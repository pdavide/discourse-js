(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("discourse-client", [], factory);
	else if(typeof exports === 'object')
		exports["discourse-client"] = factory();
	else
		root["discourse-client"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"discourse-client.js": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// The chunk loading function for additional chunks
/******/ 	// Since all referenced chunks are already included
/******/ 	// in this file, this function is empty here.
/******/ 	__webpack_require__.e = function requireEnsure() {
/******/ 		return Promise.resolve();
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonpdiscourse_client"] = window["webpackJsonpdiscourse_client"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/discourse.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@ungap/url-search-params/esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ungap/url-search-params/esm/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*! (c) Andrea Giammarchi - ISC */
var self = undefined || /* istanbul ignore next */ {};
try {
  (function (URLSearchParams, plus) {
    if (
      new URLSearchParams('q=%2B').get('q') !== plus ||
      new URLSearchParams({q: plus}).get('q') !== plus ||
      new URLSearchParams([['q', plus]]).get('q') !== plus ||
      new URLSearchParams('q=\n').toString() !== 'q=%0A' ||
      new URLSearchParams({q: ' &'}).toString() !== 'q=+%26'
    )
      throw URLSearchParams;
    self.URLSearchParams = URLSearchParams;
  }(URLSearchParams, '+'));
} catch(URLSearchParams) {
  (function (Object, String, isArray) {'use strict';
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var find = /[!'\(\)~]|%20|%00/g;
    var plus = /\+/g;
    var replace = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    var proto = {
      append: function (key, value) {
        appendTo(this._ungap, key, value);
      },
      delete: function (key) {
        delete this._ungap[key];
      },
      get: function (key) {
        return this.has(key) ? this._ungap[key][0] : null;
      },
      getAll: function (key) {
        return this.has(key) ? this._ungap[key].slice(0) : [];
      },
      has: function (key) {
        return key in this._ungap;
      },
      set: function (key, value) {
        this._ungap[key] = [String(value)];
      },
      forEach: function (callback, thisArg) {
        var self = this;
        for (var key in self._ungap)
          self._ungap[key].forEach(invoke, key);
        function invoke(value) {
          callback.call(thisArg, value, String(key), self);
        }
      },
      toJSON: function () {
        return {};
      },
      toString: function () {
        var query = [];
        for (var key in this._ungap) {
          var encoded = encode(key);
          for (var
            i = 0,
            value = this._ungap[key];
            i < value.length; i++
          ) {
            query.push(encoded + '=' + encode(value[i]));
          }
        }
        return query.join('&');
      }
    };
    for (var key in proto)
      defineProperty(URLSearchParams.prototype, key, {
        configurable: true,
        writable: true,
        value: proto[key]
      });
    self.URLSearchParams = URLSearchParams;
    function URLSearchParams(query) {
      var dict = create(null);
      defineProperty(this, '_ungap', {value: dict});
      switch (true) {
        case !query:
          break;
        case typeof query === 'string':
          if (query.charAt(0) === '?') {
            query = query.slice(1);
          }
          for (var
            pairs = query.split('&'),
            i = 0,
            length = pairs.length; i < length; i++
          ) {
            var value = pairs[i];
            var index = value.indexOf('=');
            if (-1 < index) {
              appendTo(
                dict,
                decode(value.slice(0, index)),
                decode(value.slice(index + 1))
              );
            } else if (value.length){
              appendTo(
                dict,
                decode(value),
                ''
              );
            }
          }
          break;
        case isArray(query):
          for (var
            i = 0,
            length = query.length; i < length; i++
          ) {
            var value = query[i];
            appendTo(dict, value[0], value[1]);
          }
          break;
        case 'forEach' in query:
          query.forEach(addEach, dict);
          break;
        default:
          for (var key in query)
            appendTo(dict, key, query[key]);
      }
    }

    function addEach(value, key) {
      appendTo(this, key, value);
    }
    
    function appendTo(dict, key, value) {
      var res = isArray(value) ? value.join(',') : value;
      if (key in dict)
        dict[key].push(res);
      else
        dict[key] = [res];
    }
    
    function decode(str) {
      return decodeURIComponent(str.replace(plus, ' '));
    }
    
    function encode(str) {
      return encodeURIComponent(str).replace(find, replacer);
    }

    function replacer(match) {
      return replace[match];
    }

  }(Object, String, Array.isArray));
}

(function (URLSearchParamsProto) {

  var iterable = false;
  try { iterable = !!Symbol.iterator; } catch (o_O) {}

  /* istanbul ignore else */
  if (!('forEach' in URLSearchParamsProto)) {
    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
      var self = this;
      var names = Object.create(null);
      this.toString()
          .replace(/=[\s\S]*?(?:&|$)/g, '=')
          .split('=')
          .forEach(function (name) {
            if (!name.length || name in names)
              return;
            (names[name] = self.getAll(name)).forEach(function(value) {
              callback.call(thisArg, value, name, self);
            });
          });
    };
  }

  /* istanbul ignore else */
  if (!('keys' in URLSearchParamsProto)) {
    URLSearchParamsProto.keys = function keys() {
      return iterator(this, function(value, key) { this.push(key); });
    };
  }

   /* istanbul ignore else */
  if (!('values' in URLSearchParamsProto)) {
    URLSearchParamsProto.values = function values() {
      return iterator(this, function(value, key) { this.push(value); });
    };
  }

  /* istanbul ignore else */
  if (!('entries' in URLSearchParamsProto)) {
    URLSearchParamsProto.entries = function entries() {
      return iterator(this, function(value, key) { this.push([key, value]); });
    };
  }

  /* istanbul ignore else */
  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {
    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
  }

  /* istanbul ignore else */
  if (!('sort' in URLSearchParamsProto)) {
    URLSearchParamsProto.sort = function sort() {
      var
        entries = this.entries(),
        entry = entries.next(),
        done = entry.done,
        keys = [],
        values = Object.create(null),
        i, key, value
      ;
      while (!done) {
        value = entry.value;
        key = value[0];
        keys.push(key);
        if (!(key in values)) {
          values[key] = [];
        }
        values[key].push(value[1]);
        entry = entries.next();
        done = entry.done;
      }
      // not the champion in efficiency
      // but these two bits just do the job
      keys.sort();
      for (i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        this.append(key, values[key].shift());
      }
    };
  }

  function iterator(self, callback) {
    var items = [];
    self.forEach(callback, items);
    return iterable ?
      items[Symbol.iterator]() :
      {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value};
        }
      };
  }

  /* istanbul ignore next */
  (function (Object) {
    var
      dP = Object.defineProperty,
      gOPD = Object.getOwnPropertyDescriptor,
      createSearchParamsPollute = function (search) {
        function append(name, value) {
          URLSearchParamsProto.append.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function del(name) {
          URLSearchParamsProto.delete.call(this, name);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function set(name, value) {
          URLSearchParamsProto.set.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        return function (sp, value) {
          sp.append = append;
          sp.delete = del;
          sp.set = set;
          return dP(sp, '_usp', {
            configurable: true,
            writable: true,
            value: value
          });
        };
      },
      createSearchParamsCreate = function (polluteSearchParams) {
        return function (obj, sp) {
          dP(
            obj, '_searchParams', {
              configurable: true,
              writable: true,
              value: polluteSearchParams(sp, obj)
            }
          );
          return sp;
        };
      },
      updateSearchParams = function (sp) {
        var append = sp.append;
        sp.append = URLSearchParamsProto.append;
        URLSearchParams.call(sp, sp._usp.search.slice(1));
        sp.append = append;
      },
      verifySearchParams = function (obj, Class) {
        if (!(obj instanceof Class)) throw new TypeError(
          "'searchParams' accessed on an object that " +
          "does not implement interface " + Class.name
        );
      },
      upgradeClass = function (Class) {
        var
          ClassProto = Class.prototype,
          searchParams = gOPD(ClassProto, 'searchParams'),
          href = gOPD(ClassProto, 'href'),
          search = gOPD(ClassProto, 'search'),
          createSearchParams
        ;
        if (!searchParams && search && search.set) {
          createSearchParams = createSearchParamsCreate(
            createSearchParamsPollute(search)
          );
          Object.defineProperties(
            ClassProto,
            {
              href: {
                get: function () {
                  return href.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  href.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              search: {
                get: function () {
                  return search.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  search.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              searchParams: {
                get: function () {
                  verifySearchParams(this, Class);
                  return this._searchParams || createSearchParams(
                    this,
                    new URLSearchParams(this.search.slice(1))
                  );
                },
                set: function (sp) {
                  verifySearchParams(this, Class);
                  createSearchParams(this, sp);
                }
              }
            }
          );
        }
      }
    ;
    try {
      upgradeClass(HTMLAnchorElement);
      if (/^function|object$/.test(typeof URL) && URL.prototype)
        upgradeClass(URL);
    } catch (meh) {}
  }(Object));

}(self.URLSearchParams.prototype, Object));
/* harmony default export */ __webpack_exports__["default"] = (self.URLSearchParams);


/***/ }),

/***/ "./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cacheAdapterEnhancer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buildSortedURL */ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js");
/* harmony import */ var _utils_isCacheLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/isCacheLike */ "./node_modules/axios-extensions/esm/utils/isCacheLike.js");
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-12
 */




var FIVE_MINUTES = 1000 * 60 * 5;
var CAPACITY = 100;
function cacheAdapterEnhancer(adapter, options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    var _a = options.enabledByDefault, enabledByDefault = _a === void 0 ? true : _a, _b = options.cacheFlag, cacheFlag = _b === void 0 ? 'cache' : _b, _c = options.defaultCache, defaultCache = _c === void 0 ? new lru_cache__WEBPACK_IMPORTED_MODULE_1___default.a({ maxAge: FIVE_MINUTES, max: CAPACITY }) : _c;
    return function (config) {
        var url = config.url, method = config.method, params = config.params, paramsSerializer = config.paramsSerializer, forceUpdate = config.forceUpdate;
        var useCache = (config[cacheFlag] !== void 0 && config[cacheFlag] !== null) ? config[cacheFlag] : enabledByDefault;
        if (method === 'get' && useCache) {
            // if had provide a specified cache, then use it instead
            var cache_1 = Object(_utils_isCacheLike__WEBPACK_IMPORTED_MODULE_3__["default"])(useCache) ? useCache : defaultCache;
            // build the index according to the url and params
            var index_1 = Object(_utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__["default"])(url, params, paramsSerializer);
            var responsePromise = cache_1.get(index_1);
            if (!responsePromise || forceUpdate) {
                responsePromise = (function () { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
                    var reason_1;
                    return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, adapter(config)];
                            case 1: return [2 /*return*/, _a.sent()];
                            case 2:
                                reason_1 = _a.sent();
                                cache_1.del(index_1);
                                throw reason_1;
                            case 3: return [2 /*return*/];
                        }
                    });
                }); })();
                // put the promise for the non-transformed response into cache as a placeholder
                cache_1.set(index_1, responsePromise);
                return responsePromise;
            }
            /* istanbul ignore next */
            if (process.env.LOGGER_LEVEL === 'info') {
                // eslint-disable-next-line no-console
                console.info("request cached by cache adapter: " + index_1);
            }
            return responsePromise;
        }
        return adapter(config);
    };
}
//# sourceMappingURL=cacheAdapterEnhancer.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios-extensions/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/axios-extensions/esm/index.js ***!
  \****************************************************/
/*! exports provided: Cache, cacheAdapterEnhancer, throttleAdapterEnhancer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a; });
/* harmony import */ var _cacheAdapterEnhancer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cacheAdapterEnhancer */ "./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cacheAdapterEnhancer", function() { return _cacheAdapterEnhancer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _throttleAdapterEnhancer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./throttleAdapterEnhancer */ "./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttleAdapterEnhancer", function() { return _throttleAdapterEnhancer__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-09-28
 */




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return throttleAdapterEnhancer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buildSortedURL */ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js");
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-11
 */



function throttleAdapterEnhancer(adapter, options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    var _a = options.threshold, threshold = _a === void 0 ? 1000 : _a, _b = options.cache, cache = _b === void 0 ? new lru_cache__WEBPACK_IMPORTED_MODULE_1___default.a({ max: 10 }) : _b;
    var recordCacheWithRequest = function (index, config) {
        var responsePromise = (function () { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
            var response, reason_1;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, adapter(config)];
                    case 1:
                        response = _a.sent();
                        cache.set(index, {
                            timestamp: Date.now(),
                            value: Promise.resolve(response),
                        });
                        return [2 /*return*/, response];
                    case 2:
                        reason_1 = _a.sent();
                        cache.del(index);
                        throw reason_1;
                    case 3: return [2 /*return*/];
                }
            });
        }); })();
        cache.set(index, {
            timestamp: Date.now(),
            value: responsePromise,
        });
        return responsePromise;
    };
    return function (config) {
        var url = config.url, method = config.method, params = config.params, paramsSerializer = config.paramsSerializer;
        var index = Object(_utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__["default"])(url, params, paramsSerializer);
        var now = Date.now();
        var cachedRecord = cache.get(index) || { timestamp: now };
        if (method === 'get') {
            if (now - cachedRecord.timestamp <= threshold) {
                var responsePromise = cachedRecord.value;
                if (responsePromise) {
                    /* istanbul ignore next */
                    if (process.env.LOGGER_LEVEL === 'info') {
                        // eslint-disable-next-line no-console
                        console.info("request cached by throttle adapter: " + index);
                    }
                    return responsePromise;
                }
            }
            return recordCacheWithRequest(index, config);
        }
        return adapter(config);
    };
}
//# sourceMappingURL=throttleAdapterEnhancer.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js":
/*!*******************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/utils/buildSortedURL.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return buildSortedURL; });
/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios/lib/helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-12
 */

function buildSortedURL() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var builtURL = axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0___default.a.apply(void 0, args);
    var _a = builtURL.split('?'), urlPath = _a[0], queryString = _a[1];
    if (queryString) {
        var paramsPair = queryString.split('&');
        return urlPath + "?" + paramsPair.sort().join('&');
    }
    return builtURL;
}
//# sourceMappingURL=buildSortedURL.js.map

/***/ }),

/***/ "./node_modules/axios-extensions/esm/utils/isCacheLike.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/utils/isCacheLike.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isCacheLike; });
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2018-03-19
 */
function isCacheLike(cache) {
    return !!(cache.set && cache.get && cache.del &&
        typeof cache.get === 'function' && typeof cache.set === 'function' && typeof cache.del === 'function');
}
//# sourceMappingURL=isCacheLike.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(/*! ./../helpers/btoa */ "./node_modules/axios/lib/helpers/btoa.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ( true &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
var isAbsoluteURL = __webpack_require__(/*! ./../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ./../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/btoa.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/btoa.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_advance-string-index.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_advance-string-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-instance.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_an-instance.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-copy-within.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-copy-within.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-fill.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_array-fill.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-methods.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-methods.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-reduce.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_array-reduce.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-constructor.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-create.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-create.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_classof.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_fix-re-wks.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_fix-re-wks.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ./es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_flags.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_flags.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_for-of.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_for-of.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_inherit-if-required.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_inherit-if-required.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_invoke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-regexp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-regexp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-call.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-detect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-step.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iterators.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/modules/_meta.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_meta.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/modules/_microtask.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_microtask.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_new-promise-capability.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/_new-promise-capability.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-create.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dps.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gops.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gpo.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-sap.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-sap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_perform.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_perform.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_promise-resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_promise-resolve.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "./node_modules/core-js/modules/_same-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_same-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_set-proto.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_set-proto.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "./node_modules/core-js/modules/_set-species.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_set-species.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/modules/_species-constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_species-constructor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_strict-method.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_strict-method.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-at.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_task.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_task.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");
var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-index.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_to-index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/modules/_typed-array.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-array.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
  var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");
  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");
  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
  var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");
  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");
  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js");
  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");
  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");
  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");
  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js");
  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/modules/_typed-buffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-buffer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "./node_modules/core-js/modules/_typed.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_typed.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_user-agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_user-agent.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "./node_modules/core-js/modules/_wks-define.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-define.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");
var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_wks-ext.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-ext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");


/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.filter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.for-each.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.for-each.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);
var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.index-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.index-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.is-array.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.is-array.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', { isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.map.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.now.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.now.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.name.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-property.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.promise.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;
var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();
var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);
__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(PROMISE);
Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");
var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('RegExp');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.exec.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.exec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");
__webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.flags.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.flags.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js")
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.match.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.match.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

// @@match logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.replace.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.replace.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return ch;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return ch;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return ch;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.search.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.search.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var sameValue = __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js");
var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

// @@search logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.split.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.split.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");
var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';

// eslint-disable-next-line no-empty
var SUPPORTS_Y = !!(function () { try { return new RegExp('x', 'y'); } catch (e) {} })();

// @@split logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? 0xffffffff : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ./es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").KEY;
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");
var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js");
var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/modules/_enum-keys.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.data-view.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.data-view.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js").DataView
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom.iterable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jsencrypt/bin/jsencrypt.js":
/*!*************************************************!*\
  !*** ./node_modules/jsencrypt/bin/jsencrypt.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
function int2char(n) {
    return BI_RM.charAt(n);
}
//#region BIT_OPERATIONS
// (public) this & a
function op_and(x, y) {
    return x & y;
}
// (public) this | a
function op_or(x, y) {
    return x | y;
}
// (public) this ^ a
function op_xor(x, y) {
    return x ^ y;
}
// (public) this & ~a
function op_andnot(x, y) {
    return x & ~y;
}
// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
    if (x == 0) {
        return -1;
    }
    var r = 0;
    if ((x & 0xffff) == 0) {
        x >>= 16;
        r += 16;
    }
    if ((x & 0xff) == 0) {
        x >>= 8;
        r += 8;
    }
    if ((x & 0xf) == 0) {
        x >>= 4;
        r += 4;
    }
    if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
    }
    if ((x & 1) == 0) {
        ++r;
    }
    return r;
}
// return number of 1 bits in x
function cbit(x) {
    var r = 0;
    while (x != 0) {
        x &= x - 1;
        ++r;
    }
    return r;
}
//#endregion BIT_OPERATIONS

var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";
function hex2b64(h) {
    var i;
    var c;
    var ret = "";
    for (i = 0; i + 3 <= h.length; i += 3) {
        c = parseInt(h.substring(i, i + 3), 16);
        ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
    }
    if (i + 1 == h.length) {
        c = parseInt(h.substring(i, i + 1), 16);
        ret += b64map.charAt(c << 2);
    }
    else if (i + 2 == h.length) {
        c = parseInt(h.substring(i, i + 2), 16);
        ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
    }
    while ((ret.length & 3) > 0) {
        ret += b64pad;
    }
    return ret;
}
// convert a base64 string to hex
function b64tohex(s) {
    var ret = "";
    var i;
    var k = 0; // b64 state, 0-3
    var slop = 0;
    for (i = 0; i < s.length; ++i) {
        if (s.charAt(i) == b64pad) {
            break;
        }
        var v = b64map.indexOf(s.charAt(i));
        if (v < 0) {
            continue;
        }
        if (k == 0) {
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 1;
        }
        else if (k == 1) {
            ret += int2char((slop << 2) | (v >> 4));
            slop = v & 0xf;
            k = 2;
        }
        else if (k == 2) {
            ret += int2char(slop);
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 3;
        }
        else {
            ret += int2char((slop << 2) | (v >> 4));
            ret += int2char(v & 0xf);
            k = 0;
        }
    }
    if (k == 1) {
        ret += int2char(slop << 2);
    }
    return ret;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// Hex JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder;
var Hex = {
    decode: function (a) {
        var i;
        if (decoder === undefined) {
            var hex = "0123456789ABCDEF";
            var ignore = " \f\n\r\t\u00A0\u2028\u2029";
            decoder = {};
            for (i = 0; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            hex = hex.toLowerCase();
            for (i = 10; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 2) {
                out[out.length] = bits;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 4;
            }
        }
        if (char_count) {
            throw new Error("Hex encoding incomplete: 4 bits missing");
        }
        return out;
    }
};

// Base64 JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder$1;
var Base64 = {
    decode: function (a) {
        var i;
        if (decoder$1 === undefined) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var ignore = "= \f\n\r\t\u00A0\u2028\u2029";
            decoder$1 = Object.create(null);
            for (i = 0; i < 64; ++i) {
                decoder$1[b64.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder$1[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder$1[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 4) {
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                out[out.length] = bits & 0xFF;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 6;
            }
        }
        switch (char_count) {
            case 1:
                throw new Error("Base64 encoding incomplete: at least 2 bits missing");
            case 2:
                out[out.length] = (bits >> 10);
                break;
            case 3:
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                break;
        }
        return out;
    },
    re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
    unarmor: function (a) {
        var m = Base64.re.exec(a);
        if (m) {
            if (m[1]) {
                a = m[1];
            }
            else if (m[2]) {
                a = m[2];
            }
            else {
                throw new Error("RegExp out of sync");
            }
        }
        return Base64.decode(a);
    }
};

// Big integer base-10 printing library
// Copyright (c) 2014 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var max = 10000000000000; // biggest integer that can still fit 2^53 when multiplied by 256
var Int10 = /** @class */ (function () {
    function Int10(value) {
        this.buf = [+value || 0];
    }
    Int10.prototype.mulAdd = function (m, c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] * m + c;
            if (t < max) {
                c = 0;
            }
            else {
                c = 0 | (t / max);
                t -= c * max;
            }
            b[i] = t;
        }
        if (c > 0) {
            b[i] = c;
        }
    };
    Int10.prototype.sub = function (c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] - c;
            if (t < 0) {
                t += max;
                c = 1;
            }
            else {
                c = 0;
            }
            b[i] = t;
        }
        while (b[b.length - 1] === 0) {
            b.pop();
        }
    };
    Int10.prototype.toString = function (base) {
        if ((base || 10) != 10) {
            throw new Error("only base 10 is supported");
        }
        var b = this.buf;
        var s = b[b.length - 1].toString();
        for (var i = b.length - 2; i >= 0; --i) {
            s += (max + b[i]).toString().substring(1);
        }
        return s;
    };
    Int10.prototype.valueOf = function () {
        var b = this.buf;
        var v = 0;
        for (var i = b.length - 1; i >= 0; --i) {
            v = v * max + b[i];
        }
        return v;
    };
    Int10.prototype.simplify = function () {
        var b = this.buf;
        return (b.length == 1) ? b[0] : this;
    };
    return Int10;
}());

// ASN.1 JavaScript decoder
var ellipsis = "\u2026";
var reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
var reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
function stringCut(str, len) {
    if (str.length > len) {
        str = str.substring(0, len) + ellipsis;
    }
    return str;
}
var Stream = /** @class */ (function () {
    function Stream(enc, pos) {
        this.hexDigits = "0123456789ABCDEF";
        if (enc instanceof Stream) {
            this.enc = enc.enc;
            this.pos = enc.pos;
        }
        else {
            // enc should be an array or a binary string
            this.enc = enc;
            this.pos = pos;
        }
    }
    Stream.prototype.get = function (pos) {
        if (pos === undefined) {
            pos = this.pos++;
        }
        if (pos >= this.enc.length) {
            throw new Error("Requesting byte offset " + pos + " on a stream of length " + this.enc.length);
        }
        return ("string" === typeof this.enc) ? this.enc.charCodeAt(pos) : this.enc[pos];
    };
    Stream.prototype.hexByte = function (b) {
        return this.hexDigits.charAt((b >> 4) & 0xF) + this.hexDigits.charAt(b & 0xF);
    };
    Stream.prototype.hexDump = function (start, end, raw) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
            if (raw !== true) {
                switch (i & 0xF) {
                    case 0x7:
                        s += "  ";
                        break;
                    case 0xF:
                        s += "\n";
                        break;
                    default:
                        s += " ";
                }
            }
        }
        return s;
    };
    Stream.prototype.isASCII = function (start, end) {
        for (var i = start; i < end; ++i) {
            var c = this.get(i);
            if (c < 32 || c > 176) {
                return false;
            }
        }
        return true;
    };
    Stream.prototype.parseStringISO = function (start, end) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += String.fromCharCode(this.get(i));
        }
        return s;
    };
    Stream.prototype.parseStringUTF = function (start, end) {
        var s = "";
        for (var i = start; i < end;) {
            var c = this.get(i++);
            if (c < 128) {
                s += String.fromCharCode(c);
            }
            else if ((c > 191) && (c < 224)) {
                s += String.fromCharCode(((c & 0x1F) << 6) | (this.get(i++) & 0x3F));
            }
            else {
                s += String.fromCharCode(((c & 0x0F) << 12) | ((this.get(i++) & 0x3F) << 6) | (this.get(i++) & 0x3F));
            }
        }
        return s;
    };
    Stream.prototype.parseStringBMP = function (start, end) {
        var str = "";
        var hi;
        var lo;
        for (var i = start; i < end;) {
            hi = this.get(i++);
            lo = this.get(i++);
            str += String.fromCharCode((hi << 8) | lo);
        }
        return str;
    };
    Stream.prototype.parseTime = function (start, end, shortYear) {
        var s = this.parseStringISO(start, end);
        var m = (shortYear ? reTimeS : reTimeL).exec(s);
        if (!m) {
            return "Unrecognized time: " + s;
        }
        if (shortYear) {
            // to avoid querying the timer, use the fixed range [1970, 2069]
            // it will conform with ITU X.400 [-10, +40] sliding window until 2030
            m[1] = +m[1];
            m[1] += (+m[1] < 70) ? 2000 : 1900;
        }
        s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];
        if (m[5]) {
            s += ":" + m[5];
            if (m[6]) {
                s += ":" + m[6];
                if (m[7]) {
                    s += "." + m[7];
                }
            }
        }
        if (m[8]) {
            s += " UTC";
            if (m[8] != "Z") {
                s += m[8];
                if (m[9]) {
                    s += ":" + m[9];
                }
            }
        }
        return s;
    };
    Stream.prototype.parseInteger = function (start, end) {
        var v = this.get(start);
        var neg = (v > 127);
        var pad = neg ? 255 : 0;
        var len;
        var s = "";
        // skip unuseful bits (not allowed in DER)
        while (v == pad && ++start < end) {
            v = this.get(start);
        }
        len = end - start;
        if (len === 0) {
            return neg ? -1 : 0;
        }
        // show bit length of huge integers
        if (len > 4) {
            s = v;
            len <<= 3;
            while (((+s ^ pad) & 0x80) == 0) {
                s = +s << 1;
                --len;
            }
            s = "(" + len + " bit)\n";
        }
        // decode the integer
        if (neg) {
            v = v - 256;
        }
        var n = new Int10(v);
        for (var i = start + 1; i < end; ++i) {
            n.mulAdd(256, this.get(i));
        }
        return s + n.toString();
    };
    Stream.prototype.parseBitString = function (start, end, maxLength) {
        var unusedBit = this.get(start);
        var lenBit = ((end - start - 1) << 3) - unusedBit;
        var intro = "(" + lenBit + " bit)\n";
        var s = "";
        for (var i = start + 1; i < end; ++i) {
            var b = this.get(i);
            var skip = (i == end - 1) ? unusedBit : 0;
            for (var j = 7; j >= skip; --j) {
                s += (b >> j) & 1 ? "1" : "0";
            }
            if (s.length > maxLength) {
                return intro + stringCut(s, maxLength);
            }
        }
        return intro + s;
    };
    Stream.prototype.parseOctetString = function (start, end, maxLength) {
        if (this.isASCII(start, end)) {
            return stringCut(this.parseStringISO(start, end), maxLength);
        }
        var len = end - start;
        var s = "(" + len + " byte)\n";
        maxLength /= 2; // we work in bytes
        if (len > maxLength) {
            end = start + maxLength;
        }
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
        }
        if (len > maxLength) {
            s += ellipsis;
        }
        return s;
    };
    Stream.prototype.parseOID = function (start, end, maxLength) {
        var s = "";
        var n = new Int10();
        var bits = 0;
        for (var i = start; i < end; ++i) {
            var v = this.get(i);
            n.mulAdd(128, v & 0x7F);
            bits += 7;
            if (!(v & 0x80)) { // finished
                if (s === "") {
                    n = n.simplify();
                    if (n instanceof Int10) {
                        n.sub(80);
                        s = "2." + n.toString();
                    }
                    else {
                        var m = n < 80 ? n < 40 ? 0 : 1 : 2;
                        s = m + "." + (n - m * 40);
                    }
                }
                else {
                    s += "." + n.toString();
                }
                if (s.length > maxLength) {
                    return stringCut(s, maxLength);
                }
                n = new Int10();
                bits = 0;
            }
        }
        if (bits > 0) {
            s += ".incomplete";
        }
        return s;
    };
    return Stream;
}());
var ASN1 = /** @class */ (function () {
    function ASN1(stream, header, length, tag, sub) {
        if (!(tag instanceof ASN1Tag)) {
            throw new Error("Invalid tag value.");
        }
        this.stream = stream;
        this.header = header;
        this.length = length;
        this.tag = tag;
        this.sub = sub;
    }
    ASN1.prototype.typeName = function () {
        switch (this.tag.tagClass) {
            case 0: // universal
                switch (this.tag.tagNumber) {
                    case 0x00:
                        return "EOC";
                    case 0x01:
                        return "BOOLEAN";
                    case 0x02:
                        return "INTEGER";
                    case 0x03:
                        return "BIT_STRING";
                    case 0x04:
                        return "OCTET_STRING";
                    case 0x05:
                        return "NULL";
                    case 0x06:
                        return "OBJECT_IDENTIFIER";
                    case 0x07:
                        return "ObjectDescriptor";
                    case 0x08:
                        return "EXTERNAL";
                    case 0x09:
                        return "REAL";
                    case 0x0A:
                        return "ENUMERATED";
                    case 0x0B:
                        return "EMBEDDED_PDV";
                    case 0x0C:
                        return "UTF8String";
                    case 0x10:
                        return "SEQUENCE";
                    case 0x11:
                        return "SET";
                    case 0x12:
                        return "NumericString";
                    case 0x13:
                        return "PrintableString"; // ASCII subset
                    case 0x14:
                        return "TeletexString"; // aka T61String
                    case 0x15:
                        return "VideotexString";
                    case 0x16:
                        return "IA5String"; // ASCII
                    case 0x17:
                        return "UTCTime";
                    case 0x18:
                        return "GeneralizedTime";
                    case 0x19:
                        return "GraphicString";
                    case 0x1A:
                        return "VisibleString"; // ASCII subset
                    case 0x1B:
                        return "GeneralString";
                    case 0x1C:
                        return "UniversalString";
                    case 0x1E:
                        return "BMPString";
                }
                return "Universal_" + this.tag.tagNumber.toString();
            case 1:
                return "Application_" + this.tag.tagNumber.toString();
            case 2:
                return "[" + this.tag.tagNumber.toString() + "]"; // Context
            case 3:
                return "Private_" + this.tag.tagNumber.toString();
        }
    };
    ASN1.prototype.content = function (maxLength) {
        if (this.tag === undefined) {
            return null;
        }
        if (maxLength === undefined) {
            maxLength = Infinity;
        }
        var content = this.posContent();
        var len = Math.abs(this.length);
        if (!this.tag.isUniversal()) {
            if (this.sub !== null) {
                return "(" + this.sub.length + " elem)";
            }
            return this.stream.parseOctetString(content, content + len, maxLength);
        }
        switch (this.tag.tagNumber) {
            case 0x01: // BOOLEAN
                return (this.stream.get(content) === 0) ? "false" : "true";
            case 0x02: // INTEGER
                return this.stream.parseInteger(content, content + len);
            case 0x03: // BIT_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseBitString(content, content + len, maxLength);
            case 0x04: // OCTET_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseOctetString(content, content + len, maxLength);
            // case 0x05: // NULL
            case 0x06: // OBJECT_IDENTIFIER
                return this.stream.parseOID(content, content + len, maxLength);
            // case 0x07: // ObjectDescriptor
            // case 0x08: // EXTERNAL
            // case 0x09: // REAL
            // case 0x0A: // ENUMERATED
            // case 0x0B: // EMBEDDED_PDV
            case 0x10: // SEQUENCE
            case 0x11: // SET
                if (this.sub !== null) {
                    return "(" + this.sub.length + " elem)";
                }
                else {
                    return "(no elem)";
                }
            case 0x0C: // UTF8String
                return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);
            case 0x12: // NumericString
            case 0x13: // PrintableString
            case 0x14: // TeletexString
            case 0x15: // VideotexString
            case 0x16: // IA5String
            // case 0x19: // GraphicString
            case 0x1A: // VisibleString
                // case 0x1B: // GeneralString
                // case 0x1C: // UniversalString
                return stringCut(this.stream.parseStringISO(content, content + len), maxLength);
            case 0x1E: // BMPString
                return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);
            case 0x17: // UTCTime
            case 0x18: // GeneralizedTime
                return this.stream.parseTime(content, content + len, (this.tag.tagNumber == 0x17));
        }
        return null;
    };
    ASN1.prototype.toString = function () {
        return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + ((this.sub === null) ? "null" : this.sub.length) + "]";
    };
    ASN1.prototype.toPrettyString = function (indent) {
        if (indent === undefined) {
            indent = "";
        }
        var s = indent + this.typeName() + " @" + this.stream.pos;
        if (this.length >= 0) {
            s += "+";
        }
        s += this.length;
        if (this.tag.tagConstructed) {
            s += " (constructed)";
        }
        else if ((this.tag.isUniversal() && ((this.tag.tagNumber == 0x03) || (this.tag.tagNumber == 0x04))) && (this.sub !== null)) {
            s += " (encapsulates)";
        }
        s += "\n";
        if (this.sub !== null) {
            indent += "  ";
            for (var i = 0, max = this.sub.length; i < max; ++i) {
                s += this.sub[i].toPrettyString(indent);
            }
        }
        return s;
    };
    ASN1.prototype.posStart = function () {
        return this.stream.pos;
    };
    ASN1.prototype.posContent = function () {
        return this.stream.pos + this.header;
    };
    ASN1.prototype.posEnd = function () {
        return this.stream.pos + this.header + Math.abs(this.length);
    };
    ASN1.prototype.toHexString = function () {
        return this.stream.hexDump(this.posStart(), this.posEnd(), true);
    };
    ASN1.decodeLength = function (stream) {
        var buf = stream.get();
        var len = buf & 0x7F;
        if (len == buf) {
            return len;
        }
        // no reason to use Int10, as it would be a huge buffer anyways
        if (len > 6) {
            throw new Error("Length over 48 bits not supported at position " + (stream.pos - 1));
        }
        if (len === 0) {
            return null;
        } // undefined
        buf = 0;
        for (var i = 0; i < len; ++i) {
            buf = (buf * 256) + stream.get();
        }
        return buf;
    };
    /**
     * Retrieve the hexadecimal value (as a string) of the current ASN.1 element
     * @returns {string}
     * @public
     */
    ASN1.prototype.getHexStringValue = function () {
        var hexString = this.toHexString();
        var offset = this.header * 2;
        var length = this.length * 2;
        return hexString.substr(offset, length);
    };
    ASN1.decode = function (str) {
        var stream;
        if (!(str instanceof Stream)) {
            stream = new Stream(str, 0);
        }
        else {
            stream = str;
        }
        var streamStart = new Stream(stream);
        var tag = new ASN1Tag(stream);
        var len = ASN1.decodeLength(stream);
        var start = stream.pos;
        var header = start - streamStart.pos;
        var sub = null;
        var getSub = function () {
            var ret = [];
            if (len !== null) {
                // definite length
                var end = start + len;
                while (stream.pos < end) {
                    ret[ret.length] = ASN1.decode(stream);
                }
                if (stream.pos != end) {
                    throw new Error("Content size is not correct for container starting at offset " + start);
                }
            }
            else {
                // undefined length
                try {
                    for (;;) {
                        var s = ASN1.decode(stream);
                        if (s.tag.isEOC()) {
                            break;
                        }
                        ret[ret.length] = s;
                    }
                    len = start - stream.pos; // undefined lengths are represented as negative values
                }
                catch (e) {
                    throw new Error("Exception while decoding undefined length content: " + e);
                }
            }
            return ret;
        };
        if (tag.tagConstructed) {
            // must have valid content
            sub = getSub();
        }
        else if (tag.isUniversal() && ((tag.tagNumber == 0x03) || (tag.tagNumber == 0x04))) {
            // sometimes BitString and OctetString are used to encapsulate ASN.1
            try {
                if (tag.tagNumber == 0x03) {
                    if (stream.get() != 0) {
                        throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
                    }
                }
                sub = getSub();
                for (var i = 0; i < sub.length; ++i) {
                    if (sub[i].tag.isEOC()) {
                        throw new Error("EOC is not supposed to be actual content.");
                    }
                }
            }
            catch (e) {
                // but silently ignore when they don't
                sub = null;
            }
        }
        if (sub === null) {
            if (len === null) {
                throw new Error("We can't skip over an invalid tag with undefined length at offset " + start);
            }
            stream.pos = start + Math.abs(len);
        }
        return new ASN1(streamStart, header, len, tag, sub);
    };
    return ASN1;
}());
var ASN1Tag = /** @class */ (function () {
    function ASN1Tag(stream) {
        var buf = stream.get();
        this.tagClass = buf >> 6;
        this.tagConstructed = ((buf & 0x20) !== 0);
        this.tagNumber = buf & 0x1F;
        if (this.tagNumber == 0x1F) { // long tag
            var n = new Int10();
            do {
                buf = stream.get();
                n.mulAdd(128, buf & 0x7F);
            } while (buf & 0x80);
            this.tagNumber = n.simplify();
        }
    }
    ASN1Tag.prototype.isUniversal = function () {
        return this.tagClass === 0x00;
    };
    ASN1Tag.prototype.isEOC = function () {
        return this.tagClass === 0x00 && this.tagNumber === 0x00;
    };
    return ASN1Tag;
}());

// Copyright (c) 2005  Tom Wu
// Bits per digit
var dbits;
// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary & 0xffffff) == 0xefcafe);
//#region
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
//#endregion
// (public) Constructor
var BigInteger = /** @class */ (function () {
    function BigInteger(a, b, c) {
        if (a != null) {
            if ("number" == typeof a) {
                this.fromNumber(a, b, c);
            }
            else if (b == null && "string" != typeof a) {
                this.fromString(a, 256);
            }
            else {
                this.fromString(a, b);
            }
        }
    }
    //#region PUBLIC
    // BigInteger.prototype.toString = bnToString;
    // (public) return string representation in given radix
    BigInteger.prototype.toString = function (b) {
        if (this.s < 0) {
            return "-" + this.negate().toString(b);
        }
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            return this.toRadix(b);
        }
        var km = (1 << k) - 1;
        var d;
        var m = false;
        var r = "";
        var i = this.t;
        var p = this.DB - (i * this.DB) % k;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
                m = true;
                r = int2char(d);
            }
            while (i >= 0) {
                if (p < k) {
                    d = (this[i] & ((1 << p) - 1)) << (k - p);
                    d |= this[--i] >> (p += this.DB - k);
                }
                else {
                    d = (this[i] >> (p -= k)) & km;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if (d > 0) {
                    m = true;
                }
                if (m) {
                    r += int2char(d);
                }
            }
        }
        return m ? r : "0";
    };
    // BigInteger.prototype.negate = bnNegate;
    // (public) -this
    BigInteger.prototype.negate = function () {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
    };
    // BigInteger.prototype.abs = bnAbs;
    // (public) |this|
    BigInteger.prototype.abs = function () {
        return (this.s < 0) ? this.negate() : this;
    };
    // BigInteger.prototype.compareTo = bnCompareTo;
    // (public) return + if this > a, - if this < a, 0 if equal
    BigInteger.prototype.compareTo = function (a) {
        var r = this.s - a.s;
        if (r != 0) {
            return r;
        }
        var i = this.t;
        r = i - a.t;
        if (r != 0) {
            return (this.s < 0) ? -r : r;
        }
        while (--i >= 0) {
            if ((r = this[i] - a[i]) != 0) {
                return r;
            }
        }
        return 0;
    };
    // BigInteger.prototype.bitLength = bnBitLength;
    // (public) return the number of bits in "this"
    BigInteger.prototype.bitLength = function () {
        if (this.t <= 0) {
            return 0;
        }
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
    };
    // BigInteger.prototype.mod = bnMod;
    // (public) this mod a
    BigInteger.prototype.mod = function (a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            a.subTo(r, r);
        }
        return r;
    };
    // BigInteger.prototype.modPowInt = bnModPowInt;
    // (public) this^e % m, 0 <= e < 2^32
    BigInteger.prototype.modPowInt = function (e, m) {
        var z;
        if (e < 256 || m.isEven()) {
            z = new Classic(m);
        }
        else {
            z = new Montgomery(m);
        }
        return this.exp(e, z);
    };
    // BigInteger.prototype.clone = bnClone;
    // (public)
    BigInteger.prototype.clone = function () {
        var r = nbi();
        this.copyTo(r);
        return r;
    };
    // BigInteger.prototype.intValue = bnIntValue;
    // (public) return value as integer
    BigInteger.prototype.intValue = function () {
        if (this.s < 0) {
            if (this.t == 1) {
                return this[0] - this.DV;
            }
            else if (this.t == 0) {
                return -1;
            }
        }
        else if (this.t == 1) {
            return this[0];
        }
        else if (this.t == 0) {
            return 0;
        }
        // assumes 16 < DB < 32
        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
    };
    // BigInteger.prototype.byteValue = bnByteValue;
    // (public) return value as byte
    BigInteger.prototype.byteValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
    };
    // BigInteger.prototype.shortValue = bnShortValue;
    // (public) return value as short (assumes DB>=16)
    BigInteger.prototype.shortValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
    };
    // BigInteger.prototype.signum = bnSigNum;
    // (public) 0 if this == 0, 1 if this > 0
    BigInteger.prototype.signum = function () {
        if (this.s < 0) {
            return -1;
        }
        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {
            return 0;
        }
        else {
            return 1;
        }
    };
    // BigInteger.prototype.toByteArray = bnToByteArray;
    // (public) convert to bigendian byte array
    BigInteger.prototype.toByteArray = function () {
        var i = this.t;
        var r = [];
        r[0] = this.s;
        var p = this.DB - (i * this.DB) % 8;
        var d;
        var k = 0;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {
                r[k++] = d | (this.s << (this.DB - p));
            }
            while (i >= 0) {
                if (p < 8) {
                    d = (this[i] & ((1 << p) - 1)) << (8 - p);
                    d |= this[--i] >> (p += this.DB - 8);
                }
                else {
                    d = (this[i] >> (p -= 8)) & 0xff;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if ((d & 0x80) != 0) {
                    d |= -256;
                }
                if (k == 0 && (this.s & 0x80) != (d & 0x80)) {
                    ++k;
                }
                if (k > 0 || d != this.s) {
                    r[k++] = d;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.equals = function (a) {
        return (this.compareTo(a) == 0);
    };
    // BigInteger.prototype.min = bnMin;
    BigInteger.prototype.min = function (a) {
        return (this.compareTo(a) < 0) ? this : a;
    };
    // BigInteger.prototype.max = bnMax;
    BigInteger.prototype.max = function (a) {
        return (this.compareTo(a) > 0) ? this : a;
    };
    // BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.and = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
    };
    // BigInteger.prototype.or = bnOr;
    BigInteger.prototype.or = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
    };
    // BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.xor = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
    };
    // BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.andNot = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
    };
    // BigInteger.prototype.not = bnNot;
    // (public) ~this
    BigInteger.prototype.not = function () {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) {
            r[i] = this.DM & ~this[i];
        }
        r.t = this.t;
        r.s = ~this.s;
        return r;
    };
    // BigInteger.prototype.shiftLeft = bnShiftLeft;
    // (public) this << n
    BigInteger.prototype.shiftLeft = function (n) {
        var r = nbi();
        if (n < 0) {
            this.rShiftTo(-n, r);
        }
        else {
            this.lShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.shiftRight = bnShiftRight;
    // (public) this >> n
    BigInteger.prototype.shiftRight = function (n) {
        var r = nbi();
        if (n < 0) {
            this.lShiftTo(-n, r);
        }
        else {
            this.rShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    // (public) returns index of lowest 1-bit (or -1 if none)
    BigInteger.prototype.getLowestSetBit = function () {
        for (var i = 0; i < this.t; ++i) {
            if (this[i] != 0) {
                return i * this.DB + lbit(this[i]);
            }
        }
        if (this.s < 0) {
            return this.t * this.DB;
        }
        return -1;
    };
    // BigInteger.prototype.bitCount = bnBitCount;
    // (public) return number of set bits
    BigInteger.prototype.bitCount = function () {
        var r = 0;
        var x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) {
            r += cbit(this[i] ^ x);
        }
        return r;
    };
    // BigInteger.prototype.testBit = bnTestBit;
    // (public) true iff nth bit is set
    BigInteger.prototype.testBit = function (n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) {
            return (this.s != 0);
        }
        return ((this[j] & (1 << (n % this.DB))) != 0);
    };
    // BigInteger.prototype.setBit = bnSetBit;
    // (public) this | (1<<n)
    BigInteger.prototype.setBit = function (n) {
        return this.changeBit(n, op_or);
    };
    // BigInteger.prototype.clearBit = bnClearBit;
    // (public) this & ~(1<<n)
    BigInteger.prototype.clearBit = function (n) {
        return this.changeBit(n, op_andnot);
    };
    // BigInteger.prototype.flipBit = bnFlipBit;
    // (public) this ^ (1<<n)
    BigInteger.prototype.flipBit = function (n) {
        return this.changeBit(n, op_xor);
    };
    // BigInteger.prototype.add = bnAdd;
    // (public) this + a
    BigInteger.prototype.add = function (a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
    };
    // BigInteger.prototype.subtract = bnSubtract;
    // (public) this - a
    BigInteger.prototype.subtract = function (a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
    };
    // BigInteger.prototype.multiply = bnMultiply;
    // (public) this * a
    BigInteger.prototype.multiply = function (a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
    };
    // BigInteger.prototype.divide = bnDivide;
    // (public) this / a
    BigInteger.prototype.divide = function (a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
    };
    // BigInteger.prototype.remainder = bnRemainder;
    // (public) this % a
    BigInteger.prototype.remainder = function (a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
    };
    // BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    // (public) [this/a,this%a]
    BigInteger.prototype.divideAndRemainder = function (a) {
        var q = nbi();
        var r = nbi();
        this.divRemTo(a, q, r);
        return [q, r];
    };
    // BigInteger.prototype.modPow = bnModPow;
    // (public) this^e % m (HAC 14.85)
    BigInteger.prototype.modPow = function (e, m) {
        var i = e.bitLength();
        var k;
        var r = nbv(1);
        var z;
        if (i <= 0) {
            return r;
        }
        else if (i < 18) {
            k = 1;
        }
        else if (i < 48) {
            k = 3;
        }
        else if (i < 144) {
            k = 4;
        }
        else if (i < 768) {
            k = 5;
        }
        else {
            k = 6;
        }
        if (i < 8) {
            z = new Classic(m);
        }
        else if (m.isEven()) {
            z = new Barrett(m);
        }
        else {
            z = new Montgomery(m);
        }
        // precomputation
        var g = [];
        var n = 3;
        var k1 = k - 1;
        var km = (1 << k) - 1;
        g[1] = z.convert(this);
        if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
                g[n] = nbi();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
            }
        }
        var j = e.t - 1;
        var w;
        var is1 = true;
        var r2 = nbi();
        var t;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
            if (i >= k1) {
                w = (e[j] >> (i - k1)) & km;
            }
            else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0) {
                    w |= e[j - 1] >> (this.DB + i - k1);
                }
            }
            n = k;
            while ((w & 1) == 0) {
                w >>= 1;
                --n;
            }
            if ((i -= n) < 0) {
                i += this.DB;
                --j;
            }
            if (is1) { // ret == 1, don't bother squaring or multiplying it
                g[w].copyTo(r);
                is1 = false;
            }
            else {
                while (n > 1) {
                    z.sqrTo(r, r2);
                    z.sqrTo(r2, r);
                    n -= 2;
                }
                if (n > 0) {
                    z.sqrTo(r, r2);
                }
                else {
                    t = r;
                    r = r2;
                    r2 = t;
                }
                z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2);
                t = r;
                r = r2;
                r2 = t;
                if (--i < 0) {
                    i = this.DB - 1;
                    --j;
                }
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.modInverse = bnModInverse;
    // (public) 1/this % m (HAC 14.61)
    BigInteger.prototype.modInverse = function (m) {
        var ac = m.isEven();
        if ((this.isEven() && ac) || m.signum() == 0) {
            return BigInteger.ZERO;
        }
        var u = m.clone();
        var v = this.clone();
        var a = nbv(1);
        var b = nbv(0);
        var c = nbv(0);
        var d = nbv(1);
        while (u.signum() != 0) {
            while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                    if (!a.isEven() || !b.isEven()) {
                        a.addTo(this, a);
                        b.subTo(m, b);
                    }
                    a.rShiftTo(1, a);
                }
                else if (!b.isEven()) {
                    b.subTo(m, b);
                }
                b.rShiftTo(1, b);
            }
            while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                    if (!c.isEven() || !d.isEven()) {
                        c.addTo(this, c);
                        d.subTo(m, d);
                    }
                    c.rShiftTo(1, c);
                }
                else if (!d.isEven()) {
                    d.subTo(m, d);
                }
                d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac) {
                    a.subTo(c, a);
                }
                b.subTo(d, b);
            }
            else {
                v.subTo(u, v);
                if (ac) {
                    c.subTo(a, c);
                }
                d.subTo(b, d);
            }
        }
        if (v.compareTo(BigInteger.ONE) != 0) {
            return BigInteger.ZERO;
        }
        if (d.compareTo(m) >= 0) {
            return d.subtract(m);
        }
        if (d.signum() < 0) {
            d.addTo(m, d);
        }
        else {
            return d;
        }
        if (d.signum() < 0) {
            return d.add(m);
        }
        else {
            return d;
        }
    };
    // BigInteger.prototype.pow = bnPow;
    // (public) this^e
    BigInteger.prototype.pow = function (e) {
        return this.exp(e, new NullExp());
    };
    // BigInteger.prototype.gcd = bnGCD;
    // (public) gcd(this,a) (HAC 14.54)
    BigInteger.prototype.gcd = function (a) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            return x;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
        }
        if (g > 0) {
            y.lShiftTo(g, y);
        }
        return y;
    };
    // BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    // (public) test primality with certainty >= 1-.5^t
    BigInteger.prototype.isProbablePrime = function (t) {
        var i;
        var x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i) {
                if (x[0] == lowprimes[i]) {
                    return true;
                }
            }
            return false;
        }
        if (x.isEven()) {
            return false;
        }
        i = 1;
        while (i < lowprimes.length) {
            var m = lowprimes[i];
            var j = i + 1;
            while (j < lowprimes.length && m < lplim) {
                m *= lowprimes[j++];
            }
            m = x.modInt(m);
            while (i < j) {
                if (m % lowprimes[i++] == 0) {
                    return false;
                }
            }
        }
        return x.millerRabin(t);
    };
    //#endregion PUBLIC
    //#region PROTECTED
    // BigInteger.prototype.copyTo = bnpCopyTo;
    // (protected) copy this to r
    BigInteger.prototype.copyTo = function (r) {
        for (var i = this.t - 1; i >= 0; --i) {
            r[i] = this[i];
        }
        r.t = this.t;
        r.s = this.s;
    };
    // BigInteger.prototype.fromInt = bnpFromInt;
    // (protected) set from integer value x, -DV <= x < DV
    BigInteger.prototype.fromInt = function (x) {
        this.t = 1;
        this.s = (x < 0) ? -1 : 0;
        if (x > 0) {
            this[0] = x;
        }
        else if (x < -1) {
            this[0] = x + this.DV;
        }
        else {
            this.t = 0;
        }
    };
    // BigInteger.prototype.fromString = bnpFromString;
    // (protected) set from string and radix
    BigInteger.prototype.fromString = function (s, b) {
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 256) {
            k = 8;
            /* byte array */
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            this.fromRadix(s, b);
            return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length;
        var mi = false;
        var sh = 0;
        while (--i >= 0) {
            var x = (k == 8) ? (+s[i]) & 0xff : intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-") {
                    mi = true;
                }
                continue;
            }
            mi = false;
            if (sh == 0) {
                this[this.t++] = x;
            }
            else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                this[this.t++] = (x >> (this.DB - sh));
            }
            else {
                this[this.t - 1] |= x << sh;
            }
            sh += k;
            if (sh >= this.DB) {
                sh -= this.DB;
            }
        }
        if (k == 8 && ((+s[0]) & 0x80) != 0) {
            this.s = -1;
            if (sh > 0) {
                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
            }
        }
        this.clamp();
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.clamp = bnpClamp;
    // (protected) clamp off excess high words
    BigInteger.prototype.clamp = function () {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) {
            --this.t;
        }
    };
    // BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    // (protected) r = this << n*DB
    BigInteger.prototype.dlShiftTo = function (n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) {
            r[i + n] = this[i];
        }
        for (i = n - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r.t = this.t + n;
        r.s = this.s;
    };
    // BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    // (protected) r = this >> n*DB
    BigInteger.prototype.drShiftTo = function (n, r) {
        for (var i = n; i < this.t; ++i) {
            r[i - n] = this[i];
        }
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
    };
    // BigInteger.prototype.lShiftTo = bnpLShiftTo;
    // (protected) r = this << n
    BigInteger.prototype.lShiftTo = function (n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB);
        var c = (this.s << bs) & this.DM;
        for (var i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = (this[i] >> cbs) | c;
            c = (this[i] & bm) << bs;
        }
        for (var i = ds - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
    };
    // BigInteger.prototype.rShiftTo = bnpRShiftTo;
    // (protected) r = this >> n
    BigInteger.prototype.rShiftTo = function (n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
            r.t = 0;
            return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) {
            r[this.t - ds - 1] |= (this.s & bm) << cbs;
        }
        r.t = this.t - ds;
        r.clamp();
    };
    // BigInteger.prototype.subTo = bnpSubTo;
    // (protected) r = this - a
    BigInteger.prototype.subTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c -= a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c -= a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c < -1) {
            r[i++] = this.DV + c;
        }
        else if (c > 0) {
            r[i++] = c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyTo = function (a, r) {
        var x = this.abs();
        var y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < y.t; ++i) {
            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        }
        r.s = 0;
        r.clamp();
        if (this.s != a.s) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.squareTo = bnpSquareTo;
    // (protected) r = this^2, r != this (HAC 14.16)
    BigInteger.prototype.squareTo = function (r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
            }
        }
        if (r.t > 0) {
            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        }
        r.s = 0;
        r.clamp();
    };
    // BigInteger.prototype.divRemTo = bnpDivRemTo;
    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    BigInteger.prototype.divRemTo = function (m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) {
            return;
        }
        var pt = this.abs();
        if (pt.t < pm.t) {
            if (q != null) {
                q.fromInt(0);
            }
            if (r != null) {
                this.copyTo(r);
            }
            return;
        }
        if (r == null) {
            r = nbi();
        }
        var y = nbi();
        var ts = this.s;
        var ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
        if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
        }
        else {
            pm.copyTo(y);
            pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) {
            return;
        }
        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt;
        var d2 = (1 << this.F1) / yt;
        var e = 1 << this.F2;
        var i = r.t;
        var j = i - ys;
        var t = (q == null) ? nbi() : q;
        y.dlShiftTo(j, t);
        if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t);
        t.subTo(y, y); // "negative" y so we can replace sub with am later
        while (y.t < ys) {
            y[y.t++] = 0;
        }
        while (--j >= 0) {
            // Estimate quotient digit
            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd) {
                    r.subTo(t, r);
                }
            }
        }
        if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) {
                BigInteger.ZERO.subTo(q, q);
            }
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) {
            r.rShiftTo(nsh, r);
        } // Denormalize remainder
        if (ts < 0) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.invDigit = bnpInvDigit;
    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    BigInteger.prototype.invDigit = function () {
        if (this.t < 1) {
            return 0;
        }
        var x = this[0];
        if ((x & 1) == 0) {
            return 0;
        }
        var y = x & 3; // y == 1/x mod 2^2
        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
        // last step - calculate inverse mod DV directly;
        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
        y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
        // we really want the negative inverse, and -DV < y < DV
        return (y > 0) ? this.DV - y : -y;
    };
    // BigInteger.prototype.isEven = bnpIsEven;
    // (protected) true iff this is even
    BigInteger.prototype.isEven = function () {
        return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
    };
    // BigInteger.prototype.exp = bnpExp;
    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    BigInteger.prototype.exp = function (e, z) {
        if (e > 0xffffffff || e < 1) {
            return BigInteger.ONE;
        }
        var r = nbi();
        var r2 = nbi();
        var g = z.convert(this);
        var i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & (1 << i)) > 0) {
                z.mulTo(r2, g, r);
            }
            else {
                var t = r;
                r = r2;
                r2 = t;
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.chunkSize = bnpChunkSize;
    // (protected) return x s.t. r^x < DV
    BigInteger.prototype.chunkSize = function (r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
    };
    // BigInteger.prototype.toRadix = bnpToRadix;
    // (protected) convert to radix string
    BigInteger.prototype.toRadix = function (b) {
        if (b == null) {
            b = 10;
        }
        if (this.signum() == 0 || b < 2 || b > 36) {
            return "0";
        }
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a);
        var y = nbi();
        var z = nbi();
        var r = "";
        this.divRemTo(d, y, z);
        while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
        }
        return z.intValue().toString(b) + r;
    };
    // BigInteger.prototype.fromRadix = bnpFromRadix;
    // (protected) convert from radix string
    BigInteger.prototype.fromRadix = function (s, b) {
        this.fromInt(0);
        if (b == null) {
            b = 10;
        }
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs);
        var mi = false;
        var j = 0;
        var w = 0;
        for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0) {
                    mi = true;
                }
                continue;
            }
            w = b * w + x;
            if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
            }
        }
        if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
        }
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.fromNumber = bnpFromNumber;
    // (protected) alternate constructor
    BigInteger.prototype.fromNumber = function (a, b, c) {
        if ("number" == typeof b) {
            // new BigInteger(int,int,RNG)
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    // force MSB set
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                } // force odd
                while (!this.isProbablePrime(b)) {
                    this.dAddOffset(2, 0);
                    if (this.bitLength() > a) {
                        this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                    }
                }
            }
        }
        else {
            // new BigInteger(int,RNG)
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    // BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    // (protected) r = this op a (bitwise)
    BigInteger.prototype.bitwiseTo = function (a, op, r) {
        var i;
        var f;
        var m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) {
            r[i] = op(this[i], a[i]);
        }
        if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) {
                r[i] = op(this[i], f);
            }
            r.t = this.t;
        }
        else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) {
                r[i] = op(f, a[i]);
            }
            r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
    };
    // BigInteger.prototype.changeBit = bnpChangeBit;
    // (protected) this op (1<<n)
    BigInteger.prototype.changeBit = function (n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
    };
    // BigInteger.prototype.addTo = bnpAddTo;
    // (protected) r = this + a
    BigInteger.prototype.addTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c += a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c > 0) {
            r[i++] = c;
        }
        else if (c < -1) {
            r[i++] = this.DV + c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.dMultiply = bnpDMultiply;
    // (protected) this *= n, this >= 0, 1 < n < DV
    BigInteger.prototype.dMultiply = function (n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
    };
    // BigInteger.prototype.dAddOffset = bnpDAddOffset;
    // (protected) this += n << w words, this >= 0
    BigInteger.prototype.dAddOffset = function (n, w) {
        if (n == 0) {
            return;
        }
        while (this.t <= w) {
            this[this.t++] = 0;
        }
        this[w] += n;
        while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) {
                this[this.t++] = 0;
            }
            ++this[w];
        }
    };
    // BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0; // assumes a,this >= 0
        r.t = i;
        while (i > 0) {
            r[--i] = 0;
        }
        for (var j = r.t - this.t; i < j; ++i) {
            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        }
        for (var j = Math.min(a.t, n); i < j; ++i) {
            this.am(0, a[i], r, i, 0, n - i);
        }
        r.clamp();
    };
    // BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0; // assumes a,this >= 0
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        }
        r.clamp();
        r.drShiftTo(1, r);
    };
    // BigInteger.prototype.modInt = bnpModInt;
    // (protected) this % n, n < 2^26
    BigInteger.prototype.modInt = function (n) {
        if (n <= 0) {
            return 0;
        }
        var d = this.DV % n;
        var r = (this.s < 0) ? n - 1 : 0;
        if (this.t > 0) {
            if (d == 0) {
                r = this[0] % n;
            }
            else {
                for (var i = this.t - 1; i >= 0; --i) {
                    r = (d * r + this[i]) % n;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.millerRabin = bnpMillerRabin;
    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    BigInteger.prototype.millerRabin = function (t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) {
            return false;
        }
        var r = n1.shiftRight(k);
        t = (t + 1) >> 1;
        if (t > lowprimes.length) {
            t = lowprimes.length;
        }
        var a = nbi();
        for (var i = 0; i < t; ++i) {
            // Pick bases at random, instead of starting at 2
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                    y = y.modPowInt(2, this);
                    if (y.compareTo(BigInteger.ONE) == 0) {
                        return false;
                    }
                }
                if (y.compareTo(n1) != 0) {
                    return false;
                }
            }
        }
        return true;
    };
    // BigInteger.prototype.square = bnSquare;
    // (public) this^2
    BigInteger.prototype.square = function () {
        var r = nbi();
        this.squareTo(r);
        return r;
    };
    //#region ASYNC
    // Public API method
    BigInteger.prototype.gcda = function (a, callback) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            callback(x);
            return;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        // Workhorse of the algorithm, gets called 200 - 800 times per 512 bit keygen.
        var gcda1 = function () {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
            if (!(x.signum() > 0)) {
                if (g > 0) {
                    y.lShiftTo(g, y);
                }
                setTimeout(function () { callback(y); }, 0); // escape
            }
            else {
                setTimeout(gcda1, 0);
            }
        };
        setTimeout(gcda1, 10);
    };
    // (protected) alternate constructor
    BigInteger.prototype.fromNumberAsync = function (a, b, c, callback) {
        if ("number" == typeof b) {
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                }
                var bnp_1 = this;
                var bnpfn1_1 = function () {
                    bnp_1.dAddOffset(2, 0);
                    if (bnp_1.bitLength() > a) {
                        bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);
                    }
                    if (bnp_1.isProbablePrime(b)) {
                        setTimeout(function () { callback(); }, 0); // escape
                    }
                    else {
                        setTimeout(bnpfn1_1, 0);
                    }
                };
                setTimeout(bnpfn1_1, 0);
            }
        }
        else {
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    return BigInteger;
}());
//#region REDUCERS
//#region NullExp
var NullExp = /** @class */ (function () {
    function NullExp() {
    }
    // NullExp.prototype.convert = nNop;
    NullExp.prototype.convert = function (x) {
        return x;
    };
    // NullExp.prototype.revert = nNop;
    NullExp.prototype.revert = function (x) {
        return x;
    };
    // NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
    };
    // NullExp.prototype.sqrTo = nSqrTo;
    NullExp.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
    };
    return NullExp;
}());
// Modular reduction using "classic" algorithm
var Classic = /** @class */ (function () {
    function Classic(m) {
        this.m = m;
    }
    // Classic.prototype.convert = cConvert;
    Classic.prototype.convert = function (x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) {
            return x.mod(this.m);
        }
        else {
            return x;
        }
    };
    // Classic.prototype.revert = cRevert;
    Classic.prototype.revert = function (x) {
        return x;
    };
    // Classic.prototype.reduce = cReduce;
    Classic.prototype.reduce = function (x) {
        x.divRemTo(this.m, null, x);
    };
    // Classic.prototype.mulTo = cMulTo;
    Classic.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Classic.prototype.sqrTo = cSqrTo;
    Classic.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Classic;
}());
//#endregion
//#region Montgomery
// Montgomery reduction
var Montgomery = /** @class */ (function () {
    function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 0x7fff;
        this.mph = this.mp >> 15;
        this.um = (1 << (m.DB - 15)) - 1;
        this.mt2 = 2 * m.t;
    }
    // Montgomery.prototype.convert = montConvert;
    // xR mod m
    Montgomery.prototype.convert = function (x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            this.m.subTo(r, r);
        }
        return r;
    };
    // Montgomery.prototype.revert = montRevert;
    // x/R mod m
    Montgomery.prototype.revert = function (x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
    };
    // Montgomery.prototype.reduce = montReduce;
    // x = x/R mod m (HAC 14.32)
    Montgomery.prototype.reduce = function (x) {
        while (x.t <= this.mt2) {
            // pad x so am has enough room later
            x[x.t++] = 0;
        }
        for (var i = 0; i < this.m.t; ++i) {
            // faster way of calculating u0 = x[i]*mp mod DV
            var j = x[i] & 0x7fff;
            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
            // use am to combine the multiply-shift-add into one call
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            // propagate carry
            while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
            }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Montgomery.prototype.mulTo = montMulTo;
    // r = "xy/R mod m"; x,y != r
    Montgomery.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Montgomery.prototype.sqrTo = montSqrTo;
    // r = "x^2/R mod m"; x != r
    Montgomery.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Montgomery;
}());
//#endregion Montgomery
//#region Barrett
// Barrett modular reduction
var Barrett = /** @class */ (function () {
    function Barrett(m) {
        this.m = m;
        // setup Barrett
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
    }
    // Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.convert = function (x) {
        if (x.s < 0 || x.t > 2 * this.m.t) {
            return x.mod(this.m);
        }
        else if (x.compareTo(this.m) < 0) {
            return x;
        }
        else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
        }
    };
    // Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.revert = function (x) {
        return x;
    };
    // Barrett.prototype.reduce = barrettReduce;
    // x = x mod m (HAC 14.42)
    Barrett.prototype.reduce = function (x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) {
            x.dAddOffset(1, this.m.t + 1);
        }
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Barrett.prototype.mulTo = barrettMulTo;
    // r = x*y mod m; x,y != r
    Barrett.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Barrett.prototype.sqrTo = barrettSqrTo;
    // r = x^2 mod m; x != r
    Barrett.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Barrett;
}());
//#endregion
//#endregion REDUCERS
// return new, unset BigInteger
function nbi() { return new BigInteger(null); }
function parseBigInt(str, r) {
    return new BigInteger(str, r);
}
// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
    while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 0x4000000);
        w[j++] = v & 0x3ffffff;
    }
    return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
    var xl = x & 0x7fff;
    var xh = x >> 15;
    while (--n >= 0) {
        var l = this[i] & 0x7fff;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 0x3fffffff;
    }
    return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
    var xl = x & 0x3fff;
    var xh = x >> 14;
    while (--n >= 0) {
        var l = this[i] & 0x3fff;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 0xfffffff;
    }
    return c;
}
if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    BigInteger.prototype.am = am2;
    dbits = 30;
}
else if (j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
// Digit conversions
var BI_RC = [];
var rr;
var vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
}
// return bigint initialized to value
function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
}
// returns bit length of the integer x
function nbits(x) {
    var r = 1;
    var t;
    if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
    }
    if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
    }
    if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
    }
    if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
    }
    if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
    }
    return r;
}
// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// prng4.js - uses Arcfour as a PRNG
var Arcfour = /** @class */ (function () {
    function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = [];
    }
    // Arcfour.prototype.init = ARC4init;
    // Initialize arcfour context from key, an array of ints, each from [0..255]
    Arcfour.prototype.init = function (key) {
        var i;
        var j;
        var t;
        for (i = 0; i < 256; ++i) {
            this.S[i] = i;
        }
        j = 0;
        for (i = 0; i < 256; ++i) {
            j = (j + this.S[i] + key[i % key.length]) & 255;
            t = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t;
        }
        this.i = 0;
        this.j = 0;
    };
    // Arcfour.prototype.next = ARC4next;
    Arcfour.prototype.next = function () {
        var t;
        this.i = (this.i + 1) & 255;
        this.j = (this.j + this.S[this.i]) & 255;
        t = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t;
        return this.S[(t + this.S[this.i]) & 255];
    };
    return Arcfour;
}());
// Plug in your RNG constructor here
function prng_newstate() {
    return new Arcfour();
}
// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;

// Random number generator - requires a PRNG backend, e.g. prng4.js
var rng_state;
var rng_pool = null;
var rng_pptr;
// Initialize the pool with junk if needed.
if (rng_pool == null) {
    rng_pool = [];
    rng_pptr = 0;
    var t = void 0;
    if (window.crypto && window.crypto.getRandomValues) {
        // Extract entropy (2048 bits) from RNG if available
        var z = new Uint32Array(256);
        window.crypto.getRandomValues(z);
        for (t = 0; t < z.length; ++t) {
            rng_pool[rng_pptr++] = z[t] & 255;
        }
    }
    // Use mouse events for entropy, if we do not have enough entropy by the time
    // we need it, entropy will be generated by Math.random.
    var onMouseMoveListener_1 = function (ev) {
        this.count = this.count || 0;
        if (this.count >= 256 || rng_pptr >= rng_psize) {
            if (window.removeEventListener) {
                window.removeEventListener("mousemove", onMouseMoveListener_1, false);
            }
            else if (window.detachEvent) {
                window.detachEvent("onmousemove", onMouseMoveListener_1);
            }
            return;
        }
        try {
            var mouseCoordinates = ev.x + ev.y;
            rng_pool[rng_pptr++] = mouseCoordinates & 255;
            this.count += 1;
        }
        catch (e) {
            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.
        }
    };
    if (window.addEventListener) {
        window.addEventListener("mousemove", onMouseMoveListener_1, false);
    }
    else if (window.attachEvent) {
        window.attachEvent("onmousemove", onMouseMoveListener_1);
    }
}
function rng_get_byte() {
    if (rng_state == null) {
        rng_state = prng_newstate();
        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random
        while (rng_pptr < rng_psize) {
            var random = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = random & 255;
        }
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
            rng_pool[rng_pptr] = 0;
        }
        rng_pptr = 0;
    }
    // TODO: allow reseeding after first request
    return rng_state.next();
}
var SecureRandom = /** @class */ (function () {
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = function (ba) {
        for (var i = 0; i < ba.length; ++i) {
            ba[i] = rng_get_byte();
        }
    };
    return SecureRandom;
}());

// Depends on jsbn.js and rng.js
// function linebrk(s,n) {
//   var ret = "";
//   var i = 0;
//   while(i + n < s.length) {
//     ret += s.substring(i,i+n) + "\n";
//     i += n;
//   }
//   return ret + s.substring(i,s.length);
// }
// function byte2Hex(b) {
//   if(b < 0x10)
//     return "0" + b.toString(16);
//   else
//     return b.toString(16);
// }
function pkcs1pad1(s, n) {
    if (n < s.length + 22) {
        console.error("Message too long for RSA");
        return null;
    }
    var len = n - s.length - 6;
    var filler = "";
    for (var f = 0; f < len; f += 2) {
        filler += "ff";
    }
    var m = "0001" + filler + "00" + s;
    return parseBigInt(m, 16);
}
// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s, n) {
    if (n < s.length + 11) { // TODO: fix for utf-8
        console.error("Message too long for RSA");
        return null;
    }
    var ba = [];
    var i = s.length - 1;
    while (i >= 0 && n > 0) {
        var c = s.charCodeAt(i--);
        if (c < 128) { // encode using utf-8
            ba[--n] = c;
        }
        else if ((c > 127) && (c < 2048)) {
            ba[--n] = (c & 63) | 128;
            ba[--n] = (c >> 6) | 192;
        }
        else {
            ba[--n] = (c & 63) | 128;
            ba[--n] = ((c >> 6) & 63) | 128;
            ba[--n] = (c >> 12) | 224;
        }
    }
    ba[--n] = 0;
    var rng = new SecureRandom();
    var x = [];
    while (n > 2) { // random non-zero pad
        x[0] = 0;
        while (x[0] == 0) {
            rng.nextBytes(x);
        }
        ba[--n] = x[0];
    }
    ba[--n] = 2;
    ba[--n] = 0;
    return new BigInteger(ba);
}
// "empty" RSA key constructor
var RSAKey = /** @class */ (function () {
    function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
    }
    //#region PROTECTED
    // protected
    // RSAKey.prototype.doPublic = RSADoPublic;
    // Perform raw public operation on "x": return x^e (mod n)
    RSAKey.prototype.doPublic = function (x) {
        return x.modPowInt(this.e, this.n);
    };
    // RSAKey.prototype.doPrivate = RSADoPrivate;
    // Perform raw private operation on "x": return x^d (mod n)
    RSAKey.prototype.doPrivate = function (x) {
        if (this.p == null || this.q == null) {
            return x.modPow(this.d, this.n);
        }
        // TODO: re-calculate any missing CRT params
        var xp = x.mod(this.p).modPow(this.dmp1, this.p);
        var xq = x.mod(this.q).modPow(this.dmq1, this.q);
        while (xp.compareTo(xq) < 0) {
            xp = xp.add(this.p);
        }
        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
    };
    //#endregion PROTECTED
    //#region PUBLIC
    // RSAKey.prototype.setPublic = RSASetPublic;
    // Set the public key fields N and e from hex strings
    RSAKey.prototype.setPublic = function (N, E) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
        }
        else {
            console.error("Invalid RSA public key");
        }
    };
    // RSAKey.prototype.encrypt = RSAEncrypt;
    // Return the PKCS#1 RSA encryption of "text" as an even-length hex string
    RSAKey.prototype.encrypt = function (text) {
        var m = pkcs1pad2(text, (this.n.bitLength() + 7) >> 3);
        if (m == null) {
            return null;
        }
        var c = this.doPublic(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    // RSAKey.prototype.setPrivate = RSASetPrivate;
    // Set the private key fields N, e, and d from hex strings
    RSAKey.prototype.setPrivate = function (N, E, D) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
    // Set the private key fields N, e, d and CRT params from hex strings
    RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
            this.p = parseBigInt(P, 16);
            this.q = parseBigInt(Q, 16);
            this.dmp1 = parseBigInt(DP, 16);
            this.dmq1 = parseBigInt(DQ, 16);
            this.coeff = parseBigInt(C, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.generate = RSAGenerate;
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generate = function (B, E) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        for (;;) {
            for (;;) {
                this.p = new BigInteger(B - qs, 1, rng);
                if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
                    break;
                }
            }
            for (;;) {
                this.q = new BigInteger(qs, 1, rng);
                if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
                    break;
                }
            }
            if (this.p.compareTo(this.q) <= 0) {
                var t = this.p;
                this.p = this.q;
                this.q = t;
            }
            var p1 = this.p.subtract(BigInteger.ONE);
            var q1 = this.q.subtract(BigInteger.ONE);
            var phi = p1.multiply(q1);
            if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                this.n = this.p.multiply(this.q);
                this.d = ee.modInverse(phi);
                this.dmp1 = this.d.mod(p1);
                this.dmq1 = this.d.mod(q1);
                this.coeff = this.q.modInverse(this.p);
                break;
            }
        }
    };
    // RSAKey.prototype.decrypt = RSADecrypt;
    // Return the PKCS#1 RSA decryption of "ctext".
    // "ctext" is an even-length hex string and the output is a plain string.
    RSAKey.prototype.decrypt = function (ctext) {
        var c = parseBigInt(ctext, 16);
        var m = this.doPrivate(c);
        if (m == null) {
            return null;
        }
        return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);
    };
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generateAsync = function (B, E, callback) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        var rsa = this;
        // These functions have non-descript names because they were originally for(;;) loops.
        // I don't know about cryptography to give them better names than loop1-4.
        var loop1 = function () {
            var loop4 = function () {
                if (rsa.p.compareTo(rsa.q) <= 0) {
                    var t = rsa.p;
                    rsa.p = rsa.q;
                    rsa.q = t;
                }
                var p1 = rsa.p.subtract(BigInteger.ONE);
                var q1 = rsa.q.subtract(BigInteger.ONE);
                var phi = p1.multiply(q1);
                if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                    rsa.n = rsa.p.multiply(rsa.q);
                    rsa.d = ee.modInverse(phi);
                    rsa.dmp1 = rsa.d.mod(p1);
                    rsa.dmq1 = rsa.d.mod(q1);
                    rsa.coeff = rsa.q.modInverse(rsa.p);
                    setTimeout(function () { callback(); }, 0); // escape
                }
                else {
                    setTimeout(loop1, 0);
                }
            };
            var loop3 = function () {
                rsa.q = nbi();
                rsa.q.fromNumberAsync(qs, 1, rng, function () {
                    rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
                            setTimeout(loop4, 0);
                        }
                        else {
                            setTimeout(loop3, 0);
                        }
                    });
                });
            };
            var loop2 = function () {
                rsa.p = nbi();
                rsa.p.fromNumberAsync(B - qs, 1, rng, function () {
                    rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
                            setTimeout(loop3, 0);
                        }
                        else {
                            setTimeout(loop2, 0);
                        }
                    });
                });
            };
            setTimeout(loop2, 0);
        };
        setTimeout(loop1, 0);
    };
    RSAKey.prototype.sign = function (text, digestMethod, digestName) {
        var header = getDigestHeader(digestName);
        var digest = header + digestMethod(text).toString();
        var m = pkcs1pad1(digest, this.n.bitLength() / 4);
        if (m == null) {
            return null;
        }
        var c = this.doPrivate(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    RSAKey.prototype.verify = function (text, signature, digestMethod) {
        var c = parseBigInt(signature, 16);
        var m = this.doPublic(c);
        if (m == null) {
            return null;
        }
        var unpadded = m.toString(16).replace(/^1f+00/, "");
        var digest = removeDigestHeader(unpadded);
        return digest == digestMethod(text).toString();
    };
    return RSAKey;
}());
// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d, n) {
    var b = d.toByteArray();
    var i = 0;
    while (i < b.length && b[i] == 0) {
        ++i;
    }
    if (b.length - i != n - 1 || b[i] != 2) {
        return null;
    }
    ++i;
    while (b[i] != 0) {
        if (++i >= b.length) {
            return null;
        }
    }
    var ret = "";
    while (++i < b.length) {
        var c = b[i] & 255;
        if (c < 128) { // utf-8 decode
            ret += String.fromCharCode(c);
        }
        else if ((c > 191) && (c < 224)) {
            ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
            ++i;
        }
        else {
            ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
            i += 2;
        }
    }
    return ret;
}
// https://tools.ietf.org/html/rfc3447#page-43
var DIGEST_HEADERS = {
    md2: "3020300c06082a864886f70d020205000410",
    md5: "3020300c06082a864886f70d020505000410",
    sha1: "3021300906052b0e03021a05000414",
    sha224: "302d300d06096086480165030402040500041c",
    sha256: "3031300d060960864801650304020105000420",
    sha384: "3041300d060960864801650304020205000430",
    sha512: "3051300d060960864801650304020305000440",
    ripemd160: "3021300906052b2403020105000414",
};
function getDigestHeader(name) {
    return DIGEST_HEADERS[name] || "";
}
function removeDigestHeader(str) {
    for (var name_1 in DIGEST_HEADERS) {
        if (DIGEST_HEADERS.hasOwnProperty(name_1)) {
            var header = DIGEST_HEADERS[name_1];
            var len = header.length;
            if (str.substr(0, len) == header) {
                return str.substr(len);
            }
        }
    }
    return str;
}
// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
// function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
// }
// public
// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
var YAHOO = {};
YAHOO.lang = {
    /**
     * Utility to set up the prototype, constructor and superclass properties to
     * support an inheritance strategy that can chain constructors and methods.
     * Static members will not be inherited.
     *
     * @method extend
     * @static
     * @param {Function} subc   the object to modify
     * @param {Function} superc the object to inherit
     * @param {Object} overrides  additional properties/methods to add to the
     *                              subclass prototype.  These will override the
     *                              matching items obtained from the superclass
     *                              if present.
     */
    extend: function(subc, superc, overrides) {
        if (! superc || ! subc) {
            throw new Error("YAHOO.lang.extend failed, please check that " +
                "all dependencies are included.");
        }

        var F = function() {};
        F.prototype = superc.prototype;
        subc.prototype = new F();
        subc.prototype.constructor = subc;
        subc.superclass = superc.prototype;

        if (superc.prototype.constructor == Object.prototype.constructor) {
            superc.prototype.constructor = superc;
        }

        if (overrides) {
            var i;
            for (i in overrides) {
                subc.prototype[i] = overrides[i];
            }

            /*
             * IE will not enumerate native functions in a derived object even if the
             * function was overridden.  This is a workaround for specific functions
             * we care about on the Object prototype.
             * @property _IEEnumFix
             * @param {Function} r  the object to receive the augmentation
             * @param {Function} s  the object that supplies the properties to augment
             * @static
             * @private
             */
            var _IEEnumFix = function() {},
                ADD = ["toString", "valueOf"];
            try {
                if (/MSIE/.test(navigator.userAgent)) {
                    _IEEnumFix = function(r, s) {
                        for (i = 0; i < ADD.length; i = i + 1) {
                            var fname = ADD[i], f = s[fname];
                            if (typeof f === 'function' && f != Object.prototype[fname]) {
                                r[fname] = f;
                            }
                        }
                    };
                }
            } catch (ex) {}            _IEEnumFix(subc.prototype, overrides);
        }
    }
};

/* asn1-1.0.13.js (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */

/**
 * @fileOverview
 * @name asn1-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version asn1 1.0.13 (2017-Jun-02)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * kjur's class library name space
 * <p>
 * This name space provides following name spaces:
 * <ul>
 * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>
 * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>
 * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature
 * class and utilities</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * @name KJUR
 * @namespace kjur's class library name space
 */
var KJUR = {};

/**
 * kjur's ASN.1 class library name space
 * <p>
 * This is ITU-T X.690 ASN.1 DER encoder class library and
 * class structure and methods is very similar to
 * org.bouncycastle.asn1 package of
 * well known BouncyCaslte Cryptography Library.
 * <h4>PROVIDING ASN.1 PRIMITIVES</h4>
 * Here are ASN.1 DER primitive classes.
 * <ul>
 * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>
 * <li>0x02 {@link KJUR.asn1.DERInteger}</li>
 * <li>0x03 {@link KJUR.asn1.DERBitString}</li>
 * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>
 * <li>0x05 {@link KJUR.asn1.DERNull}</li>
 * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>
 * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>
 * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>
 * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>
 * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>
 * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>
 * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>
 * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>
 * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>
 * <li>0x30 {@link KJUR.asn1.DERSequence}</li>
 * <li>0x31 {@link KJUR.asn1.DERSet}</li>
 * </ul>
 * <h4>OTHER ASN.1 CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ASN1Object}</li>
 * <li>{@link KJUR.asn1.DERAbstractString}</li>
 * <li>{@link KJUR.asn1.DERAbstractTime}</li>
 * <li>{@link KJUR.asn1.DERAbstractStructured}</li>
 * <li>{@link KJUR.asn1.DERTaggedObject}</li>
 * </ul>
 * <h4>SUB NAME SPACES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>
 * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>
 * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>
 * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>
 * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace.
 * This caused by a bug of jsdoc2.
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * ASN1 utilities class
 * @name KJUR.asn1.ASN1Util
 * @class ASN1 utilities class
 * @since asn1 1.0.2
 */
KJUR.asn1.ASN1Util = new function() {
    this.integerToByteHex = function(i) {
        var h = i.toString(16);
        if ((h.length % 2) == 1) h = '0' + h;
        return h;
    };
    this.bigIntToMinTwosComplementsHex = function(bigIntegerValue) {
        var h = bigIntegerValue.toString(16);
        if (h.substr(0, 1) != '-') {
            if (h.length % 2 == 1) {
                h = '0' + h;
            } else {
                if (! h.match(/^[0-7]/)) {
                    h = '00' + h;
                }
            }
        } else {
            var hPos = h.substr(1);
            var xorLen = hPos.length;
            if (xorLen % 2 == 1) {
                xorLen += 1;
            } else {
                if (! h.match(/^[0-7]/)) {
                    xorLen += 2;
                }
            }
            var hMask = '';
            for (var i = 0; i < xorLen; i++) {
                hMask += 'f';
            }
            var biMask = new BigInteger(hMask, 16);
            var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
            h = biNeg.toString(16).replace(/^-/, '');
        }
        return h;
    };
    /**
     * get PEM string from hexadecimal data and header string
     * @name getPEMStringFromHex
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {String} dataHex hexadecimal string of PEM body
     * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
     * @return {String} PEM formatted string of input data
     * @description
     * This method converts a hexadecimal string to a PEM string with
     * a specified header. Its line break will be CRLF("\r\n").
     * @example
     * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');
     * // value of pem will be:
     * -----BEGIN PRIVATE KEY-----
     * YWFh
     * -----END PRIVATE KEY-----
     */
    this.getPEMStringFromHex = function(dataHex, pemHeader) {
        return hextopem(dataHex, pemHeader);
    };

    /**
     * generate ASN1Object specifed by JSON parameters
     * @name newObject
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return {KJUR.asn1.ASN1Object} generated object
     * @since asn1 1.0.3
     * @description
     * generate any ASN1Object specified by JSON param
     * including ASN.1 primitive or structured.
     * Generally 'param' can be described as follows:
     * <blockquote>
     * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}
     * </blockquote>
     * 'TYPE-OF-ASN1OBJ' can be one of following symbols:
     * <ul>
     * <li>'bool' - DERBoolean</li>
     * <li>'int' - DERInteger</li>
     * <li>'bitstr' - DERBitString</li>
     * <li>'octstr' - DEROctetString</li>
     * <li>'null' - DERNull</li>
     * <li>'oid' - DERObjectIdentifier</li>
     * <li>'enum' - DEREnumerated</li>
     * <li>'utf8str' - DERUTF8String</li>
     * <li>'numstr' - DERNumericString</li>
     * <li>'prnstr' - DERPrintableString</li>
     * <li>'telstr' - DERTeletexString</li>
     * <li>'ia5str' - DERIA5String</li>
     * <li>'utctime' - DERUTCTime</li>
     * <li>'gentime' - DERGeneralizedTime</li>
     * <li>'seq' - DERSequence</li>
     * <li>'set' - DERSet</li>
     * <li>'tag' - DERTaggedObject</li>
     * </ul>
     * @example
     * newObject({'prnstr': 'aaa'});
     * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})
     * // ASN.1 Tagged Object
     * newObject({'tag': {'tag': 'a1',
     *                    'explicit': true,
     *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});
     * // more simple representation of ASN.1 Tagged Object
     * newObject({'tag': ['a1',
     *                    true,
     *                    {'seq': [
     *                      {'int': 3},
     *                      {'prnstr': 'aaa'}]}
     *                   ]});
     */
    this.newObject = function(param) {
        var _KJUR = KJUR,
            _KJUR_asn1 = _KJUR.asn1,
            _DERBoolean = _KJUR_asn1.DERBoolean,
            _DERInteger = _KJUR_asn1.DERInteger,
            _DERBitString = _KJUR_asn1.DERBitString,
            _DEROctetString = _KJUR_asn1.DEROctetString,
            _DERNull = _KJUR_asn1.DERNull,
            _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
            _DEREnumerated = _KJUR_asn1.DEREnumerated,
            _DERUTF8String = _KJUR_asn1.DERUTF8String,
            _DERNumericString = _KJUR_asn1.DERNumericString,
            _DERPrintableString = _KJUR_asn1.DERPrintableString,
            _DERTeletexString = _KJUR_asn1.DERTeletexString,
            _DERIA5String = _KJUR_asn1.DERIA5String,
            _DERUTCTime = _KJUR_asn1.DERUTCTime,
            _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
            _DERSequence = _KJUR_asn1.DERSequence,
            _DERSet = _KJUR_asn1.DERSet,
            _DERTaggedObject = _KJUR_asn1.DERTaggedObject,
            _newObject = _KJUR_asn1.ASN1Util.newObject;

        var keys = Object.keys(param);
        if (keys.length != 1)
            throw "key of param shall be only one.";
        var key = keys[0];

        if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + key + ":") == -1)
            throw "undefined key: " + key;

        if (key == "bool")    return new _DERBoolean(param[key]);
        if (key == "int")     return new _DERInteger(param[key]);
        if (key == "bitstr")  return new _DERBitString(param[key]);
        if (key == "octstr")  return new _DEROctetString(param[key]);
        if (key == "null")    return new _DERNull(param[key]);
        if (key == "oid")     return new _DERObjectIdentifier(param[key]);
        if (key == "enum")    return new _DEREnumerated(param[key]);
        if (key == "utf8str") return new _DERUTF8String(param[key]);
        if (key == "numstr")  return new _DERNumericString(param[key]);
        if (key == "prnstr")  return new _DERPrintableString(param[key]);
        if (key == "telstr")  return new _DERTeletexString(param[key]);
        if (key == "ia5str")  return new _DERIA5String(param[key]);
        if (key == "utctime") return new _DERUTCTime(param[key]);
        if (key == "gentime") return new _DERGeneralizedTime(param[key]);

        if (key == "seq") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSequence({'array': a});
        }

        if (key == "set") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSet({'array': a});
        }

        if (key == "tag") {
            var tagParam = param[key];
            if (Object.prototype.toString.call(tagParam) === '[object Array]' &&
                tagParam.length == 3) {
                var obj = _newObject(tagParam[2]);
                return new _DERTaggedObject({tag: tagParam[0],
                    explicit: tagParam[1],
                    obj: obj});
            } else {
                var newParam = {};
                if (tagParam.explicit !== undefined)
                    newParam.explicit = tagParam.explicit;
                if (tagParam.tag !== undefined)
                    newParam.tag = tagParam.tag;
                if (tagParam.obj === undefined)
                    throw "obj shall be specified for 'tag'.";
                newParam.obj = _newObject(tagParam.obj);
                return new _DERTaggedObject(newParam);
            }
        }
    };

    /**
     * get encoded hexadecimal string of ASN1Object specifed by JSON parameters
     * @name jsonToASN1HEX
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return hexadecimal string of ASN1Object
     * @since asn1 1.0.4
     * @description
     * As for ASN.1 object representation of JSON object,
     * please see {@link newObject}.
     * @example
     * jsonToASN1HEX({'prnstr': 'aaa'});
     */
    this.jsonToASN1HEX = function(param) {
        var asn1Obj = this.newObject(param);
        return asn1Obj.getEncodedHex();
    };
};

/**
 * get dot noted oid number string from hexadecimal value of OID
 * @name oidHexToInt
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} hex hexadecimal value of object identifier
 * @return {String} dot noted string of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from hexadecimal string representation of
 * ASN.1 value of object identifier to oid number string.
 * @example
 * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; "2.5.4.6"
 */
KJUR.asn1.ASN1Util.oidHexToInt = function(hex) {
    var s = "";
    var i01 = parseInt(hex.substr(0, 2), 16);
    var i0 = Math.floor(i01 / 40);
    var i1 = i01 % 40;
    var s = i0 + "." + i1;

    var binbuf = "";
    for (var i = 2; i < hex.length; i += 2) {
        var value = parseInt(hex.substr(i, 2), 16);
        var bin = ("00000000" + value.toString(2)).slice(- 8);
        binbuf = binbuf + bin.substr(1, 7);
        if (bin.substr(0, 1) == "0") {
            var bi = new BigInteger(binbuf, 2);
            s = s + "." + bi.toString(10);
            binbuf = "";
        }
    }
    return s;
};

/**
 * get hexadecimal value of object identifier from dot noted oid value
 * @name oidIntToHex
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} oidString dot noted string of object identifier
 * @return {String} hexadecimal value of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from object identifier value string.
 * to hexadecimal string representation of it.
 * @example
 * KJUR.asn1.ASN1Util.oidIntToHex("2.5.4.6") &rarr; "550406"
 */
KJUR.asn1.ASN1Util.oidIntToHex = function(oidString) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };

    var roidtox = function(roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };

    if (! oidString.match(/^[0-9.]+$/)) {
        throw "malformed oid string: " + oidString;
    }
    var h = '';
    var a = oidString.split('.');
    var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
    h += itox(i0);
    a.splice(0, 2);
    for (var i = 0; i < a.length; i++) {
        h += roidtox(a[i]);
    }
    return h;
};


// ********************************************************************
//  Abstract ASN.1 Classes
// ********************************************************************

// ********************************************************************

/**
 * base class for ASN.1 DER encoder object
 * @name KJUR.asn1.ASN1Object
 * @class base class for ASN.1 DER encoder object
 * @property {Boolean} isModified flag whether internal data was changed
 * @property {String} hTLV hexadecimal string of ASN.1 TLV
 * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)
 * @property {String} hL hexadecimal string of ASN.1 TLV length(L)
 * @property {String} hV hexadecimal string of ASN.1 TLV value(V)
 * @description
 */
KJUR.asn1.ASN1Object = function() {
    var hV = '';

    /**
     * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)
     * @name getLengthHexFromValue
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV length(L)
     */
    this.getLengthHexFromValue = function() {
        if (typeof this.hV == "undefined" || this.hV == null) {
            throw "this.hV is null or undefined.";
        }
        if (this.hV.length % 2 == 1) {
            throw "value hex must be even length: n=" + hV.length + ",v=" + this.hV;
        }
        var n = this.hV.length / 2;
        var hN = n.toString(16);
        if (hN.length % 2 == 1) {
            hN = "0" + hN;
        }
        if (n < 128) {
            return hN;
        } else {
            var hNlen = hN.length / 2;
            if (hNlen > 15) {
                throw "ASN.1 length too long to represent by 8x: n = " + n.toString(16);
            }
            var head = 128 + hNlen;
            return head.toString(16) + hN;
        }
    };

    /**
     * get hexadecimal string of ASN.1 TLV bytes
     * @name getEncodedHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV
     */
    this.getEncodedHex = function() {
        if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
            //alert("first time: " + this.hTLV);
        }
        return this.hTLV;
    };

    /**
     * get hexadecimal string of ASN.1 TLV value(V) bytes
     * @name getValueHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes
     */
    this.getValueHex = function() {
        this.getEncodedHex();
        return this.hV;
    };

    this.getFreshValueHex = function() {
        return '';
    };
};

// == BEGIN DERAbstractString ================================================
/**
 * base class for ASN.1 DER string classes
 * @name KJUR.asn1.DERAbstractString
 * @class base class for ASN.1 DER string classes
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @property {String} s internal string of value
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERAbstractString = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);

    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @return {String} string value of this string object
     */
    this.getString = function() {
        return this.s;
    };

    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newS value by a string to set
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(this.s);
    };

    /**
     * set value by a hexadecimal string
     * @name setStringHex
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newHexString value by a hexadecimal string to set
     */
    this.setStringHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string") {
            this.setString(params);
        } else if (typeof params['str'] != "undefined") {
            this.setString(params['str']);
        } else if (typeof params['hex'] != "undefined") {
            this.setStringHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
// == END   DERAbstractString ================================================

// == BEGIN DERAbstractTime ==================================================
/**
 * base class for ASN.1 DER Generalized/UTCTime class
 * @name KJUR.asn1.DERAbstractTime
 * @class base class for ASN.1 DER Generalized/UTCTime class
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractTime = function(params) {
    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);

    // --- PRIVATE METHODS --------------------
    this.localDateToUTC = function(d) {
        utc = d.getTime() + (d.getTimezoneOffset() * 60000);
        var utcDate = new Date(utc);
        return utcDate;
    };

    /*
     * format date string by Data object
     * @name formatDate
     * @memberOf KJUR.asn1.AbstractTime;
     * @param {Date} dateObject
     * @param {string} type 'utc' or 'gen'
     * @param {boolean} withMillis flag for with millisections or not
     * @description
     * 'withMillis' flag is supported from asn1 1.0.6.
     */
    this.formatDate = function(dateObject, type, withMillis) {
        var pad = this.zeroPadding;
        var d = this.localDateToUTC(dateObject);
        var year = String(d.getFullYear());
        if (type == 'utc') year = year.substr(2, 2);
        var month = pad(String(d.getMonth() + 1), 2);
        var day = pad(String(d.getDate()), 2);
        var hour = pad(String(d.getHours()), 2);
        var min = pad(String(d.getMinutes()), 2);
        var sec = pad(String(d.getSeconds()), 2);
        var s = year + month + day + hour + min + sec;
        if (withMillis === true) {
            var millis = d.getMilliseconds();
            if (millis != 0) {
                var sMillis = pad(String(millis), 3);
                sMillis = sMillis.replace(/[0]+$/, "");
                s = s + "." + sMillis;
            }
        }
        return s + "Z";
    };

    this.zeroPadding = function(s, len) {
        if (s.length >= len) return s;
        return new Array(len - s.length + 1).join('0') + s;
    };

    // --- PUBLIC METHODS --------------------
    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @return {String} string value of this time object
     */
    this.getString = function() {
        return this.s;
    };

    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {String} newS value by a string to set such like "130430235959Z"
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(newS);
    };

    /**
     * set value by a Date object
     * @name setByDateValue
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {Integer} year year of date (ex. 2013)
     * @param {Integer} month month of date between 1 and 12 (ex. 12)
     * @param {Integer} day day of month
     * @param {Integer} hour hours of date
     * @param {Integer} min minutes of date
     * @param {Integer} sec seconds of date
     */
    this.setByDateValue = function(year, month, day, hour, min, sec) {
        var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
        this.setByDate(dateObject);
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
// == END   DERAbstractTime ==================================================

// == BEGIN DERAbstractStructured ============================================
/**
 * base class for ASN.1 DER structured class
 * @name KJUR.asn1.DERAbstractStructured
 * @class base class for ASN.1 DER structured class
 * @property {Array} asn1Array internal array of ASN1Object
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractStructured = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);

    /**
     * set value by array of ASN1Object
     * @name setByASN1ObjectArray
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {array} asn1ObjectArray array of ASN1Object to set
     */
    this.setByASN1ObjectArray = function(asn1ObjectArray) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = asn1ObjectArray;
    };

    /**
     * append an ASN1Object to internal array
     * @name appendASN1Object
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {ASN1Object} asn1Object to add
     */
    this.appendASN1Object = function(asn1Object) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(asn1Object);
    };

    this.asn1Array = new Array();
    if (typeof params != "undefined") {
        if (typeof params['array'] != "undefined") {
            this.asn1Array = params['array'];
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);


// ********************************************************************
//  ASN.1 Object Classes
// ********************************************************************

// ********************************************************************
/**
 * class for ASN.1 DER Boolean
 * @name KJUR.asn1.DERBoolean
 * @class class for ASN.1 DER Boolean
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERBoolean = function() {
    KJUR.asn1.DERBoolean.superclass.constructor.call(this);
    this.hT = "01";
    this.hTLV = "0101ff";
};
YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Integer
 * @name KJUR.asn1.DERInteger
 * @class class for ASN.1 DER Integer
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERInteger = function(params) {
    KJUR.asn1.DERInteger.superclass.constructor.call(this);
    this.hT = "02";

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DERInteger
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     * @example
     * new KJUR.asn1.DERInteger(123);
     * new KJUR.asn1.DERInteger({'int': 123});
     * new KJUR.asn1.DERInteger({'hex': '1fad'});
     */
    this.setValueHex = function(newHexString) {
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['bigint'] != "undefined") {
            this.setByBigInteger(params['bigint']);
        } else if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        } else if (typeof params == "number") {
            this.setByInteger(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER encoded BitString primitive
 * @name KJUR.asn1.DERBitString
 * @class class for ASN.1 DER encoded BitString primitive
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>bin - specify binary string (ex. '10111')</li>
 * <li>array - specify array of boolean (ex. [true,false,true,true])</li>
 * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>
 * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject}
 * argument for "BitString encapsulates" structure.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: 'obj' parameter have been supported since
 * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>
 * @example
 * // default constructor
 * o = new KJUR.asn1.DERBitString();
 * // initialize with binary string
 * o = new KJUR.asn1.DERBitString({bin: "1011"});
 * // initialize with boolean array
 * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});
 * // initialize with hexadecimal string (04 is unused bits)
 * o = new KJUR.asn1.DEROctetString({hex: "04bac0"});
 * // initialize with ASN1Util.newObject argument for encapsulated
 * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // BIT STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DERBitString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = "00" + o.getEncodedHex();
    }
    KJUR.asn1.DERBitString.superclass.constructor.call(this);
    this.hT = "03";

    /**
     * set ASN.1 value(V) by a hexadecimal string including unused bits
     * @name setHexValueIncludingUnusedBits
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} newHexStringIncludingUnusedBits
     */
    this.setHexValueIncludingUnusedBits = function(newHexStringIncludingUnusedBits) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = newHexStringIncludingUnusedBits;
    };

    /**
     * set ASN.1 value(V) by unused bit and hexadecimal string of value
     * @name setUnusedBitsAndHexValue
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {Integer} unusedBits
     * @param {String} hValue
     */
    this.setUnusedBitsAndHexValue = function(unusedBits, hValue) {
        if (unusedBits < 0 || 7 < unusedBits) {
            throw "unused bits shall be from 0 to 7: u = " + unusedBits;
        }
        var hUnusedBits = "0" + unusedBits;
        this.hTLV = null;
        this.isModified = true;
        this.hV = hUnusedBits + hValue;
    };

    /**
     * set ASN.1 DER BitString by binary string<br/>
     * @name setByBinaryString
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} binaryString binary value string (i.e. '10111')
     * @description
     * Its unused bits will be calculated automatically by length of
     * 'binaryValue'. <br/>
     * NOTE: Trailing zeros '0' will be ignored.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray("01011");
     */
    this.setByBinaryString = function(binaryString) {
        binaryString = binaryString.replace(/0+$/, '');
        var unusedBits = 8 - binaryString.length % 8;
        if (unusedBits == 8) unusedBits = 0;
        for (var i = 0; i <= unusedBits; i++) {
            binaryString += '0';
        }
        var h = '';
        for (var i = 0; i < binaryString.length - 1; i += 8) {
            var b = binaryString.substr(i, 8);
            var x = parseInt(b, 2).toString(16);
            if (x.length == 1) x = '0' + x;
            h += x;
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = '0' + unusedBits + h;
    };

    /**
     * set ASN.1 TLV value(V) by an array of boolean<br/>
     * @name setByBooleanArray
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {array} booleanArray array of boolean (ex. [true, false, true])
     * @description
     * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray([false, true, false, true, true]);
     */
    this.setByBooleanArray = function(booleanArray) {
        var s = '';
        for (var i = 0; i < booleanArray.length; i++) {
            if (booleanArray[i] == true) {
                s += '1';
            } else {
                s += '0';
            }
        }
        this.setByBinaryString(s);
    };

    /**
     * generate an array of falses with specified length<br/>
     * @name newFalseArray
     * @memberOf KJUR.asn1.DERBitString
     * @function
     * @param {Integer} nLength length of array to generate
     * @return {array} array of boolean falses
     * @description
     * This static method may be useful to initialize boolean array.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.newFalseArray(3) &rarr; [false, false, false]
     */
    this.newFalseArray = function(nLength) {
        var a = new Array(nLength);
        for (var i = 0; i < nLength; i++) {
            a[i] = false;
        }
        return a;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string" && params.toLowerCase().match(/^[0-9a-f]+$/)) {
            this.setHexValueIncludingUnusedBits(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setHexValueIncludingUnusedBits(params['hex']);
        } else if (typeof params['bin'] != "undefined") {
            this.setByBinaryString(params['bin']);
        } else if (typeof params['array'] != "undefined") {
            this.setByBooleanArray(params['array']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER OctetString<br/>
 * @name KJUR.asn1.DEROctetString
 * @class class for ASN.1 DER OctetString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * This class provides ASN.1 OctetString simple type.<br/>
 * Supported "params" attributes are:
 * <ul>
 * <li>str - to set a string as a value</li>
 * <li>hex - to set a hexadecimal string as a value</li>
 * <li>obj - to set a encapsulated ASN.1 value by JSON object
 * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>
 * </ul>
 * NOTE: A parameter 'obj' have been supported
 * for "OCTET STRING, encapsulates" structure.
 * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).
 * @see KJUR.asn1.DERAbstractString - superclass
 * @example
 * // default constructor
 * o = new KJUR.asn1.DEROctetString();
 * // initialize with string
 * o = new KJUR.asn1.DEROctetString({str: "aaa"});
 * // initialize with hexadecimal string
 * o = new KJUR.asn1.DEROctetString({hex: "616161"});
 * // initialize with ASN1Util.newObject argument
 * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // OCTET STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DEROctetString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = o.getEncodedHex();
    }
    KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
    this.hT = "04";
};
YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER Null
 * @name KJUR.asn1.DERNull
 * @class class for ASN.1 DER Null
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERNull = function() {
    KJUR.asn1.DERNull.superclass.constructor.call(this);
    this.hT = "05";
    this.hTLV = "0500";
};
YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER ObjectIdentifier
 * @name KJUR.asn1.DERObjectIdentifier
 * @class class for ASN.1 DER ObjectIdentifier
 * @param {Array} params associative array of parameters (ex. {'oid': '2.5.4.5'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERObjectIdentifier = function(params) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };
    var roidtox = function(roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };

    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
    this.hT = "06";

    /**
     * set value by a hexadecimal string
     * @name setValueHex
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} newHexString hexadecimal value of OID bytes
     */
    this.setValueHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    /**
     * set value by a OID string<br/>
     * @name setValueOidString
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidString OID string (ex. 2.5.4.13)
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueOidString("2.5.4.13");
     */
    this.setValueOidString = function(oidString) {
        if (! oidString.match(/^[0-9.]+$/)) {
            throw "malformed oid string: " + oidString;
        }
        var h = '';
        var a = oidString.split('.');
        var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
        h += itox(i0);
        a.splice(0, 2);
        for (var i = 0; i < a.length; i++) {
            h += roidtox(a[i]);
        }
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = h;
    };

    /**
     * set value by a OID name
     * @name setValueName
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidName OID name (ex. 'serverAuth')
     * @since 1.0.1
     * @description
     * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.
     * Otherwise raise error.
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueName("serverAuth");
     */
    this.setValueName = function(oidName) {
        var oid = KJUR.asn1.x509.OID.name2oid(oidName);
        if (oid !== '') {
            this.setValueOidString(oid);
        } else {
            throw "DERObjectIdentifier oidName undefined: " + oidName;
        }
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (params !== undefined) {
        if (typeof params === "string") {
            if (params.match(/^[0-2].[0-9.]+$/)) {
                this.setValueOidString(params);
            } else {
                this.setValueName(params);
            }
        } else if (params.oid !== undefined) {
            this.setValueOidString(params.oid);
        } else if (params.hex !== undefined) {
            this.setValueHex(params.hex);
        } else if (params.name !== undefined) {
            this.setValueName(params.name);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Enumerated
 * @name KJUR.asn1.DEREnumerated
 * @class class for ASN.1 DER Enumerated
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * @example
 * new KJUR.asn1.DEREnumerated(123);
 * new KJUR.asn1.DEREnumerated({int: 123});
 * new KJUR.asn1.DEREnumerated({hex: '1fad'});
 */
KJUR.asn1.DEREnumerated = function(params) {
    KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
    this.hT = "0a";

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     */
    this.setValueHex = function(newHexString) {
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        } else if (typeof params == "number") {
            this.setByInteger(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER UTF8String
 * @name KJUR.asn1.DERUTF8String
 * @class class for ASN.1 DER UTF8String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERUTF8String = function(params) {
    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
    this.hT = "0c";
};
YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER NumericString
 * @name KJUR.asn1.DERNumericString
 * @class class for ASN.1 DER NumericString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERNumericString = function(params) {
    KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
    this.hT = "12";
};
YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER PrintableString
 * @name KJUR.asn1.DERPrintableString
 * @class class for ASN.1 DER PrintableString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERPrintableString = function(params) {
    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
    this.hT = "13";
};
YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER TeletexString
 * @name KJUR.asn1.DERTeletexString
 * @class class for ASN.1 DER TeletexString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERTeletexString = function(params) {
    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
    this.hT = "14";
};
YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER IA5String
 * @name KJUR.asn1.DERIA5String
 * @class class for ASN.1 DER IA5String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERIA5String = function(params) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
    this.hT = "16";
};
YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER UTCTime
 * @name KJUR.asn1.DERUTCTime
 * @class class for ASN.1 DER UTCTime
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * <h4>EXAMPLES</h4>
 * @example
 * d1 = new KJUR.asn1.DERUTCTime();
 * d1.setString('130430125959Z');
 *
 * d2 = new KJUR.asn1.DERUTCTime({'str': '130430125959Z'});
 * d3 = new KJUR.asn1.DERUTCTime({'date': new Date(Date.UTC(2015, 0, 31, 0, 0, 0, 0))});
 * d4 = new KJUR.asn1.DERUTCTime('130430125959Z');
 */
KJUR.asn1.DERUTCTime = function(params) {
    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
    this.hT = "17";

    /**
     * set value by a Date object<br/>
     * @name setByDate
     * @memberOf KJUR.asn1.DERUTCTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * o = new KJUR.asn1.DERUTCTime();
     * o.setByDate(new Date("2016/12/31"));
     */
    this.setByDate = function(dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'utc');
        this.hV = stohex(this.s);
    };

    this.getFreshValueHex = function() {
        if (typeof this.date == "undefined" && typeof this.s == "undefined") {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'utc');
            this.hV = stohex(this.s);
        }
        return this.hV;
    };

    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        } else if (typeof params == "string" && params.match(/^[0-9]{12}Z$/)) {
            this.setString(params);
        } else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        } else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER GeneralizedTime
 * @name KJUR.asn1.DERGeneralizedTime
 * @class class for ASN.1 DER GeneralizedTime
 * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})
 * @property {Boolean} withMillis flag to show milliseconds or not
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
 * </ul>
 * NOTE1: 'params' can be omitted.
 * NOTE2: 'withMillis' property is supported from asn1 1.0.6.
 */
KJUR.asn1.DERGeneralizedTime = function(params) {
    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
    this.hT = "18";
    this.withMillis = false;

    /**
     * set value by a Date object
     * @name setByDate
     * @memberOf KJUR.asn1.DERGeneralizedTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * When you specify UTC time, use 'Date.UTC' method like this:<br/>
     * o1 = new DERUTCTime();
     * o1.setByDate(date);
     *
     * date = new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)); #2015JAN31 23:59:59
     */
    this.setByDate = function(dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'gen', this.withMillis);
        this.hV = stohex(this.s);
    };

    this.getFreshValueHex = function() {
        if (this.date === undefined && this.s === undefined) {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'gen', this.withMillis);
            this.hV = stohex(this.s);
        }
        return this.hV;
    };

    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        } else if (typeof params == "string" && params.match(/^[0-9]{14}Z$/)) {
            this.setString(params);
        } else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        } else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
        if (params.millis === true) {
            this.withMillis = true;
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER Sequence
 * @name KJUR.asn1.DERSequence
 * @class class for ASN.1 DER Sequence
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERSequence = function(params) {
    KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
    this.hT = "30";
    this.getFreshValueHex = function() {
        var h = '';
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            h += asn1Obj.getEncodedHex();
        }
        this.hV = h;
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER Set
 * @name KJUR.asn1.DERSet
 * @class class for ASN.1 DER Set
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: sortflag is supported since 1.0.5.
 */
KJUR.asn1.DERSet = function(params) {
    KJUR.asn1.DERSet.superclass.constructor.call(this, params);
    this.hT = "31";
    this.sortFlag = true; // item shall be sorted only in ASN.1 DER
    this.getFreshValueHex = function() {
        var a = new Array();
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            a.push(asn1Obj.getEncodedHex());
        }
        if (this.sortFlag == true) a.sort();
        this.hV = a.join('');
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params.sortflag != "undefined" &&
            params.sortflag == false)
            this.sortFlag = false;
    }
};
YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER TaggedObject
 * @name KJUR.asn1.DERTaggedObject
 * @class class for ASN.1 DER TaggedObject
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.
 * For example, if you find '[1]' tag in a ASN.1 dump,
 * 'tagNoHex' will be 'a1'.
 * <br/>
 * As for optional argument 'params' for constructor, you can specify *ANY* of
 * following properties:
 * <ul>
 * <li>explicit - specify true if this is explicit tag otherwise false
 *     (default is 'true').</li>
 * <li>tag - specify tag (default is 'a0' which means [0])</li>
 * <li>obj - specify ASN1Object which is tagged</li>
 * </ul>
 * @example
 * d1 = new KJUR.asn1.DERUTF8String({'str':'a'});
 * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});
 * hex = d2.getEncodedHex();
 */
KJUR.asn1.DERTaggedObject = function(params) {
    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
    this.hT = "a0";
    this.hV = '';
    this.isExplicit = true;
    this.asn1Object = null;

    /**
     * set value by an ASN1Object
     * @name setString
     * @memberOf KJUR.asn1.DERTaggedObject#
     * @function
     * @param {Boolean} isExplicitFlag flag for explicit/implicit tag
     * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag
     * @param {ASN1Object} asn1Object ASN.1 to encapsulate
     */
    this.setASN1Object = function(isExplicitFlag, tagNoHex, asn1Object) {
        this.hT = tagNoHex;
        this.isExplicit = isExplicitFlag;
        this.asn1Object = asn1Object;
        if (this.isExplicit) {
            this.hV = this.asn1Object.getEncodedHex();
            this.hTLV = null;
            this.isModified = true;
        } else {
            this.hV = null;
            this.hTLV = asn1Object.getEncodedHex();
            this.hTLV = this.hTLV.replace(/^../, tagNoHex);
            this.isModified = false;
        }
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['tag'] != "undefined") {
            this.hT = params['tag'];
        }
        if (typeof params['explicit'] != "undefined") {
            this.isExplicit = params['explicit'];
        }
        if (typeof params['obj'] != "undefined") {
            this.asn1Object = params['obj'];
            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);

/**
 * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.
 * This object is just a decorator for parsing the key parameter
 * @param {string|Object} key - The key in string format, or an object containing
 * the parameters needed to build a RSAKey object.
 * @constructor
 */
var JSEncryptRSAKey = /** @class */ (function (_super) {
    __extends(JSEncryptRSAKey, _super);
    function JSEncryptRSAKey(key) {
        var _this = _super.call(this) || this;
        // Call the super constructor.
        //  RSAKey.call(this);
        // If a key key was provided.
        if (key) {
            // If this is a string...
            if (typeof key === "string") {
                _this.parseKey(key);
            }
            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||
                JSEncryptRSAKey.hasPublicKeyProperty(key)) {
                // Set the values for the key.
                _this.parsePropertiesFrom(key);
            }
        }
        return _this;
    }
    /**
     * Method to parse a pem encoded string containing both a public or private key.
     * The method will translate the pem encoded string in a der encoded string and
     * will parse private key and public key parameters. This method accepts public key
     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).
     *
     * @todo Check how many rsa formats use the same format of pkcs #1.
     *
     * The format is defined as:
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * it's possible to examine the structure of the keys obtained from openssl using
     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/
     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer
     * @private
     */
    JSEncryptRSAKey.prototype.parseKey = function (pem) {
        try {
            var modulus = 0;
            var public_exponent = 0;
            var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
            var asn1 = ASN1.decode(der);
            // Fixes a bug with OpenSSL 1.0+ private keys
            if (asn1.sub.length === 3) {
                asn1 = asn1.sub[2].sub[0];
            }
            if (asn1.sub.length === 9) {
                // Parse the private key.
                modulus = asn1.sub[1].getHexStringValue(); // bigint
                this.n = parseBigInt(modulus, 16);
                public_exponent = asn1.sub[2].getHexStringValue(); // int
                this.e = parseInt(public_exponent, 16);
                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint
                this.d = parseBigInt(private_exponent, 16);
                var prime1 = asn1.sub[4].getHexStringValue(); // bigint
                this.p = parseBigInt(prime1, 16);
                var prime2 = asn1.sub[5].getHexStringValue(); // bigint
                this.q = parseBigInt(prime2, 16);
                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint
                this.dmp1 = parseBigInt(exponent1, 16);
                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint
                this.dmq1 = parseBigInt(exponent2, 16);
                var coefficient = asn1.sub[8].getHexStringValue(); // bigint
                this.coeff = parseBigInt(coefficient, 16);
            }
            else if (asn1.sub.length === 2) {
                // Parse the public key.
                var bit_string = asn1.sub[1];
                var sequence = bit_string.sub[0];
                modulus = sequence.sub[0].getHexStringValue();
                this.n = parseBigInt(modulus, 16);
                public_exponent = sequence.sub[1].getHexStringValue();
                this.e = parseInt(public_exponent, 16);
            }
            else {
                return false;
            }
            return true;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa key.
     *
     * The translation follow the ASN.1 notation :
     * RSAPrivateKey ::= SEQUENCE {
     *   version           Version,
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER,  -- e
     *   privateExponent   INTEGER,  -- d
     *   prime1            INTEGER,  -- p
     *   prime2            INTEGER,  -- q
     *   exponent1         INTEGER,  -- d mod (p1)
     *   exponent2         INTEGER,  -- d mod (q-1)
     *   coefficient       INTEGER,  -- (inverse of q) mod p
     * }
     * @returns {string}  DER Encoded String representing the rsa private key
     * @private
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {
        var options = {
            array: [
                new KJUR.asn1.DERInteger({ int: 0 }),
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e }),
                new KJUR.asn1.DERInteger({ bigint: this.d }),
                new KJUR.asn1.DERInteger({ bigint: this.p }),
                new KJUR.asn1.DERInteger({ bigint: this.q }),
                new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),
                new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),
                new KJUR.asn1.DERInteger({ bigint: this.coeff })
            ]
        };
        var seq = new KJUR.asn1.DERSequence(options);
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {
        return hex2b64(this.getPrivateBaseKey());
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa public key.
     * The representation follow the ASN.1 notation :
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * @returns {string} DER Encoded String representing the rsa public key
     * @private
     */
    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {
        var first_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }),
                new KJUR.asn1.DERNull()
            ]
        });
        var second_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e })
            ]
        });
        var bit_string = new KJUR.asn1.DERBitString({
            hex: "00" + second_sequence.getEncodedHex()
        });
        var seq = new KJUR.asn1.DERSequence({
            array: [
                first_sequence,
                bit_string
            ]
        });
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {
        return hex2b64(this.getPublicBaseKey());
    };
    /**
     * wrap the string in block of width chars. The default value for rsa keys is 64
     * characters.
     * @param {string} str the pem encoded string without header and footer
     * @param {Number} [width=64] - the length the string has to be wrapped at
     * @returns {string}
     * @private
     */
    JSEncryptRSAKey.wordwrap = function (str, width) {
        width = width || 64;
        if (!str) {
            return str;
        }
        var regex = "(.{1," + width + "})( +|$\n?)|(.{1," + width + "})";
        return str.match(RegExp(regex, "g")).join("\n");
    };
    /**
     * Retrieve the pem encoded private key
     * @returns {string} the pem encoded private key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateKey = function () {
        var key = "-----BEGIN RSA PRIVATE KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + "\n";
        key += "-----END RSA PRIVATE KEY-----";
        return key;
    };
    /**
     * Retrieve the pem encoded public key
     * @returns {string} the pem encoded public key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicKey = function () {
        var key = "-----BEGIN PUBLIC KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + "\n";
        key += "-----END PUBLIC KEY-----";
        return key;
    };
    /**
     * Check if the object contains the necessary parameters to populate the rsa modulus
     * and public exponent parameters.
     * @param {Object} [obj={}] - An object that may contain the two public key
     * parameters
     * @returns {boolean} true if the object contains both the modulus and the public exponent
     * properties (n and e)
     * @todo check for types of n and e. N should be a parseable bigInt object, E should
     * be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e"));
    };
    /**
     * Check if the object contains ALL the parameters of an RSA key.
     * @param {Object} [obj={}] - An object that may contain nine rsa key
     * parameters
     * @returns {boolean} true if the object contains all the parameters needed
     * @todo check for types of the parameters all the parameters but the public exponent
     * should be parseable bigint objects, the public exponent should be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e") &&
            obj.hasOwnProperty("d") &&
            obj.hasOwnProperty("p") &&
            obj.hasOwnProperty("q") &&
            obj.hasOwnProperty("dmp1") &&
            obj.hasOwnProperty("dmq1") &&
            obj.hasOwnProperty("coeff"));
    };
    /**
     * Parse the properties of obj in the current rsa object. Obj should AT LEAST
     * include the modulus and public exponent (n, e) parameters.
     * @param {Object} obj - the object containing rsa parameters
     * @private
     */
    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {
        this.n = obj.n;
        this.e = obj.e;
        if (obj.hasOwnProperty("d")) {
            this.d = obj.d;
            this.p = obj.p;
            this.q = obj.q;
            this.dmp1 = obj.dmp1;
            this.dmq1 = obj.dmq1;
            this.coeff = obj.coeff;
        }
    };
    return JSEncryptRSAKey;
}(RSAKey));

/**
 *
 * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour
 * possible parameters are:
 * - default_key_size        {number}  default: 1024 the key size in bit
 * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent
 * - log                     {boolean} default: false whether log warn/error or not
 * @constructor
 */
var JSEncrypt = /** @class */ (function () {
    function JSEncrypt(options) {
        options = options || {};
        this.default_key_size = parseInt(options.default_key_size, 10) || 1024;
        this.default_public_exponent = options.default_public_exponent || "010001"; // 65537 default openssl public exponent for rsa key type
        this.log = options.log || false;
        // The private and public key.
        this.key = null;
    }
    /**
     * Method to set the rsa key parameter (one method is enough to set both the public
     * and the private key, since the private key contains the public key paramenters)
     * Log a warning if logs are enabled
     * @param {Object|string} key the pem encoded string or an object (with or without header/footer)
     * @public
     */
    JSEncrypt.prototype.setKey = function (key) {
        if (this.log && this.key) {
            console.warn("A key was already set, overriding existing.");
        }
        this.key = new JSEncryptRSAKey(key);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPrivateKey = function (privkey) {
        // Create the key.
        this.setKey(privkey);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPublicKey = function (pubkey) {
        // Sets the public key.
        this.setKey(pubkey);
    };
    /**
     * Proxy method for RSAKey object's decrypt, decrypt the string using the private
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str base64 encoded crypted string to decrypt
     * @return {string} the decrypted string
     * @public
     */
    JSEncrypt.prototype.decrypt = function (str) {
        // Return the decrypted string.
        try {
            return this.getKey().decrypt(b64tohex(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's encrypt, encrypt the string using the public
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str the string to encrypt
     * @return {string} the encrypted string encoded in base64
     * @public
     */
    JSEncrypt.prototype.encrypt = function (str) {
        // Return the encrypted string.
        try {
            return hex2b64(this.getKey().encrypt(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's sign.
     * @param {string} str the string to sign
     * @param {function} digestMethod hash method
     * @param {string} digestName the name of the hash algorithm
     * @return {string} the signature encoded in base64
     * @public
     */
    JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {
        // return the RSA signature of 'str' in 'hex' format.
        try {
            return hex2b64(this.getKey().sign(str, digestMethod, digestName));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's verify.
     * @param {string} str the string to verify
     * @param {string} signature the signature encoded in base64 to compare the string to
     * @param {function} digestMethod hash method
     * @return {boolean} whether the data and signature match
     * @public
     */
    JSEncrypt.prototype.verify = function (str, signature, digestMethod) {
        // Return the decrypted 'digest' of the signature.
        try {
            return this.getKey().verify(str, b64tohex(signature), digestMethod);
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object
     * will be created and returned
     * @param {callback} [cb] the callback to be called if we want the key to be generated
     * in an async fashion
     * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object
     * @public
     */
    JSEncrypt.prototype.getKey = function (cb) {
        // Only create new if it does not exist.
        if (!this.key) {
            // Get a new private key.
            this.key = new JSEncryptRSAKey();
            if (cb && {}.toString.call(cb) === "[object Function]") {
                this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
                return;
            }
            // Generate the key.
            this.key.generate(this.default_key_size, this.default_public_exponent);
        }
        return this.key;
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateKey();
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateBaseKeyB64();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicKey();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicBaseKeyB64();
    };
    JSEncrypt.version = "3.0.0-rc.1";
    return JSEncrypt;
}());

window.JSEncrypt = JSEncrypt;

exports.JSEncrypt = JSEncrypt;
exports.default = JSEncrypt;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = __webpack_require__(/*! pseudomap */ "./node_modules/pseudomap/map.js")
var util = __webpack_require__(/*! util */ "./node_modules/node-libs-browser/node_modules/util/util.js")

// A linked list to keep track of recently-used-ness
var Yallist = __webpack_require__(/*! yallist */ "./node_modules/yallist/yallist.js")

// use symbols if possible, otherwise just _props
var hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1'
var makeSymbol
if (hasSymbol) {
  makeSymbol = function (key) {
    return Symbol(key)
  }
} else {
  makeSymbol = function (key) {
    return '_' + key
  }
}

var MAX = makeSymbol('max')
var LENGTH = makeSymbol('length')
var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
var ALLOW_STALE = makeSymbol('allowStale')
var MAX_AGE = makeSymbol('maxAge')
var DISPOSE = makeSymbol('dispose')
var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
var LRU_LIST = makeSymbol('lruList')
var CACHE = makeSymbol('cache')

function naiveLength () { return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  if (typeof options === 'number') {
    options = { max: options }
  }

  if (!options) {
    options = {}
  }

  var max = this[MAX] = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) {
    this[MAX] = Infinity
  }

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') {
    lc = naiveLength
  }
  this[LENGTH_CALCULATOR] = lc

  this[ALLOW_STALE] = options.stale || false
  this[MAX_AGE] = options.maxAge || 0
  this[DISPOSE] = options.dispose
  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', {
  set: function (mL) {
    if (!mL || !(typeof mL === 'number') || mL <= 0) {
      mL = Infinity
    }
    this[MAX] = mL
    trim(this)
  },
  get: function () {
    return this[MAX]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', {
  set: function (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  },
  get: function () {
    return this[ALLOW_STALE]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', {
  set: function (mA) {
    if (!mA || !(typeof mA === 'number') || mA < 0) {
      mA = 0
    }
    this[MAX_AGE] = mA
    trim(this)
  },
  get: function () {
    return this[MAX_AGE]
  },
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
  set: function (lC) {
    if (typeof lC !== 'function') {
      lC = naiveLength
    }
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(function (hit) {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      }, this)
    }
    trim(this)
  },
  get: function () { return this[LENGTH_CALCULATOR] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', {
  get: function () { return this[LENGTH] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', {
  get: function () { return this[LRU_LIST].length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].tail; walker !== null;) {
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  }
}

function forEachStep (self, fn, node, thisp) {
  var hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE]) {
      hit = undefined
    }
  }
  if (hit) {
    fn.call(thisp, hit.value, hit.key, self)
  }
}

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].head; walker !== null;) {
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  }
}

LRUCache.prototype.keys = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.key
  }, this)
}

LRUCache.prototype.values = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.value
  }, this)
}

LRUCache.prototype.reset = function () {
  if (this[DISPOSE] &&
      this[LRU_LIST] &&
      this[LRU_LIST].length) {
    this[LRU_LIST].forEach(function (hit) {
      this[DISPOSE](hit.key, hit.value)
    }, this)
  }

  this[CACHE] = new Map() // hash of items by key
  this[LRU_LIST] = new Yallist() // list of items in order of use recency
  this[LENGTH] = 0 // length of items in the list
}

LRUCache.prototype.dump = function () {
  return this[LRU_LIST].map(function (hit) {
    if (!isStale(this, hit)) {
      return {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }
    }
  }, this).toArray().filter(function (h) {
    return h
  })
}

LRUCache.prototype.dumpLru = function () {
  return this[LRU_LIST]
}

/* istanbul ignore next */
LRUCache.prototype.inspect = function (n, opts) {
  var str = 'LRUCache {'
  var extras = false

  var as = this[ALLOW_STALE]
  if (as) {
    str += '\n  allowStale: true'
    extras = true
  }

  var max = this[MAX]
  if (max && max !== Infinity) {
    if (extras) {
      str += ','
    }
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  }

  var maxAge = this[MAX_AGE]
  if (maxAge) {
    if (extras) {
      str += ','
    }
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  }

  var lc = this[LENGTH_CALCULATOR]
  if (lc && lc !== naiveLength) {
    if (extras) {
      str += ','
    }
    str += '\n  length: ' + util.inspect(this[LENGTH], opts)
    extras = true
  }

  var didFirst = false
  this[LRU_LIST].forEach(function (item) {
    if (didFirst) {
      str += ',\n  '
    } else {
      if (extras) {
        str += ',\n'
      }
      didFirst = true
      str += '\n  '
    }
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = { value: item.value }
    if (item.maxAge !== maxAge) {
      val.maxAge = item.maxAge
    }
    if (lc !== naiveLength) {
      val.length = item.length
    }
    if (isStale(this, item)) {
      val.stale = true
    }

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  })

  if (didFirst || extras) {
    str += '\n'
  }
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this[MAX_AGE]

  var now = maxAge ? Date.now() : 0
  var len = this[LENGTH_CALCULATOR](value, key)

  if (this[CACHE].has(key)) {
    if (len > this[MAX]) {
      del(this, this[CACHE].get(key))
      return false
    }

    var node = this[CACHE].get(key)
    var item = node.value

    // dispose of the old one before overwriting
    // split out into 2 ifs for better coverage tracking
    if (this[DISPOSE]) {
      if (!this[NO_DISPOSE_ON_SET]) {
        this[DISPOSE](key, item.value)
      }
    }

    item.now = now
    item.maxAge = maxAge
    item.value = value
    this[LENGTH] += len - item.length
    item.length = len
    this.get(key)
    trim(this)
    return true
  }

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this[MAX]) {
    if (this[DISPOSE]) {
      this[DISPOSE](key, value)
    }
    return false
  }

  this[LENGTH] += hit.length
  this[LRU_LIST].unshift(hit)
  this[CACHE].set(key, this[LRU_LIST].head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) {
  if (!this[CACHE].has(key)) return false
  var hit = this[CACHE].get(key).value
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var node = this[LRU_LIST].tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) {
  del(this, this[CACHE].get(key))
}

LRUCache.prototype.load = function (arr) {
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) {
        this.set(hit.k, hit.v, maxAge)
      }
    }
  }
}

LRUCache.prototype.prune = function () {
  var self = this
  this[CACHE].forEach(function (value, key) {
    get(self, key, false)
  })
}

function get (self, key, doUse) {
  var node = self[CACHE].get(key)
  if (node) {
    var hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE]) hit = undefined
    } else {
      if (doUse) {
        self[LRU_LIST].unshiftNode(node)
      }
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale (self, hit) {
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {
    return false
  }
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self[MAX_AGE] && (diff > self[MAX_AGE])
  }
  return stale
}

function trim (self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

function del (self, node) {
  if (node) {
    var hit = node.value
    if (self[DISPOSE]) {
      self[DISPOSE](hit.key, hit.value)
    }
    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) {
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/util/util.js":
/*!******************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/util/util.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/promise-window/dist/promise-window.js":
/*!************************************************************!*\
  !*** ./node_modules/promise-window/dist/promise-window.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * PromiseWindow
 * https://github.com/amercier/promise-window
 * @ignore
 */
(function() {
  'use strict';

  var root = window,
      prototype,
      html = root.document.documentElement;

  /**
   * Merge the contents of two or more objects together into the first object.
   *
   *     merge( target [, object1 ] [, objectN ] )
   *
   * @param {Object} target  An object that will receive the new properties if
   *                         additional objects are passed in.
   * @param {Object} object1 An object containing additional properties to merge in.
   * @param {Object} objectN An object containing additional properties to merge in.
   * @return {Object} Returns the first object.
   * @ignore
   */
  function extend() {
    var extended = arguments[0], key, i;
    for (i = 1; i < arguments.length; i++) {
      for (key in arguments[i]) {
        if (arguments[i].hasOwnProperty(key)) {
          extended[key] = arguments[i][key];
        }
      }
    }
    return extended;
  }

  /**
   * Generates a pseudo-unique String
   *
   * @param  {String} prefix Optional.
   * @return {String} Returns a pseudo-unique string prefixed with the given prefix, if any.
   * @ignore
   */
  function generateUniqueString(prefix) {
    return prefix + new Date().getTime() + "-" + Math.floor(10e12 * Math.random());
  }

  /**
   * Create a new PromiseWindow object
   *
   * During the lifecycle of this object, popup windows can be opened, closed,
   * and reopened again. However, it'
   *
   * Instanciating this prototype does not immediately opens a new popup window.
   * To open the window, use `open()` on the created object.
   *
   * @param {String}   uri                    Destination URI
   * @param {Object}   config                 Configuration object. See description below.
   * @param {Number}   config.width           Width of the popup window. Defaults to the current document width.
   * @param {Number}   config.height          Height of the popup window. Defaults to the current document height.
   * @param {Function} config.promiseProvider Promise provider. Should return a plain object containing 3 fields:
   *                                          - `promise` {Promise}  a new Promise object
   *                                          - `resolve` {Function} the method to resolve the given Promise
   *                                          - `reject`  {Function} the method to reject the given Promise
   * @param {Function} config.onPostMessage   Handler for receiving a postMessage from the opened window. Default
   *                                          implementation resolves the promise with the data passed in the post
   *                                          message, except if this data contains an `error` field. In this case,
   *                                          it rejects the Promise with the value of that field. In all cases, closes
   *                                          the popup window.
   * @param {Function} config.onPostMessage.event Event The postMessage event
   * @param {Number}   config.watcherDelay    There is no programmatic way of knowing when a popup window is closed
   *                                          (either manually or programatically). For this reason, every time
   *                                          PromiseWindow opens a popup, a new watcher is created. The watcher checks
   *                                          regularly if the window is still open. This value defines at which
   *                                          interval this check is done. Defaults to 100ms.
   * @param {String}   config.windowName      Name to be ginven to the popup window. See `window.open` references for
   *                                          details. If `null`, a random name is generated.
   * @param {Object}   config.window          Object containing window configuration settings. Scrollbars are enabled
   *                                          by default. All `window.open` ptions are accepted, but please note that
   *                                          many of them have no effect in most modern browsers. See
   *                                          https://developer.mozilla.org/en-US/docs/Web/API/Window/open for more
   *                                          details.
   * @param {Function} config.onClose         Function being called whenever the popup is being closed (either after a
   *                                          post message has been received, or window has been closed by user, or
   *                                          `.close()` method has been called. Default implementation closes the
   *                                          popup window by calling `this._window.close()`).
   * @param {RegExp} config.originRegexp      Regular expression that matches the origin part of an URI. Defaults to
   *                                          `new RegExp('^[^:/?]+://[^/]*')`. If doesn't match (ex: relative URIs),
   *                                          use `location.origin`.
   * @constructor
   */
  function PromiseWindow(uri, config) {
    this.uri = uri;
    this.config = extend({}, this.constructor.defaultConfig, config);
    this.config.windowName = this.config.windowName || generateUniqueString('promise-window-');
    this._onPostMessage = this._onPostMessage.bind(this);
  }

  /**
   * Create a Promise provider from a Promise/A+ constructor to be used with
   * `config.promiseProvider`.
   *
   *     new PromiseWindow(..., {
   *       ...,
   *       promiseProvider: PromiseWindow.getAPlusPromiseProvider(MyCustomPromise)
   *     });
   *
   * @param  {Function} CustomPromise Promise/A+ contructor
   * @return {Function} Returns a promise provider
   * @static
   */
  PromiseWindow.getAPlusPromiseProvider = function getAPlusPromiseProvider(CustomPromise) {
    return function promiseProvider() {
      var module = {};
      module.promise = new CustomPromise(function(resolve, reject) {
        module.resolve = resolve;
        module.reject = reject;
      });
      return module;
    };
  };

  /**
   * Convenience method for:
   *
   *     new PromiseWindow(uri, config).open()
   *
   * Use this method only if you never need to close the window programatically.
   * If you do, please consider using the classic way:
   *
   *     var w = new PromiseWindow(uri, config)
   *     w.open();
   *     // ...
   *     w.close();
   *
   * @return {Promise} Returns a Promise equivalent to the one returned by `open()`
   * @static
   */
  PromiseWindow.open = function open(uri, config) {
    return new PromiseWindow(uri, config).open();
  };

  /**
   * Default configuration
   * @type {Object}
   */
  PromiseWindow.defaultConfig = {
    width: html.clientWidth,
    height: html.clientHeight,
    window: {
      scrollbars: true
    },
    watcherDelay: 100,
    promiseProvider: null,
    onPostMessage: function onPostMessage(event) {
      if (event.data.error) {
        this._reject(event.data.error);
      } else {
        this._resolve(event.data);
      }
      this.close();
    },
    windowName: null,
    onClose: function() {
      this._window.close();
    },
    originRegexp: new RegExp('^[^:/?]+://[^/]*')
  };

  // Configure default Promise provider from current invironment
  if (root.Promise) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.Promise);
  }
  else if (root.RSVP) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.RSVP.Promise);
  }
  else if (root.Q) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.Q.Promise);
  }
  else if (root.jQuery) {
    PromiseWindow.defaultConfig.promiseProvider = function promiseProvider() {
      var deferred = root.jQuery.Deferred();
      return {
        promise: deferred.promise(),
        resolve: deferred.resolve,
        reject: deferred.reject
      };
    };
  }
  else {
    PromiseWindow.defaultConfig.promiseProvider = function() {
      throw new Error('Missing promiseProvider in PromiseWindow configuration');
    };
  }

  prototype = PromiseWindow.prototype;

  /**
   * Checks whether a value is a boolean
   * @param {*} value The value to check
   * @return {boolean} `true` if value is a boolean, `false` otherwise
   * @protected
   */
  prototype._isBoolean = function _isBoolean(value) {
    return value === true || value === false;
  };

  /**
   * Converts a config value into a value compatible with `window.open`.
   * If value is a boolean, convert it to 'yes' or 'no', otherwise simply
   * casts it into a string.
   * @param {*} value The value to convert
   * @return {string} The converted value
   * @protected
   */
  prototype._serializeFeatureValue = function _serializeFeatureValue(key, value) {
    if (this._isBoolean(value)) {
      return value ? 'yes' : 'no';
    }
    return '' + value;
  };

  /**
   * Get the left and top position in the screen for a rectangle, taking
   * dual-screen position into account
   * @param {Number} width Width of the rectangle
   * @param {Number} height Height of the rectangle
   * @return {Object} position A new object representing the position of the rectangle, centered
   * @return {Number} position.left The X coordinate of the centered rectangle
   * @return {Number} position.top The Y coordinate of the centered rectangle
   * @return {Number} position.width The width of the centered rectangle
   * @return {Number} position.height The height of the centered rectangle
   * @protected
   */
  prototype._getCenteredPosition = function _getCenteredPosition(width, height) {
    var dualScreenLeft = root.screenLeft !== undefined ? root.screenLeft : screen.left,
        dualScreenTop = root.screenTop !== undefined ? root.screenTop : screen.top,
        w = root.innerWidth || html.clientWidth || screen.width,
        h = root.innerHeight || html.clientHeight || screen.height;

    return {
      left: (w / 2) - (width / 2) + dualScreenLeft,
      top:  (h / 2) - (height / 2) + dualScreenTop,
      width: width,
      height: height
    };
  };

  /**
   * Generates window features based on the current configuration
   * @return {String} Returns window features compatible with `window.open`
   * @protected
   */
  prototype._getFeatures = function _getFeatures() {
    var config = this._getCenteredPosition(this.config.width, this.config.height);
    for (var key in this.config.window) {
      if (this.config.window.hasOwnProperty(key)) {
        config[key] = this.config.window[key];
      }
    }

    return Object.keys(config)
      .map(function(key) { return key + '=' + this._serializeFeatureValue(key, config[key]); }.bind(this))
      .join(',');
  };

  /**
   * Creates a new Promise, using `config.promiseProvider`, and save reject and
   * resolve methods for later.
   *
   * @return {Promise} Returns the new Promise object created by the configured
   *                   Promise Provider.
   * @protected
   */
  prototype._createPromise = function _createPromise() {
    var module = this.config.promiseProvider();
    this._resolve = module.resolve;
    this._reject = module.reject;
    return module.promise;
  };

  /**
   * Checks whether the window is alive or not
   * @return {Boolean} Returns `true` if the window is alive, `false` otherwise
   * @protected
   */
  prototype._isWindowAlive = function _isWindowAlive() {
    return this._window && !this._window.closed;
  };

  /**
   * Starts the popup window watcher.
   * @return {void}
   * @protected
   */
  prototype._startWatcher = function _startWatcher() {
    if (this._watcherRunning) {
      throw new Error('Watcher is already started');
    }
    this._watcher = root.setInterval(function () {
      if (this._watcherRunning && !this._isWindowAlive()) {
        this.close();
      }
    }.bind(this), this.config.watcherDelay);
    this._watcherRunning = true;
  };

  /**
   * Stops the popup window watcher.
   * @return {void}
   * @protected
   */
  prototype._stopWatcher = function _stopWatcher() {
    if (!this._watcherRunning) {
      throw new Error('Watcher is already stopped');
    }
    this._watcherRunning = false;
    root.clearInterval(this._watcher);
  };

  /**
   * Callback for post message events. If and only of the event has been
   * generated from the opened popup window, it propagates it to the configured
   * post message handler (`config.onPostMessage`).
   *
   * @param {Event} event The postMessage event
   * @return {void}
   * @protected
   */
  prototype._onPostMessage = function _onPostMessage(event) {
    var expectedOriginMatches = this.config.originRegexp.exec(this.uri);
    var expectedOrigin = expectedOriginMatches && expectedOriginMatches[0] || location.origin;
    if (this._window === event.source && event.origin === expectedOrigin) {
      this.config.onPostMessage.call(this, event);
    }
  };

  /**
   * Changes the URI
   * @param {String} uri The new URI
   * @throws {Error} If the window is open
   * @return {PromiseWindow} Returns this object to allow chaining
   */
  prototype.setURI = function setURI(uri) {
    if (this.isOpen()) {
      throw new Error('Cannot change the URI while the window is open');
    }
    this.uri = uri;
    return this;
  };

  /**
   * Opens a new popup window.
   *
   * @return {Promise} Returns a new `Promise` object. This promise will be:
   *                   - rejected with `"blocked"` message if the popup window
   *                     does not open for any reason (popup blocker, etc...)
   *                   - rejected with `"closed"` if closed either manually by
   *                     the user, or programatically
   *                   - rejected with the given error if the web page opened in
   *                     the popup sends a post message with a `error` data field.
   *                   - resolved with the given data if the web page opened in
   *                     the popup sends a post message without a `error` data
   *                     field.
   */
  prototype.open = function open() {
    if (this.isOpen()) {
      throw new Error('Window is already open');
    }

    this._windowOpen = true;
    var promise = this._createPromise();
    this._window = root.open(
      this.uri,
      this.config.windowName,
      this._getFeatures()
    );
    if (!this._window) {
      this._reject("blocked");
    }
    else {
      root.addEventListener("message", this._onPostMessage, true);
      this._startWatcher();
    }
    return promise;
  };

  /**
   * Closes the popup window.
   *
   * @return {void}
   */
  prototype.close = function close() {
    if (!this.isOpen()) {
      throw new Error('Window is already closed');
    }
    this._stopWatcher();
    root.removeEventListener("message", this._onPostMessage);
    if (this._isWindowAlive()) {
      this.config.onClose.call(this);
    }
    this._reject("closed");
    this._window = null;
    this._windowOpen = false;
  };

  /**
   * Checks whether the window is open or not
   * @return {Boolean} Returns `true` if the window is opened, `false` otherwise.
   */
  prototype.isOpen = function isOpen() {
    return this._windowOpen;
  };

  // Exports PromiseWindow to the global scope
  /* jshint ignore:start */
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return PromiseWindow }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
  /* jshint ignore:end */

})();


/***/ }),

/***/ "./node_modules/pseudomap/map.js":
/*!***************************************!*\
  !*** ./node_modules/pseudomap/map.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {if (process.env.npm_package_name === 'pseudomap' &&
    process.env.npm_lifecycle_script === 'test')
  process.env.TEST_PSEUDOMAP = 'true'

if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
  module.exports = Map
} else {
  module.exports = __webpack_require__(/*! ./pseudomap */ "./node_modules/pseudomap/pseudomap.js")
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pseudomap/pseudomap.js":
/*!*********************************************!*\
  !*** ./node_modules/pseudomap/pseudomap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty

module.exports = PseudoMap

function PseudoMap (set) {
  if (!(this instanceof PseudoMap)) // whyyyyyyy
    throw new TypeError("Constructor PseudoMap requires 'new'")

  this.clear()

  if (set) {
    if ((set instanceof PseudoMap) ||
        (typeof Map === 'function' && set instanceof Map))
      set.forEach(function (value, key) {
        this.set(key, value)
      }, this)
    else if (Array.isArray(set))
      set.forEach(function (kv) {
        this.set(kv[0], kv[1])
      }, this)
    else
      throw new TypeError('invalid argument')
  }
}

PseudoMap.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  Object.keys(this._data).forEach(function (k) {
    if (k !== 'size')
      fn.call(thisp, this._data[k].value, this._data[k].key)
  }, this)
}

PseudoMap.prototype.has = function (k) {
  return !!find(this._data, k)
}

PseudoMap.prototype.get = function (k) {
  var res = find(this._data, k)
  return res && res.value
}

PseudoMap.prototype.set = function (k, v) {
  set(this._data, k, v)
}

PseudoMap.prototype.delete = function (k) {
  var res = find(this._data, k)
  if (res) {
    delete this._data[res._index]
    this._data.size--
  }
}

PseudoMap.prototype.clear = function () {
  var data = Object.create(null)
  data.size = 0

  Object.defineProperty(this, '_data', {
    value: data,
    enumerable: false,
    configurable: true,
    writable: false
  })
}

Object.defineProperty(PseudoMap.prototype, 'size', {
  get: function () {
    return this._data.size
  },
  set: function (n) {},
  enumerable: true,
  configurable: true
})

PseudoMap.prototype.values =
PseudoMap.prototype.keys =
PseudoMap.prototype.entries = function () {
  throw new Error('iterators are not implemented in this version')
}

// Either identical, or both NaN
function same (a, b) {
  return a === b || a !== a && b !== b
}

function Entry (k, v, i) {
  this.key = k
  this.value = v
  this._index = i
}

function find (data, k) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k))
      return data[key]
  }
}

function set (data, k, v) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k)) {
      data[key].value = v
      return
    }
  }
  data.size++
  data[key] = new Entry(k, v, key)
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}


/***/ }),

/***/ "./src/discourse.js":
/*!**************************!*\
  !*** ./src/discourse.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.array.for-each */ "./node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__(/*! core-js/modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");

__webpack_require__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! core-js/modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");

__webpack_require__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__(/*! core-js/modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");

__webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _discourseAuth = _interopRequireDefault(__webpack_require__(/*! ./discourseAuth */ "./src/discourseAuth.js"));

var _discourseApi = _interopRequireDefault(__webpack_require__(/*! ./discourseApi */ "./src/discourseApi.js"));

var _promiseWindow = _interopRequireDefault(__webpack_require__(/*! promise-window */ "./node_modules/promise-window/dist/promise-window.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DiscourseClient =
/*#__PURE__*/
function () {
  function DiscourseClient(options) {
    _classCallCheck(this, DiscourseClient);

    this._requireOptions(options);

    this.options = this._formatOptions(options);
    this.auth = new _discourseAuth.default(this.options);
    this.api = new _discourseApi.default(this.options.apiBaseUrl);
  }

  _createClass(DiscourseClient, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.auth.init();

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_requireOptions",
    value: function _requireOptions(options) {
      options && _typeof(options) === 'object' || function (e) {
        throw e;
      }(new Error('Options must be an object'));
      typeof options.appName === 'string' && options.appName.length > 0 || function (e) {
        throw e;
      }(new Error('options.appName must be a non-empty string'));
      typeof options.apiBaseUrl === 'string' && options.apiBaseUrl.length > 0 || function (e) {
        throw e;
      }(new Error('Options.apiBaseUrl must be a non-empty string'));
      options.scopes instanceof Array && options.scopes.length > 0 || function (e) {
        throw e;
      }(new Error('Options.scopes must be a non-empty array'));
    }
  }, {
    key: "_formatOptions",
    value: function _formatOptions(options) {
      var formattedOptions = _objectSpread({}, options); // remove trailing slash


      formattedOptions.apiBaseUrl = options.apiBaseUrl.replace(/\/$/, '');
      formattedOptions.scopes = options.scopes.join(',');
      return formattedOptions;
    }
  }, {
    key: "getApiBaseUrl",
    value: function getApiBaseUrl() {
      return this.options.apiBaseUrl;
    }
  }, {
    key: "isLoggedIn",
    value: function () {
      var _isLoggedIn = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.auth._hasUserApiKey()) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", false);

              case 2:
                _context2.prev = 2;
                _context2.next = 5;
                return this._refreshCurrentUser();

              case 5:
                return _context2.abrupt("return", true);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);
                return _context2.abrupt("return", false);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 8]]);
      }));

      function isLoggedIn() {
        return _isLoggedIn.apply(this, arguments);
      }

      return isLoggedIn;
    }()
  }, {
    key: "getCurrentUser",
    value: function getCurrentUser() {
      return JSON.parse(localStorage.getItem('currentUser'));
    }
  }, {
    key: "getCurrentUserName",
    value: function getCurrentUserName() {
      return this.getCurrentUser()['username'];
    }
  }, {
    key: "getCurrentUserDisplayName",
    value: function getCurrentUserDisplayName() {
      return this.getCurrentUser()['name'];
    }
  }, {
    key: "isCurrentUserSilenced",
    value: function isCurrentUserSilenced() {
      return !this.getCurrentUser()['can_create_topic'];
    }
  }, {
    key: "getCurrentUserAvatarUrl",
    value: function getCurrentUserAvatarUrl(size) {
      return [this.options.apiBaseUrl, this.getCurrentUser()['avatar_template'].replace('{size}', size || 110)].join('/');
    }
  }, {
    key: "getCurrentUserNotificationsUrl",
    value: function getCurrentUserNotificationsUrl() {
      return [this.options.apiBaseUrl, 'u', this.getCurrentUserName(), 'notifications'].join('/');
    }
  }, {
    key: "_refreshCurrentUser",
    value: function () {
      var _refreshCurrentUser2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.t0 = localStorage;
                _context3.t1 = JSON;
                _context3.next = 5;
                return this.api.getCurrentSessionUser();

              case 5:
                _context3.t2 = _context3.sent;
                _context3.t3 = _context3.t1.stringify.call(_context3.t1, _context3.t2);

                _context3.t0.setItem.call(_context3.t0, 'currentUser', _context3.t3);

                _context3.next = 15;
                break;

              case 10:
                _context3.prev = 10;
                _context3.t4 = _context3["catch"](0);
                _context3.next = 14;
                return this.logout();

              case 14:
                throw new Error('Not logged in.');

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 10]]);
      }));

      function _refreshCurrentUser() {
        return _refreshCurrentUser2.apply(this, arguments);
      }

      return _refreshCurrentUser;
    }()
  }, {
    key: "login",
    value: function () {
      var _login = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.isLoggedIn();

              case 2:
                if (!_context5.sent) {
                  _context5.next = 4;
                  break;
                }

                return _context5.abrupt("return");

              case 4:
                _context5.t0 = _promiseWindow.default;
                _context5.next = 7;
                return this.auth._getLoginUrl();

              case 7:
                _context5.t1 = _context5.sent;
                _context5.t2 = {
                  width: 700,
                  height: 650,
                  originRegexp: new RegExp('^' + location.origin)
                };

                _context5.t3 =
                /*#__PURE__*/
                function () {
                  var _ref = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee4(data) {
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return _this.api._setUserApiKey(data.result.key);

                          case 2:
                            _context4.next = 4;
                            return _this._refreshCurrentUser();

                          case 4:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, this);
                  }));

                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }();

                _context5.t4 = // Error
                function (error) {
                  switch (error) {
                    case 'closed':
                      dispatchEvent(new Event('discourseLoginCanceled'));
                      throw new Error('Authentication popup window closed by the user');

                    case 'blocked':
                      dispatchEvent(new Event('discourseLoginBlocked'));
                      throw new Error('Authentication popup window blocked by the browser');

                    default:
                      throw new Error('Authentication popup window returned an error: ', error);
                  }
                };

                _context5.t5 = function () {
                  return dispatchEvent(new Event('discourseLoggedIn'));
                };

                _context5.next = 14;
                return _context5.t0.open.call(_context5.t0, _context5.t1, _context5.t2).then(_context5.t3, _context5.t4).then(_context5.t5);

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function login() {
        return _login.apply(this, arguments);
      }

      return login;
    }()
  }, {
    key: "logout",
    value: function () {
      var _logout = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.api.logout(this.getCurrentUserName());

              case 2:
                this.auth._clearAuthData();

                dispatchEvent(new Event('discourseLoggedOut'));

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
  }]);

  return DiscourseClient;
}(); // Debug only


exports.default = DiscourseClient;
window.DiscourseClient = DiscourseClient;

/***/ }),

/***/ "./src/discourseApi.js":
/*!*****************************!*\
  !*** ./src/discourseApi.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! core-js/modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! core-js/modules/es6.array.reduce */ "./node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _axios = _interopRequireDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));

var _axiosExtensions = __webpack_require__(/*! axios-extensions */ "./node_modules/axios-extensions/esm/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DiscourseApi =
/*#__PURE__*/
function () {
  function DiscourseApi(apiBaseUrl) {
    _classCallCheck(this, DiscourseApi);

    this.apiBaseUrl = apiBaseUrl;
    this.api = _axios.default.create({
      baseURL: this.apiBaseUrl,
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/json'
      },
      adapter: (0, _axiosExtensions.throttleAdapterEnhancer)((0, _axiosExtensions.cacheAdapterEnhancer)(_axios.default.defaults.adapter), {
        threshold: 500 // 200 reqs/min

      })
    });

    this._setUserApiKey(localStorage.getItem('user_api_key'));
  }

  _createClass(DiscourseApi, [{
    key: "_getCallResult",
    value: function () {
      var _getCallResult2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(endpoint, prop) {
        var nocache,
            response,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                nocache = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;
                _context.prev = 1;
                _context.next = 4;
                return this.api.get(endpoint, {
                  forceUpdate: nocache
                });

              case 4:
                response = _context.sent.data;
                _context.next = 10;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](1);
                throw new Error(_context.t0);

              case 10:
                if (prop) {
                  response = prop.split('.').reduce(function (returnedResponse, currentProp) {
                    return returnedResponse[currentProp];
                  }, response);
                }

                return _context.abrupt("return", response);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 7]]);
      }));

      function _getCallResult(_x, _x2) {
        return _getCallResult2.apply(this, arguments);
      }

      return _getCallResult;
    }()
  }, {
    key: "_postCallResult",
    value: function () {
      var _postCallResult2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(endpoint, payload) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.api.post(endpoint, payload);

              case 2:
                return _context2.abrupt("return", _context2.sent.data);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _postCallResult(_x3, _x4) {
        return _postCallResult2.apply(this, arguments);
      }

      return _postCallResult;
    }()
  }, {
    key: "_setUserApiKey",
    value: function () {
      var _setUserApiKey2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(userApiKey) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (userApiKey) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                this.api.defaults.headers.common['User-Api-Key'] = userApiKey;
                _context3.next = 5;
                return this._setCsrfToken();

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _setUserApiKey(_x5) {
        return _setUserApiKey2.apply(this, arguments);
      }

      return _setUserApiKey;
    }()
  }, {
    key: "_setCsrfToken",
    value: function () {
      var _setCsrfToken2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._getCallResult('/session/csrf.json', 'csrf');

              case 2:
                this.api.defaults.headers.common['X-CSRF-Token'] = _context4.sent;

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _setCsrfToken() {
        return _setCsrfToken2.apply(this, arguments);
      }

      return _setCsrfToken;
    }()
  }, {
    key: "_enforceUserApiKey",
    value: function _enforceUserApiKey() {
      this.api.defaults.headers.common['User-Api-Key'] || function (e) {
        throw e;
      }(new Error('User API key not set'));
    }
  }, {
    key: "getCurrentSessionUser",
    value: function () {
      var _getCurrentSessionUser = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._getCallResult('/session/current.json', 'current_user', true);

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getCurrentSessionUser() {
        return _getCurrentSessionUser.apply(this, arguments);
      }

      return getCurrentSessionUser;
    }()
  }, {
    key: "getLatestPosts",
    value: function () {
      var _getLatestPosts = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(descending) {
        var posts;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return this._getCallResult('/posts.json', 'latest_posts');

              case 3:
                posts = _context6.sent;
                _context6.next = 9;
                break;

              case 6:
                _context6.prev = 6;
                _context6.t0 = _context6["catch"](0);
                throw new Error(_context6.t0);

              case 9:
                if (descending) {
                  posts = posts.reverse();
                }

                return _context6.abrupt("return", posts.filter(function (post) {
                  return post.post_type === 1;
                }));

              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 6]]);
      }));

      function getLatestPosts(_x6) {
        return _getLatestPosts.apply(this, arguments);
      }

      return getLatestPosts;
    }()
  }, {
    key: "getPostsInTopic",
    value: function () {
      var _getPostsInTopic = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(topicId, descending, nocache) {
        var posts;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._getCallResult('/t/' + topicId + '/posts.json?include_raw=true', 'post_stream.posts', nocache);

              case 2:
                posts = _context7.sent;

                if (descending) {
                  posts = posts.reverse();
                }

                return _context7.abrupt("return", posts.filter(function (post) {
                  return post.post_type === 1;
                }));

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getPostsInTopic(_x7, _x8, _x9) {
        return _getPostsInTopic.apply(this, arguments);
      }

      return getPostsInTopic;
    }()
  }, {
    key: "getTopic",
    value: function () {
      var _getTopic = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(topicId, descending) {
        var topic;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._getCallResult('/t/' + topicId + '.json?include_raw=true');

              case 2:
                topic = _context8.sent;
                topic.post_stream.posts = topic.post_stream.posts.filter(function (post) {
                  return post.post_type === 1;
                });

                if (descending) {
                  topic.post_stream.posts = topic.post_stream.posts.reverse();
                }

                return _context8.abrupt("return", topic);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getTopic(_x10, _x11) {
        return _getTopic.apply(this, arguments);
      }

      return getTopic;
    }()
  }, {
    key: "getPublicUserFields",
    value: function () {
      var _getPublicUserFields = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(username) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._getCallResult('/u/' + username + '.json?stats=false', 'user.user_fields');

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getPublicUserFields(_x12) {
        return _getPublicUserFields.apply(this, arguments);
      }

      return getPublicUserFields;
    }()
  }, {
    key: "getFirstPublicUserField",
    value: function () {
      var _getFirstPublicUserField = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(username) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this._getCallResult('/u/' + username + '.json?stats=false', 'user.user_fields.1');

              case 2:
                return _context10.abrupt("return", _context10.sent);

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getFirstPublicUserField(_x13) {
        return _getFirstPublicUserField.apply(this, arguments);
      }

      return getFirstPublicUserField;
    }()
  }, {
    key: "postMessage",
    value: function () {
      var _postMessage = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(topicId, message) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this._enforceUserApiKey();

                _context11.next = 3;
                return this._postCallResult('/posts.json', {
                  /* eslint-disable camelcase */
                  topic_id: topicId,
                  raw: message
                  /* eslint-enable camelcase */

                }).then(function (response) {
                  response.hidden && Promise.reject(response.hidden_reason_id);
                  return response;
                }).catch(function (error) {
                  return Promise.reject(error.response.data.errors);
                });

              case 3:
                return _context11.abrupt("return", _context11.sent);

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function postMessage(_x14, _x15) {
        return _postMessage.apply(this, arguments);
      }

      return postMessage;
    }()
  }, {
    key: "logout",
    value: function () {
      var _logout = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(username) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this._enforceUserApiKey(); // await this.api.delete('/session/' + username); // Not yet supported


                _context12.next = 3;
                return this.api.post('/user-api-key/revoke');

              case 3:
                delete this.api.defaults.headers.common['User-Api-Key'];
                delete this.api.defaults.headers.common['X-CSRF-Token'];

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function logout(_x16) {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
  }]);

  return DiscourseApi;
}();

exports.default = DiscourseApi;

/***/ }),

/***/ "./src/discourseAuth.js":
/*!******************************!*\
  !*** ./src/discourseAuth.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! core-js/modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__(/*! core-js/modules/es6.date.to-string */ "./node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");

__webpack_require__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! core-js/modules/es6.array.map */ "./node_modules/core-js/modules/es6.array.map.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _keyManager = _interopRequireDefault(__webpack_require__(/*! ./keyManager */ "./src/keyManager.js"));

var _urlSearchParams = _interopRequireDefault(__webpack_require__(/*! @ungap/url-search-params */ "./node_modules/@ungap/url-search-params/esm/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// polyfill
// import MobileDetect from 'mobile-detect';
var DiscourseAuth =
/*#__PURE__*/
function () {
  function DiscourseAuth(options) {
    _classCallCheck(this, DiscourseAuth);

    this.appId = this._slugify(options.appName);
    this.km = new _keyManager.default(this.appId);
    this.options = options;
  }

  _createClass(DiscourseAuth, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.km.getKeys();

              case 2:
                this._hasUserApiKey() || this._managePayload();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_hasUserApiKey",
    value: function _hasUserApiKey() {
      return localStorage.getItem('user_api_key') !== null;
    }
  }, {
    key: "_getLoginUrl",
    value: function () {
      var _getLoginUrl2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var params;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = this.options.appName;
                _context2.next = 3;
                return this.km.getPublicKey();

              case 3:
                _context2.t1 = _context2.sent;
                _context2.t2 = this._generateStoredRandom('nonce');
                _context2.t3 = this._getStoredRandom('clientId') || this._generateStoredRandom('clientId');
                _context2.t4 = location.href;
                _context2.t5 = this.options.scopes;
                params = {
                  application_name: _context2.t0,
                  public_key: _context2.t1,
                  nonce: _context2.t2,
                  client_id: _context2.t3,
                  auth_redirect: _context2.t4,
                  scopes: _context2.t5
                };
                return _context2.abrupt("return", this.options.apiBaseUrl + '/user-api-key/new?' + this._serializeParams(params));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getLoginUrl() {
        return _getLoginUrl2.apply(this, arguments);
      }

      return _getLoginUrl;
    }()
  }, {
    key: "_serializeParams",
    value: function _serializeParams(params) {
      return Object.keys(params).map(function (k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
      }).join('&');
    }
  }, {
    key: "_generateStoredRandom",
    value: function _generateStoredRandom(name) {
      var storedRandom = Math.random().toString(16).substr(2);
      localStorage.setItem(this.appId + '_' + name, storedRandom);
      return storedRandom;
    }
  }, {
    key: "_getStoredRandom",
    value: function _getStoredRandom(name) {
      var storedRandom = localStorage.getItem(this.appId + '_' + name);
      return storedRandom;
    }
  }, {
    key: "_removeStoredRandom",
    value: function _removeStoredRandom(name) {
      localStorage.removeItem(this.appId + '_' + name);
    }
  }, {
    key: "_getUserApiKey",
    value: function _getUserApiKey() {
      return localStorage.getItem('user_api_key');
    }
  }, {
    key: "_clearAuthData",
    value: function _clearAuthData() {
      localStorage.removeItem('user_api_key');
      localStorage.removeItem('currentUser');

      this._removeStoredRandom('clientId');
    }
  }, {
    key: "_managePayload",
    value: function _managePayload() {
      var _this = this;

      var url = new _urlSearchParams.default(window.location.search || window.location.hash.split('?')[1]);

      if (url.has('payload') && opener) {
        this.km.decryptPayload(url.get('payload')).then(function (payloadObject) {
          payloadObject.nonce === _this._getStoredRandom('nonce') || function (e) {
            throw e;
          }(new Error('The returned payload is invalid.'));
          payloadObject.api === 3 || function (e) {
            throw e;
          }(new Error('Wrong API version: ' + payloadObject.api + '. Discourse-js works with API version 3.'));
          localStorage.setItem('user_api_key', payloadObject.key);

          _this._removeStoredRandom('nonce');

          opener.postMessage({
            result: payloadObject
          }, location.origin);
        });
      } // var md = new MobileDetect(window.navigator.userAgent);

    }
  }, {
    key: "_slugify",
    value: function _slugify(text) {
      return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
    }
  }]);

  return DiscourseAuth;
}();

exports.default = DiscourseAuth;

/***/ }),

/***/ "./src/keyGenerator.js":
/*!*****************************!*\
  !*** ./src/keyGenerator.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

var forge = __webpack_require__(/*! ./vendor/forge-pki */ "./src/vendor/forge-pki.js");

var _default = function () {
  var generate = function generate(appId) {
    return new Promise(function (resolve, reject) {
      forge.rsa.generateKeyPair({
        workerScript: '/prime-worker.min.js'
      }, function (error, generatedKeypair) {
        generatedKeypair ? function () {
          var keypair = {
            public: forge.pki.publicKeyToPem(generatedKeypair.publicKey, 72).replace(/\r/g, ''),
            private: forge.pki.privateKeyToPem(generatedKeypair.privateKey, 72).replace(/\r/g, '')
          };
          localStorage.setItem(appId + '_publicKey', keypair.public);
          localStorage.setItem(appId + '_privateKey', keypair.private);
          resolve(keypair);
        }() : reject(error);
      });
    });
  };

  return {
    generate: generate
  };
}();

exports.default = _default;

/***/ }),

/***/ "./src/keyManager.js":
/*!***************************!*\
  !*** ./src/keyManager.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var KeyManager =
/*#__PURE__*/
function () {
  function KeyManager(appId) {
    _classCallCheck(this, KeyManager);

    this.appId = appId;
  }

  _createClass(KeyManager, [{
    key: "generateNewKeypair",
    value: function () {
      var _generateNewKeypair = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve(/*! import() | keyGenerator */).then(__webpack_require__.t.bind(null, /*! ./keyGenerator */ "./src/keyGenerator.js", 7)).then(function (_ref) {
                  var keyGenerator = _ref.default;
                  return keyGenerator.generate(_this.appId).then(function (keypair) {
                    return keypair;
                  });
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function generateNewKeypair() {
        return _generateNewKeypair.apply(this, arguments);
      }

      return generateNewKeypair;
    }()
  }, {
    key: "getKeys",
    value: function () {
      var _getKeys = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = this.readKeysFromStorage();

                if (_context2.t0) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 4;
                return this.generateNewKeypair();

              case 4:
                _context2.t0 = _context2.sent;

              case 5:
                return _context2.abrupt("return", _context2.t0);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getKeys() {
        return _getKeys.apply(this, arguments);
      }

      return getKeys;
    }()
  }, {
    key: "readKeysFromStorage",
    value: function readKeysFromStorage() {
      var publicKey = localStorage.getItem(this.appId + '_publicKey');
      var privateKey = localStorage.getItem(this.appId + '_privateKey');
      return publicKey && privateKey ? {
        public: publicKey,
        private: privateKey
      } : null;
    }
  }, {
    key: "getPublicKey",
    value: function () {
      var _getPublicKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getKeys();

              case 2:
                return _context3.abrupt("return", _context3.sent['public']);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPublicKey() {
        return _getPublicKey.apply(this, arguments);
      }

      return getPublicKey;
    }()
  }, {
    key: "getPrivateKey",
    value: function () {
      var _getPrivateKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getKeys();

              case 2:
                return _context4.abrupt("return", _context4.sent['private']);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPrivateKey() {
        return _getPrivateKey.apply(this, arguments);
      }

      return getPrivateKey;
    }()
  }, {
    key: "decryptPayload",
    value: function () {
      var _decryptPayload = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(payload) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.getPrivateKey().then(function (privateKey) {
                  return Promise.resolve(/*! import() | jsencrypt */).then(__webpack_require__.t.bind(null, /*! jsencrypt */ "./node_modules/jsencrypt/bin/jsencrypt.js", 7)).then(function (_ref2) {
                    var Jsencrypt = _ref2.default;
                    var jsencrypt = new Jsencrypt();
                    jsencrypt.setPrivateKey(privateKey);
                    return JSON.parse(jsencrypt.decrypt(payload));
                  });
                }));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function decryptPayload(_x) {
        return _decryptPayload.apply(this, arguments);
      }

      return decryptPayload;
    }()
  }]);

  return KeyManager;
}();

exports.default = KeyManager;
;

/***/ }),

/***/ "./src/vendor/forge-pki.js":
/*!*********************************!*\
  !*** ./src/vendor/forge-pki.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, Buffer, module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(/*! core-js/modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");__webpack_require__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");__webpack_require__(/*! core-js/modules/es6.typed.uint32-array */ "./node_modules/core-js/modules/es6.typed.uint32-array.js");__webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");__webpack_require__(/*! core-js/modules/es6.regexp.match */ "./node_modules/core-js/modules/es6.regexp.match.js");__webpack_require__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");__webpack_require__(/*! core-js/modules/es6.array.reduce */ "./node_modules/core-js/modules/es6.array.reduce.js");__webpack_require__(/*! core-js/modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");__webpack_require__(/*! core-js/modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");__webpack_require__(/*! core-js/modules/es6.array.index-of */ "./node_modules/core-js/modules/es6.array.index-of.js");__webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");__webpack_require__(/*! core-js/modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");__webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");__webpack_require__(/*! core-js/modules/es6.typed.uint16-array */ "./node_modules/core-js/modules/es6.typed.uint16-array.js");__webpack_require__(/*! core-js/modules/es6.typed.data-view */ "./node_modules/core-js/modules/es6.typed.data-view.js");__webpack_require__(/*! core-js/modules/es6.typed.uint8-array */ "./node_modules/core-js/modules/es6.typed.uint8-array.js");__webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");__webpack_require__(/*! core-js/modules/es6.date.to-string */ "./node_modules/core-js/modules/es6.date.to-string.js");__webpack_require__(/*! core-js/modules/es6.array.is-array */ "./node_modules/core-js/modules/es6.array.is-array.js");__webpack_require__(/*! core-js/modules/es6.date.now */ "./node_modules/core-js/modules/es6.date.now.js");__webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");__webpack_require__(/*! core-js/modules/es6.array.for-each */ "./node_modules/core-js/modules/es6.array.for-each.js");__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}(function webpackUniversalModuleDefinition(root,factory){if(( false?undefined:_typeof(exports))==='object'&&( false?undefined:_typeof(module))==='object')module.exports=factory();else if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(typeof self!=='undefined'?self:void 0,function(){return(/******/function(modules){// webpackBootstrap
/******/ // The module cache
/******/var installedModules={};/******/ /******/ // The require function
/******/function __webpack_require__(moduleId){/******/ /******/ // Check if module is in cache
/******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/ // Create a new module (and put it into the cache)
/******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******/ /******/ // Execute the module function
/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******/ /******/ // Flag the module as loaded
/******/module.l=true;/******/ /******/ // Return the exports of the module
/******/return module.exports;/******/}/******/ /******/ /******/ // expose the modules object (__webpack_modules__)
/******/__webpack_require__.m=modules;/******/ /******/ // expose the module cache
/******/__webpack_require__.c=installedModules;/******/ /******/ // define getter function for harmony exports
/******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{/******/configurable:false,/******/enumerable:true,/******/get:getter/******/});/******/}/******/};/******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
/******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******/ /******/ // Object.prototype.hasOwnProperty.call
/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******/ /******/ // __webpack_public_path__
/******/__webpack_require__.p="";/******/ /******/ // Load entry module and return exports
/******/return __webpack_require__(__webpack_require__.s=20);/******/}(/************************************************************************/ /******/[/* 0 */ /***/function(module,exports){/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */module.exports={// default options
options:{usePureJavaScript:false}};/***/},/* 1 */ /***/function(module,exports,__webpack_require__){/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);var baseN=__webpack_require__(22);/* Utilities API */var util=module.exports=forge.util=forge.util||{};// define setImmediate and nextTick
(function(){// use native nextTick (unless we're in webpack)
// webpack (or better node-libs-browser polyfill) sets process.browser.
// this way we can detect webpack properly
if(typeof process!=='undefined'&&process.nextTick&&!process.browser){util.nextTick=process.nextTick;if(typeof setImmediate==='function'){util.setImmediate=setImmediate;}else{// polyfill setImmediate with nextTick, older versions of node
// (those w/o setImmediate) won't totally starve IO
util.setImmediate=util.nextTick;}return;}// polyfill nextTick with native setImmediate
if(typeof setImmediate==='function'){util.setImmediate=function(){return setImmediate.apply(undefined,arguments);};util.nextTick=function(callback){return setImmediate(callback);};return;}/* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */ // polyfill with setTimeout
util.setImmediate=function(callback){setTimeout(callback,0);};// upgrade polyfill to use postMessage
if(typeof window!=='undefined'&&typeof window.postMessage==='function'){var handler=function handler(event){if(event.source===window&&event.data===msg){event.stopPropagation();var copy=callbacks.slice();callbacks.length=0;copy.forEach(function(callback){callback();});}};var msg='forge.setImmediate';var callbacks=[];util.setImmediate=function(callback){callbacks.push(callback);// only send message when one hasn't been sent in
// the current turn of the event loop
if(callbacks.length===1){window.postMessage(msg,'*');}};window.addEventListener('message',handler,true);}// upgrade polyfill to use MutationObserver
if(typeof MutationObserver!=='undefined'){// polyfill with MutationObserver
var now=Date.now();var attr=true;var div=document.createElement('div');var callbacks=[];new MutationObserver(function(){var copy=callbacks.slice();callbacks.length=0;copy.forEach(function(callback){callback();});}).observe(div,{attributes:true});var oldSetImmediate=util.setImmediate;util.setImmediate=function(callback){if(Date.now()-now>15){now=Date.now();oldSetImmediate(callback);}else{callbacks.push(callback);// only trigger observer when it hasn't been triggered in
// the current turn of the event loop
if(callbacks.length===1){div.setAttribute('a',attr=!attr);}}};}util.nextTick=util.setImmediate;})();// check if running under Node.js
util.isNodejs=typeof process!=='undefined'&&process.versions&&process.versions.node;// define isArray
util.isArray=Array.isArray||function(x){return Object.prototype.toString.call(x)==='[object Array]';};// define isArrayBuffer
util.isArrayBuffer=function(x){return typeof ArrayBuffer!=='undefined'&&x instanceof ArrayBuffer;};// define isArrayBufferView
util.isArrayBufferView=function(x){return x&&util.isArrayBuffer(x.buffer)&&x.byteLength!==undefined;};/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */function _checkBitsParam(n){if(!(n===8||n===16||n===24||n===32)){throw new Error('Only 8, 16, 24, or 32 bits supported: '+n);}}// TODO: set ByteBuffer to best available backing
util.ByteBuffer=ByteStringBuffer;/** Buffer w/BinaryString backing */ /**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */function ByteStringBuffer(b){// TODO: update to match DataBuffer API
// the data in this buffer
this.data='';// the pointer for reading from this buffer
this.read=0;if(typeof b==='string'){this.data=b;}else if(util.isArrayBuffer(b)||util.isArrayBufferView(b)){if(typeof Buffer!=='undefined'&&b instanceof Buffer){this.data=b.toString('binary');}else{// convert native buffer to forge buffer
// FIXME: support native buffers internally instead
var arr=new Uint8Array(b);try{this.data=String.fromCharCode.apply(null,arr);}catch(e){for(var i=0;i<arr.length;++i){this.putByte(arr[i]);}}}}else if(b instanceof ByteStringBuffer||_typeof(b)==='object'&&typeof b.data==='string'&&typeof b.read==='number'){// copy existing buffer
this.data=b.data;this.read=b.read;}// used for v8 optimization
this._constructedStringLength=0;}util.ByteStringBuffer=ByteStringBuffer;/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */var _MAX_CONSTRUCTED_STRING_LENGTH=4096;util.ByteStringBuffer.prototype._optimizeConstructedString=function(x){this._constructedStringLength+=x;if(this._constructedStringLength>_MAX_CONSTRUCTED_STRING_LENGTH){// this substr() should cause the constructed string to join
this.data.substr(0,1);this._constructedStringLength=0;}};/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */util.ByteStringBuffer.prototype.length=function(){return this.data.length-this.read;};/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */util.ByteStringBuffer.prototype.isEmpty=function(){return this.length()<=0;};/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putByte=function(b){return this.putBytes(String.fromCharCode(b));};/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.fillWithByte=function(b,n){b=String.fromCharCode(b);var d=this.data;while(n>0){if(n&1){d+=b;}n>>>=1;if(n>0){b+=b;}}this.data=d;this._optimizeConstructedString(n);return this;};/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a UTF-8 encoded string) to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putBytes=function(bytes){this.data+=bytes;this._optimizeConstructedString(bytes.length);return this;};/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putString=function(str){return this.putBytes(util.encodeUtf8(str));};/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt16=function(i){return this.putBytes(String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt24=function(i){return this.putBytes(String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt32=function(i){return this.putBytes(String.fromCharCode(i>>24&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt16Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF));};/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt24Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i>>16&0xFF));};/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt32Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>24&0xFF));};/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt=function(i,n){_checkBitsParam(n);var bytes='';do{n-=8;bytes+=String.fromCharCode(i>>n&0xFF);}while(n>0);return this.putBytes(bytes);};/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putSignedInt=function(i,n){// putInt checks n
if(i<0){i+=2<<n-1;}return this.putInt(i,n);};/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putBuffer=function(buffer){return this.putBytes(buffer.getBytes());};/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */util.ByteStringBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++);};/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.ByteStringBuffer.prototype.getInt16=function(){var rval=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.ByteStringBuffer.prototype.getInt24=function(){var rval=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.ByteStringBuffer.prototype.getInt32=function(){var rval=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);this.read+=4;return rval;};/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.ByteStringBuffer.prototype.getInt16Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.ByteStringBuffer.prototype.getInt24Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.ByteStringBuffer.prototype.getInt32Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;this.read+=4;return rval;};/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.ByteStringBuffer.prototype.getInt=function(n){_checkBitsParam(n);var rval=0;do{// TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
rval=(rval<<8)+this.data.charCodeAt(this.read++);n-=8;}while(n>0);return rval;};/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.ByteStringBuffer.prototype.getSignedInt=function(n){// getInt checks n
var x=this.getInt(n);var max=2<<n-2;if(x>=max){x-=max<<1;}return x;};/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */util.ByteStringBuffer.prototype.getBytes=function(count){var rval;if(count){// read count bytes
count=Math.min(this.length(),count);rval=this.data.slice(this.read,this.read+count);this.read+=count;}else if(count===0){rval='';}else{// read all bytes, optimize to only copy when needed
rval=this.read===0?this.data:this.data.slice(this.read);this.clear();}return rval;};/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */util.ByteStringBuffer.prototype.bytes=function(count){return typeof count==='undefined'?this.data.slice(this.read):this.data.slice(this.read,this.read+count);};/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */util.ByteStringBuffer.prototype.at=function(i){return this.data.charCodeAt(this.read+i);};/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.setAt=function(i,b){this.data=this.data.substr(0,this.read+i)+String.fromCharCode(b)+this.data.substr(this.read+i+1);return this;};/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */util.ByteStringBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1);};/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */util.ByteStringBuffer.prototype.copy=function(){var c=util.createBuffer(this.data);c.read=this.read;return c;};/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.compact=function(){if(this.read>0){this.data=this.data.slice(this.read);this.read=0;}return this;};/**
 * Clears this buffer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.clear=function(){this.data='';this.read=0;return this;};/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.truncate=function(count){var len=Math.max(0,this.length()-count);this.data=this.data.substr(this.read,len);this.read=0;return this;};/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */util.ByteStringBuffer.prototype.toHex=function(){var rval='';for(var i=this.read;i<this.data.length;++i){var b=this.data.charCodeAt(i);if(b<16){rval+='0';}rval+=b.toString(16);}return rval;};/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */util.ByteStringBuffer.prototype.toString=function(){return util.decodeUtf8(this.bytes());};/** End Buffer w/BinaryString backing */ /** Buffer w/UInt8Array backing */ /**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */function DataBuffer(b,options){// default options
options=options||{};// pointers for read from/write to buffer
this.read=options.readOffset||0;this.growSize=options.growSize||1024;var isArrayBuffer=util.isArrayBuffer(b);var isArrayBufferView=util.isArrayBufferView(b);if(isArrayBuffer||isArrayBufferView){// use ArrayBuffer directly
if(isArrayBuffer){this.data=new DataView(b);}else{// TODO: adjust read/write offset based on the type of view
// or specify that this must be done in the options ... that the
// offsets are byte-based
this.data=new DataView(b.buffer,b.byteOffset,b.byteLength);}this.write='writeOffset'in options?options.writeOffset:this.data.byteLength;return;}// initialize to empty array buffer and add any given bytes using putBytes
this.data=new DataView(new ArrayBuffer(0));this.write=0;if(b!==null&&b!==undefined){this.putBytes(b);}if('writeOffset'in options){this.write=options.writeOffset;}}util.DataBuffer=DataBuffer;/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */util.DataBuffer.prototype.length=function(){return this.write-this.read;};/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */util.DataBuffer.prototype.isEmpty=function(){return this.length()<=0;};/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */util.DataBuffer.prototype.accommodate=function(amount,growSize){if(this.length()>=amount){return this;}growSize=Math.max(growSize||this.growSize,amount);// grow buffer
var src=new Uint8Array(this.data.buffer,this.data.byteOffset,this.data.byteLength);var dst=new Uint8Array(this.length()+growSize);dst.set(src);this.data=new DataView(dst.buffer);return this;};/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putByte=function(b){this.accommodate(1);this.data.setUint8(this.write++,b);return this;};/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.fillWithByte=function(b,n){this.accommodate(n);for(var i=0;i<n;++i){this.data.setUint8(b);}return this;};/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putBytes=function(bytes,encoding){if(util.isArrayBufferView(bytes)){var src=new Uint8Array(bytes.buffer,bytes.byteOffset,bytes.byteLength);var len=src.byteLength-src.byteOffset;this.accommodate(len);var dst=new Uint8Array(this.data.buffer,this.write);dst.set(src);this.write+=len;return this;}if(util.isArrayBuffer(bytes)){var src=new Uint8Array(bytes);this.accommodate(src.byteLength);var dst=new Uint8Array(this.data.buffer);dst.set(src,this.write);this.write+=src.byteLength;return this;}// bytes is a util.DataBuffer or equivalent
if(bytes instanceof util.DataBuffer||_typeof(bytes)==='object'&&typeof bytes.read==='number'&&typeof bytes.write==='number'&&util.isArrayBufferView(bytes.data)){var src=new Uint8Array(bytes.data.byteLength,bytes.read,bytes.length());this.accommodate(src.byteLength);var dst=new Uint8Array(bytes.data.byteLength,this.write);dst.set(src);this.write+=src.byteLength;return this;}if(bytes instanceof util.ByteStringBuffer){// copy binary string and process as the same as a string parameter below
bytes=bytes.data;encoding='binary';}// string conversion
encoding=encoding||'binary';if(typeof bytes==='string'){var view;// decode from string
if(encoding==='hex'){this.accommodate(Math.ceil(bytes.length/2));view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.hex.decode(bytes,view,this.write);return this;}if(encoding==='base64'){this.accommodate(Math.ceil(bytes.length/4)*3);view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.base64.decode(bytes,view,this.write);return this;}// encode text as UTF-8 bytes
if(encoding==='utf8'){// encode as UTF-8 then decode string as raw binary
bytes=util.encodeUtf8(bytes);encoding='binary';}// decode string as raw binary
if(encoding==='binary'||encoding==='raw'){// one byte per character
this.accommodate(bytes.length);view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.raw.decode(view);return this;}// encode text as UTF-16 bytes
if(encoding==='utf16'){// two bytes per character
this.accommodate(bytes.length*2);view=new Uint16Array(this.data.buffer,this.write);this.write+=util.text.utf16.encode(view);return this;}throw new Error('Invalid encoding: '+encoding);}throw Error('Invalid parameter: '+bytes);};/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putBuffer=function(buffer){this.putBytes(buffer);buffer.clear();return this;};/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putString=function(str){return this.putBytes(str,'utf16');};/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt16=function(i){this.accommodate(2);this.data.setInt16(this.write,i);this.write+=2;return this;};/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt24=function(i){this.accommodate(3);this.data.setInt16(this.write,i>>8&0xFFFF);this.data.setInt8(this.write,i>>16&0xFF);this.write+=3;return this;};/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt32=function(i){this.accommodate(4);this.data.setInt32(this.write,i);this.write+=4;return this;};/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt16Le=function(i){this.accommodate(2);this.data.setInt16(this.write,i,true);this.write+=2;return this;};/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt24Le=function(i){this.accommodate(3);this.data.setInt8(this.write,i>>16&0xFF);this.data.setInt16(this.write,i>>8&0xFFFF,true);this.write+=3;return this;};/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt32Le=function(i){this.accommodate(4);this.data.setInt32(this.write,i,true);this.write+=4;return this;};/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt=function(i,n){_checkBitsParam(n);this.accommodate(n/8);do{n-=8;this.data.setInt8(this.write++,i>>n&0xFF);}while(n>0);return this;};/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putSignedInt=function(i,n){_checkBitsParam(n);this.accommodate(n/8);if(i<0){i+=2<<n-1;}return this.putInt(i,n);};/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */util.DataBuffer.prototype.getByte=function(){return this.data.getInt8(this.read++);};/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.DataBuffer.prototype.getInt16=function(){var rval=this.data.getInt16(this.read);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.DataBuffer.prototype.getInt24=function(){var rval=this.data.getInt16(this.read)<<8^this.data.getInt8(this.read+2);this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.DataBuffer.prototype.getInt32=function(){var rval=this.data.getInt32(this.read);this.read+=4;return rval;};/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.DataBuffer.prototype.getInt16Le=function(){var rval=this.data.getInt16(this.read,true);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.DataBuffer.prototype.getInt24Le=function(){var rval=this.data.getInt8(this.read)^this.data.getInt16(this.read+1,true)<<8;this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.DataBuffer.prototype.getInt32Le=function(){var rval=this.data.getInt32(this.read,true);this.read+=4;return rval;};/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.DataBuffer.prototype.getInt=function(n){_checkBitsParam(n);var rval=0;do{// TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
rval=(rval<<8)+this.data.getInt8(this.read++);n-=8;}while(n>0);return rval;};/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.DataBuffer.prototype.getSignedInt=function(n){// getInt checks n
var x=this.getInt(n);var max=2<<n-2;if(x>=max){x-=max<<1;}return x;};/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */util.DataBuffer.prototype.getBytes=function(count){// TODO: deprecate this method, it is poorly named and
// this.toString('binary') replaces it
// add a toTypedArray()/toArrayBuffer() function
var rval;if(count){// read count bytes
count=Math.min(this.length(),count);rval=this.data.slice(this.read,this.read+count);this.read+=count;}else if(count===0){rval='';}else{// read all bytes, optimize to only copy when needed
rval=this.read===0?this.data:this.data.slice(this.read);this.clear();}return rval;};/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */util.DataBuffer.prototype.bytes=function(count){// TODO: deprecate this method, it is poorly named, add "getString()"
return typeof count==='undefined'?this.data.slice(this.read):this.data.slice(this.read,this.read+count);};/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */util.DataBuffer.prototype.at=function(i){return this.data.getUint8(this.read+i);};/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.setAt=function(i,b){this.data.setUint8(i,b);return this;};/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */util.DataBuffer.prototype.last=function(){return this.data.getUint8(this.write-1);};/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */util.DataBuffer.prototype.copy=function(){return new util.DataBuffer(this);};/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.compact=function(){if(this.read>0){var src=new Uint8Array(this.data.buffer,this.read);var dst=new Uint8Array(src.byteLength);dst.set(src);this.data=new DataView(dst);this.write-=this.read;this.read=0;}return this;};/**
 * Clears this buffer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.clear=function(){this.data=new DataView(new ArrayBuffer(0));this.read=this.write=0;return this;};/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.truncate=function(count){this.write=Math.max(0,this.length()-count);this.read=Math.min(this.read,this.write);return this;};/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */util.DataBuffer.prototype.toHex=function(){var rval='';for(var i=this.read;i<this.data.byteLength;++i){var b=this.data.getUint8(i);if(b<16){rval+='0';}rval+=b.toString(16);}return rval;};/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */util.DataBuffer.prototype.toString=function(encoding){var view=new Uint8Array(this.data,this.read,this.length());encoding=encoding||'utf8';// encode to string
if(encoding==='binary'||encoding==='raw'){return util.binary.raw.encode(view);}if(encoding==='hex'){return util.binary.hex.encode(view);}if(encoding==='base64'){return util.binary.base64.encode(view);}// decode to text
if(encoding==='utf8'){return util.text.utf8.decode(view);}if(encoding==='utf16'){return util.text.utf16.decode(view);}throw new Error('Invalid encoding: '+encoding);};/** End Buffer w/UInt8Array backing */ /**
 * Creates a buffer that stores bytes. A value may be given to put into the
 * buffer that is either a string of bytes or a UTF-16 string that will
 * be encoded using UTF-8 (to do the latter, specify 'utf8' as the encoding).
 *
 * @param [input] the bytes to wrap (as a string) or a UTF-16 string to encode
 *          as UTF-8.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */util.createBuffer=function(input,encoding){// TODO: deprecate, use new ByteBuffer() instead
encoding=encoding||'raw';if(input!==undefined&&encoding==='utf8'){input=util.encodeUtf8(input);}return new util.ByteBuffer(input);};/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */util.fillString=function(c,n){var s='';while(n>0){if(n&1){s+=c;}n>>>=1;if(n>0){c+=c;}}return s;};/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */util.xorBytes=function(s1,s2,n){var s3='';var b='';var t='';var i=0;var c=0;for(;n>0;--n,++i){b=s1.charCodeAt(i)^s2.charCodeAt(i);if(c>=10){s3+=t;t='';c=0;}t+=String.fromCharCode(b);++c;}s3+=t;return s3;};/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */util.hexToBytes=function(hex){// TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
var rval='';var i=0;if(hex.length&1==1){// odd number of characters, convert first character alone
i=1;rval+=String.fromCharCode(parseInt(hex[0],16));}// convert 2 characters (1 byte) at a time
for(;i<hex.length;i+=2){rval+=String.fromCharCode(parseInt(hex.substr(i,2),16));}return rval;};/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */util.bytesToHex=function(bytes){// TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
return util.createBuffer(bytes).toHex();};/**
 * Converts an 32-bit integer to 4-big-endian byte string.
 *
 * @param i the integer.
 *
 * @return the byte string.
 */util.int32ToBytes=function(i){return String.fromCharCode(i>>24&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF);};// base64 characters, reverse mapping
var _base64='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';var _base64Idx=[/*43 -43 = 0*/ /*'+',  1,  2,  3,'/' */62,-1,-1,-1,63,/*'0','1','2','3','4','5','6','7','8','9' */52,53,54,55,56,57,58,59,60,61,/*15, 16, 17,'=', 19, 20, 21 */-1,-1,-1,64,-1,-1,-1,/*65 - 43 = 22*/ /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */0,1,2,3,4,5,6,7,8,9,10,11,12,/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */13,14,15,16,17,18,19,20,21,22,23,24,25,/*91 - 43 = 48 */ /*48, 49, 50, 51, 52, 53 */-1,-1,-1,-1,-1,-1,/*97 - 43 = 54*/ /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */26,27,28,29,30,31,32,33,34,35,36,37,38,/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */39,40,41,42,43,44,45,46,47,48,49,50,51];// base58 characters (Bitcoin alphabet)
var _base58='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';/**
 * Base64 encodes a 'binary' encoded string of bytes.
 *
 * @param input the binary encoded string of bytes to base64-encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output.
 */util.encode64=function(input,maxline){// TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
var line='';var output='';var chr1,chr2,chr3;var i=0;while(i<input.length){chr1=input.charCodeAt(i++);chr2=input.charCodeAt(i++);chr3=input.charCodeAt(i++);// encode 4 character group
line+=_base64.charAt(chr1>>2);line+=_base64.charAt((chr1&3)<<4|chr2>>4);if(isNaN(chr2)){line+='==';}else{line+=_base64.charAt((chr2&15)<<2|chr3>>6);line+=isNaN(chr3)?'=':_base64.charAt(chr3&63);}if(maxline&&line.length>maxline){output+=line.substr(0,maxline)+'\r\n';line=line.substr(maxline);}}output+=line;return output;};/**
 * Base64 decodes a string into a 'binary' encoded string of bytes.
 *
 * @param input the base64-encoded input.
 *
 * @return the binary encoded string.
 */util.decode64=function(input){// TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."
// remove all non-base64 characters
input=input.replace(/[^A-Za-z0-9\+\/\=]/g,'');var output='';var enc1,enc2,enc3,enc4;var i=0;while(i<input.length){enc1=_base64Idx[input.charCodeAt(i++)-43];enc2=_base64Idx[input.charCodeAt(i++)-43];enc3=_base64Idx[input.charCodeAt(i++)-43];enc4=_base64Idx[input.charCodeAt(i++)-43];output+=String.fromCharCode(enc1<<2|enc2>>4);if(enc3!==64){// decoded at least 2 bytes
output+=String.fromCharCode((enc2&15)<<4|enc3>>2);if(enc4!==64){// decoded 3 bytes
output+=String.fromCharCode((enc3&3)<<6|enc4);}}}return output;};/**
 * UTF-8 encodes the given UTF-16 encoded string (a standard JavaScript
 * string). Non-ASCII characters will be encoded as multiple bytes according
 * to UTF-8.
 *
 * @param str the string to encode.
 *
 * @return the UTF-8 encoded string.
 */util.encodeUtf8=function(str){return unescape(encodeURIComponent(str));};/**
 * Decodes a UTF-8 encoded string into a UTF-16 string.
 *
 * @param str the string to decode.
 *
 * @return the UTF-16 encoded string (standard JavaScript string).
 */util.decodeUtf8=function(str){return decodeURIComponent(escape(str));};// binary encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.binary={raw:{},hex:{},base64:{},base58:{},baseN:{encode:baseN.encode,decode:baseN.decode}};/**
 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param bytes the Uint8Array to encode.
 *
 * @return the binary-encoded string.
 */util.binary.raw.encode=function(bytes){return String.fromCharCode.apply(null,bytes);};/**
 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param str the binary-encoded string to decode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.raw.decode=function(str,output,offset){var out=output;if(!out){out=new Uint8Array(str.length);}offset=offset||0;var j=offset;for(var i=0;i<str.length;++i){out[j++]=str.charCodeAt(i);}return output?j-offset:out;};/**
 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
 * ByteBuffer as a string of hexadecimal characters.
 *
 * @param bytes the bytes to convert.
 *
 * @return the string of hexadecimal characters.
 */util.binary.hex.encode=util.bytesToHex;/**
 * Decodes a hex-encoded string to a Uint8Array.
 *
 * @param hex the hexadecimal string to convert.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.hex.decode=function(hex,output,offset){var out=output;if(!out){out=new Uint8Array(Math.ceil(hex.length/2));}offset=offset||0;var i=0,j=offset;if(hex.length&1){// odd number of characters, convert first character alone
i=1;out[j++]=parseInt(hex[0],16);}// convert 2 characters (1 byte) at a time
for(;i<hex.length;i+=2){out[j++]=parseInt(hex.substr(i,2),16);}return output?j-offset:out;};/**
 * Base64-encodes a Uint8Array.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output string.
 */util.binary.base64.encode=function(input,maxline){var line='';var output='';var chr1,chr2,chr3;var i=0;while(i<input.byteLength){chr1=input[i++];chr2=input[i++];chr3=input[i++];// encode 4 character group
line+=_base64.charAt(chr1>>2);line+=_base64.charAt((chr1&3)<<4|chr2>>4);if(isNaN(chr2)){line+='==';}else{line+=_base64.charAt((chr2&15)<<2|chr3>>6);line+=isNaN(chr3)?'=':_base64.charAt(chr3&63);}if(maxline&&line.length>maxline){output+=line.substr(0,maxline)+'\r\n';line=line.substr(maxline);}}output+=line;return output;};/**
 * Decodes a base64-encoded string to a Uint8Array.
 *
 * @param input the base64-encoded input string.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.base64.decode=function(input,output,offset){var out=output;if(!out){out=new Uint8Array(Math.ceil(input.length/4)*3);}// remove all non-base64 characters
input=input.replace(/[^A-Za-z0-9\+\/\=]/g,'');offset=offset||0;var enc1,enc2,enc3,enc4;var i=0,j=offset;while(i<input.length){enc1=_base64Idx[input.charCodeAt(i++)-43];enc2=_base64Idx[input.charCodeAt(i++)-43];enc3=_base64Idx[input.charCodeAt(i++)-43];enc4=_base64Idx[input.charCodeAt(i++)-43];out[j++]=enc1<<2|enc2>>4;if(enc3!==64){// decoded at least 2 bytes
out[j++]=(enc2&15)<<4|enc3>>2;if(enc4!==64){// decoded 3 bytes
out[j++]=(enc3&3)<<6|enc4;}}}// make sure result is the exact decoded length
return output?j-offset:out.subarray(0,j);};// add support for base58 encoding/decoding with Bitcoin alphabet
util.binary.base58.encode=function(input,maxline){return util.binary.baseN.encode(input,_base58,maxline);};util.binary.base58.decode=function(input,maxline){return util.binary.baseN.decode(input,_base58,maxline);};// text encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.text={utf8:{},utf16:{}};/**
 * Encodes the given string as UTF-8 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.text.utf8.encode=function(str,output,offset){str=util.encodeUtf8(str);var out=output;if(!out){out=new Uint8Array(str.length);}offset=offset||0;var j=offset;for(var i=0;i<str.length;++i){out[j++]=str.charCodeAt(i);}return output?j-offset:out;};/**
 * Decodes the UTF-8 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */util.text.utf8.decode=function(bytes){return util.decodeUtf8(String.fromCharCode.apply(null,bytes));};/**
 * Encodes the given string as UTF-16 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.text.utf16.encode=function(str,output,offset){var out=output;if(!out){out=new Uint8Array(str.length*2);}var view=new Uint16Array(out.buffer);offset=offset||0;var j=offset;var k=offset;for(var i=0;i<str.length;++i){view[k++]=str.charCodeAt(i);j+=2;}return output?j-offset:out;};/**
 * Decodes the UTF-16 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */util.text.utf16.decode=function(bytes){return String.fromCharCode.apply(null,new Uint16Array(bytes.buffer));};/**
 * Deflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true to return only raw deflate data, false to include zlib
 *          header and trailer.
 *
 * @return the deflated data as a string.
 */util.deflate=function(api,bytes,raw){bytes=util.decode64(api.deflate(util.encode64(bytes)).rval);// strip zlib header and trailer if necessary
if(raw){// zlib header is 2 bytes (CMF,FLG) where FLG indicates that
// there is a 4-byte DICT (alder-32) block before the data if
// its 5th bit is set
var start=2;var flg=bytes.charCodeAt(1);if(flg&0x20){start=6;}// zlib trailer is 4 bytes of adler-32
bytes=bytes.substring(start,bytes.length-4);}return bytes;};/**
 * Inflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true if the incoming data has no zlib header or trailer and is
 *          raw DEFLATE data.
 *
 * @return the inflated data as a string, null on error.
 */util.inflate=function(api,bytes,raw){// TODO: add zlib header and trailer if necessary/possible
var rval=api.inflate(util.encode64(bytes)).rval;return rval===null?null:util.decode64(rval);};/**
 * Sets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param obj the storage object, null to remove.
 */var _setStorageObject=function _setStorageObject(api,id,obj){if(!api){throw new Error('WebStorage not available.');}var rval;if(obj===null){rval=api.removeItem(id);}else{// json-encode and base64-encode object
obj=util.encode64(JSON.stringify(obj));rval=api.setItem(id,obj);}// handle potential flash error
if(typeof rval!=='undefined'&&rval.rval!==true){var error=new Error(rval.error.message);error.id=rval.error.id;error.name=rval.error.name;throw error;}};/**
 * Gets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 *
 * @return the storage object entry or null if none exists.
 */var _getStorageObject=function _getStorageObject(api,id){if(!api){throw new Error('WebStorage not available.');}// get the existing entry
var rval=api.getItem(id);/* Note: We check api.init because we can't do (api == localStorage)
    on IE because of "Class doesn't support Automation" exception. Only
    the flash api has an init method so this works too, but we need a
    better solution in the future. */ // flash returns item wrapped in an object, handle special case
if(api.init){if(rval.rval===null){if(rval.error){var error=new Error(rval.error.message);error.id=rval.error.id;error.name=rval.error.name;throw error;}// no error, but also no item
rval=null;}else{rval=rval.rval;}}// handle decoding
if(rval!==null){// base64-decode and json-decode data
rval=JSON.parse(util.decode64(rval));}return rval;};/**
 * Stores an item in local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 */var _setItem=function _setItem(api,id,key,data){// get storage object
var obj=_getStorageObject(api,id);if(obj===null){// create a new storage object
obj={};}// update key
obj[key]=data;// set storage object
_setStorageObject(api,id,obj);};/**
 * Gets an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 *
 * @return the item.
 */var _getItem=function _getItem(api,id,key){// get storage object
var rval=_getStorageObject(api,id);if(rval!==null){// return data at key
rval=key in rval?rval[key]:null;}return rval;};/**
 * Removes an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 */var _removeItem=function _removeItem(api,id,key){// get storage object
var obj=_getStorageObject(api,id);if(obj!==null&&key in obj){// remove key
delete obj[key];// see if entry has no keys remaining
var empty=true;for(var prop in obj){empty=false;break;}if(empty){// remove entry entirely if no keys are left
obj=null;}// set storage object
_setStorageObject(api,id,obj);}};/**
 * Clears the local disk storage identified by the given ID.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 */var _clearItems=function _clearItems(api,id){_setStorageObject(api,id,null);};/**
 * Calls a storage function.
 *
 * @param func the function to call.
 * @param args the arguments for the function.
 * @param location the location argument.
 *
 * @return the return value from the function.
 */var _callStorageFunction=function _callStorageFunction(func,args,location){var rval=null;// default storage types
if(typeof location==='undefined'){location=['web','flash'];}// apply storage types in order of preference
var type;var done=false;var exception=null;for(var idx in location){type=location[idx];try{if(type==='flash'||type==='both'){if(args[0]===null){throw new Error('Flash local storage not available.');}rval=func.apply(this,args);done=type==='flash';}if(type==='web'||type==='both'){args[0]=localStorage;rval=func.apply(this,args);done=true;}}catch(ex){exception=ex;}if(done){break;}}if(!done){throw exception;}return rval;};/**
 * Stores an item on local disk.
 *
 * The available types of local storage include 'flash', 'web', and 'both'.
 *
 * The type 'flash' refers to flash local storage (SharedObject). In order
 * to use flash local storage, the 'api' parameter must be valid. The type
 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
 * refers to storing using both 'flash' and 'web', not just one or the
 * other.
 *
 * The location array should list the storage types to use in order of
 * preference:
 *
 * ['flash']: flash only storage
 * ['web']: web only storage
 * ['both']: try to store in both
 * ['flash','web']: store in flash first, but if not available, 'web'
 * ['web','flash']: store in web first, but if not available, 'flash'
 *
 * The location array defaults to: ['web', 'flash']
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 * @param location an array with the preferred types of storage to use.
 */util.setItem=function(api,id,key,data,location){_callStorageFunction(_setItem,arguments,location);};/**
 * Gets an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 *
 * @return the item.
 */util.getItem=function(api,id,key,location){return _callStorageFunction(_getItem,arguments,location);};/**
 * Removes an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 */util.removeItem=function(api,id,key,location){_callStorageFunction(_removeItem,arguments,location);};/**
 * Clears the local disk storage identified by the given ID.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface if flash is available.
 * @param id the storage ID to use.
 * @param location an array with the preferred types of storage to use.
 */util.clearItems=function(api,id,location){_callStorageFunction(_clearItems,arguments,location);};/**
 * Parses the scheme, host, and port from an http(s) url.
 *
 * @param str the url string.
 *
 * @return the parsed url object or null if the url is invalid.
 */util.parseUrl=function(str){// FIXME: this regex looks a bit broken
var regex=/^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;regex.lastIndex=0;var m=regex.exec(str);var url=m===null?null:{full:str,scheme:m[1],host:m[2],port:m[3],path:m[4]};if(url){url.fullHost=url.host;if(url.port){if(url.port!==80&&url.scheme==='http'){url.fullHost+=':'+url.port;}else if(url.port!==443&&url.scheme==='https'){url.fullHost+=':'+url.port;}}else if(url.scheme==='http'){url.port=80;}else if(url.scheme==='https'){url.port=443;}url.full=url.scheme+'://'+url.fullHost;}return url;};/* Storage for query variables */var _queryVariables=null;/**
 * Returns the window location query variables. Query is parsed on the first
 * call and the same object is returned on subsequent calls. The mapping
 * is from keys to an array of values. Parameters without values will have
 * an object key set but no value added to the value array. Values are
 * unescaped.
 *
 * ...?k1=v1&k2=v2:
 * {
 *   "k1": ["v1"],
 *   "k2": ["v2"]
 * }
 *
 * ...?k1=v1&k1=v2:
 * {
 *   "k1": ["v1", "v2"]
 * }
 *
 * ...?k1=v1&k2:
 * {
 *   "k1": ["v1"],
 *   "k2": []
 * }
 *
 * ...?k1=v1&k1:
 * {
 *   "k1": ["v1"]
 * }
 *
 * ...?k1&k1:
 * {
 *   "k1": []
 * }
 *
 * @param query the query string to parse (optional, default to cached
 *          results from parsing window location search query).
 *
 * @return object mapping keys to variables.
 */util.getQueryVariables=function(query){var parse=function parse(q){var rval={};var kvpairs=q.split('&');for(var i=0;i<kvpairs.length;i++){var pos=kvpairs[i].indexOf('=');var key;var val;if(pos>0){key=kvpairs[i].substring(0,pos);val=kvpairs[i].substring(pos+1);}else{key=kvpairs[i];val=null;}if(!(key in rval)){rval[key]=[];}// disallow overriding object prototype keys
if(!(key in Object.prototype)&&val!==null){rval[key].push(unescape(val));}}return rval;};var rval;if(typeof query==='undefined'){// set cached variables if needed
if(_queryVariables===null){if(typeof window!=='undefined'&&window.location&&window.location.search){// parse window search query
_queryVariables=parse(window.location.search.substring(1));}else{// no query variables available
_queryVariables={};}}rval=_queryVariables;}else{// parse given query
rval=parse(query);}return rval;};/**
 * Parses a fragment into a path and query. This method will take a URI
 * fragment and break it up as if it were the main URI. For example:
 *    /bar/baz?a=1&b=2
 * results in:
 *    {
 *       path: ["bar", "baz"],
 *       query: {"k1": ["v1"], "k2": ["v2"]}
 *    }
 *
 * @return object with a path array and query object.
 */util.parseFragment=function(fragment){// default to whole fragment
var fp=fragment;var fq='';// split into path and query if possible at the first '?'
var pos=fragment.indexOf('?');if(pos>0){fp=fragment.substring(0,pos);fq=fragment.substring(pos+1);}// split path based on '/' and ignore first element if empty
var path=fp.split('/');if(path.length>0&&path[0]===''){path.shift();}// convert query into object
var query=fq===''?{}:util.getQueryVariables(fq);return{pathString:fp,queryString:fq,path:path,query:query};};/**
 * Makes a request out of a URI-like request string. This is intended to
 * be used where a fragment id (after a URI '#') is parsed as a URI with
 * path and query parts. The string should have a path beginning and
 * delimited by '/' and optional query parameters following a '?'. The
 * query should be a standard URL set of key value pairs delimited by
 * '&'. For backwards compatibility the initial '/' on the path is not
 * required. The request object has the following API, (fully described
 * in the method code):
 *    {
 *       path: <the path string part>.
 *       query: <the query string part>,
 *       getPath(i): get part or all of the split path array,
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */util.makeRequest=function(reqString){var frag=util.parseFragment(reqString);var req={// full path string
path:frag.pathString,// full query string
query:frag.queryString,/**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */getPath:function getPath(i){return typeof i==='undefined'?frag.path:frag.path[i];},/**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */getQuery:function getQuery(k,i){var rval;if(typeof k==='undefined'){rval=frag.query;}else{rval=frag.query[k];if(rval&&typeof i!=='undefined'){rval=rval[i];}}return rval;},getQueryLast:function getQueryLast(k,_default){var rval;var vals=req.getQuery(k);if(vals){rval=vals[vals.length-1];}else{rval=_default;}return rval;}};return req;};/**
 * Makes a URI out of a path, an object with query parameters, and a
 * fragment. Uses jQuery.param() internally for query string creation.
 * If the path is an array, it will be joined with '/'.
 *
 * @param path string path or array of strings.
 * @param query object with query parameters. (optional)
 * @param fragment fragment string. (optional)
 *
 * @return string object with request parameters.
 */util.makeLink=function(path,query,fragment){// join path parts if needed
path=jQuery.isArray(path)?path.join('/'):path;var qstr=jQuery.param(query||{});fragment=fragment||'';return path+(qstr.length>0?'?'+qstr:'')+(fragment.length>0?'#'+fragment:'');};/**
 * Follows a path of keys deep into an object hierarchy and set a value.
 * If a key does not exist or it's value is not an object, create an
 * object in it's place. This can be destructive to a object tree if
 * leaf nodes are given as non-final path keys.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param value the value to set.
 */util.setPath=function(object,keys,value){// need to start at an object
if(_typeof(object)==='object'&&object!==null){var i=0;var len=keys.length;while(i<len){var next=keys[i++];if(i==len){// last
object[next]=value;}else{// more
var hasNext=next in object;if(!hasNext||hasNext&&_typeof(object[next])!=='object'||hasNext&&object[next]===null){object[next]={};}object=object[next];}}}};/**
 * Follows a path of keys deep into an object hierarchy and return a value.
 * If a key does not exist, create an object in it's place.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param _default value to return if path not found.
 *
 * @return the value at the path if found, else default if given, else
 *         undefined.
 */util.getPath=function(object,keys,_default){var i=0;var len=keys.length;var hasNext=true;while(hasNext&&i<len&&_typeof(object)==='object'&&object!==null){var next=keys[i++];hasNext=next in object;if(hasNext){object=object[next];}}return hasNext?object:_default;};/**
 * Follow a path of keys deep into an object hierarchy and delete the
 * last one. If a key does not exist, do nothing.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 */util.deletePath=function(object,keys){// need to start at an object
if(_typeof(object)==='object'&&object!==null){var i=0;var len=keys.length;while(i<len){var next=keys[i++];if(i==len){// last
delete object[next];}else{// more
if(!(next in object)||_typeof(object[next])!=='object'||object[next]===null){break;}object=object[next];}}}};/**
 * Check if an object is empty.
 *
 * Taken from:
 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
 *
 * @param object the object to check.
 */util.isEmpty=function(obj){for(var prop in obj){if(obj.hasOwnProperty(prop)){return false;}}return true;};/**
 * Format with simple printf-style interpolation.
 *
 * %%: literal '%'
 * %s,%o: convert next argument into a string.
 *
 * @param format the string to format.
 * @param ... arguments to interpolate into the format string.
 */util.format=function(format){var re=/%./g;// current match
var match;// current part
var part;// current arg index
var argi=0;// collected parts to recombine later
var parts=[];// last index found
var last=0;// loop while matches remain
while(match=re.exec(format)){part=format.substring(last,re.lastIndex-2);// don't add empty strings (ie, parts between %s%s)
if(part.length>0){parts.push(part);}last=re.lastIndex;// switch on % code
var code=match[0][1];switch(code){case's':case'o':// check if enough arguments were given
if(argi<arguments.length){parts.push(arguments[argi++ +1]);}else{parts.push('<?>');}break;// FIXME: do proper formating for numbers, etc
//case 'f':
//case 'd':
case'%':parts.push('%');break;default:parts.push('<%'+code+'?>');}}// add trailing part of format string
parts.push(format.substring(last));return parts.join('');};/**
 * Formats a number.
 *
 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
 */util.formatNumber=function(number,decimals,dec_point,thousands_sep){// http://kevin.vanzonneveld.net
// +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +     bugfix by: Michael White (http://crestidg.com)
// +     bugfix by: Benjamin Lupton
// +     bugfix by: Allan Jensen (http://www.winternet.no)
// +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
// *     example 1: number_format(1234.5678, 2, '.', '');
// *     returns 1: 1234.57
var n=number,c=isNaN(decimals=Math.abs(decimals))?2:decimals;var d=dec_point===undefined?',':dec_point;var t=thousands_sep===undefined?'.':thousands_sep,s=n<0?'-':'';var i=parseInt(n=Math.abs(+n||0).toFixed(c),10)+'';var j=i.length>3?i.length%3:0;return s+(j?i.substr(0,j)+t:'')+i.substr(j).replace(/(\d{3})(?=\d)/g,'$1'+t)+(c?d+Math.abs(n-i).toFixed(c).slice(2):'');};/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */util.formatSize=function(size){if(size>=1073741824){size=util.formatNumber(size/1073741824,2,'.','')+' GiB';}else if(size>=1048576){size=util.formatNumber(size/1048576,2,'.','')+' MiB';}else if(size>=1024){size=util.formatNumber(size/1024,0)+' KiB';}else{size=util.formatNumber(size,0)+' bytes';}return size;};/**
 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */util.bytesFromIP=function(ip){if(ip.indexOf('.')!==-1){return util.bytesFromIPv4(ip);}if(ip.indexOf(':')!==-1){return util.bytesFromIPv6(ip);}return null;};/**
 * Converts an IPv4 string representation into bytes (in network order).
 *
 * @param ip the IPv4 address to convert.
 *
 * @return the 4-byte address or null if the address can't be parsed.
 */util.bytesFromIPv4=function(ip){ip=ip.split('.');if(ip.length!==4){return null;}var b=util.createBuffer();for(var i=0;i<ip.length;++i){var num=parseInt(ip[i],10);if(isNaN(num)){return null;}b.putByte(num);}return b.getBytes();};/**
 * Converts an IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv6 address to convert.
 *
 * @return the 16-byte address or null if the address can't be parsed.
 */util.bytesFromIPv6=function(ip){var blanks=0;ip=ip.split(':').filter(function(e){if(e.length===0)++blanks;return true;});var zeros=(8-ip.length+blanks)*2;var b=util.createBuffer();for(var i=0;i<8;++i){if(!ip[i]||ip[i].length===0){b.fillWithByte(0,zeros);zeros=0;continue;}var bytes=util.hexToBytes(ip[i]);if(bytes.length<2){b.putByte(0);}b.putBytes(bytes);}return b.getBytes();};/**
 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
 * an IPv6 string representation. The bytes must be in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */util.bytesToIP=function(bytes){if(bytes.length===4){return util.bytesToIPv4(bytes);}if(bytes.length===16){return util.bytesToIPv6(bytes);}return null;};/**
 * Converts 4-bytes into an IPv4 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 string representation or null for an invalid # of bytes.
 */util.bytesToIPv4=function(bytes){if(bytes.length!==4){return null;}var ip=[];for(var i=0;i<bytes.length;++i){ip.push(bytes.charCodeAt(i));}return ip.join('.');};/**
 * Converts 16-bytes into an IPv16 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv16 string representation or null for an invalid # of bytes.
 */util.bytesToIPv6=function(bytes){if(bytes.length!==16){return null;}var ip=[];var zeroGroups=[];var zeroMaxGroup=0;for(var i=0;i<bytes.length;i+=2){var hex=util.bytesToHex(bytes[i]+bytes[i+1]);// canonicalize zero representation
while(hex[0]==='0'&&hex!=='0'){hex=hex.substr(1);}if(hex==='0'){var last=zeroGroups[zeroGroups.length-1];var idx=ip.length;if(!last||idx!==last.end+1){zeroGroups.push({start:idx,end:idx});}else{last.end=idx;if(last.end-last.start>zeroGroups[zeroMaxGroup].end-zeroGroups[zeroMaxGroup].start){zeroMaxGroup=zeroGroups.length-1;}}}ip.push(hex);}if(zeroGroups.length>0){var group=zeroGroups[zeroMaxGroup];// only shorten group of length > 0
if(group.end-group.start>0){ip.splice(group.start,group.end-group.start+1,'');if(group.start===0){ip.unshift('');}if(group.end===7){ip.push('');}}}return ip.join(':');};/**
 * Estimates the number of processes that can be run concurrently. If
 * creating Web Workers, keep in mind that the main JavaScript process needs
 * its own core.
 *
 * @param options the options to use:
 *          update true to force an update (not use the cached value).
 * @param callback(err, max) called once the operation completes.
 */util.estimateCores=function(options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};if('cores'in util&&!options.update){return callback(null,util.cores);}if(typeof navigator!=='undefined'&&'hardwareConcurrency'in navigator&&navigator.hardwareConcurrency>0){util.cores=navigator.hardwareConcurrency;return callback(null,util.cores);}if(typeof Worker==='undefined'){// workers not available
util.cores=1;return callback(null,util.cores);}if(typeof Blob==='undefined'){// can't estimate, default to 2
util.cores=2;return callback(null,util.cores);}// create worker concurrency estimation code as blob
var blobUrl=URL.createObjectURL(new Blob(['(',function(){self.addEventListener('message',function(e){// run worker for 4 ms
var st=Date.now();var et=st+4;while(Date.now()<et){;}self.postMessage({st:st,et:et});});}.toString(),')()'],{type:'application/javascript'}));// take 5 samples using 16 workers
sample([],5,16);function sample(max,samples,numWorkers){if(samples===0){// get overlap average
var avg=Math.floor(max.reduce(function(avg,x){return avg+x;},0)/max.length);util.cores=Math.max(1,avg);URL.revokeObjectURL(blobUrl);return callback(null,util.cores);}map(numWorkers,function(err,results){max.push(reduce(numWorkers,results));sample(max,samples-1,numWorkers);});}function map(numWorkers,callback){var workers=[];var results=[];for(var i=0;i<numWorkers;++i){var worker=new Worker(blobUrl);worker.addEventListener('message',function(e){results.push(e.data);if(results.length===numWorkers){for(var i=0;i<numWorkers;++i){workers[i].terminate();}callback(null,results);}});workers.push(worker);}for(var i=0;i<numWorkers;++i){workers[i].postMessage(i);}}function reduce(numWorkers,results){// find overlapping time windows
var overlaps=[];for(var n=0;n<numWorkers;++n){var r1=results[n];var overlap=overlaps[n]=[];for(var i=0;i<numWorkers;++i){if(n===i){continue;}var r2=results[i];if(r1.st>r2.st&&r1.st<r2.et||r2.st>r1.st&&r2.st<r1.et){overlap.push(i);}}}// get maximum overlaps ... don't include overlapping worker itself
// as the main JS process was also being scheduled during the work and
// would have to be subtracted from the estimate anyway
return overlaps.reduce(function(max,overlap){return Math.max(max,overlap.length);},0);}};/***/},/* 2 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of Abstract Syntax Notation Number One.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 *
 * An API for storing data using the Abstract Syntax Notation Number One
 * format using DER (Distinguished Encoding Rules) encoding. This encoding is
 * commonly used to store data for PKI, i.e. X.509 Certificates, and this
 * implementation exists for that purpose.
 *
 * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract
 * syntax of information without restricting the way the information is encoded
 * for transmission. It provides a standard that allows for open systems
 * communication. ASN.1 defines the syntax of information data and a number of
 * simple data types as well as a notation for describing them and specifying
 * values for them.
 *
 * The RSA algorithm creates public and private keys that are often stored in
 * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This
 * class provides the most basic functionality required to store and load DSA
 * keys that are encoded according to ASN.1.
 *
 * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)
 * and DER (Distinguished Encoding Rules). DER is just a subset of BER that
 * has stricter requirements for how data must be encoded.
 *
 * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)
 * and a byte array for the value of this ASN1 structure which may be data or a
 * list of ASN.1 structures.
 *
 * Each ASN.1 structure using BER is (Tag-Length-Value):
 *
 * | byte 0 | bytes X | bytes Y |
 * |--------|---------|----------
 * |  tag   | length  |  value  |
 *
 * ASN.1 allows for tags to be of "High-tag-number form" which allows a tag to
 * be two or more octets, but that is not supported by this class. A tag is
 * only 1 byte. Bits 1-5 give the tag number (ie the data type within a
 * particular 'class'), 6 indicates whether or not the ASN.1 value is
 * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If
 * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,
 * then the class is APPLICATION. If only bit 8 is set, then the class is
 * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.
 * The tag numbers for the data types for the class UNIVERSAL are listed below:
 *
 * UNIVERSAL 0 Reserved for use by the encoding rules
 * UNIVERSAL 1 Boolean type
 * UNIVERSAL 2 Integer type
 * UNIVERSAL 3 Bitstring type
 * UNIVERSAL 4 Octetstring type
 * UNIVERSAL 5 Null type
 * UNIVERSAL 6 Object identifier type
 * UNIVERSAL 7 Object descriptor type
 * UNIVERSAL 8 External type and Instance-of type
 * UNIVERSAL 9 Real type
 * UNIVERSAL 10 Enumerated type
 * UNIVERSAL 11 Embedded-pdv type
 * UNIVERSAL 12 UTF8String type
 * UNIVERSAL 13 Relative object identifier type
 * UNIVERSAL 14-15 Reserved for future editions
 * UNIVERSAL 16 Sequence and Sequence-of types
 * UNIVERSAL 17 Set and Set-of types
 * UNIVERSAL 18-22, 25-30 Character string types
 * UNIVERSAL 23-24 Time types
 *
 * The length of an ASN.1 structure is specified after the tag identifier.
 * There is a definite form and an indefinite form. The indefinite form may
 * be used if the encoding is constructed and not all immediately available.
 * The indefinite form is encoded using a length byte with only the 8th bit
 * set. The end of the constructed object is marked using end-of-contents
 * octets (two zero bytes).
 *
 * The definite form looks like this:
 *
 * The length may take up 1 or more bytes, it depends on the length of the
 * value of the ASN.1 structure. DER encoding requires that if the ASN.1
 * structure has a value that has a length greater than 127, more than 1 byte
 * will be used to store its length, otherwise just one byte will be used.
 * This is strict.
 *
 * In the case that the length of the ASN.1 value is less than 127, 1 octet
 * (byte) is used to store the "short form" length. The 8th bit has a value of
 * 0 indicating the length is "short form" and not "long form" and bits 7-1
 * give the length of the data. (The 8th bit is the left-most, most significant
 * bit: also known as big endian or network format).
 *
 * In the case that the length of the ASN.1 value is greater than 127, 2 to
 * 127 octets (bytes) are used to store the "long form" length. The first
 * byte's 8th bit is set to 1 to indicate the length is "long form." Bits 7-1
 * give the number of additional octets. All following octets are in base 256
 * with the most significant digit first (typical big-endian binary unsigned
 * integer storage). So, for instance, if the length of a value was 257, the
 * first byte would be set to:
 *
 * 10000010 = 130 = 0x82.
 *
 * This indicates there are 2 octets (base 256) for the length. The second and
 * third bytes (the octets just mentioned) would store the length in base 256:
 *
 * octet 2: 00000001 = 1 * 256^1 = 256
 * octet 3: 00000001 = 1 * 256^0 = 1
 * total = 257
 *
 * The algorithm for converting a js integer value of 257 to base-256 is:
 *
 * var value = 257;
 * var bytes = [];
 * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first
 * bytes[1] = value & 0xFF;        // least significant byte last
 *
 * On the ASN.1 UNIVERSAL Object Identifier (OID) type:
 *
 * An OID can be written like: "value1.value2.value3...valueN"
 *
 * The DER encoding rules:
 *
 * The first byte has the value 40 * value1 + value2.
 * The following bytes, if any, encode the remaining values. Each value is
 * encoded in base 128, most significant digit first (big endian), with as
 * few digits as possible, and the most significant bit of each byte set
 * to 1 except the last in each value's encoding. For example: Given the
 * OID "1.2.840.113549", its DER encoding is (remember each byte except the
 * last one in each encoding is OR'd with 0x80):
 *
 * byte 1: 40 * 1 + 2 = 42 = 0x2A.
 * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648
 * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D
 *
 * The final value is: 0x2A864886F70D.
 * The full OID (including ASN.1 tag and length of 6 bytes) is:
 * 0x06062A864886F70D
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(3);/* ASN.1 API */var asn1=module.exports=forge.asn1=forge.asn1||{};/**
 * ASN.1 classes.
 */asn1.Class={UNIVERSAL:0x00,APPLICATION:0x40,CONTEXT_SPECIFIC:0x80,PRIVATE:0xC0};/**
 * ASN.1 types. Not all types are supported by this implementation, only
 * those necessary to implement a simple PKI are implemented.
 */asn1.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30};/**
 * Creates a new asn1 object.
 *
 * @param tagClass the tag class for the object.
 * @param type the data type (tag number) for the object.
 * @param constructed true if the asn1 object is in constructed form.
 * @param value the value for the object, if it is not constructed.
 * @param [options] the options to use:
 *          [bitStringContents] the plain BIT STRING content including padding
 *            byte.
 *
 * @return the asn1 object.
 */asn1.create=function(tagClass,type,constructed,value,options){/* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */ // remove undefined values
if(forge.util.isArray(value)){var tmp=[];for(var i=0;i<value.length;++i){if(value[i]!==undefined){tmp.push(value[i]);}}value=tmp;}var obj={tagClass:tagClass,type:type,constructed:constructed,composed:constructed||forge.util.isArray(value),value:value};if(options&&'bitStringContents'in options){// TODO: copy byte buffer if it's a buffer not a string
obj.bitStringContents=options.bitStringContents;// TODO: add readonly flag to avoid this overhead
// save copy to detect changes
obj.original=asn1.copy(obj);}return obj;};/**
 * Copies an asn1 object.
 *
 * @param obj the asn1 object.
 * @param [options] copy options:
 *          [excludeBitStringContents] true to not copy bitStringContents
 *
 * @return the a copy of the asn1 object.
 */asn1.copy=function(obj,options){var copy;if(forge.util.isArray(obj)){copy=[];for(var i=0;i<obj.length;++i){copy.push(asn1.copy(obj[i],options));}return copy;}if(typeof obj==='string'){// TODO: copy byte buffer if it's a buffer not a string
return obj;}copy={tagClass:obj.tagClass,type:obj.type,constructed:obj.constructed,composed:obj.composed,value:asn1.copy(obj.value,options)};if(options&&!options.excludeBitStringContents){// TODO: copy byte buffer if it's a buffer not a string
copy.bitStringContents=obj.bitStringContents;}return copy;};/**
 * Compares asn1 objects for equality.
 *
 * Note this function does not run in constant time.
 *
 * @param obj1 the first asn1 object.
 * @param obj2 the second asn1 object.
 * @param [options] compare options:
 *          [includeBitStringContents] true to compare bitStringContents
 *
 * @return true if the asn1 objects are equal.
 */asn1.equals=function(obj1,obj2,options){if(forge.util.isArray(obj1)){if(!forge.util.isArray(obj2)){return false;}if(obj1.length!==obj2.length){return false;}for(var i=0;i<obj1.length;++i){if(!asn1.equals(obj1[i],obj2[i])){return false;}}return true;}if(_typeof(obj1)!==_typeof(obj2)){return false;}if(typeof obj1==='string'){return obj1===obj2;}var equal=obj1.tagClass===obj2.tagClass&&obj1.type===obj2.type&&obj1.constructed===obj2.constructed&&obj1.composed===obj2.composed&&asn1.equals(obj1.value,obj2.value);if(options&&options.includeBitStringContents){equal=equal&&obj1.bitStringContents===obj2.bitStringContents;}return equal;};/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param b the BER-encoded ASN.1 byte buffer, starting with the first
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */asn1.getBerValueLength=function(b){// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
var b2=b.getByte();if(b2===0x80){return undefined;}// see if the length is "short form" or "long form" (bit 8 set)
var length;var longForm=b2&0x80;if(!longForm){// length is just the first byte
length=b2;}else{// the number of bytes the length is specified in bits 7 through 1
// and each length byte is in big-endian base-256
length=b.getInt((b2&0x7F)<<3);}return length;};/**
 * Check if the byte buffer has enough bytes. Throws an Error if not.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 * @param n the number of bytes the buffer must have.
 */function _checkBufferLength(bytes,remaining,n){if(n>remaining){var error=new Error('Too few bytes to parse DER.');error.available=bytes.length();error.remaining=remaining;error.requested=n;throw error;}}/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */var _getValueLength=function _getValueLength(bytes,remaining){// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
// fromDer already checked that this byte exists
var b2=bytes.getByte();remaining--;if(b2===0x80){return undefined;}// see if the length is "short form" or "long form" (bit 8 set)
var length;var longForm=b2&0x80;if(!longForm){// length is just the first byte
length=b2;}else{// the number of bytes the length is specified in bits 7 through 1
// and each length byte is in big-endian base-256
var longFormBytes=b2&0x7F;_checkBufferLength(bytes,remaining,longFormBytes);length=bytes.getInt(longFormBytes<<3);}// FIXME: this will only happen for 32 bit getInt with high bit set
if(length<0){throw new Error('Negative length: '+length);}return length;};/**
 * Parses an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param [strict] true to be strict when checking value lengths, false to
 *          allow truncated values (default: true).
 * @param [options] object with options or boolean strict flag
 *          [strict] true to be strict when checking value lengths, false to
 *            allow truncated values (default: true).
 *          [decodeBitStrings] true to attempt to decode the content of
 *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
 *            without schema support to understand the data context this can
 *            erroneously decode values that happen to be valid ASN.1. This
 *            flag will be deprecated or removed as soon as schema support is
 *            available. (default: true)
 *
 * @return the parsed asn1 object.
 */asn1.fromDer=function(bytes,options){if(options===undefined){options={strict:true,decodeBitStrings:true};}if(typeof options==='boolean'){options={strict:options,decodeBitStrings:true};}if(!('strict'in options)){options.strict=true;}if(!('decodeBitStrings'in options)){options.decodeBitStrings=true;}// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}return _fromDer(bytes,bytes.length(),0,options);};/**
 * Internal function to parse an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the number of bytes remaining for this chunk.
 * @param depth the current parsing depth.
 * @param options object with same options as fromDer().
 *
 * @return the parsed asn1 object.
 */function _fromDer(bytes,remaining,depth,options){// temporary storage for consumption calculations
var start;// minimum length for ASN.1 DER structure is 2
_checkBufferLength(bytes,remaining,2);// get the first byte
var b1=bytes.getByte();// consumed one byte
remaining--;// get the tag class
var tagClass=b1&0xC0;// get the type (bits 1-5)
var type=b1&0x1F;// get the variable value length and adjust remaining bytes
start=bytes.length();var length=_getValueLength(bytes,remaining);remaining-=start-bytes.length();// ensure there are enough bytes to get the value
if(length!==undefined&&length>remaining){if(options.strict){var error=new Error('Too few bytes to read ASN.1 value.');error.available=bytes.length();error.remaining=remaining;error.requested=length;throw error;}// Note: be lenient with truncated values and use remaining state bytes
length=remaining;}// value storage
var value;// possible BIT STRING contents storage
var bitStringContents;// constructed flag is bit 6 (32 = 0x20) of the first byte
var constructed=(b1&0x20)===0x20;if(constructed){// parse child asn1 objects from the value
value=[];if(length===undefined){// asn1 object of indefinite length, read until end tag
for(;;){_checkBufferLength(bytes,remaining,2);if(bytes.bytes(2)===String.fromCharCode(0,0)){bytes.getBytes(2);remaining-=2;break;}start=bytes.length();value.push(_fromDer(bytes,remaining,depth+1,options));remaining-=start-bytes.length();}}else{// parsing asn1 object of definite length
while(length>0){start=bytes.length();value.push(_fromDer(bytes,length,depth+1,options));remaining-=start-bytes.length();length-=start-bytes.length();}}}// if a BIT STRING, save the contents including padding
if(value===undefined&&tagClass===asn1.Class.UNIVERSAL&&type===asn1.Type.BITSTRING){bitStringContents=bytes.bytes(length);}// determine if a non-constructed value should be decoded as a composed
// value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)
// can be used this way.
if(value===undefined&&options.decodeBitStrings&&tagClass===asn1.Class.UNIVERSAL&&// FIXME: OCTET STRINGs not yet supported here
// .. other parts of forge expect to decode OCTET STRINGs manually
type===asn1.Type.BITSTRING/*|| type === asn1.Type.OCTETSTRING*/&&length>1){// save read position
var savedRead=bytes.read;var savedRemaining=remaining;var unused=0;if(type===asn1.Type.BITSTRING){/* The first octet gives the number of bits by which the length of the
        bit string is less than the next multiple of eight (this is called
        the "number of unused bits").

        The second and following octets give the value of the bit string
        converted to an octet string. */_checkBufferLength(bytes,remaining,1);unused=bytes.getByte();remaining--;}// if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs
if(unused===0){try{// attempt to parse child asn1 object from the value
// (stored in array to signal composed value)
start=bytes.length();var subOptions={// enforce strict mode to avoid parsing ASN.1 from plain data
verbose:options.verbose,strict:true,decodeBitStrings:true};var composed=_fromDer(bytes,remaining,depth+1,subOptions);var used=start-bytes.length();remaining-=used;if(type==asn1.Type.BITSTRING){used++;}// if the data all decoded and the class indicates UNIVERSAL or
// CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object
var tc=composed.tagClass;if(used===length&&(tc===asn1.Class.UNIVERSAL||tc===asn1.Class.CONTEXT_SPECIFIC)){value=[composed];}}catch(ex){}}if(value===undefined){// restore read position
bytes.read=savedRead;remaining=savedRemaining;}}if(value===undefined){// asn1 not constructed or composed, get raw value
// TODO: do DER to OID conversion and vice-versa in .toDer?
if(length===undefined){if(options.strict){throw new Error('Non-constructed ASN.1 object of indefinite length.');}// be lenient and use remaining state bytes
length=remaining;}if(type===asn1.Type.BMPSTRING){value='';for(;length>0;length-=2){_checkBufferLength(bytes,remaining,2);value+=String.fromCharCode(bytes.getInt16());remaining-=2;}}else{value=bytes.getBytes(length);}}// add BIT STRING contents if available
var asn1Options=bitStringContents===undefined?null:{bitStringContents:bitStringContents};// create and return asn1 object
return asn1.create(tagClass,type,constructed,value,asn1Options);}/**
 * Converts the given asn1 object to a buffer of bytes in DER format.
 *
 * @param asn1 the asn1 object to convert to bytes.
 *
 * @return the buffer of bytes.
 */asn1.toDer=function(obj){var bytes=forge.util.createBuffer();// build the first byte
var b1=obj.tagClass|obj.type;// for storing the ASN.1 value
var value=forge.util.createBuffer();// use BIT STRING contents if available and data not changed
var useBitStringContents=false;if('bitStringContents'in obj){useBitStringContents=true;if(obj.original){useBitStringContents=asn1.equals(obj,obj.original);}}if(useBitStringContents){value.putBytes(obj.bitStringContents);}else if(obj.composed){// if composed, use each child asn1 object's DER bytes as value
// turn on 6th bit (0x20 = 32) to indicate asn1 is constructed
// from other asn1 objects
if(obj.constructed){b1|=0x20;}else{// type is a bit string, add unused bits of 0x00
value.putByte(0x00);}// add all of the child DER bytes together
for(var i=0;i<obj.value.length;++i){if(obj.value[i]!==undefined){value.putBuffer(asn1.toDer(obj.value[i]));}}}else{// use asn1.value directly
if(obj.type===asn1.Type.BMPSTRING){for(var i=0;i<obj.value.length;++i){value.putInt16(obj.value.charCodeAt(i));}}else{// ensure integer is minimally-encoded
// TODO: should all leading bytes be stripped vs just one?
// .. ex '00 00 01' => '01'?
if(obj.type===asn1.Type.INTEGER&&obj.value.length>1&&(// leading 0x00 for positive integer
obj.value.charCodeAt(0)===0&&(obj.value.charCodeAt(1)&0x80)===0||// leading 0xFF for negative integer
obj.value.charCodeAt(0)===0xFF&&(obj.value.charCodeAt(1)&0x80)===0x80)){value.putBytes(obj.value.substr(1));}else{value.putBytes(obj.value);}}}// add tag byte
bytes.putByte(b1);// use "short form" encoding
if(value.length()<=127){// one byte describes the length
// bit 8 = 0 and bits 7-1 = length
bytes.putByte(value.length()&0x7F);}else{// use "long form" encoding
// 2 to 127 bytes describe the length
// first byte: bit 8 = 1 and bits 7-1 = # of additional bytes
// other bytes: length in base 256, big-endian
var len=value.length();var lenBytes='';do{lenBytes+=String.fromCharCode(len&0xFF);len=len>>>8;}while(len>0);// set first byte to # bytes used to store the length and turn on
// bit 8 to indicate long-form length is used
bytes.putByte(lenBytes.length|0x80);// concatenate length bytes in reverse since they were generated
// little endian and we need big endian
for(var i=lenBytes.length-1;i>=0;--i){bytes.putByte(lenBytes.charCodeAt(i));}}// concatenate value bytes
bytes.putBuffer(value);return bytes;};/**
 * Converts an OID dot-separated string to a byte buffer. The byte buffer
 * contains only the DER-encoded value, not any tag or length bytes.
 *
 * @param oid the OID dot-separated string.
 *
 * @return the byte buffer.
 */asn1.oidToDer=function(oid){// split OID into individual values
var values=oid.split('.');var bytes=forge.util.createBuffer();// first byte is 40 * value1 + value2
bytes.putByte(40*parseInt(values[0],10)+parseInt(values[1],10));// other bytes are each value in base 128 with 8th bit set except for
// the last byte for each value
var last,valueBytes,value,b;for(var i=2;i<values.length;++i){// produce value bytes in reverse because we don't know how many
// bytes it will take to store the value
last=true;valueBytes=[];value=parseInt(values[i],10);do{b=value&0x7F;value=value>>>7;// if value is not last, then turn on 8th bit
if(!last){b|=0x80;}valueBytes.push(b);last=false;}while(value>0);// add value bytes in reverse (needs to be in big endian)
for(var n=valueBytes.length-1;n>=0;--n){bytes.putByte(valueBytes[n]);}}return bytes;};/**
 * Converts a DER-encoded byte buffer to an OID dot-separated string. The
 * byte buffer should contain only the DER-encoded value, not any tag or
 * length bytes.
 *
 * @param bytes the byte buffer.
 *
 * @return the OID dot-separated string.
 */asn1.derToOid=function(bytes){var oid;// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}// first byte is 40 * value1 + value2
var b=bytes.getByte();oid=Math.floor(b/40)+'.'+b%40;// other bytes are each value in base 128 with 8th bit set except for
// the last byte for each value
var value=0;while(bytes.length()>0){b=bytes.getByte();value=value<<7;// not the last byte for the value
if(b&0x80){value+=b&0x7F;}else{// last byte
oid+='.'+(value+b);value=0;}}return oid;};/**
 * Converts a UTCTime value to a date.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Parsing that structure hasn't been implemented yet.
 *
 * @param utc the UTCTime value to convert.
 *
 * @return the date.
 */asn1.utcTimeToDate=function(utc){/* The following formats can be used:

    YYMMDDhhmmZ
    YYMMDDhhmm+hh'mm'
    YYMMDDhhmm-hh'mm'
    YYMMDDhhmmssZ
    YYMMDDhhmmss+hh'mm'
    YYMMDDhhmmss-hh'mm'

    Where:

    YY is the least significant two digits of the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */var date=new Date();// if YY >= 50 use 19xx, if YY < 50 use 20xx
var year=parseInt(utc.substr(0,2),10);year=year>=50?1900+year:2000+year;var MM=parseInt(utc.substr(2,2),10)-1;// use 0-11 for month
var DD=parseInt(utc.substr(4,2),10);var hh=parseInt(utc.substr(6,2),10);var mm=parseInt(utc.substr(8,2),10);var ss=0;// not just YYMMDDhhmmZ
if(utc.length>11){// get character after minutes
var c=utc.charAt(10);var end=10;// see if seconds are present
if(c!=='+'&&c!=='-'){// get seconds
ss=parseInt(utc.substr(10,2),10);end+=2;}}// update date
date.setUTCFullYear(year,MM,DD);date.setUTCHours(hh,mm,ss,0);if(end){// get +/- after end of time
c=utc.charAt(end);if(c==='+'||c==='-'){// get hours+minutes offset
var hhoffset=parseInt(utc.substr(end+1,2),10);var mmoffset=parseInt(utc.substr(end+4,2),10);// calculate offset in milliseconds
var offset=hhoffset*60+mmoffset;offset*=60000;// apply offset
if(c==='+'){date.setTime(+date-offset);}else{date.setTime(+date+offset);}}}return date;};/**
 * Converts a GeneralizedTime value to a date.
 *
 * @param gentime the GeneralizedTime value to convert.
 *
 * @return the date.
 */asn1.generalizedTimeToDate=function(gentime){/* The following formats can be used:

    YYYYMMDDHHMMSS
    YYYYMMDDHHMMSS.fff
    YYYYMMDDHHMMSSZ
    YYYYMMDDHHMMSS.fffZ
    YYYYMMDDHHMMSS+hh'mm'
    YYYYMMDDHHMMSS.fff+hh'mm'
    YYYYMMDDHHMMSS-hh'mm'
    YYYYMMDDHHMMSS.fff-hh'mm'

    Where:

    YYYY is the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    .fff is the second fraction, accurate to three decimal places
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */var date=new Date();var YYYY=parseInt(gentime.substr(0,4),10);var MM=parseInt(gentime.substr(4,2),10)-1;// use 0-11 for month
var DD=parseInt(gentime.substr(6,2),10);var hh=parseInt(gentime.substr(8,2),10);var mm=parseInt(gentime.substr(10,2),10);var ss=parseInt(gentime.substr(12,2),10);var fff=0;var offset=0;var isUTC=false;if(gentime.charAt(gentime.length-1)==='Z'){isUTC=true;}var end=gentime.length-5,c=gentime.charAt(end);if(c==='+'||c==='-'){// get hours+minutes offset
var hhoffset=parseInt(gentime.substr(end+1,2),10);var mmoffset=parseInt(gentime.substr(end+4,2),10);// calculate offset in milliseconds
offset=hhoffset*60+mmoffset;offset*=60000;// apply offset
if(c==='+'){offset*=-1;}isUTC=true;}// check for second fraction
if(gentime.charAt(14)==='.'){fff=parseFloat(gentime.substr(14),10)*1000;}if(isUTC){date.setUTCFullYear(YYYY,MM,DD);date.setUTCHours(hh,mm,ss,fff);// apply offset
date.setTime(+date+offset);}else{date.setFullYear(YYYY,MM,DD);date.setHours(hh,mm,ss,fff);}return date;};/**
 * Converts a date to a UTCTime value.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Converting to a GeneralizedTime hasn't been
 * implemented yet.
 *
 * @param date the date to convert.
 *
 * @return the UTCTime value.
 */asn1.dateToUtcTime=function(date){// TODO: validate; currently assumes proper format
if(typeof date==='string'){return date;}var rval='';// create format YYMMDDhhmmssZ
var format=[];format.push((''+date.getUTCFullYear()).substr(2));format.push(''+(date.getUTCMonth()+1));format.push(''+date.getUTCDate());format.push(''+date.getUTCHours());format.push(''+date.getUTCMinutes());format.push(''+date.getUTCSeconds());// ensure 2 digits are used for each format entry
for(var i=0;i<format.length;++i){if(format[i].length<2){rval+='0';}rval+=format[i];}rval+='Z';return rval;};/**
 * Converts a date to a GeneralizedTime value.
 *
 * @param date the date to convert.
 *
 * @return the GeneralizedTime value as a string.
 */asn1.dateToGeneralizedTime=function(date){// TODO: validate; currently assumes proper format
if(typeof date==='string'){return date;}var rval='';// create format YYYYMMDDHHMMSSZ
var format=[];format.push(''+date.getUTCFullYear());format.push(''+(date.getUTCMonth()+1));format.push(''+date.getUTCDate());format.push(''+date.getUTCHours());format.push(''+date.getUTCMinutes());format.push(''+date.getUTCSeconds());// ensure 2 digits are used for each format entry
for(var i=0;i<format.length;++i){if(format[i].length<2){rval+='0';}rval+=format[i];}rval+='Z';return rval;};/**
 * Converts a javascript integer to a DER-encoded byte buffer to be used
 * as the value for an INTEGER type.
 *
 * @param x the integer.
 *
 * @return the byte buffer.
 */asn1.integerToDer=function(x){var rval=forge.util.createBuffer();if(x>=-0x80&&x<0x80){return rval.putSignedInt(x,8);}if(x>=-0x8000&&x<0x8000){return rval.putSignedInt(x,16);}if(x>=-0x800000&&x<0x800000){return rval.putSignedInt(x,24);}if(x>=-0x80000000&&x<0x80000000){return rval.putSignedInt(x,32);}var error=new Error('Integer too large; max is 32-bits.');error.integer=x;throw error;};/**
 * Converts a DER-encoded byte buffer to a javascript integer. This is
 * typically used to decode the value of an INTEGER type.
 *
 * @param bytes the byte buffer.
 *
 * @return the integer.
 */asn1.derToInteger=function(bytes){// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}var n=bytes.length()*8;if(n>32){throw new Error('Integer too large; max is 32-bits.');}return bytes.getSignedInt(n);};/**
 * Validates that the given ASN.1 object is at least a super set of the
 * given ASN.1 structure. Only tag classes and types are checked. An
 * optional map may also be provided to capture ASN.1 values while the
 * structure is checked.
 *
 * To capture an ASN.1 value, set an object in the validator's 'capture'
 * parameter to the key to use in the capture map. To capture the full
 * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including
 * the leading unused bits counter byte, specify 'captureBitStringContents'.
 * To capture BIT STRING bytes, without the leading unused bits counter byte,
 * specify 'captureBitStringValue'.
 *
 * Objects in the validator may set a field 'optional' to true to indicate
 * that it isn't necessary to pass validation.
 *
 * @param obj the ASN.1 object to validate.
 * @param v the ASN.1 structure validator.
 * @param capture an optional map to capture values in.
 * @param errors an optional array for storing validation errors.
 *
 * @return true on success, false on failure.
 */asn1.validate=function(obj,v,capture,errors){var rval=false;// ensure tag class and type are the same if specified
if((obj.tagClass===v.tagClass||typeof v.tagClass==='undefined')&&(obj.type===v.type||typeof v.type==='undefined')){// ensure constructed flag is the same if specified
if(obj.constructed===v.constructed||typeof v.constructed==='undefined'){rval=true;// handle sub values
if(v.value&&forge.util.isArray(v.value)){var j=0;for(var i=0;rval&&i<v.value.length;++i){rval=v.value[i].optional||false;if(obj.value[j]){rval=asn1.validate(obj.value[j],v.value[i],capture,errors);if(rval){++j;}else if(v.value[i].optional){rval=true;}}if(!rval&&errors){errors.push('['+v.name+'] '+'Tag class "'+v.tagClass+'", type "'+v.type+'" expected value length "'+v.value.length+'", got "'+obj.value.length+'"');}}}if(rval&&capture){if(v.capture){capture[v.capture]=obj.value;}if(v.captureAsn1){capture[v.captureAsn1]=obj;}if(v.captureBitStringContents&&'bitStringContents'in obj){capture[v.captureBitStringContents]=obj.bitStringContents;}if(v.captureBitStringValue&&'bitStringContents'in obj){var value;if(obj.bitStringContents.length<2){capture[v.captureBitStringValue]='';}else{// FIXME: support unused bits with data shifting
var unused=obj.bitStringContents.charCodeAt(0);if(unused!==0){throw new Error('captureBitStringValue only supported for zero unused bits');}capture[v.captureBitStringValue]=obj.bitStringContents.slice(1);}}}}else if(errors){errors.push('['+v.name+'] '+'Expected constructed "'+v.constructed+'", got "'+obj.constructed+'"');}}else if(errors){if(obj.tagClass!==v.tagClass){errors.push('['+v.name+'] '+'Expected tag class "'+v.tagClass+'", got "'+obj.tagClass+'"');}if(obj.type!==v.type){errors.push('['+v.name+'] '+'Expected type "'+v.type+'", got "'+obj.type+'"');}}return rval;};// regex for testing for non-latin characters
var _nonLatinRegex=/[^\\u0000-\\u00ff]/;/**
 * Pretty prints an ASN.1 object to a string.
 *
 * @param obj the object to write out.
 * @param level the level in the tree.
 * @param indentation the indentation to use.
 *
 * @return the string.
 */asn1.prettyPrint=function(obj,level,indentation){var rval='';// set default level and indentation
level=level||0;indentation=indentation||2;// start new line for deep levels
if(level>0){rval+='\n';}// create indent
var indent='';for(var i=0;i<level*indentation;++i){indent+=' ';}// print class:type
rval+=indent+'Tag: ';switch(obj.tagClass){case asn1.Class.UNIVERSAL:rval+='Universal:';break;case asn1.Class.APPLICATION:rval+='Application:';break;case asn1.Class.CONTEXT_SPECIFIC:rval+='Context-Specific:';break;case asn1.Class.PRIVATE:rval+='Private:';break;}if(obj.tagClass===asn1.Class.UNIVERSAL){rval+=obj.type;// known types
switch(obj.type){case asn1.Type.NONE:rval+=' (None)';break;case asn1.Type.BOOLEAN:rval+=' (Boolean)';break;case asn1.Type.INTEGER:rval+=' (Integer)';break;case asn1.Type.BITSTRING:rval+=' (Bit string)';break;case asn1.Type.OCTETSTRING:rval+=' (Octet string)';break;case asn1.Type.NULL:rval+=' (Null)';break;case asn1.Type.OID:rval+=' (Object Identifier)';break;case asn1.Type.ODESC:rval+=' (Object Descriptor)';break;case asn1.Type.EXTERNAL:rval+=' (External or Instance of)';break;case asn1.Type.REAL:rval+=' (Real)';break;case asn1.Type.ENUMERATED:rval+=' (Enumerated)';break;case asn1.Type.EMBEDDED:rval+=' (Embedded PDV)';break;case asn1.Type.UTF8:rval+=' (UTF8)';break;case asn1.Type.ROID:rval+=' (Relative Object Identifier)';break;case asn1.Type.SEQUENCE:rval+=' (Sequence)';break;case asn1.Type.SET:rval+=' (Set)';break;case asn1.Type.PRINTABLESTRING:rval+=' (Printable String)';break;case asn1.Type.IA5String:rval+=' (IA5String (ASCII))';break;case asn1.Type.UTCTIME:rval+=' (UTC time)';break;case asn1.Type.GENERALIZEDTIME:rval+=' (Generalized time)';break;case asn1.Type.BMPSTRING:rval+=' (BMP String)';break;}}else{rval+=obj.type;}rval+='\n';rval+=indent+'Constructed: '+obj.constructed+'\n';if(obj.composed){var subvalues=0;var sub='';for(var i=0;i<obj.value.length;++i){if(obj.value[i]!==undefined){subvalues+=1;sub+=asn1.prettyPrint(obj.value[i],level+1,indentation);if(i+1<obj.value.length){sub+=',';}}}rval+=indent+'Sub values: '+subvalues+sub;}else{rval+=indent+'Value: ';if(obj.type===asn1.Type.OID){var oid=asn1.derToOid(obj.value);rval+=oid;if(forge.pki&&forge.pki.oids){if(oid in forge.pki.oids){rval+=' ('+forge.pki.oids[oid]+') ';}}}if(obj.type===asn1.Type.INTEGER){try{rval+=asn1.derToInteger(obj.value);}catch(ex){rval+='0x'+forge.util.bytesToHex(obj.value);}}else if(obj.type===asn1.Type.BITSTRING){// TODO: shift bits as needed to display without padding
if(obj.value.length>1){// remove unused bits field
rval+='0x'+forge.util.bytesToHex(obj.value.slice(1));}else{rval+='(none)';}// show unused bit count
if(obj.value.length>0){var unused=obj.value.charCodeAt(0);if(unused==1){rval+=' (1 unused bit shown)';}else if(unused>1){rval+=' ('+unused+' unused bits shown)';}}}else if(obj.type===asn1.Type.OCTETSTRING){if(!_nonLatinRegex.test(obj.value)){rval+='('+obj.value+') ';}rval+='0x'+forge.util.bytesToHex(obj.value);}else if(obj.type===asn1.Type.UTF8){rval+=forge.util.decodeUtf8(obj.value);}else if(obj.type===asn1.Type.PRINTABLESTRING||obj.type===asn1.Type.IA5String){rval+=obj.value;}else if(_nonLatinRegex.test(obj.value)){rval+='0x'+forge.util.bytesToHex(obj.value);}else if(obj.value.length===0){rval+='[null]';}else{rval+=obj.value;}}return rval;};/***/},/* 3 */ /***/function(module,exports,__webpack_require__){/**
 * Object IDs for ASN.1.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);forge.pki=forge.pki||{};var oids=module.exports=forge.pki.oids=forge.oids=forge.oids||{};// set id to name mapping and name to id mapping
function _IN(id,name){oids[id]=name;oids[name]=id;}// set id to name mapping only
function _I_(id,name){oids[id]=name;}// algorithm OIDs
_IN('1.2.840.113549.1.1.1','rsaEncryption');// Note: md2 & md4 not implemented
//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');
//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');
_IN('1.2.840.113549.1.1.4','md5WithRSAEncryption');_IN('1.2.840.113549.1.1.5','sha1WithRSAEncryption');_IN('1.2.840.113549.1.1.7','RSAES-OAEP');_IN('1.2.840.113549.1.1.8','mgf1');_IN('1.2.840.113549.1.1.9','pSpecified');_IN('1.2.840.113549.1.1.10','RSASSA-PSS');_IN('1.2.840.113549.1.1.11','sha256WithRSAEncryption');_IN('1.2.840.113549.1.1.12','sha384WithRSAEncryption');_IN('1.2.840.113549.1.1.13','sha512WithRSAEncryption');_IN('1.2.840.10040.4.3','dsa-with-sha1');_IN('1.3.14.3.2.7','desCBC');_IN('1.3.14.3.2.26','sha1');_IN('2.16.840.1.101.3.4.2.1','sha256');_IN('2.16.840.1.101.3.4.2.2','sha384');_IN('2.16.840.1.101.3.4.2.3','sha512');_IN('1.2.840.113549.2.5','md5');// pkcs#7 content types
_IN('1.2.840.113549.1.7.1','data');_IN('1.2.840.113549.1.7.2','signedData');_IN('1.2.840.113549.1.7.3','envelopedData');_IN('1.2.840.113549.1.7.4','signedAndEnvelopedData');_IN('1.2.840.113549.1.7.5','digestedData');_IN('1.2.840.113549.1.7.6','encryptedData');// pkcs#9 oids
_IN('1.2.840.113549.1.9.1','emailAddress');_IN('1.2.840.113549.1.9.2','unstructuredName');_IN('1.2.840.113549.1.9.3','contentType');_IN('1.2.840.113549.1.9.4','messageDigest');_IN('1.2.840.113549.1.9.5','signingTime');_IN('1.2.840.113549.1.9.6','counterSignature');_IN('1.2.840.113549.1.9.7','challengePassword');_IN('1.2.840.113549.1.9.8','unstructuredAddress');_IN('1.2.840.113549.1.9.14','extensionRequest');_IN('1.2.840.113549.1.9.20','friendlyName');_IN('1.2.840.113549.1.9.21','localKeyId');_IN('1.2.840.113549.1.9.22.1','x509Certificate');// pkcs#12 safe bags
_IN('1.2.840.113549.1.12.10.1.1','keyBag');_IN('1.2.840.113549.1.12.10.1.2','pkcs8ShroudedKeyBag');_IN('1.2.840.113549.1.12.10.1.3','certBag');_IN('1.2.840.113549.1.12.10.1.4','crlBag');_IN('1.2.840.113549.1.12.10.1.5','secretBag');_IN('1.2.840.113549.1.12.10.1.6','safeContentsBag');// password-based-encryption for pkcs#12
_IN('1.2.840.113549.1.5.13','pkcs5PBES2');_IN('1.2.840.113549.1.5.12','pkcs5PBKDF2');_IN('1.2.840.113549.1.12.1.1','pbeWithSHAAnd128BitRC4');_IN('1.2.840.113549.1.12.1.2','pbeWithSHAAnd40BitRC4');_IN('1.2.840.113549.1.12.1.3','pbeWithSHAAnd3-KeyTripleDES-CBC');_IN('1.2.840.113549.1.12.1.4','pbeWithSHAAnd2-KeyTripleDES-CBC');_IN('1.2.840.113549.1.12.1.5','pbeWithSHAAnd128BitRC2-CBC');_IN('1.2.840.113549.1.12.1.6','pbewithSHAAnd40BitRC2-CBC');// hmac OIDs
_IN('1.2.840.113549.2.7','hmacWithSHA1');_IN('1.2.840.113549.2.8','hmacWithSHA224');_IN('1.2.840.113549.2.9','hmacWithSHA256');_IN('1.2.840.113549.2.10','hmacWithSHA384');_IN('1.2.840.113549.2.11','hmacWithSHA512');// symmetric key algorithm oids
_IN('1.2.840.113549.3.7','des-EDE3-CBC');_IN('2.16.840.1.101.3.4.1.2','aes128-CBC');_IN('2.16.840.1.101.3.4.1.22','aes192-CBC');_IN('2.16.840.1.101.3.4.1.42','aes256-CBC');// certificate issuer/subject OIDs
_IN('2.5.4.3','commonName');_IN('2.5.4.5','serialName');_IN('2.5.4.6','countryName');_IN('2.5.4.7','localityName');_IN('2.5.4.8','stateOrProvinceName');_IN('2.5.4.10','organizationName');_IN('2.5.4.11','organizationalUnitName');_IN('2.5.4.13','description');// X.509 extension OIDs
_IN('2.16.840.1.113730.1.1','nsCertType');_I_('2.5.29.1','authorityKeyIdentifier');// deprecated, use .35
_I_('2.5.29.2','keyAttributes');// obsolete use .37 or .15
_I_('2.5.29.3','certificatePolicies');// deprecated, use .32
_I_('2.5.29.4','keyUsageRestriction');// obsolete use .37 or .15
_I_('2.5.29.5','policyMapping');// deprecated use .33
_I_('2.5.29.6','subtreesConstraint');// obsolete use .30
_I_('2.5.29.7','subjectAltName');// deprecated use .17
_I_('2.5.29.8','issuerAltName');// deprecated use .18
_I_('2.5.29.9','subjectDirectoryAttributes');_I_('2.5.29.10','basicConstraints');// deprecated use .19
_I_('2.5.29.11','nameConstraints');// deprecated use .30
_I_('2.5.29.12','policyConstraints');// deprecated use .36
_I_('2.5.29.13','basicConstraints');// deprecated use .19
_IN('2.5.29.14','subjectKeyIdentifier');_IN('2.5.29.15','keyUsage');_I_('2.5.29.16','privateKeyUsagePeriod');_IN('2.5.29.17','subjectAltName');_IN('2.5.29.18','issuerAltName');_IN('2.5.29.19','basicConstraints');_I_('2.5.29.20','cRLNumber');_I_('2.5.29.21','cRLReason');_I_('2.5.29.22','expirationDate');_I_('2.5.29.23','instructionCode');_I_('2.5.29.24','invalidityDate');_I_('2.5.29.25','cRLDistributionPoints');// deprecated use .31
_I_('2.5.29.26','issuingDistributionPoint');// deprecated use .28
_I_('2.5.29.27','deltaCRLIndicator');_I_('2.5.29.28','issuingDistributionPoint');_I_('2.5.29.29','certificateIssuer');_I_('2.5.29.30','nameConstraints');_IN('2.5.29.31','cRLDistributionPoints');_IN('2.5.29.32','certificatePolicies');_I_('2.5.29.33','policyMappings');_I_('2.5.29.34','policyConstraints');// deprecated use .36
_IN('2.5.29.35','authorityKeyIdentifier');_I_('2.5.29.36','policyConstraints');_IN('2.5.29.37','extKeyUsage');_I_('2.5.29.46','freshestCRL');_I_('2.5.29.54','inhibitAnyPolicy');// extKeyUsage purposes
_IN('1.3.6.1.4.1.11129.2.4.2','timestampList');_IN('1.3.6.1.5.5.7.1.1','authorityInfoAccess');_IN('1.3.6.1.5.5.7.3.1','serverAuth');_IN('1.3.6.1.5.5.7.3.2','clientAuth');_IN('1.3.6.1.5.5.7.3.3','codeSigning');_IN('1.3.6.1.5.5.7.3.4','emailProtection');_IN('1.3.6.1.5.5.7.3.8','timeStamping');/***/},/* 4 */ /***/function(module,exports,__webpack_require__){/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);module.exports=forge.md=forge.md||{};forge.md.algorithms=forge.md.algorithms||{};/***/},/* 5 */ /***/function(module,exports,__webpack_require__){/**
 * An API for getting cryptographically-secure random bytes. The bytes are
 * generated using the Fortuna algorithm devised by Bruce Schneier and
 * Niels Ferguson.
 *
 * Getting strong random bytes is not yet easy to do in javascript. The only
 * truish random entropy that can be collected is from the mouse, keyboard, or
 * from timing with respect to page loads, etc. This generator makes a poor
 * attempt at providing random bytes when those sources haven't yet provided
 * enough entropy to initially seed or to reseed the PRNG.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2009-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(23);__webpack_require__(24);__webpack_require__(1);(function(){// forge.random already defined
if(forge.random&&forge.random.getBytes){module.exports=forge.random;return;}(function(jQuery){// the default prng plugin, uses AES-128
var prng_aes={};var _prng_aes_output=new Array(4);var _prng_aes_buffer=forge.util.createBuffer();prng_aes.formatKey=function(key){// convert the key into 32-bit integers
var tmp=forge.util.createBuffer(key);key=new Array(4);key[0]=tmp.getInt32();key[1]=tmp.getInt32();key[2]=tmp.getInt32();key[3]=tmp.getInt32();// return the expanded key
return forge.aes._expandKey(key,false);};prng_aes.formatSeed=function(seed){// convert seed into 32-bit integers
var tmp=forge.util.createBuffer(seed);seed=new Array(4);seed[0]=tmp.getInt32();seed[1]=tmp.getInt32();seed[2]=tmp.getInt32();seed[3]=tmp.getInt32();return seed;};prng_aes.cipher=function(key,seed){forge.aes._updateBlock(key,seed,_prng_aes_output,false);_prng_aes_buffer.putInt32(_prng_aes_output[0]);_prng_aes_buffer.putInt32(_prng_aes_output[1]);_prng_aes_buffer.putInt32(_prng_aes_output[2]);_prng_aes_buffer.putInt32(_prng_aes_output[3]);return _prng_aes_buffer.getBytes();};prng_aes.increment=function(seed){// FIXME: do we care about carry or signed issues?
++seed[3];return seed;};prng_aes.md=forge.md.sha256;/**
 * Creates a new PRNG.
 */function spawnPrng(){var ctx=forge.prng.create(prng_aes);/**
   * Gets random bytes. If a native secure crypto API is unavailable, this
   * method tries to make the bytes more unpredictable by drawing from data that
   * can be collected from the user of the browser, eg: mouse movement.
   *
   * If a callback is given, this method will be called asynchronously.
   *
   * @param count the number of random bytes to get.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return the random bytes in a string.
   */ctx.getBytes=function(count,callback){return ctx.generate(count,callback);};/**
   * Gets random bytes asynchronously. If a native secure crypto API is
   * unavailable, this method tries to make the bytes more unpredictable by
   * drawing from data that can be collected from the user of the browser,
   * eg: mouse movement.
   *
   * @param count the number of random bytes to get.
   *
   * @return the random bytes in a string.
   */ctx.getBytesSync=function(count){return ctx.generate(count);};return ctx;}// create default prng context
var _ctx=spawnPrng();// add other sources of entropy only if window.crypto.getRandomValues is not
// available -- otherwise this source will be automatically used by the prng
var getRandomValues=null;if(typeof window!=='undefined'){var _crypto=window.crypto||window.msCrypto;if(_crypto&&_crypto.getRandomValues){getRandomValues=function getRandomValues(arr){return _crypto.getRandomValues(arr);};}}if(forge.options.usePureJavaScript||!forge.util.isNodejs&&!getRandomValues){// if this is a web worker, do not use weak entropy, instead register to
// receive strong entropy asynchronously from the main thread
if(typeof window==='undefined'||window.document===undefined){}// FIXME:
// get load time entropy
_ctx.collectInt(+new Date(),32);// add some entropy from navigator object
if(typeof navigator!=='undefined'){var _navBytes='';for(var key in navigator){try{if(typeof navigator[key]=='string'){_navBytes+=navigator[key];}}catch(e){/* Some navigator keys might not be accessible, e.g. the geolocation
          attribute throws an exception if touched in Mozilla chrome://
          context.

          Silently ignore this and just don't use this as a source of
          entropy. */}}_ctx.collect(_navBytes);_navBytes=null;}// add mouse and keyboard collectors if jquery is available
if(jQuery){// set up mouse entropy capture
jQuery().mousemove(function(e){// add mouse coords
_ctx.collectInt(e.clientX,16);_ctx.collectInt(e.clientY,16);});// set up keyboard entropy capture
jQuery().keypress(function(e){_ctx.collectInt(e.charCode,8);});}}/* Random API */if(!forge.random){forge.random=_ctx;}else{// extend forge.random with _ctx
for(var key in _ctx){forge.random[key]=_ctx[key];}}// expose spawn PRNG
forge.random.createInstance=spawnPrng;module.exports=forge.random;})(typeof jQuery!=='undefined'?jQuery:null);})();/***/},/* 6 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of basic RSA algorithms.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The only algorithm currently supported for PKI is RSA.
 *
 * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo
 * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier
 * and a subjectPublicKey of type bit string.
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of RSA, there aren't any.
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm AlgorithmIdentifier,
 *   subjectPublicKey BIT STRING
 * }
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * For an RSA public key, the subjectPublicKey is:
 *
 * RSAPublicKey ::= SEQUENCE {
 *   modulus            INTEGER,    -- n
 *   publicExponent     INTEGER     -- e
 * }
 *
 * PrivateKeyInfo ::= SEQUENCE {
 *   version                   Version,
 *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
 *   privateKey                PrivateKey,
 *   attributes           [0]  IMPLICIT Attributes OPTIONAL
 * }
 *
 * Version ::= INTEGER
 * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
 * PrivateKey ::= OCTET STRING
 * Attributes ::= SET OF Attribute
 *
 * An RSA private key as the following structure:
 *
 * RSAPrivateKey ::= SEQUENCE {
 *   version Version,
 *   modulus INTEGER, -- n
 *   publicExponent INTEGER, -- e
 *   privateExponent INTEGER, -- d
 *   prime1 INTEGER, -- p
 *   prime2 INTEGER, -- q
 *   exponent1 INTEGER, -- d mod (p-1)
 *   exponent2 INTEGER, -- d mod (q-1)
 *   coefficient INTEGER -- (inverse of q) mod p
 * }
 *
 * Version ::= INTEGER
 *
 * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(16);__webpack_require__(3);__webpack_require__(26);__webpack_require__(27);__webpack_require__(5);__webpack_require__(1);if(typeof BigInteger==='undefined'){var BigInteger=forge.jsbn.BigInteger;}// shortcut for asn.1 API
var asn1=forge.asn1;/*
 * RSA encryption and decryption, see RFC 2313.
 */forge.pki=forge.pki||{};module.exports=forge.pki.rsa=forge.rsa=forge.rsa||{};var pki=forge.pki;// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA=[6,4,2,4,2,4,6,2];// validator for a PrivateKeyInfo structure
var privateKeyValidator={// PrivateKeyInfo
name:'PrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// Version (INTEGER)
name:'PrivateKeyInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyVersion'},{// privateKeyAlgorithm
name:'PrivateKeyInfo.privateKeyAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'privateKeyOid'}]},{// PrivateKey
name:'PrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'privateKey'}]};// validator for an RSA private key
var rsaPrivateKeyValidator={// RSAPrivateKey
name:'RSAPrivateKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// Version (INTEGER)
name:'RSAPrivateKey.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyVersion'},{// modulus (n)
name:'RSAPrivateKey.modulus',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyModulus'},{// publicExponent (e)
name:'RSAPrivateKey.publicExponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPublicExponent'},{// privateExponent (d)
name:'RSAPrivateKey.privateExponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrivateExponent'},{// prime1 (p)
name:'RSAPrivateKey.prime1',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrime1'},{// prime2 (q)
name:'RSAPrivateKey.prime2',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrime2'},{// exponent1 (d mod (p-1))
name:'RSAPrivateKey.exponent1',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyExponent1'},{// exponent2 (d mod (q-1))
name:'RSAPrivateKey.exponent2',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyExponent2'},{// coefficient ((inverse of q) mod p)
name:'RSAPrivateKey.coefficient',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyCoefficient'}]};// validator for an RSA public key
var rsaPublicKeyValidator={// RSAPublicKey
name:'RSAPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// modulus (n)
name:'RSAPublicKey.modulus',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'publicKeyModulus'},{// publicExponent (e)
name:'RSAPublicKey.exponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'publicKeyExponent'}]};// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator=forge.pki.rsa.publicKeyValidator={name:'SubjectPublicKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'subjectPublicKeyInfo',value:[{name:'SubjectPublicKeyInfo.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'publicKeyOid'}]},{// subjectPublicKey
name:'SubjectPublicKeyInfo.subjectPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,value:[{// RSAPublicKey
name:'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,captureAsn1:'rsaPublicKey'}]}]};/**
 * Wrap digest in DigestInfo object.
 *
 * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 * Digest ::= OCTET STRING
 *
 * @param md the message digest object with the hash to sign.
 *
 * @return the encoded message (ready for RSA encrytion)
 */var emsaPkcs1v15encode=function emsaPkcs1v15encode(md){// get the oid for the algorithm
var oid;if(md.algorithm in pki.oids){oid=pki.oids[md.algorithm];}else{var error=new Error('Unknown message digest algorithm.');error.algorithm=md.algorithm;throw error;}var oidBytes=asn1.oidToDer(oid).getBytes();// create the digest info
var digestInfo=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var digestAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,oidBytes));digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,''));var digest=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,md.digest().getBytes());digestInfo.value.push(digestAlgorithm);digestInfo.value.push(digest);// encode digest info
return asn1.toDer(digestInfo).getBytes();};/**
 * Performs x^c mod n (RSA encryption or decryption operation).
 *
 * @param x the number to raise and mod.
 * @param key the key to use.
 * @param pub true if the key is public, false if private.
 *
 * @return the result of x^c mod n.
 */var _modPow=function _modPow(x,key,pub){if(pub){return x.modPow(key.e,key.n);}if(!key.p||!key.q){// allow calculation without CRT params (slow)
return x.modPow(key.d,key.n);}// pre-compute dP, dQ, and qInv if necessary
if(!key.dP){key.dP=key.d.mod(key.p.subtract(BigInteger.ONE));}if(!key.dQ){key.dQ=key.d.mod(key.q.subtract(BigInteger.ONE));}if(!key.qInv){key.qInv=key.q.modInverse(key.p);}/* Chinese remainder theorem (CRT) states:

    Suppose n1, n2, ..., nk are positive integers which are pairwise
    coprime (n1 and n2 have no common factors other than 1). For any
    integers x1, x2, ..., xk there exists an integer x solving the
    system of simultaneous congruences (where ~= means modularly
    congruent so a ~= b mod n means a mod n = b mod n):

    x ~= x1 mod n1
    x ~= x2 mod n2
    ...
    x ~= xk mod nk

    This system of congruences has a single simultaneous solution x
    between 0 and n - 1. Furthermore, each xk solution and x itself
    is congruent modulo the product n = n1*n2*...*nk.
    So x1 mod n = x2 mod n = xk mod n = x mod n.

    The single simultaneous solution x can be solved with the following
    equation:

    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.

    Where x is less than n, xi = x mod ni.

    For RSA we are only concerned with k = 2. The modulus n = pq, where
    p and q are coprime. The RSA decryption algorithm is:

    y = x^d mod n

    Given the above:

    x1 = x^d mod p
    r1 = n/p = q
    s1 = q^-1 mod p
    x2 = x^d mod q
    r2 = n/q = p
    s2 = p^-1 mod q

    So y = (x1r1s1 + x2r2s2) mod n
         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n

    According to Fermat's Little Theorem, if the modulus P is prime,
    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.
    Since A is not divisible by P it follows that if:
    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:

    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort
    to calculate). In order to calculate x^d mod p more quickly the
    exponent d mod (p - 1) is stored in the RSA private key (the same
    is done for x^d mod q). These values are referred to as dP and dQ
    respectively. Therefore we now have:

    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n

    Since we'll be reducing x^dP by modulo p (same for q) we can also
    reduce x by p (and q respectively) before hand. Therefore, let

    xp = ((x mod p)^dP mod p), and
    xq = ((x mod q)^dQ mod q), yielding:

    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n

    This can be further reduced to a simple algorithm that only
    requires 1 inverse (the q inverse is used) to be used and stored.
    The algorithm is called Garner's algorithm. If qInv is the
    inverse of q, we simply calculate:

    y = (qInv*(xp - xq) mod p) * q + xq

    However, there are two further complications. First, we need to
    ensure that xp > xq to prevent signed BigIntegers from being used
    so we add p until this is true (since we will be mod'ing with
    p anyway). Then, there is a known timing attack on algorithms
    using the CRT. To mitigate this risk, "cryptographic blinding"
    should be used. This requires simply generating a random number r
    between 0 and n-1 and its inverse and multiplying x by r^e before
    calculating y and then multiplying y by r^-1 afterwards. Note that
    r must be coprime with n (gcd(r, n) === 1) in order to have an
    inverse.
  */ // cryptographic blinding
var r;do{r=new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength()/8)),16);}while(r.compareTo(key.n)>=0||!r.gcd(key.n).equals(BigInteger.ONE));x=x.multiply(r.modPow(key.e,key.n)).mod(key.n);// calculate xp and xq
var xp=x.mod(key.p).modPow(key.dP,key.p);var xq=x.mod(key.q).modPow(key.dQ,key.q);// xp must be larger than xq to avoid signed bit usage
while(xp.compareTo(xq)<0){xp=xp.add(key.p);}// do last step
var y=xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);// remove effect of random for cryptographic blinding
y=y.multiply(r.modInverse(key.n)).mod(key.n);return y;};/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or
 * 'encrypt' on a public key object instead.
 *
 * Performs RSA encryption.
 *
 * The parameter bt controls whether to put padding bytes before the
 * message passed in. Set bt to either true or false to disable padding
 * completely (in order to handle e.g. EMSA-PSS encoding seperately before),
 * signaling whether the encryption operation is a public key operation
 * (i.e. encrypting data) or not, i.e. private key operation (data signing).
 *
 * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01
 * (for signing) or 0x02 (for encryption). The key operation mode (private
 * or public) is derived from this flag in that case).
 *
 * @param m the message to encrypt as a byte string.
 * @param key the RSA key to use.
 * @param bt for PKCS#1 v1.5 padding, the block type to use
 *   (0x01 for private key, 0x02 for public),
 *   to disable padding: true = public key, false = private key.
 *
 * @return the encrypted bytes as a string.
 */pki.rsa.encrypt=function(m,key,bt){var pub=bt;var eb;// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);if(bt!==false&&bt!==true){// legacy, default to PKCS#1 v1.5 padding
pub=bt===0x02;eb=_encodePkcs1_v1_5(m,key,bt);}else{eb=forge.util.createBuffer();eb.putBytes(m);}// load encryption block as big integer 'x'
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var x=new BigInteger(eb.toHex(),16);// do RSA encryption
var y=_modPow(x,key,pub);// convert y into the encrypted data byte string, if y is shorter in
// bytes than k, then prepend zero bytes to fill up ed
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var yhex=y.toString(16);var ed=forge.util.createBuffer();var zeros=k-Math.ceil(yhex.length/2);while(zeros>0){ed.putByte(0x00);--zeros;}ed.putBytes(forge.util.hexToBytes(yhex));return ed.getBytes();};/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or
 * 'verify' on a public key object instead.
 *
 * Performs RSA decryption.
 *
 * The parameter ml controls whether to apply PKCS#1 v1.5 padding
 * or not.  Set ml = false to disable padding removal completely
 * (in order to handle e.g. EMSA-PSS later on) and simply pass back
 * the RSA encryption block.
 *
 * @param ed the encrypted data to decrypt in as a byte string.
 * @param key the RSA key to use.
 * @param pub true for a public key operation, false for private.
 * @param ml the message length, if known, false to disable padding.
 *
 * @return the decrypted message as a byte string.
 */pki.rsa.decrypt=function(ed,key,pub,ml){// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);// error if the length of the encrypted data ED is not k
if(ed.length!==k){var error=new Error('Encrypted message length is invalid.');error.length=ed.length;error.expected=k;throw error;}// convert encrypted data into a big integer
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var y=new BigInteger(forge.util.createBuffer(ed).toHex(),16);// y must be less than the modulus or it wasn't the result of
// a previous mod operation (encryption) using that modulus
if(y.compareTo(key.n)>=0){throw new Error('Encrypted message is invalid.');}// do RSA decryption
var x=_modPow(y,key,pub);// create the encryption block, if x is shorter in bytes than k, then
// prepend zero bytes to fill up eb
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var xhex=x.toString(16);var eb=forge.util.createBuffer();var zeros=k-Math.ceil(xhex.length/2);while(zeros>0){eb.putByte(0x00);--zeros;}eb.putBytes(forge.util.hexToBytes(xhex));if(ml!==false){// legacy, default to PKCS#1 v1.5 padding
return _decodePkcs1_v1_5(eb.getBytes(),key,pub);}// return message
return eb.getBytes();};/**
 * Creates an RSA key-pair generation state object. It is used to allow
 * key-generation to be performed in steps. It also allows for a UI to
 * display progress updates.
 *
 * @param bits the size for the private key in bits, defaults to 2048.
 * @param e the public exponent to use, defaults to 65537 (0x10001).
 * @param [options] the options to use.
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 *
 * @return the state object to use to generate the key-pair.
 */pki.rsa.createKeyPairGenerationState=function(bits,e,options){// TODO: migrate step-based prime generation code to forge.prime
// set default bits
if(typeof bits==='string'){bits=parseInt(bits,10);}bits=bits||2048;// create prng with api that matches BigInteger secure random
options=options||{};var prng=options.prng||forge.random;var rng={// x is an array to fill with bytes
nextBytes:function nextBytes(x){var b=prng.getBytesSync(x.length);for(var i=0;i<x.length;++i){x[i]=b.charCodeAt(i);}}};var algorithm=options.algorithm||'PRIMEINC';// create PRIMEINC algorithm state
var rval;if(algorithm==='PRIMEINC'){rval={algorithm:algorithm,state:0,bits:bits,rng:rng,eInt:e||65537,e:new BigInteger(null),p:null,q:null,qBits:bits>>1,pBits:bits-(bits>>1),pqState:0,num:null,keys:null};rval.e.fromInt(rval.eInt);}else{throw new Error('Invalid key generation algorithm: '+algorithm);}return rval;};/**
 * Attempts to runs the key-generation algorithm for at most n seconds
 * (approximately) using the given state. When key-generation has completed,
 * the keys will be stored in state.keys.
 *
 * To use this function to update a UI while generating a key or to prevent
 * causing browser lockups/warnings, set "n" to a value other than 0. A
 * simple pattern for generating a key and showing a progress indicator is:
 *
 * var state = pki.rsa.createKeyPairGenerationState(2048);
 * var step = function() {
 *   // step key-generation, run algorithm for 100 ms, repeat
 *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {
 *     setTimeout(step, 1);
 *   } else {
 *     // key-generation complete
 *     // TODO: turn off progress indicator here
 *     // TODO: use the generated key-pair in "state.keys"
 *   }
 * };
 * // TODO: turn on progress indicator here
 * setTimeout(step, 0);
 *
 * @param state the state to use.
 * @param n the maximum number of milliseconds to run the algorithm for, 0
 *          to run the algorithm to completion.
 *
 * @return true if the key-generation completed, false if not.
 */pki.rsa.stepKeyPairGenerationState=function(state,n){// set default algorithm if not set
if(!('algorithm'in state)){state.algorithm='PRIMEINC';}// TODO: migrate step-based prime generation code to forge.prime
// TODO: abstract as PRIMEINC algorithm
// do key generation (based on Tom Wu's rsa.js, see jsbn.js license)
// with some minor optimizations and designed to run in steps
// local state vars
var THIRTY=new BigInteger(null);THIRTY.fromInt(30);var deltaIdx=0;var op_or=function op_or(x,y){return x|y;};// keep stepping until time limit is reached or done
var t1=+new Date();var t2;var total=0;while(state.keys===null&&(n<=0||total<n)){// generate p or q
if(state.state===0){/* Note: All primes are of the form:

        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i

        When we generate a random number, we always align it at 30k + 1. Each
        time the number is determined not to be prime we add to get to the
        next 'i', eg: if the number was at 30k + 1 we add 6. */var bits=state.p===null?state.pBits:state.qBits;var bits1=bits-1;// get a random number
if(state.pqState===0){state.num=new BigInteger(bits,state.rng);// force MSB set
if(!state.num.testBit(bits1)){state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1),op_or,state.num);}// align number on 30k+1 boundary
state.num.dAddOffset(31-state.num.mod(THIRTY).byteValue(),0);deltaIdx=0;++state.pqState;}else if(state.pqState===1){// try to make the number a prime
if(state.num.bitLength()>bits){// overflow, try again
state.pqState=0;// do primality test
}else if(state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))){++state.pqState;}else{// get next potential prime
state.num.dAddOffset(GCD_30_DELTA[deltaIdx++%8],0);}}else if(state.pqState===2){// ensure number is coprime with e
state.pqState=state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)===0?3:0;}else if(state.pqState===3){// store p or q
state.pqState=0;if(state.p===null){state.p=state.num;}else{state.q=state.num;}// advance state if both p and q are ready
if(state.p!==null&&state.q!==null){++state.state;}state.num=null;}}else if(state.state===1){// ensure p is larger than q (swap them if not)
if(state.p.compareTo(state.q)<0){state.num=state.p;state.p=state.q;state.q=state.num;}++state.state;}else if(state.state===2){// compute phi: (p - 1)(q - 1) (Euler's totient function)
state.p1=state.p.subtract(BigInteger.ONE);state.q1=state.q.subtract(BigInteger.ONE);state.phi=state.p1.multiply(state.q1);++state.state;}else if(state.state===3){// ensure e and phi are coprime
if(state.phi.gcd(state.e).compareTo(BigInteger.ONE)===0){// phi and e are coprime, advance
++state.state;}else{// phi and e aren't coprime, so generate a new p and q
state.p=null;state.q=null;state.state=0;}}else if(state.state===4){// create n, ensure n is has the right number of bits
state.n=state.p.multiply(state.q);// ensure n is right number of bits
if(state.n.bitLength()===state.bits){// success, advance
++state.state;}else{// failed, get new q
state.q=null;state.state=0;}}else if(state.state===5){// set keys
var d=state.e.modInverse(state.phi);state.keys={privateKey:pki.rsa.setPrivateKey(state.n,state.e,d,state.p,state.q,d.mod(state.p1),d.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)};}// update timing
t2=+new Date();total+=t2-t1;t1=t2;}return state.keys!==null;};/**
 * Generates an RSA public-private key pair in a single call.
 *
 * To generate a key-pair in steps (to allow for progress updates and to
 * prevent blocking or warnings in slow browsers) then use the key-pair
 * generation state functions.
 *
 * To generate a key-pair asynchronously (either through web-workers, if
 * available, or by breaking up the work on the main thread), pass a
 * callback function.
 *
 * @param [bits] the size for the private key in bits, defaults to 2048.
 * @param [e] the public exponent to use, defaults to 65537.
 * @param [options] options for key-pair generation, if given then 'bits'
 *          and 'e' must *not* be given:
 *          bits the size for the private key in bits, (default: 2048).
 *          e the public exponent to use, (default: 65537 (0x10001)).
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 * @param [callback(err, keypair)] called once the operation completes.
 *
 * @return an object with privateKey and publicKey properties.
 */pki.rsa.generateKeyPair=function(bits,e,options,callback){// (bits), (options), (callback)
if(arguments.length===1){if(_typeof(bits)==='object'){options=bits;bits=undefined;}else if(typeof bits==='function'){callback=bits;bits=undefined;}}else if(arguments.length===2){// (bits, e), (bits, options), (bits, callback), (options, callback)
if(typeof bits==='number'){if(typeof e==='function'){callback=e;e=undefined;}else if(typeof e!=='number'){options=e;e=undefined;}}else{options=bits;callback=e;bits=undefined;e=undefined;}}else if(arguments.length===3){// (bits, e, options), (bits, e, callback), (bits, options, callback)
if(typeof e==='number'){if(typeof options==='function'){callback=options;options=undefined;}}else{callback=options;options=e;e=undefined;}}options=options||{};if(bits===undefined){bits=options.bits||2048;}if(e===undefined){e=options.e||0x10001;}// if native code is permitted and a callback is given, use native
// key generation code if available and if parameters are acceptable
if(!forge.options.usePureJavaScript&&callback&&bits>=256&&bits<=16384&&(e===0x10001||e===3)){if(_detectSubtleCrypto('generateKey')&&_detectSubtleCrypto('exportKey')){// use standard native generateKey
return window.crypto.subtle.generateKey({name:'RSASSA-PKCS1-v1_5',modulusLength:bits,publicExponent:_intToUint8Array(e),hash:{name:'SHA-256'}},true/* key can be exported*/,['sign','verify']).then(function(pair){return window.crypto.subtle.exportKey('pkcs8',pair.privateKey);// avoiding catch(function(err) {...}) to support IE <= 8
}).then(undefined,function(err){callback(err);}).then(function(pkcs8){if(pkcs8){var privateKey=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));callback(null,{privateKey:privateKey,publicKey:pki.setRsaPublicKey(privateKey.n,privateKey.e)});}});}if(_detectSubtleMsCrypto('generateKey')&&_detectSubtleMsCrypto('exportKey')){var genOp=window.msCrypto.subtle.generateKey({name:'RSASSA-PKCS1-v1_5',modulusLength:bits,publicExponent:_intToUint8Array(e),hash:{name:'SHA-256'}},true/* key can be exported*/,['sign','verify']);genOp.oncomplete=function(e){var pair=e.target.result;var exportOp=window.msCrypto.subtle.exportKey('pkcs8',pair.privateKey);exportOp.oncomplete=function(e){var pkcs8=e.target.result;var privateKey=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));callback(null,{privateKey:privateKey,publicKey:pki.setRsaPublicKey(privateKey.n,privateKey.e)});};exportOp.onerror=function(err){callback(err);};};genOp.onerror=function(err){callback(err);};return;}}// use JavaScript implementation
var state=pki.rsa.createKeyPairGenerationState(bits,e,options);if(!callback){pki.rsa.stepKeyPairGenerationState(state,0);return state.keys;}_generateKeyPair(state,options,callback);};/**
 * Sets an RSA public key from BigIntegers modulus and exponent.
 *
 * @param n the modulus.
 * @param e the exponent.
 *
 * @return the public key.
 */pki.setRsaPublicKey=pki.rsa.setPublicKey=function(n,e){var key={n:n,e:e};/**
   * Encrypts the given data with this public key. Newer applications
   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
   * legacy applications.
   *
   * @param data the byte string to encrypt.
   * @param scheme the encryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA encryption,
   *          an object with an 'encode' property set to a function
   *          with the signature 'function(data, key)' that returns
   *          a binary-encoded string representing the encoded data.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the encrypted byte string.
   */key.encrypt=function(data,scheme,schemeOptions){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSAES-PKCS1-V1_5';}if(scheme==='RSAES-PKCS1-V1_5'){scheme={encode:function encode(m,key,pub){return _encodePkcs1_v1_5(m,key,0x02).getBytes();}};}else if(scheme==='RSA-OAEP'||scheme==='RSAES-OAEP'){scheme={encode:function encode(m,key){return forge.pkcs1.encode_rsa_oaep(key,m,schemeOptions);}};}else if(['RAW','NONE','NULL',null].indexOf(scheme)!==-1){scheme={encode:function encode(e){return e;}};}else if(typeof scheme==='string'){throw new Error('Unsupported encryption scheme: "'+scheme+'".');}// do scheme-based encoding then rsa encryption
var e=scheme.encode(data,key,true);return pki.rsa.encrypt(e,key,true);};/**
   * Verifies the given signature against the given digest.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
   * signature is an OCTET STRING that holds a DigestInfo.
   *
   * DigestInfo ::= SEQUENCE {
   *   digestAlgorithm DigestAlgorithmIdentifier,
   *   digest Digest
   * }
   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
   * Digest ::= OCTET STRING
   *
   * To perform PSS signature verification, provide an instance
   * of Forge PSS object as the scheme parameter.
   *
   * @param digest the message digest hash to compare against the signature,
   *          as a binary-encoded string.
   * @param signature the signature to verify, as a binary-encoded string.
   * @param scheme signature verification scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be expected, but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return true if the signature was verified, false if not.
   */key.verify=function(digest,signature,scheme){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSASSA-PKCS1-V1_5';}if(scheme==='RSASSA-PKCS1-V1_5'){scheme={verify:function verify(digest,d){// remove padding
d=_decodePkcs1_v1_5(d,key,true);// d is ASN.1 BER-encoded DigestInfo
var obj=asn1.fromDer(d);// compare the given digest to the decrypted one
return digest===obj.value[1].value;}};}else if(scheme==='NONE'||scheme==='NULL'||scheme===null){scheme={verify:function verify(digest,d){// remove padding
d=_decodePkcs1_v1_5(d,key,true);return digest===d;}};}// do rsa decryption w/o any decoding, then verify -- which does decoding
var d=pki.rsa.decrypt(signature,key,true,false);return scheme.verify(digest,d,key.n.bitLength());};return key;};/**
 * Sets an RSA private key from BigIntegers modulus, exponent, primes,
 * prime exponents, and modular multiplicative inverse.
 *
 * @param n the modulus.
 * @param e the public exponent.
 * @param d the private exponent ((inverse of e) mod n).
 * @param p the first prime.
 * @param q the second prime.
 * @param dP exponent1 (d mod (p-1)).
 * @param dQ exponent2 (d mod (q-1)).
 * @param qInv ((inverse of q) mod p)
 *
 * @return the private key.
 */pki.setRsaPrivateKey=pki.rsa.setPrivateKey=function(n,e,d,p,q,dP,dQ,qInv){var key={n:n,e:e,d:d,p:p,q:q,dP:dP,dQ:dQ,qInv:qInv};/**
   * Decrypts the given data with this private key. The decryption scheme
   * must match the one used to encrypt the data.
   *
   * @param data the byte string to decrypt.
   * @param scheme the decryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA decryption.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the decrypted byte string.
   */key.decrypt=function(data,scheme,schemeOptions){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSAES-PKCS1-V1_5';}// do rsa decryption w/o any decoding
var d=pki.rsa.decrypt(data,key,false,false);if(scheme==='RSAES-PKCS1-V1_5'){scheme={decode:_decodePkcs1_v1_5};}else if(scheme==='RSA-OAEP'||scheme==='RSAES-OAEP'){scheme={decode:function decode(d,key){return forge.pkcs1.decode_rsa_oaep(key,d,schemeOptions);}};}else if(['RAW','NONE','NULL',null].indexOf(scheme)!==-1){scheme={decode:function decode(d){return d;}};}else{throw new Error('Unsupported encryption scheme: "'+scheme+'".');}// decode according to scheme
return scheme.decode(d,key,false);};/**
   * Signs the given digest, producing a signature.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
   * an instance of Forge PSS object as the scheme parameter.
   *
   * @param md the message digest object with the hash to sign.
   * @param scheme the signature scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be used but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return the signature as a byte string.
   */key.sign=function(md,scheme){/* Note: The internal implementation of RSA operations is being
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy
      code like the use of an encoding block identifier 'bt' will eventually
      be removed. */ // private key operation
var bt=false;if(typeof scheme==='string'){scheme=scheme.toUpperCase();}if(scheme===undefined||scheme==='RSASSA-PKCS1-V1_5'){scheme={encode:emsaPkcs1v15encode};bt=0x01;}else if(scheme==='NONE'||scheme==='NULL'||scheme===null){scheme={encode:function encode(){return md;}};bt=0x01;}// encode and then encrypt
var d=scheme.encode(md,key.n.bitLength());return pki.rsa.encrypt(d,key,bt);};return key;};/**
 * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.
 *
 * @param rsaKey the ASN.1 RSAPrivateKey.
 *
 * @return the ASN.1 PrivateKeyInfo.
 */pki.wrapRsaPrivateKey=function(rsaKey){// PrivateKeyInfo
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (0)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(0).getBytes()),// privateKeyAlgorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// PrivateKey
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(rsaKey).getBytes())]);};/**
 * Converts a private key from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a PrivateKeyInfo containing an
 *          RSAPrivateKey or an RSAPrivateKey.
 *
 * @return the private key.
 */pki.privateKeyFromAsn1=function(obj){// get PrivateKeyInfo
var capture={};var errors=[];if(asn1.validate(obj,privateKeyValidator,capture,errors)){obj=asn1.fromDer(forge.util.createBuffer(capture.privateKey));}// get RSAPrivateKey
capture={};errors=[];if(!asn1.validate(obj,rsaPrivateKeyValidator,capture,errors)){var error=new Error('Cannot read private key. '+'ASN.1 object does not contain an RSAPrivateKey.');error.errors=errors;throw error;}// Note: Version is currently ignored.
// capture.privateKeyVersion
// FIXME: inefficient, get a BigInteger that uses byte strings
var n,e,d,p,q,dP,dQ,qInv;n=forge.util.createBuffer(capture.privateKeyModulus).toHex();e=forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();d=forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();p=forge.util.createBuffer(capture.privateKeyPrime1).toHex();q=forge.util.createBuffer(capture.privateKeyPrime2).toHex();dP=forge.util.createBuffer(capture.privateKeyExponent1).toHex();dQ=forge.util.createBuffer(capture.privateKeyExponent2).toHex();qInv=forge.util.createBuffer(capture.privateKeyCoefficient).toHex();// set private key
return pki.setRsaPrivateKey(new BigInteger(n,16),new BigInteger(e,16),new BigInteger(d,16),new BigInteger(p,16),new BigInteger(q,16),new BigInteger(dP,16),new BigInteger(dQ,16),new BigInteger(qInv,16));};/**
 * Converts a private key to an ASN.1 RSAPrivateKey.
 *
 * @param key the private key.
 *
 * @return the ASN.1 representation of an RSAPrivateKey.
 */pki.privateKeyToAsn1=pki.privateKeyToRSAPrivateKey=function(key){// RSAPrivateKey
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (0 = only 2 primes, 1 multiple primes)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(0).getBytes()),// modulus (n)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.n)),// publicExponent (e)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.e)),// privateExponent (d)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.d)),// privateKeyPrime1 (p)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.p)),// privateKeyPrime2 (q)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.q)),// privateKeyExponent1 (dP)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.dP)),// privateKeyExponent2 (dQ)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.dQ)),// coefficient (qInv)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.qInv))]);};/**
 * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @return the public key.
 */pki.publicKeyFromAsn1=function(obj){// get SubjectPublicKeyInfo
var capture={};var errors=[];if(asn1.validate(obj,publicKeyValidator,capture,errors)){// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){var error=new Error('Cannot read public key. Unknown OID.');error.oid=oid;throw error;}obj=capture.rsaPublicKey;}// get RSA params
errors=[];if(!asn1.validate(obj,rsaPublicKeyValidator,capture,errors)){var error=new Error('Cannot read public key. '+'ASN.1 object does not contain an RSAPublicKey.');error.errors=errors;throw error;}// FIXME: inefficient, get a BigInteger that uses byte strings
var n=forge.util.createBuffer(capture.publicKeyModulus).toHex();var e=forge.util.createBuffer(capture.publicKeyExponent).toHex();// set public key
return pki.setRsaPublicKey(new BigInteger(n,16),new BigInteger(e,16));};/**
 * Converts a public key to an ASN.1 SubjectPublicKeyInfo.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a SubjectPublicKeyInfo.
 */pki.publicKeyToAsn1=pki.publicKeyToSubjectPublicKeyInfo=function(key){// SubjectPublicKeyInfo
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AlgorithmIdentifier
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),// parameters (null)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// subjectPublicKey
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,[pki.publicKeyToRSAPublicKey(key)])]);};/**
 * Converts a public key to an ASN.1 RSAPublicKey.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a RSAPublicKey.
 */pki.publicKeyToRSAPublicKey=function(key){// RSAPublicKey
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// modulus (n)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.n)),// publicExponent (e)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.e))]);};/**
 * Encodes a message using PKCS#1 v1.5 padding.
 *
 * @param m the message to encode.
 * @param key the RSA key to use.
 * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02
 *          (for encryption).
 *
 * @return the padded byte buffer.
 */function _encodePkcs1_v1_5(m,key,bt){var eb=forge.util.createBuffer();// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);/* use PKCS#1 v1.5 padding */if(m.length>k-11){var error=new Error('Message is too long for PKCS#1 v1.5 padding.');error.length=m.length;error.max=k-11;throw error;}/* A block type BT, a padding string PS, and the data D shall be
    formatted into an octet string EB, the encryption block:

    EB = 00 || BT || PS || 00 || D

    The block type BT shall be a single octet indicating the structure of
    the encryption block. For this version of the document it shall have
    value 00, 01, or 02. For a private-key operation, the block type
    shall be 00 or 01. For a public-key operation, it shall be 02.

    The padding string PS shall consist of k-3-||D|| octets. For block
    type 00, the octets shall have value 00; for block type 01, they
    shall have value FF; and for block type 02, they shall be
    pseudorandomly generated and nonzero. This makes the length of the
    encryption block EB equal to k. */ // build the encryption block
eb.putByte(0x00);eb.putByte(bt);// create the padding
var padNum=k-3-m.length;var padByte;// private key op
if(bt===0x00||bt===0x01){padByte=bt===0x00?0x00:0xFF;for(var i=0;i<padNum;++i){eb.putByte(padByte);}}else{// public key op
// pad with random non-zero values
while(padNum>0){var numZeros=0;var padBytes=forge.random.getBytes(padNum);for(var i=0;i<padNum;++i){padByte=padBytes.charCodeAt(i);if(padByte===0){++numZeros;}else{eb.putByte(padByte);}}padNum=numZeros;}}// zero followed by message
eb.putByte(0x00);eb.putBytes(m);return eb;}/**
 * Decodes a message using PKCS#1 v1.5 padding.
 *
 * @param em the message to decode.
 * @param key the RSA key to use.
 * @param pub true if the key is a public key, false if it is private.
 * @param ml the message length, if specified.
 *
 * @return the decoded bytes.
 */function _decodePkcs1_v1_5(em,key,pub,ml){// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);/* It is an error if any of the following conditions occurs:

    1. The encryption block EB cannot be parsed unambiguously.
    2. The padding string PS consists of fewer than eight octets
      or is inconsisent with the block type BT.
    3. The decryption process is a public-key operation and the block
      type BT is not 00 or 01, or the decryption process is a
      private-key operation and the block type is not 02.
   */ // parse the encryption block
var eb=forge.util.createBuffer(em);var first=eb.getByte();var bt=eb.getByte();if(first!==0x00||pub&&bt!==0x00&&bt!==0x01||!pub&&bt!=0x02||pub&&bt===0x00&&typeof ml==='undefined'){throw new Error('Encryption block is invalid.');}var padNum=0;if(bt===0x00){// check all padding bytes for 0x00
padNum=k-3-ml;for(var i=0;i<padNum;++i){if(eb.getByte()!==0x00){throw new Error('Encryption block is invalid.');}}}else if(bt===0x01){// find the first byte that isn't 0xFF, should be after all padding
padNum=0;while(eb.length()>1){if(eb.getByte()!==0xFF){--eb.read;break;}++padNum;}}else if(bt===0x02){// look for 0x00 byte
padNum=0;while(eb.length()>1){if(eb.getByte()===0x00){--eb.read;break;}++padNum;}}// zero must be 0x00 and padNum must be (k - 3 - message length)
var zero=eb.getByte();if(zero!==0x00||padNum!==k-3-eb.length()){throw new Error('Encryption block is invalid.');}return eb.getBytes();}/**
 * Runs the key-generation algorithm asynchronously, either in the background
 * via Web Workers, or using the main thread and setImmediate.
 *
 * @param state the key-pair generation state.
 * @param [options] options for key-pair generation:
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2, -1 to use estimated cores minus one).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 * @param callback(err, keypair) called once the operation completes.
 */function _generateKeyPair(state,options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};var opts={algorithm:{name:options.algorithm||'PRIMEINC',options:{workers:options.workers||2,workLoad:options.workLoad||100,workerScript:options.workerScript}}};if('prng'in options){opts.prng=options.prng;}generate();function generate(){// find p and then q (done in series to simplify)
getPrime(state.pBits,function(err,num){if(err){return callback(err);}state.p=num;if(state.q!==null){return finish(err,state.q);}getPrime(state.qBits,finish);});}function getPrime(bits,callback){forge.prime.generateProbablePrime(bits,opts,callback);}function finish(err,num){if(err){return callback(err);}// set q
state.q=num;// ensure p is larger than q (swap them if not)
if(state.p.compareTo(state.q)<0){var tmp=state.p;state.p=state.q;state.q=tmp;}// ensure p is coprime with e
if(state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)!==0){state.p=null;generate();return;}// ensure q is coprime with e
if(state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)!==0){state.q=null;getPrime(state.qBits,finish);return;}// compute phi: (p - 1)(q - 1) (Euler's totient function)
state.p1=state.p.subtract(BigInteger.ONE);state.q1=state.q.subtract(BigInteger.ONE);state.phi=state.p1.multiply(state.q1);// ensure e and phi are coprime
if(state.phi.gcd(state.e).compareTo(BigInteger.ONE)!==0){// phi and e aren't coprime, so generate a new p and q
state.p=state.q=null;generate();return;}// create n, ensure n is has the right number of bits
state.n=state.p.multiply(state.q);if(state.n.bitLength()!==state.bits){// failed, get new q
state.q=null;getPrime(state.qBits,finish);return;}// set keys
var d=state.e.modInverse(state.phi);state.keys={privateKey:pki.rsa.setPrivateKey(state.n,state.e,d,state.p,state.q,d.mod(state.p1),d.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)};callback(null,state.keys);}}/**
 * Converts a positive BigInteger into 2's-complement big-endian bytes.
 *
 * @param b the big integer to convert.
 *
 * @return the bytes.
 */function _bnToBytes(b){// prepend 0x00 if first byte >= 0x80
var hex=b.toString(16);if(hex[0]>='8'){hex='00'+hex;}var bytes=forge.util.hexToBytes(hex);// ensure integer is minimally-encoded
if(bytes.length>1&&(// leading 0x00 for positive integer
bytes.charCodeAt(0)===0&&(bytes.charCodeAt(1)&0x80)===0||// leading 0xFF for negative integer
bytes.charCodeAt(0)===0xFF&&(bytes.charCodeAt(1)&0x80)===0x80)){return bytes.substr(1);}return bytes;}/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */function _getMillerRabinTests(bits){if(bits<=100)return 27;if(bits<=150)return 18;if(bits<=200)return 15;if(bits<=250)return 12;if(bits<=300)return 9;if(bits<=350)return 8;if(bits<=400)return 7;if(bits<=500)return 6;if(bits<=600)return 5;if(bits<=800)return 4;if(bits<=1250)return 3;return 2;}/**
 * Performs feature detection on the SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */function _detectSubtleCrypto(fn){return typeof window!=='undefined'&&_typeof(window.crypto)==='object'&&_typeof(window.crypto.subtle)==='object'&&typeof window.crypto.subtle[fn]==='function';}/**
 * Performs feature detection on the deprecated Microsoft Internet Explorer
 * outdated SubtleCrypto interface. This function should only be used after
 * checking for the modern, standard SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */function _detectSubtleMsCrypto(fn){return typeof window!=='undefined'&&_typeof(window.msCrypto)==='object'&&_typeof(window.msCrypto.subtle)==='object'&&typeof window.msCrypto.subtle[fn]==='function';}function _intToUint8Array(x){var bytes=forge.util.hexToBytes(x.toString(16));var buffer=new Uint8Array(bytes.length);for(var i=0;i<bytes.length;++i){buffer[i]=bytes.charCodeAt(i);}return buffer;}function _privateKeyFromJwk(jwk){if(jwk.kty!=='RSA'){throw new Error('Unsupported key algorithm "'+jwk.kty+'"; algorithm must be "RSA".');}return pki.setRsaPrivateKey(_base64ToBigInt(jwk.n),_base64ToBigInt(jwk.e),_base64ToBigInt(jwk.d),_base64ToBigInt(jwk.p),_base64ToBigInt(jwk.q),_base64ToBigInt(jwk.dp),_base64ToBigInt(jwk.dq),_base64ToBigInt(jwk.qi));}function _publicKeyFromJwk(jwk){if(jwk.kty!=='RSA'){throw new Error('Key algorithm must be "RSA".');}return pki.setRsaPublicKey(_base64ToBigInt(jwk.n),_base64ToBigInt(jwk.e));}function _base64ToBigInt(b64){return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)),16);}/***/},/* 7 */ /***/function(module,exports,__webpack_require__){/**
 * Advanced Encryption Standard (AES) implementation.
 *
 * This implementation is based on the public domain library 'jscrypto' which
 * was written by:
 *
 * Emily Stark (estark@stanford.edu)
 * Mike Hamburg (mhamburg@stanford.edu)
 * Dan Boneh (dabo@cs.stanford.edu)
 *
 * Parts of this code are based on the OpenSSL implementation of AES:
 * http://www.openssl.org
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(10);__webpack_require__(11);__webpack_require__(1);/* AES API */module.exports=forge.aes=forge.aes||{};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.startEncrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:false,mode:mode});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.createEncryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:false,mode:mode});};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.startDecrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:true,mode:mode});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.createDecryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:true,mode:mode});};/**
 * Creates a new AES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the AES algorithm object.
 */forge.aes.Algorithm=function(name,mode){if(!init){initialize();}var self=this;self.name=name;self.mode=new mode({blockSize:16,cipher:{encrypt:function encrypt(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,false);},decrypt:function decrypt(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,true);}}});self._init=false;};/**
 * Initializes this AES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */forge.aes.Algorithm.prototype.initialize=function(options){if(this._init){return;}var key=options.key;var tmp;/* Note: The key may be a string of bytes, an array of bytes, a byte
    buffer, or an array of 32-bit integers. If the key is in bytes, then
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit
    integers, it must be 4, 6, or 8 integers long. */if(typeof key==='string'&&(key.length===16||key.length===24||key.length===32)){// convert key string into byte buffer
key=forge.util.createBuffer(key);}else if(forge.util.isArray(key)&&(key.length===16||key.length===24||key.length===32)){// convert key integer array into byte buffer
tmp=key;key=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){key.putByte(tmp[i]);}}// convert key byte buffer into 32-bit integer array
if(!forge.util.isArray(key)){tmp=key;key=[];// key lengths of 16, 24, 32 bytes allowed
var len=tmp.length();if(len===16||len===24||len===32){len=len>>>2;for(var i=0;i<len;++i){key.push(tmp.getInt32());}}}// key must be an array of 32-bit integers by now
if(!forge.util.isArray(key)||!(key.length===4||key.length===6||key.length===8)){throw new Error('Invalid key parameter.');}// encryption operation is always used for these modes
var mode=this.mode.name;var encryptOp=['CFB','OFB','CTR','GCM'].indexOf(mode)!==-1;// do key expansion
this._w=_expandKey(key,options.decrypt&&!encryptOp);this._init=true;};/**
 * Expands a key. Typically only used for testing.
 *
 * @param key the symmetric key to expand, as an array of 32-bit words.
 * @param decrypt true to expand for decryption, false for encryption.
 *
 * @return the expanded key.
 */forge.aes._expandKey=function(key,decrypt){if(!init){initialize();}return _expandKey(key,decrypt);};/**
 * Updates a single block. Typically only used for testing.
 *
 * @param w the expanded key to use.
 * @param input an array of block-size 32-bit words.
 * @param output an array of block-size 32-bit words.
 * @param decrypt true to decrypt, false to encrypt.
 */forge.aes._updateBlock=_updateBlock;/** Register AES algorithms **/registerAlgorithm('AES-ECB',forge.cipher.modes.ecb);registerAlgorithm('AES-CBC',forge.cipher.modes.cbc);registerAlgorithm('AES-CFB',forge.cipher.modes.cfb);registerAlgorithm('AES-OFB',forge.cipher.modes.ofb);registerAlgorithm('AES-CTR',forge.cipher.modes.ctr);registerAlgorithm('AES-GCM',forge.cipher.modes.gcm);function registerAlgorithm(name,mode){var factory=function factory(){return new forge.aes.Algorithm(name,mode);};forge.cipher.registerAlgorithm(name,factory);}/** AES implementation **/var init=false;// not yet initialized
var Nb=4;// number of words comprising the state (AES = 4)
var sbox;// non-linear substitution table used in key expansion
var isbox;// inversion of sbox
var rcon;// round constant word array
var mix;// mix-columns table
var imix;// inverse mix-columns table
/**
 * Performs initialization, ie: precomputes tables to optimize for speed.
 *
 * One way to understand how AES works is to imagine that 'addition' and
 * 'multiplication' are interfaces that require certain mathematical
 * properties to hold true (ie: they are associative) but they might have
 * different implementations and produce different kinds of results ...
 * provided that their mathematical properties remain true. AES defines
 * its own methods of addition and multiplication but keeps some important
 * properties the same, ie: associativity and distributivity. The
 * explanation below tries to shed some light on how AES defines addition
 * and multiplication of bytes and 32-bit words in order to perform its
 * encryption and decryption algorithms.
 *
 * The basics:
 *
 * The AES algorithm views bytes as binary representations of polynomials
 * that have either 1 or 0 as the coefficients. It defines the addition
 * or subtraction of two bytes as the XOR operation. It also defines the
 * multiplication of two bytes as a finite field referred to as GF(2^8)
 * (Note: 'GF' means "Galois Field" which is a field that contains a finite
 * number of elements so GF(2^8) has 256 elements).
 *
 * This means that any two bytes can be represented as binary polynomials;
 * when they multiplied together and modularly reduced by an irreducible
 * polynomial of the 8th degree, the results are the field GF(2^8). The
 * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
 * This multiplication is associative with 0x01 as the identity:
 *
 * (b * 0x01 = GF(b, 0x01) = b).
 *
 * The operation GF(b, 0x02) can be performed at the byte level by left
 * shifting b once and then XOR'ing it (to perform the modular reduction)
 * with 0x11b if b is >= 128. Repeated application of the multiplication
 * of 0x02 can be used to implement the multiplication of any two bytes.
 *
 * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
 * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
 * factors can each be multiplied by 0x57 and then added together. To do
 * the multiplication, values for 0x57 multiplied by each of these 3 factors
 * can be precomputed and stored in a table. To add them, the values from
 * the table are XOR'd together.
 *
 * AES also defines addition and multiplication of words, that is 4-byte
 * numbers represented as polynomials of 3 degrees where the coefficients
 * are the values of the bytes.
 *
 * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
 *
 * Addition is performed by XOR'ing like powers of x. Multiplication
 * is performed in two steps, the first is an algebriac expansion as
 * you would do normally (where addition is XOR). But the result is
 * a polynomial larger than 3 degrees and thus it cannot fit in a word. So
 * next the result is modularly reduced by an AES-specific polynomial of
 * degree 4 which will always produce a polynomial of less than 4 degrees
 * such that it will fit in a word. In AES, this polynomial is x^4 + 1.
 *
 * The modular product of two polynomials 'a' and 'b' is thus:
 *
 * d(x) = d3x^3 + d2x^2 + d1x + d0
 * with
 * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
 * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
 * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
 * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
 *
 * As a matrix:
 *
 * [d0] = [a0 a3 a2 a1][b0]
 * [d1]   [a1 a0 a3 a2][b1]
 * [d2]   [a2 a1 a0 a3][b2]
 * [d3]   [a3 a2 a1 a0][b3]
 *
 * Special polynomials defined by AES (0x02 == {02}):
 * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
 * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
 *
 * These polynomials are used in the MixColumns() and InverseMixColumns()
 * operations, respectively, to cause each element in the state to affect
 * the output (referred to as diffusing).
 *
 * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
 * polynomial x3.
 *
 * The ShiftRows() method modifies the last 3 rows in the state (where
 * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
 * The 1st byte in the second row is moved to the end of the row. The 1st
 * and 2nd bytes in the third row are moved to the end of the row. The 1st,
 * 2nd, and 3rd bytes are moved in the fourth row.
 *
 * More details on how AES arithmetic works:
 *
 * In the polynomial representation of binary numbers, XOR performs addition
 * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
 * corresponds with the multiplication of polynomials modulo an irreducible
 * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply
 * polynomial 'a' with polynomial 'b' and then do a modular reduction by
 * an AES-specific irreducible polynomial of degree 8.
 *
 * A polynomial is irreducible if its only divisors are one and itself. For
 * the AES algorithm, this irreducible polynomial is:
 *
 * m(x) = x^8 + x^4 + x^3 + x + 1,
 *
 * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:
 * 100011011 = 283 = 0x11b.
 *
 * For example, GF(0x57, 0x83) = 0xc1 because
 *
 * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1
 * 0x85 = 131 = 10000101 = x^7 + x + 1
 *
 * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)
 * =  x^13 + x^11 + x^9 + x^8 + x^7 +
 *    x^7 + x^5 + x^3 + x^2 + x +
 *    x^6 + x^4 + x^2 + x + 1
 * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y
 *    y modulo (x^8 + x^4 + x^3 + x + 1)
 * =  x^7 + x^6 + 1.
 *
 * The modular reduction by m(x) guarantees the result will be a binary
 * polynomial of less than degree 8, so that it can fit in a byte.
 *
 * The operation to multiply a binary polynomial b with x (the polynomial
 * x in binary representation is 00000010) is:
 *
 * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1
 *
 * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the
 * most significant bit is 0 in b) then the result is already reduced. If
 * it is 1, then we can reduce it by subtracting m(x) via an XOR.
 *
 * It follows that multiplication by x (00000010 or 0x02) can be implemented
 * by performing a left shift followed by a conditional bitwise XOR with
 * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by
 * higher powers of x can be implemented by repeated application of xtime().
 *
 * By adding intermediate results, multiplication by any constant can be
 * implemented. For instance:
 *
 * GF(0x57, 0x13) = 0xfe because:
 *
 * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)
 *
 * Note: We XOR with 0x11b instead of 0x1b because in javascript our
 * datatype for b can be larger than 1 byte, so a left shift will not
 * automatically eliminate bits that overflow a byte ... by XOR'ing the
 * overflow bit with 1 (the extra one from 0x11b) we zero it out.
 *
 * GF(0x57, 0x02) = xtime(0x57) = 0xae
 * GF(0x57, 0x04) = xtime(0xae) = 0x47
 * GF(0x57, 0x08) = xtime(0x47) = 0x8e
 * GF(0x57, 0x10) = xtime(0x8e) = 0x07
 *
 * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))
 *
 * And by the distributive property (since XOR is addition and GF() is
 * multiplication):
 *
 * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)
 * = 0x57 ^ 0xae ^ 0x07
 * = 0xfe.
 */function initialize(){init=true;/* Populate the Rcon table. These are the values given by
    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)
    in the field of GF(2^8), where i starts at 1.

    rcon[0] = [0x00, 0x00, 0x00, 0x00]
    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1
    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2
    ...
    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B
    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36

    We only store the first byte because it is the only one used.
  */rcon=[0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36];// compute xtime table which maps i onto GF(i, 0x02)
var xtime=new Array(256);for(var i=0;i<128;++i){xtime[i]=i<<1;xtime[i+128]=i+128<<1^0x11B;}// compute all other tables
sbox=new Array(256);isbox=new Array(256);mix=new Array(4);imix=new Array(4);for(var i=0;i<4;++i){mix[i]=new Array(256);imix[i]=new Array(256);}var e=0,ei=0,e2,e4,e8,sx,sx2,me,ime;for(var i=0;i<256;++i){/* We need to generate the SubBytes() sbox and isbox tables so that
      we can perform byte substitutions. This requires us to traverse
      all of the elements in GF, find their multiplicative inverses,
      and apply to each the following affine transformation:

      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^
            b(i + 7) mod 8 ^ ci
      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the
      ith bit of a byte c with the value {63} or {01100011}.

      It is possible to traverse every possible value in a Galois field
      using what is referred to as a 'generator'. There are many
      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully
      traverse GF we iterate 255 times, multiplying by our generator
      each time.

      On each iteration we can determine the multiplicative inverse for
      the current element.

      Suppose there is an element in GF 'e'. For a given generator 'g',
      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns
      out that if use the inverse of a generator as another generator
      it will produce all of the corresponding multiplicative inverses
      at the same time. For this reason, we choose 5 as our inverse
      generator because it only requires 2 multiplies and 1 add and its
      inverse, 82, requires relatively few operations as well.

      In order to apply the affine transformation, the multiplicative
      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a
      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and
      'x'. Then 's' is left shifted and the high bit of 's' is made the
      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd
      with 's' and stored in 'x'. On each subsequent iteration the same
      operation is performed. When 4 iterations are complete, 'x' is
      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.
      For example:

      s = 01000001
      x = 01000001

      iteration 1: s = 10000010, x ^= s
      iteration 2: s = 00000101, x ^= s
      iteration 3: s = 00001010, x ^= s
      iteration 4: s = 00010100, x ^= s
      x ^= 0x63

      This can be done with a loop where s = (s << 1) | (s >> 7). However,
      it can also be done by using a single 16-bit (in this case 32-bit)
      number 'sx'. Since XOR is an associative operation, we can set 'sx'
      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.
      The most significant bits will flow into the high 8 bit positions
      and be correctly XOR'd with one another. All that remains will be
      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits
      afterwards.

      At the same time we're populating sbox and isbox we can precompute
      the multiplication we'll need to do to do MixColumns() later.
    */ // apply affine transformation
sx=ei^ei<<1^ei<<2^ei<<3^ei<<4;sx=sx>>8^sx&255^0x63;// update tables
sbox[e]=sx;isbox[sx]=e;/* Mixing columns is done using matrix multiplication. The columns
      that are to be mixed are each a single word in the current state.
      The state has Nb columns (4 columns). Therefore each column is a
      4 byte word. So to mix the columns in a single column 'c' where
      its rows are r0, r1, r2, and r3, we use the following matrix
      multiplication:

      [2 3 1 1]*[r0,c]=[r'0,c]
      [1 2 3 1] [r1,c] [r'1,c]
      [1 1 2 3] [r2,c] [r'2,c]
      [3 1 1 2] [r3,c] [r'3,c]

      r0, r1, r2, and r3 are each 1 byte of one of the words in the
      state (a column). To do matrix multiplication for each mixed
      column c' we multiply the corresponding row from the left matrix
      with the corresponding column from the right matrix. In total, we
      get 4 equations:

      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c
      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c
      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c
      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c

      As usual, the multiplication is as previously defined and the
      addition is XOR. In order to optimize mixing columns we can store
      the multiplication results in tables. If you think of the whole
      column as a word (it might help to visualize by mentally rotating
      the equations above by counterclockwise 90 degrees) then you can
      see that it would be useful to map the multiplications performed on
      each byte (r0, r1, r2, r3) onto a word as well. For instance, we
      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the
      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two
      respectively in the middle). This means that a table can be
      constructed that uses r0 as an index to the word. We can do the
      same with r1, r2, and r3, creating a total of 4 tables.

      To construct a full c', we can just look up each byte of c in
      their respective tables and XOR the results together.

      Also, to build each table we only have to calculate the word
      for 2,1,1,3 for every byte ... which we can do on each iteration
      of this loop since we will iterate over every byte. After we have
      calculated 2,1,1,3 we can get the results for the other tables
      by cycling the byte at the end to the beginning. For instance
      we can take the result of table 2,1,1,3 and produce table 3,2,1,1
      by moving the right most byte to the left most position just like
      how you can imagine the 3 moved out of 2,1,1,3 and to the front
      to produce 3,2,1,1.

      There is another optimization in that the same multiples of
      the current element we need in order to advance our generator
      to the next iteration can be reused in performing the 2,1,1,3
      calculation. We also calculate the inverse mix column tables,
      with e,9,d,b being the inverse of 2,1,1,3.

      When we're done, and we need to actually mix columns, the first
      byte of each state word should be put through mix[0] (2,1,1,3),
      the second through mix[1] (3,2,1,1) and so forth. Then they should
      be XOR'd together to produce the fully mixed column.
    */ // calculate mix and imix table values
sx2=xtime[sx];e2=xtime[e];e4=xtime[e2];e8=xtime[e4];me=sx2<<24^// 2
sx<<16^// 1
sx<<8^(// 1
sx^sx2);// 3
ime=(e2^e4^e8)<<24^// E (14)
(e^e8)<<16^// 9
(e^e4^e8)<<8^(// D (13)
e^e2^e8);// B (11)
// produce each of the mix tables by rotating the 2,1,1,3 value
for(var n=0;n<4;++n){mix[n][e]=me;imix[n][sx]=ime;// cycle the right most byte to the left most position
// ie: 2,1,1,3 becomes 3,2,1,1
me=me<<24|me>>>8;ime=ime<<24|ime>>>8;}// get next element and inverse
if(e===0){// 1 is the inverse of 1
e=ei=1;}else{// e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)
// ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)
e=e2^xtime[xtime[xtime[e2^e8]]];ei^=xtime[xtime[ei]];}}}/**
 * Generates a key schedule using the AES key expansion algorithm.
 *
 * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
 * routine to generate a key schedule. The Key Expansion generates a total
 * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
 * and each of the Nr rounds requires Nb words of key data. The resulting
 * key schedule consists of a linear array of 4-byte words, denoted [wi ],
 * with i in the range 0  i < Nb(Nr + 1).
 *
 * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
 * AES-128 (Nb=4, Nk=4, Nr=10)
 * AES-192 (Nb=4, Nk=6, Nr=12)
 * AES-256 (Nb=4, Nk=8, Nr=14)
 * Note: Nr=Nk+6.
 *
 * Nb is the number of columns (32-bit words) comprising the State (or
 * number of bytes in a block). For AES, Nb=4.
 *
 * @param key the key to schedule (as an array of 32-bit words).
 * @param decrypt true to modify the key schedule to decrypt, false not to.
 *
 * @return the generated key schedule.
 */function _expandKey(key,decrypt){// copy the key's words to initialize the key schedule
var w=key.slice(0);/* RotWord() will rotate a word, moving the first byte to the last
    byte's position (shifting the other bytes left).

    We will be getting the value of Rcon at i / Nk. 'i' will iterate
    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in
    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from
    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will
    increase by 1. We use a counter iNk to keep track of this.
   */ // go through the rounds expanding the key
var temp,iNk=1;var Nk=w.length;var Nr1=Nk+6+1;var end=Nb*Nr1;for(var i=Nk;i<end;++i){temp=w[i-1];if(i%Nk===0){// temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]
temp=sbox[temp>>>16&255]<<24^sbox[temp>>>8&255]<<16^sbox[temp&255]<<8^sbox[temp>>>24]^rcon[iNk]<<24;iNk++;}else if(Nk>6&&i%Nk===4){// temp = SubWord(temp)
temp=sbox[temp>>>24]<<24^sbox[temp>>>16&255]<<16^sbox[temp>>>8&255]<<8^sbox[temp&255];}w[i]=w[i-Nk]^temp;}/* When we are updating a cipher block we always use the code path for
     encryption whether we are decrypting or not (to shorten code and
     simplify the generation of look up tables). However, because there
     are differences in the decryption algorithm, other than just swapping
     in different look up tables, we must transform our key schedule to
     account for these changes:

     1. The decryption algorithm gets its key rounds in reverse order.
     2. The decryption algorithm adds the round key before mixing columns
       instead of afterwards.

     We don't need to modify our key schedule to handle the first case,
     we can just traverse the key schedule in reverse order when decrypting.

     The second case requires a little work.

     The tables we built for performing rounds will take an input and then
     perform SubBytes() and MixColumns() or, for the decrypt version,
     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires
     us to AddRoundKey() before InvMixColumns(). This means we'll need to
     apply some transformations to the round key to inverse-mix its columns
     so they'll be correct for moving AddRoundKey() to after the state has
     had its columns inverse-mixed.

     To inverse-mix the columns of the state when we're decrypting we use a
     lookup table that will apply InvSubBytes() and InvMixColumns() at the
     same time. However, the round key's bytes are not inverse-substituted
     in the decryption algorithm. To get around this problem, we can first
     substitute the bytes in the round key so that when we apply the
     transformation via the InvSubBytes()+InvMixColumns() table, it will
     undo our substitution leaving us with the original value that we
     want -- and then inverse-mix that value.

     This change will correctly alter our key schedule so that we can XOR
     each round key with our already transformed decryption state. This
     allows us to use the same code path as the encryption algorithm.

     We make one more change to the decryption key. Since the decryption
     algorithm runs in reverse from the encryption algorithm, we reverse
     the order of the round keys to avoid having to iterate over the key
     schedule backwards when running the encryption algorithm later in
     decryption mode. In addition to reversing the order of the round keys,
     we also swap each round key's 2nd and 4th rows. See the comments
     section where rounds are performed for more details about why this is
     done. These changes are done inline with the other substitution
     described above.
  */if(decrypt){var tmp;var m0=imix[0];var m1=imix[1];var m2=imix[2];var m3=imix[3];var wnew=w.slice(0);end=w.length;for(var i=0,wi=end-Nb;i<end;i+=Nb,wi-=Nb){// do not sub the first or last round key (round keys are Nb
// words) as no column mixing is performed before they are added,
// but do change the key order
if(i===0||i===end-Nb){wnew[i]=w[wi];wnew[i+1]=w[wi+3];wnew[i+2]=w[wi+2];wnew[i+3]=w[wi+1];}else{// substitute each round key byte because the inverse-mix
// table will inverse-substitute it (effectively cancel the
// substitution because round key bytes aren't sub'd in
// decryption mode) and swap indexes 3 and 1
for(var n=0;n<Nb;++n){tmp=w[wi+n];wnew[i+(3&-n)]=m0[sbox[tmp>>>24]]^m1[sbox[tmp>>>16&255]]^m2[sbox[tmp>>>8&255]]^m3[sbox[tmp&255]];}}}w=wnew;}return w;}/**
 * Updates a single block (16 bytes) using AES. The update will either
 * encrypt or decrypt the block.
 *
 * @param w the key schedule.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */function _updateBlock(w,input,output,decrypt){/*
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr1
      SubBytes(state)
      ShiftRows(state)
      MixColumns(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
  end

  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    for round = Nr-1 step -1 downto 1
      InvShiftRows(state)
      InvSubBytes(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
      InvMixColumns(state)
    end for
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
    out = state
  end
  */ // Encrypt: AddRoundKey(state, w[0, Nb-1])
// Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
var Nr=w.length/4-1;var m0,m1,m2,m3,sub;if(decrypt){m0=imix[0];m1=imix[1];m2=imix[2];m3=imix[3];sub=isbox;}else{m0=mix[0];m1=mix[1];m2=mix[2];m3=mix[3];sub=sbox;}var a,b,c,d,a2,b2,c2;a=input[0]^w[0];b=input[decrypt?3:1]^w[1];c=input[2]^w[2];d=input[decrypt?1:3]^w[3];var i=3;/* In order to share code we follow the encryption algorithm when both
    encrypting and decrypting. To account for the changes required in the
    decryption algorithm, we use different lookup tables when decrypting
    and use a modified key schedule to account for the difference in the
    order of transformations applied when performing rounds. We also get
    key rounds in reverse order (relative to encryption). */for(var round=1;round<Nr;++round){/* As described above, we'll be using table lookups to perform the
      column mixing. Each column is stored as a word in the state (the
      array 'input' has one column as a word at each index). In order to
      mix a column, we perform these transformations on each row in c,
      which is 1 byte in each word. The new column for c0 is c'0:

               m0      m1      m2      m3
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0

      So using mix tables where c0 is a word with r0 being its upper
      8 bits and r3 being its lower 8 bits:

      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]
      ...
      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]

      Therefore to mix the columns in each word in the state we
      do the following (& 255 omitted for brevity):
      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]

      However, before mixing, the algorithm requires us to perform
      ShiftRows(). The ShiftRows() transformation cyclically shifts the
      last 3 rows of the state over different offsets. The first row
      (r = 0) is not shifted.

      s'_r,c = s_r,(c + shift(r, Nb) mod Nb
      for 0 < r < 4 and 0 <= c < Nb and
      shift(1, 4) = 1
      shift(2, 4) = 2
      shift(3, 4) = 3.

      This causes the first byte in r = 1 to be moved to the end of
      the row, the first 2 bytes in r = 2 to be moved to the end of
      the row, the first 3 bytes in r = 3 to be moved to the end of
      the row:

      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]

      We can make these substitutions inline with our column mixing to
      generate an updated set of equations to produce each word in the
      state (note the columns have changed positions):

      c0 c1 c2 c3 => c0 c1 c2 c3
      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)
      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)
      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)

      Therefore:

      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3
      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3

      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0
      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0

      ... and so forth for c'2 and c'3. The important distinction is
      that the columns are cycling, with c0 being used with the m0
      map when calculating c0, but c1 being used with the m0 map when
      calculating c1 ... and so forth.

      When performing the inverse we transform the mirror image and
      skip the bottom row, instead of the top one, and move upwards:

      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption
      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)
      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption
      c3 c2 c1 c0    c3 c2 c1 c0

      If you compare the resulting matrices for ShiftRows()+MixColumns()
      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are
      different (in encrypt mode vs. decrypt mode). So in order to use
      the same code to handle both encryption and decryption, we will
      need to do some mapping.

      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be
      a row number in the state, then the resulting matrix in encryption
      mode for applying the above transformations would be:

      r1: a b c d
      r2: b c d a
      r3: c d a b
      r4: d a b c

      If we did the same in decryption mode we would get:

      r1: a d c b
      r2: b a d c
      r3: c b a d
      r4: d c b a

      If instead we swap d and b (set b=c3 and d=c1), then we get:

      r1: a b c d
      r2: d a b c
      r3: c d a b
      r4: b c d a

      Now the 1st and 3rd rows are the same as the encryption matrix. All
      we need to do then to make the mapping exactly the same is to swap
      the 2nd and 4th rows when in decryption mode. To do this without
      having to do it on each iteration, we swapped the 2nd and 4th rows
      in the decryption key schedule. We also have to do the swap above
      when we first pull in the input and when we set the final output. */a2=m0[a>>>24]^m1[b>>>16&255]^m2[c>>>8&255]^m3[d&255]^w[++i];b2=m0[b>>>24]^m1[c>>>16&255]^m2[d>>>8&255]^m3[a&255]^w[++i];c2=m0[c>>>24]^m1[d>>>16&255]^m2[a>>>8&255]^m3[b&255]^w[++i];d=m0[d>>>24]^m1[a>>>16&255]^m2[b>>>8&255]^m3[c&255]^w[++i];a=a2;b=b2;c=c2;}/*
    Encrypt:
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])

    Decrypt:
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
   */ // Note: rows are shifted inline
output[0]=sub[a>>>24]<<24^sub[b>>>16&255]<<16^sub[c>>>8&255]<<8^sub[d&255]^w[++i];output[decrypt?3:1]=sub[b>>>24]<<24^sub[c>>>16&255]<<16^sub[d>>>8&255]<<8^sub[a&255]^w[++i];output[2]=sub[c>>>24]<<24^sub[d>>>16&255]<<16^sub[a>>>8&255]<<8^sub[b&255]^w[++i];output[decrypt?1:3]=sub[d>>>24]<<24^sub[a>>>16&255]<<16^sub[b>>>8&255]<<8^sub[c&255]^w[++i];}/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('AES-<mode>', key);
 * forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates a deprecated AES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key and iv may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param options the options to use.
 *          key the symmetric key to use.
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */function _createCipher(options){options=options||{};var mode=(options.mode||'CBC').toUpperCase();var algorithm='AES-'+mode;var cipher;if(options.decrypt){cipher=forge.cipher.createDecipher(algorithm,options.key);}else{cipher=forge.cipher.createCipher(algorithm,options.key);}// backwards compatible start API
var start=cipher.start;cipher.start=function(iv,options){// backwards compatibility: support second arg as output buffer
var output=null;if(options instanceof forge.util.ByteBuffer){output=options;options={};}options=options||{};options.output=output;options.iv=iv;start.call(cipher,options);};return cipher;}/***/},/* 8 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
 *
 * See: RFC 1421.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 *
 * A Forge PEM object has the following fields:
 *
 * type: identifies the type of message (eg: "RSA PRIVATE KEY").
 *
 * procType: identifies the type of processing performed on the message,
 *   it has two subfields: version and type, eg: 4,ENCRYPTED.
 *
 * contentDomain: identifies the type of content in the message, typically
 *   only uses the value: "RFC822".
 *
 * dekInfo: identifies the message encryption algorithm and mode and includes
 *   any parameters for the algorithm, it has two subfields: algorithm and
 *   parameters, eg: DES-CBC,F8143EDE5960C597.
 *
 * headers: contains all other PEM encapsulated headers -- where order is
 *   significant (for pairing data like recipient ID + key info).
 *
 * body: the binary-encoded body.
 */var forge=__webpack_require__(0);__webpack_require__(1);// shortcut for pem API
var pem=module.exports=forge.pem=forge.pem||{};/**
 * Encodes (serializes) the given PEM object.
 *
 * @param msg the PEM message object to encode.
 * @param options the options to use:
 *          maxline the maximum characters per line for the body, (default: 64).
 *
 * @return the PEM-formatted string.
 */pem.encode=function(msg,options){options=options||{};var rval='-----BEGIN '+msg.type+'-----\r\n';// encode special headers
var header;if(msg.procType){header={name:'Proc-Type',values:[String(msg.procType.version),msg.procType.type]};rval+=foldHeader(header);}if(msg.contentDomain){header={name:'Content-Domain',values:[msg.contentDomain]};rval+=foldHeader(header);}if(msg.dekInfo){header={name:'DEK-Info',values:[msg.dekInfo.algorithm]};if(msg.dekInfo.parameters){header.values.push(msg.dekInfo.parameters);}rval+=foldHeader(header);}if(msg.headers){// encode all other headers
for(var i=0;i<msg.headers.length;++i){rval+=foldHeader(msg.headers[i]);}}// terminate header
if(msg.procType){rval+='\r\n';}// add body
rval+=forge.util.encode64(msg.body,options.maxline||64)+'\r\n';rval+='-----END '+msg.type+'-----\r\n';return rval;};/**
 * Decodes (deserializes) all PEM messages found in the given string.
 *
 * @param str the PEM-formatted string to decode.
 *
 * @return the PEM message objects in an array.
 */pem.decode=function(str){var rval=[];// split string into PEM messages (be lenient w/EOF on BEGIN line)
var rMessage=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;var rHeader=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;var rCRLF=/\r?\n/;var match;while(true){match=rMessage.exec(str);if(!match){break;}var msg={type:match[1],procType:null,contentDomain:null,dekInfo:null,headers:[],body:forge.util.decode64(match[3])};rval.push(msg);// no headers
if(!match[2]){continue;}// parse headers
var lines=match[2].split(rCRLF);var li=0;while(match&&li<lines.length){// get line, trim any rhs whitespace
var line=lines[li].replace(/\s+$/,'');// RFC2822 unfold any following folded lines
for(var nl=li+1;nl<lines.length;++nl){var next=lines[nl];if(!/\s/.test(next[0])){break;}line+=next;li=nl;}// parse header
match=line.match(rHeader);if(match){var header={name:match[1],values:[]};var values=match[2].split(',');for(var vi=0;vi<values.length;++vi){header.values.push(ltrim(values[vi]));}// Proc-Type must be the first header
if(!msg.procType){if(header.name!=='Proc-Type'){throw new Error('Invalid PEM formatted message. The first '+'encapsulated header must be "Proc-Type".');}else if(header.values.length!==2){throw new Error('Invalid PEM formatted message. The "Proc-Type" '+'header must have two subfields.');}msg.procType={version:values[0],type:values[1]};}else if(!msg.contentDomain&&header.name==='Content-Domain'){// special-case Content-Domain
msg.contentDomain=values[0]||'';}else if(!msg.dekInfo&&header.name==='DEK-Info'){// special-case DEK-Info
if(header.values.length===0){throw new Error('Invalid PEM formatted message. The "DEK-Info" '+'header must have at least one subfield.');}msg.dekInfo={algorithm:values[0],parameters:values[1]||null};}else{msg.headers.push(header);}}++li;}if(msg.procType==='ENCRYPTED'&&!msg.dekInfo){throw new Error('Invalid PEM formatted message. The "DEK-Info" '+'header must be present if "Proc-Type" is "ENCRYPTED".');}}if(rval.length===0){throw new Error('Invalid PEM formatted message.');}return rval;};function foldHeader(header){var rval=header.name+': ';// ensure values with CRLF are folded
var values=[];var insertSpace=function insertSpace(match,$1){return' '+$1;};for(var i=0;i<header.values.length;++i){values.push(header.values[i].replace(/^(\S+\r\n)/,insertSpace));}rval+=values.join(',')+'\r\n';// do folding
var length=0;var candidate=-1;for(var i=0;i<rval.length;++i,++length){if(length>65&&candidate!==-1){var insert=rval[candidate];if(insert===','){++candidate;rval=rval.substr(0,candidate)+'\r\n '+rval.substr(candidate);}else{rval=rval.substr(0,candidate)+'\r\n'+insert+rval.substr(candidate+1);}length=i-candidate-1;candidate=-1;++i;}else if(rval[i]===' '||rval[i]==='\t'||rval[i]===','){candidate=i;}}return rval;}function ltrim(str){return str.replace(/^\s+/,'');}/***/},/* 9 */ /***/function(module,exports,__webpack_require__){/**
 * Password-based encryption functions.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * An EncryptedPrivateKeyInfo:
 *
 * EncryptedPrivateKeyInfo ::= SEQUENCE {
 *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
 *   encryptedData        EncryptedData }
 *
 * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedData ::= OCTET STRING
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(2);__webpack_require__(12);__webpack_require__(4);__webpack_require__(3);__webpack_require__(13);__webpack_require__(8);__webpack_require__(5);__webpack_require__(25);__webpack_require__(6);__webpack_require__(1);if(typeof BigInteger==='undefined'){var BigInteger=forge.jsbn.BigInteger;}// shortcut for asn.1 API
var asn1=forge.asn1;/* Password-based encryption implementation. */var pki=forge.pki=forge.pki||{};module.exports=pki.pbe=forge.pbe=forge.pbe||{};var oids=pki.oids;// validator for an EncryptedPrivateKeyInfo structure
// Note: Currently only works w/algorithm params
var encryptedPrivateKeyValidator={name:'EncryptedPrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedPrivateKeyInfo.encryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encryptionOid'},{name:'AlgorithmIdentifier.parameters',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'encryptionParams'}]},{// encryptedData
name:'EncryptedPrivateKeyInfo.encryptedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encryptedData'}]};// validator for a PBES2Algorithms structure
// Note: Currently only works w/PBKDF2 + AES encryption schemes
var PBES2AlgorithmsValidator={name:'PBES2Algorithms',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.keyDerivationFunc',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.keyDerivationFunc.oid',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'kdfOid'},{name:'PBES2Algorithms.params',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.params.salt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'kdfSalt'},{name:'PBES2Algorithms.params.iterationCount',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'kdfIterationCount'},{name:'PBES2Algorithms.params.keyLength',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,optional:true,capture:'keyLength'},{// prf
name:'PBES2Algorithms.params.prf',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,value:[{name:'PBES2Algorithms.params.prf.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'prfOid'}]}]}]},{name:'PBES2Algorithms.encryptionScheme',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.encryptionScheme.oid',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encOid'},{name:'PBES2Algorithms.encryptionScheme.iv',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encIv'}]}]};var pkcs12PbeParamsValidator={name:'pkcs-12PbeParams',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'pkcs-12PbeParams.salt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'salt'},{name:'pkcs-12PbeParams.iterations',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'iterations'}]};/**
 * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.
 *
 * PBES2Algorithms ALGORITHM-IDENTIFIER ::=
 *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}
 *
 * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}
 *
 * PBES2-params ::= SEQUENCE {
 *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
 *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
 * }
 *
 * PBES2-KDFs ALGORITHM-IDENTIFIER ::=
 *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }
 *
 * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }
 *
 * PBKDF2-params ::= SEQUENCE {
 *   salt CHOICE {
 *     specified OCTET STRING,
 *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
 *   },
 *   iterationCount INTEGER (1..MAX),
 *   keyLength INTEGER (1..MAX) OPTIONAL,
 *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
 * }
 *
 * @param obj the ASN.1 PrivateKeyInfo object.
 * @param password the password to encrypt with.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          prfAlgorithm the PRF message digest algorithm to use
 *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptPrivateKeyInfo=function(obj,password,options){// set default options
options=options||{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||'aes128';options.prfAlgorithm=options.prfAlgorithm||'sha1';// generate PBE params
var salt=forge.random.getBytesSync(options.saltSize);var count=options.count;var countBytes=asn1.integerToDer(count);var dkLen;var encryptionAlgorithm;var encryptedData;if(options.algorithm.indexOf('aes')===0||options.algorithm==='des'){// do PBES2
var ivLen,encOid,cipherFn;switch(options.algorithm){case'aes128':dkLen=16;ivLen=16;encOid=oids['aes128-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'aes192':dkLen=24;ivLen=16;encOid=oids['aes192-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'aes256':dkLen=32;ivLen=16;encOid=oids['aes256-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'des':dkLen=8;ivLen=8;encOid=oids['desCBC'];cipherFn=forge.des.createEncryptionCipher;break;default:var error=new Error('Cannot encrypt private key. Unknown encryption algorithm.');error.algorithm=options.algorithm;throw error;}// get PRF message digest
var prfAlgorithm='hmacWith'+options.prfAlgorithm.toUpperCase();var md=prfAlgorithmToMessageDigest(prfAlgorithm);// encrypt private key using pbe SHA-1 and AES/DES
var dk=forge.pkcs5.pbkdf2(password,salt,count,dkLen,md);var iv=forge.random.getBytesSync(ivLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(asn1.toDer(obj));cipher.finish();encryptedData=cipher.output.getBytes();// get PBKDF2-params
var params=createPbkdf2Params(salt,countBytes,dkLen,prfAlgorithm);encryptionAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// keyDerivationFunc
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),// PBKDF2-params
params]),// encryptionScheme
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(encOid).getBytes()),// iv
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,iv)])])]);}else if(options.algorithm==='3des'){// Do PKCS12 PBE
dkLen=24;var saltBytes=new forge.util.ByteBuffer(salt);var dk=pki.pbe.generatePkcs12Key(password,saltBytes,1,count,dkLen);var iv=pki.pbe.generatePkcs12Key(password,saltBytes,2,count,dkLen);var cipher=forge.des.createEncryptionCipher(dk);cipher.start(iv);cipher.update(asn1.toDer(obj));cipher.finish();encryptedData=cipher.output.getBytes();encryptionAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),// pkcs-12PbeParams
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// salt
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,salt),// iteration count
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,countBytes.getBytes())])]);}else{var error=new Error('Cannot encrypt private key. Unknown encryption algorithm.');error.algorithm=options.algorithm;throw error;}// EncryptedPrivateKeyInfo
var rval=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// encryptionAlgorithm
encryptionAlgorithm,// encryptedData
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,encryptedData)]);return rval;};/**
 * Decrypts a ASN.1 PrivateKeyInfo object.
 *
 * @param obj the ASN.1 EncryptedPrivateKeyInfo object.
 * @param password the password to decrypt with.
 *
 * @return the ASN.1 PrivateKeyInfo on success, null on failure.
 */pki.decryptPrivateKeyInfo=function(obj,password){var rval=null;// get PBE params
var capture={};var errors=[];if(!asn1.validate(obj,encryptedPrivateKeyValidator,capture,errors)){var error=new Error('Cannot read encrypted private key. '+'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}// get cipher
var oid=asn1.derToOid(capture.encryptionOid);var cipher=pki.pbe.getCipher(oid,capture.encryptionParams,password);// get encrypted data
var encrypted=forge.util.createBuffer(capture.encryptedData);cipher.update(encrypted);if(cipher.finish()){rval=asn1.fromDer(cipher.output);}return rval;};/**
 * Converts a EncryptedPrivateKeyInfo to PEM format.
 *
 * @param epki the EncryptedPrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted encrypted private key.
 */pki.encryptedPrivateKeyToPem=function(epki,maxline){// convert to DER, then PEM-encode
var msg={type:'ENCRYPTED PRIVATE KEY',body:asn1.toDer(epki).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
 * is not performed.
 *
 * @param pem the EncryptedPrivateKeyInfo in PEM-format.
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptedPrivateKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='ENCRYPTED PRIVATE KEY'){var error=new Error('Could not convert encrypted private key from PEM; '+'PEM header type is "ENCRYPTED PRIVATE KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert encrypted private key from PEM; '+'PEM is encrypted.');}// convert DER to ASN.1 object
return asn1.fromDer(msg.body);};/**
 * Encrypts an RSA private key. By default, the key will be wrapped in
 * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.
 * This is the standard, preferred way to encrypt a private key.
 *
 * To produce a non-standard PEM-encrypted private key that uses encapsulated
 * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL
 * private key encryption), set the 'legacy' option to true. Note: Using this
 * option will cause the iteration count to be forced to 1.
 *
 * Note: The 'des' algorithm is supported, but it is not considered to be
 * secure because it only uses a single 56-bit key. If possible, it is highly
 * recommended that a different algorithm be used.
 *
 * @param rsaKey the RSA key to encrypt.
 * @param password the password to use.
 * @param options:
 *          algorithm: the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des', 'des').
 *          count: the iteration count to use.
 *          saltSize: the salt size to use.
 *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated
 *            headers (DEK-Info) private key.
 *
 * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptRsaPrivateKey=function(rsaKey,password,options){// standard PKCS#8
options=options||{};if(!options.legacy){// encrypt PrivateKeyInfo
var rval=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));rval=pki.encryptPrivateKeyInfo(rval,password,options);return pki.encryptedPrivateKeyToPem(rval);}// legacy non-PKCS#8
var algorithm;var iv;var dkLen;var cipherFn;switch(options.algorithm){case'aes128':algorithm='AES-128-CBC';dkLen=16;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'aes192':algorithm='AES-192-CBC';dkLen=24;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'aes256':algorithm='AES-256-CBC';dkLen=32;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'3des':algorithm='DES-EDE3-CBC';dkLen=24;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;case'des':algorithm='DES-CBC';dkLen=8;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;default:var error=new Error('Could not encrypt RSA private key; unsupported '+'encryption algorithm "'+options.algorithm+'".');error.algorithm=options.algorithm;throw error;}// encrypt private key using OpenSSL legacy key derivation
var dk=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));cipher.finish();var msg={type:'RSA PRIVATE KEY',procType:{version:'4',type:'ENCRYPTED'},dekInfo:{algorithm:algorithm,parameters:forge.util.bytesToHex(iv).toUpperCase()},body:cipher.output.getBytes()};return forge.pem.encode(msg);};/**
 * Decrypts an RSA private key.
 *
 * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.
 * @param password the password to use.
 *
 * @return the RSA key on success, null on failure.
 */pki.decryptRsaPrivateKey=function(pem,password){var rval=null;var msg=forge.pem.decode(pem)[0];if(msg.type!=='ENCRYPTED PRIVATE KEY'&&msg.type!=='PRIVATE KEY'&&msg.type!=='RSA PRIVATE KEY'){var error=new Error('Could not convert private key from PEM; PEM header type '+'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');error.headerType=error;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){var dkLen;var cipherFn;switch(msg.dekInfo.algorithm){case'DES-CBC':dkLen=8;cipherFn=forge.des.createDecryptionCipher;break;case'DES-EDE3-CBC':dkLen=24;cipherFn=forge.des.createDecryptionCipher;break;case'AES-128-CBC':dkLen=16;cipherFn=forge.aes.createDecryptionCipher;break;case'AES-192-CBC':dkLen=24;cipherFn=forge.aes.createDecryptionCipher;break;case'AES-256-CBC':dkLen=32;cipherFn=forge.aes.createDecryptionCipher;break;case'RC2-40-CBC':dkLen=5;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,40);};break;case'RC2-64-CBC':dkLen=8;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,64);};break;case'RC2-128-CBC':dkLen=16;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,128);};break;default:var error=new Error('Could not decrypt private key; unsupported '+'encryption algorithm "'+msg.dekInfo.algorithm+'".');error.algorithm=msg.dekInfo.algorithm;throw error;}// use OpenSSL legacy key derivation
var iv=forge.util.hexToBytes(msg.dekInfo.parameters);var dk=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(forge.util.createBuffer(msg.body));if(cipher.finish()){rval=cipher.output.getBytes();}else{return rval;}}else{rval=msg.body;}if(msg.type==='ENCRYPTED PRIVATE KEY'){rval=pki.decryptPrivateKeyInfo(asn1.fromDer(rval),password);}else{// decryption already performed above
rval=asn1.fromDer(rval);}if(rval!==null){rval=pki.privateKeyFromAsn1(rval);}return rval;};/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */pki.pbe.generatePkcs12Key=function(password,salt,id,iter,n,md){var j,l;if(typeof md==='undefined'||md===null){if(!('sha1'in forge.md)){throw new Error('"sha1" hash algorithm unavailable.');}md=forge.md.sha1.create();}var u=md.digestLength;var v=md.blockLength;var result=new forge.util.ByteBuffer();/* Convert password to Unicode byte buffer + trailing 0-byte. */var passBuf=new forge.util.ByteBuffer();if(password!==null&&password!==undefined){for(l=0;l<password.length;l++){passBuf.putInt16(password.charCodeAt(l));}passBuf.putInt16(0);}/* Length of salt and password in BYTES. */var p=passBuf.length();var s=salt.length();/* 1. Construct a string, D (the "diversifier"), by concatenating
        v copies of ID. */var D=new forge.util.ByteBuffer();D.fillWithByte(id,v);/* 2. Concatenate copies of the salt together to create a string S of length
        v * ceil(s / v) bytes (the final copy of the salt may be trunacted
        to create S).
        Note that if the salt is the empty string, then so is S. */var Slen=v*Math.ceil(s/v);var S=new forge.util.ByteBuffer();for(l=0;l<Slen;l++){S.putByte(salt.at(l%s));}/* 3. Concatenate copies of the password together to create a string P of
        length v * ceil(p / v) bytes (the final copy of the password may be
        truncated to create P).
        Note that if the password is the empty string, then so is P. */var Plen=v*Math.ceil(p/v);var P=new forge.util.ByteBuffer();for(l=0;l<Plen;l++){P.putByte(passBuf.at(l%p));}/* 4. Set I=S||P to be the concatenation of S and P. */var I=S;I.putBuffer(P);/* 5. Set c=ceil(n / u). */var c=Math.ceil(n/u);/* 6. For i=1, 2, ..., c, do the following: */for(var i=1;i<=c;i++){/* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */var buf=new forge.util.ByteBuffer();buf.putBytes(D.bytes());buf.putBytes(I.bytes());for(var round=0;round<iter;round++){md.start();md.update(buf.getBytes());buf=md.digest();}/* b) Concatenate copies of Ai to create a string B of length v bytes (the
          final copy of Ai may be truncated to create B). */var B=new forge.util.ByteBuffer();for(l=0;l<v;l++){B.putByte(buf.at(l%u));}/* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,
          where k=ceil(s / v) + ceil(p / v), modify I by setting
          Ij=(Ij+B+1) mod 2v for each j.  */var k=Math.ceil(s/v)+Math.ceil(p/v);var Inew=new forge.util.ByteBuffer();for(j=0;j<k;j++){var chunk=new forge.util.ByteBuffer(I.getBytes(v));var x=0x1ff;for(l=B.length()-1;l>=0;l--){x=x>>8;x+=B.at(l)+chunk.at(l);chunk.setAt(l,x&0xff);}Inew.putBuffer(chunk);}I=Inew;/* Add Ai to A. */result.putBuffer(buf);}result.truncate(result.length()-n);return result;};/**
 * Get new Forge cipher object instance.
 *
 * @param oid the OID (in string notation).
 * @param params the ASN.1 params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */pki.pbe.getCipher=function(oid,params,password){switch(oid){case pki.oids['pkcs5PBES2']:return pki.pbe.getCipherForPBES2(oid,params,password);case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:case pki.oids['pbewithSHAAnd40BitRC2-CBC']:return pki.pbe.getCipherForPKCS12PBE(oid,params,password);default:var error=new Error('Cannot read encrypted PBE data block. Unsupported OID.');error.oid=oid;error.supportedOids=['pkcs5PBES2','pbeWithSHAAnd3-KeyTripleDES-CBC','pbewithSHAAnd40BitRC2-CBC'];throw error;}};/**
 * Get new Forge cipher object instance according to PBES2 params block.
 *
 * The returned cipher instance is already started using the IV
 * from PBES2 parameter block.
 *
 * @param oid the PKCS#5 PBKDF2 OID (in string notation).
 * @param params the ASN.1 PBES2-params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */pki.pbe.getCipherForPBES2=function(oid,params,password){// get PBE params
var capture={};var errors=[];if(!asn1.validate(params,PBES2AlgorithmsValidator,capture,errors)){var error=new Error('Cannot read password-based-encryption algorithm '+'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}// check oids
oid=asn1.derToOid(capture.kdfOid);if(oid!==pki.oids['pkcs5PBKDF2']){var error=new Error('Cannot read encrypted private key. '+'Unsupported key derivation function OID.');error.oid=oid;error.supportedOids=['pkcs5PBKDF2'];throw error;}oid=asn1.derToOid(capture.encOid);if(oid!==pki.oids['aes128-CBC']&&oid!==pki.oids['aes192-CBC']&&oid!==pki.oids['aes256-CBC']&&oid!==pki.oids['des-EDE3-CBC']&&oid!==pki.oids['desCBC']){var error=new Error('Cannot read encrypted private key. '+'Unsupported encryption scheme OID.');error.oid=oid;error.supportedOids=['aes128-CBC','aes192-CBC','aes256-CBC','des-EDE3-CBC','desCBC'];throw error;}// set PBE params
var salt=capture.kdfSalt;var count=forge.util.createBuffer(capture.kdfIterationCount);count=count.getInt(count.length()<<3);var dkLen;var cipherFn;switch(pki.oids[oid]){case'aes128-CBC':dkLen=16;cipherFn=forge.aes.createDecryptionCipher;break;case'aes192-CBC':dkLen=24;cipherFn=forge.aes.createDecryptionCipher;break;case'aes256-CBC':dkLen=32;cipherFn=forge.aes.createDecryptionCipher;break;case'des-EDE3-CBC':dkLen=24;cipherFn=forge.des.createDecryptionCipher;break;case'desCBC':dkLen=8;cipherFn=forge.des.createDecryptionCipher;break;}// get PRF message digest
var md=prfOidToMessageDigest(capture.prfOid);// decrypt private key using pbe with chosen PRF and AES/DES
var dk=forge.pkcs5.pbkdf2(password,salt,count,dkLen,md);var iv=capture.encIv;var cipher=cipherFn(dk);cipher.start(iv);return cipher;};/**
 * Get new Forge cipher object instance for PKCS#12 PBE.
 *
 * The returned cipher instance is already started using the key & IV
 * derived from the provided password and PKCS#12 PBE salt.
 *
 * @param oid The PKCS#12 PBE OID (in string notation).
 * @param params The ASN.1 PKCS#12 PBE-params object.
 * @param password The password to decrypt with.
 *
 * @return the new cipher object instance.
 */pki.pbe.getCipherForPKCS12PBE=function(oid,params,password){// get PBE params
var capture={};var errors=[];if(!asn1.validate(params,pkcs12PbeParamsValidator,capture,errors)){var error=new Error('Cannot read password-based-encryption algorithm '+'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}var salt=forge.util.createBuffer(capture.salt);var count=forge.util.createBuffer(capture.iterations);count=count.getInt(count.length()<<3);var dkLen,dIvLen,cipherFn;switch(oid){case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:dkLen=24;dIvLen=8;cipherFn=forge.des.startDecrypting;break;case pki.oids['pbewithSHAAnd40BitRC2-CBC']:dkLen=5;dIvLen=8;cipherFn=function cipherFn(key,iv){var cipher=forge.rc2.createDecryptionCipher(key,40);cipher.start(iv,null);return cipher;};break;default:var error=new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');error.oid=oid;throw error;}// get PRF message digest
var md=prfOidToMessageDigest(capture.prfOid);var key=pki.pbe.generatePkcs12Key(password,salt,1,count,dkLen,md);md.start();var iv=pki.pbe.generatePkcs12Key(password,salt,2,count,dIvLen,md);return cipherFn(key,iv);};/**
 * OpenSSL's legacy key derivation function.
 *
 * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
 *
 * @param password the password to derive the key from.
 * @param salt the salt to use, null for none.
 * @param dkLen the number of bytes needed for the derived key.
 * @param [options] the options to use:
 *          [md] an optional message digest object to use.
 */pki.pbe.opensslDeriveBytes=function(password,salt,dkLen,md){if(typeof md==='undefined'||md===null){if(!('md5'in forge.md)){throw new Error('"md5" hash algorithm unavailable.');}md=forge.md.md5.create();}if(salt===null){salt='';}var digests=[hash(md,password+salt)];for(var length=16,i=1;length<dkLen;++i,length+=16){digests.push(hash(md,digests[i-1]+password+salt));}return digests.join('').substr(0,dkLen);};function hash(md,bytes){return md.start().update(bytes).digest().getBytes();}function prfOidToMessageDigest(prfOid){// get PRF algorithm, default to SHA-1
var prfAlgorithm;if(!prfOid){prfAlgorithm='hmacWithSHA1';}else{prfAlgorithm=pki.oids[asn1.derToOid(prfOid)];if(!prfAlgorithm){var error=new Error('Unsupported PRF OID.');error.oid=prfOid;error.supported=['hmacWithSHA1','hmacWithSHA224','hmacWithSHA256','hmacWithSHA384','hmacWithSHA512'];throw error;}}return prfAlgorithmToMessageDigest(prfAlgorithm);}function prfAlgorithmToMessageDigest(prfAlgorithm){var factory=forge.md;switch(prfAlgorithm){case'hmacWithSHA224':factory=forge.md.sha512;case'hmacWithSHA1':case'hmacWithSHA256':case'hmacWithSHA384':case'hmacWithSHA512':prfAlgorithm=prfAlgorithm.substr(8).toLowerCase();break;default:var error=new Error('Unsupported PRF algorithm.');error.algorithm=prfAlgorithm;error.supported=['hmacWithSHA1','hmacWithSHA224','hmacWithSHA256','hmacWithSHA384','hmacWithSHA512'];throw error;}if(!factory||!(prfAlgorithm in factory)){throw new Error('Unknown hash algorithm: '+prfAlgorithm);}return factory[prfAlgorithm].create();}function createPbkdf2Params(salt,countBytes,dkLen,prfAlgorithm){var params=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// salt
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,salt),// iteration count
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,countBytes.getBytes())]);// when PRF algorithm is not SHA-1 default, add key length and PRF algorithm
if(prfAlgorithm!=='hmacWithSHA1'){params.value.push(// key length
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,forge.util.hexToBytes(dkLen.toString(16))),// AlgorithmIdentifier
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),// parameters (null)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]));}return params;}/***/},/* 10 */ /***/function(module,exports,__webpack_require__){/**
 * Cipher base API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);module.exports=forge.cipher=forge.cipher||{};// registered algorithms
forge.cipher.algorithms=forge.cipher.algorithms||{};/**
 * Creates a cipher object that can be used to encrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */forge.cipher.createCipher=function(algorithm,key){var api=algorithm;if(typeof api==='string'){api=forge.cipher.getAlgorithm(api);if(api){api=api();}}if(!api){throw new Error('Unsupported algorithm: '+algorithm);}// assume block cipher
return new forge.cipher.BlockCipher({algorithm:api,key:key,decrypt:false});};/**
 * Creates a decipher object that can be used to decrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */forge.cipher.createDecipher=function(algorithm,key){var api=algorithm;if(typeof api==='string'){api=forge.cipher.getAlgorithm(api);if(api){api=api();}}if(!api){throw new Error('Unsupported algorithm: '+algorithm);}// assume block cipher
return new forge.cipher.BlockCipher({algorithm:api,key:key,decrypt:true});};/**
 * Registers an algorithm by name. If the name was already registered, the
 * algorithm API object will be overwritten.
 *
 * @param name the name of the algorithm.
 * @param algorithm the algorithm API object.
 */forge.cipher.registerAlgorithm=function(name,algorithm){name=name.toUpperCase();forge.cipher.algorithms[name]=algorithm;};/**
 * Gets a registered algorithm by name.
 *
 * @param name the name of the algorithm.
 *
 * @return the algorithm, if found, null if not.
 */forge.cipher.getAlgorithm=function(name){name=name.toUpperCase();if(name in forge.cipher.algorithms){return forge.cipher.algorithms[name];}return null;};var BlockCipher=forge.cipher.BlockCipher=function(options){this.algorithm=options.algorithm;this.mode=this.algorithm.mode;this.blockSize=this.mode.blockSize;this._finish=false;this._input=null;this.output=null;this._op=options.decrypt?this.mode.decrypt:this.mode.encrypt;this._decrypt=options.decrypt;this.algorithm.initialize(options);};/**
 * Starts or restarts the encryption or decryption process, whichever
 * was previously configured.
 *
 * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
 * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in
 * bytes, then it must be Nb (16) bytes in length. If the IV is given in as
 * 32-bit integers, then it must be 4 integers long.
 *
 * Note: an IV is not required or used in ECB mode.
 *
 * For GCM-mode, the IV must be given as a binary-encoded string of bytes or
 * a byte buffer. The number of bytes should be 12 (96 bits) as recommended
 * by NIST SP-800-38D but another length may be given.
 *
 * @param options the options to use:
 *          iv the initialization vector to use as a binary-encoded string of
 *            bytes, null to reuse the last ciphered block from a previous
 *            update() (this "residue" method is for legacy support only).
 *          additionalData additional authentication data as a binary-encoded
 *            string of bytes, for 'GCM' mode, (default: none).
 *          tagLength desired length of authentication tag, in bits, for
 *            'GCM' mode (0-128, default: 128).
 *          tag the authentication tag to check if decrypting, as a
 *             binary-encoded string of bytes.
 *          output the output the buffer to write to, null to create one.
 */BlockCipher.prototype.start=function(options){options=options||{};var opts={};for(var key in options){opts[key]=options[key];}opts.decrypt=this._decrypt;this._finish=false;this._input=forge.util.createBuffer();this.output=options.output||forge.util.createBuffer();this.mode.start(opts);};/**
 * Updates the next block according to the cipher mode.
 *
 * @param input the buffer to read from.
 */BlockCipher.prototype.update=function(input){if(input){// input given, so empty it into the input buffer
this._input.putBuffer(input);}// do cipher operation until it needs more input and not finished
while(!this._op.call(this.mode,this._input,this.output,this._finish)&&!this._finish){}// free consumed memory from input buffer
this._input.compact();};/**
 * Finishes encrypting or decrypting.
 *
 * @param pad a padding function to use in CBC mode, null for default,
 *          signature(blockSize, buffer, decrypt).
 *
 * @return true if successful, false on error.
 */BlockCipher.prototype.finish=function(pad){// backwards-compatibility w/deprecated padding API
// Note: will overwrite padding functions even after another start() call
if(pad&&(this.mode.name==='ECB'||this.mode.name==='CBC')){this.mode.pad=function(input){return pad(this.blockSize,input,false);};this.mode.unpad=function(output){return pad(this.blockSize,output,true);};}// build options for padding and afterFinish functions
var options={};options.decrypt=this._decrypt;// get # of bytes that won't fill a block
options.overflow=this._input.length()%this.blockSize;if(!this._decrypt&&this.mode.pad){if(!this.mode.pad(this._input,options)){return false;}}// do final update
this._finish=true;this.update();if(this._decrypt&&this.mode.unpad){if(!this.mode.unpad(this.output,options)){return false;}}if(this.mode.afterFinish){if(!this.mode.afterFinish(this.output,options)){return false;}}return true;};/***/},/* 11 */ /***/function(module,exports,__webpack_require__){/**
 * Supported cipher modes.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);forge.cipher=forge.cipher||{};// supported cipher modes
var modes=module.exports=forge.cipher.modes=forge.cipher.modes||{};/** Electronic codebook (ECB) (Don't use this; it's not secure) **/modes.ecb=function(options){options=options||{};this.name='ECB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);};modes.ecb.prototype.start=function(options){};modes.ecb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// write output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}};modes.ecb.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// decrypt block
this.cipher.decrypt(this._inBlock,this._outBlock);// write output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}};modes.ecb.prototype.pad=function(input,options){// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=input.length()===this.blockSize?this.blockSize:this.blockSize-input.length();input.fillWithByte(padding,padding);return true;};modes.ecb.prototype.unpad=function(output,options){// check for error: input data not a multiple of blockSize
if(options.overflow>0){return false;}// ensure padding byte count is valid
var len=output.length();var count=output.at(len-1);if(count>this.blockSize<<2){return false;}// trim off padding bytes
output.truncate(count);return true;};/** Cipher-block Chaining (CBC) **/modes.cbc=function(options){options=options||{};this.name='CBC';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);};modes.cbc.prototype.start=function(options){// Note: legacy support for using IV residue (has security flaws)
// if IV is null, reuse block from previous processing
if(options.iv===null){// must have a previous block
if(!this._prev){throw new Error('Invalid IV parameter.');}this._iv=this._prev.slice(0);}else if(!('iv'in options)){throw new Error('Invalid IV parameter.');}else{// save IV as "previous" block
this._iv=transformIV(options.iv);this._prev=this._iv.slice(0);}};modes.cbc.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
// CBC XOR's IV (or previous block) with plaintext
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._prev[i]^input.getInt32();}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// write output, save previous block
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}this._prev=this._outBlock;};modes.cbc.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// decrypt block
this.cipher.decrypt(this._inBlock,this._outBlock);// write output, save previous ciphered block
// CBC XOR's IV (or previous block) with ciphertext
for(var i=0;i<this._ints;++i){output.putInt32(this._prev[i]^this._outBlock[i]);}this._prev=this._inBlock.slice(0);};modes.cbc.prototype.pad=function(input,options){// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=input.length()===this.blockSize?this.blockSize:this.blockSize-input.length();input.fillWithByte(padding,padding);return true;};modes.cbc.prototype.unpad=function(output,options){// check for error: input data not a multiple of blockSize
if(options.overflow>0){return false;}// ensure padding byte count is valid
var len=output.length();var count=output.at(len-1);if(count>this.blockSize<<2){return false;}// trim off padding bytes
output.truncate(count);return true;};/** Cipher feedback (CFB) **/modes.cfb=function(options){options=options||{};this.name='CFB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.cfb.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.cfb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output, write input as output
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32()^this._outBlock[i];output.putInt32(this._inBlock[i]);}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output, write input as partial output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialBlock[i]=input.getInt32()^this._outBlock[i];this._partialOutput.putInt32(this._partialBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._partialBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};modes.cfb.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block (CFB always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output, write input as output
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();output.putInt32(this._inBlock[i]^this._outBlock[i]);}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output, write input as partial output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialBlock[i]=input.getInt32();this._partialOutput.putInt32(this._partialBlock[i]^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._partialBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};/** Output feedback (OFB) **/modes.ofb=function(options){options=options||{};this.name='OFB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.ofb.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.ofb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(input.length()===0){return true;}// encrypt block (OFB always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output and update next input
for(var i=0;i<this._ints;++i){output.putInt32(input.getInt32()^this._outBlock[i]);this._inBlock[i]=this._outBlock[i];}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._outBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};modes.ofb.prototype.decrypt=modes.ofb.prototype.encrypt;/** Counter (CTR) **/modes.ctr=function(options){options=options||{};this.name='CTR';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.ctr.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.ctr.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block (CTR always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output
for(var i=0;i<this._ints;++i){output.putInt32(input.getInt32()^this._outBlock[i]);}}else{// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;}// block complete, increment counter (input block)
inc32(this._inBlock);};modes.ctr.prototype.decrypt=modes.ctr.prototype.encrypt;/** Galois/Counter Mode (GCM) **/modes.gcm=function(options){options=options||{};this.name='GCM';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;// R is actually this value concatenated with 120 more zero bits, but
// we only XOR against R so the other zeros have no effect -- we just
// apply this value to the first integer in a block
this._R=0xE1000000;};modes.gcm.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// ensure IV is a byte buffer
var iv=forge.util.createBuffer(options.iv);// no ciphered data processed yet
this._cipherLength=0;// default additional data is none
var additionalData;if('additionalData'in options){additionalData=forge.util.createBuffer(options.additionalData);}else{additionalData=forge.util.createBuffer();}// default tag length is 128 bits
if('tagLength'in options){this._tagLength=options.tagLength;}else{this._tagLength=128;}// if tag is given, ensure tag matches tag length
this._tag=null;if(options.decrypt){// save tag to check later
this._tag=forge.util.createBuffer(options.tag).getBytes();if(this._tag.length!==this._tagLength/8){throw new Error('Authentication tag does not match tag length.');}}// create tmp storage for hash calculation
this._hashBlock=new Array(this._ints);// no tag generated yet
this.tag=null;// generate hash subkey
// (apply block cipher to "zero" block)
this._hashSubkey=new Array(this._ints);this.cipher.encrypt([0,0,0,0],this._hashSubkey);// generate table M
// use 4-bit tables (32 component decomposition of a 16 byte value)
// 8-bit tables take more space and are known to have security
// vulnerabilities (in native implementations)
this.componentBits=4;this._m=this.generateHashTable(this._hashSubkey,this.componentBits);// Note: support IV length different from 96 bits? (only supporting
// 96 bits is recommended by NIST SP-800-38D)
// generate J_0
var ivLength=iv.length();if(ivLength===12){// 96-bit IV
this._j0=[iv.getInt32(),iv.getInt32(),iv.getInt32(),1];}else{// IV is NOT 96-bits
this._j0=[0,0,0,0];while(iv.length()>0){this._j0=this.ghash(this._hashSubkey,this._j0,[iv.getInt32(),iv.getInt32(),iv.getInt32(),iv.getInt32()]);}this._j0=this.ghash(this._hashSubkey,this._j0,[0,0].concat(from64To32(ivLength*8)));}// generate ICB (initial counter block)
this._inBlock=this._j0.slice(0);inc32(this._inBlock);this._partialBytes=0;// consume authentication data
additionalData=forge.util.createBuffer(additionalData);// save additional data length as a BE 64-bit number
this._aDataLength=from64To32(additionalData.length()*8);// pad additional data to 128 bit (16 byte) block size
var overflow=additionalData.length()%this.blockSize;if(overflow){additionalData.fillWithByte(0,this.blockSize-overflow);}this._s=[0,0,0,0];while(additionalData.length()>0){this._s=this.ghash(this._hashSubkey,this._s,[additionalData.getInt32(),additionalData.getInt32(),additionalData.getInt32(),additionalData.getInt32()]);}};modes.gcm.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]^=input.getInt32());}this._cipherLength+=this.blockSize;}else{// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes===0||finish){// handle overflow prior to hashing
if(finish){// get block overflow
var overflow=inputLength%this.blockSize;this._cipherLength+=overflow;// truncate for hash function
this._partialOutput.truncate(this.blockSize-overflow);}else{this._cipherLength+=this.blockSize;}// get output block for hashing
for(var i=0;i<this._ints;++i){this._outBlock[i]=this._partialOutput.getInt32();}this._partialOutput.read-=this.blockSize;}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){// block still incomplete, restore input buffer, get partial output,
// and return early
input.read-=this.blockSize;output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;}// update hash block S
this._s=this.ghash(this._hashSubkey,this._s,this._outBlock);// increment counter (input block)
inc32(this._inBlock);};modes.gcm.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
var inputLength=input.length();if(inputLength<this.blockSize&&!(finish&&inputLength>0)){return true;}// encrypt block (GCM always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// increment counter (input block)
inc32(this._inBlock);// update hash block S
this._hashBlock[0]=input.getInt32();this._hashBlock[1]=input.getInt32();this._hashBlock[2]=input.getInt32();this._hashBlock[3]=input.getInt32();this._s=this.ghash(this._hashSubkey,this._s,this._hashBlock);// XOR hash input with output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]^this._hashBlock[i]);}// increment cipher data length
if(inputLength<this.blockSize){this._cipherLength+=inputLength%this.blockSize;}else{this._cipherLength+=this.blockSize;}};modes.gcm.prototype.afterFinish=function(output,options){var rval=true;// handle overflow
if(options.decrypt&&options.overflow){output.truncate(this.blockSize-options.overflow);}// handle authentication tag
this.tag=forge.util.createBuffer();// concatenate additional data length with cipher length
var lengths=this._aDataLength.concat(from64To32(this._cipherLength*8));// include lengths in hash
this._s=this.ghash(this._hashSubkey,this._s,lengths);// do GCTR(J_0, S)
var tag=[];this.cipher.encrypt(this._j0,tag);for(var i=0;i<this._ints;++i){this.tag.putInt32(this._s[i]^tag[i]);}// trim tag to length
this.tag.truncate(this.tag.length()%(this._tagLength/8));// check authentication tag
if(options.decrypt&&this.tag.bytes()!==this._tag){rval=false;}return rval;};/**
 * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois
 * field multiplication. The field, GF(2^128), is defined by the polynomial:
 *
 * x^128 + x^7 + x^2 + x + 1
 *
 * Which is represented in little-endian binary form as: 11100001 (0xe1). When
 * the value of a coefficient is 1, a bit is set. The value R, is the
 * concatenation of this value and 120 zero bits, yielding a 128-bit value
 * which matches the block size.
 *
 * This function will multiply two elements (vectors of bytes), X and Y, in
 * the field GF(2^128). The result is initialized to zero. For each bit of
 * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)
 * by the current value of Y. For each bit, the value of Y will be raised by
 * a power of x (multiplied by the polynomial x). This can be achieved by
 * shifting Y once to the right. If the current value of Y, prior to being
 * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.
 * Otherwise, we must divide by R after shifting to find the remainder.
 *
 * @param x the first block to multiply by the second.
 * @param y the second block to multiply by the first.
 *
 * @return the block result of the multiplication.
 */modes.gcm.prototype.multiply=function(x,y){var z_i=[0,0,0,0];var v_i=y.slice(0);// calculate Z_128 (block has 128 bits)
for(var i=0;i<128;++i){// if x_i is 0, Z_{i+1} = Z_i (unchanged)
// else Z_{i+1} = Z_i ^ V_i
// get x_i by finding 32-bit int position, then left shift 1 by remainder
var x_i=x[i/32|0]&1<<31-i%32;if(x_i){z_i[0]^=v_i[0];z_i[1]^=v_i[1];z_i[2]^=v_i[2];z_i[3]^=v_i[3];}// if LSB(V_i) is 1, V_i = V_i >> 1
// else V_i = (V_i >> 1) ^ R
this.pow(v_i,v_i);}return z_i;};modes.gcm.prototype.pow=function(x,out){// if LSB(x) is 1, x = x >>> 1
// else x = (x >>> 1) ^ R
var lsb=x[3]&1;// always do x >>> 1:
// starting with the rightmost integer, shift each integer to the right
// one bit, pulling in the bit from the integer to the left as its top
// most bit (do this for the last 3 integers)
for(var i=3;i>0;--i){out[i]=x[i]>>>1|(x[i-1]&1)<<31;}// shift the first integer normally
out[0]=x[0]>>>1;// if lsb was not set, then polynomial had a degree of 127 and doesn't
// need to divided; otherwise, XOR with R to find the remainder; we only
// need to XOR the first integer since R technically ends w/120 zero bits
if(lsb){out[0]^=this._R;}};modes.gcm.prototype.tableMultiply=function(x){// assumes 4-bit tables are used
var z=[0,0,0,0];for(var i=0;i<32;++i){var idx=i/8|0;var x_i=x[idx]>>>(7-i%8)*4&0xF;var ah=this._m[i][x_i];z[0]^=ah[0];z[1]^=ah[1];z[2]^=ah[2];z[3]^=ah[3];}return z;};/**
 * A continuing version of the GHASH algorithm that operates on a single
 * block. The hash block, last hash value (Ym) and the new block to hash
 * are given.
 *
 * @param h the hash block.
 * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.
 * @param x the block to hash.
 *
 * @return the hashed value (Ym).
 */modes.gcm.prototype.ghash=function(h,y,x){y[0]^=x[0];y[1]^=x[1];y[2]^=x[2];y[3]^=x[3];return this.tableMultiply(y);//return this.multiply(y, h);
};/**
 * Precomputes a table for multiplying against the hash subkey. This
 * mechanism provides a substantial speed increase over multiplication
 * performed without a table. The table-based multiplication this table is
 * for solves X * H by multiplying each component of X by H and then
 * composing the results together using XOR.
 *
 * This function can be used to generate tables with different bit sizes
 * for the components, however, this implementation assumes there are
 * 32 components of X (which is a 16 byte vector), therefore each component
 * takes 4-bits (so the table is constructed with bits=4).
 *
 * @param h the hash subkey.
 * @param bits the bit size for a component.
 */modes.gcm.prototype.generateHashTable=function(h,bits){// TODO: There are further optimizations that would use only the
// first table M_0 (or some variant) along with a remainder table;
// this can be explored in the future
var multiplier=8/bits;var perInt=4*multiplier;var size=16*multiplier;var m=new Array(size);for(var i=0;i<size;++i){var tmp=[0,0,0,0];var idx=i/perInt|0;var shft=(perInt-1-i%perInt)*bits;tmp[idx]=1<<bits-1<<shft;m[i]=this.generateSubHashTable(this.multiply(tmp,h),bits);}return m;};/**
 * Generates a table for multiplying against the hash subkey for one
 * particular component (out of all possible component values).
 *
 * @param mid the pre-multiplied value for the middle key of the table.
 * @param bits the bit size for a component.
 */modes.gcm.prototype.generateSubHashTable=function(mid,bits){// compute the table quickly by minimizing the number of
// POW operations -- they only need to be performed for powers of 2,
// all other entries can be composed from those powers using XOR
var size=1<<bits;var half=size>>>1;var m=new Array(size);m[half]=mid.slice(0);var i=half>>>1;while(i>0){// raise m0[2 * i] and store in m0[i]
this.pow(m[2*i],m[i]=[]);i>>=1;}i=2;while(i<half){for(var j=1;j<i;++j){var m_i=m[i];var m_j=m[j];m[i+j]=[m_i[0]^m_j[0],m_i[1]^m_j[1],m_i[2]^m_j[2],m_i[3]^m_j[3]];}i*=2;}m[0]=[0,0,0,0];/* Note: We could avoid storing these by doing composition during multiply
  calculate top half using composition by speed is preferred. */for(i=half+1;i<size;++i){var c=m[i^half];m[i]=[mid[0]^c[0],mid[1]^c[1],mid[2]^c[2],mid[3]^c[3]];}return m;};/** Utility functions */function transformIV(iv){if(typeof iv==='string'){// convert iv string into byte buffer
iv=forge.util.createBuffer(iv);}if(forge.util.isArray(iv)&&iv.length>4){// convert iv byte array into byte buffer
var tmp=iv;iv=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){iv.putByte(tmp[i]);}}if(!forge.util.isArray(iv)){// convert iv byte buffer into 32-bit integer array
iv=[iv.getInt32(),iv.getInt32(),iv.getInt32(),iv.getInt32()];}return iv;}function inc32(block){// increment last 32 bits of block only
block[block.length-1]=block[block.length-1]+1&0xFFFFFFFF;}function from64To32(num){// convert 64-bit number to two BE Int32s
return[num/0x100000000|0,num&0xFFFFFFFF];}/***/},/* 12 */ /***/function(module,exports,__webpack_require__){/**
 * DES (Data Encryption Standard) implementation.
 *
 * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.
 * It is based on the BSD-licensed implementation by Paul Tero:
 *
 * Paul Tero, July 2001
 * http://www.tero.co.uk/des/
 *
 * Optimised for performance with large blocks by Michael Hayworth, November 2001
 * http://www.netdealing.com
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2012-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(10);__webpack_require__(11);__webpack_require__(1);/* DES API */module.exports=forge.des=forge.des||{};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */forge.des.startEncrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:false,mode:mode||(iv===null?'ECB':'CBC')});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.des.createEncryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:false,mode:mode});};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */forge.des.startDecrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:true,mode:mode||(iv===null?'ECB':'CBC')});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.des.createDecryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:true,mode:mode});};/**
 * Creates a new DES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the DES algorithm object.
 */forge.des.Algorithm=function(name,mode){var self=this;self.name=name;self.mode=new mode({blockSize:8,cipher:{encrypt:function encrypt(inBlock,outBlock){return _updateBlock(self._keys,inBlock,outBlock,false);},decrypt:function decrypt(inBlock,outBlock){return _updateBlock(self._keys,inBlock,outBlock,true);}}});self._init=false;};/**
 * Initializes this DES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */forge.des.Algorithm.prototype.initialize=function(options){if(this._init){return;}var key=forge.util.createBuffer(options.key);if(this.name.indexOf('3DES')===0){if(key.length()!==24){throw new Error('Invalid Triple-DES key size: '+key.length()*8);}}// do key expansion to 16 or 48 subkeys (single or triple DES)
this._keys=_createKeys(key);this._init=true;};/** Register DES algorithms **/registerAlgorithm('DES-ECB',forge.cipher.modes.ecb);registerAlgorithm('DES-CBC',forge.cipher.modes.cbc);registerAlgorithm('DES-CFB',forge.cipher.modes.cfb);registerAlgorithm('DES-OFB',forge.cipher.modes.ofb);registerAlgorithm('DES-CTR',forge.cipher.modes.ctr);registerAlgorithm('3DES-ECB',forge.cipher.modes.ecb);registerAlgorithm('3DES-CBC',forge.cipher.modes.cbc);registerAlgorithm('3DES-CFB',forge.cipher.modes.cfb);registerAlgorithm('3DES-OFB',forge.cipher.modes.ofb);registerAlgorithm('3DES-CTR',forge.cipher.modes.ctr);function registerAlgorithm(name,mode){var factory=function factory(){return new forge.des.Algorithm(name,mode);};forge.cipher.registerAlgorithm(name,factory);}/** DES implementation **/var spfunction1=[0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004];var spfunction2=[-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000];var spfunction3=[0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200];var spfunction4=[0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080];var spfunction5=[0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100];var spfunction6=[0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010];var spfunction7=[0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002];var spfunction8=[0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000];/**
 * Create necessary sub keys.
 *
 * @param key the 64-bit or 192-bit key.
 *
 * @return the expanded keys.
 */function _createKeys(key){var pc2bytes0=[0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204],pc2bytes1=[0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101],pc2bytes2=[0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808],pc2bytes3=[0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000],pc2bytes4=[0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010],pc2bytes5=[0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420],pc2bytes6=[0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002],pc2bytes7=[0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800],pc2bytes8=[0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002],pc2bytes9=[0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408],pc2bytes10=[0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020],pc2bytes11=[0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200],pc2bytes12=[0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010],pc2bytes13=[0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105];// how many iterations (1 for des, 3 for triple des)
// changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys
var iterations=key.length()>8?3:1;// stores the return keys
var keys=[];// now define the left shifts which need to be done
var shifts=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0];var n=0,tmp;for(var j=0;j<iterations;j++){var left=key.getInt32();var right=key.getInt32();tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;tmp=(right>>>-16^left)&0x0000ffff;left^=tmp;right^=tmp<<-16;tmp=(left>>>2^right)&0x33333333;right^=tmp;left^=tmp<<2;tmp=(right>>>-16^left)&0x0000ffff;left^=tmp;right^=tmp<<-16;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;// right needs to be shifted and OR'd with last four bits of left
tmp=left<<8|right>>>20&0x000000f0;// left needs to be put upside down
left=right<<24|right<<8&0xff0000|right>>>8&0xff00|right>>>24&0xf0;right=tmp;// now go through and perform these shifts on the left and right keys
for(var i=0;i<shifts.length;++i){//shift the keys either one or two bits to the left
if(shifts[i]){left=left<<2|left>>>26;right=right<<2|right>>>26;}else{left=left<<1|left>>>27;right=right<<1|right>>>27;}left&=-0xf;right&=-0xf;// now apply PC-2, in such a way that E is easier when encrypting or
// decrypting this conversion will look like PC-2 except only the last 6
// bits of each byte are used rather than 48 consecutive bits and the
// order of lines will be according to how the S selection functions will
// be applied: S2, S4, S6, S8, S1, S3, S5, S7
var lefttmp=pc2bytes0[left>>>28]|pc2bytes1[left>>>24&0xf]|pc2bytes2[left>>>20&0xf]|pc2bytes3[left>>>16&0xf]|pc2bytes4[left>>>12&0xf]|pc2bytes5[left>>>8&0xf]|pc2bytes6[left>>>4&0xf];var righttmp=pc2bytes7[right>>>28]|pc2bytes8[right>>>24&0xf]|pc2bytes9[right>>>20&0xf]|pc2bytes10[right>>>16&0xf]|pc2bytes11[right>>>12&0xf]|pc2bytes12[right>>>8&0xf]|pc2bytes13[right>>>4&0xf];tmp=(righttmp>>>16^lefttmp)&0x0000ffff;keys[n++]=lefttmp^tmp;keys[n++]=righttmp^tmp<<16;}}return keys;}/**
 * Updates a single block (1 byte) using DES. The update will either
 * encrypt or decrypt the block.
 *
 * @param keys the expanded keys.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */function _updateBlock(keys,input,output,decrypt){// set up loops for single or triple DES
var iterations=keys.length===32?3:9;var looping;if(iterations===3){looping=decrypt?[30,-2,-2]:[0,32,2];}else{looping=decrypt?[94,62,-2,32,64,2,30,-2,-2]:[0,32,2,62,30,-2,64,96,2];}var tmp;var left=input[0];var right=input[1];// first each 64 bit chunk of the message must be permuted according to IP
tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;tmp=(left>>>16^right)&0x0000ffff;right^=tmp;left^=tmp<<16;tmp=(right>>>2^left)&0x33333333;left^=tmp;right^=tmp<<2;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;// rotate left 1 bit
left=left<<1|left>>>31;right=right<<1|right>>>31;for(var j=0;j<iterations;j+=3){var endloop=looping[j+1];var loopinc=looping[j+2];// now go through and perform the encryption or decryption
for(var i=looping[j];i!=endloop;i+=loopinc){var right1=right^keys[i];var right2=(right>>>4|right<<28)^keys[i+1];// passing these bytes through the S selection functions
tmp=left;left=right;right=tmp^(spfunction2[right1>>>24&0x3f]|spfunction4[right1>>>16&0x3f]|spfunction6[right1>>>8&0x3f]|spfunction8[right1&0x3f]|spfunction1[right2>>>24&0x3f]|spfunction3[right2>>>16&0x3f]|spfunction5[right2>>>8&0x3f]|spfunction7[right2&0x3f]);}// unreverse left and right
tmp=left;left=right;right=tmp;}// rotate right 1 bit
left=left>>>1|left<<31;right=right>>>1|right<<31;// now perform IP-1, which is IP in the opposite direction
tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(right>>>2^left)&0x33333333;left^=tmp;right^=tmp<<2;tmp=(left>>>16^right)&0x0000ffff;right^=tmp;left^=tmp<<16;tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;output[0]=left;output[1]=right;}/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('DES-<mode>', key);
 * forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates a deprecated DES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param options the options to use.
 *          key the symmetric key to use (64 or 192 bits).
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */function _createCipher(options){options=options||{};var mode=(options.mode||'CBC').toUpperCase();var algorithm='DES-'+mode;var cipher;if(options.decrypt){cipher=forge.cipher.createDecipher(algorithm,options.key);}else{cipher=forge.cipher.createCipher(algorithm,options.key);}// backwards compatible start API
var start=cipher.start;cipher.start=function(iv,options){// backwards compatibility: support second arg as output buffer
var output=null;if(options instanceof forge.util.ByteBuffer){output=options;options={};}options=options||{};options.output=output;options.iv=iv;start.call(cipher,options);};return cipher;}/***/},/* 13 */ /***/function(module,exports,__webpack_require__){/**
 * Password-Based Key-Derivation Function #2 implementation.
 *
 * See RFC 2898 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(14);__webpack_require__(4);__webpack_require__(1);var pkcs5=forge.pkcs5=forge.pkcs5||{};var crypto;if(forge.util.isNodejs&&!forge.options.usePureJavaScript){crypto=__webpack_require__(15);}/**
 * Derives a key from a password.
 *
 * @param p the password as a binary-encoded string of bytes.
 * @param s the salt as a binary-encoded string of bytes.
 * @param c the iteration count, a positive integer.
 * @param dkLen the intended length, in bytes, of the derived key,
 *          (max: 2^32 - 1) * hash length of the PRF.
 * @param [md] the message digest (or algorithm identifier as a string) to use
 *          in the PRF, defaults to SHA-1.
 * @param [callback(err, key)] presence triggers asynchronous version, called
 *          once the operation completes.
 *
 * @return the derived key, as a binary-encoded string of bytes, for the
 *           synchronous version (if no callback is specified).
 */module.exports=forge.pbkdf2=pkcs5.pbkdf2=function(p,s,c,dkLen,md,callback){if(typeof md==='function'){callback=md;md=null;}// use native implementation if possible and not disabled, note that
// some node versions only support SHA-1, others allow digest to be changed
if(forge.util.isNodejs&&!forge.options.usePureJavaScript&&crypto.pbkdf2&&(md===null||_typeof(md)!=='object')&&(crypto.pbkdf2Sync.length>4||!md||md==='sha1')){if(typeof md!=='string'){// default prf to SHA-1
md='sha1';}p=new Buffer(p,'binary');s=new Buffer(s,'binary');if(!callback){if(crypto.pbkdf2Sync.length===4){return crypto.pbkdf2Sync(p,s,c,dkLen).toString('binary');}return crypto.pbkdf2Sync(p,s,c,dkLen,md).toString('binary');}if(crypto.pbkdf2Sync.length===4){return crypto.pbkdf2(p,s,c,dkLen,function(err,key){if(err){return callback(err);}callback(null,key.toString('binary'));});}return crypto.pbkdf2(p,s,c,dkLen,md,function(err,key){if(err){return callback(err);}callback(null,key.toString('binary'));});}if(typeof md==='undefined'||md===null){// default prf to SHA-1
md='sha1';}if(typeof md==='string'){if(!(md in forge.md.algorithms)){throw new Error('Unknown hash algorithm: '+md);}md=forge.md[md].create();}var hLen=md.digestLength;/* 1. If dkLen > (2^32 - 1) * hLen, output "derived key too long" and
    stop. */if(dkLen>0xFFFFFFFF*hLen){var err=new Error('Derived key is too long.');if(callback){return callback(err);}throw err;}/* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:

    len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */var len=Math.ceil(dkLen/hLen);var r=dkLen-(len-1)*hLen;/* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:

    T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),

    where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:

    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c

    where

    u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).

    Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */var prf=forge.hmac.create();prf.start(md,p);var dk='';var xor,u_c,u_c1;// sync version
if(!callback){for(var i=1;i<=len;++i){// PRF(P, S || INT(i)) (first iteration)
prf.start(null,null);prf.update(s);prf.update(forge.util.int32ToBytes(i));xor=u_c1=prf.digest().getBytes();// PRF(P, u_{c-1}) (other iterations)
for(var j=2;j<=c;++j){prf.start(null,null);prf.update(u_c1);u_c=prf.digest().getBytes();// F(p, s, c, i)
xor=forge.util.xorBytes(xor,u_c,hLen);u_c1=u_c;}/* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:

        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */dk+=i<len?xor:xor.substr(0,r);}/* 5. Output the derived key DK. */return dk;}// async version
var i=1,j;function outer(){if(i>len){// done
return callback(null,dk);}// PRF(P, S || INT(i)) (first iteration)
prf.start(null,null);prf.update(s);prf.update(forge.util.int32ToBytes(i));xor=u_c1=prf.digest().getBytes();// PRF(P, u_{c-1}) (other iterations)
j=2;inner();}function inner(){if(j<=c){prf.start(null,null);prf.update(u_c1);u_c=prf.digest().getBytes();// F(p, s, c, i)
xor=forge.util.xorBytes(xor,u_c,hLen);u_c1=u_c;++j;return forge.util.setImmediate(inner);}/* 4. Concatenate the blocks and extract the first dkLen octets to
      produce a derived key DK:

      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */dk+=i<len?xor:xor.substr(0,r);++i;outer();}outer();};/***/},/* 14 */ /***/function(module,exports,__webpack_require__){/**
 * Hash-based Message Authentication Code implementation. Requires a message
 * digest object that can be obtained, for example, from forge.md.sha1 or
 * forge.md.md5.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);/* HMAC API */var hmac=module.exports=forge.hmac=forge.hmac||{};/**
 * Creates an HMAC object that uses the given message digest object.
 *
 * @return an HMAC object.
 */hmac.create=function(){// the hmac key to use
var _key=null;// the message digest to use
var _md=null;// the inner padding
var _ipadding=null;// the outer padding
var _opadding=null;// hmac context
var ctx={};/**
   * Starts or restarts the HMAC with the given key and message digest.
   *
   * @param md the message digest to use, null to reuse the previous one,
   *           a string to use builtin 'sha1', 'md5', 'sha256'.
   * @param key the key to use as a string, array of bytes, byte buffer,
   *           or null to reuse the previous key.
   */ctx.start=function(md,key){if(md!==null){if(typeof md==='string'){// create builtin message digest
md=md.toLowerCase();if(md in forge.md.algorithms){_md=forge.md.algorithms[md].create();}else{throw new Error('Unknown hash algorithm "'+md+'"');}}else{// store message digest
_md=md;}}if(key===null){// reuse previous key
key=_key;}else{if(typeof key==='string'){// convert string into byte buffer
key=forge.util.createBuffer(key);}else if(forge.util.isArray(key)){// convert byte array into byte buffer
var tmp=key;key=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){key.putByte(tmp[i]);}}// if key is longer than blocksize, hash it
var keylen=key.length();if(keylen>_md.blockLength){_md.start();_md.update(key.bytes());key=_md.digest();}// mix key into inner and outer padding
// ipadding = [0x36 * blocksize] ^ key
// opadding = [0x5C * blocksize] ^ key
_ipadding=forge.util.createBuffer();_opadding=forge.util.createBuffer();keylen=key.length();for(var i=0;i<keylen;++i){var tmp=key.at(i);_ipadding.putByte(0x36^tmp);_opadding.putByte(0x5C^tmp);}// if key is shorter than blocksize, add additional padding
if(keylen<_md.blockLength){var tmp=_md.blockLength-keylen;for(var i=0;i<tmp;++i){_ipadding.putByte(0x36);_opadding.putByte(0x5C);}}_key=key;_ipadding=_ipadding.bytes();_opadding=_opadding.bytes();}// digest is done like so: hash(opadding | hash(ipadding | message))
// prepare to do inner hash
// hash(ipadding | message)
_md.start();_md.update(_ipadding);};/**
   * Updates the HMAC with the given message bytes.
   *
   * @param bytes the bytes to update with.
   */ctx.update=function(bytes){_md.update(bytes);};/**
   * Produces the Message Authentication Code (MAC).
   *
   * @return a byte buffer containing the digest value.
   */ctx.getMac=function(){// digest is done like so: hash(opadding | hash(ipadding | message))
// here we do the outer hashing
var inner=_md.digest().bytes();_md.start();_md.update(_opadding);_md.update(inner);return _md.digest();};// alias for getMac
ctx.digest=ctx.getMac;return ctx;};/***/},/* 15 */ /***/function(module,exports){/* (ignored) */ /***/},/* 16 */ /***/function(module,exports,__webpack_require__){// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.
// Basic JavaScript BN library - subset useful for RSA encryption.
/*
Licensing (LICENSE)
-------------------

This software is covered under the following copyright:
*/ /*
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */ /*
Address all questions regarding this license to:

  Tom Wu
  tjw@cs.Stanford.EDU
*/var forge=__webpack_require__(0);module.exports=forge.jsbn=forge.jsbn||{};// Bits per digit
var dbits;// JavaScript engine analysis
var canary=0xdeadbeefcafe;var j_lm=(canary&0xffffff)==0xefcafe;// (public) Constructor
function BigInteger(a,b,c){this.data=[];if(a!=null)if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b);}forge.jsbn.BigInteger=BigInteger;// return new, unset BigInteger
function nbi(){return new BigInteger(null);}// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this.data[i++]+w.data[j]+c;c=Math.floor(v/0x4000000);w.data[j++]=v&0x3ffffff;}return c;}// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n){var xl=x&0x7fff,xh=x>>15;while(--n>=0){var l=this.data[i]&0x7fff;var h=this.data[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);w.data[j++]=l&0x3fffffff;}return c;}// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n){var xl=x&0x3fff,xh=x>>14;while(--n>=0){var l=this.data[i]&0x3fff;var h=this.data[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&0x3fff)<<14)+w.data[j]+c;c=(l>>28)+(m>>14)+xh*h;w.data[j++]=l&0xfffffff;}return c;}// node.js (no browser)
if(typeof navigator==='undefined'){BigInteger.prototype.am=am3;dbits=28;}else if(j_lm&&navigator.appName=="Microsoft Internet Explorer"){BigInteger.prototype.am=am2;dbits=30;}else if(j_lm&&navigator.appName!="Netscape"){BigInteger.prototype.am=am1;dbits=26;}else{// Mozilla/Netscape seems to prefer am3
BigInteger.prototype.am=am3;dbits=28;}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=(1<<dbits)-1;BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;// Digit conversions
var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array();var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv){BI_RC[rr++]=vv;}rr="a".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}rr="A".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}function int2char(n){return BI_RM.charAt(n);}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];return c==null?-1:c;}// (protected) copy this to r
function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i){r.data[i]=this.data[i];}r.t=this.t;r.s=this.s;}// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this.data[0]=x;else if(x<-1)this.data[0]=x+this.DV;else this.t=0;}// return bigint initialized to value
function nbv(i){var r=nbi();r.fromInt(i);return r;}// (protected) set from string and radix
function bnpFromString(s,b){var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;// byte array
else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{this.fromRadix(s,b);return;}this.t=0;this.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&0xff:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue;}mi=false;if(sh==0)this.data[this.t++]=x;else if(sh+k>this.DB){this.data[this.t-1]|=(x&(1<<this.DB-sh)-1)<<sh;this.data[this.t++]=x>>this.DB-sh;}else this.data[this.t-1]|=x<<sh;sh+=k;if(sh>=this.DB)sh-=this.DB;}if(k==8&&(s[0]&0x80)!=0){this.s=-1;if(sh>0)this.data[this.t-1]|=(1<<this.DB-sh)-1<<sh;}this.clamp();if(mi)BigInteger.ZERO.subTo(this,this);}// (protected) clamp off excess high words
function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this.data[this.t-1]==c){--this.t;}}// (public) return string representation in given radix
function bnToString(b){if(this.s<0)return"-"+this.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return this.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=this.t;var p=this.DB-i*this.DB%k;if(i-->0){if(p<this.DB&&(d=this.data[i]>>p)>0){m=true;r=int2char(d);}while(i>=0){if(p<k){d=(this.data[i]&(1<<p)-1)<<k-p;d|=this.data[--i]>>(p+=this.DB-k);}else{d=this.data[i]>>(p-=k)&km;if(p<=0){p+=this.DB;--i;}}if(d>0)m=true;if(m)r+=int2char(d);}}return m?r:"0";}// (public) -this
function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,r);return r;}// (public) |this|
function bnAbs(){return this.s<0?this.negate():this;}// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0){if((r=this.data[i]-a.data[i])!=0)return r;}return 0;}// returns bit length of the integer x
function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16;}if((t=x>>8)!=0){x=t;r+=8;}if((t=x>>4)!=0){x=t;r+=4;}if((t=x>>2)!=0){x=t;r+=2;}if((t=x>>1)!=0){x=t;r+=1;}return r;}// (public) return the number of bits in "this"
function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this.data[this.t-1]^this.s&this.DM);}// (protected) r = this << n*DB
function bnpDLShiftTo(n,r){var i;for(i=this.t-1;i>=0;--i){r.data[i+n]=this.data[i];}for(i=n-1;i>=0;--i){r.data[i]=0;}r.t=this.t+n;r.s=this.s;}// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i){r.data[i-n]=this.data[i];}r.t=Math.max(this.t-n,0);r.s=this.s;}// (protected) r = this << n
function bnpLShiftTo(n,r){var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/this.DB),c=this.s<<bs&this.DM,i;for(i=this.t-1;i>=0;--i){r.data[i+ds+1]=this.data[i]>>cbs|c;c=(this.data[i]&bm)<<bs;}for(i=ds-1;i>=0;--i){r.data[i]=0;}r.data[ds]=c;r.t=this.t+ds+1;r.s=this.s;r.clamp();}// (protected) r = this >> n
function bnpRShiftTo(n,r){r.s=this.s;var ds=Math.floor(n/this.DB);if(ds>=this.t){r.t=0;return;}var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<bs)-1;r.data[0]=this.data[ds]>>bs;for(var i=ds+1;i<this.t;++i){r.data[i-ds-1]|=(this.data[i]&bm)<<cbs;r.data[i-ds]=this.data[i]>>bs;}if(bs>0)r.data[this.t-ds-1]|=(this.s&bm)<<cbs;r.t=this.t-ds;r.clamp();}// (protected) r = this - a
function bnpSubTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this.data[i]-a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}if(a.t<this.t){c-=a.s;while(i<this.t){c+=this.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=this.s;}else{c+=this.s;while(i<a.t){c-=a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c-=a.s;}r.s=c<0?-1:0;if(c<-1)r.data[i++]=this.DV+c;else if(c>0)r.data[i++]=c;r.t=i;r.clamp();}// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0){r.data[i]=0;}for(i=0;i<y.t;++i){r.data[i+x.t]=x.am(0,y.data[i],r,i,0,x.t);}r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r);}// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0){r.data[i]=0;}for(i=0;i<x.t-1;++i){var c=x.am(i,x.data[i],r,2*i,0,1);if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1))>=x.DV){r.data[i+x.t]-=x.DV;r.data[i+x.t+1]=1;}}if(r.t>0)r.data[r.t-1]+=x.am(i,x.data[i],r,2*i,0,1);r.s=0;r.clamp();}// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r){var pm=m.abs();if(pm.t<=0)return;var pt=this.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)this.copyTo(r);return;}if(r==null)r=nbi();var y=nbi(),ts=this.s,ms=m.s;var nsh=this.DB-nbits(pm.data[pm.t-1]);// normalize modulus
if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r);}else{pm.copyTo(y);pt.copyTo(r);}var ys=y.t;var y0=y.data[ys-1];if(y0==0)return;var yt=y0*(1<<this.F1)+(ys>1?y.data[ys-2]>>this.F2:0);var d1=this.FV/yt,d2=(1<<this.F1)/yt,e=1<<this.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r.data[r.t++]=1;r.subTo(t,r);}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);// "negative" y so we can replace sub with am later
while(y.t<ys){y.data[y.t++]=0;}while(--j>=0){// Estimate quotient digit
var qd=r.data[--i]==y0?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);if((r.data[i]+=y.am(0,qd,r,j,0,ys))<qd){// Try it out
y.dlShiftTo(j,t);r.subTo(t,r);while(r.data[i]<--qd){r.subTo(t,r);}}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q);}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);// Denormalize remainder
if(ts<0)BigInteger.ZERO.subTo(r,r);}// (public) this mod a
function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r;}// Modular reduction using "classic" algorithm
function Classic(m){this.m=m;}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x;}function cRevert(x){return x;}function cReduce(x){x.divRemTo(this.m,null,x);}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}function cSqrTo(x,r){x.squareTo(r);this.reduce(r);}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit(){if(this.t<1)return 0;var x=this.data[0];if((x&1)==0)return 0;var y=x&3;// y == 1/x mod 2^2
y=y*(2-(x&0xf)*y)&0xf;// y == 1/x mod 2^4
y=y*(2-(x&0xff)*y)&0xff;// y == 1/x mod 2^8
y=y*(2-((x&0xffff)*y&0xffff))&0xffff;// y == 1/x mod 2^16
// last step - calculate inverse mod DV directly;
// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
y=y*(2-x*y%this.DV)%this.DV;// y == 1/x mod 2^dbits
// we really want the negative inverse, and -DV < y < DV
return y>0?this.DV-y:-y;}// Montgomery reduction
function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&0x7fff;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t;}// xR mod m
function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r;}// x/R mod m
function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r;}// x = x/R mod m (HAC 14.32)
function montReduce(x){while(x.t<=this.mt2){// pad x so am has enough room later
x.data[x.t++]=0;}for(var i=0;i<this.m.t;++i){// faster way of calculating u0 = x.data[i]*mp mod DV
var j=x.data[i]&0x7fff;var u0=j*this.mpl+((j*this.mph+(x.data[i]>>15)*this.mpl&this.um)<<15)&x.DM;// use am to combine the multiply-shift-add into one call
j=i+this.m.t;x.data[j]+=this.m.am(0,u0,x,i,0,this.m.t);// propagate carry
while(x.data[j]>=x.DV){x.data[j]-=x.DV;x.data[++j]++;}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x);}// r = "x^2/R mod m"; x != r
function montSqrTo(x,r){x.squareTo(r);this.reduce(r);}// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;// (protected) true iff this is even
function bnpIsEven(){return(this.t>0?this.data[0]&1:this.s)==0;}// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z){if(e>0xffffffff||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t;}}return z.revert(r);}// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z);}// protected
BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;// public
BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;// "constants"
BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);// jsbn2 lib
//Copyright (c) 2005-2009  Tom Wu
//All Rights Reserved.
//See "LICENSE" for details (See jsbn.js for LICENSE).
//Extended JavaScript BN functions, required for RSA private ops.
//Version 1.1: new BigInteger("0", 10) returns "proper" zero
//(public)
function bnClone(){var r=nbi();this.copyTo(r);return r;}//(public) return value as integer
function bnIntValue(){if(this.s<0){if(this.t==1)return this.data[0]-this.DV;else if(this.t==0)return-1;}else if(this.t==1)return this.data[0];else if(this.t==0)return 0;// assumes 16 < DB < 32
return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0];}//(public) return value as byte
function bnByteValue(){return this.t==0?this.s:this.data[0]<<24>>24;}//(public) return value as short (assumes DB>=16)
function bnShortValue(){return this.t==0?this.s:this.data[0]<<16>>16;}//(protected) return x s.t. r^x < DV
function bnpChunkSize(r){return Math.floor(Math.LN2*this.DB/Math.log(r));}//(public) 0 if this == 0, 1 if this > 0
function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this.data[0]<=0)return 0;else return 1;}//(protected) convert to radix string
function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z);}return z.intValue().toString(b)+r;}//(protected) convert from radix string
function bnpFromRadix(s,b){this.fromInt(0);if(b==null)b=10;var cs=this.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&this.signum()==0)mi=true;continue;}w=b*w+x;if(++j>=cs){this.dMultiply(d);this.dAddOffset(w,0);j=0;w=0;}}if(j>0){this.dMultiply(Math.pow(b,j));this.dAddOffset(w,0);}if(mi)BigInteger.ZERO.subTo(this,this);}//(protected) alternate constructor
function bnpFromNumber(a,b,c){if("number"==typeof b){// new BigInteger(int,int,RNG)
if(a<2)this.fromInt(1);else{this.fromNumber(a,c);if(!this.testBit(a-1))// force MSB set
this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);if(this.isEven())this.dAddOffset(1,0);// force odd
while(!this.isProbablePrime(b)){this.dAddOffset(2,0);if(this.bitLength()>a)this.subTo(BigInteger.ONE.shiftLeft(a-1),this);}}}else{// new BigInteger(int,RNG)
var x=new Array(),t=a&7;x.length=(a>>3)+1;b.nextBytes(x);if(t>0)x[0]&=(1<<t)-1;else x[0]=0;this.fromString(x,256);}}//(public) convert to bigendian byte array
function bnToByteArray(){var i=this.t,r=new Array();r[0]=this.s;var p=this.DB-i*this.DB%8,d,k=0;if(i-->0){if(p<this.DB&&(d=this.data[i]>>p)!=(this.s&this.DM)>>p)r[k++]=d|this.s<<this.DB-p;while(i>=0){if(p<8){d=(this.data[i]&(1<<p)-1)<<8-p;d|=this.data[--i]>>(p+=this.DB-8);}else{d=this.data[i]>>(p-=8)&0xff;if(p<=0){p+=this.DB;--i;}}if((d&0x80)!=0)d|=-256;if(k==0&&(this.s&0x80)!=(d&0x80))++k;if(k>0||d!=this.s)r[k++]=d;}}return r;}function bnEquals(a){return this.compareTo(a)==0;}function bnMin(a){return this.compareTo(a)<0?this:a;}function bnMax(a){return this.compareTo(a)>0?this:a;}//(protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r){var i,f,m=Math.min(a.t,this.t);for(i=0;i<m;++i){r.data[i]=op(this.data[i],a.data[i]);}if(a.t<this.t){f=a.s&this.DM;for(i=m;i<this.t;++i){r.data[i]=op(this.data[i],f);}r.t=this.t;}else{f=this.s&this.DM;for(i=m;i<a.t;++i){r.data[i]=op(f,a.data[i]);}r.t=a.t;}r.s=op(this.s,a.s);r.clamp();}//(public) this & a
function op_and(x,y){return x&y;}function bnAnd(a){var r=nbi();this.bitwiseTo(a,op_and,r);return r;}//(public) this | a
function op_or(x,y){return x|y;}function bnOr(a){var r=nbi();this.bitwiseTo(a,op_or,r);return r;}//(public) this ^ a
function op_xor(x,y){return x^y;}function bnXor(a){var r=nbi();this.bitwiseTo(a,op_xor,r);return r;}//(public) this & ~a
function op_andnot(x,y){return x&~y;}function bnAndNot(a){var r=nbi();this.bitwiseTo(a,op_andnot,r);return r;}//(public) ~this
function bnNot(){var r=nbi();for(var i=0;i<this.t;++i){r.data[i]=this.DM&~this.data[i];}r.t=this.t;r.s=~this.s;return r;}//(public) this << n
function bnShiftLeft(n){var r=nbi();if(n<0)this.rShiftTo(-n,r);else this.lShiftTo(n,r);return r;}//(public) this >> n
function bnShiftRight(n){var r=nbi();if(n<0)this.lShiftTo(-n,r);else this.rShiftTo(n,r);return r;}//return index of lowest 1-bit in x, x < 2^31
function lbit(x){if(x==0)return-1;var r=0;if((x&0xffff)==0){x>>=16;r+=16;}if((x&0xff)==0){x>>=8;r+=8;}if((x&0xf)==0){x>>=4;r+=4;}if((x&3)==0){x>>=2;r+=2;}if((x&1)==0)++r;return r;}//(public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit(){for(var i=0;i<this.t;++i){if(this.data[i]!=0)return i*this.DB+lbit(this.data[i]);}if(this.s<0)return this.t*this.DB;return-1;}//return number of 1 bits in x
function cbit(x){var r=0;while(x!=0){x&=x-1;++r;}return r;}//(public) return number of set bits
function bnBitCount(){var r=0,x=this.s&this.DM;for(var i=0;i<this.t;++i){r+=cbit(this.data[i]^x);}return r;}//(public) true iff nth bit is set
function bnTestBit(n){var j=Math.floor(n/this.DB);if(j>=this.t)return this.s!=0;return(this.data[j]&1<<n%this.DB)!=0;}//(protected) this op (1<<n)
function bnpChangeBit(n,op){var r=BigInteger.ONE.shiftLeft(n);this.bitwiseTo(r,op,r);return r;}//(public) this | (1<<n)
function bnSetBit(n){return this.changeBit(n,op_or);}//(public) this & ~(1<<n)
function bnClearBit(n){return this.changeBit(n,op_andnot);}//(public) this ^ (1<<n)
function bnFlipBit(n){return this.changeBit(n,op_xor);}//(protected) r = this + a
function bnpAddTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this.data[i]+a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}if(a.t<this.t){c+=a.s;while(i<this.t){c+=this.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=this.s;}else{c+=this.s;while(i<a.t){c+=a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=a.s;}r.s=c<0?-1:0;if(c>0)r.data[i++]=c;else if(c<-1)r.data[i++]=this.DV+c;r.t=i;r.clamp();}//(public) this + a
function bnAdd(a){var r=nbi();this.addTo(a,r);return r;}//(public) this - a
function bnSubtract(a){var r=nbi();this.subTo(a,r);return r;}//(public) this * a
function bnMultiply(a){var r=nbi();this.multiplyTo(a,r);return r;}//(public) this / a
function bnDivide(a){var r=nbi();this.divRemTo(a,r,null);return r;}//(public) this % a
function bnRemainder(a){var r=nbi();this.divRemTo(a,null,r);return r;}//(public) [this/a,this%a]
function bnDivideAndRemainder(a){var q=nbi(),r=nbi();this.divRemTo(a,q,r);return new Array(q,r);}//(protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n){this.data[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp();}//(protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w){this.data[this.t++]=0;}this.data[w]+=n;while(this.data[w]>=this.DV){this.data[w]-=this.DV;if(++w>=this.t)this.data[this.t++]=0;++this.data[w];}}//A "null" reducer
function NullExp(){}function nNop(x){return x;}function nMulTo(x,y,r){x.multiplyTo(y,r);}function nSqrTo(x,r){x.squareTo(r);}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;//(public) this^e
function bnPow(e){return this.exp(e,new NullExp());}//(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r){var i=Math.min(this.t+a.t,n);r.s=0;// assumes a,this >= 0
r.t=i;while(i>0){r.data[--i]=0;}var j;for(j=r.t-this.t;i<j;++i){r.data[i+this.t]=this.am(0,a.data[i],r,i,0,this.t);}for(j=Math.min(a.t,n);i<j;++i){this.am(0,a.data[i],r,i,0,n-i);}r.clamp();}//(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r){--n;var i=r.t=this.t+a.t-n;r.s=0;// assumes a,this >= 0
while(--i>=0){r.data[i]=0;}for(i=Math.max(n-this.t,0);i<a.t;++i){r.data[this.t+i-n]=this.am(n-i,a.data[i],r,0,0,this.t+i-n);}r.clamp();r.drShiftTo(1,r);}//Barrett modular reduction
function Barrett(m){// setup Barrett
this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*m.t,this.r2);this.mu=this.r2.divide(m);this.m=m;}function barrettConvert(x){if(x.s<0||x.t>2*this.m.t)return x.mod(this.m);else if(x.compareTo(this.m)<0)return x;else{var r=nbi();x.copyTo(r);this.reduce(r);return r;}}function barrettRevert(x){return x;}//x = x mod m (HAC 14.42)
function barrettReduce(x){x.drShiftTo(this.m.t-1,this.r2);if(x.t>this.m.t+1){x.t=this.m.t+1;x.clamp();}this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(x.compareTo(this.r2)<0){x.dAddOffset(1,this.m.t+1);}x.subTo(this.r2,x);while(x.compareTo(this.m)>=0){x.subTo(this.m,x);}}//r = x^2 mod m; x != r
function barrettSqrTo(x,r){x.squareTo(r);this.reduce(r);}//r = x*y mod m; x,y != r
function barrettMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;//(public) this^e % m (HAC 14.85)
function bnModPow(e,m){var i=e.bitLength(),k,r=nbv(1),z;if(i<=0)return r;else if(i<18)k=1;else if(i<48)k=3;else if(i<144)k=4;else if(i<768)k=5;else k=6;if(i<8)z=new Classic(m);else if(m.isEven())z=new Barrett(m);else z=new Montgomery(m);// precomputation
var g=new Array(),n=3,k1=k-1,km=(1<<k)-1;g[1]=z.convert(this);if(k>1){var g2=nbi();z.sqrTo(g[1],g2);while(n<=km){g[n]=nbi();z.mulTo(g2,g[n-2],g[n]);n+=2;}}var j=e.t-1,w,is1=true,r2=nbi(),t;i=nbits(e.data[j])-1;while(j>=0){if(i>=k1)w=e.data[j]>>i-k1&km;else{w=(e.data[j]&(1<<i+1)-1)<<k1-i;if(j>0)w|=e.data[j-1]>>this.DB+i-k1;}n=k;while((w&1)==0){w>>=1;--n;}if((i-=n)<0){i+=this.DB;--j;}if(is1){// ret == 1, don't bother squaring or multiplying it
g[w].copyTo(r);is1=false;}else{while(n>1){z.sqrTo(r,r2);z.sqrTo(r2,r);n-=2;}if(n>0)z.sqrTo(r,r2);else{t=r;r=r2;r2=t;}z.mulTo(r2,g[w],r);}while(j>=0&&(e.data[j]&1<<i)==0){z.sqrTo(r,r2);t=r;r=r2;r2=t;if(--i<0){i=this.DB-1;--j;}}}return z.revert(r);}//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a){var x=this.s<0?this.negate():this.clone();var y=a.s<0?a.negate():a.clone();if(x.compareTo(y)<0){var t=x;x=y;y=t;}var i=x.getLowestSetBit(),g=y.getLowestSetBit();if(g<0)return x;if(i<g)g=i;if(g>0){x.rShiftTo(g,x);y.rShiftTo(g,y);}while(x.signum()>0){if((i=x.getLowestSetBit())>0)x.rShiftTo(i,x);if((i=y.getLowestSetBit())>0)y.rShiftTo(i,y);if(x.compareTo(y)>=0){x.subTo(y,x);x.rShiftTo(1,x);}else{y.subTo(x,y);y.rShiftTo(1,y);}}if(g>0)y.lShiftTo(g,y);return y;}//(protected) this % n, n < 2^26
function bnpModInt(n){if(n<=0)return 0;var d=this.DV%n,r=this.s<0?n-1:0;if(this.t>0)if(d==0)r=this.data[0]%n;else for(var i=this.t-1;i>=0;--i){r=(d*r+this.data[i])%n;}return r;}//(public) 1/this % m (HAC 14.61)
function bnModInverse(m){var ac=m.isEven();if(this.isEven()&&ac||m.signum()==0)return BigInteger.ZERO;var u=m.clone(),v=this.clone();var a=nbv(1),b=nbv(0),c=nbv(0),d=nbv(1);while(u.signum()!=0){while(u.isEven()){u.rShiftTo(1,u);if(ac){if(!a.isEven()||!b.isEven()){a.addTo(this,a);b.subTo(m,b);}a.rShiftTo(1,a);}else if(!b.isEven())b.subTo(m,b);b.rShiftTo(1,b);}while(v.isEven()){v.rShiftTo(1,v);if(ac){if(!c.isEven()||!d.isEven()){c.addTo(this,c);d.subTo(m,d);}c.rShiftTo(1,c);}else if(!d.isEven())d.subTo(m,d);d.rShiftTo(1,d);}if(u.compareTo(v)>=0){u.subTo(v,u);if(ac)a.subTo(c,a);b.subTo(d,b);}else{v.subTo(u,v);if(ac)c.subTo(a,c);d.subTo(b,d);}}if(v.compareTo(BigInteger.ONE)!=0)return BigInteger.ZERO;if(d.compareTo(m)>=0)return d.subtract(m);if(d.signum()<0)d.addTo(m,d);else return d;if(d.signum()<0)return d.add(m);else return d;}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];var lplim=(1<<26)/lowprimes[lowprimes.length-1];//(public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t){var i,x=this.abs();if(x.t==1&&x.data[0]<=lowprimes[lowprimes.length-1]){for(i=0;i<lowprimes.length;++i){if(x.data[0]==lowprimes[i])return true;}return false;}if(x.isEven())return false;i=1;while(i<lowprimes.length){var m=lowprimes[i],j=i+1;while(j<lowprimes.length&&m<lplim){m*=lowprimes[j++];}m=x.modInt(m);while(i<j){if(m%lowprimes[i++]==0)return false;}}return x.millerRabin(t);}//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t){var n1=this.subtract(BigInteger.ONE);var k=n1.getLowestSetBit();if(k<=0)return false;var r=n1.shiftRight(k);var prng=bnGetPrng();var a;for(var i=0;i<t;++i){// select witness 'a' at random from between 1 and n1
do{a=new BigInteger(this.bitLength(),prng);}while(a.compareTo(BigInteger.ONE)<=0||a.compareTo(n1)>=0);var y=a.modPow(r,this);if(y.compareTo(BigInteger.ONE)!=0&&y.compareTo(n1)!=0){var j=1;while(j++<k&&y.compareTo(n1)!=0){y=y.modPowInt(2,this);if(y.compareTo(BigInteger.ONE)==0)return false;}if(y.compareTo(n1)!=0)return false;}}return true;}// get pseudo random number generator
function bnGetPrng(){// create prng with api that matches BigInteger secure random
return{// x is an array to fill with bytes
nextBytes:function nextBytes(x){for(var i=0;i<x.length;++i){x[i]=Math.floor(Math.random()*0x0100);}}};}//protected
BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.fromNumber=bnpFromNumber;BigInteger.prototype.bitwiseTo=bnpBitwiseTo;BigInteger.prototype.changeBit=bnpChangeBit;BigInteger.prototype.addTo=bnpAddTo;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger.prototype.modInt=bnpModInt;BigInteger.prototype.millerRabin=bnpMillerRabin;//public
BigInteger.prototype.clone=bnClone;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.byteValue=bnByteValue;BigInteger.prototype.shortValue=bnShortValue;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.toByteArray=bnToByteArray;BigInteger.prototype.equals=bnEquals;BigInteger.prototype.min=bnMin;BigInteger.prototype.max=bnMax;BigInteger.prototype.and=bnAnd;BigInteger.prototype.or=bnOr;BigInteger.prototype.xor=bnXor;BigInteger.prototype.andNot=bnAndNot;BigInteger.prototype.not=bnNot;BigInteger.prototype.shiftLeft=bnShiftLeft;BigInteger.prototype.shiftRight=bnShiftRight;BigInteger.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger.prototype.bitCount=bnBitCount;BigInteger.prototype.testBit=bnTestBit;BigInteger.prototype.setBit=bnSetBit;BigInteger.prototype.clearBit=bnClearBit;BigInteger.prototype.flipBit=bnFlipBit;BigInteger.prototype.add=bnAdd;BigInteger.prototype.subtract=bnSubtract;BigInteger.prototype.multiply=bnMultiply;BigInteger.prototype.divide=bnDivide;BigInteger.prototype.remainder=bnRemainder;BigInteger.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger.prototype.modPow=bnModPow;BigInteger.prototype.modInverse=bnModInverse;BigInteger.prototype.pow=bnPow;BigInteger.prototype.gcd=bnGCD;BigInteger.prototype.isProbablePrime=bnIsProbablePrime;//BigInteger interfaces not implemented in jsbn:
//BigInteger(int signum, byte[] magnitude)
//double doubleValue()
//float floatValue()
//int hashCode()
//long longValue()
//static BigInteger valueOf(long val)
/***/},/* 17 */ /***/function(module,exports,__webpack_require__){/**
 * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);var sha1=module.exports=forge.sha1=forge.sha1||{};forge.md.sha1=forge.md.algorithms.sha1=sha1;/**
 * Creates a SHA-1 message digest object.
 *
 * @return a message digest object.
 */sha1.create=function(){// do initialization as necessary
if(!_initialized){_init();}// SHA-1 state contains five 32-bit integers
var _state=null;// input buffer
var _input=forge.util.createBuffer();// used for word storage
var _w=new Array(80);// message digest object
var md={algorithm:'sha1',blockLength:64,digestLength:20,// 56-bit length of message so far (does not including padding)
messageLength:0,// true message length
fullMessageLength:null,// size of message length in bytes
messageLengthSize:8};/**
   * Starts the digest.
   *
   * @return this digest object.
   */md.start=function(){// up to 56-bit message length for convenience
md.messageLength=0;// full message length (set md.messageLength64 for backwards-compatibility)
md.fullMessageLength=md.messageLength64=[];var int32s=md.messageLengthSize/4;for(var i=0;i<int32s;++i){md.fullMessageLength.push(0);}_input=forge.util.createBuffer();_state={h0:0x67452301,h1:0xEFCDAB89,h2:0x98BADCFE,h3:0x10325476,h4:0xC3D2E1F0};return md;};// start digest automatically for first time
md.start();/**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */md.update=function(msg,encoding){if(encoding==='utf8'){msg=forge.util.encodeUtf8(msg);}// update message length
var len=msg.length;md.messageLength+=len;len=[len/0x100000000>>>0,len>>>0];for(var i=md.fullMessageLength.length-1;i>=0;--i){md.fullMessageLength[i]+=len[1];len[1]=len[0]+(md.fullMessageLength[i]/0x100000000>>>0);md.fullMessageLength[i]=md.fullMessageLength[i]>>>0;len[0]=len[1]/0x100000000>>>0;}// add bytes to input buffer
_input.putBytes(msg);// process bytes
_update(_state,_w,_input);// compact input buffer every 2K or if empty
if(_input.read>2048||_input.length()===0){_input.compact();}return md;};/**
    * Produces the digest.
    *
    * @return a byte buffer containing the digest value.
    */md.digest=function(){/* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */var finalBlock=forge.util.createBuffer();finalBlock.putBytes(_input.bytes());// compute remaining size to be digested (include message length size)
var remaining=md.fullMessageLength[md.fullMessageLength.length-1]+md.messageLengthSize;// add padding for overflow blockSize - overflow
// _padding starts with 1 byte with first bit is set (byte value 128), then
// there may be up to (blockSize - 1) other pad bytes
var overflow=remaining&md.blockLength-1;finalBlock.putBytes(_padding.substr(0,md.blockLength-overflow));// serialize message length in bits in big-endian order; since length
// is stored in bytes we multiply by 8 and add carry from next int
var next,carry;var bits=md.fullMessageLength[0]*8;for(var i=0;i<md.fullMessageLength.length-1;++i){next=md.fullMessageLength[i+1]*8;carry=next/0x100000000>>>0;bits+=carry;finalBlock.putInt32(bits>>>0);bits=next>>>0;}finalBlock.putInt32(bits);var s2={h0:_state.h0,h1:_state.h1,h2:_state.h2,h3:_state.h3,h4:_state.h4};_update(s2,_w,finalBlock);var rval=forge.util.createBuffer();rval.putInt32(s2.h0);rval.putInt32(s2.h1);rval.putInt32(s2.h2);rval.putInt32(s2.h3);rval.putInt32(s2.h4);return rval;};return md;};// sha-1 padding bytes not initialized yet
var _padding=null;var _initialized=false;/**
 * Initializes the constant tables.
 */function _init(){// create padding
_padding=String.fromCharCode(128);_padding+=forge.util.fillString(String.fromCharCode(0x00),64);// now initialized
_initialized=true;}/**
 * Updates a SHA-1 state with the given byte buffer.
 *
 * @param s the SHA-1 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */function _update(s,w,bytes){// consume 512 bit (64 byte) chunks
var t,a,b,c,d,e,f,i;var len=bytes.length();while(len>=64){// the w array will be populated with sixteen 32-bit big-endian words
// and then extended into 80 32-bit words according to SHA-1 algorithm
// and for 32-79 using Max Locktyukhin's optimization
// initialize hash value for this chunk
a=s.h0;b=s.h1;c=s.h2;d=s.h3;e=s.h4;// round 1
for(i=0;i<16;++i){t=bytes.getInt32();w[i]=t;f=d^b&(c^d);t=(a<<5|a>>>27)+f+e+0x5A827999+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}for(;i<20;++i){t=w[i-3]^w[i-8]^w[i-14]^w[i-16];t=t<<1|t>>>31;w[i]=t;f=d^b&(c^d);t=(a<<5|a>>>27)+f+e+0x5A827999+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 2
for(;i<32;++i){t=w[i-3]^w[i-8]^w[i-14]^w[i-16];t=t<<1|t>>>31;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0x6ED9EBA1+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}for(;i<40;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0x6ED9EBA1+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 3
for(;i<60;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b&c|d&(b^c);t=(a<<5|a>>>27)+f+e+0x8F1BBCDC+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 4
for(;i<80;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0xCA62C1D6+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// update hash state
s.h0=s.h0+a|0;s.h1=s.h1+b|0;s.h2=s.h2+c|0;s.h3=s.h3+d|0;s.h4=s.h4+e|0;len-=64;}}/***/},/* 18 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of X.509 and related components (such as
 * Certification Signing Requests) of a Public Key Infrastructure.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The ASN.1 representation of an X.509v3 certificate is as follows
 * (see RFC 2459):
 *
 * Certificate ::= SEQUENCE {
 *   tbsCertificate       TBSCertificate,
 *   signatureAlgorithm   AlgorithmIdentifier,
 *   signatureValue       BIT STRING
 * }
 *
 * TBSCertificate ::= SEQUENCE {
 *   version         [0]  EXPLICIT Version DEFAULT v1,
 *   serialNumber         CertificateSerialNumber,
 *   signature            AlgorithmIdentifier,
 *   issuer               Name,
 *   validity             Validity,
 *   subject              Name,
 *   subjectPublicKeyInfo SubjectPublicKeyInfo,
 *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   extensions      [3]  EXPLICIT Extensions OPTIONAL
 *                        -- If present, version shall be v3
 * }
 *
 * Version ::= INTEGER  { v1(0), v2(1), v3(2) }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * Name ::= CHOICE {
 *   // only one possible choice for now
 *   RDNSequence
 * }
 *
 * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 *
 * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
 *
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type     AttributeType,
 *   value    AttributeValue
 * }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY DEFINED BY AttributeType
 *
 * Validity ::= SEQUENCE {
 *   notBefore      Time,
 *   notAfter       Time
 * }
 *
 * Time ::= CHOICE {
 *   utcTime        UTCTime,
 *   generalTime    GeneralizedTime
 * }
 *
 * UniqueIdentifier ::= BIT STRING
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm            AlgorithmIdentifier,
 *   subjectPublicKey     BIT STRING
 * }
 *
 * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
 *
 * Extension ::= SEQUENCE {
 *   extnID      OBJECT IDENTIFIER,
 *   critical    BOOLEAN DEFAULT FALSE,
 *   extnValue   OCTET STRING
 * }
 *
 * The only key algorithm currently supported for PKI is RSA.
 *
 * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
 *
 * PKCS#10 v1.7 describes certificate signing requests:
 *
 * CertificationRequestInfo:
 *
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes{{ CRIAttributes }}
 * }
 *
 * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
 *
 * CRIAttributes  ATTRIBUTE  ::= {
 *   ... -- add any locally defined attributes here -- }
 *
 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
 *   type   ATTRIBUTE.&id({IOSet}),
 *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
 * }
 *
 * CertificationRequest ::= SEQUENCE {
 *   certificationRequestInfo CertificationRequestInfo,
 *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
 *   signature          BIT STRING
 * }
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(2);__webpack_require__(12);__webpack_require__(4);__webpack_require__(30);__webpack_require__(3);__webpack_require__(8);__webpack_require__(19);__webpack_require__(6);__webpack_require__(1);// shortcut for asn.1 API
var asn1=forge.asn1;/* Public Key Infrastructure (PKI) implementation. */var pki=module.exports=forge.pki=forge.pki||{};var oids=pki.oids;// short name OID mappings
var _shortNames={};_shortNames['CN']=oids['commonName'];_shortNames['commonName']='CN';_shortNames['C']=oids['countryName'];_shortNames['countryName']='C';_shortNames['L']=oids['localityName'];_shortNames['localityName']='L';_shortNames['ST']=oids['stateOrProvinceName'];_shortNames['stateOrProvinceName']='ST';_shortNames['O']=oids['organizationName'];_shortNames['organizationName']='O';_shortNames['OU']=oids['organizationalUnitName'];_shortNames['organizationalUnitName']='OU';_shortNames['E']=oids['emailAddress'];_shortNames['emailAddress']='E';// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator=forge.pki.rsa.publicKeyValidator;// validator for an X.509v3 certificate
var x509CertificateValidator={name:'Certificate',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Certificate.TBSCertificate',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'tbsCertificate',value:[{name:'Certificate.TBSCertificate.version',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.version.integer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certVersion'}]},{name:'Certificate.TBSCertificate.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certSerialNumber'},{name:'Certificate.TBSCertificate.signature',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Certificate.TBSCertificate.signature.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certinfoSignatureOid'},{name:'Certificate.TBSCertificate.signature.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'certinfoSignatureParams'}]},{name:'Certificate.TBSCertificate.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certIssuer'},{name:'Certificate.TBSCertificate.validity',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,// Note: UTC and generalized times may both appear so the capture
// names are based on their detected order, the names used below
// are only for the common case, which validity time really means
// "notBefore" and which means "notAfter" will be determined by order
value:[{// notBefore (Time) (UTC time case)
name:'Certificate.TBSCertificate.validity.notBefore (utc)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.UTCTIME,constructed:false,optional:true,capture:'certValidity1UTCTime'},{// notBefore (Time) (generalized time case)
name:'Certificate.TBSCertificate.validity.notBefore (generalized)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.GENERALIZEDTIME,constructed:false,optional:true,capture:'certValidity2GeneralizedTime'},{// notAfter (Time) (only UTC time is supported)
name:'Certificate.TBSCertificate.validity.notAfter (utc)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.UTCTIME,constructed:false,optional:true,capture:'certValidity3UTCTime'},{// notAfter (Time) (only UTC time is supported)
name:'Certificate.TBSCertificate.validity.notAfter (generalized)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.GENERALIZEDTIME,constructed:false,optional:true,capture:'certValidity4GeneralizedTime'}]},{// Name (subject) (RDNSequence)
name:'Certificate.TBSCertificate.subject',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certSubject'},// SubjectPublicKeyInfo
publicKeyValidator,{// issuerUniqueID (optional)
name:'Certificate.TBSCertificate.issuerUniqueID',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.issuerUniqueID.id',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,// TODO: support arbitrary bit length ids
captureBitStringValue:'certIssuerUniqueId'}]},{// subjectUniqueID (optional)
name:'Certificate.TBSCertificate.subjectUniqueID',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:2,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.subjectUniqueID.id',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,// TODO: support arbitrary bit length ids
captureBitStringValue:'certSubjectUniqueId'}]},{// Extensions (optional)
name:'Certificate.TBSCertificate.extensions',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:3,constructed:true,captureAsn1:'certExtensions',optional:true}]},{// AlgorithmIdentifier (signature algorithm)
name:'Certificate.signatureAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// algorithm
name:'Certificate.signatureAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certSignatureOid'},{name:'Certificate.TBSCertificate.signature.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'certSignatureParams'}]},{// SignatureValue
name:'Certificate.signatureValue',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,captureBitStringValue:'certSignature'}]};var rsassaPssParameterValidator={name:'rsapss',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'rsapss.hashAlgorithm',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,value:[{name:'rsapss.hashAlgorithm.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.SEQUENCE,constructed:true,optional:true,value:[{name:'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'hashOid'/* parameter block omitted, for SHA1 NULL anyhow. */}]}]},{name:'rsapss.maskGenAlgorithm',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.SEQUENCE,constructed:true,optional:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'maskGenOid'},{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'maskGenHashOid'/* parameter block omitted, for SHA1 NULL anyhow. */}]}]}]},{name:'rsapss.saltLength',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:2,optional:true,value:[{name:'rsapss.saltLength.saltLength',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.INTEGER,constructed:false,capture:'saltLength'}]},{name:'rsapss.trailerField',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:3,optional:true,value:[{name:'rsapss.trailer.trailer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.INTEGER,constructed:false,capture:'trailer'}]}]};// validator for a CertificationRequestInfo structure
var certificationRequestInfoValidator={name:'CertificationRequestInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certificationRequestInfo',value:[{name:'CertificationRequestInfo.integer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certificationRequestInfoVersion'},{// Name (subject) (RDNSequence)
name:'CertificationRequestInfo.subject',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certificationRequestInfoSubject'},// SubjectPublicKeyInfo
publicKeyValidator,{name:'CertificationRequestInfo.attributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,capture:'certificationRequestInfoAttributes',value:[{name:'CertificationRequestInfo.attributes',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'CertificationRequestInfo.attributes.type',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false},{name:'CertificationRequestInfo.attributes.value',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true}]}]}]};// validator for a CertificationRequest structure
var certificationRequestValidator={name:'CertificationRequest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'csr',value:[certificationRequestInfoValidator,{// AlgorithmIdentifier (signature algorithm)
name:'CertificationRequest.signatureAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// algorithm
name:'CertificationRequest.signatureAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'csrSignatureOid'},{name:'CertificationRequest.signatureAlgorithm.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'csrSignatureParams'}]},{// signature
name:'CertificationRequest.signature',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,captureBitStringValue:'csrSignature'}]};/**
 * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
 * sets into an array with objects that have type and value properties.
 *
 * @param rdn the RDNSequence to convert.
 * @param md a message digest to append type and value to if provided.
 */pki.RDNAttributesAsArray=function(rdn,md){var rval=[];// each value in 'rdn' in is a SET of RelativeDistinguishedName
var set,attr,obj;for(var si=0;si<rdn.value.length;++si){// get the RelativeDistinguishedName set
set=rdn.value[si];// each value in the SET is an AttributeTypeAndValue sequence
// containing first a type (an OID) and second a value (defined by
// the OID)
for(var i=0;i<set.value.length;++i){obj={};attr=set.value[i];obj.type=asn1.derToOid(attr.value[0].value);obj.value=attr.value[1].value;obj.valueTagClass=attr.value[1].type;// if the OID is known, get its name and short name
if(obj.type in oids){obj.name=oids[obj.type];if(obj.name in _shortNames){obj.shortName=_shortNames[obj.name];}}if(md){md.update(obj.type);md.update(obj.value);}rval.push(obj);}}return rval;};/**
 * Converts ASN.1 CRIAttributes into an array with objects that have type and
 * value properties.
 *
 * @param attributes the CRIAttributes to convert.
 */pki.CRIAttributesAsArray=function(attributes){var rval=[];// each value in 'attributes' in is a SEQUENCE with an OID and a SET
for(var si=0;si<attributes.length;++si){// get the attribute sequence
var seq=attributes[si];// each value in the SEQUENCE containing first a type (an OID) and
// second a set of values (defined by the OID)
var type=asn1.derToOid(seq.value[0].value);var values=seq.value[1].value;for(var vi=0;vi<values.length;++vi){var obj={};obj.type=type;obj.value=values[vi].value;obj.valueTagClass=values[vi].type;// if the OID is known, get its name and short name
if(obj.type in oids){obj.name=oids[obj.type];if(obj.name in _shortNames){obj.shortName=_shortNames[obj.name];}}// parse extensions
if(obj.type===oids.extensionRequest){obj.extensions=[];for(var ei=0;ei<obj.value.length;++ei){obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));}}rval.push(obj);}}return rval;};/**
 * Gets an issuer or subject attribute from its name, type, or short name.
 *
 * @param obj the issuer or subject object.
 * @param options a short name string or an object with:
 *          shortName the short name for the attribute.
 *          name the name for the attribute.
 *          type the type for the attribute.
 *
 * @return the attribute.
 */function _getAttribute(obj,options){if(typeof options==='string'){options={shortName:options};}var rval=null;var attr;for(var i=0;rval===null&&i<obj.attributes.length;++i){attr=obj.attributes[i];if(options.type&&options.type===attr.type){rval=attr;}else if(options.name&&options.name===attr.name){rval=attr;}else if(options.shortName&&options.shortName===attr.shortName){rval=attr;}}return rval;}/**
 * Converts signature parameters from ASN.1 structure.
 *
 * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
 * no parameters.
 *
 * RSASSA-PSS-params  ::=  SEQUENCE  {
 *   hashAlgorithm      [0] HashAlgorithm DEFAULT
 *                             sha1Identifier,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
 *                             mgf1SHA1Identifier,
 *   saltLength         [2] INTEGER DEFAULT 20,
 *   trailerField       [3] INTEGER DEFAULT 1
 * }
 *
 * HashAlgorithm  ::=  AlgorithmIdentifier
 *
 * MaskGenAlgorithm  ::=  AlgorithmIdentifier
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * @param oid The OID specifying the signature algorithm
 * @param obj The ASN.1 structure holding the parameters
 * @param fillDefaults Whether to use return default values where omitted
 * @return signature parameter object
 */var _readSignatureParameters=function _readSignatureParameters(oid,obj,fillDefaults){var params={};if(oid!==oids['RSASSA-PSS']){return params;}if(fillDefaults){params={hash:{algorithmOid:oids['sha1']},mgf:{algorithmOid:oids['mgf1'],hash:{algorithmOid:oids['sha1']}},saltLength:20};}var capture={};var errors=[];if(!asn1.validate(obj,rsassaPssParameterValidator,capture,errors)){var error=new Error('Cannot read RSASSA-PSS parameter block.');error.errors=errors;throw error;}if(capture.hashOid!==undefined){params.hash=params.hash||{};params.hash.algorithmOid=asn1.derToOid(capture.hashOid);}if(capture.maskGenOid!==undefined){params.mgf=params.mgf||{};params.mgf.algorithmOid=asn1.derToOid(capture.maskGenOid);params.mgf.hash=params.mgf.hash||{};params.mgf.hash.algorithmOid=asn1.derToOid(capture.maskGenHashOid);}if(capture.saltLength!==undefined){params.saltLength=capture.saltLength.charCodeAt(0);}return params;};/**
 * Converts an X.509 certificate from PEM format.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. This will scan the TBSCertificate part of the ASN.1
 * object while it is converted so it doesn't need to be converted back
 * to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certificate.
 */pki.certificateFromPem=function(pem,computeHash,strict){var msg=forge.pem.decode(pem)[0];if(msg.type!=='CERTIFICATE'&&msg.type!=='X509 CERTIFICATE'&&msg.type!=='TRUSTED CERTIFICATE'){var error=new Error('Could not convert certificate from PEM; PEM header type '+'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert certificate from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body,strict);return pki.certificateFromAsn1(obj,computeHash);};/**
 * Converts an X.509 certificate to PEM format.
 *
 * @param cert the certificate.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certificate.
 */pki.certificateToPem=function(cert,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'CERTIFICATE',body:asn1.toDer(pki.certificateToAsn1(cert)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts an RSA public key from PEM format.
 *
 * @param pem the PEM-formatted public key.
 *
 * @return the public key.
 */pki.publicKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='PUBLIC KEY'&&msg.type!=='RSA PUBLIC KEY'){var error=new Error('Could not convert public key from PEM; PEM header '+'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert public key from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body);return pki.publicKeyFromAsn1(obj);};/**
 * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */pki.publicKeyToPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'PUBLIC KEY',body:asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts an RSA public key to PEM format (using an RSAPublicKey).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */pki.publicKeyToRSAPublicKeyPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'RSA PUBLIC KEY',body:asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Gets a fingerprint for the given public key.
 *
 * @param options the options to use.
 *          [md] the message digest object to use (defaults to forge.md.sha1).
 *          [type] the type of fingerprint, such as 'RSAPublicKey',
 *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
 *          [encoding] an alternative output encoding, such as 'hex'
 *            (defaults to none, outputs a byte buffer).
 *          [delimiter] the delimiter to use between bytes for 'hex' encoded
 *            output, eg: ':' (defaults to none).
 *
 * @return the fingerprint as a byte buffer or other encoding based on options.
 */pki.getPublicKeyFingerprint=function(key,options){options=options||{};var md=options.md||forge.md.sha1.create();var type=options.type||'RSAPublicKey';var bytes;switch(type){case'RSAPublicKey':bytes=asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();break;case'SubjectPublicKeyInfo':bytes=asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();break;default:throw new Error('Unknown fingerprint type "'+options.type+'".');}// hash public key bytes
md.start();md.update(bytes);var digest=md.digest();if(options.encoding==='hex'){var hex=digest.toHex();if(options.delimiter){return hex.match(/.{2}/g).join(options.delimiter);}return hex;}else if(options.encoding==='binary'){return digest.getBytes();}else if(options.encoding){throw new Error('Unknown encoding "'+options.encoding+'".');}return digest;};/**
 * Converts a PKCS#10 certification request (CSR) from PEM format.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. This will scan the CertificationRequestInfo part of
 * the ASN.1 object while it is converted so it doesn't need to be converted
 * back to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certification request (CSR).
 */pki.certificationRequestFromPem=function(pem,computeHash,strict){var msg=forge.pem.decode(pem)[0];if(msg.type!=='CERTIFICATE REQUEST'){var error=new Error('Could not convert certification request from PEM; '+'PEM header type is not "CERTIFICATE REQUEST".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert certification request from PEM; '+'PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body,strict);return pki.certificationRequestFromAsn1(obj,computeHash);};/**
 * Converts a PKCS#10 certification request (CSR) to PEM format.
 *
 * @param csr the certification request.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certification request.
 */pki.certificationRequestToPem=function(csr,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'CERTIFICATE REQUEST',body:asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Creates an empty X.509v3 RSA certificate.
 *
 * @return the certificate.
 */pki.createCertificate=function(){var cert={};cert.version=0x02;cert.serialNumber='00';cert.signatureOid=null;cert.signature=null;cert.siginfo={};cert.siginfo.algorithmOid=null;cert.validity={};cert.validity.notBefore=new Date();cert.validity.notAfter=new Date();cert.issuer={};cert.issuer.getField=function(sn){return _getAttribute(cert.issuer,sn);};cert.issuer.addField=function(attr){_fillMissingFields([attr]);cert.issuer.attributes.push(attr);};cert.issuer.attributes=[];cert.issuer.hash=null;cert.subject={};cert.subject.getField=function(sn){return _getAttribute(cert.subject,sn);};cert.subject.addField=function(attr){_fillMissingFields([attr]);cert.subject.attributes.push(attr);};cert.subject.attributes=[];cert.subject.hash=null;cert.extensions=[];cert.publicKey=null;cert.md=null;/**
   * Sets the subject of this certificate.
   *
   * @param attrs the array of subject attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */cert.setSubject=function(attrs,uniqueId){// set new attributes, clear hash
_fillMissingFields(attrs);cert.subject.attributes=attrs;delete cert.subject.uniqueId;if(uniqueId){// TODO: support arbitrary bit length ids
cert.subject.uniqueId=uniqueId;}cert.subject.hash=null;};/**
   * Sets the issuer of this certificate.
   *
   * @param attrs the array of issuer attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */cert.setIssuer=function(attrs,uniqueId){// set new attributes, clear hash
_fillMissingFields(attrs);cert.issuer.attributes=attrs;delete cert.issuer.uniqueId;if(uniqueId){// TODO: support arbitrary bit length ids
cert.issuer.uniqueId=uniqueId;}cert.issuer.hash=null;};/**
   * Sets the extensions of this certificate.
   *
   * @param exts the array of extensions to use.
   */cert.setExtensions=function(exts){for(var i=0;i<exts.length;++i){_fillMissingExtensionFields(exts[i],{cert:cert});}// set new extensions
cert.extensions=exts;};/**
   * Gets an extension by its name or id.
   *
   * @param options the name to use or an object with:
   *          name the name to use.
   *          id the id to use.
   *
   * @return the extension or null if not found.
   */cert.getExtension=function(options){if(typeof options==='string'){options={name:options};}var rval=null;var ext;for(var i=0;rval===null&&i<cert.extensions.length;++i){ext=cert.extensions[i];if(options.id&&ext.id===options.id){rval=ext;}else if(options.name&&ext.name===options.name){rval=ext;}}return rval;};/**
   * Signs this certificate using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */cert.sign=function(key,md){// TODO: get signature OID from private key
cert.md=md||forge.md.sha1.create();var algorithmOid=oids[cert.md.algorithm+'WithRSAEncryption'];if(!algorithmOid){var error=new Error('Could not compute certificate digest. '+'Unknown message digest algorithm OID.');error.algorithm=cert.md.algorithm;throw error;}cert.signatureOid=cert.siginfo.algorithmOid=algorithmOid;// get TBSCertificate, convert to DER
cert.tbsCertificate=pki.getTBSCertificate(cert);var bytes=asn1.toDer(cert.tbsCertificate);// digest and sign
cert.md.update(bytes.getBytes());cert.signature=key.sign(cert.md);};/**
   * Attempts verify the signature on the passed certificate using this
   * certificate's public key.
   *
   * @param child the certificate to verify.
   *
   * @return true if verified, false if not.
   */cert.verify=function(child){var rval=false;if(!cert.issued(child)){var issuer=child.issuer;var subject=cert.subject;var error=new Error('The parent certificate did not issue the given child '+'certificate; the child certificate\'s issuer does not match the '+'parent\'s subject.');error.expectedIssuer=issuer.attributes;error.actualIssuer=subject.attributes;throw error;}var md=child.md;if(md===null){// check signature OID for supported signature types
if(child.signatureOid in oids){var oid=oids[child.signatureOid];switch(oid){case'sha1WithRSAEncryption':md=forge.md.sha1.create();break;case'md5WithRSAEncryption':md=forge.md.md5.create();break;case'sha256WithRSAEncryption':md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':md=forge.md.sha512.create();break;case'RSASSA-PSS':md=forge.md.sha256.create();break;}}if(md===null){var error=new Error('Could not compute certificate digest. '+'Unknown signature OID.');error.signatureOid=child.signatureOid;throw error;}// produce DER formatted TBSCertificate and digest it
var tbsCertificate=child.tbsCertificate||pki.getTBSCertificate(child);var bytes=asn1.toDer(tbsCertificate);md.update(bytes.getBytes());}if(md!==null){var scheme;switch(child.signatureOid){case oids.sha1WithRSAEncryption:scheme=undefined;/* use PKCS#1 v1.5 padding scheme */break;case oids['RSASSA-PSS']:var hash,mgf;/* initialize mgf */hash=oids[child.signatureParameters.mgf.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported MGF hash function.');error.oid=child.signatureParameters.mgf.hash.algorithmOid;error.name=hash;throw error;}mgf=oids[child.signatureParameters.mgf.algorithmOid];if(mgf===undefined||forge.mgf[mgf]===undefined){var error=new Error('Unsupported MGF function.');error.oid=child.signatureParameters.mgf.algorithmOid;error.name=mgf;throw error;}mgf=forge.mgf[mgf].create(forge.md[hash].create());/* initialize hash function */hash=oids[child.signatureParameters.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){throw{message:'Unsupported RSASSA-PSS hash function.',oid:child.signatureParameters.hash.algorithmOid,name:hash};}scheme=forge.pss.create(forge.md[hash].create(),mgf,child.signatureParameters.saltLength);break;}// verify signature on cert using public key
rval=cert.publicKey.verify(md.digest().getBytes(),child.signature,scheme);}return rval;};/**
   * Returns true if this certificate's issuer matches the passed
   * certificate's subject. Note that no signature check is performed.
   *
   * @param parent the certificate to check.
   *
   * @return true if this certificate's issuer matches the passed certificate's
   *         subject.
   */cert.isIssuer=function(parent){var rval=false;var i=cert.issuer;var s=parent.subject;// compare hashes if present
if(i.hash&&s.hash){rval=i.hash===s.hash;}else if(i.attributes.length===s.attributes.length){// all attributes are the same so issuer matches subject
rval=true;var iattr,sattr;for(var n=0;rval&&n<i.attributes.length;++n){iattr=i.attributes[n];sattr=s.attributes[n];if(iattr.type!==sattr.type||iattr.value!==sattr.value){// attribute mismatch
rval=false;}}}return rval;};/**
   * Returns true if this certificate's subject matches the issuer of the
   * given certificate). Note that not signature check is performed.
   *
   * @param child the certificate to check.
   *
   * @return true if this certificate's subject matches the passed
   *         certificate's issuer.
   */cert.issued=function(child){return child.isIssuer(cert);};/**
   * Generates the subjectKeyIdentifier for this certificate as byte buffer.
   *
   * @return the subjectKeyIdentifier for this certificate as byte buffer.
   */cert.generateSubjectKeyIdentifier=function(){/* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:

      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
        value of the BIT STRING subjectPublicKey (excluding the tag,
        length, and number of unused bits).

      (2) The keyIdentifier is composed of a four bit type field with
        the value 0100 followed by the least significant 60 bits of the
        SHA-1 hash of the value of the BIT STRING subjectPublicKey
        (excluding the tag, length, and number of unused bit string bits).
    */ // skipping the tag, length, and number of unused bits is the same
// as just using the RSAPublicKey (for RSA keys, which are the
// only ones supported)
return pki.getPublicKeyFingerprint(cert.publicKey,{type:'RSAPublicKey'});};/**
   * Verifies the subjectKeyIdentifier extension value for this certificate
   * against its public key. If no extension is found, false will be
   * returned.
   *
   * @return true if verified, false if not.
   */cert.verifySubjectKeyIdentifier=function(){var oid=oids['subjectKeyIdentifier'];for(var i=0;i<cert.extensions.length;++i){var ext=cert.extensions[i];if(ext.id===oid){var ski=cert.generateSubjectKeyIdentifier().getBytes();return forge.util.hexToBytes(ext.subjectKeyIdentifier)===ski;}}return false;};return cert;};/**
 * Converts an X.509v3 RSA certificate from an ASN.1 object.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
 * object needs to be scanned before the cert object is created.
 *
 * @param obj the asn1 representation of an X.509v3 RSA certificate.
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certificate.
 */pki.certificateFromAsn1=function(obj,computeHash){// validate certificate and capture data
var capture={};var errors=[];if(!asn1.validate(obj,x509CertificateValidator,capture,errors)){var error=new Error('Cannot read X.509 certificate. '+'ASN.1 object is not an X509v3 Certificate.');error.errors=errors;throw error;}// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){throw new Error('Cannot read public key. OID is not RSA.');}// create certificate
var cert=pki.createCertificate();cert.version=capture.certVersion?capture.certVersion.charCodeAt(0):0;var serial=forge.util.createBuffer(capture.certSerialNumber);cert.serialNumber=serial.toHex();cert.signatureOid=forge.asn1.derToOid(capture.certSignatureOid);cert.signatureParameters=_readSignatureParameters(cert.signatureOid,capture.certSignatureParams,true);cert.siginfo.algorithmOid=forge.asn1.derToOid(capture.certinfoSignatureOid);cert.siginfo.parameters=_readSignatureParameters(cert.siginfo.algorithmOid,capture.certinfoSignatureParams,false);cert.signature=capture.certSignature;var validity=[];if(capture.certValidity1UTCTime!==undefined){validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));}if(capture.certValidity2GeneralizedTime!==undefined){validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));}if(capture.certValidity3UTCTime!==undefined){validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));}if(capture.certValidity4GeneralizedTime!==undefined){validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));}if(validity.length>2){throw new Error('Cannot read notBefore/notAfter validity times; more '+'than two times were provided in the certificate.');}if(validity.length<2){throw new Error('Cannot read notBefore/notAfter validity times; they '+'were not provided as either UTCTime or GeneralizedTime.');}cert.validity.notBefore=validity[0];cert.validity.notAfter=validity[1];// keep TBSCertificate to preserve signature when exporting
cert.tbsCertificate=capture.tbsCertificate;if(computeHash){// check signature OID for supported signature types
cert.md=null;if(cert.signatureOid in oids){var oid=oids[cert.signatureOid];switch(oid){case'sha1WithRSAEncryption':cert.md=forge.md.sha1.create();break;case'md5WithRSAEncryption':cert.md=forge.md.md5.create();break;case'sha256WithRSAEncryption':cert.md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':cert.md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':cert.md=forge.md.sha512.create();break;case'RSASSA-PSS':cert.md=forge.md.sha256.create();break;}}if(cert.md===null){var error=new Error('Could not compute certificate digest. '+'Unknown signature OID.');error.signatureOid=cert.signatureOid;throw error;}// produce DER formatted TBSCertificate and digest it
var bytes=asn1.toDer(cert.tbsCertificate);cert.md.update(bytes.getBytes());}// handle issuer, build issuer message digest
var imd=forge.md.sha1.create();cert.issuer.getField=function(sn){return _getAttribute(cert.issuer,sn);};cert.issuer.addField=function(attr){_fillMissingFields([attr]);cert.issuer.attributes.push(attr);};cert.issuer.attributes=pki.RDNAttributesAsArray(capture.certIssuer,imd);if(capture.certIssuerUniqueId){cert.issuer.uniqueId=capture.certIssuerUniqueId;}cert.issuer.hash=imd.digest().toHex();// handle subject, build subject message digest
var smd=forge.md.sha1.create();cert.subject.getField=function(sn){return _getAttribute(cert.subject,sn);};cert.subject.addField=function(attr){_fillMissingFields([attr]);cert.subject.attributes.push(attr);};cert.subject.attributes=pki.RDNAttributesAsArray(capture.certSubject,smd);if(capture.certSubjectUniqueId){cert.subject.uniqueId=capture.certSubjectUniqueId;}cert.subject.hash=smd.digest().toHex();// handle extensions
if(capture.certExtensions){cert.extensions=pki.certificateExtensionsFromAsn1(capture.certExtensions);}else{cert.extensions=[];}// convert RSA public key from ASN.1
cert.publicKey=pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);return cert;};/**
 * Converts an ASN.1 extensions object (with extension sequences as its
 * values) into an array of extension objects with types and values.
 *
 * Supported extensions:
 *
 * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 * KeyUsage ::= BIT STRING {
 *   digitalSignature        (0),
 *   nonRepudiation          (1),
 *   keyEncipherment         (2),
 *   dataEncipherment        (3),
 *   keyAgreement            (4),
 *   keyCertSign             (5),
 *   cRLSign                 (6),
 *   encipherOnly            (7),
 *   decipherOnly            (8)
 * }
 *
 * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
 * BasicConstraints ::= SEQUENCE {
 *   cA                      BOOLEAN DEFAULT FALSE,
 *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
 * }
 *
 * subjectAltName EXTENSION ::= {
 *   SYNTAX GeneralNames
 *   IDENTIFIED BY id-ce-subjectAltName
 * }
 *
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 *
 * GeneralName ::= CHOICE {
 *   otherName      [0] INSTANCE OF OTHER-NAME,
 *   rfc822Name     [1] IA5String,
 *   dNSName        [2] IA5String,
 *   x400Address    [3] ORAddress,
 *   directoryName  [4] Name,
 *   ediPartyName   [5] EDIPartyName,
 *   uniformResourceIdentifier [6] IA5String,
 *   IPAddress      [7] OCTET STRING,
 *   registeredID   [8] OBJECT IDENTIFIER
 * }
 *
 * OTHER-NAME ::= TYPE-IDENTIFIER
 *
 * EDIPartyName ::= SEQUENCE {
 *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
 *   partyName    [1] DirectoryString {ub-name}
 * }
 *
 * @param exts the extensions ASN.1 with extension sequences to parse.
 *
 * @return the array.
 */pki.certificateExtensionsFromAsn1=function(exts){var rval=[];for(var i=0;i<exts.value.length;++i){// get extension sequence
var extseq=exts.value[i];for(var ei=0;ei<extseq.value.length;++ei){rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));}}return rval;};/**
 * Parses a single certificate extension from ASN.1.
 *
 * @param ext the extension in ASN.1 format.
 *
 * @return the parsed extension as an object.
 */pki.certificateExtensionFromAsn1=function(ext){// an extension has:
// [0] extnID      OBJECT IDENTIFIER
// [1] critical    BOOLEAN DEFAULT FALSE
// [2] extnValue   OCTET STRING
var e={};e.id=asn1.derToOid(ext.value[0].value);e.critical=false;if(ext.value[1].type===asn1.Type.BOOLEAN){e.critical=ext.value[1].value.charCodeAt(0)!==0x00;e.value=ext.value[2].value;}else{e.value=ext.value[1].value;}// if the oid is known, get its name
if(e.id in oids){e.name=oids[e.id];// handle key usage
if(e.name==='keyUsage'){// get value as BIT STRING
var ev=asn1.fromDer(e.value);var b2=0x00;var b3=0x00;if(ev.value.length>1){// skip first byte, just indicates unused bits which
// will be padded with 0s anyway
// get bytes with flag bits
b2=ev.value.charCodeAt(1);b3=ev.value.length>2?ev.value.charCodeAt(2):0;}// set flags
e.digitalSignature=(b2&0x80)===0x80;e.nonRepudiation=(b2&0x40)===0x40;e.keyEncipherment=(b2&0x20)===0x20;e.dataEncipherment=(b2&0x10)===0x10;e.keyAgreement=(b2&0x08)===0x08;e.keyCertSign=(b2&0x04)===0x04;e.cRLSign=(b2&0x02)===0x02;e.encipherOnly=(b2&0x01)===0x01;e.decipherOnly=(b3&0x80)===0x80;}else if(e.name==='basicConstraints'){// handle basic constraints
// get value as SEQUENCE
var ev=asn1.fromDer(e.value);// get cA BOOLEAN flag (defaults to false)
if(ev.value.length>0&&ev.value[0].type===asn1.Type.BOOLEAN){e.cA=ev.value[0].value.charCodeAt(0)!==0x00;}else{e.cA=false;}// get path length constraint
var value=null;if(ev.value.length>0&&ev.value[0].type===asn1.Type.INTEGER){value=ev.value[0].value;}else if(ev.value.length>1){value=ev.value[1].value;}if(value!==null){e.pathLenConstraint=asn1.derToInteger(value);}}else if(e.name==='extKeyUsage'){// handle extKeyUsage
// value is a SEQUENCE of OIDs
var ev=asn1.fromDer(e.value);for(var vi=0;vi<ev.value.length;++vi){var oid=asn1.derToOid(ev.value[vi].value);if(oid in oids){e[oids[oid]]=true;}else{e[oid]=true;}}}else if(e.name==='nsCertType'){// handle nsCertType
// get value as BIT STRING
var ev=asn1.fromDer(e.value);var b2=0x00;if(ev.value.length>1){// skip first byte, just indicates unused bits which
// will be padded with 0s anyway
// get bytes with flag bits
b2=ev.value.charCodeAt(1);}// set flags
e.client=(b2&0x80)===0x80;e.server=(b2&0x40)===0x40;e.email=(b2&0x20)===0x20;e.objsign=(b2&0x10)===0x10;e.reserved=(b2&0x08)===0x08;e.sslCA=(b2&0x04)===0x04;e.emailCA=(b2&0x02)===0x02;e.objCA=(b2&0x01)===0x01;}else if(e.name==='subjectAltName'||e.name==='issuerAltName'){// handle subjectAltName/issuerAltName
e.altNames=[];// ev is a SYNTAX SEQUENCE
var gn;var ev=asn1.fromDer(e.value);for(var n=0;n<ev.value.length;++n){// get GeneralName
gn=ev.value[n];var altName={type:gn.type,value:gn.value};e.altNames.push(altName);// Note: Support for types 1,2,6,7,8
switch(gn.type){// rfc822Name
case 1:// dNSName
case 2:// uniformResourceIdentifier (URI)
case 6:break;// IPAddress
case 7:// convert to IPv4/IPv6 string representation
altName.ip=forge.util.bytesToIP(gn.value);break;// registeredID
case 8:altName.oid=asn1.derToOid(gn.value);break;default:// unsupported
}}}else if(e.name==='subjectKeyIdentifier'){// value is an OCTETSTRING w/the hash of the key-type specific
// public key structure (eg: RSAPublicKey)
var ev=asn1.fromDer(e.value);e.subjectKeyIdentifier=forge.util.bytesToHex(ev.value);}}return e;};/**
 * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the CertificationRequestInfo part of the
 * ASN.1 object needs to be scanned before the csr object is created.
 *
 * @param obj the asn1 representation of a PKCS#10 certification request (CSR).
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certification request (CSR).
 */pki.certificationRequestFromAsn1=function(obj,computeHash){// validate certification request and capture data
var capture={};var errors=[];if(!asn1.validate(obj,certificationRequestValidator,capture,errors)){var error=new Error('Cannot read PKCS#10 certificate request. '+'ASN.1 object is not a PKCS#10 CertificationRequest.');error.errors=errors;throw error;}// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){throw new Error('Cannot read public key. OID is not RSA.');}// create certification request
var csr=pki.createCertificationRequest();csr.version=capture.csrVersion?capture.csrVersion.charCodeAt(0):0;csr.signatureOid=forge.asn1.derToOid(capture.csrSignatureOid);csr.signatureParameters=_readSignatureParameters(csr.signatureOid,capture.csrSignatureParams,true);csr.siginfo.algorithmOid=forge.asn1.derToOid(capture.csrSignatureOid);csr.siginfo.parameters=_readSignatureParameters(csr.siginfo.algorithmOid,capture.csrSignatureParams,false);csr.signature=capture.csrSignature;// keep CertificationRequestInfo to preserve signature when exporting
csr.certificationRequestInfo=capture.certificationRequestInfo;if(computeHash){// check signature OID for supported signature types
csr.md=null;if(csr.signatureOid in oids){var oid=oids[csr.signatureOid];switch(oid){case'sha1WithRSAEncryption':csr.md=forge.md.sha1.create();break;case'md5WithRSAEncryption':csr.md=forge.md.md5.create();break;case'sha256WithRSAEncryption':csr.md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':csr.md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':csr.md=forge.md.sha512.create();break;case'RSASSA-PSS':csr.md=forge.md.sha256.create();break;}}if(csr.md===null){var error=new Error('Could not compute certification request digest. '+'Unknown signature OID.');error.signatureOid=csr.signatureOid;throw error;}// produce DER formatted CertificationRequestInfo and digest it
var bytes=asn1.toDer(csr.certificationRequestInfo);csr.md.update(bytes.getBytes());}// handle subject, build subject message digest
var smd=forge.md.sha1.create();csr.subject.getField=function(sn){return _getAttribute(csr.subject,sn);};csr.subject.addField=function(attr){_fillMissingFields([attr]);csr.subject.attributes.push(attr);};csr.subject.attributes=pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject,smd);csr.subject.hash=smd.digest().toHex();// convert RSA public key from ASN.1
csr.publicKey=pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);// convert attributes from ASN.1
csr.getAttribute=function(sn){return _getAttribute(csr,sn);};csr.addAttribute=function(attr){_fillMissingFields([attr]);csr.attributes.push(attr);};csr.attributes=pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes||[]);return csr;};/**
 * Creates an empty certification request (a CSR or certificate signing
 * request). Once created, its public key and attributes can be set and then
 * it can be signed.
 *
 * @return the empty certification request.
 */pki.createCertificationRequest=function(){var csr={};csr.version=0x00;csr.signatureOid=null;csr.signature=null;csr.siginfo={};csr.siginfo.algorithmOid=null;csr.subject={};csr.subject.getField=function(sn){return _getAttribute(csr.subject,sn);};csr.subject.addField=function(attr){_fillMissingFields([attr]);csr.subject.attributes.push(attr);};csr.subject.attributes=[];csr.subject.hash=null;csr.publicKey=null;csr.attributes=[];csr.getAttribute=function(sn){return _getAttribute(csr,sn);};csr.addAttribute=function(attr){_fillMissingFields([attr]);csr.attributes.push(attr);};csr.md=null;/**
   * Sets the subject of this certification request.
   *
   * @param attrs the array of subject attributes to use.
   */csr.setSubject=function(attrs){// set new attributes
_fillMissingFields(attrs);csr.subject.attributes=attrs;csr.subject.hash=null;};/**
   * Sets the attributes of this certification request.
   *
   * @param attrs the array of attributes to use.
   */csr.setAttributes=function(attrs){// set new attributes
_fillMissingFields(attrs);csr.attributes=attrs;};/**
   * Signs this certification request using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */csr.sign=function(key,md){// TODO: get signature OID from private key
csr.md=md||forge.md.sha1.create();var algorithmOid=oids[csr.md.algorithm+'WithRSAEncryption'];if(!algorithmOid){var error=new Error('Could not compute certification request digest. '+'Unknown message digest algorithm OID.');error.algorithm=csr.md.algorithm;throw error;}csr.signatureOid=csr.siginfo.algorithmOid=algorithmOid;// get CertificationRequestInfo, convert to DER
csr.certificationRequestInfo=pki.getCertificationRequestInfo(csr);var bytes=asn1.toDer(csr.certificationRequestInfo);// digest and sign
csr.md.update(bytes.getBytes());csr.signature=key.sign(csr.md);};/**
   * Attempts verify the signature on the passed certification request using
   * its public key.
   *
   * A CSR that has been exported to a file in PEM format can be verified using
   * OpenSSL using this command:
   *
   * openssl req -in <the-csr-pem-file> -verify -noout -text
   *
   * @return true if verified, false if not.
   */csr.verify=function(){var rval=false;var md=csr.md;if(md===null){// check signature OID for supported signature types
if(csr.signatureOid in oids){// TODO: create DRY `OID to md` function
var oid=oids[csr.signatureOid];switch(oid){case'sha1WithRSAEncryption':md=forge.md.sha1.create();break;case'md5WithRSAEncryption':md=forge.md.md5.create();break;case'sha256WithRSAEncryption':md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':md=forge.md.sha512.create();break;case'RSASSA-PSS':md=forge.md.sha256.create();break;}}if(md===null){var error=new Error('Could not compute certification request digest. '+'Unknown signature OID.');error.signatureOid=csr.signatureOid;throw error;}// produce DER formatted CertificationRequestInfo and digest it
var cri=csr.certificationRequestInfo||pki.getCertificationRequestInfo(csr);var bytes=asn1.toDer(cri);md.update(bytes.getBytes());}if(md!==null){var scheme;switch(csr.signatureOid){case oids.sha1WithRSAEncryption:/* use PKCS#1 v1.5 padding scheme */break;case oids['RSASSA-PSS']:var hash,mgf;/* initialize mgf */hash=oids[csr.signatureParameters.mgf.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported MGF hash function.');error.oid=csr.signatureParameters.mgf.hash.algorithmOid;error.name=hash;throw error;}mgf=oids[csr.signatureParameters.mgf.algorithmOid];if(mgf===undefined||forge.mgf[mgf]===undefined){var error=new Error('Unsupported MGF function.');error.oid=csr.signatureParameters.mgf.algorithmOid;error.name=mgf;throw error;}mgf=forge.mgf[mgf].create(forge.md[hash].create());/* initialize hash function */hash=oids[csr.signatureParameters.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported RSASSA-PSS hash function.');error.oid=csr.signatureParameters.hash.algorithmOid;error.name=hash;throw error;}scheme=forge.pss.create(forge.md[hash].create(),mgf,csr.signatureParameters.saltLength);break;}// verify signature on csr using its public key
rval=csr.publicKey.verify(md.digest().getBytes(),csr.signature,scheme);}return rval;};return csr;};/**
 * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
 *
 * @param obj the subject or issuer (distinguished name).
 *
 * @return the ASN.1 RDNSequence.
 */function _dnToAsn1(obj){// create an empty RDNSequence
var rval=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// iterate over attributes
var attr,set;var attrs=obj.attributes;for(var i=0;i<attrs.length;++i){attr=attrs[i];var value=attr.value;// reuse tag class for attribute value if available
var valueTagClass=asn1.Type.PRINTABLESTRING;if('valueTagClass'in attr){valueTagClass=attr.valueTagClass;if(valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(value);}// FIXME: handle more encodings
}// create a RelativeDistinguishedName set
// each value in the set is an AttributeTypeAndValue first
// containing the type (an OID) and second the value
set=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AttributeType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(attr.type).getBytes()),// AttributeValue
asn1.create(asn1.Class.UNIVERSAL,valueTagClass,false,value)])]);rval.value.push(set);}return rval;}/**
 * Gets all printable attributes (typically of an issuer or subject) in a
 * simplified JSON format for display.
 *
 * @param attrs the attributes.
 *
 * @return the JSON for display.
 */function _getAttributesAsJson(attrs){var rval={};for(var i=0;i<attrs.length;++i){var attr=attrs[i];if(attr.shortName&&(attr.valueTagClass===asn1.Type.UTF8||attr.valueTagClass===asn1.Type.PRINTABLESTRING||attr.valueTagClass===asn1.Type.IA5STRING)){var value=attr.value;if(attr.valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(attr.value);}if(!(attr.shortName in rval)){rval[attr.shortName]=value;}else if(forge.util.isArray(rval[attr.shortName])){rval[attr.shortName].push(value);}else{rval[attr.shortName]=[rval[attr.shortName],value];}}}return rval;}/**
 * Fills in missing fields in attributes.
 *
 * @param attrs the attributes to fill missing fields in.
 */function _fillMissingFields(attrs){var attr;for(var i=0;i<attrs.length;++i){attr=attrs[i];// populate missing name
if(typeof attr.name==='undefined'){if(attr.type&&attr.type in pki.oids){attr.name=pki.oids[attr.type];}else if(attr.shortName&&attr.shortName in _shortNames){attr.name=pki.oids[_shortNames[attr.shortName]];}}// populate missing type (OID)
if(typeof attr.type==='undefined'){if(attr.name&&attr.name in pki.oids){attr.type=pki.oids[attr.name];}else{var error=new Error('Attribute type not specified.');error.attribute=attr;throw error;}}// populate missing shortname
if(typeof attr.shortName==='undefined'){if(attr.name&&attr.name in _shortNames){attr.shortName=_shortNames[attr.name];}}// convert extensions to value
if(attr.type===oids.extensionRequest){attr.valueConstructed=true;attr.valueTagClass=asn1.Type.SEQUENCE;if(!attr.value&&attr.extensions){attr.value=[];for(var ei=0;ei<attr.extensions.length;++ei){attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));}}}if(typeof attr.value==='undefined'){var error=new Error('Attribute value not specified.');error.attribute=attr;throw error;}}}/**
 * Fills in missing fields in certificate extensions.
 *
 * @param e the extension.
 * @param [options] the options to use.
 *          [cert] the certificate the extensions are for.
 *
 * @return the extension.
 */function _fillMissingExtensionFields(e,options){options=options||{};// populate missing name
if(typeof e.name==='undefined'){if(e.id&&e.id in pki.oids){e.name=pki.oids[e.id];}}// populate missing id
if(typeof e.id==='undefined'){if(e.name&&e.name in pki.oids){e.id=pki.oids[e.name];}else{var error=new Error('Extension ID not specified.');error.extension=e;throw error;}}if(typeof e.value!=='undefined'){return e;}// handle missing value:
// value is a BIT STRING
if(e.name==='keyUsage'){// build flags
var unused=0;var b2=0x00;var b3=0x00;if(e.digitalSignature){b2|=0x80;unused=7;}if(e.nonRepudiation){b2|=0x40;unused=6;}if(e.keyEncipherment){b2|=0x20;unused=5;}if(e.dataEncipherment){b2|=0x10;unused=4;}if(e.keyAgreement){b2|=0x08;unused=3;}if(e.keyCertSign){b2|=0x04;unused=2;}if(e.cRLSign){b2|=0x02;unused=1;}if(e.encipherOnly){b2|=0x01;unused=0;}if(e.decipherOnly){b3|=0x80;unused=7;}// create bit string
var value=String.fromCharCode(unused);if(b3!==0){value+=String.fromCharCode(b2)+String.fromCharCode(b3);}else if(b2!==0){value+=String.fromCharCode(b2);}e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,value);}else if(e.name==='basicConstraints'){// basicConstraints is a SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// cA BOOLEAN flag defaults to false
if(e.cA){e.value.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BOOLEAN,false,String.fromCharCode(0xFF)));}if('pathLenConstraint'in e){e.value.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(e.pathLenConstraint).getBytes()));}}else if(e.name==='extKeyUsage'){// extKeyUsage is a SEQUENCE of OIDs
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;for(var key in e){if(e[key]!==true){continue;}// key is name in OID map
if(key in oids){seq.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids[key]).getBytes()));}else if(key.indexOf('.')!==-1){// assume key is an OID
seq.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(key).getBytes()));}}}else if(e.name==='nsCertType'){// nsCertType is a BIT STRING
// build flags
var unused=0;var b2=0x00;if(e.client){b2|=0x80;unused=7;}if(e.server){b2|=0x40;unused=6;}if(e.email){b2|=0x20;unused=5;}if(e.objsign){b2|=0x10;unused=4;}if(e.reserved){b2|=0x08;unused=3;}if(e.sslCA){b2|=0x04;unused=2;}if(e.emailCA){b2|=0x02;unused=1;}if(e.objCA){b2|=0x01;unused=0;}// create bit string
var value=String.fromCharCode(unused);if(b2!==0){value+=String.fromCharCode(b2);}e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,value);}else if(e.name==='subjectAltName'||e.name==='issuerAltName'){// SYNTAX SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var altName;for(var n=0;n<e.altNames.length;++n){altName=e.altNames[n];var value=altName.value;// handle IP
if(altName.type===7&&altName.ip){value=forge.util.bytesFromIP(altName.ip);if(value===null){var error=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');error.extension=e;throw error;}}else if(altName.type===8){// handle OID
if(altName.oid){value=asn1.oidToDer(asn1.oidToDer(altName.oid));}else{// deprecated ... convert value to OID
value=asn1.oidToDer(value);}}e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,altName.type,false,value));}}else if(e.name==='subjectKeyIdentifier'&&options.cert){var ski=options.cert.generateSubjectKeyIdentifier();e.subjectKeyIdentifier=ski.toHex();// OCTETSTRING w/digest
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,ski.getBytes());}else if(e.name==='authorityKeyIdentifier'&&options.cert){// SYNTAX SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;if(e.keyIdentifier){var keyIdentifier=e.keyIdentifier===true?options.cert.generateSubjectKeyIdentifier().getBytes():e.keyIdentifier;seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,false,keyIdentifier));}if(e.authorityCertIssuer){var authorityCertIssuer=[asn1.create(asn1.Class.CONTEXT_SPECIFIC,4,true,[_dnToAsn1(e.authorityCertIssuer===true?options.cert.issuer:e.authorityCertIssuer)])];seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,authorityCertIssuer));}if(e.serialNumber){var serialNumber=forge.util.hexToBytes(e.serialNumber===true?options.cert.serialNumber:e.serialNumber);seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,false,serialNumber));}}else if(e.name==='cRLDistributionPoints'){e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;// Create sub SEQUENCE of DistributionPointName
var subSeq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// Create fullName CHOICE
var fullNameGeneralNames=asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[]);var altName;for(var n=0;n<e.altNames.length;++n){altName=e.altNames[n];var value=altName.value;// handle IP
if(altName.type===7&&altName.ip){value=forge.util.bytesFromIP(altName.ip);if(value===null){var error=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');error.extension=e;throw error;}}else if(altName.type===8){// handle OID
if(altName.oid){value=asn1.oidToDer(asn1.oidToDer(altName.oid));}else{// deprecated ... convert value to OID
value=asn1.oidToDer(value);}}fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,altName.type,false,value));}// Add to the parent SEQUENCE
subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[fullNameGeneralNames]));seq.push(subSeq);}// ensure value has been defined by now
if(typeof e.value==='undefined'){var error=new Error('Extension value not specified.');error.extension=e;throw error;}return e;}/**
 * Convert signature parameters object to ASN.1
 *
 * @param {String} oid Signature algorithm OID
 * @param params The signature parametrs object
 * @return ASN.1 object representing signature parameters
 */function _signatureParametersToAsn1(oid,params){switch(oid){case oids['RSASSA-PSS']:var parts=[];if(params.hash.algorithmOid!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.hash.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')])]));}if(params.mgf.algorithmOid!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.mgf.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')])])]));}if(params.saltLength!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(params.saltLength).getBytes())]));}return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,parts);default:return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'');}}/**
 * Converts a certification request's attributes to an ASN.1 set of
 * CRIAttributes.
 *
 * @param csr certification request.
 *
 * @return the ASN.1 set of CRIAttributes.
 */function _CRIAttributesToAsn1(csr){// create an empty context-specific container
var rval=asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[]);// no attributes, return empty container
if(csr.attributes.length===0){return rval;}// each attribute has a sequence with a type and a set of values
var attrs=csr.attributes;for(var i=0;i<attrs.length;++i){var attr=attrs[i];var value=attr.value;// reuse tag class for attribute value if available
var valueTagClass=asn1.Type.UTF8;if('valueTagClass'in attr){valueTagClass=attr.valueTagClass;}if(valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(value);}var valueConstructed=false;if('valueConstructed'in attr){valueConstructed=attr.valueConstructed;}// FIXME: handle more encodings
// create a RelativeDistinguishedName set
// each value in the set is an AttributeTypeAndValue first
// containing the type (an OID) and second the value
var seq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AttributeType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(attr.type).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[// AttributeValue
asn1.create(asn1.Class.UNIVERSAL,valueTagClass,valueConstructed,value)])]);rval.value.push(seq);}return rval;}var jan_1_1950=new Date('1950-01-01T00:00:00Z');var jan_1_2050=new Date('2050-01-01T00:00:00Z');/**
 * Converts a Date object to ASN.1
 * Handles the different format before and after 1st January 2050
 *
 * @param date date object.
 *
 * @return the ASN.1 object representing the date.
 */function _dateToAsn1(date){if(date>=jan_1_1950&&date<jan_1_2050){return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.UTCTIME,false,asn1.dateToUtcTime(date));}else{return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.GENERALIZEDTIME,false,asn1.dateToGeneralizedTime(date));}}/**
 * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
 *
 * @param cert the certificate.
 *
 * @return the asn1 TBSCertificate.
 */pki.getTBSCertificate=function(cert){// TBSCertificate
var notBefore=_dateToAsn1(cert.validity.notBefore);var notAfter=_dateToAsn1(cert.validity.notAfter);var tbs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// integer
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(cert.version).getBytes())]),// serialNumber
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,forge.util.hexToBytes(cert.serialNumber)),// signature
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),// parameters
_signatureParametersToAsn1(cert.siginfo.algorithmOid,cert.siginfo.parameters)]),// issuer
_dnToAsn1(cert.issuer),// validity
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[notBefore,notAfter]),// subject
_dnToAsn1(cert.subject),// SubjectPublicKeyInfo
pki.publicKeyToAsn1(cert.publicKey)]);if(cert.issuer.uniqueId){// issuerUniqueID (optional)
tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,// TODO: support arbitrary bit length ids
String.fromCharCode(0x00)+cert.issuer.uniqueId)]));}if(cert.subject.uniqueId){// subjectUniqueID (optional)
tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,// TODO: support arbitrary bit length ids
String.fromCharCode(0x00)+cert.subject.uniqueId)]));}if(cert.extensions.length>0){// extensions (optional)
tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));}return tbs;};/**
 * Gets the ASN.1 CertificationRequestInfo part of a
 * PKCS#10 CertificationRequest.
 *
 * @param csr the certification request.
 *
 * @return the asn1 CertificationRequestInfo.
 */pki.getCertificationRequestInfo=function(csr){// CertificationRequestInfo
var cri=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(csr.version).getBytes()),// subject
_dnToAsn1(csr.subject),// SubjectPublicKeyInfo
pki.publicKeyToAsn1(csr.publicKey),// attributes
_CRIAttributesToAsn1(csr)]);return cri;};/**
 * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
 *
 * @param dn the DistinguishedName.
 *
 * @return the asn1 representation of a DistinguishedName.
 */pki.distinguishedNameToAsn1=function(dn){return _dnToAsn1(dn);};/**
 * Converts an X.509v3 RSA certificate to an ASN.1 object.
 *
 * @param cert the certificate.
 *
 * @return the asn1 representation of an X.509v3 RSA certificate.
 */pki.certificateToAsn1=function(cert){// prefer cached TBSCertificate over generating one
var tbsCertificate=cert.tbsCertificate||pki.getTBSCertificate(cert);// Certificate
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// TBSCertificate
tbsCertificate,// AlgorithmIdentifier (signature algorithm)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(cert.signatureOid).getBytes()),// parameters
_signatureParametersToAsn1(cert.signatureOid,cert.signatureParameters)]),// SignatureValue
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,String.fromCharCode(0x00)+cert.signature)]);};/**
 * Converts X.509v3 certificate extensions to ASN.1.
 *
 * @param exts the extensions to convert.
 *
 * @return the extensions in ASN.1 format.
 */pki.certificateExtensionsToAsn1=function(exts){// create top-level extension container
var rval=asn1.create(asn1.Class.CONTEXT_SPECIFIC,3,true,[]);// create extension sequence (stores a sequence for each extension)
var seq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);rval.value.push(seq);for(var i=0;i<exts.length;++i){seq.value.push(pki.certificateExtensionToAsn1(exts[i]));}return rval;};/**
 * Converts a single certificate extension to ASN.1.
 *
 * @param ext the extension to convert.
 *
 * @return the extension in ASN.1 format.
 */pki.certificateExtensionToAsn1=function(ext){// create a sequence for each extension
var extseq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// extnID (OID)
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(ext.id).getBytes()));// critical defaults to false
if(ext.critical){// critical BOOLEAN DEFAULT FALSE
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BOOLEAN,false,String.fromCharCode(0xFF)));}var value=ext.value;if(typeof ext.value!=='string'){// value is asn.1
value=asn1.toDer(value).getBytes();}// extnValue (OCTET STRING)
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,value));return extseq;};/**
 * Converts a PKCS#10 certification request to an ASN.1 object.
 *
 * @param csr the certification request.
 *
 * @return the asn1 representation of a certification request.
 */pki.certificationRequestToAsn1=function(csr){// prefer cached CertificationRequestInfo over generating one
var cri=csr.certificationRequestInfo||pki.getCertificationRequestInfo(csr);// Certificate
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// CertificationRequestInfo
cri,// AlgorithmIdentifier (signature algorithm)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(csr.signatureOid).getBytes()),// parameters
_signatureParametersToAsn1(csr.signatureOid,csr.signatureParameters)]),// signature
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,String.fromCharCode(0x00)+csr.signature)]);};/**
 * Creates a CA store.
 *
 * @param certs an optional array of certificate objects or PEM-formatted
 *          certificate strings to add to the CA store.
 *
 * @return the CA store.
 */pki.createCaStore=function(certs){// create CA store
var caStore={// stored certificates
certs:{}};/**
   * Gets the certificate that issued the passed certificate or its
   * 'parent'.
   *
   * @param cert the certificate to get the parent for.
   *
   * @return the parent certificate or null if none was found.
   */caStore.getIssuer=function(cert){var rval=getBySubject(cert.issuer);// see if there are multiple matches
/*if(forge.util.isArray(rval)) {
      // TODO: resolve multiple matches by checking
      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.
      // FIXME: or alternatively do authority key mapping
      // if possible (X.509v1 certs can't work?)
      throw new Error('Resolving multiple issuer matches not implemented yet.');
    }*/return rval;};/**
   * Adds a trusted certificate to the store.
   *
   * @param cert the certificate to add as a trusted certificate (either a
   *          pki.certificate object or a PEM-formatted certificate).
   */caStore.addCertificate=function(cert){// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}ensureSubjectHasHash(cert.subject);if(!caStore.hasCertificate(cert)){// avoid duplicate certificates in store
if(cert.subject.hash in caStore.certs){// subject hash already exists, append to array
var tmp=caStore.certs[cert.subject.hash];if(!forge.util.isArray(tmp)){tmp=[tmp];}tmp.push(cert);caStore.certs[cert.subject.hash]=tmp;}else{caStore.certs[cert.subject.hash]=cert;}}};/**
   * Checks to see if the given certificate is in the store.
   *
   * @param cert the certificate to check (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return true if the certificate is in the store, false if not.
   */caStore.hasCertificate=function(cert){// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}var match=getBySubject(cert.subject);if(!match){return false;}if(!forge.util.isArray(match)){match=[match];}// compare DER-encoding of certificates
var der1=asn1.toDer(pki.certificateToAsn1(cert)).getBytes();for(var i=0;i<match.length;++i){var der2=asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();if(der1===der2){return true;}}return false;};/**
   * Lists all of the certificates kept in the store.
   *
   * @return an array of all of the pki.certificate objects in the store.
   */caStore.listAllCertificates=function(){var certList=[];for(var hash in caStore.certs){if(caStore.certs.hasOwnProperty(hash)){var value=caStore.certs[hash];if(!forge.util.isArray(value)){certList.push(value);}else{for(var i=0;i<value.length;++i){certList.push(value[i]);}}}}return certList;};/**
   * Removes a certificate from the store.
   *
   * @param cert the certificate to remove (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return the certificate that was removed or null if the certificate
   *           wasn't in store.
   */caStore.removeCertificate=function(cert){var result;// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}ensureSubjectHasHash(cert.subject);if(!caStore.hasCertificate(cert)){return null;}var match=getBySubject(cert.subject);if(!forge.util.isArray(match)){result=caStore.certs[cert.subject.hash];delete caStore.certs[cert.subject.hash];return result;}// compare DER-encoding of certificates
var der1=asn1.toDer(pki.certificateToAsn1(cert)).getBytes();for(var i=0;i<match.length;++i){var der2=asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();if(der1===der2){result=match[i];match.splice(i,1);}}if(match.length===0){delete caStore.certs[cert.subject.hash];}return result;};function getBySubject(subject){ensureSubjectHasHash(subject);return caStore.certs[subject.hash]||null;}function ensureSubjectHasHash(subject){// produce subject hash if it doesn't exist
if(!subject.hash){var md=forge.md.sha1.create();subject.attributes=pki.RDNAttributesAsArray(_dnToAsn1(subject),md);subject.hash=md.digest().toHex();}}// auto-add passed in certs
if(certs){// parse PEM-formatted certificates as necessary
for(var i=0;i<certs.length;++i){var cert=certs[i];caStore.addCertificate(cert);}}return caStore;};/**
 * Certificate verification errors, based on TLS.
 */pki.certificateError={bad_certificate:'forge.pki.BadCertificate',unsupported_certificate:'forge.pki.UnsupportedCertificate',certificate_revoked:'forge.pki.CertificateRevoked',certificate_expired:'forge.pki.CertificateExpired',certificate_unknown:'forge.pki.CertificateUnknown',unknown_ca:'forge.pki.UnknownCertificateAuthority'};/**
 * Verifies a certificate chain against the given Certificate Authority store
 * with an optional custom verify callback.
 *
 * @param caStore a certificate store to verify against.
 * @param chain the certificate chain to verify, with the root or highest
 *          authority at the end (an array of certificates).
 * @param verify called for every certificate in the chain.
 *
 * The verify callback has the following signature:
 *
 * verified - Set to true if certificate was verified, otherwise the
 *   pki.certificateError for why the certificate failed.
 * depth - The current index in the chain, where 0 is the end point's cert.
 * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
 *   end point.
 *
 * The function returns true on success and on failure either the appropriate
 * pki.certificateError or an object with 'error' set to the appropriate
 * pki.certificateError and 'message' set to a custom error message.
 *
 * @return true if successful, error thrown if not.
 */pki.verifyCertificateChain=function(caStore,chain,verify){/* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate
    Section 6: Certification Path Validation
    See inline parentheticals related to this particular implementation.

    The primary goal of path validation is to verify the binding between
    a subject distinguished name or a subject alternative name and subject
    public key, as represented in the end entity certificate, based on the
    public key of the trust anchor. This requires obtaining a sequence of
    certificates that support that binding. That sequence should be provided
    in the passed 'chain'. The trust anchor should be in the given CA
    store. The 'end entity' certificate is the certificate provided by the
    end point (typically a server) and is the first in the chain.

    To meet this goal, the path validation process verifies, among other
    things, that a prospective certification path (a sequence of n
    certificates or a 'chain') satisfies the following conditions:

    (a) for all x in {1, ..., n-1}, the subject of certificate x is
          the issuer of certificate x+1;

    (b) certificate 1 is issued by the trust anchor;

    (c) certificate n is the certificate to be validated; and

    (d) for all x in {1, ..., n}, the certificate was valid at the
          time in question.

    Note that here 'n' is index 0 in the chain and 1 is the last certificate
    in the chain and it must be signed by a certificate in the connection's
    CA store.

    The path validation process also determines the set of certificate
    policies that are valid for this path, based on the certificate policies
    extension, policy mapping extension, policy constraints extension, and
    inhibit any-policy extension.

    Note: Policy mapping extension not supported (Not Required).

    Note: If the certificate has an unsupported critical extension, then it
    must be rejected.

    Note: A certificate is self-issued if the DNs that appear in the subject
    and issuer fields are identical and are not empty.

    The path validation algorithm assumes the following seven inputs are
    provided to the path processing logic. What this specific implementation
    will use is provided parenthetically:

    (a) a prospective certification path of length n (the 'chain')
    (b) the current date/time: ('now').
    (c) user-initial-policy-set: A set of certificate policy identifiers
          naming the policies that are acceptable to the certificate user.
          The user-initial-policy-set contains the special value any-policy
          if the user is not concerned about certificate policy
          (Not implemented. Any policy is accepted).
    (d) trust anchor information, describing a CA that serves as a trust
          anchor for the certification path. The trust anchor information
          includes:

      (1)  the trusted issuer name,
      (2)  the trusted public key algorithm,
      (3)  the trusted public key, and
      (4)  optionally, the trusted public key parameters associated
             with the public key.

      (Trust anchors are provided via certificates in the CA store).

      The trust anchor information may be provided to the path processing
      procedure in the form of a self-signed certificate. The trusted anchor
      information is trusted because it was delivered to the path processing
      procedure by some trustworthy out-of-band procedure. If the trusted
      public key algorithm requires parameters, then the parameters are
      provided along with the trusted public key (No parameters used in this
      implementation).

    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is
          allowed in the certification path.
          (Not implemented, no policy checking)

    (f) initial-explicit-policy, which indicates if the path must be valid
          for at least one of the certificate policies in the user-initial-
          policy-set.
          (Not implemented, no policy checking)

    (g) initial-any-policy-inhibit, which indicates whether the
          anyPolicy OID should be processed if it is included in a
          certificate.
          (Not implemented, so any policy is valid provided that it is
          not marked as critical) */ /* Basic Path Processing:

    For each certificate in the 'chain', the following is checked:

    1. The certificate validity period includes the current time.
    2. The certificate was signed by its parent (where the parent is either
       the next in the chain or from the CA store). Allow processing to
       continue to the next step if no parent is found but the certificate is
       in the CA store.
    3. TODO: The certificate has not been revoked.
    4. The certificate issuer name matches the parent's subject name.
    5. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is within one of the permitted subtrees of X.500 distinguished names
       and that each of the alternative names in the subjectAltName extension
       (critical or non-critical) is within one of the permitted subtrees for
       that name type.
    6. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is not within one of the excluded subtrees for X.500 distinguished
       names and none of the subjectAltName extension names are excluded for
       that name type.
    7. The other steps in the algorithm for basic path processing involve
       handling the policy extension which is not presently supported in this
       implementation. Instead, if a critical policy extension is found, the
       certificate is rejected as not supported.
    8. If the certificate is not the first or if its the only certificate in
       the chain (having no parent from the CA store or is self-signed) and it
       has a critical key usage extension, verify that the keyCertSign bit is
       set. If the key usage extension exists, verify that the basic
       constraints extension exists. If the basic constraints extension exists,
       verify that the cA flag is set. If pathLenConstraint is set, ensure that
       the number of certificates that precede in the chain (come earlier
       in the chain as implemented below), excluding the very first in the
       chain (typically the end-entity one), isn't greater than the
       pathLenConstraint. This constraint limits the number of intermediate
       CAs that may appear below a CA before only end-entity certificates
       may be issued. */ // copy cert chain references to another array to protect against changes
// in verify callback
chain=chain.slice(0);var certs=chain.slice(0);// get current date
var now=new Date();// verify each cert in the chain using its parent, where the parent
// is either the next in the chain or from the CA store
var first=true;var error=null;var depth=0;do{var cert=chain.shift();var parent=null;var selfSigned=false;// 1. check valid time
if(now<cert.validity.notBefore||now>cert.validity.notAfter){error={message:'Certificate is not valid yet or has expired.',error:pki.certificateError.certificate_expired,notBefore:cert.validity.notBefore,notAfter:cert.validity.notAfter,now:now};}// 2. verify with parent from chain or CA store
if(error===null){parent=chain[0]||caStore.getIssuer(cert);if(parent===null){// check for self-signed cert
if(cert.isIssuer(cert)){selfSigned=true;parent=cert;}}if(parent){// FIXME: current CA store implementation might have multiple
// certificates where the issuer can't be determined from the
// certificate (happens rarely with, eg: old certificates) so normalize
// by always putting parents into an array
// TODO: there's may be an extreme degenerate case currently uncovered
// where an old intermediate certificate seems to have a matching parent
// but none of the parents actually verify ... but the intermediate
// is in the CA and it should pass this check; needs investigation
var parents=parent;if(!forge.util.isArray(parents)){parents=[parents];}// try to verify with each possible parent (typically only one)
var verified=false;while(!verified&&parents.length>0){parent=parents.shift();try{verified=parent.verify(cert);}catch(ex){// failure to verify, don't care why, try next one
}}if(!verified){error={message:'Certificate signature is invalid.',error:pki.certificateError.bad_certificate};}}if(error===null&&(!parent||selfSigned)&&!caStore.hasCertificate(cert)){// no parent issuer and certificate itself is not trusted
error={message:'Certificate is not trusted.',error:pki.certificateError.unknown_ca};}}// TODO: 3. check revoked
// 4. check for matching issuer/subject
if(error===null&&parent&&!cert.isIssuer(parent)){// parent is not issuer
error={message:'Certificate issuer is invalid.',error:pki.certificateError.bad_certificate};}// 5. TODO: check names with permitted names tree
// 6. TODO: check names against excluded names tree
// 7. check for unsupported critical extensions
if(error===null){// supported extensions
var se={keyUsage:true,basicConstraints:true};for(var i=0;error===null&&i<cert.extensions.length;++i){var ext=cert.extensions[i];if(ext.critical&&!(ext.name in se)){error={message:'Certificate has an unsupported critical extension.',error:pki.certificateError.unsupported_certificate};}}}// 8. check for CA if cert is not first or is the only certificate
// remaining in chain with no parent or is self-signed
if(error===null&&(!first||chain.length===0&&(!parent||selfSigned))){// first check keyUsage extension and then basic constraints
var bcExt=cert.getExtension('basicConstraints');var keyUsageExt=cert.getExtension('keyUsage');if(keyUsageExt!==null){// keyCertSign must be true and there must be a basic
// constraints extension
if(!keyUsageExt.keyCertSign||bcExt===null){// bad certificate
error={message:'Certificate keyUsage or basicConstraints conflict '+'or indicate that the certificate is not a CA. '+'If the certificate is the only one in the chain or '+'isn\'t the first then the certificate must be a '+'valid CA.',error:pki.certificateError.bad_certificate};}}// basic constraints cA flag must be set
if(error===null&&bcExt!==null&&!bcExt.cA){// bad certificate
error={message:'Certificate basicConstraints indicates the certificate '+'is not a CA.',error:pki.certificateError.bad_certificate};}// if error is not null and keyUsage is available, then we know it
// has keyCertSign and there is a basic constraints extension too,
// which means we can check pathLenConstraint (if it exists)
if(error===null&&keyUsageExt!==null&&'pathLenConstraint'in bcExt){// pathLen is the maximum # of intermediate CA certs that can be
// found between the current certificate and the end-entity (depth 0)
// certificate; this number does not include the end-entity (depth 0,
// last in the chain) even if it happens to be a CA certificate itself
var pathLen=depth-1;if(pathLen>bcExt.pathLenConstraint){// pathLenConstraint violated, bad certificate
error={message:'Certificate basicConstraints pathLenConstraint violated.',error:pki.certificateError.bad_certificate};}}}// call application callback
var vfd=error===null?true:error.error;var ret=verify?verify(vfd,depth,certs):vfd;if(ret===true){// clear any set error
error=null;}else{// if passed basic tests, set default message and alert
if(vfd===true){error={message:'The application rejected the certificate.',error:pki.certificateError.bad_certificate};}// check for custom error info
if(ret||ret===0){// set custom message and error
if(_typeof(ret)==='object'&&!forge.util.isArray(ret)){if(ret.message){error.message=ret.message;}if(ret.error){error.error=ret.error;}}else if(typeof ret==='string'){// set custom error
error.error=ret;}}// throw error
throw error;}// no longer first cert in chain
first=false;++depth;}while(chain.length>0);return true;};/***/},/* 19 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of PKCS#1 PSS signature padding.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 */var forge=__webpack_require__(0);__webpack_require__(5);__webpack_require__(1);// shortcut for PSS API
var pss=module.exports=forge.pss=forge.pss||{};/**
 * Creates a PSS signature scheme object.
 *
 * There are several ways to provide a salt for encoding:
 *
 * 1. Specify the saltLength only and the built-in PRNG will generate it.
 * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
 *   will be used.
 * 3. Specify the salt itself as a forge.util.ByteBuffer.
 *
 * @param options the options to use:
 *          md the message digest object to use, a forge md instance.
 *          mgf the mask generation function to use, a forge mgf instance.
 *          [saltLength] the length of the salt in octets.
 *          [prng] the pseudo-random number generator to use to produce a salt.
 *          [salt] the salt to use when encoding.
 *
 * @return a signature scheme object.
 */pss.create=function(options){// backwards compatibility w/legacy args: hash, mgf, sLen
if(arguments.length===3){options={md:arguments[0],mgf:arguments[1],saltLength:arguments[2]};}var hash=options.md;var mgf=options.mgf;var hLen=hash.digestLength;var salt_=options.salt||null;if(typeof salt_==='string'){// assume binary-encoded string
salt_=forge.util.createBuffer(salt_);}var sLen;if('saltLength'in options){sLen=options.saltLength;}else if(salt_!==null){sLen=salt_.length();}else{throw new Error('Salt length not specified or specific salt not given.');}if(salt_!==null&&salt_.length()!==sLen){throw new Error('Given salt length does not match length of given salt.');}var prng=options.prng||forge.random;var pssobj={};/**
   * Encodes a PSS signature.
   *
   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
   *
   * @param md the message digest object with the hash to sign.
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return the encoded message as a binary-encoded string of length
   *           ceil((modBits - 1) / 8).
   */pssobj.encode=function(md,modBits){var i;var emBits=modBits-1;var emLen=Math.ceil(emBits/8);/* 2. Let mHash = Hash(M), an octet string of length hLen. */var mHash=md.digest().getBytes();/* 3. If emLen < hLen + sLen + 2, output "encoding error" and stop. */if(emLen<hLen+sLen+2){throw new Error('Message is too long to encrypt.');}/* 4. Generate a random octet string salt of length sLen; if sLen = 0,
     *    then salt is the empty string. */var salt;if(salt_===null){salt=prng.getBytesSync(sLen);}else{salt=salt_.bytes();}/* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */var m_=new forge.util.ByteBuffer();m_.fillWithByte(0,8);m_.putBytes(mHash);m_.putBytes(salt);/* 6. Let H = Hash(M'), an octet string of length hLen. */hash.start();hash.update(m_.getBytes());var h=hash.digest().getBytes();/* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
     *    zero octets.  The length of PS may be 0. */var ps=new forge.util.ByteBuffer();ps.fillWithByte(0,emLen-sLen-hLen-2);/* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length
     *    emLen - hLen - 1. */ps.putByte(0x01);ps.putBytes(salt);var db=ps.getBytes();/* 9. Let dbMask = MGF(H, emLen - hLen - 1). */var maskLen=emLen-hLen-1;var dbMask=mgf.generate(h,maskLen);/* 10. Let maskedDB = DB \xor dbMask. */var maskedDB='';for(i=0;i<maskLen;i++){maskedDB+=String.fromCharCode(db.charCodeAt(i)^dbMask.charCodeAt(i));}/* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
     *     maskedDB to zero. */var mask=0xFF00>>8*emLen-emBits&0xFF;maskedDB=String.fromCharCode(maskedDB.charCodeAt(0)&~mask)+maskedDB.substr(1);/* 12. Let EM = maskedDB || H || 0xbc.
     * 13. Output EM. */return maskedDB+h+String.fromCharCode(0xbc);};/**
   * Verifies a PSS signature.
   *
   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
   *
   * @param mHash the message digest hash, as a binary-encoded string, to
   *         compare against the signature.
   * @param em the encoded message, as a binary-encoded string
   *          (RSA decryption result).
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return true if the signature was verified, false if not.
   */pssobj.verify=function(mHash,em,modBits){var i;var emBits=modBits-1;var emLen=Math.ceil(emBits/8);/* c. Convert the message representative m to an encoded message EM
     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits
     *    is the length in bits of the RSA modulus n */em=em.substr(-emLen);/* 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop. */if(emLen<hLen+sLen+2){throw new Error('Inconsistent parameters to PSS signature verification.');}/* 4. If the rightmost octet of EM does not have hexadecimal value
     *    0xbc, output "inconsistent" and stop. */if(em.charCodeAt(emLen-1)!==0xbc){throw new Error('Encoded message does not end in 0xBC.');}/* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
     *    let H be the next hLen octets. */var maskLen=emLen-hLen-1;var maskedDB=em.substr(0,maskLen);var h=em.substr(maskLen,hLen);/* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
     *    maskedDB are not all equal to zero, output "inconsistent" and stop. */var mask=0xFF00>>8*emLen-emBits&0xFF;if((maskedDB.charCodeAt(0)&mask)!==0){throw new Error('Bits beyond keysize not zero as expected.');}/* 7. Let dbMask = MGF(H, emLen - hLen - 1). */var dbMask=mgf.generate(h,maskLen);/* 8. Let DB = maskedDB \xor dbMask. */var db='';for(i=0;i<maskLen;i++){db+=String.fromCharCode(maskedDB.charCodeAt(i)^dbMask.charCodeAt(i));}/* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
     * in DB to zero. */db=String.fromCharCode(db.charCodeAt(0)&~mask)+db.substr(1);/* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
     * position is "position 1") does not have hexadecimal value 0x01,
     * output "inconsistent" and stop. */var checkLen=emLen-hLen-sLen-2;for(i=0;i<checkLen;i++){if(db.charCodeAt(i)!==0x00){throw new Error('Leftmost octets not zero as expected');}}if(db.charCodeAt(checkLen)!==0x01){throw new Error('Inconsistent PSS signature, 0x01 marker not found');}/* 11. Let salt be the last sLen octets of DB. */var salt=db.substr(-sLen);/* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */var m_=new forge.util.ByteBuffer();m_.fillWithByte(0,8);m_.putBytes(mHash);m_.putBytes(salt);/* 13. Let H' = Hash(M'), an octet string of length hLen. */hash.start();hash.update(m_.getBytes());var h_=hash.digest().getBytes();/* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */return h===h_;};return pssobj;};/***/},/* 20 */ /***/function(module,exports,__webpack_require__){__webpack_require__(21);module.exports=__webpack_require__(0);/***/},/* 21 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of a basic Public Key Infrastructure, including
 * support for RSA public and private keys.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(3);__webpack_require__(9);__webpack_require__(8);__webpack_require__(13);__webpack_require__(28);__webpack_require__(19);__webpack_require__(6);__webpack_require__(1);__webpack_require__(18);// shortcut for asn.1 API
var asn1=forge.asn1;/* Public Key Infrastructure (PKI) implementation. */var pki=module.exports=forge.pki=forge.pki||{};/**
 * NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.
 *
 * Converts PEM-formatted data to DER.
 *
 * @param pem the PEM-formatted data.
 *
 * @return the DER-formatted data.
 */pki.pemToDer=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert PEM to DER; PEM is encrypted.');}return forge.util.createBuffer(msg.body);};/**
 * Converts an RSA private key from PEM format.
 *
 * @param pem the PEM-formatted private key.
 *
 * @return the private key.
 */pki.privateKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='PRIVATE KEY'&&msg.type!=='RSA PRIVATE KEY'){var error=new Error('Could not convert private key from PEM; PEM '+'header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert private key from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body);return pki.privateKeyFromAsn1(obj);};/**
 * Converts an RSA private key to PEM format.
 *
 * @param key the private key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */pki.privateKeyToPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'RSA PRIVATE KEY',body:asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts a PrivateKeyInfo to PEM format.
 *
 * @param pki the PrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */pki.privateKeyInfoToPem=function(pki,maxline){// convert to DER, then PEM-encode
var msg={type:'PRIVATE KEY',body:asn1.toDer(pki).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/***/},/* 22 */ /***/function(module,exports){/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */var api={};module.exports=api;// baseN alphabet indexes
var _reverseAlphabets={};/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */api.encode=function(input,alphabet,maxline){if(typeof alphabet!=='string'){throw new TypeError('"alphabet" must be a string.');}if(maxline!==undefined&&typeof maxline!=='number'){throw new TypeError('"maxline" must be a number.');}var output='';if(!(input instanceof Uint8Array)){// assume forge byte buffer
output=_encodeWithByteBuffer(input,alphabet);}else{var i=0;var base=alphabet.length;var first=alphabet.charAt(0);var digits=[0];for(i=0;i<input.length;++i){for(var j=0,carry=input[i];j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%base;carry=carry/base|0;}while(carry>0){digits.push(carry%base);carry=carry/base|0;}}// deal with leading zeros
for(i=0;input[i]===0&&i<input.length-1;++i){output+=first;}// convert digits to a string
for(i=digits.length-1;i>=0;--i){output+=alphabet[digits[i]];}}if(maxline){var regex=new RegExp('.{1,'+maxline+'}','g');output=output.match(regex).join('\r\n');}return output;};/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */api.decode=function(input,alphabet){if(typeof input!=='string'){throw new TypeError('"input" must be a string.');}if(typeof alphabet!=='string'){throw new TypeError('"alphabet" must be a string.');}var table=_reverseAlphabets[alphabet];if(!table){// compute reverse alphabet
table=_reverseAlphabets[alphabet]=[];for(var i=0;i<alphabet.length;++i){table[alphabet.charCodeAt(i)]=i;}}// remove whitespace characters
input=input.replace(/\s/g,'');var base=alphabet.length;var first=alphabet.charAt(0);var bytes=[0];for(var i=0;i<input.length;i++){var value=table[input.charCodeAt(i)];if(value===undefined){return;}for(var j=0,carry=value;j<bytes.length;++j){carry+=bytes[j]*base;bytes[j]=carry&0xff;carry>>=8;}while(carry>0){bytes.push(carry&0xff);carry>>=8;}}// deal with leading zeros
for(var k=0;input[k]===first&&k<input.length-1;++k){bytes.push(0);}if(typeof Buffer!=='undefined'){return Buffer.from(bytes.reverse());}return new Uint8Array(bytes.reverse());};function _encodeWithByteBuffer(input,alphabet){var i=0;var base=alphabet.length;var first=alphabet.charAt(0);var digits=[0];for(i=0;i<input.length();++i){for(var j=0,carry=input.at(i);j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%base;carry=carry/base|0;}while(carry>0){digits.push(carry%base);carry=carry/base|0;}}var output='';// deal with leading zeros
for(i=0;input.at(i)===0&&i<input.length()-1;++i){output+=first;}// convert digits to a string
for(i=digits.length-1;i>=0;--i){output+=alphabet[digits[i]];}return output;}/***/},/* 23 */ /***/function(module,exports,__webpack_require__){/**
 * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
 *
 * See FIPS 180-2 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);var sha256=module.exports=forge.sha256=forge.sha256||{};forge.md.sha256=forge.md.algorithms.sha256=sha256;/**
 * Creates a SHA-256 message digest object.
 *
 * @return a message digest object.
 */sha256.create=function(){// do initialization as necessary
if(!_initialized){_init();}// SHA-256 state contains eight 32-bit integers
var _state=null;// input buffer
var _input=forge.util.createBuffer();// used for word storage
var _w=new Array(64);// message digest object
var md={algorithm:'sha256',blockLength:64,digestLength:32,// 56-bit length of message so far (does not including padding)
messageLength:0,// true message length
fullMessageLength:null,// size of message length in bytes
messageLengthSize:8};/**
   * Starts the digest.
   *
   * @return this digest object.
   */md.start=function(){// up to 56-bit message length for convenience
md.messageLength=0;// full message length (set md.messageLength64 for backwards-compatibility)
md.fullMessageLength=md.messageLength64=[];var int32s=md.messageLengthSize/4;for(var i=0;i<int32s;++i){md.fullMessageLength.push(0);}_input=forge.util.createBuffer();_state={h0:0x6A09E667,h1:0xBB67AE85,h2:0x3C6EF372,h3:0xA54FF53A,h4:0x510E527F,h5:0x9B05688C,h6:0x1F83D9AB,h7:0x5BE0CD19};return md;};// start digest automatically for first time
md.start();/**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */md.update=function(msg,encoding){if(encoding==='utf8'){msg=forge.util.encodeUtf8(msg);}// update message length
var len=msg.length;md.messageLength+=len;len=[len/0x100000000>>>0,len>>>0];for(var i=md.fullMessageLength.length-1;i>=0;--i){md.fullMessageLength[i]+=len[1];len[1]=len[0]+(md.fullMessageLength[i]/0x100000000>>>0);md.fullMessageLength[i]=md.fullMessageLength[i]>>>0;len[0]=len[1]/0x100000000>>>0;}// add bytes to input buffer
_input.putBytes(msg);// process bytes
_update(_state,_w,_input);// compact input buffer every 2K or if empty
if(_input.read>2048||_input.length()===0){_input.compact();}return md;};/**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */md.digest=function(){/* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */var finalBlock=forge.util.createBuffer();finalBlock.putBytes(_input.bytes());// compute remaining size to be digested (include message length size)
var remaining=md.fullMessageLength[md.fullMessageLength.length-1]+md.messageLengthSize;// add padding for overflow blockSize - overflow
// _padding starts with 1 byte with first bit is set (byte value 128), then
// there may be up to (blockSize - 1) other pad bytes
var overflow=remaining&md.blockLength-1;finalBlock.putBytes(_padding.substr(0,md.blockLength-overflow));// serialize message length in bits in big-endian order; since length
// is stored in bytes we multiply by 8 and add carry from next int
var next,carry;var bits=md.fullMessageLength[0]*8;for(var i=0;i<md.fullMessageLength.length-1;++i){next=md.fullMessageLength[i+1]*8;carry=next/0x100000000>>>0;bits+=carry;finalBlock.putInt32(bits>>>0);bits=next>>>0;}finalBlock.putInt32(bits);var s2={h0:_state.h0,h1:_state.h1,h2:_state.h2,h3:_state.h3,h4:_state.h4,h5:_state.h5,h6:_state.h6,h7:_state.h7};_update(s2,_w,finalBlock);var rval=forge.util.createBuffer();rval.putInt32(s2.h0);rval.putInt32(s2.h1);rval.putInt32(s2.h2);rval.putInt32(s2.h3);rval.putInt32(s2.h4);rval.putInt32(s2.h5);rval.putInt32(s2.h6);rval.putInt32(s2.h7);return rval;};return md;};// sha-256 padding bytes not initialized yet
var _padding=null;var _initialized=false;// table of constants
var _k=null;/**
 * Initializes the constant tables.
 */function _init(){// create padding
_padding=String.fromCharCode(128);_padding+=forge.util.fillString(String.fromCharCode(0x00),64);// create K table for SHA-256
_k=[0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2];// now initialized
_initialized=true;}/**
 * Updates a SHA-256 state with the given byte buffer.
 *
 * @param s the SHA-256 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */function _update(s,w,bytes){// consume 512 bit (64 byte) chunks
var t1,t2,s0,s1,ch,maj,i,a,b,c,d,e,f,g,h;var len=bytes.length();while(len>=64){// the w array will be populated with sixteen 32-bit big-endian words
// and then extended into 64 32-bit words according to SHA-256
for(i=0;i<16;++i){w[i]=bytes.getInt32();}for(;i<64;++i){// XOR word 2 words ago rot right 17, rot right 19, shft right 10
t1=w[i-2];t1=(t1>>>17|t1<<15)^(t1>>>19|t1<<13)^t1>>>10;// XOR word 15 words ago rot right 7, rot right 18, shft right 3
t2=w[i-15];t2=(t2>>>7|t2<<25)^(t2>>>18|t2<<14)^t2>>>3;// sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32
w[i]=t1+w[i-7]+t2+w[i-16]|0;}// initialize hash value for this chunk
a=s.h0;b=s.h1;c=s.h2;d=s.h3;e=s.h4;f=s.h5;g=s.h6;h=s.h7;// round function
for(i=0;i<64;++i){// Sum1(e)
s1=(e>>>6|e<<26)^(e>>>11|e<<21)^(e>>>25|e<<7);// Ch(e, f, g) (optimized the same way as SHA-1)
ch=g^e&(f^g);// Sum0(a)
s0=(a>>>2|a<<30)^(a>>>13|a<<19)^(a>>>22|a<<10);// Maj(a, b, c) (optimized the same way as SHA-1)
maj=a&b|c&(a^b);// main algorithm
t1=h+s1+ch+_k[i]+w[i];t2=s0+maj;h=g;g=f;f=e;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
// can't truncate with `| 0`
e=d+t1>>>0;d=c;c=b;b=a;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
// can't truncate with `| 0`
a=t1+t2>>>0;}// update hash state
s.h0=s.h0+a|0;s.h1=s.h1+b|0;s.h2=s.h2+c|0;s.h3=s.h3+d|0;s.h4=s.h4+e|0;s.h5=s.h5+f|0;s.h6=s.h6+g|0;s.h7=s.h7+h|0;len-=64;}}/***/},/* 24 */ /***/function(module,exports,__webpack_require__){/**
 * A javascript implementation of a cryptographically-secure
 * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
 * here though the use of SHA-256 is not enforced; when generating an
 * a PRNG context, the hashing algorithm and block cipher used for
 * the generator are specified via a plugin.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);var _crypto=null;if(forge.util.isNodejs&&!forge.options.usePureJavaScript&&!process.versions['node-webkit']){_crypto=__webpack_require__(15);}/* PRNG API */var prng=module.exports=forge.prng=forge.prng||{};/**
 * Creates a new PRNG context.
 *
 * A PRNG plugin must be passed in that will provide:
 *
 * 1. A function that initializes the key and seed of a PRNG context. It
 *   will be given a 16 byte key and a 16 byte seed. Any key expansion
 *   or transformation of the seed from a byte string into an array of
 *   integers (or similar) should be performed.
 * 2. The cryptographic function used by the generator. It takes a key and
 *   a seed.
 * 3. A seed increment function. It takes the seed and returns seed + 1.
 * 4. An api to create a message digest.
 *
 * For an example, see random.js.
 *
 * @param plugin the PRNG plugin to use.
 */prng.create=function(plugin){var ctx={plugin:plugin,key:null,seed:null,time:null,// number of reseeds so far
reseeds:0,// amount of data generated so far
generated:0,// no initial key bytes
keyBytes:''};// create 32 entropy pools (each is a message digest)
var md=plugin.md;var pools=new Array(32);for(var i=0;i<32;++i){pools[i]=md.create();}ctx.pools=pools;// entropy pools are written to cyclically, starting at index 0
ctx.pool=0;/**
   * Generates random bytes. The bytes may be generated synchronously or
   * asynchronously. Web workers must use the asynchronous interface or
   * else the behavior is undefined.
   *
   * @param count the number of random bytes to generate.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */ctx.generate=function(count,callback){// do synchronously
if(!callback){return ctx.generateSync(count);}// simple generator using counter-based CBC
var cipher=ctx.plugin.cipher;var increment=ctx.plugin.increment;var formatKey=ctx.plugin.formatKey;var formatSeed=ctx.plugin.formatSeed;var b=forge.util.createBuffer();// paranoid deviation from Fortuna:
// reset key for every request to protect previously
// generated random bytes should the key be discovered;
// there is no 100ms based reseeding because of this
// forced reseed for every `generate` call
ctx.key=null;generate();function generate(err){if(err){return callback(err);}// sufficient bytes generated
if(b.length()>=count){return callback(null,b.getBytes(count));}// if amount of data generated is greater than 1 MiB, trigger reseed
if(ctx.generated>0xfffff){ctx.key=null;}if(ctx.key===null){// prevent stack overflow
return forge.util.nextTick(function(){_reseed(generate);});}// generate the random bytes
var bytes=cipher(ctx.key,ctx.seed);ctx.generated+=bytes.length;b.putBytes(bytes);// generate bytes for a new key and seed
ctx.key=formatKey(cipher(ctx.key,increment(ctx.seed)));ctx.seed=formatSeed(cipher(ctx.key,ctx.seed));forge.util.setImmediate(generate);}};/**
   * Generates random bytes synchronously.
   *
   * @param count the number of random bytes to generate.
   *
   * @return count random bytes as a string.
   */ctx.generateSync=function(count){// simple generator using counter-based CBC
var cipher=ctx.plugin.cipher;var increment=ctx.plugin.increment;var formatKey=ctx.plugin.formatKey;var formatSeed=ctx.plugin.formatSeed;// paranoid deviation from Fortuna:
// reset key for every request to protect previously
// generated random bytes should the key be discovered;
// there is no 100ms based reseeding because of this
// forced reseed for every `generateSync` call
ctx.key=null;var b=forge.util.createBuffer();while(b.length()<count){// if amount of data generated is greater than 1 MiB, trigger reseed
if(ctx.generated>0xfffff){ctx.key=null;}if(ctx.key===null){_reseedSync();}// generate the random bytes
var bytes=cipher(ctx.key,ctx.seed);ctx.generated+=bytes.length;b.putBytes(bytes);// generate bytes for a new key and seed
ctx.key=formatKey(cipher(ctx.key,increment(ctx.seed)));ctx.seed=formatSeed(cipher(ctx.key,ctx.seed));}return b.getBytes(count);};/**
   * Private function that asynchronously reseeds a generator.
   *
   * @param callback(err) called once the operation completes.
   */function _reseed(callback){if(ctx.pools[0].messageLength>=32){_seed();return callback();}// not enough seed data...
var needed=32-ctx.pools[0].messageLength<<5;ctx.seedFile(needed,function(err,bytes){if(err){return callback(err);}ctx.collect(bytes);_seed();callback();});}/**
   * Private function that synchronously reseeds a generator.
   */function _reseedSync(){if(ctx.pools[0].messageLength>=32){return _seed();}// not enough seed data...
var needed=32-ctx.pools[0].messageLength<<5;ctx.collect(ctx.seedFileSync(needed));_seed();}/**
   * Private function that seeds a generator once enough bytes are available.
   */function _seed(){// update reseed count
ctx.reseeds=ctx.reseeds===0xffffffff?0:ctx.reseeds+1;// goal is to update `key` via:
// key = hash(key + s)
//   where 's' is all collected entropy from selected pools, then...
// create a plugin-based message digest
var md=ctx.plugin.md.create();// consume current key bytes
md.update(ctx.keyBytes);// digest the entropy of pools whose index k meet the
// condition 'n mod 2^k == 0' where n is the number of reseeds
var _2powK=1;for(var k=0;k<32;++k){if(ctx.reseeds%_2powK===0){md.update(ctx.pools[k].digest().getBytes());ctx.pools[k].start();}_2powK=_2powK<<1;}// get digest for key bytes
ctx.keyBytes=md.digest().getBytes();// paranoid deviation from Fortuna:
// update `seed` via `seed = hash(key)`
// instead of initializing to zero once and only
// ever incrementing it
md.start();md.update(ctx.keyBytes);var seedBytes=md.digest().getBytes();// update state
ctx.key=ctx.plugin.formatKey(ctx.keyBytes);ctx.seed=ctx.plugin.formatSeed(seedBytes);ctx.generated=0;}/**
   * The built-in default seedFile. This seedFile is used when entropy
   * is needed immediately.
   *
   * @param needed the number of bytes that are needed.
   *
   * @return the random bytes.
   */function defaultSeedFile(needed){// use window.crypto.getRandomValues strong source of entropy if available
var getRandomValues=null;if(typeof window!=='undefined'){var _crypto=window.crypto||window.msCrypto;if(_crypto&&_crypto.getRandomValues){getRandomValues=function getRandomValues(arr){return _crypto.getRandomValues(arr);};}}var b=forge.util.createBuffer();if(getRandomValues){while(b.length()<needed){// max byte length is 65536 before QuotaExceededError is thrown
// http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues
var count=Math.max(1,Math.min(needed-b.length(),65536)/4);var entropy=new Uint32Array(Math.floor(count));try{getRandomValues(entropy);for(var i=0;i<entropy.length;++i){b.putInt32(entropy[i]);}}catch(e){/* only ignore QuotaExceededError */if(!(typeof QuotaExceededError!=='undefined'&&e instanceof QuotaExceededError)){throw e;}}}}// be sad and add some weak random data
if(b.length()<needed){/* Draws from Park-Miller "minimal standard" 31 bit PRNG,
      implemented with David G. Carta's optimization: with 32 bit math
      and without division (Public Domain). */var hi,lo,next;var seed=Math.floor(Math.random()*0x010000);while(b.length()<needed){lo=16807*(seed&0xFFFF);hi=16807*(seed>>16);lo+=(hi&0x7FFF)<<16;lo+=hi>>15;lo=(lo&0x7FFFFFFF)+(lo>>31);seed=lo&0xFFFFFFFF;// consume lower 3 bytes of seed
for(var i=0;i<3;++i){// throw in more pseudo random
next=seed>>>(i<<3);next^=Math.floor(Math.random()*0x0100);b.putByte(String.fromCharCode(next&0xFF));}}}return b.getBytes(needed);}// initialize seed file APIs
if(_crypto){// use nodejs async API
ctx.seedFile=function(needed,callback){_crypto.randomBytes(needed,function(err,bytes){if(err){return callback(err);}callback(null,bytes.toString());});};// use nodejs sync API
ctx.seedFileSync=function(needed){return _crypto.randomBytes(needed).toString();};}else{ctx.seedFile=function(needed,callback){try{callback(null,defaultSeedFile(needed));}catch(e){callback(e);}};ctx.seedFileSync=defaultSeedFile;}/**
   * Adds entropy to a prng ctx's accumulator.
   *
   * @param bytes the bytes of entropy as a string.
   */ctx.collect=function(bytes){// iterate over pools distributing entropy cyclically
var count=bytes.length;for(var i=0;i<count;++i){ctx.pools[ctx.pool].update(bytes.substr(i,1));ctx.pool=ctx.pool===31?0:ctx.pool+1;}};/**
   * Collects an integer of n bits.
   *
   * @param i the integer entropy.
   * @param n the number of bits in the integer.
   */ctx.collectInt=function(i,n){var bytes='';for(var x=0;x<n;x+=8){bytes+=String.fromCharCode(i>>x&0xFF);}ctx.collect(bytes);};/**
   * Registers a Web Worker to receive immediate entropy from the main thread.
   * This method is required until Web Workers can access the native crypto
   * API. This method should be called twice for each created worker, once in
   * the main thread, and once in the worker itself.
   *
   * @param worker the worker to register.
   */ctx.registerWorker=function(worker){// worker receives random bytes
if(worker===self){ctx.seedFile=function(needed,callback){function listener(e){var data=e.data;if(data.forge&&data.forge.prng){self.removeEventListener('message',listener);callback(data.forge.prng.err,data.forge.prng.bytes);}}self.addEventListener('message',listener);self.postMessage({forge:{prng:{needed:needed}}});};}else{// main thread sends random bytes upon request
var listener=function listener(e){var data=e.data;if(data.forge&&data.forge.prng){ctx.seedFile(data.forge.prng.needed,function(err,bytes){worker.postMessage({forge:{prng:{err:err,bytes:bytes}}});});}};// TODO: do we need to remove the event listener when the worker dies?
worker.addEventListener('message',listener);}};return ctx;};/***/},/* 25 */ /***/function(module,exports,__webpack_require__){/**
 * RC2 implementation.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * Information on the RC2 cipher is available from RFC #2268,
 * http://www.ietf.org/rfc/rfc2268.txt
 */var forge=__webpack_require__(0);__webpack_require__(1);var piTable=[0xd9,0x78,0xf9,0xc4,0x19,0xdd,0xb5,0xed,0x28,0xe9,0xfd,0x79,0x4a,0xa0,0xd8,0x9d,0xc6,0x7e,0x37,0x83,0x2b,0x76,0x53,0x8e,0x62,0x4c,0x64,0x88,0x44,0x8b,0xfb,0xa2,0x17,0x9a,0x59,0xf5,0x87,0xb3,0x4f,0x13,0x61,0x45,0x6d,0x8d,0x09,0x81,0x7d,0x32,0xbd,0x8f,0x40,0xeb,0x86,0xb7,0x7b,0x0b,0xf0,0x95,0x21,0x22,0x5c,0x6b,0x4e,0x82,0x54,0xd6,0x65,0x93,0xce,0x60,0xb2,0x1c,0x73,0x56,0xc0,0x14,0xa7,0x8c,0xf1,0xdc,0x12,0x75,0xca,0x1f,0x3b,0xbe,0xe4,0xd1,0x42,0x3d,0xd4,0x30,0xa3,0x3c,0xb6,0x26,0x6f,0xbf,0x0e,0xda,0x46,0x69,0x07,0x57,0x27,0xf2,0x1d,0x9b,0xbc,0x94,0x43,0x03,0xf8,0x11,0xc7,0xf6,0x90,0xef,0x3e,0xe7,0x06,0xc3,0xd5,0x2f,0xc8,0x66,0x1e,0xd7,0x08,0xe8,0xea,0xde,0x80,0x52,0xee,0xf7,0x84,0xaa,0x72,0xac,0x35,0x4d,0x6a,0x2a,0x96,0x1a,0xd2,0x71,0x5a,0x15,0x49,0x74,0x4b,0x9f,0xd0,0x5e,0x04,0x18,0xa4,0xec,0xc2,0xe0,0x41,0x6e,0x0f,0x51,0xcb,0xcc,0x24,0x91,0xaf,0x50,0xa1,0xf4,0x70,0x39,0x99,0x7c,0x3a,0x85,0x23,0xb8,0xb4,0x7a,0xfc,0x02,0x36,0x5b,0x25,0x55,0x97,0x31,0x2d,0x5d,0xfa,0x98,0xe3,0x8a,0x92,0xae,0x05,0xdf,0x29,0x10,0x67,0x6c,0xba,0xc9,0xd3,0x00,0xe6,0xcf,0xe1,0x9e,0xa8,0x2c,0x63,0x16,0x01,0x3f,0x58,0xe2,0x89,0xa9,0x0d,0x38,0x34,0x1b,0xab,0x33,0xff,0xb0,0xbb,0x48,0x0c,0x5f,0xb9,0xb1,0xcd,0x2e,0xc5,0xf3,0xdb,0x47,0xe5,0xa5,0x9c,0x77,0x0a,0xa6,0x20,0x68,0xfe,0x7f,0xc1,0xad];var s=[1,2,3,5];/**
 * Rotate a word left by given number of bits.
 *
 * Bits that are shifted out on the left are put back in on the right
 * hand side.
 *
 * @param word The word to shift left.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */var rol=function rol(word,bits){return word<<bits&0xffff|(word&0xffff)>>16-bits;};/**
 * Rotate a word right by given number of bits.
 *
 * Bits that are shifted out on the right are put back in on the left
 * hand side.
 *
 * @param word The word to shift right.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */var ror=function ror(word,bits){return(word&0xffff)>>bits|word<<16-bits&0xffff;};/* RC2 API */module.exports=forge.rc2=forge.rc2||{};/**
 * Perform RC2 key expansion as per RFC #2268, section 2.
 *
 * @param key variable-length user key (between 1 and 128 bytes)
 * @param effKeyBits number of effective key bits (default: 128)
 * @return the expanded RC2 key (ByteBuffer of 128 bytes)
 */forge.rc2.expandKey=function(key,effKeyBits){if(typeof key==='string'){key=forge.util.createBuffer(key);}effKeyBits=effKeyBits||128;/* introduce variables that match the names used in RFC #2268 */var L=key;var T=key.length();var T1=effKeyBits;var T8=Math.ceil(T1/8);var TM=0xff>>(T1&0x07);var i;for(i=T;i<128;i++){L.putByte(piTable[L.at(i-1)+L.at(i-T)&0xff]);}L.setAt(128-T8,piTable[L.at(128-T8)&TM]);for(i=127-T8;i>=0;i--){L.setAt(i,piTable[L.at(i+1)^L.at(i+T8)]);}return L;};/**
 * Creates a RC2 cipher object.
 *
 * @param key the symmetric key to use (as base for key generation).
 * @param bits the number of effective key bits.
 * @param encrypt false for decryption, true for encryption.
 *
 * @return the cipher.
 */var createCipher=function createCipher(key,bits,encrypt){var _finish=false,_input=null,_output=null,_iv=null;var mixRound,mashRound;var i,j,K=[];/* Expand key and fill into K[] Array */key=forge.rc2.expandKey(key,bits);for(i=0;i<64;i++){K.push(key.getInt16Le());}if(encrypt){/**
     * Perform one mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */mixRound=function mixRound(R){for(i=0;i<4;i++){R[i]+=K[j]+(R[(i+3)%4]&R[(i+2)%4])+(~R[(i+3)%4]&R[(i+1)%4]);R[i]=rol(R[i],s[i]);j++;}};/**
     * Perform one mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */mashRound=function mashRound(R){for(i=0;i<4;i++){R[i]+=K[R[(i+3)%4]&63];}};}else{/**
     * Perform one r-mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */mixRound=function mixRound(R){for(i=3;i>=0;i--){R[i]=ror(R[i],s[i]);R[i]-=K[j]+(R[(i+3)%4]&R[(i+2)%4])+(~R[(i+3)%4]&R[(i+1)%4]);j--;}};/**
     * Perform one r-mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */mashRound=function mashRound(R){for(i=3;i>=0;i--){R[i]-=K[R[(i+3)%4]&63];}};}/**
   * Run the specified cipher execution plan.
   *
   * This function takes four words from the input buffer, applies the IV on
   * it (if requested) and runs the provided execution plan.
   *
   * The plan must be put together in form of a array of arrays.  Where the
   * outer one is simply a list of steps to perform and the inner one needs
   * to have two elements: the first one telling how many rounds to perform,
   * the second one telling what to do (i.e. the function to call).
   *
   * @param {Array} plan The plan to execute.
   */var runPlan=function runPlan(plan){var R=[];/* Get data from input buffer and fill the four words into R */for(i=0;i<4;i++){var val=_input.getInt16Le();if(_iv!==null){if(encrypt){/* We're encrypting, apply the IV first. */val^=_iv.getInt16Le();}else{/* We're decryption, keep cipher text for next block. */_iv.putInt16Le(val);}}R.push(val&0xffff);}/* Reset global "j" variable as per spec. */j=encrypt?0:63;/* Run execution plan. */for(var ptr=0;ptr<plan.length;ptr++){for(var ctr=0;ctr<plan[ptr][0];ctr++){plan[ptr][1](R);}}/* Write back result to output buffer. */for(i=0;i<4;i++){if(_iv!==null){if(encrypt){/* We're encrypting in CBC-mode, feed back encrypted bytes into
             IV buffer to carry it forward to next block. */_iv.putInt16Le(R[i]);}else{R[i]^=_iv.getInt16Le();}}_output.putInt16Le(R[i]);}};/* Create cipher object */var cipher=null;cipher={/**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */start:function start(iv,output){if(iv){/* CBC mode */if(typeof iv==='string'){iv=forge.util.createBuffer(iv);}}_finish=false;_input=forge.util.createBuffer();_output=output||new forge.util.createBuffer();_iv=iv;cipher.output=_output;},/**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */update:function update(input){if(!_finish){// not finishing, so fill the input buffer with more input
_input.putBuffer(input);}while(_input.length()>=8){runPlan([[5,mixRound],[1,mashRound],[6,mixRound],[1,mashRound],[5,mixRound]]);}},/**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */finish:function finish(pad){var rval=true;if(encrypt){if(pad){rval=pad(8,_input,!encrypt);}else{// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=_input.length()===8?8:8-_input.length();_input.fillWithByte(padding,padding);}}if(rval){// do final update
_finish=true;cipher.update();}if(!encrypt){// check for error: input data not a multiple of block size
rval=_input.length()===0;if(rval){if(pad){rval=pad(8,_output,!encrypt);}else{// ensure padding byte count is valid
var len=_output.length();var count=_output.at(len-1);if(count>len){rval=false;}else{// trim off padding bytes
_output.truncate(count);}}}}return rval;}};return cipher;};/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */forge.rc2.startEncrypting=function(key,iv,output){var cipher=forge.rc2.createEncryptionCipher(key,128);cipher.start(iv,output);return cipher;};/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start encrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */forge.rc2.createEncryptionCipher=function(key,bits){return createCipher(key,bits,true);};/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */forge.rc2.startDecrypting=function(key,iv,output){var cipher=forge.rc2.createDecryptionCipher(key,128);cipher.start(iv,output);return cipher;};/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start decrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */forge.rc2.createDecryptionCipher=function(key,bits){return createCipher(key,bits,false);};/***/},/* 26 */ /***/function(module,exports,__webpack_require__){/**
 * Partial implementation of PKCS#1 v2.2: RSA-OEAP
 *
 * Modified but based on the following MIT and BSD licensed code:
 *
 * https://github.com/kjur/jsjws/blob/master/rsa.js:
 *
 * The 'jsjws'(JSON Web Signature JavaScript Library) License
 *
 * Copyright (c) 2012 Kenji Urushima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:
 *
 * RSAES-OAEP.js
 * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $
 * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)
 * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.
 * Contact: ellis@nukinetics.com
 * Distributed under the BSD License.
 *
 * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125
 *
 * @author Evan Jones (http://evanjones.ca/)
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(5);__webpack_require__(17);// shortcut for PKCS#1 API
var pkcs1=module.exports=forge.pkcs1=forge.pkcs1||{};/**
 * Encode the given RSAES-OAEP message (M) using key, with optional label (L)
 * and seed.
 *
 * This method does not perform RSA encryption, it only encodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param message the message to encode.
 * @param options the options to use:
 *          label an optional label to use.
 *          seed the seed to use.
 *          md the message digest object to use, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the encoded message bytes.
 */pkcs1.encode_rsa_oaep=function(key,message,options){// parse arguments
var label;var seed;var md;var mgf1Md;// legacy args (label, seed, md)
if(typeof options==='string'){label=options;seed=arguments[3]||undefined;md=arguments[4]||undefined;}else if(options){label=options.label||undefined;seed=options.seed||undefined;md=options.md||undefined;if(options.mgf1&&options.mgf1.md){mgf1Md=options.mgf1.md;}}// default OAEP to SHA-1 message digest
if(!md){md=forge.md.sha1.create();}else{md.start();}// default MGF-1 to same as OAEP
if(!mgf1Md){mgf1Md=md;}// compute length in bytes and check output
var keyLength=Math.ceil(key.n.bitLength()/8);var maxLength=keyLength-2*md.digestLength-2;if(message.length>maxLength){var error=new Error('RSAES-OAEP input message length is too long.');error.length=message.length;error.maxLength=maxLength;throw error;}if(!label){label='';}md.update(label,'raw');var lHash=md.digest();var PS='';var PS_length=maxLength-message.length;for(var i=0;i<PS_length;i++){PS+='\x00';}var DB=lHash.getBytes()+PS+'\x01'+message;if(!seed){seed=forge.random.getBytes(md.digestLength);}else if(seed.length!==md.digestLength){var error=new Error('Invalid RSAES-OAEP seed. The seed length must '+'match the digest length.');error.seedLength=seed.length;error.digestLength=md.digestLength;throw error;}var dbMask=rsa_mgf1(seed,keyLength-md.digestLength-1,mgf1Md);var maskedDB=forge.util.xorBytes(DB,dbMask,DB.length);var seedMask=rsa_mgf1(maskedDB,md.digestLength,mgf1Md);var maskedSeed=forge.util.xorBytes(seed,seedMask,seed.length);// return encoded message
return'\x00'+maskedSeed+maskedDB;};/**
 * Decode the given RSAES-OAEP encoded message (EM) using key, with optional
 * label (L).
 *
 * This method does not perform RSA decryption, it only decodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param em the encoded message to decode.
 * @param options the options to use:
 *          label an optional label to use.
 *          md the message digest object to use for OAEP, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the decoded message bytes.
 */pkcs1.decode_rsa_oaep=function(key,em,options){// parse args
var label;var md;var mgf1Md;// legacy args
if(typeof options==='string'){label=options;md=arguments[3]||undefined;}else if(options){label=options.label||undefined;md=options.md||undefined;if(options.mgf1&&options.mgf1.md){mgf1Md=options.mgf1.md;}}// compute length in bytes
var keyLength=Math.ceil(key.n.bitLength()/8);if(em.length!==keyLength){var error=new Error('RSAES-OAEP encoded message length is invalid.');error.length=em.length;error.expectedLength=keyLength;throw error;}// default OAEP to SHA-1 message digest
if(md===undefined){md=forge.md.sha1.create();}else{md.start();}// default MGF-1 to same as OAEP
if(!mgf1Md){mgf1Md=md;}if(keyLength<2*md.digestLength+2){throw new Error('RSAES-OAEP key is too short for the hash function.');}if(!label){label='';}md.update(label,'raw');var lHash=md.digest().getBytes();// split the message into its parts
var y=em.charAt(0);var maskedSeed=em.substring(1,md.digestLength+1);var maskedDB=em.substring(1+md.digestLength);var seedMask=rsa_mgf1(maskedDB,md.digestLength,mgf1Md);var seed=forge.util.xorBytes(maskedSeed,seedMask,maskedSeed.length);var dbMask=rsa_mgf1(seed,keyLength-md.digestLength-1,mgf1Md);var db=forge.util.xorBytes(maskedDB,dbMask,maskedDB.length);var lHashPrime=db.substring(0,md.digestLength);// constant time check that all values match what is expected
var error=y!=='\x00';// constant time check lHash vs lHashPrime
for(var i=0;i<md.digestLength;++i){error|=lHash.charAt(i)!==lHashPrime.charAt(i);}// "constant time" find the 0x1 byte separating the padding (zeros) from the
// message
// TODO: It must be possible to do this in a better/smarter way?
var in_ps=1;var index=md.digestLength;for(var j=md.digestLength;j<db.length;j++){var code=db.charCodeAt(j);var is_0=code&0x1^0x1;// non-zero if not 0 or 1 in the ps section
var error_mask=in_ps?0xfffe:0x0000;error|=code&error_mask;// latch in_ps to zero after we find 0x1
in_ps=in_ps&is_0;index+=in_ps;}if(error||db.charCodeAt(index)!==0x1){throw new Error('Invalid RSAES-OAEP padding.');}return db.substring(index+1);};function rsa_mgf1(seed,maskLength,hash){// default to SHA-1 message digest
if(!hash){hash=forge.md.sha1.create();}var t='';var count=Math.ceil(maskLength/hash.digestLength);for(var i=0;i<count;++i){var c=String.fromCharCode(i>>24&0xFF,i>>16&0xFF,i>>8&0xFF,i&0xFF);hash.start();hash.update(seed+c);t+=hash.digest().getBytes();}return t.substring(0,maskLength);}/***/},/* 27 */ /***/function(module,exports,__webpack_require__){/**
 * Prime number generation API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(16);__webpack_require__(5);(function(){// forge.prime already defined
if(forge.prime){module.exports=forge.prime;return;}/* PRIME API */var prime=module.exports=forge.prime=forge.prime||{};var BigInteger=forge.jsbn.BigInteger;// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA=[6,4,2,4,2,4,6,2];var THIRTY=new BigInteger(null);THIRTY.fromInt(30);var op_or=function op_or(x,y){return x|y;};/**
 * Generates a random probable prime with the given number of bits.
 *
 * Alternative algorithms can be specified by name as a string or as an
 * object with custom options like so:
 *
 * {
 *   name: 'PRIMEINC',
 *   options: {
 *     maxBlockTime: <the maximum amount of time to block the main
 *       thread before allowing I/O other JS to run>,
 *     millerRabinTests: <the number of miller-rabin tests to run>,
 *     workerScript: <the worker script URL>,
 *     workers: <the number of web workers (if supported) to use,
 *       -1 to use estimated cores minus one>.
 *     workLoad: the size of the work load, ie: number of possible prime
 *       numbers for each web worker to check per work assignment,
 *       (default: 100).
 *   }
 * }
 *
 * @param bits the number of bits for the prime number.
 * @param options the options to use.
 *          [algorithm] the algorithm to use (default: 'PRIMEINC').
 *          [prng] a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *
 * @return callback(err, num) called once the operation completes.
 */prime.generateProbablePrime=function(bits,options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};// default to PRIMEINC algorithm
var algorithm=options.algorithm||'PRIMEINC';if(typeof algorithm==='string'){algorithm={name:algorithm};}algorithm.options=algorithm.options||{};// create prng with api that matches BigInteger secure random
var prng=options.prng||forge.random;var rng={// x is an array to fill with bytes
nextBytes:function nextBytes(x){var b=prng.getBytesSync(x.length);for(var i=0;i<x.length;++i){x[i]=b.charCodeAt(i);}}};if(algorithm.name==='PRIMEINC'){return primeincFindPrime(bits,rng,algorithm.options,callback);}throw new Error('Invalid prime generation algorithm: '+algorithm.name);};function primeincFindPrime(bits,rng,options,callback){if('workers'in options){return primeincFindPrimeWithWorkers(bits,rng,options,callback);}return primeincFindPrimeWithoutWorkers(bits,rng,options,callback);}function primeincFindPrimeWithoutWorkers(bits,rng,options,callback){// initialize random number
var num=generateRandom(bits,rng);/* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The
  number we are given is always aligned at 30k + 1. Each time the number is
  determined not to be prime we add to get to the next 'i', eg: if the number
  was at 30k + 1 we add 6. */var deltaIdx=0;// get required number of MR tests
var mrTests=getMillerRabinTests(num.bitLength());if('millerRabinTests'in options){mrTests=options.millerRabinTests;}// find prime nearest to 'num' for maxBlockTime ms
// 10 ms gives 5ms of leeway for other calculations before dropping
// below 60fps (1000/60 == 16.67), but in reality, the number will
// likely be higher due to an 'atomic' big int modPow
var maxBlockTime=10;if('maxBlockTime'in options){maxBlockTime=options.maxBlockTime;}_primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback);}function _primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback){var start=+new Date();do{// overflow, regenerate random number
if(num.bitLength()>bits){num=generateRandom(bits,rng);}// do primality test
if(num.isProbablePrime(mrTests)){return callback(null,num);}// get next potential prime
num.dAddOffset(GCD_30_DELTA[deltaIdx++%8],0);}while(maxBlockTime<0||+new Date()-start<maxBlockTime);// keep trying later
forge.util.setImmediate(function(){_primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback);});}// NOTE: This algorithm is indeterminate in nature because workers
// run in parallel looking at different segments of numbers. Even if this
// algorithm is run twice with the same input from a predictable RNG, it
// may produce different outputs.
function primeincFindPrimeWithWorkers(bits,rng,options,callback){// web workers unavailable
if(typeof Worker==='undefined'){return primeincFindPrimeWithoutWorkers(bits,rng,options,callback);}// initialize random number
var num=generateRandom(bits,rng);// use web workers to generate keys
var numWorkers=options.workers;var workLoad=options.workLoad||100;var range=workLoad*30/8;var workerScript=options.workerScript||'forge/prime.worker.js';if(numWorkers===-1){return forge.util.estimateCores(function(err,cores){if(err){// default to 2
cores=2;}numWorkers=cores-1;generate();});}generate();function generate(){// require at least 1 worker
numWorkers=Math.max(1,numWorkers);// TODO: consider optimizing by starting workers outside getPrime() ...
// note that in order to clean up they will have to be made internally
// asynchronous which may actually be slower
// start workers immediately
var workers=[];for(var i=0;i<numWorkers;++i){// FIXME: fix path or use blob URLs
workers[i]=new Worker(workerScript);}var running=numWorkers;// listen for requests from workers and assign ranges to find prime
for(var i=0;i<numWorkers;++i){workers[i].addEventListener('message',workerMessage);}/* Note: The distribution of random numbers is unknown. Therefore, each
    web worker is continuously allocated a range of numbers to check for a
    random number until one is found.

    Every 30 numbers will be checked just 8 times, because prime numbers
    have the form:

    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)

    Therefore, if we want a web worker to run N checks before asking for
    a new range of numbers, each range must contain N*30/8 numbers.

    For 100 checks (workLoad), this is a range of 375. */var found=false;function workerMessage(e){// ignore message, prime already found
if(found){return;}--running;var data=e.data;if(data.found){// terminate all workers
for(var i=0;i<workers.length;++i){workers[i].terminate();}found=true;return callback(null,new BigInteger(data.prime,16));}// overflow, regenerate random number
if(num.bitLength()>bits){num=generateRandom(bits,rng);}// assign new range to check
var hex=num.toString(16);// start prime search
e.target.postMessage({hex:hex,workLoad:workLoad});num.dAddOffset(range,0);}}}/**
 * Generates a random number using the given number of bits and RNG.
 *
 * @param bits the number of bits for the number.
 * @param rng the random number generator to use.
 *
 * @return the random number.
 */function generateRandom(bits,rng){var num=new BigInteger(bits,rng);// force MSB set
var bits1=bits-1;if(!num.testBit(bits1)){num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1),op_or,num);}// align number on 30k+1 boundary
num.dAddOffset(31-num.mod(THIRTY).byteValue(),0);return num;}/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */function getMillerRabinTests(bits){if(bits<=100)return 27;if(bits<=150)return 18;if(bits<=200)return 15;if(bits<=250)return 12;if(bits<=300)return 9;if(bits<=350)return 8;if(bits<=400)return 7;if(bits<=500)return 6;if(bits<=600)return 5;if(bits<=800)return 4;if(bits<=1250)return 3;return 2;}})();/***/},/* 28 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of PKCS#12.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#12 is as follows
 * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)
 *
 * PFX ::= SEQUENCE {
 *   version  INTEGER {v3(3)}(v3,...),
 *   authSafe ContentInfo,
 *   macData  MacData OPTIONAL
 * }
 *
 * MacData ::= SEQUENCE {
 *   mac DigestInfo,
 *   macSalt OCTET STRING,
 *   iterations INTEGER DEFAULT 1
 * }
 * Note: The iterations default is for historical reasons and its use is
 * deprecated. A higher value, like 1024, is recommended.
 *
 * DigestInfo is defined in PKCS#7 as follows:
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of SHA1 there is none.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * Digest ::= OCTET STRING
 *
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType ContentType,
 *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * AuthenticatedSafe ::= SEQUENCE OF ContentInfo
 * -- Data if unencrypted
 * -- EncryptedData if password-encrypted
 * -- EnvelopedData if public key-encrypted
 *
 *
 * SafeContents ::= SEQUENCE OF SafeBag
 *
 * SafeBag ::= SEQUENCE {
 *   bagId     BAG-TYPE.&id ({PKCS12BagSet})
 *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),
 *   bagAttributes SET OF PKCS12Attribute OPTIONAL
 * }
 *
 * PKCS12Attribute ::= SEQUENCE {
 *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),
 *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})
 * } -- This type is compatible with the X.500 type Attribute
 *
 * PKCS12AttrSet ATTRIBUTE ::= {
 *   friendlyName | -- from PKCS #9
 *   localKeyId, -- from PKCS #9
 *   ... -- Other attributes are allowed
 * }
 *
 * CertBag ::= SEQUENCE {
 *   certId    BAG-TYPE.&id   ({CertTypes}),
 *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})
 * }
 *
 * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}
 *   -- DER-encoded X.509 certificate stored in OCTET STRING
 *
 * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}
 * -- Base64-encoded SDSI certificate stored in IA5String
 *
 * CertTypes BAG-TYPE ::= {
 *   x509Certificate |
 *   sdsiCertificate,
 *   ... -- For future extensions
 * }
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(14);__webpack_require__(3);__webpack_require__(29);__webpack_require__(9);__webpack_require__(5);__webpack_require__(6);__webpack_require__(17);__webpack_require__(1);__webpack_require__(18);// shortcut for asn.1 & PKI API
var asn1=forge.asn1;var pki=forge.pki;// shortcut for PKCS#12 API
var p12=module.exports=forge.pkcs12=forge.pkcs12||{};var contentInfoValidator={name:'ContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// a ContentInfo
constructed:true,value:[{name:'ContentInfo.contentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'ContentInfo.content',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,captureAsn1:'content'}]};var pfxValidator={name:'PFX',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PFX.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},contentInfoValidator,{name:'PFX.macData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,captureAsn1:'mac',value:[{name:'PFX.macData.mac',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// DigestInfo
constructed:true,value:[{name:'PFX.macData.mac.digestAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// DigestAlgorithmIdentifier
constructed:true,value:[{name:'PFX.macData.mac.digestAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'macAlgorithm'},{name:'PFX.macData.mac.digestAlgorithm.parameters',tagClass:asn1.Class.UNIVERSAL,captureAsn1:'macAlgorithmParameters'}]},{name:'PFX.macData.mac.digest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'macDigest'}]},{name:'PFX.macData.macSalt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'macSalt'},{name:'PFX.macData.iterations',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,optional:true,capture:'macIterations'}]}]};var safeBagValidator={name:'SafeBag',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SafeBag.bagId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'bagId'},{name:'SafeBag.bagValue',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,captureAsn1:'bagValue'},{name:'SafeBag.bagAttributes',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,optional:true,capture:'bagAttributes'}]};var attributeValidator={name:'Attribute',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Attribute.attrId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'oid'},{name:'Attribute.attrValues',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,capture:'values'}]};var certBagValidator={name:'CertBag',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'CertBag.certId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certId'},{name:'CertBag.certValue',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,/* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */value:[{name:'CertBag.certValue[0]',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.OCTETSTRING,constructed:false,capture:'cert'}]}]};/**
 * Search SafeContents structure for bags with matching attributes.
 *
 * The search can optionally be narrowed by a certain bag type.
 *
 * @param safeContents the SafeContents structure to search in.
 * @param attrName the name of the attribute to compare against.
 * @param attrValue the attribute value to search for.
 * @param [bagType] bag type to narrow search by.
 *
 * @return an array of matching bags.
 */function _getBagsByAttribute(safeContents,attrName,attrValue,bagType){var result=[];for(var i=0;i<safeContents.length;i++){for(var j=0;j<safeContents[i].safeBags.length;j++){var bag=safeContents[i].safeBags[j];if(bagType!==undefined&&bag.type!==bagType){continue;}// only filter by bag type, no attribute specified
if(attrName===null){result.push(bag);continue;}if(bag.attributes[attrName]!==undefined&&bag.attributes[attrName].indexOf(attrValue)>=0){result.push(bag);}}}return result;}/**
 * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.
 *
 * @param obj The PKCS#12 PFX in ASN.1 notation.
 * @param strict true to use strict DER decoding, false not to (default: true).
 * @param {String} password Password to decrypt with (optional).
 *
 * @return PKCS#12 PFX object.
 */p12.pkcs12FromAsn1=function(obj,strict,password){// handle args
if(typeof strict==='string'){password=strict;strict=true;}else if(strict===undefined){strict=true;}// validate PFX and capture data
var capture={};var errors=[];if(!asn1.validate(obj,pfxValidator,capture,errors)){var error=new Error('Cannot read PKCS#12 PFX. '+'ASN.1 object is not an PKCS#12 PFX.');error.errors=error;throw error;}var pfx={version:capture.version.charCodeAt(0),safeContents:[],/**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */getBags:function getBags(filter){var rval={};var localKeyId;if('localKeyId'in filter){localKeyId=filter.localKeyId;}else if('localKeyIdHex'in filter){localKeyId=forge.util.hexToBytes(filter.localKeyIdHex);}// filter on bagType only
if(localKeyId===undefined&&!('friendlyName'in filter)&&'bagType'in filter){rval[filter.bagType]=_getBagsByAttribute(pfx.safeContents,null,null,filter.bagType);}if(localKeyId!==undefined){rval.localKeyId=_getBagsByAttribute(pfx.safeContents,'localKeyId',localKeyId,filter.bagType);}if('friendlyName'in filter){rval.friendlyName=_getBagsByAttribute(pfx.safeContents,'friendlyName',filter.friendlyName,filter.bagType);}return rval;},/**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */getBagsByFriendlyName:function getBagsByFriendlyName(friendlyName,bagType){return _getBagsByAttribute(pfx.safeContents,'friendlyName',friendlyName,bagType);},/**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */getBagsByLocalKeyId:function getBagsByLocalKeyId(localKeyId,bagType){return _getBagsByAttribute(pfx.safeContents,'localKeyId',localKeyId,bagType);}};if(capture.version.charCodeAt(0)!==3){var error=new Error('PKCS#12 PFX of version other than 3 not supported.');error.version=capture.version.charCodeAt(0);throw error;}if(asn1.derToOid(capture.contentType)!==pki.oids.data){var error=new Error('Only PKCS#12 PFX in password integrity mode supported.');error.oid=asn1.derToOid(capture.contentType);throw error;}var data=capture.content.value[0];if(data.tagClass!==asn1.Class.UNIVERSAL||data.type!==asn1.Type.OCTETSTRING){throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');}data=_decodePkcs7Data(data);// check for MAC
if(capture.mac){var md=null;var macKeyBytes=0;var macAlgorithm=asn1.derToOid(capture.macAlgorithm);switch(macAlgorithm){case pki.oids.sha1:md=forge.md.sha1.create();macKeyBytes=20;break;case pki.oids.sha256:md=forge.md.sha256.create();macKeyBytes=32;break;case pki.oids.sha384:md=forge.md.sha384.create();macKeyBytes=48;break;case pki.oids.sha512:md=forge.md.sha512.create();macKeyBytes=64;break;case pki.oids.md5:md=forge.md.md5.create();macKeyBytes=16;break;}if(md===null){throw new Error('PKCS#12 uses unsupported MAC algorithm: '+macAlgorithm);}// verify MAC (iterations default to 1)
var macSalt=new forge.util.ByteBuffer(capture.macSalt);var macIterations='macIterations'in capture?parseInt(forge.util.bytesToHex(capture.macIterations),16):1;var macKey=p12.generateKey(password,macSalt,3,macIterations,macKeyBytes,md);var mac=forge.hmac.create();mac.start(md,macKey);mac.update(data.value);var macValue=mac.getMac();if(macValue.getBytes()!==capture.macDigest){throw new Error('PKCS#12 MAC could not be verified. Invalid password?');}}_decodeAuthenticatedSafe(pfx,data.value,strict,password);return pfx;};/**
 * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines "Data" as an OCTET STRING,
 * but it is sometimes an OCTET STRING that is composed/constructed of chunks,
 * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This
 * function transforms this corner-case into the usual simple,
 * non-composed/constructed OCTET STRING.
 *
 * This function may be moved to ASN.1 at some point to better deal with
 * more BER-encoding issues, should they arise.
 *
 * @param data the ASN.1 Data object to transform.
 */function _decodePkcs7Data(data){// handle special case of "chunked" data content: an octet string composed
// of other octet strings
if(data.composed||data.constructed){var value=forge.util.createBuffer();for(var i=0;i<data.value.length;++i){value.putBytes(data.value[i].value);}data.composed=data.constructed=false;data.value=value.getBytes();}return data;}/**
 * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.
 *
 * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.
 *
 * @param pfx The PKCS#12 PFX object to fill.
 * @param {String} authSafe BER-encoded AuthenticatedSafe.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 */function _decodeAuthenticatedSafe(pfx,authSafe,strict,password){authSafe=asn1.fromDer(authSafe,strict);/* actually it's BER encoded */if(authSafe.tagClass!==asn1.Class.UNIVERSAL||authSafe.type!==asn1.Type.SEQUENCE||authSafe.constructed!==true){throw new Error('PKCS#12 AuthenticatedSafe expected to be a '+'SEQUENCE OF ContentInfo');}for(var i=0;i<authSafe.value.length;i++){var contentInfo=authSafe.value[i];// validate contentInfo and capture data
var capture={};var errors=[];if(!asn1.validate(contentInfo,contentInfoValidator,capture,errors)){var error=new Error('Cannot read ContentInfo.');error.errors=errors;throw error;}var obj={encrypted:false};var safeContents=null;var data=capture.content.value[0];switch(asn1.derToOid(capture.contentType)){case pki.oids.data:if(data.tagClass!==asn1.Class.UNIVERSAL||data.type!==asn1.Type.OCTETSTRING){throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');}safeContents=_decodePkcs7Data(data).value;break;case pki.oids.encryptedData:safeContents=_decryptSafeContents(data,password);obj.encrypted=true;break;default:var error=new Error('Unsupported PKCS#12 contentType.');error.contentType=asn1.derToOid(capture.contentType);throw error;}obj.safeBags=_decodeSafeContents(safeContents,strict,password);pfx.safeContents.push(obj);}}/**
 * Decrypt PKCS#7 EncryptedData structure.
 *
 * @param data ASN.1 encoded EncryptedContentInfo object.
 * @param password The user-provided password.
 *
 * @return The decrypted SafeContents (ASN.1 object).
 */function _decryptSafeContents(data,password){var capture={};var errors=[];if(!asn1.validate(data,forge.pkcs7.asn1.encryptedDataValidator,capture,errors)){var error=new Error('Cannot read EncryptedContentInfo.');error.errors=errors;throw error;}var oid=asn1.derToOid(capture.contentType);if(oid!==pki.oids.data){var error=new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');error.oid=oid;throw error;}// get cipher
oid=asn1.derToOid(capture.encAlgorithm);var cipher=pki.pbe.getCipher(oid,capture.encParameter,password);// get encrypted data
var encryptedContentAsn1=_decodePkcs7Data(capture.encryptedContentAsn1);var encrypted=forge.util.createBuffer(encryptedContentAsn1.value);cipher.update(encrypted);if(!cipher.finish()){throw new Error('Failed to decrypt PKCS#12 SafeContents.');}return cipher.output.getBytes();}/**
 * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.
 *
 * The safeContents is a BER-encoded SEQUENCE OF SafeBag.
 *
 * @param {String} safeContents BER-encoded safeContents.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 *
 * @return {Array} Array of Bag objects.
 */function _decodeSafeContents(safeContents,strict,password){// if strict and no safe contents, return empty safes
if(!strict&&safeContents.length===0){return[];}// actually it's BER-encoded
safeContents=asn1.fromDer(safeContents,strict);if(safeContents.tagClass!==asn1.Class.UNIVERSAL||safeContents.type!==asn1.Type.SEQUENCE||safeContents.constructed!==true){throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');}var res=[];for(var i=0;i<safeContents.value.length;i++){var safeBag=safeContents.value[i];// validate SafeBag and capture data
var capture={};var errors=[];if(!asn1.validate(safeBag,safeBagValidator,capture,errors)){var error=new Error('Cannot read SafeBag.');error.errors=errors;throw error;}/* Create bag object and push to result array. */var bag={type:asn1.derToOid(capture.bagId),attributes:_decodeBagAttributes(capture.bagAttributes)};res.push(bag);var validator,decoder;var bagAsn1=capture.bagValue.value[0];switch(bag.type){case pki.oids.pkcs8ShroudedKeyBag:/* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.
           Afterwards we can handle it like a keyBag,
           which is a PrivateKeyInfo. */bagAsn1=pki.decryptPrivateKeyInfo(bagAsn1,password);if(bagAsn1===null){throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');}/* fall through */case pki.oids.keyBag:/* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our
           PKI module, hence we don't have to do validation/capturing here,
           just pass what we already got. */try{bag.key=pki.privateKeyFromAsn1(bagAsn1);}catch(e){// ignore unknown key type, pass asn1 value
bag.key=null;bag.asn1=bagAsn1;}continue;/* Nothing more to do. */case pki.oids.certBag:/* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.
           Therefore put the SafeBag content through another validator to
           capture the fields.  Afterwards check & store the results. */validator=certBagValidator;decoder=function decoder(){if(asn1.derToOid(capture.certId)!==pki.oids.x509Certificate){var error=new Error('Unsupported certificate type, only X.509 supported.');error.oid=asn1.derToOid(capture.certId);throw error;}// true=produce cert hash
var certAsn1=asn1.fromDer(capture.cert,strict);try{bag.cert=pki.certificateFromAsn1(certAsn1,true);}catch(e){// ignore unknown cert type, pass asn1 value
bag.cert=null;bag.asn1=certAsn1;}};break;default:var error=new Error('Unsupported PKCS#12 SafeBag type.');error.oid=bag.type;throw error;}/* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */if(validator!==undefined&&!asn1.validate(bagAsn1,validator,capture,errors)){var error=new Error('Cannot read PKCS#12 '+validator.name);error.errors=errors;throw error;}/* Call decoder function from above to store the results. */decoder();}return res;}/**
 * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.
 *
 * @param attributes SET OF PKCS12Attribute (ASN.1 object).
 *
 * @return the decoded attributes.
 */function _decodeBagAttributes(attributes){var decodedAttrs={};if(attributes!==undefined){for(var i=0;i<attributes.length;++i){var capture={};var errors=[];if(!asn1.validate(attributes[i],attributeValidator,capture,errors)){var error=new Error('Cannot read PKCS#12 BagAttribute.');error.errors=errors;throw error;}var oid=asn1.derToOid(capture.oid);if(pki.oids[oid]===undefined){// unsupported attribute type, ignore.
continue;}decodedAttrs[pki.oids[oid]]=[];for(var j=0;j<capture.values.length;++j){decodedAttrs[pki.oids[oid]].push(capture.values[j].value);}}}return decodedAttrs;}/**
 * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a
 * password is provided then the private key will be encrypted.
 *
 * An entire certificate chain may also be included. To do this, pass
 * an array for the "cert" parameter where the first certificate is
 * the one that is paired with the private key and each subsequent one
 * verifies the previous one. The certificates may be in PEM format or
 * have been already parsed by Forge.
 *
 * @todo implement password-based-encryption for the whole package
 *
 * @param key the private key.
 * @param cert the certificate (may be an array of certificates in order
 *          to specify a certificate chain).
 * @param password the password to use, null for none.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          useMac true to include a MAC, false not to, defaults to true.
 *          localKeyId the local key ID to use, in hex.
 *          friendlyName the friendly name to use.
 *          generateLocalKeyId true to generate a random local key ID,
 *            false not to, defaults to true.
 *
 * @return the PKCS#12 PFX ASN.1 object.
 */p12.toPkcs12Asn1=function(key,cert,password,options){// set default options
options=options||{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||options.encAlgorithm||'aes128';if(!('useMac'in options)){options.useMac=true;}if(!('localKeyId'in options)){options.localKeyId=null;}if(!('generateLocalKeyId'in options)){options.generateLocalKeyId=true;}var localKeyId=options.localKeyId;var bagAttrs;if(localKeyId!==null){localKeyId=forge.util.hexToBytes(localKeyId);}else if(options.generateLocalKeyId){// use SHA-1 of paired cert, if available
if(cert){var pairedCert=forge.util.isArray(cert)?cert[0]:cert;if(typeof pairedCert==='string'){pairedCert=pki.certificateFromPem(pairedCert);}var sha1=forge.md.sha1.create();sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());localKeyId=sha1.digest().getBytes();}else{// FIXME: consider using SHA-1 of public key (which can be generated
// from private key components), see: cert.generateSubjectKeyIdentifier
// generate random bytes
localKeyId=forge.random.getBytes(20);}}var attrs=[];if(localKeyId!==null){attrs.push(// localKeyID
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// attrId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.localKeyId).getBytes()),// attrValues
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,localKeyId)])]));}if('friendlyName'in options){attrs.push(// friendlyName
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// attrId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.friendlyName).getBytes()),// attrValues
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BMPSTRING,false,options.friendlyName)])]));}if(attrs.length>0){bagAttrs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,attrs);}// collect contents for AuthenticatedSafe
var contents=[];// create safe bag(s) for certificate chain
var chain=[];if(cert!==null){if(forge.util.isArray(cert)){chain=cert;}else{chain=[cert];}}var certSafeBags=[];for(var i=0;i<chain.length;++i){// convert cert from PEM as necessary
cert=chain[i];if(typeof cert==='string'){cert=pki.certificateFromPem(cert);}// SafeBag
var certBagAttrs=i===0?bagAttrs:undefined;var certAsn1=pki.certificateToAsn1(cert);var certSafeBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.certBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// CertBag
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// certId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.x509Certificate).getBytes()),// certValue (x509Certificate)
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(certAsn1).getBytes())])])]),// bagAttributes (OPTIONAL)
certBagAttrs]);certSafeBags.push(certSafeBag);}if(certSafeBags.length>0){// SafeContents
var certSafeContents=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,certSafeBags);// ContentInfo
var certCI=// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(certSafeContents).getBytes())])]);contents.push(certCI);}// create safe contents for private key
var keyBag=null;if(key!==null){// SafeBag
var pkAsn1=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));if(password===null){// no encryption
keyBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.keyBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// PrivateKeyInfo
pkAsn1]),// bagAttributes (OPTIONAL)
bagAttrs]);}else{// encrypted PrivateKeyInfo
keyBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// EncryptedPrivateKeyInfo
pki.encryptPrivateKeyInfo(pkAsn1,password,options)]),// bagAttributes (OPTIONAL)
bagAttrs]);}// SafeContents
var keySafeContents=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[keyBag]);// ContentInfo
var keyCI=// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(keySafeContents).getBytes())])]);contents.push(keyCI);}// create AuthenticatedSafe by stringing together the contents
var safe=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,contents);var macData;if(options.useMac){// MacData
var sha1=forge.md.sha1.create();var macSalt=new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));var count=options.count;// 160-bit key
var key=p12.generateKey(password,macSalt,3,count,20);var mac=forge.hmac.create();mac.start(sha1,key);mac.update(asn1.toDer(safe).getBytes());var macValue=mac.getMac();macData=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// mac DigestInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// digestAlgorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm = SHA-1
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.sha1).getBytes()),// parameters = Null
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// digest
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,macValue.getBytes())]),// macSalt OCTET STRING
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,macSalt.getBytes()),// iterations INTEGER (XXX: Only support count < 65536)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(count).getBytes())]);}// PFX
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (3)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(3).getBytes()),// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(safe).getBytes())])]),macData]);};/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */p12.generateKey=forge.pbe.generatePkcs12Key;/***/},/* 29 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
 *
 * @author Dave Longley
 * @author Stefan Siegl
 *
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#7 is as follows
 * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
 *
 * A PKCS#7 message consists of a ContentInfo on root level, which may
 * contain any number of further ContentInfo nested into it.
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType                ContentType,
 *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * EnvelopedData ::= SEQUENCE {
 *   version                    Version,
 *   recipientInfos             RecipientInfos,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * EncryptedData ::= SEQUENCE {
 *   version                    Version,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
 *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
 *
 * SignedData ::= SEQUENCE {
 *   version           INTEGER,
 *   digestAlgorithms  DigestAlgorithmIdentifiers,
 *   contentInfo       ContentInfo,
 *   certificates      [0] IMPLICIT Certificates OPTIONAL,
 *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos       SignerInfos
 * }
 *
 * SignerInfos ::= SET OF SignerInfo
 *
 * SignerInfo ::= SEQUENCE {
 *   version                    Version,
 *   issuerAndSerialNumber      IssuerAndSerialNumber,
 *   digestAlgorithm            DigestAlgorithmIdentifier,
 *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
 *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
 *   encryptedDigest            EncryptedDigest,
 *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
 * }
 *
 * EncryptedDigest ::= OCTET STRING
 *
 * Attributes ::= SET OF Attribute
 *
 * Attribute ::= SEQUENCE {
 *   attrType    OBJECT IDENTIFIER,
 *   attrValues  SET OF AttributeValue
 * }
 *
 * AttributeValue ::= ANY
 *
 * Version ::= INTEGER
 *
 * RecipientInfos ::= SET OF RecipientInfo
 *
 * EncryptedContentInfo ::= SEQUENCE {
 *   contentType                 ContentType,
 *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
 *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
 * }
 *
 * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of AES and DES3, there is only one,
 * the IV.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * EncryptedContent ::= OCTET STRING
 *
 * RecipientInfo ::= SEQUENCE {
 *   version                     Version,
 *   issuerAndSerialNumber       IssuerAndSerialNumber,
 *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
 *   encryptedKey                EncryptedKey
 * }
 *
 * IssuerAndSerialNumber ::= SEQUENCE {
 *   issuer                      Name,
 *   serialNumber                CertificateSerialNumber
 * }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedKey ::= OCTET STRING
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(1);// shortcut for ASN.1 API
var asn1=forge.asn1;// shortcut for PKCS#7 API
var p7v=module.exports=forge.pkcs7asn1=forge.pkcs7asn1||{};forge.pkcs7=forge.pkcs7||{};forge.pkcs7.asn1=p7v;var contentInfoValidator={name:'ContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'ContentInfo.ContentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'ContentInfo.content',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,captureAsn1:'content'}]};p7v.contentInfoValidator=contentInfoValidator;var encryptedContentInfoValidator={name:'EncryptedContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedContentInfo.contentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'EncryptedContentInfo.contentEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encAlgorithm'},{name:'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,captureAsn1:'encParameter'}]},{name:'EncryptedContentInfo.encryptedContent',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,/* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */capture:'encryptedContent',captureAsn1:'encryptedContentAsn1'}]};p7v.envelopedDataValidator={name:'EnvelopedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EnvelopedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'EnvelopedData.RecipientInfos',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,captureAsn1:'recipientInfos'}].concat(encryptedContentInfoValidator)};p7v.encryptedDataValidator={name:'EncryptedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'}].concat(encryptedContentInfoValidator)};var signerValidator={name:'SignerInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false},{name:'SignerInfo.issuerAndSerialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.issuerAndSerialNumber.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'issuer'},{name:'SignerInfo.issuerAndSerialNumber.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'serial'}]},{name:'SignerInfo.digestAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.digestAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'digestAlgorithm'},{name:'SignerInfo.digestAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,constructed:false,captureAsn1:'digestParameter',optional:true}]},{name:'SignerInfo.authenticatedAttributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,capture:'authenticatedAttributes'},{name:'SignerInfo.digestEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,capture:'signatureAlgorithm'},{name:'SignerInfo.encryptedDigest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'signature'},{name:'SignerInfo.unauthenticatedAttributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,optional:true,capture:'unauthenticatedAttributes'}]};p7v.signedDataValidator={name:'SignedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'SignedData.DigestAlgorithms',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,captureAsn1:'digestAlgorithms'},contentInfoValidator,{name:'SignedData.Certificates',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,optional:true,captureAsn1:'certificates'},{name:'SignedData.CertificateRevocationLists',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,optional:true,captureAsn1:'crls'},{name:'SignedData.SignerInfos',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,capture:'signerInfos',optional:true,value:[signerValidator]}]};p7v.recipientInfoValidator={name:'RecipientInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'RecipientInfo.issuerAndSerial',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.issuerAndSerial.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'issuer'},{name:'RecipientInfo.issuerAndSerial.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'serial'}]},{name:'RecipientInfo.keyEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.keyEncryptionAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encAlgorithm'},{name:'RecipientInfo.keyEncryptionAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,constructed:false,captureAsn1:'encParameter'}]},{name:'RecipientInfo.encryptedKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encKey'}]};/***/},/* 30 */ /***/function(module,exports,__webpack_require__){/**
 * Node.js module for Forge mask generation functions.
 *
 * @author Stefan Siegl
 *
 * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
 */var forge=__webpack_require__(0);__webpack_require__(31);module.exports=forge.mgf=forge.mgf||{};forge.mgf.mgf1=forge.mgf1;/***/},/* 31 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of mask generation function MGF1.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);forge.mgf=forge.mgf||{};var mgf1=module.exports=forge.mgf.mgf1=forge.mgf1=forge.mgf1||{};/**
 * Creates a MGF1 mask generation function object.
 *
 * @param md the message digest API to use (eg: forge.md.sha1.create()).
 *
 * @return a mask generation function object.
 */mgf1.create=function(md){var mgf={/**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */generate:function generate(seed,maskLen){/* 2. Let T be the empty octet string. */var t=new forge.util.ByteBuffer();/* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */var len=Math.ceil(maskLen/md.digestLength);for(var i=0;i<len;i++){/* a. Convert counter to an octet string C of length 4 octets */var c=new forge.util.ByteBuffer();c.putInt32(i);/* b. Concatenate the hash of the seed mgfSeed and C to the octet
         * string T: */md.start();md.update(seed+c.getBytes());t.putBuffer(md.digest());}/* Output the leading maskLen octets of T as the octet string mask. */t.truncate(t.length()-maskLen);return t.getBytes();}};return mgf;};/***/}]));});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHVuZ2FwL3VybC1zZWFyY2gtcGFyYW1zL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zLWV4dGVuc2lvbnMvZXNtL2NhY2hlQWRhcHRlckVuaGFuY2VyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MtZXh0ZW5zaW9ucy9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy1leHRlbnNpb25zL2VzbS90aHJvdHRsZUFkYXB0ZXJFbmhhbmNlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zLWV4dGVuc2lvbnMvZXNtL3V0aWxzL2J1aWxkU29ydGVkVVJMLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MtZXh0ZW5zaW9ucy9lc20vdXRpbHMvaXNDYWNoZUxpa2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191c2VyLWFnZW50LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvanNlbmNyeXB0L2Jpbi9qc2VuY3J5cHQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9wcm9taXNlLXdpbmRvdy9kaXN0L3Byb21pc2Utd2luZG93LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHNldWRvbWFwL21hcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3BzZXVkb21hcC9wc2V1ZG9tYXAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Lyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Lyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL2Rpc2NvdXJzZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL2Rpc2NvdXJzZUFwaS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL2Rpc2NvdXJzZUF1dGguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL3NyYy9rZXlHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL3NyYy9rZXlNYW5hZ2VyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9zcmMvdmVuZG9yL2ZvcmdlLXBraS5qcyJdLCJuYW1lcyI6WyJEaXNjb3Vyc2VDbGllbnQiLCJvcHRpb25zIiwiX3JlcXVpcmVPcHRpb25zIiwiX2Zvcm1hdE9wdGlvbnMiLCJhdXRoIiwiRGlzY291cnNlQXV0aCIsImFwaSIsIkRpc2NvdXJzZUFwaSIsImFwaUJhc2VVcmwiLCJpbml0IiwiRXJyb3IiLCJhcHBOYW1lIiwibGVuZ3RoIiwic2NvcGVzIiwiQXJyYXkiLCJmb3JtYXR0ZWRPcHRpb25zIiwicmVwbGFjZSIsImpvaW4iLCJfaGFzVXNlckFwaUtleSIsIl9yZWZyZXNoQ3VycmVudFVzZXIiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZ2V0Q3VycmVudFVzZXIiLCJzaXplIiwiZ2V0Q3VycmVudFVzZXJOYW1lIiwiZ2V0Q3VycmVudFNlc3Npb25Vc2VyIiwic3RyaW5naWZ5Iiwic2V0SXRlbSIsImxvZ291dCIsImlzTG9nZ2VkSW4iLCJQcm9taXNlV2luZG93IiwiX2dldExvZ2luVXJsIiwid2lkdGgiLCJoZWlnaHQiLCJvcmlnaW5SZWdleHAiLCJSZWdFeHAiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImRhdGEiLCJfc2V0VXNlckFwaUtleSIsInJlc3VsdCIsImtleSIsImVycm9yIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50Iiwib3BlbiIsInRoZW4iLCJfY2xlYXJBdXRoRGF0YSIsIndpbmRvdyIsImF4aW9zIiwiY3JlYXRlIiwiYmFzZVVSTCIsImhlYWRlcnMiLCJhZGFwdGVyIiwiZGVmYXVsdHMiLCJ0aHJlc2hvbGQiLCJlbmRwb2ludCIsInByb3AiLCJub2NhY2hlIiwiZ2V0IiwiZm9yY2VVcGRhdGUiLCJyZXNwb25zZSIsInNwbGl0IiwicmVkdWNlIiwicmV0dXJuZWRSZXNwb25zZSIsImN1cnJlbnRQcm9wIiwicGF5bG9hZCIsInBvc3QiLCJ1c2VyQXBpS2V5IiwiY29tbW9uIiwiX3NldENzcmZUb2tlbiIsIl9nZXRDYWxsUmVzdWx0IiwiZGVzY2VuZGluZyIsInBvc3RzIiwicmV2ZXJzZSIsImZpbHRlciIsInBvc3RfdHlwZSIsInRvcGljSWQiLCJ0b3BpYyIsInBvc3Rfc3RyZWFtIiwidXNlcm5hbWUiLCJtZXNzYWdlIiwiX2VuZm9yY2VVc2VyQXBpS2V5IiwiX3Bvc3RDYWxsUmVzdWx0IiwidG9waWNfaWQiLCJyYXciLCJoaWRkZW4iLCJQcm9taXNlIiwicmVqZWN0IiwiaGlkZGVuX3JlYXNvbl9pZCIsImNhdGNoIiwiZXJyb3JzIiwiYXBwSWQiLCJfc2x1Z2lmeSIsImttIiwiS2V5TWFuYWdlciIsImdldEtleXMiLCJfbWFuYWdlUGF5bG9hZCIsImdldFB1YmxpY0tleSIsIl9nZW5lcmF0ZVN0b3JlZFJhbmRvbSIsIl9nZXRTdG9yZWRSYW5kb20iLCJocmVmIiwicGFyYW1zIiwiYXBwbGljYXRpb25fbmFtZSIsInB1YmxpY19rZXkiLCJub25jZSIsImNsaWVudF9pZCIsImF1dGhfcmVkaXJlY3QiLCJfc2VyaWFsaXplUGFyYW1zIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsImsiLCJlbmNvZGVVUklDb21wb25lbnQiLCJuYW1lIiwic3RvcmVkUmFuZG9tIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwicmVtb3ZlSXRlbSIsIl9yZW1vdmVTdG9yZWRSYW5kb20iLCJ1cmwiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJoYXNoIiwiaGFzIiwib3BlbmVyIiwiZGVjcnlwdFBheWxvYWQiLCJwYXlsb2FkT2JqZWN0IiwicG9zdE1lc3NhZ2UiLCJ0ZXh0IiwidG9Mb3dlckNhc2UiLCJmb3JnZSIsInJlcXVpcmUiLCJnZW5lcmF0ZSIsInJlc29sdmUiLCJyc2EiLCJnZW5lcmF0ZUtleVBhaXIiLCJ3b3JrZXJTY3JpcHQiLCJnZW5lcmF0ZWRLZXlwYWlyIiwia2V5cGFpciIsInB1YmxpYyIsInBraSIsInB1YmxpY0tleVRvUGVtIiwicHVibGljS2V5IiwicHJpdmF0ZSIsInByaXZhdGVLZXlUb1BlbSIsInByaXZhdGVLZXkiLCJrZXlHZW5lcmF0b3IiLCJkZWZhdWx0IiwicmVhZEtleXNGcm9tU3RvcmFnZSIsImdlbmVyYXRlTmV3S2V5cGFpciIsImdldFByaXZhdGVLZXkiLCJKc2VuY3J5cHQiLCJqc2VuY3J5cHQiLCJzZXRQcml2YXRlS2V5IiwiZGVjcnlwdCIsIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwic2VsZiIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwiZ2V0dGVyIiwibyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIm4iLCJfX2VzTW9kdWxlIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJ1c2VQdXJlSmF2YVNjcmlwdCIsImJhc2VOIiwidXRpbCIsInByb2Nlc3MiLCJuZXh0VGljayIsImJyb3dzZXIiLCJzZXRJbW1lZGlhdGUiLCJhcHBseSIsInVuZGVmaW5lZCIsImFyZ3VtZW50cyIsImNhbGxiYWNrIiwic2V0VGltZW91dCIsImhhbmRsZXIiLCJldmVudCIsInNvdXJjZSIsIm1zZyIsInN0b3BQcm9wYWdhdGlvbiIsImNvcHkiLCJjYWxsYmFja3MiLCJzbGljZSIsImZvckVhY2giLCJwdXNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJub3ciLCJEYXRlIiwiYXR0ciIsImRpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwib2xkU2V0SW1tZWRpYXRlIiwic2V0QXR0cmlidXRlIiwiaXNOb2RlanMiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJpc0FycmF5IiwieCIsImlzQXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImlzQXJyYXlCdWZmZXJWaWV3IiwiYnVmZmVyIiwiYnl0ZUxlbmd0aCIsIl9jaGVja0JpdHNQYXJhbSIsIkJ5dGVCdWZmZXIiLCJCeXRlU3RyaW5nQnVmZmVyIiwiYiIsInJlYWQiLCJCdWZmZXIiLCJhcnIiLCJVaW50OEFycmF5IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZSIsInB1dEJ5dGUiLCJfY29uc3RydWN0ZWRTdHJpbmdMZW5ndGgiLCJfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEgiLCJfb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyIsImlzRW1wdHkiLCJwdXRCeXRlcyIsImZpbGxXaXRoQnl0ZSIsImJ5dGVzIiwicHV0U3RyaW5nIiwic3RyIiwiZW5jb2RlVXRmOCIsInB1dEludDE2IiwicHV0SW50MjQiLCJwdXRJbnQzMiIsInB1dEludDE2TGUiLCJwdXRJbnQyNExlIiwicHV0SW50MzJMZSIsInB1dEludCIsInB1dFNpZ25lZEludCIsInB1dEJ1ZmZlciIsImdldEJ5dGVzIiwiZ2V0Qnl0ZSIsImNoYXJDb2RlQXQiLCJnZXRJbnQxNiIsInJ2YWwiLCJnZXRJbnQyNCIsImdldEludDMyIiwiZ2V0SW50MTZMZSIsImdldEludDI0TGUiLCJnZXRJbnQzMkxlIiwiZ2V0SW50IiwiZ2V0U2lnbmVkSW50IiwibWF4IiwiY291bnQiLCJtaW4iLCJjbGVhciIsImF0Iiwic2V0QXQiLCJsYXN0IiwiY3JlYXRlQnVmZmVyIiwiY29tcGFjdCIsInRydW5jYXRlIiwibGVuIiwidG9IZXgiLCJkZWNvZGVVdGY4IiwiRGF0YUJ1ZmZlciIsInJlYWRPZmZzZXQiLCJncm93U2l6ZSIsIkRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsIndyaXRlIiwid3JpdGVPZmZzZXQiLCJhY2NvbW1vZGF0ZSIsImFtb3VudCIsInNyYyIsImRzdCIsInNldCIsInNldFVpbnQ4IiwiZW5jb2RpbmciLCJ2aWV3IiwiY2VpbCIsImJpbmFyeSIsImhleCIsImRlY29kZSIsImJhc2U2NCIsIlVpbnQxNkFycmF5IiwidXRmMTYiLCJlbmNvZGUiLCJzZXRJbnQxNiIsInNldEludDgiLCJzZXRJbnQzMiIsImdldEludDgiLCJnZXRVaW50OCIsInV0ZjgiLCJpbnB1dCIsImZpbGxTdHJpbmciLCJ4b3JCeXRlcyIsInMxIiwiczIiLCJzMyIsInQiLCJoZXhUb0J5dGVzIiwicGFyc2VJbnQiLCJieXRlc1RvSGV4IiwiaW50MzJUb0J5dGVzIiwiX2Jhc2U2NCIsIl9iYXNlNjRJZHgiLCJfYmFzZTU4IiwiZW5jb2RlNjQiLCJtYXhsaW5lIiwibGluZSIsIm91dHB1dCIsImNocjEiLCJjaHIyIiwiY2hyMyIsImNoYXJBdCIsImlzTmFOIiwiZGVjb2RlNjQiLCJlbmMxIiwiZW5jMiIsImVuYzMiLCJlbmM0IiwidW5lc2NhcGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJiYXNlNTgiLCJvZmZzZXQiLCJvdXQiLCJqIiwic3ViYXJyYXkiLCJkZWZsYXRlIiwic3RhcnQiLCJmbGciLCJzdWJzdHJpbmciLCJpbmZsYXRlIiwiX3NldFN0b3JhZ2VPYmplY3QiLCJpZCIsIm9iaiIsIl9nZXRTdG9yYWdlT2JqZWN0IiwiX3NldEl0ZW0iLCJfZ2V0SXRlbSIsIl9yZW1vdmVJdGVtIiwiZW1wdHkiLCJfY2xlYXJJdGVtcyIsIl9jYWxsU3RvcmFnZUZ1bmN0aW9uIiwiZnVuYyIsImFyZ3MiLCJ0eXBlIiwiZG9uZSIsImV4Y2VwdGlvbiIsImlkeCIsImV4IiwiY2xlYXJJdGVtcyIsInBhcnNlVXJsIiwicmVnZXgiLCJsYXN0SW5kZXgiLCJleGVjIiwiZnVsbCIsInNjaGVtZSIsImhvc3QiLCJwb3J0IiwicGF0aCIsImZ1bGxIb3N0IiwiX3F1ZXJ5VmFyaWFibGVzIiwiZ2V0UXVlcnlWYXJpYWJsZXMiLCJxdWVyeSIsInEiLCJrdnBhaXJzIiwicG9zIiwiaW5kZXhPZiIsInZhbCIsInBhcnNlRnJhZ21lbnQiLCJmcmFnbWVudCIsImZwIiwiZnEiLCJzaGlmdCIsInBhdGhTdHJpbmciLCJxdWVyeVN0cmluZyIsIm1ha2VSZXF1ZXN0IiwicmVxU3RyaW5nIiwiZnJhZyIsInJlcSIsImdldFBhdGgiLCJnZXRRdWVyeSIsImdldFF1ZXJ5TGFzdCIsIl9kZWZhdWx0IiwidmFscyIsIm1ha2VMaW5rIiwialF1ZXJ5IiwicXN0ciIsInBhcmFtIiwic2V0UGF0aCIsInZhbHVlIiwibmV4dCIsImhhc05leHQiLCJkZWxldGVQYXRoIiwiZm9ybWF0IiwicmUiLCJtYXRjaCIsInBhcnQiLCJhcmdpIiwicGFydHMiLCJjb2RlIiwiZm9ybWF0TnVtYmVyIiwibnVtYmVyIiwiZGVjaW1hbHMiLCJkZWNfcG9pbnQiLCJ0aG91c2FuZHNfc2VwIiwiYWJzIiwidG9GaXhlZCIsImZvcm1hdFNpemUiLCJieXRlc0Zyb21JUCIsImlwIiwiYnl0ZXNGcm9tSVB2NCIsImJ5dGVzRnJvbUlQdjYiLCJudW0iLCJibGFua3MiLCJ6ZXJvcyIsImJ5dGVzVG9JUCIsImJ5dGVzVG9JUHY0IiwiYnl0ZXNUb0lQdjYiLCJ6ZXJvR3JvdXBzIiwiemVyb01heEdyb3VwIiwiZW5kIiwiZ3JvdXAiLCJzcGxpY2UiLCJ1bnNoaWZ0IiwiZXN0aW1hdGVDb3JlcyIsInVwZGF0ZSIsImNvcmVzIiwibmF2aWdhdG9yIiwiaGFyZHdhcmVDb25jdXJyZW5jeSIsIldvcmtlciIsIkJsb2IiLCJibG9iVXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwic3QiLCJldCIsInNhbXBsZSIsInNhbXBsZXMiLCJudW1Xb3JrZXJzIiwiYXZnIiwiZmxvb3IiLCJyZXZva2VPYmplY3RVUkwiLCJlcnIiLCJyZXN1bHRzIiwid29ya2VycyIsIndvcmtlciIsInRlcm1pbmF0ZSIsIm92ZXJsYXBzIiwicjEiLCJvdmVybGFwIiwicjIiLCJhc24xIiwiQ2xhc3MiLCJVTklWRVJTQUwiLCJBUFBMSUNBVElPTiIsIkNPTlRFWFRfU1BFQ0lGSUMiLCJQUklWQVRFIiwiVHlwZSIsIk5PTkUiLCJCT09MRUFOIiwiSU5URUdFUiIsIkJJVFNUUklORyIsIk9DVEVUU1RSSU5HIiwiTlVMTCIsIk9JRCIsIk9ERVNDIiwiRVhURVJOQUwiLCJSRUFMIiwiRU5VTUVSQVRFRCIsIkVNQkVEREVEIiwiVVRGOCIsIlJPSUQiLCJTRVFVRU5DRSIsIlNFVCIsIlBSSU5UQUJMRVNUUklORyIsIklBNVNUUklORyIsIlVUQ1RJTUUiLCJHRU5FUkFMSVpFRFRJTUUiLCJCTVBTVFJJTkciLCJ0YWdDbGFzcyIsImNvbnN0cnVjdGVkIiwidG1wIiwiY29tcG9zZWQiLCJiaXRTdHJpbmdDb250ZW50cyIsIm9yaWdpbmFsIiwiZXhjbHVkZUJpdFN0cmluZ0NvbnRlbnRzIiwiZXF1YWxzIiwib2JqMSIsIm9iajIiLCJlcXVhbCIsImluY2x1ZGVCaXRTdHJpbmdDb250ZW50cyIsImdldEJlclZhbHVlTGVuZ3RoIiwiYjIiLCJsb25nRm9ybSIsIl9jaGVja0J1ZmZlckxlbmd0aCIsInJlbWFpbmluZyIsImF2YWlsYWJsZSIsInJlcXVlc3RlZCIsIl9nZXRWYWx1ZUxlbmd0aCIsImxvbmdGb3JtQnl0ZXMiLCJmcm9tRGVyIiwic3RyaWN0IiwiZGVjb2RlQml0U3RyaW5ncyIsIl9mcm9tRGVyIiwiZGVwdGgiLCJiMSIsInNhdmVkUmVhZCIsInNhdmVkUmVtYWluaW5nIiwidW51c2VkIiwic3ViT3B0aW9ucyIsInZlcmJvc2UiLCJ1c2VkIiwidGMiLCJhc24xT3B0aW9ucyIsInRvRGVyIiwidXNlQml0U3RyaW5nQ29udGVudHMiLCJsZW5CeXRlcyIsIm9pZFRvRGVyIiwib2lkIiwidmFsdWVzIiwidmFsdWVCeXRlcyIsImRlclRvT2lkIiwidXRjVGltZVRvRGF0ZSIsInV0YyIsImRhdGUiLCJ5ZWFyIiwiTU0iLCJERCIsImhoIiwibW0iLCJzcyIsInNldFVUQ0Z1bGxZZWFyIiwic2V0VVRDSG91cnMiLCJoaG9mZnNldCIsIm1tb2Zmc2V0Iiwic2V0VGltZSIsImdlbmVyYWxpemVkVGltZVRvRGF0ZSIsImdlbnRpbWUiLCJZWVlZIiwiZmZmIiwiaXNVVEMiLCJwYXJzZUZsb2F0Iiwic2V0RnVsbFllYXIiLCJzZXRIb3VycyIsImRhdGVUb1V0Y1RpbWUiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJkYXRlVG9HZW5lcmFsaXplZFRpbWUiLCJpbnRlZ2VyVG9EZXIiLCJpbnRlZ2VyIiwiZGVyVG9JbnRlZ2VyIiwidmFsaWRhdGUiLCJ2IiwiY2FwdHVyZSIsIm9wdGlvbmFsIiwiY2FwdHVyZUFzbjEiLCJjYXB0dXJlQml0U3RyaW5nQ29udGVudHMiLCJjYXB0dXJlQml0U3RyaW5nVmFsdWUiLCJfbm9uTGF0aW5SZWdleCIsInByZXR0eVByaW50IiwibGV2ZWwiLCJpbmRlbnRhdGlvbiIsImluZGVudCIsIklBNVN0cmluZyIsInN1YnZhbHVlcyIsInN1YiIsIm9pZHMiLCJ0ZXN0IiwiX0lOIiwiX0lfIiwibWQiLCJhbGdvcml0aG1zIiwicHJuZ19hZXMiLCJfcHJuZ19hZXNfb3V0cHV0IiwiX3BybmdfYWVzX2J1ZmZlciIsImZvcm1hdEtleSIsImFlcyIsIl9leHBhbmRLZXkiLCJmb3JtYXRTZWVkIiwic2VlZCIsImNpcGhlciIsIl91cGRhdGVCbG9jayIsImluY3JlbWVudCIsInNoYTI1NiIsInNwYXduUHJuZyIsImN0eCIsInBybmciLCJnZXRCeXRlc1N5bmMiLCJfY3R4IiwiZ2V0UmFuZG9tVmFsdWVzIiwiX2NyeXB0byIsImNyeXB0byIsIm1zQ3J5cHRvIiwiY29sbGVjdEludCIsIl9uYXZCeXRlcyIsImNvbGxlY3QiLCJtb3VzZW1vdmUiLCJjbGllbnRYIiwiY2xpZW50WSIsImtleXByZXNzIiwiY2hhckNvZGUiLCJjcmVhdGVJbnN0YW5jZSIsIkJpZ0ludGVnZXIiLCJqc2JuIiwiR0NEXzMwX0RFTFRBIiwicHJpdmF0ZUtleVZhbGlkYXRvciIsInJzYVByaXZhdGVLZXlWYWxpZGF0b3IiLCJyc2FQdWJsaWNLZXlWYWxpZGF0b3IiLCJwdWJsaWNLZXlWYWxpZGF0b3IiLCJlbXNhUGtjczF2MTVlbmNvZGUiLCJhbGdvcml0aG0iLCJvaWRCeXRlcyIsImRpZ2VzdEluZm8iLCJkaWdlc3RBbGdvcml0aG0iLCJkaWdlc3QiLCJfbW9kUG93IiwicHViIiwibW9kUG93IiwiZFAiLCJtb2QiLCJzdWJ0cmFjdCIsIk9ORSIsImRRIiwicUludiIsIm1vZEludmVyc2UiLCJyIiwiYml0TGVuZ3RoIiwiY29tcGFyZVRvIiwiZ2NkIiwibXVsdGlwbHkiLCJ4cCIsInhxIiwiYWRkIiwieSIsImVuY3J5cHQiLCJidCIsImViIiwiX2VuY29kZVBrY3MxX3YxXzUiLCJ5aGV4IiwiZWQiLCJtbCIsImV4cGVjdGVkIiwieGhleCIsIl9kZWNvZGVQa2NzMV92MV81IiwiY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZSIsImJpdHMiLCJybmciLCJuZXh0Qnl0ZXMiLCJzdGF0ZSIsImVJbnQiLCJxQml0cyIsInBCaXRzIiwicHFTdGF0ZSIsImZyb21JbnQiLCJzdGVwS2V5UGFpckdlbmVyYXRpb25TdGF0ZSIsIlRISVJUWSIsImRlbHRhSWR4Iiwib3Bfb3IiLCJ0MSIsInQyIiwidG90YWwiLCJiaXRzMSIsInRlc3RCaXQiLCJiaXR3aXNlVG8iLCJzaGlmdExlZnQiLCJkQWRkT2Zmc2V0IiwiYnl0ZVZhbHVlIiwiaXNQcm9iYWJsZVByaW1lIiwiX2dldE1pbGxlclJhYmluVGVzdHMiLCJwMSIsInExIiwicGhpIiwic2V0UHVibGljS2V5IiwiX2RldGVjdFN1YnRsZUNyeXB0byIsInN1YnRsZSIsImdlbmVyYXRlS2V5IiwibW9kdWx1c0xlbmd0aCIsInB1YmxpY0V4cG9uZW50IiwiX2ludFRvVWludDhBcnJheSIsInBhaXIiLCJleHBvcnRLZXkiLCJwa2NzOCIsInByaXZhdGVLZXlGcm9tQXNuMSIsInNldFJzYVB1YmxpY0tleSIsIl9kZXRlY3RTdWJ0bGVNc0NyeXB0byIsImdlbk9wIiwib25jb21wbGV0ZSIsInRhcmdldCIsImV4cG9ydE9wIiwib25lcnJvciIsIl9nZW5lcmF0ZUtleVBhaXIiLCJzY2hlbWVPcHRpb25zIiwidG9VcHBlckNhc2UiLCJwa2NzMSIsImVuY29kZV9yc2Ffb2FlcCIsInZlcmlmeSIsInNpZ25hdHVyZSIsInNldFJzYVByaXZhdGVLZXkiLCJkZWNvZGVfcnNhX29hZXAiLCJzaWduIiwid3JhcFJzYVByaXZhdGVLZXkiLCJyc2FLZXkiLCJyc2FFbmNyeXB0aW9uIiwicHJpdmF0ZUtleU1vZHVsdXMiLCJwcml2YXRlS2V5UHVibGljRXhwb25lbnQiLCJwcml2YXRlS2V5UHJpdmF0ZUV4cG9uZW50IiwicHJpdmF0ZUtleVByaW1lMSIsInByaXZhdGVLZXlQcmltZTIiLCJwcml2YXRlS2V5RXhwb25lbnQxIiwicHJpdmF0ZUtleUV4cG9uZW50MiIsInByaXZhdGVLZXlDb2VmZmljaWVudCIsInByaXZhdGVLZXlUb0FzbjEiLCJwcml2YXRlS2V5VG9SU0FQcml2YXRlS2V5IiwiX2JuVG9CeXRlcyIsInB1YmxpY0tleUZyb21Bc24xIiwicHVibGljS2V5T2lkIiwicnNhUHVibGljS2V5IiwicHVibGljS2V5TW9kdWx1cyIsInB1YmxpY0tleUV4cG9uZW50IiwicHVibGljS2V5VG9Bc24xIiwicHVibGljS2V5VG9TdWJqZWN0UHVibGljS2V5SW5mbyIsInB1YmxpY0tleVRvUlNBUHVibGljS2V5IiwicGFkTnVtIiwicGFkQnl0ZSIsIm51bVplcm9zIiwicGFkQnl0ZXMiLCJlbSIsImZpcnN0IiwiemVybyIsIm9wdHMiLCJ3b3JrTG9hZCIsImdldFByaW1lIiwiZmluaXNoIiwicHJpbWUiLCJnZW5lcmF0ZVByb2JhYmxlUHJpbWUiLCJmbiIsIl9wcml2YXRlS2V5RnJvbUp3ayIsImp3ayIsImt0eSIsIl9iYXNlNjRUb0JpZ0ludCIsImRwIiwiZHEiLCJxaSIsIl9wdWJsaWNLZXlGcm9tSndrIiwiYjY0Iiwic3RhcnRFbmNyeXB0aW5nIiwiaXYiLCJtb2RlIiwiX2NyZWF0ZUNpcGhlciIsImNyZWF0ZUVuY3J5cHRpb25DaXBoZXIiLCJzdGFydERlY3J5cHRpbmciLCJjcmVhdGVEZWNyeXB0aW9uQ2lwaGVyIiwiQWxnb3JpdGhtIiwiaW5pdGlhbGl6ZSIsImJsb2NrU2l6ZSIsImluQmxvY2siLCJvdXRCbG9jayIsIl93IiwiX2luaXQiLCJlbmNyeXB0T3AiLCJyZWdpc3RlckFsZ29yaXRobSIsIm1vZGVzIiwiZWNiIiwiY2JjIiwiY2ZiIiwib2ZiIiwiY3RyIiwiZ2NtIiwiTmIiLCJzYm94IiwiaXNib3giLCJyY29uIiwibWl4IiwiaW1peCIsInh0aW1lIiwiZWkiLCJlMiIsImU0IiwiZTgiLCJzeCIsInN4MiIsIm1lIiwiaW1lIiwidyIsInRlbXAiLCJpTmsiLCJOayIsIk5yMSIsIm0wIiwibTEiLCJtMiIsIm0zIiwid25ldyIsIndpIiwiTnIiLCJhIiwiYTIiLCJjMiIsInJvdW5kIiwiY3JlYXRlRGVjaXBoZXIiLCJjcmVhdGVDaXBoZXIiLCJwZW0iLCJoZWFkZXIiLCJwcm9jVHlwZSIsInZlcnNpb24iLCJmb2xkSGVhZGVyIiwiY29udGVudERvbWFpbiIsImRla0luZm8iLCJwYXJhbWV0ZXJzIiwiYm9keSIsInJNZXNzYWdlIiwickhlYWRlciIsInJDUkxGIiwibGluZXMiLCJsaSIsIm5sIiwidmkiLCJsdHJpbSIsImluc2VydFNwYWNlIiwiJDEiLCJjYW5kaWRhdGUiLCJpbnNlcnQiLCJwYmUiLCJlbmNyeXB0ZWRQcml2YXRlS2V5VmFsaWRhdG9yIiwiUEJFUzJBbGdvcml0aG1zVmFsaWRhdG9yIiwicGtjczEyUGJlUGFyYW1zVmFsaWRhdG9yIiwiZW5jcnlwdFByaXZhdGVLZXlJbmZvIiwicGFzc3dvcmQiLCJzYWx0U2l6ZSIsInByZkFsZ29yaXRobSIsInNhbHQiLCJjb3VudEJ5dGVzIiwiZGtMZW4iLCJlbmNyeXB0aW9uQWxnb3JpdGhtIiwiZW5jcnlwdGVkRGF0YSIsIml2TGVuIiwiZW5jT2lkIiwiY2lwaGVyRm4iLCJkZXMiLCJwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QiLCJkayIsInBrY3M1IiwicGJrZGYyIiwiY3JlYXRlUGJrZGYyUGFyYW1zIiwic2FsdEJ5dGVzIiwiZ2VuZXJhdGVQa2NzMTJLZXkiLCJkZWNyeXB0UHJpdmF0ZUtleUluZm8iLCJlbmNyeXB0aW9uT2lkIiwiZ2V0Q2lwaGVyIiwiZW5jcnlwdGlvblBhcmFtcyIsImVuY3J5cHRlZCIsImVuY3J5cHRlZFByaXZhdGVLZXlUb1BlbSIsImVwa2kiLCJlbmNyeXB0ZWRQcml2YXRlS2V5RnJvbVBlbSIsImhlYWRlclR5cGUiLCJlbmNyeXB0UnNhUHJpdmF0ZUtleSIsImxlZ2FjeSIsIm9wZW5zc2xEZXJpdmVCeXRlcyIsImRlY3J5cHRSc2FQcml2YXRlS2V5IiwicmMyIiwiaXRlciIsInNoYTEiLCJ1IiwiZGlnZXN0TGVuZ3RoIiwiYmxvY2tMZW5ndGgiLCJwYXNzQnVmIiwiRCIsIlNsZW4iLCJTIiwiUGxlbiIsIlAiLCJJIiwiYnVmIiwiQiIsIkluZXciLCJjaHVuayIsImdldENpcGhlckZvclBCRVMyIiwiZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFIiwic3VwcG9ydGVkT2lkcyIsImtkZk9pZCIsImtkZlNhbHQiLCJrZGZJdGVyYXRpb25Db3VudCIsInByZk9pZFRvTWVzc2FnZURpZ2VzdCIsInByZk9pZCIsImVuY0l2IiwiaXRlcmF0aW9ucyIsImRJdkxlbiIsIm1kNSIsImRpZ2VzdHMiLCJzdXBwb3J0ZWQiLCJzaGE1MTIiLCJnZXRBbGdvcml0aG0iLCJCbG9ja0NpcGhlciIsIl9maW5pc2giLCJfaW5wdXQiLCJfb3AiLCJfZGVjcnlwdCIsInBhZCIsInVucGFkIiwib3ZlcmZsb3ciLCJhZnRlckZpbmlzaCIsIl9pbnRzIiwiX2luQmxvY2siLCJfb3V0QmxvY2siLCJwYWRkaW5nIiwiX3ByZXYiLCJfaXYiLCJ0cmFuc2Zvcm1JViIsIl9wYXJ0aWFsQmxvY2siLCJfcGFydGlhbE91dHB1dCIsIl9wYXJ0aWFsQnl0ZXMiLCJpbnB1dExlbmd0aCIsInBhcnRpYWxCeXRlcyIsImluYzMyIiwiX1IiLCJfY2lwaGVyTGVuZ3RoIiwiYWRkaXRpb25hbERhdGEiLCJfdGFnTGVuZ3RoIiwidGFnTGVuZ3RoIiwiX3RhZyIsInRhZyIsIl9oYXNoQmxvY2siLCJfaGFzaFN1YmtleSIsImNvbXBvbmVudEJpdHMiLCJfbSIsImdlbmVyYXRlSGFzaFRhYmxlIiwiaXZMZW5ndGgiLCJfajAiLCJnaGFzaCIsImNvbmNhdCIsImZyb202NFRvMzIiLCJfYURhdGFMZW5ndGgiLCJfcyIsImxlbmd0aHMiLCJ6X2kiLCJ2X2kiLCJ4X2kiLCJwb3ciLCJsc2IiLCJ0YWJsZU11bHRpcGx5IiwieiIsImFoIiwiaCIsIm11bHRpcGxpZXIiLCJwZXJJbnQiLCJzaGZ0IiwiZ2VuZXJhdGVTdWJIYXNoVGFibGUiLCJtaWQiLCJoYWxmIiwibV9pIiwibV9qIiwiYmxvY2siLCJfa2V5cyIsIl9jcmVhdGVLZXlzIiwic3BmdW5jdGlvbjEiLCJzcGZ1bmN0aW9uMiIsInNwZnVuY3Rpb24zIiwic3BmdW5jdGlvbjQiLCJzcGZ1bmN0aW9uNSIsInNwZnVuY3Rpb242Iiwic3BmdW5jdGlvbjciLCJzcGZ1bmN0aW9uOCIsInBjMmJ5dGVzMCIsInBjMmJ5dGVzMSIsInBjMmJ5dGVzMiIsInBjMmJ5dGVzMyIsInBjMmJ5dGVzNCIsInBjMmJ5dGVzNSIsInBjMmJ5dGVzNiIsInBjMmJ5dGVzNyIsInBjMmJ5dGVzOCIsInBjMmJ5dGVzOSIsInBjMmJ5dGVzMTAiLCJwYzJieXRlczExIiwicGMyYnl0ZXMxMiIsInBjMmJ5dGVzMTMiLCJzaGlmdHMiLCJsZWZ0IiwicmlnaHQiLCJsZWZ0dG1wIiwicmlnaHR0bXAiLCJsb29waW5nIiwiZW5kbG9vcCIsImxvb3BpbmMiLCJyaWdodDEiLCJyaWdodDIiLCJwYmtkZjJTeW5jIiwiaExlbiIsInByZiIsImhtYWMiLCJ4b3IiLCJ1X2MiLCJ1X2MxIiwib3V0ZXIiLCJpbm5lciIsIl9rZXkiLCJfbWQiLCJfaXBhZGRpbmciLCJfb3BhZGRpbmciLCJrZXlsZW4iLCJnZXRNYWMiLCJkYml0cyIsImNhbmFyeSIsImpfbG0iLCJmcm9tTnVtYmVyIiwiZnJvbVN0cmluZyIsIm5iaSIsImFtMSIsImFtMiIsInhsIiwieGgiLCJhbTMiLCJhbSIsIkRCIiwiRE0iLCJEViIsIkJJX0ZQIiwiRlYiLCJGMSIsIkYyIiwiQklfUk0iLCJCSV9SQyIsInJyIiwidnYiLCJpbnQyY2hhciIsImludEF0IiwiYm5wQ29weVRvIiwiYm5wRnJvbUludCIsIm5idiIsImJucEZyb21TdHJpbmciLCJmcm9tUmFkaXgiLCJtaSIsInNoIiwiY2xhbXAiLCJaRVJPIiwic3ViVG8iLCJibnBDbGFtcCIsImJuVG9TdHJpbmciLCJuZWdhdGUiLCJ0b1JhZGl4IiwiYm5OZWdhdGUiLCJibkFicyIsImJuQ29tcGFyZVRvIiwibmJpdHMiLCJibkJpdExlbmd0aCIsImJucERMU2hpZnRUbyIsImJucERSU2hpZnRUbyIsImJucExTaGlmdFRvIiwiYnMiLCJjYnMiLCJibSIsImRzIiwiYm5wUlNoaWZ0VG8iLCJibnBTdWJUbyIsImJucE11bHRpcGx5VG8iLCJibnBTcXVhcmVUbyIsImJucERpdlJlbVRvIiwicG0iLCJwdCIsImNvcHlUbyIsInRzIiwibXMiLCJuc2giLCJsU2hpZnRUbyIsInlzIiwieTAiLCJ5dCIsImQxIiwiZDIiLCJkbFNoaWZ0VG8iLCJxZCIsImRyU2hpZnRUbyIsInJTaGlmdFRvIiwiYm5Nb2QiLCJkaXZSZW1UbyIsIkNsYXNzaWMiLCJjQ29udmVydCIsImNSZXZlcnQiLCJjUmVkdWNlIiwiY011bFRvIiwibXVsdGlwbHlUbyIsImNTcXJUbyIsInNxdWFyZVRvIiwiY29udmVydCIsInJldmVydCIsIm11bFRvIiwic3FyVG8iLCJibnBJbnZEaWdpdCIsIk1vbnRnb21lcnkiLCJtcCIsImludkRpZ2l0IiwibXBsIiwibXBoIiwidW0iLCJtdDIiLCJtb250Q29udmVydCIsIm1vbnRSZXZlcnQiLCJtb250UmVkdWNlIiwidTAiLCJtb250U3FyVG8iLCJtb250TXVsVG8iLCJibnBJc0V2ZW4iLCJibnBFeHAiLCJnIiwiYm5Nb2RQb3dJbnQiLCJpc0V2ZW4iLCJleHAiLCJtb2RQb3dJbnQiLCJibkNsb25lIiwiYm5JbnRWYWx1ZSIsImJuQnl0ZVZhbHVlIiwiYm5TaG9ydFZhbHVlIiwiYm5wQ2h1bmtTaXplIiwiTE4yIiwibG9nIiwiYm5TaWdOdW0iLCJibnBUb1JhZGl4Iiwic2lnbnVtIiwiY3MiLCJjaHVua1NpemUiLCJpbnRWYWx1ZSIsImJucEZyb21SYWRpeCIsImRNdWx0aXBseSIsImJucEZyb21OdW1iZXIiLCJiblRvQnl0ZUFycmF5IiwiYm5FcXVhbHMiLCJibk1pbiIsImJuTWF4IiwiYm5wQml0d2lzZVRvIiwib3AiLCJmIiwib3BfYW5kIiwiYm5BbmQiLCJibk9yIiwib3BfeG9yIiwiYm5Yb3IiLCJvcF9hbmRub3QiLCJibkFuZE5vdCIsImJuTm90IiwiYm5TaGlmdExlZnQiLCJiblNoaWZ0UmlnaHQiLCJsYml0IiwiYm5HZXRMb3dlc3RTZXRCaXQiLCJjYml0IiwiYm5CaXRDb3VudCIsImJuVGVzdEJpdCIsImJucENoYW5nZUJpdCIsImJuU2V0Qml0IiwiY2hhbmdlQml0IiwiYm5DbGVhckJpdCIsImJuRmxpcEJpdCIsImJucEFkZFRvIiwiYm5BZGQiLCJhZGRUbyIsImJuU3VidHJhY3QiLCJibk11bHRpcGx5IiwiYm5EaXZpZGUiLCJiblJlbWFpbmRlciIsImJuRGl2aWRlQW5kUmVtYWluZGVyIiwiYm5wRE11bHRpcGx5IiwiYm5wREFkZE9mZnNldCIsIk51bGxFeHAiLCJuTm9wIiwibk11bFRvIiwiblNxclRvIiwiYm5Qb3ciLCJibnBNdWx0aXBseUxvd2VyVG8iLCJibnBNdWx0aXBseVVwcGVyVG8iLCJCYXJyZXR0IiwicTMiLCJtdSIsImRpdmlkZSIsImJhcnJldHRDb252ZXJ0IiwiYmFycmV0dFJldmVydCIsImJhcnJldHRSZWR1Y2UiLCJtdWx0aXBseVVwcGVyVG8iLCJtdWx0aXBseUxvd2VyVG8iLCJiYXJyZXR0U3FyVG8iLCJiYXJyZXR0TXVsVG8iLCJibk1vZFBvdyIsImsxIiwiZzIiLCJpczEiLCJibkdDRCIsImNsb25lIiwiZ2V0TG93ZXN0U2V0Qml0IiwiYm5wTW9kSW50IiwiYm5Nb2RJbnZlcnNlIiwiYWMiLCJsb3dwcmltZXMiLCJscGxpbSIsImJuSXNQcm9iYWJsZVByaW1lIiwibW9kSW50IiwibWlsbGVyUmFiaW4iLCJibnBNaWxsZXJSYWJpbiIsIm4xIiwic2hpZnRSaWdodCIsImJuR2V0UHJuZyIsInNob3J0VmFsdWUiLCJ0b0J5dGVBcnJheSIsImFuZCIsIm9yIiwiYW5kTm90Iiwibm90IiwiYml0Q291bnQiLCJzZXRCaXQiLCJjbGVhckJpdCIsImZsaXBCaXQiLCJyZW1haW5kZXIiLCJkaXZpZGVBbmRSZW1haW5kZXIiLCJfaW5pdGlhbGl6ZWQiLCJfc3RhdGUiLCJtZXNzYWdlTGVuZ3RoIiwiZnVsbE1lc3NhZ2VMZW5ndGgiLCJtZXNzYWdlTGVuZ3RoU2l6ZSIsIm1lc3NhZ2VMZW5ndGg2NCIsImludDMycyIsImgwIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJfdXBkYXRlIiwiZmluYWxCbG9jayIsIl9wYWRkaW5nIiwiY2FycnkiLCJfc2hvcnROYW1lcyIsIng1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciIsInJzYXNzYVBzc1BhcmFtZXRlclZhbGlkYXRvciIsImNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvciIsImNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yIiwiUkROQXR0cmlidXRlc0FzQXJyYXkiLCJyZG4iLCJzaSIsInZhbHVlVGFnQ2xhc3MiLCJzaG9ydE5hbWUiLCJDUklBdHRyaWJ1dGVzQXNBcnJheSIsInNlcSIsImV4dGVuc2lvblJlcXVlc3QiLCJleHRlbnNpb25zIiwiY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMSIsIl9nZXRBdHRyaWJ1dGUiLCJfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMiLCJmaWxsRGVmYXVsdHMiLCJhbGdvcml0aG1PaWQiLCJtZ2YiLCJzYWx0TGVuZ3RoIiwiaGFzaE9pZCIsIm1hc2tHZW5PaWQiLCJtYXNrR2VuSGFzaE9pZCIsImNlcnRpZmljYXRlRnJvbVBlbSIsImNvbXB1dGVIYXNoIiwiY2VydGlmaWNhdGVGcm9tQXNuMSIsImNlcnRpZmljYXRlVG9QZW0iLCJjZXJ0IiwiY2VydGlmaWNhdGVUb0FzbjEiLCJwdWJsaWNLZXlGcm9tUGVtIiwicHVibGljS2V5VG9SU0FQdWJsaWNLZXlQZW0iLCJnZXRQdWJsaWNLZXlGaW5nZXJwcmludCIsImRlbGltaXRlciIsImNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbVBlbSIsImNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbUFzbjEiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdFRvUGVtIiwiY3NyIiwiY2VydGlmaWNhdGlvblJlcXVlc3RUb0FzbjEiLCJjcmVhdGVDZXJ0aWZpY2F0ZSIsInNlcmlhbE51bWJlciIsInNpZ25hdHVyZU9pZCIsInNpZ2luZm8iLCJ2YWxpZGl0eSIsIm5vdEJlZm9yZSIsIm5vdEFmdGVyIiwiaXNzdWVyIiwiZ2V0RmllbGQiLCJzbiIsImFkZEZpZWxkIiwiX2ZpbGxNaXNzaW5nRmllbGRzIiwic3ViamVjdCIsInNldFN1YmplY3QiLCJhdHRycyIsInVuaXF1ZUlkIiwic2V0SXNzdWVyIiwic2V0RXh0ZW5zaW9ucyIsImV4dHMiLCJfZmlsbE1pc3NpbmdFeHRlbnNpb25GaWVsZHMiLCJnZXRFeHRlbnNpb24iLCJleHQiLCJ0YnNDZXJ0aWZpY2F0ZSIsImdldFRCU0NlcnRpZmljYXRlIiwiY2hpbGQiLCJpc3N1ZWQiLCJleHBlY3RlZElzc3VlciIsImFjdHVhbElzc3VlciIsInNoYTM4NCIsInNoYTFXaXRoUlNBRW5jcnlwdGlvbiIsInNpZ25hdHVyZVBhcmFtZXRlcnMiLCJwc3MiLCJpc0lzc3VlciIsInBhcmVudCIsImlhdHRyIiwic2F0dHIiLCJnZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyIiwidmVyaWZ5U3ViamVjdEtleUlkZW50aWZpZXIiLCJza2kiLCJzdWJqZWN0S2V5SWRlbnRpZmllciIsImNlcnRWZXJzaW9uIiwic2VyaWFsIiwiY2VydFNlcmlhbE51bWJlciIsImNlcnRTaWduYXR1cmVPaWQiLCJjZXJ0U2lnbmF0dXJlUGFyYW1zIiwiY2VydGluZm9TaWduYXR1cmVPaWQiLCJjZXJ0aW5mb1NpZ25hdHVyZVBhcmFtcyIsImNlcnRTaWduYXR1cmUiLCJjZXJ0VmFsaWRpdHkxVVRDVGltZSIsImNlcnRWYWxpZGl0eTJHZW5lcmFsaXplZFRpbWUiLCJjZXJ0VmFsaWRpdHkzVVRDVGltZSIsImNlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWUiLCJpbWQiLCJjZXJ0SXNzdWVyIiwiY2VydElzc3VlclVuaXF1ZUlkIiwic21kIiwiY2VydFN1YmplY3QiLCJjZXJ0U3ViamVjdFVuaXF1ZUlkIiwiY2VydEV4dGVuc2lvbnMiLCJjZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMSIsInN1YmplY3RQdWJsaWNLZXlJbmZvIiwiZXh0c2VxIiwiY3JpdGljYWwiLCJldiIsImIzIiwiZGlnaXRhbFNpZ25hdHVyZSIsIm5vblJlcHVkaWF0aW9uIiwia2V5RW5jaXBoZXJtZW50IiwiZGF0YUVuY2lwaGVybWVudCIsImtleUFncmVlbWVudCIsImtleUNlcnRTaWduIiwiY1JMU2lnbiIsImVuY2lwaGVyT25seSIsImRlY2lwaGVyT25seSIsImNBIiwicGF0aExlbkNvbnN0cmFpbnQiLCJjbGllbnQiLCJzZXJ2ZXIiLCJlbWFpbCIsIm9ianNpZ24iLCJyZXNlcnZlZCIsInNzbENBIiwiZW1haWxDQSIsIm9iakNBIiwiYWx0TmFtZXMiLCJnbiIsImFsdE5hbWUiLCJjcmVhdGVDZXJ0aWZpY2F0aW9uUmVxdWVzdCIsImNzclZlcnNpb24iLCJjc3JTaWduYXR1cmVPaWQiLCJjc3JTaWduYXR1cmVQYXJhbXMiLCJjc3JTaWduYXR1cmUiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8iLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0IiwiZ2V0QXR0cmlidXRlIiwiYWRkQXR0cmlidXRlIiwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZXMiLCJnZXRDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8iLCJjcmkiLCJfZG5Ub0FzbjEiLCJfZ2V0QXR0cmlidXRlc0FzSnNvbiIsImF0dHJpYnV0ZSIsInZhbHVlQ29uc3RydWN0ZWQiLCJjZXJ0aWZpY2F0ZUV4dGVuc2lvblRvQXNuMSIsImV4dGVuc2lvbiIsImtleUlkZW50aWZpZXIiLCJhdXRob3JpdHlDZXJ0SXNzdWVyIiwic3ViU2VxIiwiZnVsbE5hbWVHZW5lcmFsTmFtZXMiLCJfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMSIsIl9DUklBdHRyaWJ1dGVzVG9Bc24xIiwiamFuXzFfMTk1MCIsImphbl8xXzIwNTAiLCJfZGF0ZVRvQXNuMSIsInRicyIsImNlcnRpZmljYXRlRXh0ZW5zaW9uc1RvQXNuMSIsImRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xIiwiZG4iLCJjcmVhdGVDYVN0b3JlIiwiY2VydHMiLCJjYVN0b3JlIiwiZ2V0SXNzdWVyIiwiZ2V0QnlTdWJqZWN0IiwiYWRkQ2VydGlmaWNhdGUiLCJlbnN1cmVTdWJqZWN0SGFzSGFzaCIsImhhc0NlcnRpZmljYXRlIiwiZGVyMSIsImRlcjIiLCJsaXN0QWxsQ2VydGlmaWNhdGVzIiwiY2VydExpc3QiLCJyZW1vdmVDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlRXJyb3IiLCJiYWRfY2VydGlmaWNhdGUiLCJ1bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlX3Jldm9rZWQiLCJjZXJ0aWZpY2F0ZV9leHBpcmVkIiwiY2VydGlmaWNhdGVfdW5rbm93biIsInVua25vd25fY2EiLCJ2ZXJpZnlDZXJ0aWZpY2F0ZUNoYWluIiwiY2hhaW4iLCJzZWxmU2lnbmVkIiwicGFyZW50cyIsInZlcmlmaWVkIiwic2UiLCJrZXlVc2FnZSIsImJhc2ljQ29uc3RyYWludHMiLCJiY0V4dCIsImtleVVzYWdlRXh0IiwicGF0aExlbiIsInZmZCIsInJldCIsInNhbHRfIiwic0xlbiIsInBzc29iaiIsIm1vZEJpdHMiLCJlbUJpdHMiLCJlbUxlbiIsIm1IYXNoIiwibV8iLCJwcyIsImRiIiwibWFza0xlbiIsImRiTWFzayIsIm1hc2tlZERCIiwibWFzayIsImNoZWNrTGVuIiwiaF8iLCJwZW1Ub0RlciIsInByaXZhdGVLZXlGcm9tUGVtIiwicHJpdmF0ZUtleUluZm9Ub1BlbSIsIl9yZXZlcnNlQWxwaGFiZXRzIiwiYWxwaGFiZXQiLCJUeXBlRXJyb3IiLCJfZW5jb2RlV2l0aEJ5dGVCdWZmZXIiLCJiYXNlIiwiZGlnaXRzIiwidGFibGUiLCJmcm9tIiwiaDUiLCJoNiIsImg3IiwiX2siLCJzMCIsImNoIiwibWFqIiwicGx1Z2luIiwidGltZSIsInJlc2VlZHMiLCJnZW5lcmF0ZWQiLCJrZXlCeXRlcyIsInBvb2xzIiwicG9vbCIsImdlbmVyYXRlU3luYyIsIl9yZXNlZWQiLCJfcmVzZWVkU3luYyIsIl9zZWVkIiwibmVlZGVkIiwic2VlZEZpbGUiLCJzZWVkRmlsZVN5bmMiLCJfMnBvd0siLCJzZWVkQnl0ZXMiLCJkZWZhdWx0U2VlZEZpbGUiLCJlbnRyb3B5IiwiVWludDMyQXJyYXkiLCJRdW90YUV4Y2VlZGVkRXJyb3IiLCJoaSIsImxvIiwicmFuZG9tQnl0ZXMiLCJyZWdpc3RlcldvcmtlciIsImxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBpVGFibGUiLCJyb2wiLCJ3b3JkIiwicm9yIiwiZXhwYW5kS2V5IiwiZWZmS2V5Qml0cyIsIkwiLCJUIiwiVDEiLCJUOCIsIlRNIiwiX291dHB1dCIsIm1peFJvdW5kIiwibWFzaFJvdW5kIiwiSyIsIlIiLCJydW5QbGFuIiwicGxhbiIsInB0ciIsImxhYmVsIiwibWdmMU1kIiwibWdmMSIsImtleUxlbmd0aCIsIm1heExlbmd0aCIsImxIYXNoIiwiUFMiLCJQU19sZW5ndGgiLCJzZWVkTGVuZ3RoIiwicnNhX21nZjEiLCJzZWVkTWFzayIsIm1hc2tlZFNlZWQiLCJleHBlY3RlZExlbmd0aCIsImxIYXNoUHJpbWUiLCJpbl9wcyIsImluZGV4IiwiaXNfMCIsImVycm9yX21hc2siLCJtYXNrTGVuZ3RoIiwicHJpbWVpbmNGaW5kUHJpbWUiLCJwcmltZWluY0ZpbmRQcmltZVdpdGhXb3JrZXJzIiwicHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyIsImdlbmVyYXRlUmFuZG9tIiwibXJUZXN0cyIsImdldE1pbGxlclJhYmluVGVzdHMiLCJtaWxsZXJSYWJpblRlc3RzIiwibWF4QmxvY2tUaW1lIiwiX3ByaW1laW5jIiwicmFuZ2UiLCJydW5uaW5nIiwid29ya2VyTWVzc2FnZSIsImZvdW5kIiwicDEyIiwicGtjczEyIiwiY29udGVudEluZm9WYWxpZGF0b3IiLCJwZnhWYWxpZGF0b3IiLCJzYWZlQmFnVmFsaWRhdG9yIiwiYXR0cmlidXRlVmFsaWRhdG9yIiwiY2VydEJhZ1ZhbGlkYXRvciIsIl9nZXRCYWdzQnlBdHRyaWJ1dGUiLCJzYWZlQ29udGVudHMiLCJhdHRyTmFtZSIsImF0dHJWYWx1ZSIsImJhZ1R5cGUiLCJzYWZlQmFncyIsImJhZyIsInBrY3MxMkZyb21Bc24xIiwicGZ4IiwiZ2V0QmFncyIsImxvY2FsS2V5SWQiLCJsb2NhbEtleUlkSGV4IiwiZnJpZW5kbHlOYW1lIiwiZ2V0QmFnc0J5RnJpZW5kbHlOYW1lIiwiZ2V0QmFnc0J5TG9jYWxLZXlJZCIsImNvbnRlbnRUeXBlIiwiY29udGVudCIsIl9kZWNvZGVQa2NzN0RhdGEiLCJtYWMiLCJtYWNLZXlCeXRlcyIsIm1hY0FsZ29yaXRobSIsIm1hY1NhbHQiLCJtYWNJdGVyYXRpb25zIiwibWFjS2V5IiwibWFjVmFsdWUiLCJtYWNEaWdlc3QiLCJfZGVjb2RlQXV0aGVudGljYXRlZFNhZmUiLCJhdXRoU2FmZSIsImNvbnRlbnRJbmZvIiwiX2RlY3J5cHRTYWZlQ29udGVudHMiLCJfZGVjb2RlU2FmZUNvbnRlbnRzIiwicGtjczciLCJlbmNyeXB0ZWREYXRhVmFsaWRhdG9yIiwiZW5jQWxnb3JpdGhtIiwiZW5jUGFyYW1ldGVyIiwiZW5jcnlwdGVkQ29udGVudEFzbjEiLCJyZXMiLCJzYWZlQmFnIiwiYmFnSWQiLCJfZGVjb2RlQmFnQXR0cmlidXRlcyIsImJhZ0F0dHJpYnV0ZXMiLCJ2YWxpZGF0b3IiLCJkZWNvZGVyIiwiYmFnQXNuMSIsImJhZ1ZhbHVlIiwicGtjczhTaHJvdWRlZEtleUJhZyIsImtleUJhZyIsImNlcnRCYWciLCJjZXJ0SWQiLCJ4NTA5Q2VydGlmaWNhdGUiLCJjZXJ0QXNuMSIsImRlY29kZWRBdHRycyIsInRvUGtjczEyQXNuMSIsInVzZU1hYyIsImdlbmVyYXRlTG9jYWxLZXlJZCIsImJhZ0F0dHJzIiwicGFpcmVkQ2VydCIsImNvbnRlbnRzIiwiY2VydFNhZmVCYWdzIiwiY2VydEJhZ0F0dHJzIiwiY2VydFNhZmVCYWciLCJjZXJ0U2FmZUNvbnRlbnRzIiwiY2VydENJIiwicGtBc24xIiwia2V5U2FmZUNvbnRlbnRzIiwia2V5Q0kiLCJzYWZlIiwibWFjRGF0YSIsInA3diIsInBrY3M3YXNuMSIsImVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yIiwiZW52ZWxvcGVkRGF0YVZhbGlkYXRvciIsInNpZ25lclZhbGlkYXRvciIsInNpZ25lZERhdGFWYWxpZGF0b3IiLCJyZWNpcGllbnRJbmZvVmFsaWRhdG9yIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxnQkFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0Esa0RBQTBDO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FB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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5U1k7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsb0RBQVc7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLGdEQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxnREFBUzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBbUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWEsRUFBRSxLQUFLO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVksRUFBRSxLQUFLO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWSxFQUFFLEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU0sOENBQThDLGFBQWE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU0sOENBQThDLGFBQWE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMseUdBQW9COztBQUUvQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkRBQVU7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6a0JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUN6TEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFPLENBQUMsaUVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzlEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JCQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0FBNkMsRUFBN0MsQ0FBZ0QsRUFBaEQsQ0FBbUQsRUFBbkQsQ0FBc0QsRUFBdEQsQ0FBeUQsRUFBekQsQ0FBNEQsRUFBNUQsQ0FBK0QsRUFBL0QsQ0FBa0UsRUFBbEUsQ0FBcUUsRUFBckUsQ0FBd0UsR0FBeEUsQ0FBNEUsR0FBNUUsQ0FBZ0YsR0FBaEYsQ0FBb0YsR0FBcEYsQ0FBd0YsR0FBeEYsQ0FBNEYsR0FBNUYsQ0FBZ0csR0FBaEcsQ0FBb0csR0FBcEcsQ0FBd0csR0FBeEcsQ0FBNEcsR0FBNUcsQ0FBZ0gsR0FBaEgsQ0FBb0gsR0FBcEgsQ0FBd0gsR0FBeEgsQ0FBNEgsR0FBNUgsQ0FBZ0ksR0FBaEksQ0FBb0ksR0FBcEksQ0FBd0ksR0FBeEksQ0FBNEksR0FBNUksQ0FBZ0osR0FBaEosQ0FBb0osR0FBcEosQ0FBd0osR0FBeEosQ0FBNEosR0FBNUosQ0FBZ0ssR0FBaEssQ0FBb0ssR0FBcEssQ0FBd0ssR0FBeEssQ0FBNEssR0FBNUssQ0FBZ0wsR0FBaEwsQ0FBb0wsR0FBcEwsQ0FBd0wsR0FBeEwsQ0FBNEwsR0FBNUwsQ0FBZ00sR0FBaE0sQ0FBb00sR0FBcE0sQ0FBd00sR0FBeE0sQ0FBNE0sR0FBNU0sQ0FBZ04sR0FBaE4sQ0FBb04sR0FBcE4sQ0FBd04sR0FBeE4sQ0FBNE4sR0FBNU4sQ0FBZ08sR0FBaE8sQ0FBb08sR0FBcE8sQ0FBd08sR0FBeE8sQ0FBNE8sR0FBNU8sQ0FBZ1AsR0FBaFAsQ0FBb1AsR0FBcFAsQ0FBd1AsR0FBeFAsQ0FBNFAsR0FBNVAsQ0FBZ1EsR0FBaFEsQ0FBb1EsR0FBcFEsQ0FBd1EsR0FBeFEsQ0FBNFEsR0FBNVEsQ0FBZ1IsR0FBaFIsQ0FBb1IsR0FBcFIsQ0FBd1IsR0FBeFIsQ0FBNFIsR0FBNVIsQ0FBZ1MsR0FBaFMsQ0FBb1MsR0FBcFMsQ0FBd1MsR0FBeFMsQ0FBNFMsR0FBNVMsQ0FBZ1QsR0FBaFQsQ0FBb1QsR0FBcFQsQ0FBd1QsR0FBeFQsQ0FBNFQsR0FBNVQsQ0FBZ1UsR0FBaFUsQ0FBb1UsR0FBcFUsQ0FBd1UsR0FBeFUsQ0FBNFUsR0FBNVUs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QSxLQUFPLENBOTRtQkcsQ0FqRU0sQ0FBaEIsRUFpOW1CQyxDQTM5bUJELEUiLCJmaWxlIjoiZGlzY291cnNlLWNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiZGlzY291cnNlLWNsaWVudFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJkaXNjb3Vyc2UtY2xpZW50XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImRpc2NvdXJzZS1jbGllbnRcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xuIFx0ZnVuY3Rpb24gd2VicGFja0pzb25wQ2FsbGJhY2soZGF0YSkge1xuIFx0XHR2YXIgY2h1bmtJZHMgPSBkYXRhWzBdO1xuIFx0XHR2YXIgbW9yZU1vZHVsZXMgPSBkYXRhWzFdO1xuXG5cbiBcdFx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG4gXHRcdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdO1xuIFx0XHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcbiBcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdHJlc29sdmVzLnB1c2goaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKTtcbiBcdFx0XHR9XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcbiBcdFx0fVxuIFx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGlmKHBhcmVudEpzb25wRnVuY3Rpb24pIHBhcmVudEpzb25wRnVuY3Rpb24oZGF0YSk7XG5cbiBcdFx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG4gXHRcdFx0cmVzb2x2ZXMuc2hpZnQoKSgpO1xuIFx0XHR9XG5cbiBcdH07XG5cblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3NcbiBcdC8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuIFx0Ly8gUHJvbWlzZSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbiBcdHZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG4gXHRcdFwiZGlzY291cnNlLWNsaWVudC5qc1wiOiAwXG4gXHR9O1xuXG5cblxuIFx0Ly8gc2NyaXB0IHBhdGggZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIGpzb25wU2NyaXB0U3JjKGNodW5rSWQpIHtcbiBcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyAoe31bY2h1bmtJZF18fGNodW5rSWQpICsgXCIuanNcIlxuIFx0fVxuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cbiBcdC8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuIFx0Ly8gU2luY2UgYWxsIHJlZmVyZW5jZWQgY2h1bmtzIGFyZSBhbHJlYWR5IGluY2x1ZGVkXG4gXHQvLyBpbiB0aGlzIGZpbGUsIHRoaXMgZnVuY3Rpb24gaXMgZW1wdHkgaGVyZS5cbiBcdF9fd2VicGFja19yZXF1aXJlX18uZSA9IGZ1bmN0aW9uIHJlcXVpcmVFbnN1cmUoKSB7XG4gXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiBcdH07XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gb24gZXJyb3IgZnVuY3Rpb24gZm9yIGFzeW5jIGxvYWRpbmdcbiBcdF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiBcdHZhciBqc29ucEFycmF5ID0gd2luZG93W1wid2VicGFja0pzb25wZGlzY291cnNlX2NsaWVudFwiXSA9IHdpbmRvd1tcIndlYnBhY2tKc29ucGRpc2NvdXJzZV9jbGllbnRcIl0gfHwgW107XG4gXHR2YXIgb2xkSnNvbnBGdW5jdGlvbiA9IGpzb25wQXJyYXkucHVzaC5iaW5kKGpzb25wQXJyYXkpO1xuIFx0anNvbnBBcnJheS5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2s7XG4gXHRqc29ucEFycmF5ID0ganNvbnBBcnJheS5zbGljZSgpO1xuIFx0Zm9yKHZhciBpID0gMDsgaSA8IGpzb25wQXJyYXkubGVuZ3RoOyBpKyspIHdlYnBhY2tKc29ucENhbGxiYWNrKGpzb25wQXJyYXlbaV0pO1xuIFx0dmFyIHBhcmVudEpzb25wRnVuY3Rpb24gPSBvbGRKc29ucEZ1bmN0aW9uO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9kaXNjb3Vyc2UuanNcIik7XG4iLCIvKiEgKGMpIEFuZHJlYSBHaWFtbWFyY2hpIC0gSVNDICovXG52YXIgc2VsZiA9IHRoaXMgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307XG50cnkge1xuICAoZnVuY3Rpb24gKFVSTFNlYXJjaFBhcmFtcywgcGx1cykge1xuICAgIGlmIChcbiAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoJ3E9JTJCJykuZ2V0KCdxJykgIT09IHBsdXMgfHxcbiAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoe3E6IHBsdXN9KS5nZXQoJ3EnKSAhPT0gcGx1cyB8fFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhbWydxJywgcGx1c11dKS5nZXQoJ3EnKSAhPT0gcGx1cyB8fFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcygncT1cXG4nKS50b1N0cmluZygpICE9PSAncT0lMEEnIHx8XG4gICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKHtxOiAnICYnfSkudG9TdHJpbmcoKSAhPT0gJ3E9KyUyNidcbiAgICApXG4gICAgICB0aHJvdyBVUkxTZWFyY2hQYXJhbXM7XG4gICAgc2VsZi5VUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXM7XG4gIH0oVVJMU2VhcmNoUGFyYW1zLCAnKycpKTtcbn0gY2F0Y2goVVJMU2VhcmNoUGFyYW1zKSB7XG4gIChmdW5jdGlvbiAoT2JqZWN0LCBTdHJpbmcsIGlzQXJyYXkpIHsndXNlIHN0cmljdCc7XG4gICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBmaW5kID0gL1shJ1xcKFxcKX5dfCUyMHwlMDAvZztcbiAgICB2YXIgcGx1cyA9IC9cXCsvZztcbiAgICB2YXIgcmVwbGFjZSA9IHtcbiAgICAgICchJzogJyUyMScsXG4gICAgICBcIidcIjogJyUyNycsXG4gICAgICAnKCc6ICclMjgnLFxuICAgICAgJyknOiAnJTI5JyxcbiAgICAgICd+JzogJyU3RScsXG4gICAgICAnJTIwJzogJysnLFxuICAgICAgJyUwMCc6ICdcXHgwMCdcbiAgICB9O1xuICAgIHZhciBwcm90byA9IHtcbiAgICAgIGFwcGVuZDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgYXBwZW5kVG8odGhpcy5fdW5nYXAsIGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5nYXBba2V5XTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldWzBdIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXRBbGw6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldLnNsaWNlKDApIDogW107XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5fdW5nYXA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl91bmdhcFtrZXldID0gW1N0cmluZyh2YWx1ZSldO1xuICAgICAgfSxcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZWxmLl91bmdhcClcbiAgICAgICAgICBzZWxmLl91bmdhcFtrZXldLmZvckVhY2goaW52b2tlLCBrZXkpO1xuICAgICAgICBmdW5jdGlvbiBpbnZva2UodmFsdWUpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBTdHJpbmcoa2V5KSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fdW5nYXApIHtcbiAgICAgICAgICB2YXIgZW5jb2RlZCA9IGVuY29kZShrZXkpO1xuICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdW5nYXBba2V5XTtcbiAgICAgICAgICAgIGkgPCB2YWx1ZS5sZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcXVlcnkucHVzaChlbmNvZGVkICsgJz0nICsgZW5jb2RlKHZhbHVlW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeS5qb2luKCcmJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG8pXG4gICAgICBkZWZpbmVQcm9wZXJ0eShVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHByb3RvW2tleV1cbiAgICAgIH0pO1xuICAgIHNlbGYuVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xuICAgIGZ1bmN0aW9uIFVSTFNlYXJjaFBhcmFtcyhxdWVyeSkge1xuICAgICAgdmFyIGRpY3QgPSBjcmVhdGUobnVsbCk7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3VuZ2FwJywge3ZhbHVlOiBkaWN0fSk7XG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSAhcXVlcnk6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJzpcbiAgICAgICAgICBpZiAocXVlcnkuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICBwYWlycyA9IHF1ZXJ5LnNwbGl0KCcmJyksXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHZhbHVlLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgIGlmICgtMSA8IGluZGV4KSB7XG4gICAgICAgICAgICAgIGFwcGVuZFRvKFxuICAgICAgICAgICAgICAgIGRpY3QsXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlLnNsaWNlKDAsIGluZGV4KSksXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlLnNsaWNlKGluZGV4ICsgMSkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCl7XG4gICAgICAgICAgICAgIGFwcGVuZFRvKFxuICAgICAgICAgICAgICAgIGRpY3QsXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpc0FycmF5KHF1ZXJ5KTpcbiAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBxdWVyeS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcXVlcnlbaV07XG4gICAgICAgICAgICBhcHBlbmRUbyhkaWN0LCB2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9yRWFjaCcgaW4gcXVlcnk6XG4gICAgICAgICAgcXVlcnkuZm9yRWFjaChhZGRFYWNoLCBkaWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcXVlcnkpXG4gICAgICAgICAgICBhcHBlbmRUbyhkaWN0LCBrZXksIHF1ZXJ5W2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEVhY2godmFsdWUsIGtleSkge1xuICAgICAgYXBwZW5kVG8odGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGFwcGVuZFRvKGRpY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywnKSA6IHZhbHVlO1xuICAgICAgaWYgKGtleSBpbiBkaWN0KVxuICAgICAgICBkaWN0W2tleV0ucHVzaChyZXMpO1xuICAgICAgZWxzZVxuICAgICAgICBkaWN0W2tleV0gPSBbcmVzXTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZShwbHVzLCAnICcpKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoZmluZCwgcmVwbGFjZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVttYXRjaF07XG4gICAgfVxuXG4gIH0oT2JqZWN0LCBTdHJpbmcsIEFycmF5LmlzQXJyYXkpKTtcbn1cblxuKGZ1bmN0aW9uIChVUkxTZWFyY2hQYXJhbXNQcm90bykge1xuXG4gIHZhciBpdGVyYWJsZSA9IGZhbHNlO1xuICB0cnkgeyBpdGVyYWJsZSA9ICEhU3ltYm9sLml0ZXJhdG9yOyB9IGNhdGNoIChvX08pIHt9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ2ZvckVhY2gnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy50b1N0cmluZygpXG4gICAgICAgICAgLnJlcGxhY2UoLz1bXFxzXFxTXSo/KD86JnwkKS9nLCAnPScpXG4gICAgICAgICAgLnNwbGl0KCc9JylcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFuYW1lLmxlbmd0aCB8fCBuYW1lIGluIG5hbWVzKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAobmFtZXNbbmFtZV0gPSBzZWxmLmdldEFsbChuYW1lKSkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgna2V5cycgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkgeyB0aGlzLnB1c2goa2V5KTsgfSk7XG4gICAgfTtcbiAgfVxuXG4gICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgndmFsdWVzJyBpbiBVUkxTZWFyY2hQYXJhbXNQcm90bykpIHtcbiAgICBVUkxTZWFyY2hQYXJhbXNQcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkgeyB0aGlzLnB1c2godmFsdWUpOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ2VudHJpZXMnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgdGhpcy5wdXNoKFtrZXksIHZhbHVlXSk7IH0pO1xuICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXRlcmFibGUgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG9bU3ltYm9sLml0ZXJhdG9yXSA9IFVSTFNlYXJjaFBhcmFtc1Byb3RvLmVudHJpZXM7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgnc29ydCcgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uc29ydCA9IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgICB2YXJcbiAgICAgICAgZW50cmllcyA9IHRoaXMuZW50cmllcygpLFxuICAgICAgICBlbnRyeSA9IGVudHJpZXMubmV4dCgpLFxuICAgICAgICBkb25lID0gZW50cnkuZG9uZSxcbiAgICAgICAga2V5cyA9IFtdLFxuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBpLCBrZXksIHZhbHVlXG4gICAgICA7XG4gICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgdmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAga2V5ID0gdmFsdWVbMF07XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICBpZiAoIShrZXkgaW4gdmFsdWVzKSkge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2tleV0ucHVzaCh2YWx1ZVsxXSk7XG4gICAgICAgIGVudHJ5ID0gZW50cmllcy5uZXh0KCk7XG4gICAgICAgIGRvbmUgPSBlbnRyeS5kb25lO1xuICAgICAgfVxuICAgICAgLy8gbm90IHRoZSBjaGFtcGlvbiBpbiBlZmZpY2llbmN5XG4gICAgICAvLyBidXQgdGhlc2UgdHdvIGJpdHMganVzdCBkbyB0aGUgam9iXG4gICAgICBrZXlzLnNvcnQoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKGtleXNbaV0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdGhpcy5hcHBlbmQoa2V5LCB2YWx1ZXNba2V5XS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0b3Ioc2VsZiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBzZWxmLmZvckVhY2goY2FsbGJhY2ssIGl0ZW1zKTtcbiAgICByZXR1cm4gaXRlcmFibGUgP1xuICAgICAgaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpIDpcbiAgICAgIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgIH1cbiAgICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAoZnVuY3Rpb24gKE9iamVjdCkge1xuICAgIHZhclxuICAgICAgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc1BvbGx1dGUgPSBmdW5jdGlvbiAoc2VhcmNoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmFwcGVuZC5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLl91c3AsIG5hbWUgPyAoJz8nICsgbmFtZSkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsKG5hbWUpIHtcbiAgICAgICAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5kZWxldGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLl91c3AsIG5hbWUgPyAoJz8nICsgbmFtZSkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uc2V0LmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgc2VhcmNoLnNldC5jYWxsKHRoaXMuX3VzcCwgbmFtZSA/ICgnPycgKyBuYW1lKSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNwLCB2YWx1ZSkge1xuICAgICAgICAgIHNwLmFwcGVuZCA9IGFwcGVuZDtcbiAgICAgICAgICBzcC5kZWxldGUgPSBkZWw7XG4gICAgICAgICAgc3Auc2V0ID0gc2V0O1xuICAgICAgICAgIHJldHVybiBkUChzcCwgJ191c3AnLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc0NyZWF0ZSA9IGZ1bmN0aW9uIChwb2xsdXRlU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBzcCkge1xuICAgICAgICAgIGRQKFxuICAgICAgICAgICAgb2JqLCAnX3NlYXJjaFBhcmFtcycsIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHBvbGx1dGVTZWFyY2hQYXJhbXMoc3AsIG9iailcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBzcDtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAoc3ApIHtcbiAgICAgICAgdmFyIGFwcGVuZCA9IHNwLmFwcGVuZDtcbiAgICAgICAgc3AuYXBwZW5kID0gVVJMU2VhcmNoUGFyYW1zUHJvdG8uYXBwZW5kO1xuICAgICAgICBVUkxTZWFyY2hQYXJhbXMuY2FsbChzcCwgc3AuX3VzcC5zZWFyY2guc2xpY2UoMSkpO1xuICAgICAgICBzcC5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICB9LFxuICAgICAgdmVyaWZ5U2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKG9iaiwgQ2xhc3MpIHtcbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgQ2xhc3MpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiJ3NlYXJjaFBhcmFtcycgYWNjZXNzZWQgb24gYW4gb2JqZWN0IHRoYXQgXCIgK1xuICAgICAgICAgIFwiZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBcIiArIENsYXNzLm5hbWVcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1cGdyYWRlQ2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgQ2xhc3NQcm90byA9IENsYXNzLnByb3RvdHlwZSxcbiAgICAgICAgICBzZWFyY2hQYXJhbXMgPSBnT1BEKENsYXNzUHJvdG8sICdzZWFyY2hQYXJhbXMnKSxcbiAgICAgICAgICBocmVmID0gZ09QRChDbGFzc1Byb3RvLCAnaHJlZicpLFxuICAgICAgICAgIHNlYXJjaCA9IGdPUEQoQ2xhc3NQcm90bywgJ3NlYXJjaCcpLFxuICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc1xuICAgICAgICA7XG4gICAgICAgIGlmICghc2VhcmNoUGFyYW1zICYmIHNlYXJjaCAmJiBzZWFyY2guc2V0KSB7XG4gICAgICAgICAgY3JlYXRlU2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zQ3JlYXRlKFxuICAgICAgICAgICAgY3JlYXRlU2VhcmNoUGFyYW1zUG9sbHV0ZShzZWFyY2gpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICAgICAgICAgIENsYXNzUHJvdG8sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGhyZWY6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBocmVmLmdldC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzcCA9IHRoaXMuX3NlYXJjaFBhcmFtcztcbiAgICAgICAgICAgICAgICAgIGhyZWYuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNwKSB1cGRhdGVTZWFyY2hQYXJhbXMoc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2VhcmNoOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2VhcmNoLmdldC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzcCA9IHRoaXMuX3NlYXJjaFBhcmFtcztcbiAgICAgICAgICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoc3ApIHVwZGF0ZVNlYXJjaFBhcmFtcyhzcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZlcmlmeVNlYXJjaFBhcmFtcyh0aGlzLCBDbGFzcyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoUGFyYW1zIHx8IGNyZWF0ZVNlYXJjaFBhcmFtcyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyh0aGlzLnNlYXJjaC5zbGljZSgxKSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzcCkge1xuICAgICAgICAgICAgICAgICAgdmVyaWZ5U2VhcmNoUGFyYW1zKHRoaXMsIENsYXNzKTtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtcyh0aGlzLCBzcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIDtcbiAgICB0cnkge1xuICAgICAgdXBncmFkZUNsYXNzKEhUTUxBbmNob3JFbGVtZW50KTtcbiAgICAgIGlmICgvXmZ1bmN0aW9ufG9iamVjdCQvLnRlc3QodHlwZW9mIFVSTCkgJiYgVVJMLnByb3RvdHlwZSlcbiAgICAgICAgdXBncmFkZUNsYXNzKFVSTCk7XG4gICAgfSBjYXRjaCAobWVoKSB7fVxuICB9KE9iamVjdCkpO1xuXG59KHNlbGYuVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZSwgT2JqZWN0KSk7XG5leHBvcnQgZGVmYXVsdCBzZWxmLlVSTFNlYXJjaFBhcmFtcztcbiIsIi8qKlxuICogQGF1dGhvciBLdWl0b3NcbiAqIEBob21lcGFnZSBodHRwczovL2dpdGh1Yi5jb20va3VpdG9zL1xuICogQHNpbmNlIDIwMTctMTAtMTJcbiAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBMUlVDYWNoZSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IGJ1aWxkU29ydGVkVVJMIGZyb20gJy4vdXRpbHMvYnVpbGRTb3J0ZWRVUkwnO1xuaW1wb3J0IGlzQ2FjaGVMaWtlIGZyb20gJy4vdXRpbHMvaXNDYWNoZUxpa2UnO1xudmFyIEZJVkVfTUlOVVRFUyA9IDEwMDAgKiA2MCAqIDU7XG52YXIgQ0FQQUNJVFkgPSAxMDA7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYWNoZUFkYXB0ZXJFbmhhbmNlcihhZGFwdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5hYmxlZEJ5RGVmYXVsdCwgZW5hYmxlZEJ5RGVmYXVsdCA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIF9iID0gb3B0aW9ucy5jYWNoZUZsYWcsIGNhY2hlRmxhZyA9IF9iID09PSB2b2lkIDAgPyAnY2FjaGUnIDogX2IsIF9jID0gb3B0aW9ucy5kZWZhdWx0Q2FjaGUsIGRlZmF1bHRDYWNoZSA9IF9jID09PSB2b2lkIDAgPyBuZXcgTFJVQ2FjaGUoeyBtYXhBZ2U6IEZJVkVfTUlOVVRFUywgbWF4OiBDQVBBQ0lUWSB9KSA6IF9jO1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciB1cmwgPSBjb25maWcudXJsLCBtZXRob2QgPSBjb25maWcubWV0aG9kLCBwYXJhbXMgPSBjb25maWcucGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyID0gY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIsIGZvcmNlVXBkYXRlID0gY29uZmlnLmZvcmNlVXBkYXRlO1xuICAgICAgICB2YXIgdXNlQ2FjaGUgPSAoY29uZmlnW2NhY2hlRmxhZ10gIT09IHZvaWQgMCAmJiBjb25maWdbY2FjaGVGbGFnXSAhPT0gbnVsbCkgPyBjb25maWdbY2FjaGVGbGFnXSA6IGVuYWJsZWRCeURlZmF1bHQ7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdnZXQnICYmIHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAvLyBpZiBoYWQgcHJvdmlkZSBhIHNwZWNpZmllZCBjYWNoZSwgdGhlbiB1c2UgaXQgaW5zdGVhZFxuICAgICAgICAgICAgdmFyIGNhY2hlXzEgPSBpc0NhY2hlTGlrZSh1c2VDYWNoZSkgPyB1c2VDYWNoZSA6IGRlZmF1bHRDYWNoZTtcbiAgICAgICAgICAgIC8vIGJ1aWxkIHRoZSBpbmRleCBhY2NvcmRpbmcgdG8gdGhlIHVybCBhbmQgcGFyYW1zXG4gICAgICAgICAgICB2YXIgaW5kZXhfMSA9IGJ1aWxkU29ydGVkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKTtcbiAgICAgICAgICAgIHZhciByZXNwb25zZVByb21pc2UgPSBjYWNoZV8xLmdldChpbmRleF8xKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VQcm9taXNlIHx8IGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhc29uXzE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYWRhcHRlcihjb25maWcpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlXzEuZGVsKGluZGV4XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWFzb25fMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7IH0pKCk7XG4gICAgICAgICAgICAgICAgLy8gcHV0IHRoZSBwcm9taXNlIGZvciB0aGUgbm9uLXRyYW5zZm9ybWVkIHJlc3BvbnNlIGludG8gY2FjaGUgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGNhY2hlXzEuc2V0KGluZGV4XzEsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTE9HR0VSX0xFVkVMID09PSAnaW5mbycpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInJlcXVlc3QgY2FjaGVkIGJ5IGNhY2hlIGFkYXB0ZXI6IFwiICsgaW5kZXhfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGFwdGVyKGNvbmZpZyk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlQWRhcHRlckVuaGFuY2VyLmpzLm1hcCIsIi8qKlxuICogQGF1dGhvciBLdWl0b3NcbiAqIEBob21lcGFnZSBodHRwczovL2dpdGh1Yi5jb20va3VpdG9zL1xuICogQHNpbmNlIDIwMTctMDktMjhcbiAqL1xuaW1wb3J0IENhY2hlIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgY2FjaGVBZGFwdGVyRW5oYW5jZXIgZnJvbSAnLi9jYWNoZUFkYXB0ZXJFbmhhbmNlcic7XG5pbXBvcnQgdGhyb3R0bGVBZGFwdGVyRW5oYW5jZXIgZnJvbSAnLi90aHJvdHRsZUFkYXB0ZXJFbmhhbmNlcic7XG5leHBvcnQgeyBDYWNoZSwgY2FjaGVBZGFwdGVyRW5oYW5jZXIsIHRocm90dGxlQWRhcHRlckVuaGFuY2VyLCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXG4gKiBAYXV0aG9yIEt1aXRvc1xuICogQGhvbWVwYWdlIGh0dHBzOi8vZ2l0aHViLmNvbS9rdWl0b3MvXG4gKiBAc2luY2UgMjAxNy0xMC0xMVxuICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgYnVpbGRTb3J0ZWRVUkwgZnJvbSAnLi91dGlscy9idWlsZFNvcnRlZFVSTCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJvdHRsZUFkYXB0ZXJFbmhhbmNlcihhZGFwdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMudGhyZXNob2xkLCB0aHJlc2hvbGQgPSBfYSA9PT0gdm9pZCAwID8gMTAwMCA6IF9hLCBfYiA9IG9wdGlvbnMuY2FjaGUsIGNhY2hlID0gX2IgPT09IHZvaWQgMCA/IG5ldyBMUlVDYWNoZSh7IG1heDogMTAgfSkgOiBfYjtcbiAgICB2YXIgcmVjb3JkQ2FjaGVXaXRoUmVxdWVzdCA9IGZ1bmN0aW9uIChpbmRleCwgY29uZmlnKSB7XG4gICAgICAgIHZhciByZXNwb25zZVByb21pc2UgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIHJlYXNvbl8xO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYWRhcHRlcihjb25maWcpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFByb21pc2UucmVzb2x2ZShyZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZGVsKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlYXNvbl8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pKCk7XG4gICAgICAgIGNhY2hlLnNldChpbmRleCwge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdmFsdWU6IHJlc3BvbnNlUHJvbWlzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgdXJsID0gY29uZmlnLnVybCwgbWV0aG9kID0gY29uZmlnLm1ldGhvZCwgcGFyYW1zID0gY29uZmlnLnBhcmFtcywgcGFyYW1zU2VyaWFsaXplciA9IGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyO1xuICAgICAgICB2YXIgaW5kZXggPSBidWlsZFNvcnRlZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcik7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgY2FjaGVkUmVjb3JkID0gY2FjaGUuZ2V0KGluZGV4KSB8fCB7IHRpbWVzdGFtcDogbm93IH07XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICBpZiAobm93IC0gY2FjaGVkUmVjb3JkLnRpbWVzdGFtcCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VQcm9taXNlID0gY2FjaGVkUmVjb3JkLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkxPR0dFUl9MRVZFTCA9PT0gJ2luZm8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicmVxdWVzdCBjYWNoZWQgYnkgdGhyb3R0bGUgYWRhcHRlcjogXCIgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkQ2FjaGVXaXRoUmVxdWVzdChpbmRleCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRhcHRlcihjb25maWcpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZUFkYXB0ZXJFbmhhbmNlci5qcy5tYXAiLCIvKipcbiAqIEBhdXRob3IgS3VpdG9zXG4gKiBAaG9tZXBhZ2UgaHR0cHM6Ly9naXRodWIuY29tL2t1aXRvcy9cbiAqIEBzaW5jZSAyMDE3LTEwLTEyXG4gKi9cbmltcG9ydCBidWlsZFVSTCBmcm9tICdheGlvcy9saWIvaGVscGVycy9idWlsZFVSTCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFNvcnRlZFVSTCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGJ1aWx0VVJMID0gYnVpbGRVUkwuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICB2YXIgX2EgPSBidWlsdFVSTC5zcGxpdCgnPycpLCB1cmxQYXRoID0gX2FbMF0sIHF1ZXJ5U3RyaW5nID0gX2FbMV07XG4gICAgaWYgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHZhciBwYXJhbXNQYWlyID0gcXVlcnlTdHJpbmcuc3BsaXQoJyYnKTtcbiAgICAgICAgcmV0dXJuIHVybFBhdGggKyBcIj9cIiArIHBhcmFtc1BhaXIuc29ydCgpLmpvaW4oJyYnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWx0VVJMO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRTb3J0ZWRVUkwuanMubWFwIiwiLyoqXG4gKiBAYXV0aG9yIEt1aXRvc1xuICogQGhvbWVwYWdlIGh0dHBzOi8vZ2l0aHViLmNvbS9rdWl0b3MvXG4gKiBAc2luY2UgMjAxOC0wMy0xOVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0NhY2hlTGlrZShjYWNoZSkge1xuICAgIHJldHVybiAhIShjYWNoZS5zZXQgJiYgY2FjaGUuZ2V0ICYmIGNhY2hlLmRlbCAmJlxuICAgICAgICB0eXBlb2YgY2FjaGUuZ2V0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYWNoZS5zZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNhY2hlLmRlbCA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0NhY2hlTGlrZS5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcbnZhciBidG9hID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5idG9hICYmIHdpbmRvdy5idG9hLmJpbmQod2luZG93KSkgfHwgcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J0b2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgdmFyIHhEb21haW4gPSBmYWxzZTtcblxuICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG4gICAgLy8gT25seSBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgY2FsbHMgYW5kIGRvZXNuJ3QgcmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgICAhaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSB7XG4gICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG4gICAgICB4RG9tYWluID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIC8vIElFIHNlbmRzIDEyMjMgaW5zdGVhZCBvZiAyMDQgKGh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXMvMjAxKVxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gMjA0IDogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICB2YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG5cbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vLi4vZGVmYXVsdHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSB1dGlscy5tZXJnZSh7XG4gICAgICB1cmw6IGFyZ3VtZW50c1swXVxuICAgIH0sIGFyZ3VtZW50c1sxXSk7XG4gIH1cblxuICBjb25maWcgPSB1dGlscy5tZXJnZShkZWZhdWx0cywge21ldGhvZDogJ2dldCd9LCB0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIC8vIE5vdGU6IHN0YXR1cyBpcyBub3QgZXhwb3NlZCBieSBYRG9tYWluUmVxdWVzdFxuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KSB7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgaW5kZXggPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDA7XG4gIHZhciBpID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYgKGFMZW4gPCAyKSBmb3IgKDs7KSB7XG4gICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggKz0gaTtcbiAgICBpZiAoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvciAoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZXhlYycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xuXG52YXIgU1BFQ0lFUyA9IHdrcygnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMiAmJiByZXN1bHRbMF0gPT09ICdhJyAmJiByZXN1bHRbMV0gPT09ICdiJztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7XG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MID8gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgfVxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUykgfHxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgZm5zID0gZXhlYyhcbiAgICAgIGRlZmluZWQsXG4gICAgICBTWU1CT0wsXG4gICAgICAnJ1tLRVldLFxuICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgICB2YXIgcnhmbiA9IGZuc1sxXTtcblxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICB9IGVsc2UgaWYgKE9ic2VydmVyICYmICEoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBidWlsdGluRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcblxuIC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cbiAgcmV0dXJuIGJ1aWx0aW5FeGVjLmNhbGwoUiwgUyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS8sXG4gICAgICByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMVtMQVNUX0lOREVYXSAhPT0gMCB8fCByZTJbTEFTVF9JTkRFWF0gIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmVbTEFTVF9JTkRFWF07XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGghJyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKSB7XG4gIHZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuICB2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG4gIHZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG4gIHZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4gIHZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xuICB2YXIgJGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xuICB2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG4gIHZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbiAgdmFyIHByb3BlcnR5RGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbiAgdmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4gIHZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuICB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuICB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbiAgdmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xuICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbiAgdmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbiAgdmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG4gIHZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbiAgdmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xuICB2YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG4gIHZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuICB2YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuICB2YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4gIHZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbiAgdmFyIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpO1xuICB2YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuICB2YXIgQXJyYXlJdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xuICB2YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG4gIHZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG4gIHZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbiAgdmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbiAgdmFyIGFycmF5Q29weVdpdGhpbiA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyk7XG4gIHZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbiAgdmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbiAgdmFyIGRQID0gJERQLmY7XG4gIHZhciBnT1BEID0gJEdPUEQuZjtcbiAgdmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbiAgdmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG4gIHZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuICB2YXIgU0hBUkVEX0JVRkZFUiA9ICdTaGFyZWQnICsgQVJSQVlfQlVGRkVSO1xuICB2YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xuICB2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXlbUFJPVE9UWVBFXTtcbiAgdmFyICRBcnJheUJ1ZmZlciA9ICRidWZmZXIuQXJyYXlCdWZmZXI7XG4gIHZhciAkRGF0YVZpZXcgPSAkYnVmZmVyLkRhdGFWaWV3O1xuICB2YXIgYXJyYXlGb3JFYWNoID0gY3JlYXRlQXJyYXlNZXRob2QoMCk7XG4gIHZhciBhcnJheUZpbHRlciA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpO1xuICB2YXIgYXJyYXlTb21lID0gY3JlYXRlQXJyYXlNZXRob2QoMyk7XG4gIHZhciBhcnJheUV2ZXJ5ID0gY3JlYXRlQXJyYXlNZXRob2QoNCk7XG4gIHZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbiAgdmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG4gIHZhciBhcnJheUluY2x1ZGVzID0gY3JlYXRlQXJyYXlJbmNsdWRlcyh0cnVlKTtcbiAgdmFyIGFycmF5SW5kZXhPZiA9IGNyZWF0ZUFycmF5SW5jbHVkZXMoZmFsc2UpO1xuICB2YXIgYXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXM7XG4gIHZhciBhcnJheUtleXMgPSBBcnJheUl0ZXJhdG9ycy5rZXlzO1xuICB2YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcbiAgdmFyIGFycmF5TGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mO1xuICB2YXIgYXJyYXlSZWR1Y2UgPSBBcnJheVByb3RvLnJlZHVjZTtcbiAgdmFyIGFycmF5UmVkdWNlUmlnaHQgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0O1xuICB2YXIgYXJyYXlKb2luID0gQXJyYXlQcm90by5qb2luO1xuICB2YXIgYXJyYXlTb3J0ID0gQXJyYXlQcm90by5zb3J0O1xuICB2YXIgYXJyYXlTbGljZSA9IEFycmF5UHJvdG8uc2xpY2U7XG4gIHZhciBhcnJheVRvU3RyaW5nID0gQXJyYXlQcm90by50b1N0cmluZztcbiAgdmFyIGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBBcnJheVByb3RvLnRvTG9jYWxlU3RyaW5nO1xuICB2YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG4gIHZhciBUQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG4gIHZhciBUWVBFRF9DT05TVFJVQ1RPUiA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKTtcbiAgdmFyIERFRl9DT05TVFJVQ1RPUiA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBBTExfQ09OU1RSVUNUT1JTID0gJHR5cGVkLkNPTlNUUjtcbiAgdmFyIFRZUEVEX0FSUkFZID0gJHR5cGVkLlRZUEVEO1xuICB2YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xuICB2YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT09IDE7XG4gIH0pO1xuXG4gIHZhciBGT1JDRURfU0VUID0gISFVaW50OEFycmF5ICYmICEhVWludDhBcnJheVtQUk9UT1RZUEVdLnNldCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBpZiAoaXNPYmplY3QoaXQpICYmIFRZUEVEX0FSUkFZIGluIGl0KSByZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiAoQywgbGVuZ3RoKSB7XG4gICAgaWYgKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24gKE8sIGxpc3QpIHtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSwgaW50ZXJuYWwpIHtcbiAgICBkUChpdCwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH0gfSk7XG4gIH07XG5cbiAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3Qoc291cmNlKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspIHtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmIChtYXBwaW5nICYmIGFMZW4gPiAyKSBtYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoLyogLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbiAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSkgOiB2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG8gPSB7XG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qICwgZW5kICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCwgZW5kICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbGlkYXRlKHRoYXQpLmxlbmd0aDtcbiAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IG1pZGRsZSkge1xuICAgICAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheVNvbWUodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIE8gPSB2YWxpZGF0ZSh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcbiAgICAgIHZhciAkYmVnaW4gPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciAkc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyogLCBvZmZzZXQgKi8pIHtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIHNyYyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbiArIG9mZnNldCA+IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldClcbiAgICAgICYmIHRhcmdldFtUWVBFRF9BUlJBWV1cbiAgICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcbiAgICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcbiAgdmFyICRnZXREZXNjID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgaWYgKGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICAmJiBpc09iamVjdChkZXNjKVxuICAgICAgJiYgaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgICAmJiAhaGFzKGRlc2MsICdnZXQnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnc2V0JylcbiAgICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgICAmJiAhZGVzYy5jb25maWd1cmFibGVcbiAgICAgICYmICghaGFzKGRlc2MsICd3cml0YWJsZScpIHx8IGRlc2Mud3JpdGFibGUpXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSlcbiAgICApIHtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmICghQUxMX0NPTlNUUlVDVE9SUykge1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAkc2V0RGVzY1xuICB9KTtcblxuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSkge1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICRzbGljZSxcbiAgICBzZXQ6ICRzZXQsXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTsgfVxuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIENMQU1QRUQgPSAhIUNMQU1QRUQ7XG4gICAgdmFyIE5BTUUgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSc7XG4gICAgdmFyIEdFVFRFUiA9ICdnZXQnICsgS0VZO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIEtFWTtcbiAgICB2YXIgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXTtcbiAgICB2YXIgQmFzZSA9IFR5cGVkQXJyYXkgfHwge307XG4gICAgdmFyIFRBQyA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSk7XG4gICAgdmFyIEZPUkNFRCA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWO1xuICAgIHZhciBPID0ge307XG4gICAgdmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5ICYmIFR5cGVkQXJyYXlbUFJPVE9UWVBFXTtcbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4ZmYgPyAweGZmIDogdmFsdWUgJiAweGZmO1xuICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheSgxKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0pIHx8ICEkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgQmFzZSh0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheSkpIGhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYgKCFMSUJSQVJZKSBUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdO1xuICAgIHZhciBDT1JSRUNUX0lURVJfTkFNRSA9ICEhJG5hdGl2ZUl0ZXJhdG9yXG4gICAgICAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcbiAgICB2YXIgJGl0ZXJhdG9yID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgaGlkZShUeXBlZEFycmF5LCBUWVBFRF9DT05TVFJVQ1RPUiwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBUWVBFRF9BUlJBWSwgTkFNRSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIERFRl9DT05TVFJVQ1RPUiwgVHlwZWRBcnJheSk7XG5cbiAgICBpZiAoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSB7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFU1xuICAgIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IEJhc2Uub2YuY2FsbChUeXBlZEFycmF5LCAxKTsgfSksIE5BTUUsIHtcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QLCBOQU1FLCBwcm90byk7XG5cbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRURfU0VULCBOQU1FLCB7IHNldDogJHNldCB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgIGlmICghTElCUkFSWSAmJiBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgPSBhcnJheVRvU3RyaW5nO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7IHNsaWNlOiAkc2xpY2UgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHsgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZyB9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmICghTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCEnO1xudmFyICRBcnJheUJ1ZmZlciA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdO1xudmFyICREYXRhVmlldyA9IGdsb2JhbFtEQVRBX1ZJRVddO1xudmFyIE1hdGggPSBnbG9iYWwuTWF0aDtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXNcbnZhciBJbmZpbml0eSA9IGdsb2JhbC5JbmZpbml0eTtcbnZhciBCYXNlQnVmZmVyID0gJEFycmF5QnVmZmVyO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcbnZhciBCVUZGRVIgPSAnYnVmZmVyJztcbnZhciBCWVRFX0xFTkdUSCA9ICdieXRlTGVuZ3RoJztcbnZhciBCWVRFX09GRlNFVCA9ICdieXRlT2Zmc2V0JztcbnZhciAkQlVGRkVSID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSO1xudmFyICRMRU5HVEggPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSDtcbnZhciAkT0ZGU0VUID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG5mdW5jdGlvbiBwYWNrSUVFRTc1NCh2YWx1ZSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobkJ5dGVzKTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICB2YXIgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmICh2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiB1bnBhY2tJRUVFNzU0KGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBlTGVuIC0gNztcbiAgdmFyIGkgPSBuQnl0ZXMgLSAxO1xuICB2YXIgcyA9IGJ1ZmZlcltpLS1dO1xuICB2YXIgZSA9IHMgJiAxMjc7XG4gIHZhciBtO1xuICBzID4+PSA3O1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrSTMyKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufVxuZnVuY3Rpb24gcGFja0k4KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMTYoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMzIoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrRjY0KGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufVxuZnVuY3Rpb24gcGFja0YzMihpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn1cblxuZnVuY3Rpb24gYWRkR2V0dGVyKEMsIGtleSwgaW50ZXJuYWwpIHtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykgc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59XG5cbmlmICghJHR5cGVkLkFCVikge1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgobGVuZ3RoKTtcbiAgICB0aGlzLl9iID0gYXJyYXlGaWxsLmNhbGwobmV3IEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBidWZmZXJbJExFTkdUSF07XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyLCA4KTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAkQXJyYXlCdWZmZXIoMSk7XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gJEFycmF5QnVmZmVyLm5hbWUgIT0gQVJSQVlfQlVGRkVSO1xuICB9KSkge1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHRvSW5kZXgobGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSBoaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH1cbiAgICBpZiAoIUxJQlJBUlkpIEFycmF5QnVmZmVyUHJvdG8uY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKTtcbiAgdmFyICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSkgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFRZUEVEID0gdWlkKCd0eXBlZF9hcnJheScpO1xudmFyIFZJRVcgPSB1aWQoJ3ZpZXcnKTtcbnZhciBBQlYgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KTtcbnZhciBDT05TVFIgPSBBQlY7XG52YXIgaSA9IDA7XG52YXIgbCA9IDk7XG52YXIgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlIChpIDwgbCkge1xuICBpZiAoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSkge1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6IEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiBUWVBFRCxcbiAgVklFVzogVklFV1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZmlsdGVyLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNyAvIDE1LjQuNC4yMCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIFNUUklDVCA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyICRuYXRpdmUgPSBbXS5pbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7IGlzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5JykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkbWFwID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ubWFwLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTtcbiIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywgeyBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9IH0pO1xuIiwidmFyIERhdGVQcm90byA9IERhdGUucHJvdG90eXBlO1xudmFyIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRGF0ZVByb3RvW1RPX1NUUklOR107XG52YXIgZ2V0VGltZSA9IERhdGVQcm90by5nZXRUaW1lO1xuaWYgKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcbiIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjggfHwgJyc7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuICAgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG4gICAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuICAgICAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBCYXNlID0gJFJlZ0V4cDtcbnZhciBwcm90byA9ICRSZWdFeHAucHJvdG90eXBlO1xudmFyIHJlMSA9IC9hL2c7XG52YXIgcmUyID0gL2EvZztcbi8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxudmFyIENPUlJFQ1RfTkVXID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7XG4gIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKSB7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZikge1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHA7XG4gICAgdmFyIHBpUkUgPSBpc1JlZ0V4cChwKTtcbiAgICB2YXIgZmlVID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcFxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZilcbiAgICAgICAgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZilcbiAgICAgICwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoaXQpIHsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7KSBwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xucmVxdWlyZSgnLi9fZXhwb3J0Jykoe1xuICB0YXJnZXQ6ICdSZWdFeHAnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiByZWdleHBFeGVjICE9PSAvLi8uZXhlY1xufSwge1xuICBleGVjOiByZWdleHBFeGVjXG59KTtcbiIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgICBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQG1hdGNoXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkbWF0Y2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoIXJ4Lmdsb2JhbCkgcmV0dXJuIHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUykpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBBW25dID0gbWF0Y2hTdHI7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuID09PSAwID8gbnVsbCA6IEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJmAnXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJmAnXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG5cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgIHZhciBjYXB0dXJlO1xuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBjaDtcbiAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gY2g7XG4gICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgIH0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgc2FtZVZhbHVlID0gcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG4vLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc2VhcmNoXG4gICAgZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc2VhcmNoXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkc2VhcmNoLCByZWdleHAsIHRoaXMpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIHByZXZpb3VzTGFzdEluZGV4ID0gcngubGFzdEluZGV4O1xuICAgICAgaWYgKCFzYW1lVmFsdWUocHJldmlvdXNMYXN0SW5kZXgsIDApKSByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgaWYgKCFzYW1lVmFsdWUocngubGFzdEluZGV4LCBwcmV2aW91c0xhc3RJbmRleCkpIHJ4Lmxhc3RJbmRleCA9IHByZXZpb3VzTGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IC0xIDogcmVzdWx0LmluZGV4O1xuICAgIH1cbiAgXTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY2FsbFJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xudmFyICRtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgJFNQTElUID0gJ3NwbGl0JztcbnZhciBMRU5HVEggPSAnbGVuZ3RoJztcbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxudmFyIFNVUFBPUlRTX1kgPSAhIShmdW5jdGlvbiAoKSB7IHRyeSB7IHJldHVybiBuZXcgUmVnRXhwKCd4JywgJ3knKTsgfSBjYXRjaCAoZSkge30gfSkoKTtcblxuLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG4gIGlmIChcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gJHNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogJHNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gJHNwbGl0O1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzcGxpdHRlci5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpXG4gICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09ICRzcGxpdCk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyeC51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKFNVUFBPUlRTX1kgPyAneScgOiAnZycpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoU1VQUE9SVFNfWSA/IHJ4IDogJ14oPzonICsgcnguc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDB4ZmZmZmZmZmYgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gU1VQUE9SVFNfWSA/IHEgOiAwO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTVVBQT1JUU19ZID8gUyA6IFMuc2xpY2UocSkpO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAoZSA9ICRtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmIChyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLkpTRW5jcnlwdCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgQklfUk0gPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuZnVuY3Rpb24gaW50MmNoYXIobikge1xuICAgIHJldHVybiBCSV9STS5jaGFyQXQobik7XG59XG4vLyNyZWdpb24gQklUX09QRVJBVElPTlNcbi8vIChwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCwgeSkge1xuICAgIHJldHVybiB4ICYgeTtcbn1cbi8vIChwdWJsaWMpIHRoaXMgfCBhXG5mdW5jdGlvbiBvcF9vcih4LCB5KSB7XG4gICAgcmV0dXJuIHggfCB5O1xufVxuLy8gKHB1YmxpYykgdGhpcyBeIGFcbmZ1bmN0aW9uIG9wX3hvcih4LCB5KSB7XG4gICAgcmV0dXJuIHggXiB5O1xufVxuLy8gKHB1YmxpYykgdGhpcyAmIH5hXG5mdW5jdGlvbiBvcF9hbmRub3QoeCwgeSkge1xuICAgIHJldHVybiB4ICYgfnk7XG59XG4vLyByZXR1cm4gaW5kZXggb2YgbG93ZXN0IDEtYml0IGluIHgsIHggPCAyXjMxXG5mdW5jdGlvbiBsYml0KHgpIHtcbiAgICBpZiAoeCA9PSAwKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgoeCAmIDB4ZmZmZikgPT0gMCkge1xuICAgICAgICB4ID4+PSAxNjtcbiAgICAgICAgciArPSAxNjtcbiAgICB9XG4gICAgaWYgKCh4ICYgMHhmZikgPT0gMCkge1xuICAgICAgICB4ID4+PSA4O1xuICAgICAgICByICs9IDg7XG4gICAgfVxuICAgIGlmICgoeCAmIDB4ZikgPT0gMCkge1xuICAgICAgICB4ID4+PSA0O1xuICAgICAgICByICs9IDQ7XG4gICAgfVxuICAgIGlmICgoeCAmIDMpID09IDApIHtcbiAgICAgICAgeCA+Pj0gMjtcbiAgICAgICAgciArPSAyO1xuICAgIH1cbiAgICBpZiAoKHggJiAxKSA9PSAwKSB7XG4gICAgICAgICsrcjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG4vLyByZXR1cm4gbnVtYmVyIG9mIDEgYml0cyBpbiB4XG5mdW5jdGlvbiBjYml0KHgpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgd2hpbGUgKHggIT0gMCkge1xuICAgICAgICB4ICY9IHggLSAxO1xuICAgICAgICArK3I7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuLy8jZW5kcmVnaW9uIEJJVF9PUEVSQVRJT05TXG5cbnZhciBiNjRtYXAgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBiNjRwYWQgPSBcIj1cIjtcbmZ1bmN0aW9uIGhleDJiNjQoaCkge1xuICAgIHZhciBpO1xuICAgIHZhciBjO1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIGZvciAoaSA9IDA7IGkgKyAzIDw9IGgubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgYyA9IHBhcnNlSW50KGguc3Vic3RyaW5nKGksIGkgKyAzKSwgMTYpO1xuICAgICAgICByZXQgKz0gYjY0bWFwLmNoYXJBdChjID4+IDYpICsgYjY0bWFwLmNoYXJBdChjICYgNjMpO1xuICAgIH1cbiAgICBpZiAoaSArIDEgPT0gaC5sZW5ndGgpIHtcbiAgICAgICAgYyA9IHBhcnNlSW50KGguc3Vic3RyaW5nKGksIGkgKyAxKSwgMTYpO1xuICAgICAgICByZXQgKz0gYjY0bWFwLmNoYXJBdChjIDw8IDIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpICsgMiA9PSBoLmxlbmd0aCkge1xuICAgICAgICBjID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XG4gICAgICAgIHJldCArPSBiNjRtYXAuY2hhckF0KGMgPj4gMikgKyBiNjRtYXAuY2hhckF0KChjICYgMykgPDwgNCk7XG4gICAgfVxuICAgIHdoaWxlICgocmV0Lmxlbmd0aCAmIDMpID4gMCkge1xuICAgICAgICByZXQgKz0gYjY0cGFkO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8gY29udmVydCBhIGJhc2U2NCBzdHJpbmcgdG8gaGV4XG5mdW5jdGlvbiBiNjR0b2hleChzKSB7XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgdmFyIGk7XG4gICAgdmFyIGsgPSAwOyAvLyBiNjQgc3RhdGUsIDAtM1xuICAgIHZhciBzbG9wID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gYjY0cGFkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdiA9IGI2NG1hcC5pbmRleE9mKHMuY2hhckF0KGkpKTtcbiAgICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIodiA+PiAyKTtcbiAgICAgICAgICAgIHNsb3AgPSB2ICYgMztcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGsgPT0gMSkge1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKChzbG9wIDw8IDIpIHwgKHYgPj4gNCkpO1xuICAgICAgICAgICAgc2xvcCA9IHYgJiAweGY7XG4gICAgICAgICAgICBrID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrID09IDIpIHtcbiAgICAgICAgICAgIHJldCArPSBpbnQyY2hhcihzbG9wKTtcbiAgICAgICAgICAgIHJldCArPSBpbnQyY2hhcih2ID4+IDIpO1xuICAgICAgICAgICAgc2xvcCA9IHYgJiAzO1xuICAgICAgICAgICAgayA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIoKHNsb3AgPDwgMikgfCAodiA+PiA0KSk7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIodiAmIDB4Zik7XG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoayA9PSAxKSB7XG4gICAgICAgIHJldCArPSBpbnQyY2hhcihzbG9wIDw8IDIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XG5cbi8vIEhleCBKYXZhU2NyaXB0IGRlY29kZXJcbi8vIENvcHlyaWdodCAoYykgMjAwOC0yMDEzIExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0PlxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4vLyBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXG52YXIgZGVjb2RlcjtcbnZhciBIZXggPSB7XG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGRlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGhleCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiO1xuICAgICAgICAgICAgdmFyIGlnbm9yZSA9IFwiIFxcZlxcblxcclxcdFxcdTAwQTBcXHUyMDI4XFx1MjAyOVwiO1xuICAgICAgICAgICAgZGVjb2RlciA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyW2hleC5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhleCA9IGhleC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChpID0gMTA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcltoZXguY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaWdub3JlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcltpZ25vcmUuY2hhckF0KGkpXSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgdmFyIGJpdHMgPSAwO1xuICAgICAgICB2YXIgY2hhcl9jb3VudCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGEuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSBkZWNvZGVyW2NdO1xuICAgICAgICAgICAgaWYgKGMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGNoYXJhY3RlciBhdCBvZmZzZXQgXCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgfD0gYztcbiAgICAgICAgICAgIGlmICgrK2NoYXJfY291bnQgPj0gMikge1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICAgICAgY2hhcl9jb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaXRzIDw8PSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyX2NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZXggZW5jb2RpbmcgaW5jb21wbGV0ZTogNCBiaXRzIG1pc3NpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59O1xuXG4vLyBCYXNlNjQgSmF2YVNjcmlwdCBkZWNvZGVyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxMyBMYXBvIEx1Y2hpbmkgPGxhcG9AbGFwby5pdD5cbi8vIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuLy8gcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuLy8gV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcbi8vIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbi8vIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcbi8vIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIGltbWVkOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCB1bmRlZjogdHJ1ZSwgcmVnZXhkYXNoOiBmYWxzZSAqL1xudmFyIGRlY29kZXIkMTtcbnZhciBCYXNlNjQgPSB7XG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGRlY29kZXIkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gICAgICAgICAgICB2YXIgaWdub3JlID0gXCI9IFxcZlxcblxcclxcdFxcdTAwQTBcXHUyMDI4XFx1MjAyOVwiO1xuICAgICAgICAgICAgZGVjb2RlciQxID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlciQxW2I2NC5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpZ25vcmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyJDFbaWdub3JlLmNoYXJBdChpKV0gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBiaXRzID0gMDtcbiAgICAgICAgdmFyIGNoYXJfY291bnQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSBhLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gZGVjb2RlciQxW2NdO1xuICAgICAgICAgICAgaWYgKGMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGNoYXJhY3RlciBhdCBvZmZzZXQgXCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgfD0gYztcbiAgICAgICAgICAgIGlmICgrK2NoYXJfY291bnQgPj0gNCkge1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDE2KTtcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gYml0cyAmIDB4RkY7XG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICAgICAgY2hhcl9jb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaXRzIDw8PSA2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY2hhcl9jb3VudCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NCBlbmNvZGluZyBpbmNvbXBsZXRlOiBhdCBsZWFzdCAyIGJpdHMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiAxMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gKGJpdHMgPj4gMTYpO1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG4gICAgcmU6IC8tLS0tLUJFR0lOIFteLV0rLS0tLS0oW0EtWmEtejAtOStcXC89XFxzXSspLS0tLS1FTkQgW14tXSstLS0tLXxiZWdpbi1iYXNlNjRbXlxcbl0rXFxuKFtBLVphLXowLTkrXFwvPVxcc10rKT09PT0vLFxuICAgIHVuYXJtb3I6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBtID0gQmFzZTY0LnJlLmV4ZWMoYSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBpZiAobVsxXSkge1xuICAgICAgICAgICAgICAgIGEgPSBtWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobVsyXSkge1xuICAgICAgICAgICAgICAgIGEgPSBtWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnRXhwIG91dCBvZiBzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYXNlNjQuZGVjb2RlKGEpO1xuICAgIH1cbn07XG5cbi8vIEJpZyBpbnRlZ2VyIGJhc2UtMTAgcHJpbnRpbmcgbGlicmFyeVxuLy8gQ29weXJpZ2h0IChjKSAyMDE0IExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0PlxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4vLyBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXG52YXIgbWF4ID0gMTAwMDAwMDAwMDAwMDA7IC8vIGJpZ2dlc3QgaW50ZWdlciB0aGF0IGNhbiBzdGlsbCBmaXQgMl41MyB3aGVuIG11bHRpcGxpZWQgYnkgMjU2XG52YXIgSW50MTAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50MTAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWYgPSBbK3ZhbHVlIHx8IDBdO1xuICAgIH1cbiAgICBJbnQxMC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gKG0sIGMpIHtcbiAgICAgICAgLy8gYXNzZXJ0KG0gPD0gMjU2KVxuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xuICAgICAgICB2YXIgbCA9IGIubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHQgPSBiW2ldICogbSArIGM7XG4gICAgICAgICAgICBpZiAodCA8IG1heCkge1xuICAgICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYyA9IDAgfCAodCAvIG1heCk7XG4gICAgICAgICAgICAgICAgdCAtPSBjICogbWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYltpXSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPiAwKSB7XG4gICAgICAgICAgICBiW2ldID0gYztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW50MTAucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIGFzc2VydChtIDw9IDI1NilcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgdmFyIGwgPSBiLmxlbmd0aDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICB0ID0gYltpXSAtIGM7XG4gICAgICAgICAgICBpZiAodCA8IDApIHtcbiAgICAgICAgICAgICAgICB0ICs9IG1heDtcbiAgICAgICAgICAgICAgICBjID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYltpXSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGJbYi5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICAgICAgYi5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW50MTAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgaWYgKChiYXNlIHx8IDEwKSAhPSAxMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25seSBiYXNlIDEwIGlzIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xuICAgICAgICB2YXIgcyA9IGJbYi5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICBmb3IgKHZhciBpID0gYi5sZW5ndGggLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcyArPSAobWF4ICsgYltpXSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBJbnQxMC5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgdmFyIHYgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gYi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdiA9IHYgKiBtYXggKyBiW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgSW50MTAucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xuICAgICAgICByZXR1cm4gKGIubGVuZ3RoID09IDEpID8gYlswXSA6IHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gSW50MTA7XG59KCkpO1xuXG4vLyBBU04uMSBKYXZhU2NyaXB0IGRlY29kZXJcbnZhciBlbGxpcHNpcyA9IFwiXFx1MjAyNlwiO1xudmFyIHJlVGltZVMgPSAvXihcXGRcXGQpKDBbMS05XXwxWzAtMl0pKDBbMS05XXxbMTJdXFxkfDNbMDFdKShbMDFdXFxkfDJbMC0zXSkoPzooWzAtNV1cXGQpKD86KFswLTVdXFxkKSg/OlsuLF0oXFxkezEsM30pKT8pPyk/KFp8Wy0rXSg/OlswXVxcZHwxWzAtMl0pKFswLTVdXFxkKT8pPyQvO1xudmFyIHJlVGltZUwgPSAvXihcXGRcXGRcXGRcXGQpKDBbMS05XXwxWzAtMl0pKDBbMS05XXxbMTJdXFxkfDNbMDFdKShbMDFdXFxkfDJbMC0zXSkoPzooWzAtNV1cXGQpKD86KFswLTVdXFxkKSg/OlsuLF0oXFxkezEsM30pKT8pPyk/KFp8Wy0rXSg/OlswXVxcZHwxWzAtMl0pKFswLTVdXFxkKT8pPyQvO1xuZnVuY3Rpb24gc3RyaW5nQ3V0KHN0ciwgbGVuKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPiBsZW4pIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBsZW4pICsgZWxsaXBzaXM7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG52YXIgU3RyZWFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmVhbShlbmMsIHBvcykge1xuICAgICAgICB0aGlzLmhleERpZ2l0cyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiO1xuICAgICAgICBpZiAoZW5jIGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLmVuYyA9IGVuYy5lbmM7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGVuYy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmMgc2hvdWxkIGJlIGFuIGFycmF5IG9yIGEgYmluYXJ5IHN0cmluZ1xuICAgICAgICAgICAgdGhpcy5lbmMgPSBlbmM7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdHJlYW0ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy5lbmMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0aW5nIGJ5dGUgb2Zmc2V0IFwiICsgcG9zICsgXCIgb24gYSBzdHJlYW0gb2YgbGVuZ3RoIFwiICsgdGhpcy5lbmMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGlzLmVuYykgPyB0aGlzLmVuYy5jaGFyQ29kZUF0KHBvcykgOiB0aGlzLmVuY1twb3NdO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5oZXhCeXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGV4RGlnaXRzLmNoYXJBdCgoYiA+PiA0KSAmIDB4RikgKyB0aGlzLmhleERpZ2l0cy5jaGFyQXQoYiAmIDB4Rik7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLmhleER1bXAgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcmF3KSB7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHMgKz0gdGhpcy5oZXhCeXRlKHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgICAgIGlmIChyYXcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGkgJiAweEYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IFwiICBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBcIiBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLmlzQVNDSUkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldChpKTtcbiAgICAgICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDE3Nikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VTdHJpbmdJU08gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVN0cmluZ1VURiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOykge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldChpKyspO1xuICAgICAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoYyA+IDE5MSkgJiYgKGMgPCAyMjQpKSB7XG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MUYpIDw8IDYpIHwgKHRoaXMuZ2V0KGkrKykgJiAweDNGKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgwRikgPDwgMTIpIHwgKCh0aGlzLmdldChpKyspICYgMHgzRikgPDwgNikgfCAodGhpcy5nZXQoaSsrKSAmIDB4M0YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VTdHJpbmdCTVAgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgdmFyIGhpO1xuICAgICAgICB2YXIgbG87XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDspIHtcbiAgICAgICAgICAgIGhpID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgICAgIGxvID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChoaSA8PCA4KSB8IGxvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVRpbWUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc2hvcnRZZWFyKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5wYXJzZVN0cmluZ0lTTyhzdGFydCwgZW5kKTtcbiAgICAgICAgdmFyIG0gPSAoc2hvcnRZZWFyID8gcmVUaW1lUyA6IHJlVGltZUwpLmV4ZWMocyk7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVW5yZWNvZ25pemVkIHRpbWU6IFwiICsgcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvcnRZZWFyKSB7XG4gICAgICAgICAgICAvLyB0byBhdm9pZCBxdWVyeWluZyB0aGUgdGltZXIsIHVzZSB0aGUgZml4ZWQgcmFuZ2UgWzE5NzAsIDIwNjldXG4gICAgICAgICAgICAvLyBpdCB3aWxsIGNvbmZvcm0gd2l0aCBJVFUgWC40MDAgWy0xMCwgKzQwXSBzbGlkaW5nIHdpbmRvdyB1bnRpbCAyMDMwXG4gICAgICAgICAgICBtWzFdID0gK21bMV07XG4gICAgICAgICAgICBtWzFdICs9ICgrbVsxXSA8IDcwKSA/IDIwMDAgOiAxOTAwO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBtWzFdICsgXCItXCIgKyBtWzJdICsgXCItXCIgKyBtWzNdICsgXCIgXCIgKyBtWzRdO1xuICAgICAgICBpZiAobVs1XSkge1xuICAgICAgICAgICAgcyArPSBcIjpcIiArIG1bNV07XG4gICAgICAgICAgICBpZiAobVs2XSkge1xuICAgICAgICAgICAgICAgIHMgKz0gXCI6XCIgKyBtWzZdO1xuICAgICAgICAgICAgICAgIGlmIChtWzddKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXCIuXCIgKyBtWzddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobVs4XSkge1xuICAgICAgICAgICAgcyArPSBcIiBVVENcIjtcbiAgICAgICAgICAgIGlmIChtWzhdICE9IFwiWlwiKSB7XG4gICAgICAgICAgICAgICAgcyArPSBtWzhdO1xuICAgICAgICAgICAgICAgIGlmIChtWzldKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXCI6XCIgKyBtWzldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VJbnRlZ2VyID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldChzdGFydCk7XG4gICAgICAgIHZhciBuZWcgPSAodiA+IDEyNyk7XG4gICAgICAgIHZhciBwYWQgPSBuZWcgPyAyNTUgOiAwO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIC8vIHNraXAgdW51c2VmdWwgYml0cyAobm90IGFsbG93ZWQgaW4gREVSKVxuICAgICAgICB3aGlsZSAodiA9PSBwYWQgJiYgKytzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5lZyA/IC0xIDogMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG93IGJpdCBsZW5ndGggb2YgaHVnZSBpbnRlZ2Vyc1xuICAgICAgICBpZiAobGVuID4gNCkge1xuICAgICAgICAgICAgcyA9IHY7XG4gICAgICAgICAgICBsZW4gPDw9IDM7XG4gICAgICAgICAgICB3aGlsZSAoKCgrcyBeIHBhZCkgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcyA9ICtzIDw8IDE7XG4gICAgICAgICAgICAgICAgLS1sZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gXCIoXCIgKyBsZW4gKyBcIiBiaXQpXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVjb2RlIHRoZSBpbnRlZ2VyXG4gICAgICAgIGlmIChuZWcpIHtcbiAgICAgICAgICAgIHYgPSB2IC0gMjU2O1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gbmV3IEludDEwKHYpO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQgKyAxOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIG4ubXVsQWRkKDI1NiwgdGhpcy5nZXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzICsgbi50b1N0cmluZygpO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZUJpdFN0cmluZyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHVudXNlZEJpdCA9IHRoaXMuZ2V0KHN0YXJ0KTtcbiAgICAgICAgdmFyIGxlbkJpdCA9ICgoZW5kIC0gc3RhcnQgLSAxKSA8PCAzKSAtIHVudXNlZEJpdDtcbiAgICAgICAgdmFyIGludHJvID0gXCIoXCIgKyBsZW5CaXQgKyBcIiBiaXQpXFxuXCI7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0KGkpO1xuICAgICAgICAgICAgdmFyIHNraXAgPSAoaSA9PSBlbmQgLSAxKSA/IHVudXNlZEJpdCA6IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gNzsgaiA+PSBza2lwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBzICs9IChiID4+IGopICYgMSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50cm8gKyBzdHJpbmdDdXQocywgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50cm8gKyBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZU9jdGV0U3RyaW5nID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG1heExlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5pc0FTQ0lJKHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHRoaXMucGFyc2VTdHJpbmdJU08oc3RhcnQsIGVuZCksIG1heExlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICB2YXIgcyA9IFwiKFwiICsgbGVuICsgXCIgYnl0ZSlcXG5cIjtcbiAgICAgICAgbWF4TGVuZ3RoIC89IDI7IC8vIHdlIHdvcmsgaW4gYnl0ZXNcbiAgICAgICAgaWYgKGxlbiA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBtYXhMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHMgKz0gdGhpcy5oZXhCeXRlKHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBzICs9IGVsbGlwc2lzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZU9JRCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xuICAgICAgICB2YXIgbiA9IG5ldyBJbnQxMCgpO1xuICAgICAgICB2YXIgYml0cyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0KGkpO1xuICAgICAgICAgICAgbi5tdWxBZGQoMTI4LCB2ICYgMHg3Rik7XG4gICAgICAgICAgICBiaXRzICs9IDc7XG4gICAgICAgICAgICBpZiAoISh2ICYgMHg4MCkpIHsgLy8gZmluaXNoZWRcbiAgICAgICAgICAgICAgICBpZiAocyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5zaW1wbGlmeSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEludDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnN1Yig4MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gXCIyLlwiICsgbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBuIDwgODAgPyBuIDwgNDAgPyAwIDogMSA6IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbSArIFwiLlwiICsgKG4gLSBtICogNDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzICs9IFwiLlwiICsgbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dChzLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuID0gbmV3IEludDEwKCk7XG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICBzICs9IFwiLmluY29tcGxldGVcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIHJldHVybiBTdHJlYW07XG59KCkpO1xudmFyIEFTTjEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQVNOMShzdHJlYW0sIGhlYWRlciwgbGVuZ3RoLCB0YWcsIHN1Yikge1xuICAgICAgICBpZiAoISh0YWcgaW5zdGFuY2VvZiBBU04xVGFnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YWcgdmFsdWUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YjtcbiAgICB9XG4gICAgQVNOMS5wcm90b3R5cGUudHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50YWcudGFnQ2xhc3MpIHtcbiAgICAgICAgICAgIGNhc2UgMDogLy8gdW5pdmVyc2FsXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRhZy50YWdOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRU9DXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJPT0xFQU5cIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSU5URUdFUlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJCSVRfU1RSSU5HXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk9DVEVUX1NUUklOR1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJOVUxMXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk9CSkVDVF9JREVOVElGSUVSXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk9iamVjdERlc2NyaXB0b3JcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRVhURVJOQUxcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUkVBTFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MEE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFTlVNRVJBVEVEXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwQjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVNQkVEREVEX1BEVlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MEM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJVVEY4U3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlNFUVVFTkNFXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlNFVFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJOdW1lcmljU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlByaW50YWJsZVN0cmluZ1wiOyAvLyBBU0NJSSBzdWJzZXRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVGVsZXRleFN0cmluZ1wiOyAvLyBha2EgVDYxU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlZpZGVvdGV4U3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIklBNVN0cmluZ1wiOyAvLyBBU0NJSVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJVVENUaW1lXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdlbmVyYWxpemVkVGltZVwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJHcmFwaGljU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlZpc2libGVTdHJpbmdcIjsgLy8gQVNDSUkgc3Vic2V0XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxQjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdlbmVyYWxTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDFDOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVW5pdmVyc2FsU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJNUFN0cmluZ1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJVbml2ZXJzYWxfXCIgKyB0aGlzLnRhZy50YWdOdW1iZXIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJBcHBsaWNhdGlvbl9cIiArIHRoaXMudGFnLnRhZ051bWJlci50b1N0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIltcIiArIHRoaXMudGFnLnRhZ051bWJlci50b1N0cmluZygpICsgXCJdXCI7IC8vIENvbnRleHRcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJQcml2YXRlX1wiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAobWF4TGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4TGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5wb3NDb250ZW50KCk7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLmFicyh0aGlzLmxlbmd0aCk7XG4gICAgICAgIGlmICghdGhpcy50YWcuaXNVbml2ZXJzYWwoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgdGhpcy5zdWIubGVuZ3RoICsgXCIgZWxlbSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wYXJzZU9jdGV0U3RyaW5nKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sIG1heExlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnRhZy50YWdOdW1iZXIpIHtcbiAgICAgICAgICAgIGNhc2UgMHgwMTogLy8gQk9PTEVBTlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5zdHJlYW0uZ2V0KGNvbnRlbnQpID09PSAwKSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiO1xuICAgICAgICAgICAgY2FzZSAweDAyOiAvLyBJTlRFR0VSXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBhcnNlSW50ZWdlcihjb250ZW50LCBjb250ZW50ICsgbGVuKTtcbiAgICAgICAgICAgIGNhc2UgMHgwMzogLy8gQklUX1NUUklOR1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YiA/IFwiKFwiICsgdGhpcy5zdWIubGVuZ3RoICsgXCIgZWxlbSlcIiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhcnNlQml0U3RyaW5nKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sIG1heExlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4MDQ6IC8vIE9DVEVUX1NUUklOR1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YiA/IFwiKFwiICsgdGhpcy5zdWIubGVuZ3RoICsgXCIgZWxlbSlcIiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhcnNlT2N0ZXRTdHJpbmcoY29udGVudCwgY29udGVudCArIGxlbiwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwNTogLy8gTlVMTFxuICAgICAgICAgICAgY2FzZSAweDA2OiAvLyBPQkpFQ1RfSURFTlRJRklFUlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wYXJzZU9JRChjb250ZW50LCBjb250ZW50ICsgbGVuLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgLy8gY2FzZSAweDA3OiAvLyBPYmplY3REZXNjcmlwdG9yXG4gICAgICAgICAgICAvLyBjYXNlIDB4MDg6IC8vIEVYVEVSTkFMXG4gICAgICAgICAgICAvLyBjYXNlIDB4MDk6IC8vIFJFQUxcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwQTogLy8gRU5VTUVSQVRFRFxuICAgICAgICAgICAgLy8gY2FzZSAweDBCOiAvLyBFTUJFRERFRF9QRFZcbiAgICAgICAgICAgIGNhc2UgMHgxMDogLy8gU0VRVUVOQ0VcbiAgICAgICAgICAgIGNhc2UgMHgxMTogLy8gU0VUXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIHRoaXMuc3ViLmxlbmd0aCArIFwiIGVsZW0pXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIobm8gZWxlbSlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDB4MEM6IC8vIFVURjhTdHJpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHRoaXMuc3RyZWFtLnBhcnNlU3RyaW5nVVRGKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4pLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgY2FzZSAweDEyOiAvLyBOdW1lcmljU3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MTM6IC8vIFByaW50YWJsZVN0cmluZ1xuICAgICAgICAgICAgY2FzZSAweDE0OiAvLyBUZWxldGV4U3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MTU6IC8vIFZpZGVvdGV4U3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MTY6IC8vIElBNVN0cmluZ1xuICAgICAgICAgICAgLy8gY2FzZSAweDE5OiAvLyBHcmFwaGljU3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MUE6IC8vIFZpc2libGVTdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDB4MUI6IC8vIEdlbmVyYWxTdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDB4MUM6IC8vIFVuaXZlcnNhbFN0cmluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQodGhpcy5zdHJlYW0ucGFyc2VTdHJpbmdJU08oY29udGVudCwgY29udGVudCArIGxlbiksIG1heExlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4MUU6IC8vIEJNUFN0cmluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQodGhpcy5zdHJlYW0ucGFyc2VTdHJpbmdCTVAoY29udGVudCwgY29udGVudCArIGxlbiksIG1heExlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4MTc6IC8vIFVUQ1RpbWVcbiAgICAgICAgICAgIGNhc2UgMHgxODogLy8gR2VuZXJhbGl6ZWRUaW1lXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBhcnNlVGltZShjb250ZW50LCBjb250ZW50ICsgbGVuLCAodGhpcy50YWcudGFnTnVtYmVyID09IDB4MTcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlTmFtZSgpICsgXCJAXCIgKyB0aGlzLnN0cmVhbS5wb3MgKyBcIltoZWFkZXI6XCIgKyB0aGlzLmhlYWRlciArIFwiLGxlbmd0aDpcIiArIHRoaXMubGVuZ3RoICsgXCIsc3ViOlwiICsgKCh0aGlzLnN1YiA9PT0gbnVsbCkgPyBcIm51bGxcIiA6IHRoaXMuc3ViLmxlbmd0aCkgKyBcIl1cIjtcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnRvUHJldHR5U3RyaW5nID0gZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICBpZiAoaW5kZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluZGVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBpbmRlbnQgKyB0aGlzLnR5cGVOYW1lKCkgKyBcIiBAXCIgKyB0aGlzLnN0cmVhbS5wb3M7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICBzICs9IFwiK1wiO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLnRhZy50YWdDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgcyArPSBcIiAoY29uc3RydWN0ZWQpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMudGFnLmlzVW5pdmVyc2FsKCkgJiYgKCh0aGlzLnRhZy50YWdOdW1iZXIgPT0gMHgwMykgfHwgKHRoaXMudGFnLnRhZ051bWJlciA9PSAweDA0KSkpICYmICh0aGlzLnN1YiAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHMgKz0gXCIgKGVuY2Fwc3VsYXRlcylcIjtcbiAgICAgICAgfVxuICAgICAgICBzICs9IFwiXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLnN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5kZW50ICs9IFwiICBcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSB0aGlzLnN1Yi5sZW5ndGg7IGkgPCBtYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIHMgKz0gdGhpcy5zdWJbaV0udG9QcmV0dHlTdHJpbmcoaW5kZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnBvc1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9zO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUucG9zQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBvcyArIHRoaXMuaGVhZGVyO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUucG9zRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9zICsgdGhpcy5oZWFkZXIgKyBNYXRoLmFicyh0aGlzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS50b0hleFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLmhleER1bXAodGhpcy5wb3NTdGFydCgpLCB0aGlzLnBvc0VuZCgpLCB0cnVlKTtcbiAgICB9O1xuICAgIEFTTjEuZGVjb2RlTGVuZ3RoID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICB2YXIgYnVmID0gc3RyZWFtLmdldCgpO1xuICAgICAgICB2YXIgbGVuID0gYnVmICYgMHg3RjtcbiAgICAgICAgaWYgKGxlbiA9PSBidWYpIHtcbiAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gcmVhc29uIHRvIHVzZSBJbnQxMCwgYXMgaXQgd291bGQgYmUgYSBodWdlIGJ1ZmZlciBhbnl3YXlzXG4gICAgICAgIGlmIChsZW4gPiA2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb3ZlciA0OCBiaXRzIG5vdCBzdXBwb3J0ZWQgYXQgcG9zaXRpb24gXCIgKyAoc3RyZWFtLnBvcyAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAvLyB1bmRlZmluZWRcbiAgICAgICAgYnVmID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgYnVmID0gKGJ1ZiAqIDI1NikgKyBzdHJlYW0uZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBoZXhhZGVjaW1hbCB2YWx1ZSAoYXMgYSBzdHJpbmcpIG9mIHRoZSBjdXJyZW50IEFTTi4xIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBBU04xLnByb3RvdHlwZS5nZXRIZXhTdHJpbmdWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhleFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuaGVhZGVyICogMjtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoICogMjtcbiAgICAgICAgcmV0dXJuIGhleFN0cmluZy5zdWJzdHIob2Zmc2V0LCBsZW5ndGgpO1xuICAgIH07XG4gICAgQVNOMS5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBzdHJlYW07XG4gICAgICAgIGlmICghKHN0ciBpbnN0YW5jZW9mIFN0cmVhbSkpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBTdHJlYW0oc3RyLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IHN0cjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZWFtU3RhcnQgPSBuZXcgU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIHZhciB0YWcgPSBuZXcgQVNOMVRhZyhzdHJlYW0pO1xuICAgICAgICB2YXIgbGVuID0gQVNOMS5kZWNvZGVMZW5ndGgoc3RyZWFtKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICAgICAgdmFyIGhlYWRlciA9IHN0YXJ0IC0gc3RyZWFtU3RhcnQucG9zO1xuICAgICAgICB2YXIgc3ViID0gbnVsbDtcbiAgICAgICAgdmFyIGdldFN1YiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIGlmIChsZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZpbml0ZSBsZW5ndGhcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBsZW47XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0cmVhbS5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W3JldC5sZW5ndGhdID0gQVNOMS5kZWNvZGUoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5wb3MgIT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRlbnQgc2l6ZSBpcyBub3QgY29ycmVjdCBmb3IgY29udGFpbmVyIHN0YXJ0aW5nIGF0IG9mZnNldCBcIiArIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgbGVuZ3RoXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBBU04xLmRlY29kZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMudGFnLmlzRU9DKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuID0gc3RhcnQgLSBzdHJlYW0ucG9zOyAvLyB1bmRlZmluZWQgbGVuZ3RocyBhcmUgcmVwcmVzZW50ZWQgYXMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4Y2VwdGlvbiB3aGlsZSBkZWNvZGluZyB1bmRlZmluZWQgbGVuZ3RoIGNvbnRlbnQ6IFwiICsgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRhZy50YWdDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgLy8gbXVzdCBoYXZlIHZhbGlkIGNvbnRlbnRcbiAgICAgICAgICAgIHN1YiA9IGdldFN1YigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZy5pc1VuaXZlcnNhbCgpICYmICgodGFnLnRhZ051bWJlciA9PSAweDAzKSB8fCAodGFnLnRhZ051bWJlciA9PSAweDA0KSkpIHtcbiAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBCaXRTdHJpbmcgYW5kIE9jdGV0U3RyaW5nIGFyZSB1c2VkIHRvIGVuY2Fwc3VsYXRlIEFTTi4xXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0YWcudGFnTnVtYmVyID09IDB4MDMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5nZXQoKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCSVQgU1RSSU5HcyB3aXRoIHVudXNlZCBiaXRzIGNhbm5vdCBlbmNhcHN1bGF0ZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViID0gZ2V0U3ViKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YltpXS50YWcuaXNFT0MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRU9DIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBhY3R1YWwgY29udGVudC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGJ1dCBzaWxlbnRseSBpZ25vcmUgd2hlbiB0aGV5IGRvbid0XG4gICAgICAgICAgICAgICAgc3ViID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGVuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2UgY2FuJ3Qgc2tpcCBvdmVyIGFuIGludmFsaWQgdGFnIHdpdGggdW5kZWZpbmVkIGxlbmd0aCBhdCBvZmZzZXQgXCIgKyBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0ucG9zID0gc3RhcnQgKyBNYXRoLmFicyhsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVNOMShzdHJlYW1TdGFydCwgaGVhZGVyLCBsZW4sIHRhZywgc3ViKTtcbiAgICB9O1xuICAgIHJldHVybiBBU04xO1xufSgpKTtcbnZhciBBU04xVGFnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFTTjFUYWcoc3RyZWFtKSB7XG4gICAgICAgIHZhciBidWYgPSBzdHJlYW0uZ2V0KCk7XG4gICAgICAgIHRoaXMudGFnQ2xhc3MgPSBidWYgPj4gNjtcbiAgICAgICAgdGhpcy50YWdDb25zdHJ1Y3RlZCA9ICgoYnVmICYgMHgyMCkgIT09IDApO1xuICAgICAgICB0aGlzLnRhZ051bWJlciA9IGJ1ZiAmIDB4MUY7XG4gICAgICAgIGlmICh0aGlzLnRhZ051bWJlciA9PSAweDFGKSB7IC8vIGxvbmcgdGFnXG4gICAgICAgICAgICB2YXIgbiA9IG5ldyBJbnQxMCgpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGJ1ZiA9IHN0cmVhbS5nZXQoKTtcbiAgICAgICAgICAgICAgICBuLm11bEFkZCgxMjgsIGJ1ZiAmIDB4N0YpO1xuICAgICAgICAgICAgfSB3aGlsZSAoYnVmICYgMHg4MCk7XG4gICAgICAgICAgICB0aGlzLnRhZ051bWJlciA9IG4uc2ltcGxpZnkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBU04xVGFnLnByb3RvdHlwZS5pc1VuaXZlcnNhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnQ2xhc3MgPT09IDB4MDA7XG4gICAgfTtcbiAgICBBU04xVGFnLnByb3RvdHlwZS5pc0VPQyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnQ2xhc3MgPT09IDB4MDAgJiYgdGhpcy50YWdOdW1iZXIgPT09IDB4MDA7XG4gICAgfTtcbiAgICByZXR1cm4gQVNOMVRhZztcbn0oKSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAwNSAgVG9tIFd1XG4vLyBCaXRzIHBlciBkaWdpdFxudmFyIGRiaXRzO1xuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkgJiAweGZmZmZmZikgPT0gMHhlZmNhZmUpO1xuLy8jcmVnaW9uXG52YXIgbG93cHJpbWVzID0gWzIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjksIDMxLCAzNywgNDEsIDQzLCA0NywgNTMsIDU5LCA2MSwgNjcsIDcxLCA3MywgNzksIDgzLCA4OSwgOTcsIDEwMSwgMTAzLCAxMDcsIDEwOSwgMTEzLCAxMjcsIDEzMSwgMTM3LCAxMzksIDE0OSwgMTUxLCAxNTcsIDE2MywgMTY3LCAxNzMsIDE3OSwgMTgxLCAxOTEsIDE5MywgMTk3LCAxOTksIDIxMSwgMjIzLCAyMjcsIDIyOSwgMjMzLCAyMzksIDI0MSwgMjUxLCAyNTcsIDI2MywgMjY5LCAyNzEsIDI3NywgMjgxLCAyODMsIDI5MywgMzA3LCAzMTEsIDMxMywgMzE3LCAzMzEsIDMzNywgMzQ3LCAzNDksIDM1MywgMzU5LCAzNjcsIDM3MywgMzc5LCAzODMsIDM4OSwgMzk3LCA0MDEsIDQwOSwgNDE5LCA0MjEsIDQzMSwgNDMzLCA0MzksIDQ0MywgNDQ5LCA0NTcsIDQ2MSwgNDYzLCA0NjcsIDQ3OSwgNDg3LCA0OTEsIDQ5OSwgNTAzLCA1MDksIDUyMSwgNTIzLCA1NDEsIDU0NywgNTU3LCA1NjMsIDU2OSwgNTcxLCA1NzcsIDU4NywgNTkzLCA1OTksIDYwMSwgNjA3LCA2MTMsIDYxNywgNjE5LCA2MzEsIDY0MSwgNjQzLCA2NDcsIDY1MywgNjU5LCA2NjEsIDY3MywgNjc3LCA2ODMsIDY5MSwgNzAxLCA3MDksIDcxOSwgNzI3LCA3MzMsIDczOSwgNzQzLCA3NTEsIDc1NywgNzYxLCA3NjksIDc3MywgNzg3LCA3OTcsIDgwOSwgODExLCA4MjEsIDgyMywgODI3LCA4MjksIDgzOSwgODUzLCA4NTcsIDg1OSwgODYzLCA4NzcsIDg4MSwgODgzLCA4ODcsIDkwNywgOTExLCA5MTksIDkyOSwgOTM3LCA5NDEsIDk0NywgOTUzLCA5NjcsIDk3MSwgOTc3LCA5ODMsIDk5MSwgOTk3XTtcbnZhciBscGxpbSA9ICgxIDw8IDI2KSAvIGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoIC0gMV07XG4vLyNlbmRyZWdpb25cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG52YXIgQmlnSW50ZWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaWdJbnRlZ2VyKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21OdW1iZXIoYSwgYiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09IG51bGwgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyhhLCAyNTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vI3JlZ2lvbiBQVUJMSUNcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIiArIHRoaXMubmVnYXRlKCkudG9TdHJpbmcoYik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmIChiID09IDE2KSB7XG4gICAgICAgICAgICBrID0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDgpIHtcbiAgICAgICAgICAgIGsgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMikge1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSAzMikge1xuICAgICAgICAgICAgayA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSA0KSB7XG4gICAgICAgICAgICBrID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUmFkaXgoYik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGttID0gKDEgPDwgaykgLSAxO1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdmFyIG0gPSBmYWxzZTtcbiAgICAgICAgdmFyIHIgPSBcIlwiO1xuICAgICAgICB2YXIgaSA9IHRoaXMudDtcbiAgICAgICAgdmFyIHAgPSB0aGlzLkRCIC0gKGkgKiB0aGlzLkRCKSAlIGs7XG4gICAgICAgIGlmIChpLS0gPiAwKSB7XG4gICAgICAgICAgICBpZiAocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzW2ldID4+IHApID4gMCkge1xuICAgICAgICAgICAgICAgIG0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHIgPSBpbnQyY2hhcihkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocCA8IGspIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8IChrIC0gcCk7XG4gICAgICAgICAgICAgICAgICAgIGQgfD0gdGhpc1stLWldID4+IChwICs9IHRoaXMuREIgLSBrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAodGhpc1tpXSA+PiAocCAtPSBrKSkgJiBrbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCArPSB0aGlzLkRCO1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgciArPSBpbnQyY2hhcihkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0gPyByIDogXCIwXCI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbiAgICAvLyAocHVibGljKSAtdGhpc1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuICAgIC8vIChwdWJsaWMpIHx0aGlzfFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuICsgaWYgdGhpcyA+IGEsIC0gaWYgdGhpcyA8IGEsIDAgaWYgZXF1YWxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IHRoaXMucyAtIGEucztcbiAgICAgICAgaWYgKHIgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSB0aGlzLnQ7XG4gICAgICAgIHIgPSBpIC0gYS50O1xuICAgICAgICBpZiAociAhPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucyA8IDApID8gLXIgOiByO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKChyID0gdGhpc1tpXSAtIGFbaV0pICE9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IGJuQml0TGVuZ3RoO1xuICAgIC8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuREIgKiAodGhpcy50IC0gMSkgKyBuYml0cyh0aGlzW3RoaXMudCAtIDFdIF4gKHRoaXMucyAmIHRoaXMuRE0pKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuICAgIC8vIChwdWJsaWMpIHRoaXMgbW9kIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmFicygpLmRpdlJlbVRvKGEsIG51bGwsIHIpO1xuICAgICAgICBpZiAodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkge1xuICAgICAgICAgICAgYS5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvd0ludCA9IGJuTW9kUG93SW50O1xuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0sIDAgPD0gZSA8IDJeMzJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3dJbnQgPSBmdW5jdGlvbiAoZSwgbSkge1xuICAgICAgICB2YXIgejtcbiAgICAgICAgaWYgKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeiA9IG5ldyBNb250Z29tZXJ5KG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cChlLCB6KTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsb25lID0gYm5DbG9uZTtcbiAgICAvLyAocHVibGljKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmNvcHlUbyhyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGludGVnZXJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzWzBdIC0gdGhpcy5EVjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnQgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDwgMzJcbiAgICAgICAgcmV0dXJuICgodGhpc1sxXSAmICgoMSA8PCAoMzIgLSB0aGlzLkRCKSkgLSAxKSkgPDwgdGhpcy5EQikgfCB0aGlzWzBdO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYnl0ZVZhbHVlID0gYm5CeXRlVmFsdWU7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGJ5dGVcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMjQpID4+IDI0O1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hvcnRWYWx1ZSA9IGJuU2hvcnRWYWx1ZTtcbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgc2hvcnQgKGFzc3VtZXMgREI+PTE2KVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMTYpID4+IDE2O1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2lnbnVtID0gYm5TaWdOdW07XG4gICAgLy8gKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50IDw9IDAgfHwgKHRoaXMudCA9PSAxICYmIHRoaXNbMF0gPD0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbiAgICAvLyAocHVibGljKSBjb252ZXJ0IHRvIGJpZ2VuZGlhbiBieXRlIGFycmF5XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy50O1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICByWzBdID0gdGhpcy5zO1xuICAgICAgICB2YXIgcCA9IHRoaXMuREIgLSAoaSAqIHRoaXMuREIpICUgODtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgaWYgKGktLSA+IDApIHtcbiAgICAgICAgICAgIGlmIChwIDwgdGhpcy5EQiAmJiAoZCA9IHRoaXNbaV0gPj4gcCkgIT0gKHRoaXMucyAmIHRoaXMuRE0pID4+IHApIHtcbiAgICAgICAgICAgICAgICByW2srK10gPSBkIHwgKHRoaXMucyA8PCAodGhpcy5EQiAtIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocCA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8ICg4IC0gcCk7XG4gICAgICAgICAgICAgICAgICAgIGQgfD0gdGhpc1stLWldID4+IChwICs9IHRoaXMuREIgLSA4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAodGhpc1tpXSA+PiAocCAtPSA4KSkgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwICs9IHRoaXMuREI7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChkICYgMHg4MCkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkIHw9IC0yNTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID09IDAgJiYgKHRoaXMucyAmIDB4ODApICE9IChkICYgMHg4MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKytrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcltrKytdID0gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBibkVxdWFscztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpID09IDApO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA8IDApID8gdGhpcyA6IGE7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpID4gMCkgPyB0aGlzIDogYTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYml0d2lzZVRvKGEsIG9wX2FuZCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3Bfb3IsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGJuWG9yO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYml0d2lzZVRvKGEsIG9wX3hvciwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gYm5BbmROb3Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfYW5kbm90LCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBibk5vdDtcbiAgICAvLyAocHVibGljKSB+dGhpc1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgcltpXSA9IHRoaXMuRE0gJiB+dGhpc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByLnQgPSB0aGlzLnQ7XG4gICAgICAgIHIucyA9IH50aGlzLnM7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG4gICAgLy8gKHB1YmxpYykgdGhpcyA8PCBuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnJTaGlmdFRvKC1uLCByKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubFNoaWZ0VG8obiwgcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgPj4gblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubFNoaWZ0VG8oLW4sIHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yU2hpZnRUbyhuLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGJuR2V0TG93ZXN0U2V0Qml0O1xuICAgIC8vIChwdWJsaWMpIHJldHVybnMgaW5kZXggb2YgbG93ZXN0IDEtYml0IChvciAtMSBpZiBub25lKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gIT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICogdGhpcy5EQiArIGxiaXQodGhpc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnQgKiB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdENvdW50ID0gYm5CaXRDb3VudDtcbiAgICAvLyAocHVibGljKSByZXR1cm4gbnVtYmVyIG9mIHNldCBiaXRzXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gMDtcbiAgICAgICAgdmFyIHggPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByICs9IGNiaXQodGhpc1tpXSBeIHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUudGVzdEJpdCA9IGJuVGVzdEJpdDtcbiAgICAvLyAocHVibGljKSB0cnVlIGlmZiBudGggYml0IGlzIHNldFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRlc3RCaXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpO1xuICAgICAgICBpZiAoaiA+PSB0aGlzLnQpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zICE9IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKHRoaXNbal0gJiAoMSA8PCAobiAlIHRoaXMuREIpKSkgIT0gMCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zZXRCaXQgPSBiblNldEJpdDtcbiAgICAvLyAocHVibGljKSB0aGlzIHwgKDE8PG4pXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX29yKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gYm5DbGVhckJpdDtcbiAgICAvLyAocHVibGljKSB0aGlzICYgfigxPDxuKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX2FuZG5vdCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgXiAoMTw8bilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX3hvcik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBibkFkZDtcbiAgICAvLyAocHVibGljKSB0aGlzICsgYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYWRkVG8oYSwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBiblN1YnRyYWN0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgLSBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLnN1YlRvKGEsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gYm5NdWx0aXBseTtcbiAgICAvLyAocHVibGljKSB0aGlzICogYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5tdWx0aXBseVRvKGEsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGJuRGl2aWRlO1xuICAgIC8vIChwdWJsaWMpIHRoaXMgLyBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhhLCByLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBiblJlbWFpbmRlcjtcbiAgICAvLyAocHVibGljKSB0aGlzICUgYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuZGl2UmVtVG8oYSwgbnVsbCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG4gICAgLy8gKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHEgPSBuYmkoKTtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhhLCBxLCByKTtcbiAgICAgICAgcmV0dXJuIFtxLCByXTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGJuTW9kUG93O1xuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0gKEhBQyAxNC44NSlcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBmdW5jdGlvbiAoZSwgbSkge1xuICAgICAgICB2YXIgaSA9IGUuYml0TGVuZ3RoKCk7XG4gICAgICAgIHZhciBrO1xuICAgICAgICB2YXIgciA9IG5idigxKTtcbiAgICAgICAgdmFyIHo7XG4gICAgICAgIGlmIChpIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPCAxOCkge1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICAgICAgICBrID0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpIDwgMTQ0KSB7XG4gICAgICAgICAgICBrID0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpIDwgNzY4KSB7XG4gICAgICAgICAgICBrID0gNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGsgPSA2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uaXNFdmVuKCkpIHtcbiAgICAgICAgICAgIHogPSBuZXcgQmFycmV0dChtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVjb21wdXRhdGlvblxuICAgICAgICB2YXIgZyA9IFtdO1xuICAgICAgICB2YXIgbiA9IDM7XG4gICAgICAgIHZhciBrMSA9IGsgLSAxO1xuICAgICAgICB2YXIga20gPSAoMSA8PCBrKSAtIDE7XG4gICAgICAgIGdbMV0gPSB6LmNvbnZlcnQodGhpcyk7XG4gICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgdmFyIGcyID0gbmJpKCk7XG4gICAgICAgICAgICB6LnNxclRvKGdbMV0sIGcyKTtcbiAgICAgICAgICAgIHdoaWxlIChuIDw9IGttKSB7XG4gICAgICAgICAgICAgICAgZ1tuXSA9IG5iaSgpO1xuICAgICAgICAgICAgICAgIHoubXVsVG8oZzIsIGdbbiAtIDJdLCBnW25dKTtcbiAgICAgICAgICAgICAgICBuICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGogPSBlLnQgLSAxO1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdmFyIGlzMSA9IHRydWU7XG4gICAgICAgIHZhciByMiA9IG5iaSgpO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgaSA9IG5iaXRzKGVbal0pIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMCkge1xuICAgICAgICAgICAgaWYgKGkgPj0gazEpIHtcbiAgICAgICAgICAgICAgICB3ID0gKGVbal0gPj4gKGkgLSBrMSkpICYga207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gKGVbal0gJiAoKDEgPDwgKGkgKyAxKSkgLSAxKSkgPDwgKGsxIC0gaSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHcgfD0gZVtqIC0gMV0gPj4gKHRoaXMuREIgKyBpIC0gazEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBrO1xuICAgICAgICAgICAgd2hpbGUgKCh3ICYgMSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHcgPj49IDE7XG4gICAgICAgICAgICAgICAgLS1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpIC09IG4pIDwgMCkge1xuICAgICAgICAgICAgICAgIGkgKz0gdGhpcy5EQjtcbiAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXMxKSB7IC8vIHJldCA9PSAxLCBkb24ndCBib3RoZXIgc3F1YXJpbmcgb3IgbXVsdGlwbHlpbmcgaXRcbiAgICAgICAgICAgICAgICBnW3ddLmNvcHlUbyhyKTtcbiAgICAgICAgICAgICAgICBpczEgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB6LnNxclRvKHIsIHIyKTtcbiAgICAgICAgICAgICAgICAgICAgei5zcXJUbyhyMiwgcik7XG4gICAgICAgICAgICAgICAgICAgIG4gLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6Lm11bFRvKHIyLCBnW3ddLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqID49IDAgJiYgKGVbal0gJiAoMSA8PCBpKSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgICAgIHQgPSByO1xuICAgICAgICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICAgICAgICByMiA9IHQ7XG4gICAgICAgICAgICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuREIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6LnJldmVydChyKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG4gICAgLy8gKHB1YmxpYykgMS90aGlzICUgbSAoSEFDIDE0LjYxKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICB2YXIgYWMgPSBtLmlzRXZlbigpO1xuICAgICAgICBpZiAoKHRoaXMuaXNFdmVuKCkgJiYgYWMpIHx8IG0uc2lnbnVtKCkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludGVnZXIuWkVSTztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdSA9IG0uY2xvbmUoKTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhciBhID0gbmJ2KDEpO1xuICAgICAgICB2YXIgYiA9IG5idigwKTtcbiAgICAgICAgdmFyIGMgPSBuYnYoMCk7XG4gICAgICAgIHZhciBkID0gbmJ2KDEpO1xuICAgICAgICB3aGlsZSAodS5zaWdudW0oKSAhPSAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodS5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgIHUuclNoaWZ0VG8oMSwgdSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYS5pc0V2ZW4oKSB8fCAhYi5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5hZGRUbyh0aGlzLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuc3ViVG8obSwgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5yU2hpZnRUbygxLCBhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWIuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5zdWJUbyhtLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYi5yU2hpZnRUbygxLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh2LmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgdi5yU2hpZnRUbygxLCB2KTtcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmFkZFRvKHRoaXMsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5zdWJUbyhtLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjLnJTaGlmdFRvKDEsIGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZC5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICBkLnN1YlRvKG0sIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkLnJTaGlmdFRvKDEsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHUuY29tcGFyZVRvKHYpID49IDApIHtcbiAgICAgICAgICAgICAgICB1LnN1YlRvKHYsIHUpO1xuICAgICAgICAgICAgICAgIGlmIChhYykge1xuICAgICAgICAgICAgICAgICAgICBhLnN1YlRvKGMsIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiLnN1YlRvKGQsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdi5zdWJUbyh1LCB2KTtcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5zdWJUbyhhLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZC5zdWJUbyhiLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodi5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuY29tcGFyZVRvKG0pID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkLnN1YnRyYWN0KG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkLnNpZ251bSgpIDwgMCkge1xuICAgICAgICAgICAgZC5hZGRUbyhtLCBkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkLnNpZ251bSgpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuYWRkKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGJuUG93O1xuICAgIC8vIChwdWJsaWMpIHRoaXNeZVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cChlLCBuZXcgTnVsbEV4cCgpKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuICAgIC8vIChwdWJsaWMpIGdjZCh0aGlzLGEpIChIQUMgMTQuNTQpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHggPSAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YXIgeSA9IChhLnMgPCAwKSA/IGEubmVnYXRlKCkgOiBhLmNsb25lKCk7XG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA8IDApIHtcbiAgICAgICAgICAgIHZhciB0ID0geDtcbiAgICAgICAgICAgIHggPSB5O1xuICAgICAgICAgICAgeSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgICB2YXIgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIGlmIChnIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBnKSB7XG4gICAgICAgICAgICBnID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgIHguclNoaWZ0VG8oZywgeCk7XG4gICAgICAgICAgICB5LnJTaGlmdFRvKGcsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh4LnNpZ251bSgpID4gMCkge1xuICAgICAgICAgICAgaWYgKChpID0geC5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbyhpLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSA9IHkuZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkge1xuICAgICAgICAgICAgICAgIHkuclNoaWZ0VG8oaSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHguc3ViVG8oeSwgeCk7XG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbygxLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHkuc3ViVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgeS5yU2hpZnRUbygxLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgIHkubFNoaWZ0VG8oZywgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBibklzUHJvYmFibGVQcmltZTtcbiAgICAvLyAocHVibGljKSB0ZXN0IHByaW1hbGl0eSB3aXRoIGNlcnRhaW50eSA+PSAxLS41XnRcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHggPSB0aGlzLmFicygpO1xuICAgICAgICBpZiAoeC50ID09IDEgJiYgeFswXSA8PSBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbG93cHJpbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhbMF0gPT0gbG93cHJpbWVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAxO1xuICAgICAgICB3aGlsZSAoaSA8IGxvd3ByaW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBtID0gbG93cHJpbWVzW2ldO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbG93cHJpbWVzLmxlbmd0aCAmJiBtIDwgbHBsaW0pIHtcbiAgICAgICAgICAgICAgICBtICo9IGxvd3ByaW1lc1tqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbSA9IHgubW9kSW50KG0pO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG0gJSBsb3dwcmltZXNbaSsrXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHgubWlsbGVyUmFiaW4odCk7XG4gICAgfTtcbiAgICAvLyNlbmRyZWdpb24gUFVCTElDXG4gICAgLy8jcmVnaW9uIFBST1RFQ1RFRFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvcHlUbyA9IGJucENvcHlUbztcbiAgICAvLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvcHlUbyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gdGhpcy50O1xuICAgICAgICByLnMgPSB0aGlzLnM7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tSW50ID0gYm5wRnJvbUludDtcbiAgICAvLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tSW50ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50ID0gMTtcbiAgICAgICAgdGhpcy5zID0gKHggPCAwKSA/IC0xIDogMDtcbiAgICAgICAgaWYgKHggPiAwKSB7XG4gICAgICAgICAgICB0aGlzWzBdID0geDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4IDwgLTEpIHtcbiAgICAgICAgICAgIHRoaXNbMF0gPSB4ICsgdGhpcy5EVjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBibnBGcm9tU3RyaW5nO1xuICAgIC8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHMsIGIpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmIChiID09IDE2KSB7XG4gICAgICAgICAgICBrID0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDgpIHtcbiAgICAgICAgICAgIGsgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMjU2KSB7XG4gICAgICAgICAgICBrID0gODtcbiAgICAgICAgICAgIC8qIGJ5dGUgYXJyYXkgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDIpIHtcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMzIpIHtcbiAgICAgICAgICAgIGsgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gNCkge1xuICAgICAgICAgICAgayA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZyb21SYWRpeChzLCBiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnQgPSAwO1xuICAgICAgICB0aGlzLnMgPSAwO1xuICAgICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgICB2YXIgbWkgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNoID0gMDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgeCA9IChrID09IDgpID8gKCtzW2ldKSAmIDB4ZmYgOiBpbnRBdChzLCBpKTtcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICBtaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWkgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2ggKyBrID4gdGhpcy5EQikge1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50IC0gMV0gfD0gKHggJiAoKDEgPDwgKHRoaXMuREIgLSBzaCkpIC0gMSkpIDw8IHNoO1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50KytdID0gKHggPj4gKHRoaXMuREIgLSBzaCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQgLSAxXSB8PSB4IDw8IHNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2ggKz0gaztcbiAgICAgICAgICAgIGlmIChzaCA+PSB0aGlzLkRCKSB7XG4gICAgICAgICAgICAgICAgc2ggLT0gdGhpcy5EQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoayA9PSA4ICYmICgoK3NbMF0pICYgMHg4MCkgIT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zID0gLTE7XG4gICAgICAgICAgICBpZiAoc2ggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQgLSAxXSB8PSAoKDEgPDwgKHRoaXMuREIgLSBzaCkpIC0gMSkgPDwgc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGFtcCgpO1xuICAgICAgICBpZiAobWkpIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2xhbXAgPSBibnBDbGFtcDtcbiAgICAvLyAocHJvdGVjdGVkKSBjbGFtcCBvZmYgZXhjZXNzIGhpZ2ggd29yZHNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgICB3aGlsZSAodGhpcy50ID4gMCAmJiB0aGlzW3RoaXMudCAtIDFdID09IGMpIHtcbiAgICAgICAgICAgIC0tdGhpcy50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRsU2hpZnRUbyA9IGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpICsgbl0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gdGhpcy50ICsgbjtcbiAgICAgICAgci5zID0gdGhpcy5zO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZHJTaGlmdFRvID0gYm5wRFJTaGlmdFRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBmdW5jdGlvbiAobiwgcikge1xuICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByW2kgLSBuXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gTWF0aC5tYXgodGhpcy50IC0gbiwgMCk7XG4gICAgICAgIHIucyA9IHRoaXMucztcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gYm5wTFNoaWZ0VG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgdmFyIGJzID0gbiAlIHRoaXMuREI7XG4gICAgICAgIHZhciBjYnMgPSB0aGlzLkRCIC0gYnM7XG4gICAgICAgIHZhciBibSA9ICgxIDw8IGNicykgLSAxO1xuICAgICAgICB2YXIgZHMgPSBNYXRoLmZsb29yKG4gLyB0aGlzLkRCKTtcbiAgICAgICAgdmFyIGMgPSAodGhpcy5zIDw8IGJzKSAmIHRoaXMuRE07XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpICsgZHMgKyAxXSA9ICh0aGlzW2ldID4+IGNicykgfCBjO1xuICAgICAgICAgICAgYyA9ICh0aGlzW2ldICYgYm0pIDw8IGJzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBkcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICByW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByW2RzXSA9IGM7XG4gICAgICAgIHIudCA9IHRoaXMudCArIGRzICsgMTtcbiAgICAgICAgci5zID0gdGhpcy5zO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yU2hpZnRUbyA9IGJucFJTaGlmdFRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yU2hpZnRUbyA9IGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgIHIucyA9IHRoaXMucztcbiAgICAgICAgdmFyIGRzID0gTWF0aC5mbG9vcihuIC8gdGhpcy5EQik7XG4gICAgICAgIGlmIChkcyA+PSB0aGlzLnQpIHtcbiAgICAgICAgICAgIHIudCA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJzID0gbiAlIHRoaXMuREI7XG4gICAgICAgIHZhciBjYnMgPSB0aGlzLkRCIC0gYnM7XG4gICAgICAgIHZhciBibSA9ICgxIDw8IGJzKSAtIDE7XG4gICAgICAgIHJbMF0gPSB0aGlzW2RzXSA+PiBicztcbiAgICAgICAgZm9yICh2YXIgaSA9IGRzICsgMTsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByW2kgLSBkcyAtIDFdIHw9ICh0aGlzW2ldICYgYm0pIDw8IGNicztcbiAgICAgICAgICAgIHJbaSAtIGRzXSA9IHRoaXNbaV0gPj4gYnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJzID4gMCkge1xuICAgICAgICAgICAgclt0aGlzLnQgLSBkcyAtIDFdIHw9ICh0aGlzLnMgJiBibSkgPDwgY2JzO1xuICAgICAgICB9XG4gICAgICAgIHIudCA9IHRoaXMudCAtIGRzO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJUbyA9IGJucFN1YlRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gZnVuY3Rpb24gKGEsIHIpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBtID0gTWF0aC5taW4oYS50LCB0aGlzLnQpO1xuICAgICAgICB3aGlsZSAoaSA8IG0pIHtcbiAgICAgICAgICAgIGMgKz0gdGhpc1tpXSAtIGFbaV07XG4gICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudCA8IHRoaXMudCkge1xuICAgICAgICAgICAgYyAtPSBhLnM7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMudCkge1xuICAgICAgICAgICAgICAgIGMgKz0gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYS50KSB7XG4gICAgICAgICAgICAgICAgYyAtPSBhW2ldO1xuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjIC09IGEucztcbiAgICAgICAgfVxuICAgICAgICByLnMgPSAoYyA8IDApID8gLTEgOiAwO1xuICAgICAgICBpZiAoYyA8IC0xKSB7XG4gICAgICAgICAgICByW2krK10gPSB0aGlzLkRWICsgYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID4gMCkge1xuICAgICAgICAgICAgcltpKytdID0gYztcbiAgICAgICAgfVxuICAgICAgICByLnQgPSBpO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VG8gPSBmdW5jdGlvbiAoYSwgcikge1xuICAgICAgICB2YXIgeCA9IHRoaXMuYWJzKCk7XG4gICAgICAgIHZhciB5ID0gYS5hYnMoKTtcbiAgICAgICAgdmFyIGkgPSB4LnQ7XG4gICAgICAgIHIudCA9IGkgKyB5LnQ7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHkudDsgKytpKSB7XG4gICAgICAgICAgICByW2kgKyB4LnRdID0geC5hbSgwLCB5W2ldLCByLCBpLCAwLCB4LnQpO1xuICAgICAgICB9XG4gICAgICAgIHIucyA9IDA7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICAgICAgaWYgKHRoaXMucyAhPSBhLnMpIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlVG8gPSBibnBTcXVhcmVUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpc14yLCByICE9IHRoaXMgKEhBQyAxNC4xNilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmVUbyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgICAgICAgdmFyIGkgPSByLnQgPSAyICogeC50O1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB4LnQgLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0geC5hbShpLCB4W2ldLCByLCAyICogaSwgMCwgMSk7XG4gICAgICAgICAgICBpZiAoKHJbaSArIHgudF0gKz0geC5hbShpICsgMSwgMiAqIHhbaV0sIHIsIDIgKiBpICsgMSwgYywgeC50IC0gaSAtIDEpKSA+PSB4LkRWKSB7XG4gICAgICAgICAgICAgICAgcltpICsgeC50XSAtPSB4LkRWO1xuICAgICAgICAgICAgICAgIHJbaSArIHgudCArIDFdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoci50ID4gMCkge1xuICAgICAgICAgICAgcltyLnQgLSAxXSArPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByLnMgPSAwO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIGRpdmlkZSB0aGlzIGJ5IG0sIHF1b3RpZW50IGFuZCByZW1haW5kZXIgdG8gcSwgciAoSEFDIDE0LjIwKVxuICAgIC8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdlJlbVRvID0gZnVuY3Rpb24gKG0sIHEsIHIpIHtcbiAgICAgICAgdmFyIHBtID0gbS5hYnMoKTtcbiAgICAgICAgaWYgKHBtLnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gICAgICAgIGlmIChwdC50IDwgcG0udCkge1xuICAgICAgICAgICAgaWYgKHEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHEuZnJvbUludCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcHlUbyhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PSBudWxsKSB7XG4gICAgICAgICAgICByID0gbmJpKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSBuYmkoKTtcbiAgICAgICAgdmFyIHRzID0gdGhpcy5zO1xuICAgICAgICB2YXIgbXMgPSBtLnM7XG4gICAgICAgIHZhciBuc2ggPSB0aGlzLkRCIC0gbmJpdHMocG1bcG0udCAtIDFdKTsgLy8gbm9ybWFsaXplIG1vZHVsdXNcbiAgICAgICAgaWYgKG5zaCA+IDApIHtcbiAgICAgICAgICAgIHBtLmxTaGlmdFRvKG5zaCwgeSk7XG4gICAgICAgICAgICBwdC5sU2hpZnRUbyhuc2gsIHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG0uY29weVRvKHkpO1xuICAgICAgICAgICAgcHQuY29weVRvKHIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5cyA9IHkudDtcbiAgICAgICAgdmFyIHkwID0geVt5cyAtIDFdO1xuICAgICAgICBpZiAoeTAgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5dCA9IHkwICogKDEgPDwgdGhpcy5GMSkgKyAoKHlzID4gMSkgPyB5W3lzIC0gMl0gPj4gdGhpcy5GMiA6IDApO1xuICAgICAgICB2YXIgZDEgPSB0aGlzLkZWIC8geXQ7XG4gICAgICAgIHZhciBkMiA9ICgxIDw8IHRoaXMuRjEpIC8geXQ7XG4gICAgICAgIHZhciBlID0gMSA8PCB0aGlzLkYyO1xuICAgICAgICB2YXIgaSA9IHIudDtcbiAgICAgICAgdmFyIGogPSBpIC0geXM7XG4gICAgICAgIHZhciB0ID0gKHEgPT0gbnVsbCkgPyBuYmkoKSA6IHE7XG4gICAgICAgIHkuZGxTaGlmdFRvKGosIHQpO1xuICAgICAgICBpZiAoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgICAgICAgICAgcltyLnQrK10gPSAxO1xuICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgfVxuICAgICAgICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsIHQpO1xuICAgICAgICB0LnN1YlRvKHksIHkpOyAvLyBcIm5lZ2F0aXZlXCIgeSBzbyB3ZSBjYW4gcmVwbGFjZSBzdWIgd2l0aCBhbSBsYXRlclxuICAgICAgICB3aGlsZSAoeS50IDwgeXMpIHtcbiAgICAgICAgICAgIHlbeS50KytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoLS1qID49IDApIHtcbiAgICAgICAgICAgIC8vIEVzdGltYXRlIHF1b3RpZW50IGRpZ2l0XG4gICAgICAgICAgICB2YXIgcWQgPSAoclstLWldID09IHkwKSA/IHRoaXMuRE0gOiBNYXRoLmZsb29yKHJbaV0gKiBkMSArIChyW2kgLSAxXSArIGUpICogZDIpO1xuICAgICAgICAgICAgaWYgKChyW2ldICs9IHkuYW0oMCwgcWQsIHIsIGosIDAsIHlzKSkgPCBxZCkgeyAvLyBUcnkgaXQgb3V0XG4gICAgICAgICAgICAgICAgeS5kbFNoaWZ0VG8oaiwgdCk7XG4gICAgICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocltpXSA8IC0tcWQpIHtcbiAgICAgICAgICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHEgIT0gbnVsbCkge1xuICAgICAgICAgICAgci5kclNoaWZ0VG8oeXMsIHEpO1xuICAgICAgICAgICAgaWYgKHRzICE9IG1zKSB7XG4gICAgICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEsIHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHIudCA9IHlzO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgICAgIGlmIChuc2ggPiAwKSB7XG4gICAgICAgICAgICByLnJTaGlmdFRvKG5zaCwgcik7XG4gICAgICAgIH0gLy8gRGVub3JtYWxpemUgcmVtYWluZGVyXG4gICAgICAgIGlmICh0cyA8IDApIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbiAgICAvLyAocHJvdGVjdGVkKSByZXR1cm4gXCItMS90aGlzICUgMl5EQlwiOyB1c2VmdWwgZm9yIE1vbnQuIHJlZHVjdGlvblxuICAgIC8vIGp1c3RpZmljYXRpb246XG4gICAgLy8gICAgICAgICB4eSA9PSAxIChtb2QgbSlcbiAgICAvLyAgICAgICAgIHh5ID0gIDEra21cbiAgICAvLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4gICAgLy8geFt5KDIteHkpXSA9IDEta14ybV4yXG4gICAgLy8geFt5KDIteHkpXSA9PSAxIChtb2QgbV4yKVxuICAgIC8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbiAgICAvLyBzaG91bGQgcmVkdWNlIHggYW5kIHkoMi14eSkgYnkgbV4yIGF0IGVhY2ggc3RlcCB0byBrZWVwIHNpemUgYm91bmRlZC5cbiAgICAvLyBKUyBtdWx0aXBseSBcIm92ZXJmbG93c1wiIGRpZmZlcmVudGx5IGZyb20gQy9DKyssIHNvIGNhcmUgaXMgbmVlZGVkIGhlcmUuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IHRoaXNbMF07XG4gICAgICAgIGlmICgoeCAmIDEpID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0geCAmIDM7IC8vIHkgPT0gMS94IG1vZCAyXjJcbiAgICAgICAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZikgKiB5KSkgJiAweGY7IC8vIHkgPT0gMS94IG1vZCAyXjRcbiAgICAgICAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZmYpICogeSkpICYgMHhmZjsgLy8geSA9PSAxL3ggbW9kIDJeOFxuICAgICAgICB5ID0gKHkgKiAoMiAtICgoKHggJiAweGZmZmYpICogeSkgJiAweGZmZmYpKSkgJiAweGZmZmY7IC8vIHkgPT0gMS94IG1vZCAyXjE2XG4gICAgICAgIC8vIGxhc3Qgc3RlcCAtIGNhbGN1bGF0ZSBpbnZlcnNlIG1vZCBEViBkaXJlY3RseTtcbiAgICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDw9IDMyIGFuZCBhc3N1bWVzIGFiaWxpdHkgdG8gaGFuZGxlIDQ4LWJpdCBpbnRzXG4gICAgICAgIHkgPSAoeSAqICgyIC0geCAqIHkgJSB0aGlzLkRWKSkgJSB0aGlzLkRWOyAvLyB5ID09IDEveCBtb2QgMl5kYml0c1xuICAgICAgICAvLyB3ZSByZWFsbHkgd2FudCB0aGUgbmVnYXRpdmUgaW52ZXJzZSwgYW5kIC1EViA8IHkgPCBEVlxuICAgICAgICByZXR1cm4gKHkgPiAwKSA/IHRoaXMuRFYgLSB5IDogLXk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBibnBJc0V2ZW47XG4gICAgLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZmYgdGhpcyBpcyBldmVuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnQgPiAwKSA/ICh0aGlzWzBdICYgMSkgOiB0aGlzLnMpID09IDA7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5leHAgPSBibnBFeHA7XG4gICAgLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uIChlLCB6KSB7XG4gICAgICAgIGlmIChlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHZhciByMiA9IG5iaSgpO1xuICAgICAgICB2YXIgZyA9IHouY29udmVydCh0aGlzKTtcbiAgICAgICAgdmFyIGkgPSBuYml0cyhlKSAtIDE7XG4gICAgICAgIGcuY29weVRvKHIpO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgaWYgKChlICYgKDEgPDwgaSkpID4gMCkge1xuICAgICAgICAgICAgICAgIHoubXVsVG8ocjIsIGcsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByO1xuICAgICAgICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICAgICAgICByMiA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuICAgIC8vIChwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaHVua1NpemUgPSBmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLkxOMiAqIHRoaXMuREIgLyBNYXRoLmxvZyhyKSk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1JhZGl4ID0gYm5wVG9SYWRpeDtcbiAgICAvLyAocHJvdGVjdGVkKSBjb252ZXJ0IHRvIHJhZGl4IHN0cmluZ1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvUmFkaXggPSBmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICBiID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT0gMCB8fCBiIDwgMiB8fCBiID4gMzYpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbiAgICAgICAgdmFyIGEgPSBNYXRoLnBvdyhiLCBjcyk7XG4gICAgICAgIHZhciBkID0gbmJ2KGEpO1xuICAgICAgICB2YXIgeSA9IG5iaSgpO1xuICAgICAgICB2YXIgeiA9IG5iaSgpO1xuICAgICAgICB2YXIgciA9IFwiXCI7XG4gICAgICAgIHRoaXMuZGl2UmVtVG8oZCwgeSwgeik7XG4gICAgICAgIHdoaWxlICh5LnNpZ251bSgpID4gMCkge1xuICAgICAgICAgICAgciA9IChhICsgei5pbnRWYWx1ZSgpKS50b1N0cmluZyhiKS5zdWJzdHIoMSkgKyByO1xuICAgICAgICAgICAgeS5kaXZSZW1UbyhkLCB5LCB6KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21SYWRpeCA9IGJucEZyb21SYWRpeDtcbiAgICAvLyAocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVJhZGl4ID0gZnVuY3Rpb24gKHMsIGIpIHtcbiAgICAgICAgdGhpcy5mcm9tSW50KDApO1xuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICBiID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG4gICAgICAgIHZhciBkID0gTWF0aC5wb3coYiwgY3MpO1xuICAgICAgICB2YXIgbWkgPSBmYWxzZTtcbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHggPSBpbnRBdChzLCBpKTtcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIiAmJiB0aGlzLnNpZ251bSgpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcgPSBiICogdyArIHg7XG4gICAgICAgICAgICBpZiAoKytqID49IGNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kTXVsdGlwbHkoZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsIDApO1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIHcgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYiwgaikpO1xuICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaSkge1xuICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbiAgICAvLyAocHJvdGVjdGVkKSBhbHRlcm5hdGUgY29uc3RydWN0b3JcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxpbnQsUk5HKVxuICAgICAgICAgICAgaWYgKGEgPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tSW50KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKGEsIGMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50ZXN0Qml0KGEgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBNU0Igc2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIG9wX29yLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KDEsIDApO1xuICAgICAgICAgICAgICAgIH0gLy8gZm9yY2Ugb2RkXG4gICAgICAgICAgICAgICAgd2hpbGUgKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQoMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJpdExlbmd0aCgpID4gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxSTkcpXG4gICAgICAgICAgICB2YXIgeCA9IFtdO1xuICAgICAgICAgICAgdmFyIHQgPSBhICYgNztcbiAgICAgICAgICAgIHgubGVuZ3RoID0gKGEgPj4gMykgKyAxO1xuICAgICAgICAgICAgYi5uZXh0Qnl0ZXMoeCk7XG4gICAgICAgICAgICBpZiAodCA+IDApIHtcbiAgICAgICAgICAgICAgICB4WzBdICY9ICgoMSA8PCB0KSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeFswXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcoeCwgMjU2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYml0d2lzZVRvID0gYm5wQml0d2lzZVRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIG9wIGEgKGJpdHdpc2UpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0d2lzZVRvID0gZnVuY3Rpb24gKGEsIG9wLCByKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgdmFyIG0gPSBNYXRoLm1pbihhLnQsIHRoaXMudCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgICAgIHJbaV0gPSBvcCh0aGlzW2ldLCBhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS50IDwgdGhpcy50KSB7XG4gICAgICAgICAgICBmID0gYS5zICYgdGhpcy5ETTtcbiAgICAgICAgICAgIGZvciAoaSA9IG07IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHJbaV0gPSBvcCh0aGlzW2ldLCBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGYgPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgZm9yIChpID0gbTsgaSA8IGEudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcltpXSA9IG9wKGYsIGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci50ID0gYS50O1xuICAgICAgICB9XG4gICAgICAgIHIucyA9IG9wKHRoaXMucywgYS5zKTtcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2hhbmdlQml0ID0gYm5wQ2hhbmdlQml0O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgb3AgKDE8PG4pXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2hhbmdlQml0ID0gZnVuY3Rpb24gKG4sIG9wKSB7XG4gICAgICAgIHZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xuICAgICAgICB0aGlzLmJpdHdpc2VUbyhyLCBvcCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkVG8gPSBibnBBZGRUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyArIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGRUbyA9IGZ1bmN0aW9uIChhLCByKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICB2YXIgbSA9IE1hdGgubWluKGEudCwgdGhpcy50KTtcbiAgICAgICAgd2hpbGUgKGkgPCBtKSB7XG4gICAgICAgICAgICBjICs9IHRoaXNbaV0gKyBhW2ldO1xuICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnQgPCB0aGlzLnQpIHtcbiAgICAgICAgICAgIGMgKz0gYS5zO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnQpIHtcbiAgICAgICAgICAgICAgICBjICs9IHRoaXNbaV07XG4gICAgICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGEudCkge1xuICAgICAgICAgICAgICAgIGMgKz0gYVtpXTtcbiAgICAgICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyArPSBhLnM7XG4gICAgICAgIH1cbiAgICAgICAgci5zID0gKGMgPCAwKSA/IC0xIDogMDtcbiAgICAgICAgaWYgKGMgPiAwKSB7XG4gICAgICAgICAgICByW2krK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAtMSkge1xuICAgICAgICAgICAgcltpKytdID0gdGhpcy5EViArIGM7XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gaTtcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZE11bHRpcGx5ID0gYm5wRE11bHRpcGx5O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgKj0gbiwgdGhpcyA+PSAwLCAxIDwgbiA8IERWXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZE11bHRpcGx5ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpc1t0aGlzLnRdID0gdGhpcy5hbSgwLCBuIC0gMSwgdGhpcywgMCwgMCwgdGhpcy50KTtcbiAgICAgICAgKyt0aGlzLnQ7XG4gICAgICAgIHRoaXMuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRBZGRPZmZzZXQgPSBibnBEQWRkT2Zmc2V0O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgKz0gbiA8PCB3IHdvcmRzLCB0aGlzID49IDBcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gZnVuY3Rpb24gKG4sIHcpIHtcbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnQgPD0gdykge1xuICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbd10gKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXNbd10gPj0gdGhpcy5EVikge1xuICAgICAgICAgICAgdGhpc1t3XSAtPSB0aGlzLkRWO1xuICAgICAgICAgICAgaWYgKCsrdyA+PSB0aGlzLnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCsrXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3RoaXNbd107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gbG93ZXIgbiB3b3JkcyBvZiBcInRoaXMgKiBhXCIsIGEudCA8PSBuXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGZ1bmN0aW9uIChhLCBuLCByKSB7XG4gICAgICAgIHZhciBpID0gTWF0aC5taW4odGhpcy50ICsgYS50LCBuKTtcbiAgICAgICAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICAgICAgICByLnQgPSBpO1xuICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgIHJbLS1pXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IHIudCAtIHRoaXMudDsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgcltpICsgdGhpcy50XSA9IHRoaXMuYW0oMCwgYVtpXSwgciwgaSwgMCwgdGhpcy50KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gTWF0aC5taW4oYS50LCBuKTsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hbSgwLCBhW2ldLCByLCBpLCAwLCBuIC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlVcHBlclRvID0gYm5wTXVsdGlwbHlVcHBlclRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuICAgIC8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVVwcGVyVG8gPSBmdW5jdGlvbiAoYSwgbiwgcikge1xuICAgICAgICAtLW47XG4gICAgICAgIHZhciBpID0gci50ID0gdGhpcy50ICsgYS50IC0gbjtcbiAgICAgICAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IE1hdGgubWF4KG4gLSB0aGlzLnQsIDApOyBpIDwgYS50OyArK2kpIHtcbiAgICAgICAgICAgIHJbdGhpcy50ICsgaSAtIG5dID0gdGhpcy5hbShuIC0gaSwgYVtpXSwgciwgMCwgMCwgdGhpcy50ICsgaSAtIG4pO1xuICAgICAgICB9XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICAgICAgci5kclNoaWZ0VG8oMSwgcik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnQgPSBibnBNb2RJbnQ7XG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyAlIG4sIG4gPCAyXjI2XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW50ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGQgPSB0aGlzLkRWICUgbjtcbiAgICAgICAgdmFyIHIgPSAodGhpcy5zIDwgMCkgPyBuIC0gMSA6IDA7XG4gICAgICAgIGlmICh0aGlzLnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAoZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgciA9IHRoaXNbMF0gJSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSAoZCAqIHIgKyB0aGlzW2ldKSAlIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubWlsbGVyUmFiaW4gPSBibnBNaWxsZXJSYWJpbjtcbiAgICAvLyAocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgIHZhciBrID0gbjEuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIGlmIChrIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG4gICAgICAgIHQgPSAodCArIDEpID4+IDE7XG4gICAgICAgIGlmICh0ID4gbG93cHJpbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdCA9IGxvd3ByaW1lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBuYmkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIFBpY2sgYmFzZXMgYXQgcmFuZG9tLCBpbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0IDJcbiAgICAgICAgICAgIGEuZnJvbUludChsb3dwcmltZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbG93cHJpbWVzLmxlbmd0aCldKTtcbiAgICAgICAgICAgIHZhciB5ID0gYS5tb2RQb3cociwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkubW9kUG93SW50KDIsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGJuU3F1YXJlO1xuICAgIC8vIChwdWJsaWMpIHRoaXNeMlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5zcXVhcmVUbyhyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyNyZWdpb24gQVNZTkNcbiAgICAvLyBQdWJsaWMgQVBJIG1ldGhvZFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdjZGEgPSBmdW5jdGlvbiAoYSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHggPSAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YXIgeSA9IChhLnMgPCAwKSA/IGEubmVnYXRlKCkgOiBhLmNsb25lKCk7XG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA8IDApIHtcbiAgICAgICAgICAgIHZhciB0ID0geDtcbiAgICAgICAgICAgIHggPSB5O1xuICAgICAgICAgICAgeSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgICB2YXIgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIGlmIChnIDwgMCkge1xuICAgICAgICAgICAgY2FsbGJhY2soeCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBnKSB7XG4gICAgICAgICAgICBnID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgIHguclNoaWZ0VG8oZywgeCk7XG4gICAgICAgICAgICB5LnJTaGlmdFRvKGcsIHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdvcmtob3JzZSBvZiB0aGUgYWxnb3JpdGhtLCBnZXRzIGNhbGxlZCAyMDAgLSA4MDAgdGltZXMgcGVyIDUxMiBiaXQga2V5Z2VuLlxuICAgICAgICB2YXIgZ2NkYTEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICB4LnJTaGlmdFRvKGksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeS5yU2hpZnRUbyhpLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgeC5zdWJUbyh5LCB4KTtcbiAgICAgICAgICAgICAgICB4LnJTaGlmdFRvKDEsIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeS5zdWJUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICB5LnJTaGlmdFRvKDEsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoeC5zaWdudW0oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHkubFNoaWZ0VG8oZywgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBjYWxsYmFjayh5KTsgfSwgMCk7IC8vIGVzY2FwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChnY2RhMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQoZ2NkYTEsIDEwKTtcbiAgICB9O1xuICAgIC8vIChwcm90ZWN0ZWQpIGFsdGVybmF0ZSBjb25zdHJ1Y3RvclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21OdW1iZXJBc3luYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgYikge1xuICAgICAgICAgICAgaWYgKGEgPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tSW50KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKGEsIGMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50ZXN0Qml0KGEgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCBvcF9vciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCgxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJucF8xID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgYm5wZm4xXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJucF8xLmRBZGRPZmZzZXQoMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibnBfMS5iaXRMZW5ndGgoKSA+IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJucF8xLnN1YlRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIGJucF8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYm5wXzEuaXNQcm9iYWJsZVByaW1lKGIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soKTsgfSwgMCk7IC8vIGVzY2FwZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChibnBmbjFfMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYm5wZm4xXzEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHggPSBbXTtcbiAgICAgICAgICAgIHZhciB0ID0gYSAmIDc7XG4gICAgICAgICAgICB4Lmxlbmd0aCA9IChhID4+IDMpICsgMTtcbiAgICAgICAgICAgIGIubmV4dEJ5dGVzKHgpO1xuICAgICAgICAgICAgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgeFswXSAmPSAoKDEgPDwgdCkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHhbMF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKHgsIDI1Nik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCaWdJbnRlZ2VyO1xufSgpKTtcbi8vI3JlZ2lvbiBSRURVQ0VSU1xuLy8jcmVnaW9uIE51bGxFeHBcbnZhciBOdWxsRXhwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bGxFeHAoKSB7XG4gICAgfVxuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuICAgIE51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IG5Ob3A7XG4gICAgTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICAvLyBOdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IG5NdWxUbztcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICB9O1xuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLnNxclRvID0gblNxclRvO1xuICAgIE51bGxFeHAucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICB9O1xuICAgIHJldHVybiBOdWxsRXhwO1xufSgpKTtcbi8vIE1vZHVsYXIgcmVkdWN0aW9uIHVzaW5nIFwiY2xhc3NpY1wiIGFsZ29yaXRobVxudmFyIENsYXNzaWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xhc3NpYyhtKSB7XG4gICAgICAgIHRoaXMubSA9IG07XG4gICAgfVxuICAgIC8vIENsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHgucyA8IDAgfHwgeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQgPSBjUmV2ZXJ0O1xuICAgIENsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gY1JlZHVjZTtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB4LmRpdlJlbVRvKHRoaXMubSwgbnVsbCwgeCk7XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGNNdWxUbztcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGZ1bmN0aW9uICh4LCByKSB7XG4gICAgICAgIHguc3F1YXJlVG8ocik7XG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH07XG4gICAgcmV0dXJuIENsYXNzaWM7XG59KCkpO1xuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gTW9udGdvbWVyeVxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbnZhciBNb250Z29tZXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICAgICAgICB0aGlzLm0gPSBtO1xuICAgICAgICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICAgICAgICB0aGlzLm1wbCA9IHRoaXMubXAgJiAweDdmZmY7XG4gICAgICAgIHRoaXMubXBoID0gdGhpcy5tcCA+PiAxNTtcbiAgICAgICAgdGhpcy51bSA9ICgxIDw8IChtLkRCIC0gMTUpKSAtIDE7XG4gICAgICAgIHRoaXMubXQyID0gMiAqIG0udDtcbiAgICB9XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IG1vbnRDb252ZXJ0O1xuICAgIC8vIHhSIG1vZCBtXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHguYWJzKCkuZGxTaGlmdFRvKHRoaXMubS50LCByKTtcbiAgICAgICAgci5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHIpO1xuICAgICAgICBpZiAoeC5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkge1xuICAgICAgICAgICAgdGhpcy5tLnN1YlRvKHIsIHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0ID0gbW9udFJldmVydDtcbiAgICAvLyB4L1IgbW9kIG1cbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB4LmNvcHlUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbiAgICAvLyB4ID0geC9SIG1vZCBtIChIQUMgMTQuMzIpXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgd2hpbGUgKHgudCA8PSB0aGlzLm10Mikge1xuICAgICAgICAgICAgLy8gcGFkIHggc28gYW0gaGFzIGVub3VnaCByb29tIGxhdGVyXG4gICAgICAgICAgICB4W3gudCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm0udDsgKytpKSB7XG4gICAgICAgICAgICAvLyBmYXN0ZXIgd2F5IG9mIGNhbGN1bGF0aW5nIHUwID0geFtpXSptcCBtb2QgRFZcbiAgICAgICAgICAgIHZhciBqID0geFtpXSAmIDB4N2ZmZjtcbiAgICAgICAgICAgIHZhciB1MCA9IChqICogdGhpcy5tcGwgKyAoKChqICogdGhpcy5tcGggKyAoeFtpXSA+PiAxNSkgKiB0aGlzLm1wbCkgJiB0aGlzLnVtKSA8PCAxNSkpICYgeC5ETTtcbiAgICAgICAgICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgICAgICAgICAgaiA9IGkgKyB0aGlzLm0udDtcbiAgICAgICAgICAgIHhbal0gKz0gdGhpcy5tLmFtKDAsIHUwLCB4LCBpLCAwLCB0aGlzLm0udCk7XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUgY2FycnlcbiAgICAgICAgICAgIHdoaWxlICh4W2pdID49IHguRFYpIHtcbiAgICAgICAgICAgICAgICB4W2pdIC09IHguRFY7XG4gICAgICAgICAgICAgICAgeFsrK2pdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeC5jbGFtcCgpO1xuICAgICAgICB4LmRyU2hpZnRUbyh0aGlzLm0udCwgeCk7XG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHtcbiAgICAgICAgICAgIHguc3ViVG8odGhpcy5tLCB4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG87XG4gICAgLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIC8vIE1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gbW9udFNxclRvO1xuICAgIC8vIHIgPSBcInheMi9SIG1vZCBtXCI7IHggIT0gclxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICByZXR1cm4gTW9udGdvbWVyeTtcbn0oKSk7XG4vLyNlbmRyZWdpb24gTW9udGdvbWVyeVxuLy8jcmVnaW9uIEJhcnJldHRcbi8vIEJhcnJldHQgbW9kdWxhciByZWR1Y3Rpb25cbnZhciBCYXJyZXR0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhcnJldHQobSkge1xuICAgICAgICB0aGlzLm0gPSBtO1xuICAgICAgICAvLyBzZXR1cCBCYXJyZXR0XG4gICAgICAgIHRoaXMucjIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5xMyA9IG5iaSgpO1xuICAgICAgICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oMiAqIG0udCwgdGhpcy5yMik7XG4gICAgICAgIHRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbiAgICB9XG4gICAgLy8gQmFycmV0dC5wcm90b3R5cGUuY29udmVydCA9IGJhcnJldHRDb252ZXJ0O1xuICAgIEJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoeC5zIDwgMCB8fCB4LnQgPiAyICogdGhpcy5tLnQpIHtcbiAgICAgICAgICAgIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgICAgICB4LmNvcHlUbyhyKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGJhcnJldHRSZXZlcnQ7XG4gICAgQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBiYXJyZXR0UmVkdWNlO1xuICAgIC8vIHggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG4gICAgQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeC5kclNoaWZ0VG8odGhpcy5tLnQgLSAxLCB0aGlzLnIyKTtcbiAgICAgICAgaWYgKHgudCA+IHRoaXMubS50ICsgMSkge1xuICAgICAgICAgICAgeC50ID0gdGhpcy5tLnQgKyAxO1xuICAgICAgICAgICAgeC5jbGFtcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXUubXVsdGlwbHlVcHBlclRvKHRoaXMucjIsIHRoaXMubS50ICsgMSwgdGhpcy5xMyk7XG4gICAgICAgIHRoaXMubS5tdWx0aXBseUxvd2VyVG8odGhpcy5xMywgdGhpcy5tLnQgKyAxLCB0aGlzLnIyKTtcbiAgICAgICAgd2hpbGUgKHguY29tcGFyZVRvKHRoaXMucjIpIDwgMCkge1xuICAgICAgICAgICAgeC5kQWRkT2Zmc2V0KDEsIHRoaXMubS50ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgeC5zdWJUbyh0aGlzLnIyLCB4KTtcbiAgICAgICAgd2hpbGUgKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkge1xuICAgICAgICAgICAgeC5zdWJUbyh0aGlzLm0sIHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGJhcnJldHRNdWxUbztcbiAgICAvLyByID0geCp5IG1vZCBtOyB4LHkgIT0gclxuICAgIEJhcnJldHQucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvO1xuICAgIC8vIHIgPSB4XjIgbW9kIG07IHggIT0gclxuICAgIEJhcnJldHQucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICByZXR1cm4gQmFycmV0dDtcbn0oKSk7XG4vLyNlbmRyZWdpb25cbi8vI2VuZHJlZ2lvbiBSRURVQ0VSU1xuLy8gcmV0dXJuIG5ldywgdW5zZXQgQmlnSW50ZWdlclxuZnVuY3Rpb24gbmJpKCkgeyByZXR1cm4gbmV3IEJpZ0ludGVnZXIobnVsbCk7IH1cbmZ1bmN0aW9uIHBhcnNlQmlnSW50KHN0ciwgcikge1xuICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihzdHIsIHIpO1xufVxuLy8gYW06IENvbXB1dGUgd19qICs9ICh4KnRoaXNfaSksIHByb3BhZ2F0ZSBjYXJyaWVzLFxuLy8gYyBpcyBpbml0aWFsIGNhcnJ5LCByZXR1cm5zIGZpbmFsIGNhcnJ5LlxuLy8gYyA8IDMqZHZhbHVlLCB4IDwgMipkdmFsdWUsIHRoaXNfaSA8IGR2YWx1ZVxuLy8gV2UgbmVlZCB0byBzZWxlY3QgdGhlIGZhc3Rlc3Qgb25lIHRoYXQgd29ya3MgaW4gdGhpcyBlbnZpcm9ubWVudC5cbi8vIGFtMTogdXNlIGEgc2luZ2xlIG11bHQgYW5kIGRpdmlkZSB0byBnZXQgdGhlIGhpZ2ggYml0cyxcbi8vIG1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSAyNiBiZWNhdXNlXG4vLyBtYXggaW50ZXJuYWwgdmFsdWUgPSAyKmR2YWx1ZV4yLTIqZHZhbHVlICg8IDJeNTMpXG5mdW5jdGlvbiBhbTEoaSwgeCwgdywgaiwgYywgbikge1xuICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgdiA9IHggKiB0aGlzW2krK10gKyB3W2pdICsgYztcbiAgICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDB4NDAwMDAwMCk7XG4gICAgICAgIHdbaisrXSA9IHYgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGksIHgsIHcsIGosIGMsIG4pIHtcbiAgICB2YXIgeGwgPSB4ICYgMHg3ZmZmO1xuICAgIHZhciB4aCA9IHggPj4gMTU7XG4gICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICAgIHZhciBsID0gdGhpc1tpXSAmIDB4N2ZmZjtcbiAgICAgICAgdmFyIGggPSB0aGlzW2krK10gPj4gMTU7XG4gICAgICAgIHZhciBtID0geGggKiBsICsgaCAqIHhsO1xuICAgICAgICBsID0geGwgKiBsICsgKChtICYgMHg3ZmZmKSA8PCAxNSkgKyB3W2pdICsgKGMgJiAweDNmZmZmZmZmKTtcbiAgICAgICAgYyA9IChsID4+PiAzMCkgKyAobSA+Pj4gMTUpICsgeGggKiBoICsgKGMgPj4+IDMwKTtcbiAgICAgICAgd1tqKytdID0gbCAmIDB4M2ZmZmZmZmY7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuLy8gQWx0ZXJuYXRlbHksIHNldCBtYXggZGlnaXQgYml0cyB0byAyOCBzaW5jZSBzb21lXG4vLyBicm93c2VycyBzbG93IGRvd24gd2hlbiBkZWFsaW5nIHdpdGggMzItYml0IG51bWJlcnMuXG5mdW5jdGlvbiBhbTMoaSwgeCwgdywgaiwgYywgbikge1xuICAgIHZhciB4bCA9IHggJiAweDNmZmY7XG4gICAgdmFyIHhoID0geCA+PiAxNDtcbiAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzW2ldICYgMHgzZmZmO1xuICAgICAgICB2YXIgaCA9IHRoaXNbaSsrXSA+PiAxNDtcbiAgICAgICAgdmFyIG0gPSB4aCAqIGwgKyBoICogeGw7XG4gICAgICAgIGwgPSB4bCAqIGwgKyAoKG0gJiAweDNmZmYpIDw8IDE0KSArIHdbal0gKyBjO1xuICAgICAgICBjID0gKGwgPj4gMjgpICsgKG0gPj4gMTQpICsgeGggKiBoO1xuICAgICAgICB3W2orK10gPSBsICYgMHhmZmZmZmZmO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cbmlmIChqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PSBcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiKSkge1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICAgIGRiaXRzID0gMzA7XG59XG5lbHNlIGlmIChqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSAhPSBcIk5ldHNjYXBlXCIpKSB7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gICAgZGJpdHMgPSAyNjtcbn1cbmVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMztcbiAgICBkYml0cyA9IDI4O1xufVxuQmlnSW50ZWdlci5wcm90b3R5cGUuREIgPSBkYml0cztcbkJpZ0ludGVnZXIucHJvdG90eXBlLkRNID0gKCgxIDw8IGRiaXRzKSAtIDEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMSA8PCBkYml0cyk7XG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMiwgQklfRlApO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjEgPSBCSV9GUCAtIGRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyICogZGJpdHMgLSBCSV9GUDtcbi8vIERpZ2l0IGNvbnZlcnNpb25zXG52YXIgQklfUkMgPSBbXTtcbnZhciBycjtcbnZhciB2djtcbnJyID0gXCIwXCIuY2hhckNvZGVBdCgwKTtcbmZvciAodnYgPSAwOyB2diA8PSA5OyArK3Z2KSB7XG4gICAgQklfUkNbcnIrK10gPSB2djtcbn1cbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikge1xuICAgIEJJX1JDW3JyKytdID0gdnY7XG59XG5yciA9IFwiQVwiLmNoYXJDb2RlQXQoMCk7XG5mb3IgKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIHtcbiAgICBCSV9SQ1tycisrXSA9IHZ2O1xufVxuZnVuY3Rpb24gaW50QXQocywgaSkge1xuICAgIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgICByZXR1cm4gKGMgPT0gbnVsbCkgPyAtMSA6IGM7XG59XG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkge1xuICAgIHZhciByID0gbmJpKCk7XG4gICAgci5mcm9tSW50KGkpO1xuICAgIHJldHVybiByO1xufVxuLy8gcmV0dXJucyBiaXQgbGVuZ3RoIG9mIHRoZSBpbnRlZ2VyIHhcbmZ1bmN0aW9uIG5iaXRzKHgpIHtcbiAgICB2YXIgciA9IDE7XG4gICAgdmFyIHQ7XG4gICAgaWYgKCh0ID0geCA+Pj4gMTYpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gMTY7XG4gICAgfVxuICAgIGlmICgodCA9IHggPj4gOCkgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSA4O1xuICAgIH1cbiAgICBpZiAoKHQgPSB4ID4+IDQpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gNDtcbiAgICB9XG4gICAgaWYgKCh0ID0geCA+PiAyKSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDI7XG4gICAgfVxuICAgIGlmICgodCA9IHggPj4gMSkgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBwcm5nNC5qcyAtIHVzZXMgQXJjZm91ciBhcyBhIFBSTkdcbnZhciBBcmNmb3VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFyY2ZvdXIoKSB7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuaiA9IDA7XG4gICAgICAgIHRoaXMuUyA9IFtdO1xuICAgIH1cbiAgICAvLyBBcmNmb3VyLnByb3RvdHlwZS5pbml0ID0gQVJDNGluaXQ7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcmNmb3VyIGNvbnRleHQgZnJvbSBrZXksIGFuIGFycmF5IG9mIGludHMsIGVhY2ggZnJvbSBbMC4uMjU1XVxuICAgIEFyY2ZvdXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5TW2ldID0gaTtcbiAgICAgICAgfVxuICAgICAgICBqID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgICAgICBqID0gKGogKyB0aGlzLlNbaV0gKyBrZXlbaSAlIGtleS5sZW5ndGhdKSAmIDI1NTtcbiAgICAgICAgICAgIHQgPSB0aGlzLlNbaV07XG4gICAgICAgICAgICB0aGlzLlNbaV0gPSB0aGlzLlNbal07XG4gICAgICAgICAgICB0aGlzLlNbal0gPSB0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuaiA9IDA7XG4gICAgfTtcbiAgICAvLyBBcmNmb3VyLnByb3RvdHlwZS5uZXh0ID0gQVJDNG5leHQ7XG4gICAgQXJjZm91ci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHRoaXMuaSA9ICh0aGlzLmkgKyAxKSAmIDI1NTtcbiAgICAgICAgdGhpcy5qID0gKHRoaXMuaiArIHRoaXMuU1t0aGlzLmldKSAmIDI1NTtcbiAgICAgICAgdCA9IHRoaXMuU1t0aGlzLmldO1xuICAgICAgICB0aGlzLlNbdGhpcy5pXSA9IHRoaXMuU1t0aGlzLmpdO1xuICAgICAgICB0aGlzLlNbdGhpcy5qXSA9IHQ7XG4gICAgICAgIHJldHVybiB0aGlzLlNbKHQgKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTVdO1xuICAgIH07XG4gICAgcmV0dXJuIEFyY2ZvdXI7XG59KCkpO1xuLy8gUGx1ZyBpbiB5b3VyIFJORyBjb25zdHJ1Y3RvciBoZXJlXG5mdW5jdGlvbiBwcm5nX25ld3N0YXRlKCkge1xuICAgIHJldHVybiBuZXcgQXJjZm91cigpO1xufVxuLy8gUG9vbCBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0IGFuZCBncmVhdGVyIHRoYW4gMzIuXG4vLyBBbiBhcnJheSBvZiBieXRlcyB0aGUgc2l6ZSBvZiB0aGUgcG9vbCB3aWxsIGJlIHBhc3NlZCB0byBpbml0KClcbnZhciBybmdfcHNpemUgPSAyNTY7XG5cbi8vIFJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIC0gcmVxdWlyZXMgYSBQUk5HIGJhY2tlbmQsIGUuZy4gcHJuZzQuanNcbnZhciBybmdfc3RhdGU7XG52YXIgcm5nX3Bvb2wgPSBudWxsO1xudmFyIHJuZ19wcHRyO1xuLy8gSW5pdGlhbGl6ZSB0aGUgcG9vbCB3aXRoIGp1bmsgaWYgbmVlZGVkLlxuaWYgKHJuZ19wb29sID09IG51bGwpIHtcbiAgICBybmdfcG9vbCA9IFtdO1xuICAgIHJuZ19wcHRyID0gMDtcbiAgICB2YXIgdCA9IHZvaWQgMDtcbiAgICBpZiAod2luZG93LmNyeXB0byAmJiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICAvLyBFeHRyYWN0IGVudHJvcHkgKDIwNDggYml0cykgZnJvbSBSTkcgaWYgYXZhaWxhYmxlXG4gICAgICAgIHZhciB6ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHopO1xuICAgICAgICBmb3IgKHQgPSAwOyB0IDwgei5sZW5ndGg7ICsrdCkge1xuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB6W3RdICYgMjU1O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZSBtb3VzZSBldmVudHMgZm9yIGVudHJvcHksIGlmIHdlIGRvIG5vdCBoYXZlIGVub3VnaCBlbnRyb3B5IGJ5IHRoZSB0aW1lXG4gICAgLy8gd2UgbmVlZCBpdCwgZW50cm9weSB3aWxsIGJlIGdlbmVyYXRlZCBieSBNYXRoLnJhbmRvbS5cbiAgICB2YXIgb25Nb3VzZU1vdmVMaXN0ZW5lcl8xID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHRoaXMuY291bnQgPSB0aGlzLmNvdW50IHx8IDA7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ID49IDI1NiB8fCBybmdfcHB0ciA+PSBybmdfcHNpemUpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlTGlzdGVuZXJfMSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2luZG93LmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmRldGFjaEV2ZW50KFwib25tb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmVMaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG1vdXNlQ29vcmRpbmF0ZXMgPSBldi54ICsgZXYueTtcbiAgICAgICAgICAgIHJuZ19wb29sW3JuZ19wcHRyKytdID0gbW91c2VDb29yZGluYXRlcyAmIDI1NTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gU29tZXRpbWVzIEZpcmVmb3ggd2lsbCBkZW55IHBlcm1pc3Npb24gdG8gYWNjZXNzIGV2ZW50IHByb3BlcnRpZXMgZm9yIHNvbWUgcmVhc29uLiBJZ25vcmUuXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudChcIm9ubW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlTGlzdGVuZXJfMSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcm5nX2dldF9ieXRlKCkge1xuICAgIGlmIChybmdfc3RhdGUgPT0gbnVsbCkge1xuICAgICAgICBybmdfc3RhdGUgPSBwcm5nX25ld3N0YXRlKCk7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG1heSBub3QgaGF2ZSBjb2xsZWN0ZWQgZW5vdWdoIGVudHJvcHkuICBJZiBub3QsIGZhbGwgYmFjayB0byBNYXRoLnJhbmRvbVxuICAgICAgICB3aGlsZSAocm5nX3BwdHIgPCBybmdfcHNpemUpIHtcbiAgICAgICAgICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKDY1NTM2ICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICBybmdfcG9vbFtybmdfcHB0cisrXSA9IHJhbmRvbSAmIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBybmdfc3RhdGUuaW5pdChybmdfcG9vbCk7XG4gICAgICAgIGZvciAocm5nX3BwdHIgPSAwOyBybmdfcHB0ciA8IHJuZ19wb29sLmxlbmd0aDsgKytybmdfcHB0cikge1xuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHJdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBybmdfcHB0ciA9IDA7XG4gICAgfVxuICAgIC8vIFRPRE86IGFsbG93IHJlc2VlZGluZyBhZnRlciBmaXJzdCByZXF1ZXN0XG4gICAgcmV0dXJuIHJuZ19zdGF0ZS5uZXh0KCk7XG59XG52YXIgU2VjdXJlUmFuZG9tID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlY3VyZVJhbmRvbSgpIHtcbiAgICB9XG4gICAgU2VjdXJlUmFuZG9tLnByb3RvdHlwZS5uZXh0Qnl0ZXMgPSBmdW5jdGlvbiAoYmEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYmFbaV0gPSBybmdfZ2V0X2J5dGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlY3VyZVJhbmRvbTtcbn0oKSk7XG5cbi8vIERlcGVuZHMgb24ganNibi5qcyBhbmQgcm5nLmpzXG4vLyBmdW5jdGlvbiBsaW5lYnJrKHMsbikge1xuLy8gICB2YXIgcmV0ID0gXCJcIjtcbi8vICAgdmFyIGkgPSAwO1xuLy8gICB3aGlsZShpICsgbiA8IHMubGVuZ3RoKSB7XG4vLyAgICAgcmV0ICs9IHMuc3Vic3RyaW5nKGksaStuKSArIFwiXFxuXCI7XG4vLyAgICAgaSArPSBuO1xuLy8gICB9XG4vLyAgIHJldHVybiByZXQgKyBzLnN1YnN0cmluZyhpLHMubGVuZ3RoKTtcbi8vIH1cbi8vIGZ1bmN0aW9uIGJ5dGUySGV4KGIpIHtcbi8vICAgaWYoYiA8IDB4MTApXG4vLyAgICAgcmV0dXJuIFwiMFwiICsgYi50b1N0cmluZygxNik7XG4vLyAgIGVsc2Vcbi8vICAgICByZXR1cm4gYi50b1N0cmluZygxNik7XG4vLyB9XG5mdW5jdGlvbiBwa2NzMXBhZDEocywgbikge1xuICAgIGlmIChuIDwgcy5sZW5ndGggKyAyMikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWVzc2FnZSB0b28gbG9uZyBmb3IgUlNBXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IG4gLSBzLmxlbmd0aCAtIDY7XG4gICAgdmFyIGZpbGxlciA9IFwiXCI7XG4gICAgZm9yICh2YXIgZiA9IDA7IGYgPCBsZW47IGYgKz0gMikge1xuICAgICAgICBmaWxsZXIgKz0gXCJmZlwiO1xuICAgIH1cbiAgICB2YXIgbSA9IFwiMDAwMVwiICsgZmlsbGVyICsgXCIwMFwiICsgcztcbiAgICByZXR1cm4gcGFyc2VCaWdJbnQobSwgMTYpO1xufVxuLy8gUEtDUyMxICh0eXBlIDIsIHJhbmRvbSkgcGFkIGlucHV0IHN0cmluZyBzIHRvIG4gYnl0ZXMsIGFuZCByZXR1cm4gYSBiaWdpbnRcbmZ1bmN0aW9uIHBrY3MxcGFkMihzLCBuKSB7XG4gICAgaWYgKG4gPCBzLmxlbmd0aCArIDExKSB7IC8vIFRPRE86IGZpeCBmb3IgdXRmLThcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk1lc3NhZ2UgdG9vIGxvbmcgZm9yIFJTQVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBiYSA9IFtdO1xuICAgIHZhciBpID0gcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpID49IDAgJiYgbiA+IDApIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaS0tKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHsgLy8gZW5jb2RlIHVzaW5nIHV0Zi04XG4gICAgICAgICAgICBiYVstLW5dID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyA+IDEyNykgJiYgKGMgPCAyMDQ4KSkge1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgYmFbLS1uXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIGJhWy0tbl0gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmFbLS1uXSA9IDA7XG4gICAgdmFyIHJuZyA9IG5ldyBTZWN1cmVSYW5kb20oKTtcbiAgICB2YXIgeCA9IFtdO1xuICAgIHdoaWxlIChuID4gMikgeyAvLyByYW5kb20gbm9uLXplcm8gcGFkXG4gICAgICAgIHhbMF0gPSAwO1xuICAgICAgICB3aGlsZSAoeFswXSA9PSAwKSB7XG4gICAgICAgICAgICBybmcubmV4dEJ5dGVzKHgpO1xuICAgICAgICB9XG4gICAgICAgIGJhWy0tbl0gPSB4WzBdO1xuICAgIH1cbiAgICBiYVstLW5dID0gMjtcbiAgICBiYVstLW5dID0gMDtcbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYmEpO1xufVxuLy8gXCJlbXB0eVwiIFJTQSBrZXkgY29uc3RydWN0b3JcbnZhciBSU0FLZXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUlNBS2V5KCkge1xuICAgICAgICB0aGlzLm4gPSBudWxsO1xuICAgICAgICB0aGlzLmUgPSAwO1xuICAgICAgICB0aGlzLmQgPSBudWxsO1xuICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB0aGlzLnEgPSBudWxsO1xuICAgICAgICB0aGlzLmRtcDEgPSBudWxsO1xuICAgICAgICB0aGlzLmRtcTEgPSBudWxsO1xuICAgICAgICB0aGlzLmNvZWZmID0gbnVsbDtcbiAgICB9XG4gICAgLy8jcmVnaW9uIFBST1RFQ1RFRFxuICAgIC8vIHByb3RlY3RlZFxuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZG9QdWJsaWMgPSBSU0FEb1B1YmxpYztcbiAgICAvLyBQZXJmb3JtIHJhdyBwdWJsaWMgb3BlcmF0aW9uIG9uIFwieFwiOiByZXR1cm4geF5lIChtb2QgbilcbiAgICBSU0FLZXkucHJvdG90eXBlLmRvUHVibGljID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgubW9kUG93SW50KHRoaXMuZSwgdGhpcy5uKTtcbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZG9Qcml2YXRlID0gUlNBRG9Qcml2YXRlO1xuICAgIC8vIFBlcmZvcm0gcmF3IHByaXZhdGUgb3BlcmF0aW9uIG9uIFwieFwiOiByZXR1cm4geF5kIChtb2QgbilcbiAgICBSU0FLZXkucHJvdG90eXBlLmRvUHJpdmF0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh0aGlzLnAgPT0gbnVsbCB8fCB0aGlzLnEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHgubW9kUG93KHRoaXMuZCwgdGhpcy5uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZS1jYWxjdWxhdGUgYW55IG1pc3NpbmcgQ1JUIHBhcmFtc1xuICAgICAgICB2YXIgeHAgPSB4Lm1vZCh0aGlzLnApLm1vZFBvdyh0aGlzLmRtcDEsIHRoaXMucCk7XG4gICAgICAgIHZhciB4cSA9IHgubW9kKHRoaXMucSkubW9kUG93KHRoaXMuZG1xMSwgdGhpcy5xKTtcbiAgICAgICAgd2hpbGUgKHhwLmNvbXBhcmVUbyh4cSkgPCAwKSB7XG4gICAgICAgICAgICB4cCA9IHhwLmFkZCh0aGlzLnApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4cC5zdWJ0cmFjdCh4cSkubXVsdGlwbHkodGhpcy5jb2VmZikubW9kKHRoaXMucCkubXVsdGlwbHkodGhpcy5xKS5hZGQoeHEpO1xuICAgIH07XG4gICAgLy8jZW5kcmVnaW9uIFBST1RFQ1RFRFxuICAgIC8vI3JlZ2lvbiBQVUJMSUNcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLnNldFB1YmxpYyA9IFJTQVNldFB1YmxpYztcbiAgICAvLyBTZXQgdGhlIHB1YmxpYyBrZXkgZmllbGRzIE4gYW5kIGUgZnJvbSBoZXggc3RyaW5nc1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2V0UHVibGljID0gZnVuY3Rpb24gKE4sIEUpIHtcbiAgICAgICAgaWYgKE4gIT0gbnVsbCAmJiBFICE9IG51bGwgJiYgTi5sZW5ndGggPiAwICYmIEUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5uID0gcGFyc2VCaWdJbnQoTiwgMTYpO1xuICAgICAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgUlNBIHB1YmxpYyBrZXlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZW5jcnlwdCA9IFJTQUVuY3J5cHQ7XG4gICAgLy8gUmV0dXJuIHRoZSBQS0NTIzEgUlNBIGVuY3J5cHRpb24gb2YgXCJ0ZXh0XCIgYXMgYW4gZXZlbi1sZW5ndGggaGV4IHN0cmluZ1xuICAgIFJTQUtleS5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBtID0gcGtjczFwYWQyKHRleHQsICh0aGlzLm4uYml0TGVuZ3RoKCkgKyA3KSA+PiAzKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSB0aGlzLmRvUHVibGljKG0pO1xuICAgICAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoKGgubGVuZ3RoICYgMSkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCIgKyBoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGUgPSBSU0FTZXRQcml2YXRlO1xuICAgIC8vIFNldCB0aGUgcHJpdmF0ZSBrZXkgZmllbGRzIE4sIGUsIGFuZCBkIGZyb20gaGV4IHN0cmluZ3NcbiAgICBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGUgPSBmdW5jdGlvbiAoTiwgRSwgRCkge1xuICAgICAgICBpZiAoTiAhPSBudWxsICYmIEUgIT0gbnVsbCAmJiBOLmxlbmd0aCA+IDAgJiYgRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChOLCAxNik7XG4gICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgICAgICB0aGlzLmQgPSBwYXJzZUJpZ0ludChELCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBSU0EgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZUV4ID0gUlNBU2V0UHJpdmF0ZUV4O1xuICAgIC8vIFNldCB0aGUgcHJpdmF0ZSBrZXkgZmllbGRzIE4sIGUsIGQgYW5kIENSVCBwYXJhbXMgZnJvbSBoZXggc3RyaW5nc1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZUV4ID0gZnVuY3Rpb24gKE4sIEUsIEQsIFAsIFEsIERQLCBEUSwgQykge1xuICAgICAgICBpZiAoTiAhPSBudWxsICYmIEUgIT0gbnVsbCAmJiBOLmxlbmd0aCA+IDAgJiYgRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChOLCAxNik7XG4gICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgICAgICB0aGlzLmQgPSBwYXJzZUJpZ0ludChELCAxNik7XG4gICAgICAgICAgICB0aGlzLnAgPSBwYXJzZUJpZ0ludChQLCAxNik7XG4gICAgICAgICAgICB0aGlzLnEgPSBwYXJzZUJpZ0ludChRLCAxNik7XG4gICAgICAgICAgICB0aGlzLmRtcDEgPSBwYXJzZUJpZ0ludChEUCwgMTYpO1xuICAgICAgICAgICAgdGhpcy5kbXExID0gcGFyc2VCaWdJbnQoRFEsIDE2KTtcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSBwYXJzZUJpZ0ludChDLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBSU0EgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZ2VuZXJhdGUgPSBSU0FHZW5lcmF0ZTtcbiAgICAvLyBHZW5lcmF0ZSBhIG5ldyByYW5kb20gcHJpdmF0ZSBrZXkgQiBiaXRzIGxvbmcsIHVzaW5nIHB1YmxpYyBleHB0IEVcbiAgICBSU0FLZXkucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKEIsIEUpIHtcbiAgICAgICAgdmFyIHJuZyA9IG5ldyBTZWN1cmVSYW5kb20oKTtcbiAgICAgICAgdmFyIHFzID0gQiA+PiAxO1xuICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgIHZhciBlZSA9IG5ldyBCaWdJbnRlZ2VyKEUsIDE2KTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMucCA9IG5ldyBCaWdJbnRlZ2VyKEIgLSBxcywgMSwgcm5nKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2QoZWUpLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCAmJiB0aGlzLnAuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xID0gbmV3IEJpZ0ludGVnZXIocXMsIDEsIHJuZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKGVlKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDAgJiYgdGhpcy5xLmlzUHJvYmFibGVQcmltZSgxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucC5jb21wYXJlVG8odGhpcy5xKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnA7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5xO1xuICAgICAgICAgICAgICAgIHRoaXMucSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcDEgPSB0aGlzLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICAgICAgdmFyIHExID0gdGhpcy5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgICAgIHZhciBwaGkgPSBwMS5tdWx0aXBseShxMSk7XG4gICAgICAgICAgICBpZiAocGhpLmdjZChlZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uID0gdGhpcy5wLm11bHRpcGx5KHRoaXMucSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kID0gZWUubW9kSW52ZXJzZShwaGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG1wMSA9IHRoaXMuZC5tb2QocDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG1xMSA9IHRoaXMuZC5tb2QocTEpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZmYgPSB0aGlzLnEubW9kSW52ZXJzZSh0aGlzLnApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLmRlY3J5cHQgPSBSU0FEZWNyeXB0O1xuICAgIC8vIFJldHVybiB0aGUgUEtDUyMxIFJTQSBkZWNyeXB0aW9uIG9mIFwiY3RleHRcIi5cbiAgICAvLyBcImN0ZXh0XCIgaXMgYW4gZXZlbi1sZW5ndGggaGV4IHN0cmluZyBhbmQgdGhlIG91dHB1dCBpcyBhIHBsYWluIHN0cmluZy5cbiAgICBSU0FLZXkucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoY3RleHQpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUJpZ0ludChjdGV4dCwgMTYpO1xuICAgICAgICB2YXIgbSA9IHRoaXMuZG9Qcml2YXRlKGMpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGtjczF1bnBhZDIobSwgKHRoaXMubi5iaXRMZW5ndGgoKSArIDcpID4+IDMpO1xuICAgIH07XG4gICAgLy8gR2VuZXJhdGUgYSBuZXcgcmFuZG9tIHByaXZhdGUga2V5IEIgYml0cyBsb25nLCB1c2luZyBwdWJsaWMgZXhwdCBFXG4gICAgUlNBS2V5LnByb3RvdHlwZS5nZW5lcmF0ZUFzeW5jID0gZnVuY3Rpb24gKEIsIEUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBybmcgPSBuZXcgU2VjdXJlUmFuZG9tKCk7XG4gICAgICAgIHZhciBxcyA9IEIgPj4gMTtcbiAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xuICAgICAgICB2YXIgZWUgPSBuZXcgQmlnSW50ZWdlcihFLCAxNik7XG4gICAgICAgIHZhciByc2EgPSB0aGlzO1xuICAgICAgICAvLyBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBub24tZGVzY3JpcHQgbmFtZXMgYmVjYXVzZSB0aGV5IHdlcmUgb3JpZ2luYWxseSBmb3IoOzspIGxvb3BzLlxuICAgICAgICAvLyBJIGRvbid0IGtub3cgYWJvdXQgY3J5cHRvZ3JhcGh5IHRvIGdpdmUgdGhlbSBiZXR0ZXIgbmFtZXMgdGhhbiBsb29wMS00LlxuICAgICAgICB2YXIgbG9vcDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9vcDQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJzYS5wLmNvbXBhcmVUbyhyc2EucSkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHJzYS5wO1xuICAgICAgICAgICAgICAgICAgICByc2EucCA9IHJzYS5xO1xuICAgICAgICAgICAgICAgICAgICByc2EucSA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwMSA9IHJzYS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgICAgICAgICB2YXIgcTEgPSByc2EucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgICAgICAgICAgdmFyIHBoaSA9IHAxLm11bHRpcGx5KHExKTtcbiAgICAgICAgICAgICAgICBpZiAocGhpLmdjZChlZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5uID0gcnNhLnAubXVsdGlwbHkocnNhLnEpO1xuICAgICAgICAgICAgICAgICAgICByc2EuZCA9IGVlLm1vZEludmVyc2UocGhpKTtcbiAgICAgICAgICAgICAgICAgICAgcnNhLmRtcDEgPSByc2EuZC5tb2QocDEpO1xuICAgICAgICAgICAgICAgICAgICByc2EuZG1xMSA9IHJzYS5kLm1vZChxMSk7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5jb2VmZiA9IHJzYS5xLm1vZEludmVyc2UocnNhLnApO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soKTsgfSwgMCk7IC8vIGVzY2FwZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wMSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBsb29wMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByc2EucSA9IG5iaSgpO1xuICAgICAgICAgICAgICAgIHJzYS5xLmZyb21OdW1iZXJBc3luYyhxcywgMSwgcm5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2RhKGVlLCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwICYmIHJzYS5xLmlzUHJvYmFibGVQcmltZSgxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3A0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDMsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbG9vcDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnNhLnAgPSBuYmkoKTtcbiAgICAgICAgICAgICAgICByc2EucC5mcm9tTnVtYmVyQXN5bmMoQiAtIHFzLCAxLCBybmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcnNhLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZGEoZWUsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDAgJiYgcnNhLnAuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDMsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDIsIDApO1xuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KGxvb3AxLCAwKTtcbiAgICB9O1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uICh0ZXh0LCBkaWdlc3RNZXRob2QsIGRpZ2VzdE5hbWUpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IGdldERpZ2VzdEhlYWRlcihkaWdlc3ROYW1lKTtcbiAgICAgICAgdmFyIGRpZ2VzdCA9IGhlYWRlciArIGRpZ2VzdE1ldGhvZCh0ZXh0KS50b1N0cmluZygpO1xuICAgICAgICB2YXIgbSA9IHBrY3MxcGFkMShkaWdlc3QsIHRoaXMubi5iaXRMZW5ndGgoKSAvIDQpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHRoaXMuZG9Qcml2YXRlKG0pO1xuICAgICAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoKGgubGVuZ3RoICYgMSkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCIgKyBoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSU0FLZXkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uICh0ZXh0LCBzaWduYXR1cmUsIGRpZ2VzdE1ldGhvZCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlQmlnSW50KHNpZ25hdHVyZSwgMTYpO1xuICAgICAgICB2YXIgbSA9IHRoaXMuZG9QdWJsaWMoYyk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bnBhZGRlZCA9IG0udG9TdHJpbmcoMTYpLnJlcGxhY2UoL14xZiswMC8sIFwiXCIpO1xuICAgICAgICB2YXIgZGlnZXN0ID0gcmVtb3ZlRGlnZXN0SGVhZGVyKHVucGFkZGVkKTtcbiAgICAgICAgcmV0dXJuIGRpZ2VzdCA9PSBkaWdlc3RNZXRob2QodGV4dCkudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBSU0FLZXk7XG59KCkpO1xuLy8gVW5kbyBQS0NTIzEgKHR5cGUgMiwgcmFuZG9tKSBwYWRkaW5nIGFuZCwgaWYgdmFsaWQsIHJldHVybiB0aGUgcGxhaW50ZXh0XG5mdW5jdGlvbiBwa2NzMXVucGFkMihkLCBuKSB7XG4gICAgdmFyIGIgPSBkLnRvQnl0ZUFycmF5KCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYi5sZW5ndGggJiYgYltpXSA9PSAwKSB7XG4gICAgICAgICsraTtcbiAgICB9XG4gICAgaWYgKGIubGVuZ3RoIC0gaSAhPSBuIC0gMSB8fCBiW2ldICE9IDIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgICsraTtcbiAgICB3aGlsZSAoYltpXSAhPSAwKSB7XG4gICAgICAgIGlmICgrK2kgPj0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHdoaWxlICgrK2kgPCBiLmxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IGJbaV0gJiAyNTU7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7IC8vIHV0Zi04IGRlY29kZVxuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgPiAxOTEpICYmIChjIDwgMjI0KSkge1xuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMzEpIDw8IDYpIHwgKGJbaSArIDFdICYgNjMpKTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDE1KSA8PCAxMikgfCAoKGJbaSArIDFdICYgNjMpIDw8IDYpIHwgKGJbaSArIDJdICYgNjMpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NDcjcGFnZS00M1xudmFyIERJR0VTVF9IRUFERVJTID0ge1xuICAgIG1kMjogXCIzMDIwMzAwYzA2MDgyYTg2NDg4NmY3MGQwMjAyMDUwMDA0MTBcIixcbiAgICBtZDU6IFwiMzAyMDMwMGMwNjA4MmE4NjQ4ODZmNzBkMDIwNTA1MDAwNDEwXCIsXG4gICAgc2hhMTogXCIzMDIxMzAwOTA2MDUyYjBlMDMwMjFhMDUwMDA0MTRcIixcbiAgICBzaGEyMjQ6IFwiMzAyZDMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjA0MDUwMDA0MWNcIixcbiAgICBzaGEyNTY6IFwiMzAzMTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAxMDUwMDA0MjBcIixcbiAgICBzaGEzODQ6IFwiMzA0MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAyMDUwMDA0MzBcIixcbiAgICBzaGE1MTI6IFwiMzA1MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAzMDUwMDA0NDBcIixcbiAgICByaXBlbWQxNjA6IFwiMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0XCIsXG59O1xuZnVuY3Rpb24gZ2V0RGlnZXN0SGVhZGVyKG5hbWUpIHtcbiAgICByZXR1cm4gRElHRVNUX0hFQURFUlNbbmFtZV0gfHwgXCJcIjtcbn1cbmZ1bmN0aW9uIHJlbW92ZURpZ2VzdEhlYWRlcihzdHIpIHtcbiAgICBmb3IgKHZhciBuYW1lXzEgaW4gRElHRVNUX0hFQURFUlMpIHtcbiAgICAgICAgaWYgKERJR0VTVF9IRUFERVJTLmhhc093blByb3BlcnR5KG5hbWVfMSkpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBESUdFU1RfSEVBREVSU1tuYW1lXzFdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGhlYWRlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3RyLnN1YnN0cigwLCBsZW4pID09IGhlYWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8vIFJldHVybiB0aGUgUEtDUyMxIFJTQSBlbmNyeXB0aW9uIG9mIFwidGV4dFwiIGFzIGEgQmFzZTY0LWVuY29kZWQgc3RyaW5nXG4vLyBmdW5jdGlvbiBSU0FFbmNyeXB0QjY0KHRleHQpIHtcbi8vICB2YXIgaCA9IHRoaXMuZW5jcnlwdCh0ZXh0KTtcbi8vICBpZihoKSByZXR1cm4gaGV4MmI2NChoKTsgZWxzZSByZXR1cm4gbnVsbDtcbi8vIH1cbi8vIHB1YmxpY1xuLy8gUlNBS2V5LnByb3RvdHlwZS5lbmNyeXB0X2I2NCA9IFJTQUVuY3J5cHRCNjQ7XG5cbi8qIVxuQ29weXJpZ2h0IChjKSAyMDExLCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuQ29kZSBsaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2U6XG5odHRwOi8vZGV2ZWxvcGVyLnlhaG9vLmNvbS95dWkvbGljZW5zZS5odG1sXG52ZXJzaW9uOiAyLjkuMFxuKi9cbnZhciBZQUhPTyA9IHt9O1xuWUFIT08ubGFuZyA9IHtcbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHRvIHNldCB1cCB0aGUgcHJvdG90eXBlLCBjb25zdHJ1Y3RvciBhbmQgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzIHRvXG4gICAgICogc3VwcG9ydCBhbiBpbmhlcml0YW5jZSBzdHJhdGVneSB0aGF0IGNhbiBjaGFpbiBjb25zdHJ1Y3RvcnMgYW5kIG1ldGhvZHMuXG4gICAgICogU3RhdGljIG1lbWJlcnMgd2lsbCBub3QgYmUgaW5oZXJpdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBleHRlbmRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViYyAgIHRoZSBvYmplY3QgdG8gbW9kaWZ5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjIHRoZSBvYmplY3QgdG8gaW5oZXJpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgIGFkZGl0aW9uYWwgcHJvcGVydGllcy9tZXRob2RzIHRvIGFkZCB0byB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNsYXNzIHByb3RvdHlwZS4gIFRoZXNlIHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZyBpdGVtcyBvYnRhaW5lZCBmcm9tIHRoZSBzdXBlcmNsYXNzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwcmVzZW50LlxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24oc3ViYywgc3VwZXJjLCBvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCEgc3VwZXJjIHx8ICEgc3ViYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWUFIT08ubGFuZy5leHRlbmQgZmFpbGVkLCBwbGVhc2UgY2hlY2sgdGhhdCBcIiArXG4gICAgICAgICAgICAgICAgXCJhbGwgZGVwZW5kZW5jaWVzIGFyZSBpbmNsdWRlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIEYucHJvdG90eXBlID0gc3VwZXJjLnByb3RvdHlwZTtcbiAgICAgICAgc3ViYy5wcm90b3R5cGUgPSBuZXcgRigpO1xuICAgICAgICBzdWJjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YmM7XG4gICAgICAgIHN1YmMuc3VwZXJjbGFzcyA9IHN1cGVyYy5wcm90b3R5cGU7XG5cbiAgICAgICAgaWYgKHN1cGVyYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgc3VwZXJjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1cGVyYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpIGluIG92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgIHN1YmMucHJvdG90eXBlW2ldID0gb3ZlcnJpZGVzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSUUgd2lsbCBub3QgZW51bWVyYXRlIG5hdGl2ZSBmdW5jdGlvbnMgaW4gYSBkZXJpdmVkIG9iamVjdCBldmVuIGlmIHRoZVxuICAgICAgICAgICAgICogZnVuY3Rpb24gd2FzIG92ZXJyaWRkZW4uICBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3Igc3BlY2lmaWMgZnVuY3Rpb25zXG4gICAgICAgICAgICAgKiB3ZSBjYXJlIGFib3V0IG9uIHRoZSBPYmplY3QgcHJvdG90eXBlLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IF9JRUVudW1GaXhcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHIgIHRoZSBvYmplY3QgdG8gcmVjZWl2ZSB0aGUgYXVnbWVudGF0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzICB0aGUgb2JqZWN0IHRoYXQgc3VwcGxpZXMgdGhlIHByb3BlcnRpZXMgdG8gYXVnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIF9JRUVudW1GaXggPSBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgICAgIEFERCA9IFtcInRvU3RyaW5nXCIsIFwidmFsdWVPZlwiXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKC9NU0lFLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9JRUVudW1GaXggPSBmdW5jdGlvbihyLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQURELmxlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuYW1lID0gQUREW2ldLCBmID0gc1tmbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nICYmIGYgIT0gT2JqZWN0LnByb3RvdHlwZVtmbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcltmbmFtZV0gPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge30gICAgICAgICAgICBfSUVFbnVtRml4KHN1YmMucHJvdG90eXBlLCBvdmVycmlkZXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyogYXNuMS0xLjAuMTMuanMgKGMpIDIwMTMtMjAxNyBLZW5qaSBVcnVzaGltYSB8IGtqdXIuZ2l0aHViLmNvbS9qc3JzYXNpZ24vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGZpbGVPdmVydmlld1xuICogQG5hbWUgYXNuMS0xLjAuanNcbiAqIEBhdXRob3IgS2VuamkgVXJ1c2hpbWEga2VuamkudXJ1c2hpbWFAZ21haWwuY29tXG4gKiBAdmVyc2lvbiBhc24xIDEuMC4xMyAoMjAxNy1KdW4tMDIpXG4gKiBAc2luY2UganNyc2FzaWduIDIuMVxuICogQGxpY2Vuc2UgPGEgaHJlZj1cImh0dHBzOi8va2p1ci5naXRodWIuaW8vanNyc2FzaWduL2xpY2Vuc2UvXCI+TUlUIExpY2Vuc2U8L2E+XG4gKi9cblxuLyoqXG4gKiBranVyJ3MgY2xhc3MgbGlicmFyeSBuYW1lIHNwYWNlXG4gKiA8cD5cbiAqIFRoaXMgbmFtZSBzcGFjZSBwcm92aWRlcyBmb2xsb3dpbmcgbmFtZSBzcGFjZXM6XG4gKiA8dWw+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMX0gLSBBU04uMSBwcmltaXRpdmUgaGV4YWRlY2ltYWwgZW5jb2RlcjwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS54NTA5fSAtIEFTTi4xIHN0cnVjdHVyZSBmb3IgWC41MDkgY2VydGlmaWNhdGUgYW5kIENSTDwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuY3J5cHRvfSAtIEphdmEgQ3J5cHRvZ3JhcGhpYyBFeHRlbnNpb24oSkNFKSBzdHlsZSBNZXNzYWdlRGlnZXN0L1NpZ25hdHVyZVxuICogY2xhc3MgYW5kIHV0aWxpdGllczwvbGk+XG4gKiA8L3VsPlxuICogPC9wPlxuICogTk9URTogUGxlYXNlIGlnbm9yZSBtZXRob2Qgc3VtbWFyeSBhbmQgZG9jdW1lbnQgb2YgdGhpcyBuYW1lc3BhY2UuIFRoaXMgY2F1c2VkIGJ5IGEgYnVnIG9mIGpzZG9jMi5cbiAqIEBuYW1lIEtKVVJcbiAqIEBuYW1lc3BhY2Uga2p1cidzIGNsYXNzIGxpYnJhcnkgbmFtZSBzcGFjZVxuICovXG52YXIgS0pVUiA9IHt9O1xuXG4vKipcbiAqIGtqdXIncyBBU04uMSBjbGFzcyBsaWJyYXJ5IG5hbWUgc3BhY2VcbiAqIDxwPlxuICogVGhpcyBpcyBJVFUtVCBYLjY5MCBBU04uMSBERVIgZW5jb2RlciBjbGFzcyBsaWJyYXJ5IGFuZFxuICogY2xhc3Mgc3RydWN0dXJlIGFuZCBtZXRob2RzIGlzIHZlcnkgc2ltaWxhciB0b1xuICogb3JnLmJvdW5jeWNhc3RsZS5hc24xIHBhY2thZ2Ugb2ZcbiAqIHdlbGwga25vd24gQm91bmN5Q2FzbHRlIENyeXB0b2dyYXBoeSBMaWJyYXJ5LlxuICogPGg0PlBST1ZJRElORyBBU04uMSBQUklNSVRJVkVTPC9oND5cbiAqIEhlcmUgYXJlIEFTTi4xIERFUiBwcmltaXRpdmUgY2xhc3Nlcy5cbiAqIDx1bD5cbiAqIDxsaT4weDAxIHtAbGluayBLSlVSLmFzbjEuREVSQm9vbGVhbn08L2xpPlxuICogPGxpPjB4MDIge0BsaW5rIEtKVVIuYXNuMS5ERVJJbnRlZ2VyfTwvbGk+XG4gKiA8bGk+MHgwMyB7QGxpbmsgS0pVUi5hc24xLkRFUkJpdFN0cmluZ308L2xpPlxuICogPGxpPjB4MDQge0BsaW5rIEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZ308L2xpPlxuICogPGxpPjB4MDUge0BsaW5rIEtKVVIuYXNuMS5ERVJOdWxsfTwvbGk+XG4gKiA8bGk+MHgwNiB7QGxpbmsgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXJ9PC9saT5cbiAqIDxsaT4weDBhIHtAbGluayBLSlVSLmFzbjEuREVSRW51bWVyYXRlZH08L2xpPlxuICogPGxpPjB4MGMge0BsaW5rIEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxMiB7QGxpbmsgS0pVUi5hc24xLkRFUk51bWVyaWNTdHJpbmd9PC9saT5cbiAqIDxsaT4weDEzIHtAbGluayBLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxNCB7QGxpbmsgS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmd9PC9saT5cbiAqIDxsaT4weDE2IHtAbGluayBLSlVSLmFzbjEuREVSSUE1U3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxNyB7QGxpbmsgS0pVUi5hc24xLkRFUlVUQ1RpbWV9PC9saT5cbiAqIDxsaT4weDE4IHtAbGluayBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lfTwvbGk+XG4gKiA8bGk+MHgzMCB7QGxpbmsgS0pVUi5hc24xLkRFUlNlcXVlbmNlfTwvbGk+XG4gKiA8bGk+MHgzMSB7QGxpbmsgS0pVUi5hc24xLkRFUlNldH08L2xpPlxuICogPC91bD5cbiAqIDxoND5PVEhFUiBBU04uMSBDTEFTU0VTPC9oND5cbiAqIDx1bD5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkFTTjFPYmplY3R9PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nfTwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWV9PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZH08L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0fTwvbGk+XG4gKiA8L3VsPlxuICogPGg0PlNVQiBOQU1FIFNQQUNFUzwvaDQ+XG4gKiA8dWw+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jYWRlc30gLSBDQWRFUyBsb25nIHRlcm0gc2lnbmF0dXJlIGZvcm1hdDwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jbXN9IC0gQ3J5cHRvZ3JhcGhpYyBNZXNzYWdlIFN5bnRheDwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jc3J9IC0gQ2VydGlmaWNhdGUgU2lnbmluZyBSZXF1ZXN0IChDU1IvUEtDUyMxMCk8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEudHNwfSAtIFJGQyAzMTYxIFRpbWVzdGFtcGluZyBQcm90b2NvbCBGb3JtYXQ8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEueDUwOX0gLSBSRkMgNTI4MCBYLjUwOSBjZXJ0aWZpY2F0ZSBhbmQgQ1JMPC9saT5cbiAqIDwvdWw+XG4gKiA8L3A+XG4gKiBOT1RFOiBQbGVhc2UgaWdub3JlIG1ldGhvZCBzdW1tYXJ5IGFuZCBkb2N1bWVudCBvZiB0aGlzIG5hbWVzcGFjZS5cbiAqIFRoaXMgY2F1c2VkIGJ5IGEgYnVnIG9mIGpzZG9jMi5cbiAqIEBuYW1lIEtKVVIuYXNuMVxuICogQG5hbWVzcGFjZVxuICovXG5pZiAodHlwZW9mIEtKVVIuYXNuMSA9PSBcInVuZGVmaW5lZFwiIHx8ICFLSlVSLmFzbjEpIEtKVVIuYXNuMSA9IHt9O1xuXG4vKipcbiAqIEFTTjEgdXRpbGl0aWVzIGNsYXNzXG4gKiBAbmFtZSBLSlVSLmFzbjEuQVNOMVV0aWxcbiAqIEBjbGFzcyBBU04xIHV0aWxpdGllcyBjbGFzc1xuICogQHNpbmNlIGFzbjEgMS4wLjJcbiAqL1xuS0pVUi5hc24xLkFTTjFVdGlsID0gbmV3IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW50ZWdlclRvQnl0ZUhleCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIGggPSBpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKChoLmxlbmd0aCAlIDIpID09IDEpIGggPSAnMCcgKyBoO1xuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuICAgIHRoaXMuYmlnSW50VG9NaW5Ud29zQ29tcGxlbWVudHNIZXggPSBmdW5jdGlvbihiaWdJbnRlZ2VyVmFsdWUpIHtcbiAgICAgICAgdmFyIGggPSBiaWdJbnRlZ2VyVmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaC5zdWJzdHIoMCwgMSkgIT0gJy0nKSB7XG4gICAgICAgICAgICBpZiAoaC5sZW5ndGggJSAyID09IDEpIHtcbiAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEgaC5tYXRjaCgvXlswLTddLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9ICcwMCcgKyBoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoUG9zID0gaC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB2YXIgeG9yTGVuID0gaFBvcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoeG9yTGVuICUgMiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgeG9yTGVuICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghIGgubWF0Y2goL15bMC03XS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHhvckxlbiArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoTWFzayA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4b3JMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGhNYXNrICs9ICdmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaU1hc2sgPSBuZXcgQmlnSW50ZWdlcihoTWFzaywgMTYpO1xuICAgICAgICAgICAgdmFyIGJpTmVnID0gYmlNYXNrLnhvcihiaWdJbnRlZ2VyVmFsdWUpLmFkZChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgICAgICBoID0gYmlOZWcudG9TdHJpbmcoMTYpLnJlcGxhY2UoL14tLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0IFBFTSBzdHJpbmcgZnJvbSBoZXhhZGVjaW1hbCBkYXRhIGFuZCBoZWFkZXIgc3RyaW5nXG4gICAgICogQG5hbWUgZ2V0UEVNU3RyaW5nRnJvbUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUhleCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgUEVNIGJvZHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGVtSGVhZGVyIFBFTSBoZWFkZXIgc3RyaW5nIChleC4gJ1JTQSBQUklWQVRFIEtFWScpXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBQRU0gZm9ybWF0dGVkIHN0cmluZyBvZiBpbnB1dCBkYXRhXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhpcyBtZXRob2QgY29udmVydHMgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBQRU0gc3RyaW5nIHdpdGhcbiAgICAgKiBhIHNwZWNpZmllZCBoZWFkZXIuIEl0cyBsaW5lIGJyZWFrIHdpbGwgYmUgQ1JMRihcIlxcclxcblwiKS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwZW0gID0gS0pVUi5hc24xLkFTTjFVdGlsLmdldFBFTVN0cmluZ0Zyb21IZXgoJzYxNjE2MScsICdSU0EgUFJJVkFURSBLRVknKTtcbiAgICAgKiAvLyB2YWx1ZSBvZiBwZW0gd2lsbCBiZTpcbiAgICAgKiAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cbiAgICAgKiBZV0ZoXG4gICAgICogLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UEVNU3RyaW5nRnJvbUhleCA9IGZ1bmN0aW9uKGRhdGFIZXgsIHBlbUhlYWRlcikge1xuICAgICAgICByZXR1cm4gaGV4dG9wZW0oZGF0YUhleCwgcGVtSGVhZGVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgQVNOMU9iamVjdCBzcGVjaWZlZCBieSBKU09OIHBhcmFtZXRlcnNcbiAgICAgKiBAbmFtZSBuZXdPYmplY3RcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW0gSlNPTiBwYXJhbWV0ZXIgdG8gZ2VuZXJhdGUgQVNOMU9iamVjdFxuICAgICAqIEByZXR1cm4ge0tKVVIuYXNuMS5BU04xT2JqZWN0fSBnZW5lcmF0ZWQgb2JqZWN0XG4gICAgICogQHNpbmNlIGFzbjEgMS4wLjNcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBnZW5lcmF0ZSBhbnkgQVNOMU9iamVjdCBzcGVjaWZpZWQgYnkgSlNPTiBwYXJhbVxuICAgICAqIGluY2x1ZGluZyBBU04uMSBwcmltaXRpdmUgb3Igc3RydWN0dXJlZC5cbiAgICAgKiBHZW5lcmFsbHkgJ3BhcmFtJyBjYW4gYmUgZGVzY3JpYmVkIGFzIGZvbGxvd3M6XG4gICAgICogPGJsb2NrcXVvdGU+XG4gICAgICoge1RZUEUtT0YtQVNOT0JKOiBBU04xT0JKLVBBUkFNRVRFUn1cbiAgICAgKiA8L2Jsb2NrcXVvdGU+XG4gICAgICogJ1RZUEUtT0YtQVNOMU9CSicgY2FuIGJlIG9uZSBvZiBmb2xsb3dpbmcgc3ltYm9sczpcbiAgICAgKiA8dWw+XG4gICAgICogPGxpPidib29sJyAtIERFUkJvb2xlYW48L2xpPlxuICAgICAqIDxsaT4naW50JyAtIERFUkludGVnZXI8L2xpPlxuICAgICAqIDxsaT4nYml0c3RyJyAtIERFUkJpdFN0cmluZzwvbGk+XG4gICAgICogPGxpPidvY3RzdHInIC0gREVST2N0ZXRTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4nbnVsbCcgLSBERVJOdWxsPC9saT5cbiAgICAgKiA8bGk+J29pZCcgLSBERVJPYmplY3RJZGVudGlmaWVyPC9saT5cbiAgICAgKiA8bGk+J2VudW0nIC0gREVSRW51bWVyYXRlZDwvbGk+XG4gICAgICogPGxpPid1dGY4c3RyJyAtIERFUlVURjhTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4nbnVtc3RyJyAtIERFUk51bWVyaWNTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4ncHJuc3RyJyAtIERFUlByaW50YWJsZVN0cmluZzwvbGk+XG4gICAgICogPGxpPid0ZWxzdHInIC0gREVSVGVsZXRleFN0cmluZzwvbGk+XG4gICAgICogPGxpPidpYTVzdHInIC0gREVSSUE1U3RyaW5nPC9saT5cbiAgICAgKiA8bGk+J3V0Y3RpbWUnIC0gREVSVVRDVGltZTwvbGk+XG4gICAgICogPGxpPidnZW50aW1lJyAtIERFUkdlbmVyYWxpemVkVGltZTwvbGk+XG4gICAgICogPGxpPidzZXEnIC0gREVSU2VxdWVuY2U8L2xpPlxuICAgICAqIDxsaT4nc2V0JyAtIERFUlNldDwvbGk+XG4gICAgICogPGxpPid0YWcnIC0gREVSVGFnZ2VkT2JqZWN0PC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbmV3T2JqZWN0KHsncHJuc3RyJzogJ2FhYSd9KTtcbiAgICAgKiBuZXdPYmplY3QoeydzZXEnOiBbeydpbnQnOiAzfSwgeydwcm5zdHInOiAnYWFhJ31dfSlcbiAgICAgKiAvLyBBU04uMSBUYWdnZWQgT2JqZWN0XG4gICAgICogbmV3T2JqZWN0KHsndGFnJzogeyd0YWcnOiAnYTEnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAnZXhwbGljaXQnOiB0cnVlLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAnb2JqJzogeydzZXEnOiBbeydpbnQnOiAzfSwgeydwcm5zdHInOiAnYWFhJ31dfX19KTtcbiAgICAgKiAvLyBtb3JlIHNpbXBsZSByZXByZXNlbnRhdGlvbiBvZiBBU04uMSBUYWdnZWQgT2JqZWN0XG4gICAgICogbmV3T2JqZWN0KHsndGFnJzogWydhMScsXG4gICAgICogICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICogICAgICAgICAgICAgICAgICAgIHsnc2VxJzogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHsnaW50JzogM30sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgeydwcm5zdHInOiAnYWFhJ31dfVxuICAgICAqICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgKi9cbiAgICB0aGlzLm5ld09iamVjdCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHZhciBfS0pVUiA9IEtKVVIsXG4gICAgICAgICAgICBfS0pVUl9hc24xID0gX0tKVVIuYXNuMSxcbiAgICAgICAgICAgIF9ERVJCb29sZWFuID0gX0tKVVJfYXNuMS5ERVJCb29sZWFuLFxuICAgICAgICAgICAgX0RFUkludGVnZXIgPSBfS0pVUl9hc24xLkRFUkludGVnZXIsXG4gICAgICAgICAgICBfREVSQml0U3RyaW5nID0gX0tKVVJfYXNuMS5ERVJCaXRTdHJpbmcsXG4gICAgICAgICAgICBfREVST2N0ZXRTdHJpbmcgPSBfS0pVUl9hc24xLkRFUk9jdGV0U3RyaW5nLFxuICAgICAgICAgICAgX0RFUk51bGwgPSBfS0pVUl9hc24xLkRFUk51bGwsXG4gICAgICAgICAgICBfREVST2JqZWN0SWRlbnRpZmllciA9IF9LSlVSX2FzbjEuREVST2JqZWN0SWRlbnRpZmllcixcbiAgICAgICAgICAgIF9ERVJFbnVtZXJhdGVkID0gX0tKVVJfYXNuMS5ERVJFbnVtZXJhdGVkLFxuICAgICAgICAgICAgX0RFUlVURjhTdHJpbmcgPSBfS0pVUl9hc24xLkRFUlVURjhTdHJpbmcsXG4gICAgICAgICAgICBfREVSTnVtZXJpY1N0cmluZyA9IF9LSlVSX2FzbjEuREVSTnVtZXJpY1N0cmluZyxcbiAgICAgICAgICAgIF9ERVJQcmludGFibGVTdHJpbmcgPSBfS0pVUl9hc24xLkRFUlByaW50YWJsZVN0cmluZyxcbiAgICAgICAgICAgIF9ERVJUZWxldGV4U3RyaW5nID0gX0tKVVJfYXNuMS5ERVJUZWxldGV4U3RyaW5nLFxuICAgICAgICAgICAgX0RFUklBNVN0cmluZyA9IF9LSlVSX2FzbjEuREVSSUE1U3RyaW5nLFxuICAgICAgICAgICAgX0RFUlVUQ1RpbWUgPSBfS0pVUl9hc24xLkRFUlVUQ1RpbWUsXG4gICAgICAgICAgICBfREVSR2VuZXJhbGl6ZWRUaW1lID0gX0tKVVJfYXNuMS5ERVJHZW5lcmFsaXplZFRpbWUsXG4gICAgICAgICAgICBfREVSU2VxdWVuY2UgPSBfS0pVUl9hc24xLkRFUlNlcXVlbmNlLFxuICAgICAgICAgICAgX0RFUlNldCA9IF9LSlVSX2FzbjEuREVSU2V0LFxuICAgICAgICAgICAgX0RFUlRhZ2dlZE9iamVjdCA9IF9LSlVSX2FzbjEuREVSVGFnZ2VkT2JqZWN0LFxuICAgICAgICAgICAgX25ld09iamVjdCA9IF9LSlVSX2FzbjEuQVNOMVV0aWwubmV3T2JqZWN0O1xuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFyYW0pO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggIT0gMSlcbiAgICAgICAgICAgIHRocm93IFwia2V5IG9mIHBhcmFtIHNoYWxsIGJlIG9ubHkgb25lLlwiO1xuICAgICAgICB2YXIga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBpZiAoXCI6Ym9vbDppbnQ6Yml0c3RyOm9jdHN0cjpudWxsOm9pZDplbnVtOnV0ZjhzdHI6bnVtc3RyOnBybnN0cjp0ZWxzdHI6aWE1c3RyOnV0Y3RpbWU6Z2VudGltZTpzZXE6c2V0OnRhZzpcIi5pbmRleE9mKFwiOlwiICsga2V5ICsgXCI6XCIpID09IC0xKVxuICAgICAgICAgICAgdGhyb3cgXCJ1bmRlZmluZWQga2V5OiBcIiArIGtleTtcblxuICAgICAgICBpZiAoa2V5ID09IFwiYm9vbFwiKSAgICByZXR1cm4gbmV3IF9ERVJCb29sZWFuKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiaW50XCIpICAgICByZXR1cm4gbmV3IF9ERVJJbnRlZ2VyKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiYml0c3RyXCIpICByZXR1cm4gbmV3IF9ERVJCaXRTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJvY3RzdHJcIikgIHJldHVybiBuZXcgX0RFUk9jdGV0U3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwibnVsbFwiKSAgICByZXR1cm4gbmV3IF9ERVJOdWxsKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwib2lkXCIpICAgICByZXR1cm4gbmV3IF9ERVJPYmplY3RJZGVudGlmaWVyKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiZW51bVwiKSAgICByZXR1cm4gbmV3IF9ERVJFbnVtZXJhdGVkKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwidXRmOHN0clwiKSByZXR1cm4gbmV3IF9ERVJVVEY4U3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwibnVtc3RyXCIpICByZXR1cm4gbmV3IF9ERVJOdW1lcmljU3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwicHJuc3RyXCIpICByZXR1cm4gbmV3IF9ERVJQcmludGFibGVTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJ0ZWxzdHJcIikgIHJldHVybiBuZXcgX0RFUlRlbGV0ZXhTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJpYTVzdHJcIikgIHJldHVybiBuZXcgX0RFUklBNVN0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcInV0Y3RpbWVcIikgcmV0dXJuIG5ldyBfREVSVVRDVGltZShwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcImdlbnRpbWVcIikgcmV0dXJuIG5ldyBfREVSR2VuZXJhbGl6ZWRUaW1lKHBhcmFtW2tleV0pO1xuXG4gICAgICAgIGlmIChrZXkgPT0gXCJzZXFcIikge1xuICAgICAgICAgICAgdmFyIHBhcmFtTGlzdCA9IHBhcmFtW2tleV07XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXNuMU9iaiA9IF9uZXdPYmplY3QocGFyYW1MaXN0W2ldKTtcbiAgICAgICAgICAgICAgICBhLnB1c2goYXNuMU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJTZXF1ZW5jZSh7J2FycmF5JzogYX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1MaXN0ID0gcGFyYW1ba2V5XTtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhc24xT2JqID0gX25ld09iamVjdChwYXJhbUxpc3RbaV0pO1xuICAgICAgICAgICAgICAgIGEucHVzaChhc24xT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgX0RFUlNldCh7J2FycmF5JzogYX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSA9PSBcInRhZ1wiKSB7XG4gICAgICAgICAgICB2YXIgdGFnUGFyYW0gPSBwYXJhbVtrZXldO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YWdQYXJhbSkgPT09ICdbb2JqZWN0IEFycmF5XScgJiZcbiAgICAgICAgICAgICAgICB0YWdQYXJhbS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBfbmV3T2JqZWN0KHRhZ1BhcmFtWzJdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJUYWdnZWRPYmplY3Qoe3RhZzogdGFnUGFyYW1bMF0sXG4gICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0OiB0YWdQYXJhbVsxXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqOiBvYmp9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1BhcmFtID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRhZ1BhcmFtLmV4cGxpY2l0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtLmV4cGxpY2l0ID0gdGFnUGFyYW0uZXhwbGljaXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ1BhcmFtLnRhZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbS50YWcgPSB0YWdQYXJhbS50YWc7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ1BhcmFtLm9iaiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm9iaiBzaGFsbCBiZSBzcGVjaWZpZWQgZm9yICd0YWcnLlwiO1xuICAgICAgICAgICAgICAgIG5ld1BhcmFtLm9iaiA9IF9uZXdPYmplY3QodGFnUGFyYW0ub2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJUYWdnZWRPYmplY3QobmV3UGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdldCBlbmNvZGVkIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04xT2JqZWN0IHNwZWNpZmVkIGJ5IEpTT04gcGFyYW1ldGVyc1xuICAgICAqIEBuYW1lIGpzb25Ub0FTTjFIRVhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW0gSlNPTiBwYXJhbWV0ZXIgdG8gZ2VuZXJhdGUgQVNOMU9iamVjdFxuICAgICAqIEByZXR1cm4gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTjFPYmplY3RcbiAgICAgKiBAc2luY2UgYXNuMSAxLjAuNFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEFzIGZvciBBU04uMSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgSlNPTiBvYmplY3QsXG4gICAgICogcGxlYXNlIHNlZSB7QGxpbmsgbmV3T2JqZWN0fS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGpzb25Ub0FTTjFIRVgoeydwcm5zdHInOiAnYWFhJ30pO1xuICAgICAqL1xuICAgIHRoaXMuanNvblRvQVNOMUhFWCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHZhciBhc24xT2JqID0gdGhpcy5uZXdPYmplY3QocGFyYW0pO1xuICAgICAgICByZXR1cm4gYXNuMU9iai5nZXRFbmNvZGVkSGV4KCk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogZ2V0IGRvdCBub3RlZCBvaWQgbnVtYmVyIHN0cmluZyBmcm9tIGhleGFkZWNpbWFsIHZhbHVlIG9mIE9JRFxuICogQG5hbWUgb2lkSGV4VG9JbnRcbiAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGhleCBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllclxuICogQHJldHVybiB7U3RyaW5nfSBkb3Qgbm90ZWQgc3RyaW5nIG9mIG9iamVjdCBpZGVudGlmaWVyXG4gKiBAc2luY2UganNyc2FzaWduIDQuOC4zIGFzbjEgMS4wLjdcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzdGF0aWMgbWV0aG9kIGNvbnZlcnRzIGZyb20gaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBBU04uMSB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllciB0byBvaWQgbnVtYmVyIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKiBLSlVSLmFzbjEuQVNOMVV0aWwub2lkSGV4VG9JbnQoJzU1MDQwNicpICZyYXJyOyBcIjIuNS40LjZcIlxuICovXG5LSlVSLmFzbjEuQVNOMVV0aWwub2lkSGV4VG9JbnQgPSBmdW5jdGlvbihoZXgpIHtcbiAgICB2YXIgcyA9IFwiXCI7XG4gICAgdmFyIGkwMSA9IHBhcnNlSW50KGhleC5zdWJzdHIoMCwgMiksIDE2KTtcbiAgICB2YXIgaTAgPSBNYXRoLmZsb29yKGkwMSAvIDQwKTtcbiAgICB2YXIgaTEgPSBpMDEgJSA0MDtcbiAgICB2YXIgcyA9IGkwICsgXCIuXCIgKyBpMTtcblxuICAgIHZhciBiaW5idWYgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICAgICAgdmFyIGJpbiA9IChcIjAwMDAwMDAwXCIgKyB2YWx1ZS50b1N0cmluZygyKSkuc2xpY2UoLSA4KTtcbiAgICAgICAgYmluYnVmID0gYmluYnVmICsgYmluLnN1YnN0cigxLCA3KTtcbiAgICAgICAgaWYgKGJpbi5zdWJzdHIoMCwgMSkgPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHZhciBiaSA9IG5ldyBCaWdJbnRlZ2VyKGJpbmJ1ZiwgMik7XG4gICAgICAgICAgICBzID0gcyArIFwiLlwiICsgYmkudG9TdHJpbmcoMTApO1xuICAgICAgICAgICAgYmluYnVmID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogZ2V0IGhleGFkZWNpbWFsIHZhbHVlIG9mIG9iamVjdCBpZGVudGlmaWVyIGZyb20gZG90IG5vdGVkIG9pZCB2YWx1ZVxuICogQG5hbWUgb2lkSW50VG9IZXhcbiAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG9pZFN0cmluZyBkb3Qgbm90ZWQgc3RyaW5nIG9mIG9iamVjdCBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGhleGFkZWNpbWFsIHZhbHVlIG9mIG9iamVjdCBpZGVudGlmaWVyXG4gKiBAc2luY2UganNyc2FzaWduIDQuOC4zIGFzbjEgMS4wLjdcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzdGF0aWMgbWV0aG9kIGNvbnZlcnRzIGZyb20gb2JqZWN0IGlkZW50aWZpZXIgdmFsdWUgc3RyaW5nLlxuICogdG8gaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0LlxuICogQGV4YW1wbGVcbiAqIEtKVVIuYXNuMS5BU04xVXRpbC5vaWRJbnRUb0hleChcIjIuNS40LjZcIikgJnJhcnI7IFwiNTUwNDA2XCJcbiAqL1xuS0pVUi5hc24xLkFTTjFVdGlsLm9pZEludFRvSGV4ID0gZnVuY3Rpb24ob2lkU3RyaW5nKSB7XG4gICAgdmFyIGl0b3ggPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBoID0gaS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoLmxlbmd0aCA9PSAxKSBoID0gJzAnICsgaDtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcblxuICAgIHZhciByb2lkdG94ID0gZnVuY3Rpb24ocm9pZCkge1xuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihyb2lkLCAxMCk7XG4gICAgICAgIHZhciBiID0gYmkudG9TdHJpbmcoMik7XG4gICAgICAgIHZhciBwYWRMZW4gPSA3IC0gYi5sZW5ndGggJSA3O1xuICAgICAgICBpZiAocGFkTGVuID09IDcpIHBhZExlbiA9IDA7XG4gICAgICAgIHZhciBiUGFkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkTGVuOyBpKyspIGJQYWQgKz0gJzAnO1xuICAgICAgICBiID0gYlBhZCArIGI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGggLSAxOyBpICs9IDcpIHtcbiAgICAgICAgICAgIHZhciBiOCA9IGIuc3Vic3RyKGksIDcpO1xuICAgICAgICAgICAgaWYgKGkgIT0gYi5sZW5ndGggLSA3KSBiOCA9ICcxJyArIGI4O1xuICAgICAgICAgICAgaCArPSBpdG94KHBhcnNlSW50KGI4LCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcblxuICAgIGlmICghIG9pZFN0cmluZy5tYXRjaCgvXlswLTkuXSskLykpIHtcbiAgICAgICAgdGhyb3cgXCJtYWxmb3JtZWQgb2lkIHN0cmluZzogXCIgKyBvaWRTdHJpbmc7XG4gICAgfVxuICAgIHZhciBoID0gJyc7XG4gICAgdmFyIGEgPSBvaWRTdHJpbmcuc3BsaXQoJy4nKTtcbiAgICB2YXIgaTAgPSBwYXJzZUludChhWzBdKSAqIDQwICsgcGFyc2VJbnQoYVsxXSk7XG4gICAgaCArPSBpdG94KGkwKTtcbiAgICBhLnNwbGljZSgwLCAyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaCArPSByb2lkdG94KGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gaDtcbn07XG5cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBBYnN0cmFjdCBBU04uMSBDbGFzc2VzXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vKipcbiAqIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBlbmNvZGVyIG9iamVjdFxuICogQG5hbWUgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBjbGFzcyBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgZW5jb2RlciBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNNb2RpZmllZCBmbGFnIHdoZXRoZXIgaW50ZXJuYWwgZGF0YSB3YXMgY2hhbmdlZFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGhUTFYgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMVlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGhUIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgdGFnKFQpXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaEwgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViBsZW5ndGgoTClcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBoViBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIHZhbHVlKFYpXG4gKiBAZGVzY3JpcHRpb25cbiAqL1xuS0pVUi5hc24xLkFTTjFPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaFYgPSAnJztcblxuICAgIC8qKlxuICAgICAqIGdldCBoZXhhZGVjaW1hbCBBU04uMSBUTFYgbGVuZ3RoKEwpIGJ5dGVzIGZyb20gVExWIHZhbHVlKFYpXG4gICAgICogQG5hbWUgZ2V0TGVuZ3RoSGV4RnJvbVZhbHVlXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xT2JqZWN0I1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViBsZW5ndGgoTClcbiAgICAgKi9cbiAgICB0aGlzLmdldExlbmd0aEhleEZyb21WYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaFYgPT0gXCJ1bmRlZmluZWRcIiB8fCB0aGlzLmhWID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IFwidGhpcy5oViBpcyBudWxsIG9yIHVuZGVmaW5lZC5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oVi5sZW5ndGggJSAyID09IDEpIHtcbiAgICAgICAgICAgIHRocm93IFwidmFsdWUgaGV4IG11c3QgYmUgZXZlbiBsZW5ndGg6IG49XCIgKyBoVi5sZW5ndGggKyBcIix2PVwiICsgdGhpcy5oVjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IHRoaXMuaFYubGVuZ3RoIC8gMjtcbiAgICAgICAgdmFyIGhOID0gbi50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoTi5sZW5ndGggJSAyID09IDEpIHtcbiAgICAgICAgICAgIGhOID0gXCIwXCIgKyBoTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8IDEyOCkge1xuICAgICAgICAgICAgcmV0dXJuIGhOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhObGVuID0gaE4ubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIGlmIChoTmxlbiA+IDE1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJBU04uMSBsZW5ndGggdG9vIGxvbmcgdG8gcmVwcmVzZW50IGJ5IDh4OiBuID0gXCIgKyBuLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZWFkID0gMTI4ICsgaE5sZW47XG4gICAgICAgICAgICByZXR1cm4gaGVhZC50b1N0cmluZygxNikgKyBoTjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViBieXRlc1xuICAgICAqIEBuYW1lIGdldEVuY29kZWRIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFPYmplY3QjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWXG4gICAgICovXG4gICAgdGhpcy5nZXRFbmNvZGVkSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmhUTFYgPT0gbnVsbCB8fCB0aGlzLmlzTW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaFYgPSB0aGlzLmdldEZyZXNoVmFsdWVIZXgoKTtcbiAgICAgICAgICAgIHRoaXMuaEwgPSB0aGlzLmdldExlbmd0aEhleEZyb21WYWx1ZSgpO1xuICAgICAgICAgICAgdGhpcy5oVExWID0gdGhpcy5oVCArIHRoaXMuaEwgKyB0aGlzLmhWO1xuICAgICAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAvL2FsZXJ0KFwiZmlyc3QgdGltZTogXCIgKyB0aGlzLmhUTFYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhUTFY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdldCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIHZhbHVlKFYpIGJ5dGVzXG4gICAgICogQG5hbWUgZ2V0VmFsdWVIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFPYmplY3QjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIHZhbHVlKFYpIGJ5dGVzXG4gICAgICovXG4gICAgdGhpcy5nZXRWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldEVuY29kZWRIZXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbn07XG5cbi8vID09IEJFR0lOIERFUkFic3RyYWN0U3RyaW5nID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgc3RyaW5nIGNsYXNzZXNcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBzdHJpbmcgY2xhc3Nlc1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzIGludGVybmFsIHN0cmluZyBvZiB2YWx1ZVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPnN0ciAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIHN0cmluZzwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIGdldCBzdHJpbmcgdmFsdWUgb2YgdGhpcyBzdHJpbmcgb2JqZWN0XG4gICAgICogQG5hbWUgZ2V0U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyB2YWx1ZSBvZiB0aGlzIHN0cmluZyBvYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLmdldFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBzdHJpbmdcbiAgICAgKiBAbmFtZSBzZXRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdTIHZhbHVlIGJ5IGEgc3RyaW5nIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0U3RyaW5nID0gZnVuY3Rpb24obmV3Uykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBuZXdTO1xuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgICAqIEBuYW1lIHNldFN0cmluZ0hleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld0hleFN0cmluZyB2YWx1ZSBieSBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldFN0cmluZ0hleCA9IGZ1bmN0aW9uKG5ld0hleFN0cmluZykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBudWxsO1xuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydzdHInXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhwYXJhbXNbJ3N0ciddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydoZXgnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZ0hleChwYXJhbXNbJ2hleCddKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vID09IEVORCAgIERFUkFic3RyYWN0U3RyaW5nID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyA9PSBCRUdJTiBERVJBYnN0cmFjdFRpbWUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKlxuICogYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIEdlbmVyYWxpemVkL1VUQ1RpbWUgY2xhc3NcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWVcbiAqIEBjbGFzcyBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgR2VuZXJhbGl6ZWQvVVRDVGltZSBjbGFzc1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICcxMzA0MzAyMzU5NTlaJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5BU04xT2JqZWN0IC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG5cbiAgICAvLyAtLS0gUFJJVkFURSBNRVRIT0RTIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdGhpcy5sb2NhbERhdGVUb1VUQyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdXRjID0gZC5nZXRUaW1lKCkgKyAoZC5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApO1xuICAgICAgICB2YXIgdXRjRGF0ZSA9IG5ldyBEYXRlKHV0Yyk7XG4gICAgICAgIHJldHVybiB1dGNEYXRlO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIGZvcm1hdCBkYXRlIHN0cmluZyBieSBEYXRhIG9iamVjdFxuICAgICAqIEBuYW1lIGZvcm1hdERhdGVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFic3RyYWN0VGltZTtcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVPYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAndXRjJyBvciAnZ2VuJ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aE1pbGxpcyBmbGFnIGZvciB3aXRoIG1pbGxpc2VjdGlvbnMgb3Igbm90XG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogJ3dpdGhNaWxsaXMnIGZsYWcgaXMgc3VwcG9ydGVkIGZyb20gYXNuMSAxLjAuNi5cbiAgICAgKi9cbiAgICB0aGlzLmZvcm1hdERhdGUgPSBmdW5jdGlvbihkYXRlT2JqZWN0LCB0eXBlLCB3aXRoTWlsbGlzKSB7XG4gICAgICAgIHZhciBwYWQgPSB0aGlzLnplcm9QYWRkaW5nO1xuICAgICAgICB2YXIgZCA9IHRoaXMubG9jYWxEYXRlVG9VVEMoZGF0ZU9iamVjdCk7XG4gICAgICAgIHZhciB5ZWFyID0gU3RyaW5nKGQuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgIGlmICh0eXBlID09ICd1dGMnKSB5ZWFyID0geWVhci5zdWJzdHIoMiwgMik7XG4gICAgICAgIHZhciBtb250aCA9IHBhZChTdHJpbmcoZC5nZXRNb250aCgpICsgMSksIDIpO1xuICAgICAgICB2YXIgZGF5ID0gcGFkKFN0cmluZyhkLmdldERhdGUoKSksIDIpO1xuICAgICAgICB2YXIgaG91ciA9IHBhZChTdHJpbmcoZC5nZXRIb3VycygpKSwgMik7XG4gICAgICAgIHZhciBtaW4gPSBwYWQoU3RyaW5nKGQuZ2V0TWludXRlcygpKSwgMik7XG4gICAgICAgIHZhciBzZWMgPSBwYWQoU3RyaW5nKGQuZ2V0U2Vjb25kcygpKSwgMik7XG4gICAgICAgIHZhciBzID0geWVhciArIG1vbnRoICsgZGF5ICsgaG91ciArIG1pbiArIHNlYztcbiAgICAgICAgaWYgKHdpdGhNaWxsaXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgaWYgKG1pbGxpcyAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNNaWxsaXMgPSBwYWQoU3RyaW5nKG1pbGxpcyksIDMpO1xuICAgICAgICAgICAgICAgIHNNaWxsaXMgPSBzTWlsbGlzLnJlcGxhY2UoL1swXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgcyA9IHMgKyBcIi5cIiArIHNNaWxsaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMgKyBcIlpcIjtcbiAgICB9O1xuXG4gICAgdGhpcy56ZXJvUGFkZGluZyA9IGZ1bmN0aW9uKHMsIGxlbikge1xuICAgICAgICBpZiAocy5sZW5ndGggPj0gbGVuKSByZXR1cm4gcztcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheShsZW4gLSBzLmxlbmd0aCArIDEpLmpvaW4oJzAnKSArIHM7XG4gICAgfTtcblxuICAgIC8vIC0tLSBQVUJMSUMgTUVUSE9EUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKlxuICAgICAqIGdldCBzdHJpbmcgdmFsdWUgb2YgdGhpcyBzdHJpbmcgb2JqZWN0XG4gICAgICogQG5hbWUgZ2V0U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgdmFsdWUgb2YgdGhpcyB0aW1lIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMuZ2V0U3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIHN0cmluZ1xuICAgICAqIEBuYW1lIHNldFN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdTIHZhbHVlIGJ5IGEgc3RyaW5nIHRvIHNldCBzdWNoIGxpa2UgXCIxMzA0MzAyMzU5NTlaXCJcbiAgICAgKi9cbiAgICB0aGlzLnNldFN0cmluZyA9IGZ1bmN0aW9uKG5ld1MpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zID0gbmV3UztcbiAgICAgICAgdGhpcy5oViA9IHN0b2hleChuZXdTKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgRGF0ZSBvYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeURhdGVWYWx1ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0geWVhciB5ZWFyIG9mIGRhdGUgKGV4LiAyMDEzKVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbW9udGggbW9udGggb2YgZGF0ZSBiZXR3ZWVuIDEgYW5kIDEyIChleC4gMTIpXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBkYXkgZGF5IG9mIG1vbnRoXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBob3VyIGhvdXJzIG9mIGRhdGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG1pbiBtaW51dGVzIG9mIGRhdGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHNlYyBzZWNvbmRzIG9mIGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5RGF0ZVZhbHVlID0gZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpIHtcbiAgICAgICAgdmFyIGRhdGVPYmplY3QgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciwgbWluLCBzZWMsIDApKTtcbiAgICAgICAgdGhpcy5zZXRCeURhdGUoZGF0ZU9iamVjdCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vID09IEVORCAgIERFUkFic3RyYWN0VGltZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyA9PSBCRUdJTiBERVJBYnN0cmFjdFN0cnVjdHVyZWQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKlxuICogYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIHN0cnVjdHVyZWQgY2xhc3NcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWRcbiAqIEBjbGFzcyBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgc3RydWN0dXJlZCBjbGFzc1xuICogQHByb3BlcnR5IHtBcnJheX0gYXNuMUFycmF5IGludGVybmFsIGFycmF5IG9mIEFTTjFPYmplY3RcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGFycmF5IG9mIEFTTjFPYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeUFTTjFPYmplY3RBcnJheVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFzbjFPYmplY3RBcnJheSBhcnJheSBvZiBBU04xT2JqZWN0IHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlBU04xT2JqZWN0QXJyYXkgPSBmdW5jdGlvbihhc24xT2JqZWN0QXJyYXkpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hc24xQXJyYXkgPSBhc24xT2JqZWN0QXJyYXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFwcGVuZCBhbiBBU04xT2JqZWN0IHRvIGludGVybmFsIGFycmF5XG4gICAgICogQG5hbWUgYXBwZW5kQVNOMU9iamVjdFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QVNOMU9iamVjdH0gYXNuMU9iamVjdCB0byBhZGRcbiAgICAgKi9cbiAgICB0aGlzLmFwcGVuZEFTTjFPYmplY3QgPSBmdW5jdGlvbihhc24xT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXNuMUFycmF5LnB1c2goYXNuMU9iamVjdCk7XG4gICAgfTtcblxuICAgIHRoaXMuYXNuMUFycmF5ID0gbmV3IEFycmF5KCk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snYXJyYXknXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmFzbjFBcnJheSA9IHBhcmFtc1snYXJyYXknXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBBU04uMSBPYmplY3QgQ2xhc3Nlc1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBCb29sZWFuXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQm9vbGVhblxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgQm9vbGVhblxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuQVNOMU9iamVjdCAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUkJvb2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICBLSlVSLmFzbjEuREVSQm9vbGVhbi5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDFcIjtcbiAgICB0aGlzLmhUTFYgPSBcIjAxMDFmZlwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJCb29sZWFuLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgSW50ZWdlclxuICogQG5hbWUgS0pVUi5hc24xLkRFUkludGVnZXJcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEludGVnZXJcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5pbnQgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgaW50ZWdlciB2YWx1ZTwvbGk+XG4gKiA8bGk+YmlnaW50IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IEJpZ0ludGVnZXIgb2JqZWN0PC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPC91bD5cbiAqIE5PVEU6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5LSlVSLmFzbjEuREVSSW50ZWdlciA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJJbnRlZ2VyLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwMlwiO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IFRvbSBXdSdzIEJpZ0ludGVnZXIgb2JqZWN0XG4gICAgICogQG5hbWUgc2V0QnlCaWdJbnRlZ2VyXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJJbnRlZ2VyI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QmlnSW50ZWdlcn0gYmlnSW50ZWdlclZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyID0gZnVuY3Rpb24oYmlnSW50ZWdlclZhbHVlKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaFYgPSBLSlVSLmFzbjEuQVNOMVV0aWwuYmlnSW50VG9NaW5Ud29zQ29tcGxlbWVudHNIZXgoYmlnSW50ZWdlclZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGludGVnZXIgdmFsdWVcbiAgICAgKiBAbmFtZSBzZXRCeUludGVnZXJcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkludGVnZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGludGVnZXIgdmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUludGVnZXIgPSBmdW5jdGlvbihpbnRWYWx1ZSkge1xuICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihTdHJpbmcoaW50VmFsdWUpLCAxMCk7XG4gICAgICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyKGJpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGludGVnZXIgdmFsdWVcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSSW50ZWdlciNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGludGVnZXIgdmFsdWVcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA8YnIvPlxuICAgICAqIE5PVEU6IFZhbHVlIHNoYWxsIGJlIHJlcHJlc2VudGVkIGJ5IG1pbmltdW0gb2N0ZXQgbGVuZ3RoIG9mXG4gICAgICogdHdvJ3MgY29tcGxlbWVudCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcigxMjMpO1xuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7J2ludCc6IDEyM30pO1xuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7J2hleCc6ICcxZmFkJ30pO1xuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVIZXggPSBmdW5jdGlvbihuZXdIZXhTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5oViA9IG5ld0hleFN0cmluZztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydiaWdpbnQnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5QmlnSW50ZWdlcihwYXJhbXNbJ2JpZ2ludCddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydpbnQnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXNbJ2ludCddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlJbnRlZ2VyKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaGV4J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUhleChwYXJhbXNbJ2hleCddKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSSW50ZWdlciwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIGVuY29kZWQgQml0U3RyaW5nIHByaW1pdGl2ZVxuICogQG5hbWUgS0pVUi5hc24xLkRFUkJpdFN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgZW5jb2RlZCBCaXRTdHJpbmcgcHJpbWl0aXZlXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+YmluIC0gc3BlY2lmeSBiaW5hcnkgc3RyaW5nIChleC4gJzEwMTExJyk8L2xpPlxuICogPGxpPmFycmF5IC0gc3BlY2lmeSBhcnJheSBvZiBib29sZWFuIChleC4gW3RydWUsZmFsc2UsdHJ1ZSx0cnVlXSk8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIHZhbHVlKFYpIGluY2x1ZGluZyB1bnVzZWQgYml0czwvbGk+XG4gKiA8bGk+b2JqIC0gc3BlY2lmeSB7QGxpbmsgS0pVUi5hc24xLkFTTjFVdGlsLm5ld09iamVjdH1cbiAqIGFyZ3VtZW50IGZvciBcIkJpdFN0cmluZyBlbmNhcHN1bGF0ZXNcIiBzdHJ1Y3R1cmUuPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFMTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuPGJyLz5cbiAqIE5PVEUyOiAnb2JqJyBwYXJhbWV0ZXIgaGF2ZSBiZWVuIHN1cHBvcnRlZCBzaW5jZVxuICogYXNuMSAxLjAuMTEsIGpzcnNhc2lnbiA2LjEuMSAoMjAxNi1TZXAtMjUpLjxici8+XG4gKiBAZXhhbXBsZVxuICogLy8gZGVmYXVsdCBjb25zdHJ1Y3RvclxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKCk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggYmluYXJ5IHN0cmluZ1xuICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKHtiaW46IFwiMTAxMVwifSk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggYm9vbGVhbiBhcnJheVxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKHthcnJheTogW3RydWUsZmFsc2UsdHJ1ZSx0cnVlXX0pO1xuICogLy8gaW5pdGlhbGl6ZSB3aXRoIGhleGFkZWNpbWFsIHN0cmluZyAoMDQgaXMgdW51c2VkIGJpdHMpXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZyh7aGV4OiBcIjA0YmFjMFwifSk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggQVNOMVV0aWwubmV3T2JqZWN0IGFyZ3VtZW50IGZvciBlbmNhcHN1bGF0ZWRcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZyh7b2JqOiB7c2VxOiBbe2ludDogM30sIHtwcm5zdHI6ICdhYWEnfV19fSk7XG4gKiAvLyBhYm92ZSBnZW5lcmF0ZXMgYSBBU04uMSBkYXRhIGxpa2UgdGhpczpcbiAqIC8vIEJJVCBTVFJJTkcsIGVuY2Fwc3VsYXRlcyB7XG4gKiAvLyAgIFNFUVVFTkNFIHtcbiAqIC8vICAgICBJTlRFR0VSIDNcbiAqIC8vICAgICBQcmludGFibGVTdHJpbmcgJ2FhYSdcbiAqIC8vICAgICB9XG4gKiAvLyAgIH1cbiAqL1xuS0pVUi5hc24xLkRFUkJpdFN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGFyYW1zLm9iaiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbyA9IEtKVVIuYXNuMS5BU04xVXRpbC5uZXdPYmplY3QocGFyYW1zLm9iaik7XG4gICAgICAgIHBhcmFtcy5oZXggPSBcIjAwXCIgKyBvLmdldEVuY29kZWRIZXgoKTtcbiAgICB9XG4gICAgS0pVUi5hc24xLkRFUkJpdFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDNcIjtcblxuICAgIC8qKlxuICAgICAqIHNldCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZyBpbmNsdWRpbmcgdW51c2VkIGJpdHNcbiAgICAgKiBAbmFtZSBzZXRIZXhWYWx1ZUluY2x1ZGluZ1VudXNlZEJpdHNcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3SGV4U3RyaW5nSW5jbHVkaW5nVW51c2VkQml0c1xuICAgICAqL1xuICAgIHRoaXMuc2V0SGV4VmFsdWVJbmNsdWRpbmdVbnVzZWRCaXRzID0gZnVuY3Rpb24obmV3SGV4U3RyaW5nSW5jbHVkaW5nVW51c2VkQml0cykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nSW5jbHVkaW5nVW51c2VkQml0cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IEFTTi4xIHZhbHVlKFYpIGJ5IHVudXNlZCBiaXQgYW5kIGhleGFkZWNpbWFsIHN0cmluZyBvZiB2YWx1ZVxuICAgICAqIEBuYW1lIHNldFVudXNlZEJpdHNBbmRIZXhWYWx1ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gdW51c2VkQml0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoVmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLnNldFVudXNlZEJpdHNBbmRIZXhWYWx1ZSA9IGZ1bmN0aW9uKHVudXNlZEJpdHMsIGhWYWx1ZSkge1xuICAgICAgICBpZiAodW51c2VkQml0cyA8IDAgfHwgNyA8IHVudXNlZEJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IFwidW51c2VkIGJpdHMgc2hhbGwgYmUgZnJvbSAwIHRvIDc6IHUgPSBcIiArIHVudXNlZEJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhVbnVzZWRCaXRzID0gXCIwXCIgKyB1bnVzZWRCaXRzO1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhWID0gaFVudXNlZEJpdHMgKyBoVmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCBBU04uMSBERVIgQml0U3RyaW5nIGJ5IGJpbmFyeSBzdHJpbmc8YnIvPlxuICAgICAqIEBuYW1lIHNldEJ5QmluYXJ5U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJpbmFyeVN0cmluZyBiaW5hcnkgdmFsdWUgc3RyaW5nIChpLmUuICcxMDExMScpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogSXRzIHVudXNlZCBiaXRzIHdpbGwgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJ5IGxlbmd0aCBvZlxuICAgICAqICdiaW5hcnlWYWx1ZScuIDxici8+XG4gICAgICogTk9URTogVHJhaWxpbmcgemVyb3MgJzAnIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZygpO1xuICAgICAqIG8uc2V0QnlCb29sZWFuQXJyYXkoXCIwMTAxMVwiKTtcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5QmluYXJ5U3RyaW5nID0gZnVuY3Rpb24oYmluYXJ5U3RyaW5nKSB7XG4gICAgICAgIGJpbmFyeVN0cmluZyA9IGJpbmFyeVN0cmluZy5yZXBsYWNlKC8wKyQvLCAnJyk7XG4gICAgICAgIHZhciB1bnVzZWRCaXRzID0gOCAtIGJpbmFyeVN0cmluZy5sZW5ndGggJSA4O1xuICAgICAgICBpZiAodW51c2VkQml0cyA9PSA4KSB1bnVzZWRCaXRzID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdW51c2VkQml0czsgaSsrKSB7XG4gICAgICAgICAgICBiaW5hcnlTdHJpbmcgKz0gJzAnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aCAtIDE7IGkgKz0gOCkge1xuICAgICAgICAgICAgdmFyIGIgPSBiaW5hcnlTdHJpbmcuc3Vic3RyKGksIDgpO1xuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChiLCAyKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBpZiAoeC5sZW5ndGggPT0gMSkgeCA9ICcwJyArIHg7XG4gICAgICAgICAgICBoICs9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oViA9ICcwJyArIHVudXNlZEJpdHMgKyBoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgQVNOLjEgVExWIHZhbHVlKFYpIGJ5IGFuIGFycmF5IG9mIGJvb2xlYW48YnIvPlxuICAgICAqIEBuYW1lIHNldEJ5Qm9vbGVhbkFycmF5XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHthcnJheX0gYm9vbGVhbkFycmF5IGFycmF5IG9mIGJvb2xlYW4gKGV4LiBbdHJ1ZSwgZmFsc2UsIHRydWVdKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE5PVEU6IFRyYWlsaW5nIGZhbHNlcyB3aWxsIGJlIGlnbm9yZWQgaW4gdGhlIEFTTi4xIERFUiBPYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcbiAgICAgKiBvLnNldEJ5Qm9vbGVhbkFycmF5KFtmYWxzZSwgdHJ1ZSwgZmFsc2UsIHRydWUsIHRydWVdKTtcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5Qm9vbGVhbkFycmF5ID0gZnVuY3Rpb24oYm9vbGVhbkFycmF5KSB7XG4gICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbGVhbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYm9vbGVhbkFycmF5W2ldID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzICs9ICcxJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcyArPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRCeUJpbmFyeVN0cmluZyhzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgYW4gYXJyYXkgb2YgZmFsc2VzIHdpdGggc3BlY2lmaWVkIGxlbmd0aDxici8+XG4gICAgICogQG5hbWUgbmV3RmFsc2VBcnJheVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBuTGVuZ3RoIGxlbmd0aCBvZiBhcnJheSB0byBnZW5lcmF0ZVxuICAgICAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBvZiBib29sZWFuIGZhbHNlc1xuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoaXMgc3RhdGljIG1ldGhvZCBtYXkgYmUgdXNlZnVsIHRvIGluaXRpYWxpemUgYm9vbGVhbiBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZygpO1xuICAgICAqIG8ubmV3RmFsc2VBcnJheSgzKSAmcmFycjsgW2ZhbHNlLCBmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgdGhpcy5uZXdGYWxzZUFycmF5ID0gZnVuY3Rpb24obkxlbmd0aCkge1xuICAgICAgICB2YXIgYSA9IG5ldyBBcnJheShuTGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFbaV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09IFwic3RyaW5nXCIgJiYgcGFyYW1zLnRvTG93ZXJDYXNlKCkubWF0Y2goL15bMC05YS1mXSskLykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGV4VmFsdWVJbmNsdWRpbmdVbnVzZWRCaXRzKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaGV4J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRIZXhWYWx1ZUluY2x1ZGluZ1VudXNlZEJpdHMocGFyYW1zWydoZXgnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snYmluJ10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUJpbmFyeVN0cmluZyhwYXJhbXNbJ2JpbiddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydhcnJheSddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlCb29sZWFuQXJyYXkocGFyYW1zWydhcnJheSddKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQml0U3RyaW5nLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgT2N0ZXRTdHJpbmc8YnIvPlxuICogQG5hbWUgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBPY3RldFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIEFTTi4xIE9jdGV0U3RyaW5nIHNpbXBsZSB0eXBlLjxici8+XG4gKiBTdXBwb3J0ZWQgXCJwYXJhbXNcIiBhdHRyaWJ1dGVzIGFyZTpcbiAqIDx1bD5cbiAqIDxsaT5zdHIgLSB0byBzZXQgYSBzdHJpbmcgYXMgYSB2YWx1ZTwvbGk+XG4gKiA8bGk+aGV4IC0gdG8gc2V0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIGFzIGEgdmFsdWU8L2xpPlxuICogPGxpPm9iaiAtIHRvIHNldCBhIGVuY2Fwc3VsYXRlZCBBU04uMSB2YWx1ZSBieSBKU09OIG9iamVjdFxuICogd2hpY2ggaXMgZGVmaW5lZCBpbiB7QGxpbmsgS0pVUi5hc24xLkFTTjFVdGlsLm5ld09iamVjdH08L2xpPlxuICogPC91bD5cbiAqIE5PVEU6IEEgcGFyYW1ldGVyICdvYmonIGhhdmUgYmVlbiBzdXBwb3J0ZWRcbiAqIGZvciBcIk9DVEVUIFNUUklORywgZW5jYXBzdWxhdGVzXCIgc3RydWN0dXJlLlxuICogc2luY2UgYXNuMSAxLjAuMTEsIGpzcnNhc2lnbiA2LjEuMSAoMjAxNi1TZXAtMjUpLlxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKiBAZXhhbXBsZVxuICogLy8gZGVmYXVsdCBjb25zdHJ1Y3RvclxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcoKTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBzdHJpbmdcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtzdHI6IFwiYWFhXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBoZXhhZGVjaW1hbCBzdHJpbmdcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtoZXg6IFwiNjE2MTYxXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBBU04xVXRpbC5uZXdPYmplY3QgYXJndW1lbnRcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtvYmo6IHtzZXE6IFt7aW50OiAzfSwge3BybnN0cjogJ2FhYSd9XX19KTtcbiAqIC8vIGFib3ZlIGdlbmVyYXRlcyBhIEFTTi4xIGRhdGEgbGlrZSB0aGlzOlxuICogLy8gT0NURVQgU1RSSU5HLCBlbmNhcHN1bGF0ZXMge1xuICogLy8gICBTRVFVRU5DRSB7XG4gKiAvLyAgICAgSU5URUdFUiAzXG4gKiAvLyAgICAgUHJpbnRhYmxlU3RyaW5nICdhYWEnXG4gKiAvLyAgICAgfVxuICogLy8gICB9XG4gKi9cbktKVVIuYXNuMS5ERVJPY3RldFN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGFyYW1zLm9iaiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbyA9IEtKVVIuYXNuMS5BU04xVXRpbC5uZXdPYmplY3QocGFyYW1zLm9iaik7XG4gICAgICAgIHBhcmFtcy5oZXggPSBvLmdldEVuY29kZWRIZXgoKTtcbiAgICB9XG4gICAgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjA0XCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE51bGxcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJOdWxsXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBOdWxsXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5BU04xT2JqZWN0IC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSTnVsbCA9IGZ1bmN0aW9uKCkge1xuICAgIEtKVVIuYXNuMS5ERVJOdWxsLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwNVwiO1xuICAgIHRoaXMuaFRMViA9IFwiMDUwMFwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJOdWxsLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgT2JqZWN0SWRlbnRpZmllclxuICogQG5hbWUgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXJcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE9iamVjdElkZW50aWZpZXJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydvaWQnOiAnMi41LjQuNSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPm9pZCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIG9pZCBzdHJpbmcgKGV4LiAyLjUuNC4xMyk8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbktKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIGl0b3ggPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBoID0gaS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoLmxlbmd0aCA9PSAxKSBoID0gJzAnICsgaDtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICB2YXIgcm9pZHRveCA9IGZ1bmN0aW9uKHJvaWQpIHtcbiAgICAgICAgdmFyIGggPSAnJztcbiAgICAgICAgdmFyIGJpID0gbmV3IEJpZ0ludGVnZXIocm9pZCwgMTApO1xuICAgICAgICB2YXIgYiA9IGJpLnRvU3RyaW5nKDIpO1xuICAgICAgICB2YXIgcGFkTGVuID0gNyAtIGIubGVuZ3RoICUgNztcbiAgICAgICAgaWYgKHBhZExlbiA9PSA3KSBwYWRMZW4gPSAwO1xuICAgICAgICB2YXIgYlBhZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbjsgaSsrKSBiUGFkICs9ICcwJztcbiAgICAgICAgYiA9IGJQYWQgKyBiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoIC0gMTsgaSArPSA3KSB7XG4gICAgICAgICAgICB2YXIgYjggPSBiLnN1YnN0cihpLCA3KTtcbiAgICAgICAgICAgIGlmIChpICE9IGIubGVuZ3RoIC0gNykgYjggPSAnMScgKyBiODtcbiAgICAgICAgICAgIGggKz0gaXRveChwYXJzZUludChiOCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG5cbiAgICBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDZcIjtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgICAqIEBuYW1lIHNldFZhbHVlSGV4XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdIZXhTdHJpbmcgaGV4YWRlY2ltYWwgdmFsdWUgb2YgT0lEIGJ5dGVzXG4gICAgICovXG4gICAgdGhpcy5zZXRWYWx1ZUhleCA9IGZ1bmN0aW9uKG5ld0hleFN0cmluZykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBudWxsO1xuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBPSUQgc3RyaW5nPGJyLz5cbiAgICAgKiBAbmFtZSBzZXRWYWx1ZU9pZFN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2lkU3RyaW5nIE9JRCBzdHJpbmcgKGV4LiAyLjUuNC4xMylcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIoKTtcbiAgICAgKiBvLnNldFZhbHVlT2lkU3RyaW5nKFwiMi41LjQuMTNcIik7XG4gICAgICovXG4gICAgdGhpcy5zZXRWYWx1ZU9pZFN0cmluZyA9IGZ1bmN0aW9uKG9pZFN0cmluZykge1xuICAgICAgICBpZiAoISBvaWRTdHJpbmcubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgICAgICB0aHJvdyBcIm1hbGZvcm1lZCBvaWQgc3RyaW5nOiBcIiArIG9pZFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICB2YXIgYSA9IG9pZFN0cmluZy5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgaTAgPSBwYXJzZUludChhWzBdKSAqIDQwICsgcGFyc2VJbnQoYVsxXSk7XG4gICAgICAgIGggKz0gaXRveChpMCk7XG4gICAgICAgIGEuc3BsaWNlKDAsIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGggKz0gcm9pZHRveChhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBudWxsO1xuICAgICAgICB0aGlzLmhWID0gaDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgT0lEIG5hbWVcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZU5hbWVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9pZE5hbWUgT0lEIG5hbWUgKGV4LiAnc2VydmVyQXV0aCcpXG4gICAgICogQHNpbmNlIDEuMC4xXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogT0lEIG5hbWUgc2hhbGwgYmUgZGVmaW5lZCBpbiAnS0pVUi5hc24xLng1MDkuT0lELm5hbWUyb2lkTGlzdCcuXG4gICAgICogT3RoZXJ3aXNlIHJhaXNlIGVycm9yLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllcigpO1xuICAgICAqIG8uc2V0VmFsdWVOYW1lKFwic2VydmVyQXV0aFwiKTtcbiAgICAgKi9cbiAgICB0aGlzLnNldFZhbHVlTmFtZSA9IGZ1bmN0aW9uKG9pZE5hbWUpIHtcbiAgICAgICAgdmFyIG9pZCA9IEtKVVIuYXNuMS54NTA5Lk9JRC5uYW1lMm9pZChvaWROYW1lKTtcbiAgICAgICAgaWYgKG9pZCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcob2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiREVST2JqZWN0SWRlbnRpZmllciBvaWROYW1lIHVuZGVmaW5lZDogXCIgKyBvaWROYW1lO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLm1hdGNoKC9eWzAtMl0uWzAtOS5dKyQvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcocGFyYW1zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZU5hbWUocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMub2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcocGFyYW1zLm9pZCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KHBhcmFtcy5oZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVOYW1lKHBhcmFtcy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIEVudW1lcmF0ZWRcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBFbnVtZXJhdGVkXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+aW50IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGludGVnZXIgdmFsdWU8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKiBAZXhhbXBsZVxuICogbmV3IEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkKDEyMyk7XG4gKiBuZXcgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQoe2ludDogMTIzfSk7XG4gKiBuZXcgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQoe2hleDogJzFmYWQnfSk7XG4gKi9cbktKVVIuYXNuMS5ERVJFbnVtZXJhdGVkID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcIjBhXCI7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgVG9tIFd1J3MgQmlnSW50ZWdlciBvYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeUJpZ0ludGVnZXJcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCaWdJbnRlZ2VyfSBiaWdJbnRlZ2VyVmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUJpZ0ludGVnZXIgPSBmdW5jdGlvbihiaWdJbnRlZ2VyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oViA9IEtKVVIuYXNuMS5BU04xVXRpbC5iaWdJbnRUb01pblR3b3NDb21wbGVtZW50c0hleChiaWdJbnRlZ2VyVmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBuYW1lIHNldEJ5SW50ZWdlclxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGludGVnZXIgdmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUludGVnZXIgPSBmdW5jdGlvbihpbnRWYWx1ZSkge1xuICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihTdHJpbmcoaW50VmFsdWUpLCAxMCk7XG4gICAgICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyKGJpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGludGVnZXIgdmFsdWVcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGludGVnZXIgdmFsdWVcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA8YnIvPlxuICAgICAqIE5PVEU6IFZhbHVlIHNoYWxsIGJlIHJlcHJlc2VudGVkIGJ5IG1pbmltdW0gb2N0ZXQgbGVuZ3RoIG9mXG4gICAgICogdHdvJ3MgY29tcGxlbWVudCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLnNldFZhbHVlSGV4ID0gZnVuY3Rpb24obmV3SGV4U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmc7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snaW50J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUludGVnZXIocGFyYW1zWydpbnQnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2hleCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVIZXgocGFyYW1zWydoZXgnXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBVVEY4U3RyaW5nXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSVVRGOFN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVVRGOFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUlVURjhTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSVVRGOFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIwY1wiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE51bWVyaWNTdHJpbmdcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBOdW1lcmljU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjEyXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUk51bWVyaWNTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgUHJpbnRhYmxlU3RyaW5nXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBQcmludGFibGVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJQcmludGFibGVTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjEzXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBUZWxldGV4U3RyaW5nXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSVGVsZXRleFN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVGVsZXRleFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSVGVsZXRleFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxNFwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJUZWxldGV4U3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIElBNVN0cmluZ1xuICogQG5hbWUgS0pVUi5hc24xLkRFUklBNVN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgSUE1U3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSSUE1U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUklBNVN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxNlwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJJQTVTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgVVRDVGltZVxuICogQG5hbWUgS0pVUi5hc24xLkRFUlVUQ1RpbWVcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFVUQ1RpbWVcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnMTMwNDMwMjM1OTU5Wid9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZVxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+c3RyIC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgc3RyaW5nIChleC4nMTMwNDMwMjM1OTU5WicpPC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPGxpPmRhdGUgLSBzcGVjaWZ5IERhdGUgb2JqZWN0LjwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKiA8aDQ+RVhBTVBMRVM8L2g0PlxuICogQGV4YW1wbGVcbiAqIGQxID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKCk7XG4gKiBkMS5zZXRTdHJpbmcoJzEzMDQzMDEyNTk1OVonKTtcbiAqXG4gKiBkMiA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSh7J3N0cic6ICcxMzA0MzAxMjU5NTlaJ30pO1xuICogZDMgPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoeydkYXRlJzogbmV3IERhdGUoRGF0ZS5VVEMoMjAxNSwgMCwgMzEsIDAsIDAsIDAsIDApKX0pO1xuICogZDQgPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoJzEzMDQzMDEyNTk1OVonKTtcbiAqL1xuS0pVUi5hc24xLkRFUlVUQ1RpbWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSVVRDVGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxN1wiO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgRGF0ZSBvYmplY3Q8YnIvPlxuICAgICAqIEBuYW1lIHNldEJ5RGF0ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSVVRDVGltZSNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVPYmplY3QgRGF0ZSBvYmplY3QgdG8gc2V0IEFTTi4xIHZhbHVlKFYpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKCk7XG4gICAgICogby5zZXRCeURhdGUobmV3IERhdGUoXCIyMDE2LzEyLzMxXCIpKTtcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5RGF0ZSA9IGZ1bmN0aW9uKGRhdGVPYmplY3QpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kYXRlID0gZGF0ZU9iamVjdDtcbiAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ3V0YycpO1xuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0ZSA9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB0aGlzLnMgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsICd1dGMnKTtcbiAgICAgICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJhbXMuc3RyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcy5zdHIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJzdHJpbmdcIiAmJiBwYXJhbXMubWF0Y2goL15bMC05XXsxMn1aJC8pKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5oZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmdIZXgocGFyYW1zLmhleCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRCeURhdGUocGFyYW1zLmRhdGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJVVENUaW1lLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBHZW5lcmFsaXplZFRpbWVcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWVcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEdlbmVyYWxpemVkVGltZVxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICcyMDEzMDQzMDIzNTk1OVonfSlcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gd2l0aE1pbGxpcyBmbGFnIHRvIHNob3cgbWlsbGlzZWNvbmRzIG9yIG5vdFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZVxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+c3RyIC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgc3RyaW5nIChleC4nMjAxMzA0MzAyMzU5NTlaJyk8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8bGk+ZGF0ZSAtIHNwZWNpZnkgRGF0ZSBvYmplY3QuPC9saT5cbiAqIDxsaT5taWxsaXMgLSBzcGVjaWZ5IGZsYWcgdG8gc2hvdyBtaWxsaXNlY29uZHMgKGZyb20gMS4wLjYpPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFMTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKiBOT1RFMjogJ3dpdGhNaWxsaXMnIHByb3BlcnR5IGlzIHN1cHBvcnRlZCBmcm9tIGFzbjEgMS4wLjYuXG4gKi9cbktKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjE4XCI7XG4gICAgdGhpcy53aXRoTWlsbGlzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBEYXRlIG9iamVjdFxuICAgICAqIEBuYW1lIHNldEJ5RGF0ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZU9iamVjdCBEYXRlIG9iamVjdCB0byBzZXQgQVNOLjEgdmFsdWUoVilcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFdoZW4geW91IHNwZWNpZnkgVVRDIHRpbWUsIHVzZSAnRGF0ZS5VVEMnIG1ldGhvZCBsaWtlIHRoaXM6PGJyLz5cbiAgICAgKiBvMSA9IG5ldyBERVJVVENUaW1lKCk7XG4gICAgICogbzEuc2V0QnlEYXRlKGRhdGUpO1xuICAgICAqXG4gICAgICogZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKDIwMTUsIDAsIDMxLCAyMywgNTksIDU5LCAwKSk7ICMyMDE1SkFOMzEgMjM6NTk6NTlcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5RGF0ZSA9IGZ1bmN0aW9uKGRhdGVPYmplY3QpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kYXRlID0gZGF0ZU9iamVjdDtcbiAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ2dlbicsIHRoaXMud2l0aE1pbGxpcyk7XG4gICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsICdnZW4nLCB0aGlzLndpdGhNaWxsaXMpO1xuICAgICAgICAgICAgdGhpcy5oViA9IHN0b2hleCh0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zdHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zLnN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcInN0cmluZ1wiICYmIHBhcmFtcy5tYXRjaCgvXlswLTldezE0fVokLykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZ0hleChwYXJhbXMuaGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5RGF0ZShwYXJhbXMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5taWxsaXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMud2l0aE1pbGxpcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZSwgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgU2VxdWVuY2VcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJTZXF1ZW5jZVxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgU2VxdWVuY2VcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWRcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPmFycmF5IC0gc3BlY2lmeSBhcnJheSBvZiBBU04xT2JqZWN0IHRvIHNldCBlbGVtZW50cyBvZiBjb250ZW50PC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuS0pVUi5hc24xLkRFUlNlcXVlbmNlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlNlcXVlbmNlLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjMwXCI7XG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hc24xQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhc24xT2JqID0gdGhpcy5hc24xQXJyYXlbaV07XG4gICAgICAgICAgICBoICs9IGFzbjFPYmouZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaFYgPSBoO1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJTZXF1ZW5jZSwgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgU2V0XG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSU2V0XG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBTZXRcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWRcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPmFycmF5IC0gc3BlY2lmeSBhcnJheSBvZiBBU04xT2JqZWN0IHRvIHNldCBlbGVtZW50cyBvZiBjb250ZW50PC9saT5cbiAqIDxsaT5zb3J0ZmxhZyAtIGZsYWcgZm9yIHNvcnQgKGRlZmF1bHQ6IHRydWUpLiBBU04uMSBCRVIgaXMgbm90IHNvcnRlZCBpbiAnU0VUIE9GJy48L2xpPlxuICogPC91bD5cbiAqIE5PVEUxOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC48YnIvPlxuICogTk9URTI6IHNvcnRmbGFnIGlzIHN1cHBvcnRlZCBzaW5jZSAxLjAuNS5cbiAqL1xuS0pVUi5hc24xLkRFUlNldCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJTZXQuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMzFcIjtcbiAgICB0aGlzLnNvcnRGbGFnID0gdHJ1ZTsgLy8gaXRlbSBzaGFsbCBiZSBzb3J0ZWQgb25seSBpbiBBU04uMSBERVJcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFzbjFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFzbjFPYmogPSB0aGlzLmFzbjFBcnJheVtpXTtcbiAgICAgICAgICAgIGEucHVzaChhc24xT2JqLmdldEVuY29kZWRIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc29ydEZsYWcgPT0gdHJ1ZSkgYS5zb3J0KCk7XG4gICAgICAgIHRoaXMuaFYgPSBhLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5zb3J0ZmxhZyAhPSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBwYXJhbXMuc29ydGZsYWcgPT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNvcnRGbGFnID0gZmFsc2U7XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJTZXQsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFRhZ2dlZE9iamVjdFxuICogQG5hbWUgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVGFnZ2VkT2JqZWN0XG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogUGFyYW1ldGVyICd0YWdOb05leCcgaXMgQVNOLjEgdGFnKFQpIHZhbHVlIGZvciB0aGlzIG9iamVjdC5cbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgZmluZCAnWzFdJyB0YWcgaW4gYSBBU04uMSBkdW1wLFxuICogJ3RhZ05vSGV4JyB3aWxsIGJlICdhMScuXG4gKiA8YnIvPlxuICogQXMgZm9yIG9wdGlvbmFsIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5ICpBTlkqIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5leHBsaWNpdCAtIHNwZWNpZnkgdHJ1ZSBpZiB0aGlzIGlzIGV4cGxpY2l0IHRhZyBvdGhlcndpc2UgZmFsc2VcbiAqICAgICAoZGVmYXVsdCBpcyAndHJ1ZScpLjwvbGk+XG4gKiA8bGk+dGFnIC0gc3BlY2lmeSB0YWcgKGRlZmF1bHQgaXMgJ2EwJyB3aGljaCBtZWFucyBbMF0pPC9saT5cbiAqIDxsaT5vYmogLSBzcGVjaWZ5IEFTTjFPYmplY3Qgd2hpY2ggaXMgdGFnZ2VkPC9saT5cbiAqIDwvdWw+XG4gKiBAZXhhbXBsZVxuICogZDEgPSBuZXcgS0pVUi5hc24xLkRFUlVURjhTdHJpbmcoeydzdHInOidhJ30pO1xuICogZDIgPSBuZXcgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdCh7J29iaic6IGQxfSk7XG4gKiBoZXggPSBkMi5nZXRFbmNvZGVkSGV4KCk7XG4gKi9cbktKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3QgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0LnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCJhMFwiO1xuICAgIHRoaXMuaFYgPSAnJztcbiAgICB0aGlzLmlzRXhwbGljaXQgPSB0cnVlO1xuICAgIHRoaXMuYXNuMU9iamVjdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYW4gQVNOMU9iamVjdFxuICAgICAqIEBuYW1lIHNldFN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0I1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFeHBsaWNpdEZsYWcgZmxhZyBmb3IgZXhwbGljaXQvaW1wbGljaXQgdGFnXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB0YWdOb0hleCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgdGFnXG4gICAgICogQHBhcmFtIHtBU04xT2JqZWN0fSBhc24xT2JqZWN0IEFTTi4xIHRvIGVuY2Fwc3VsYXRlXG4gICAgICovXG4gICAgdGhpcy5zZXRBU04xT2JqZWN0ID0gZnVuY3Rpb24oaXNFeHBsaWNpdEZsYWcsIHRhZ05vSGV4LCBhc24xT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuaFQgPSB0YWdOb0hleDtcbiAgICAgICAgdGhpcy5pc0V4cGxpY2l0ID0gaXNFeHBsaWNpdEZsYWc7XG4gICAgICAgIHRoaXMuYXNuMU9iamVjdCA9IGFzbjFPYmplY3Q7XG4gICAgICAgIGlmICh0aGlzLmlzRXhwbGljaXQpIHtcbiAgICAgICAgICAgIHRoaXMuaFYgPSB0aGlzLmFzbjFPYmplY3QuZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhWID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaFRMViA9IGFzbjFPYmplY3QuZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICAgICAgdGhpcy5oVExWID0gdGhpcy5oVExWLnJlcGxhY2UoL14uLi8sIHRhZ05vSGV4KTtcbiAgICAgICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1sndGFnJ10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5oVCA9IHBhcmFtc1sndGFnJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ2V4cGxpY2l0J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5pc0V4cGxpY2l0ID0gcGFyYW1zWydleHBsaWNpdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydvYmonXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmFzbjFPYmplY3QgPSBwYXJhbXNbJ29iaiddO1xuICAgICAgICAgICAgdGhpcy5zZXRBU04xT2JqZWN0KHRoaXMuaXNFeHBsaWNpdCwgdGhpcy5oVCwgdGhpcy5hc24xT2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0LCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEpTRW5jcnlwdFJTQUtleSB0aGF0IGV4dGVuZHMgVG9tIFd1J3MgUlNBIGtleSBvYmplY3QuXG4gKiBUaGlzIG9iamVjdCBpcyBqdXN0IGEgZGVjb3JhdG9yIGZvciBwYXJzaW5nIHRoZSBrZXkgcGFyYW1ldGVyXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleSAtIFRoZSBrZXkgaW4gc3RyaW5nIGZvcm1hdCwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAqIHRoZSBwYXJhbWV0ZXJzIG5lZWRlZCB0byBidWlsZCBhIFJTQUtleSBvYmplY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpTRW5jcnlwdFJTQUtleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNFbmNyeXB0UlNBS2V5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTRW5jcnlwdFJTQUtleShrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLy8gQ2FsbCB0aGUgc3VwZXIgY29uc3RydWN0b3IuXG4gICAgICAgIC8vICBSU0FLZXkuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gSWYgYSBrZXkga2V5IHdhcyBwcm92aWRlZC5cbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmluZy4uLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZUtleShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoSlNFbmNyeXB0UlNBS2V5Lmhhc1ByaXZhdGVLZXlQcm9wZXJ0eShrZXkpIHx8XG4gICAgICAgICAgICAgICAgSlNFbmNyeXB0UlNBS2V5Lmhhc1B1YmxpY0tleVByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlcyBmb3IgdGhlIGtleS5cbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZVByb3BlcnRpZXNGcm9tKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcGFyc2UgYSBwZW0gZW5jb2RlZCBzdHJpbmcgY29udGFpbmluZyBib3RoIGEgcHVibGljIG9yIHByaXZhdGUga2V5LlxuICAgICAqIFRoZSBtZXRob2Qgd2lsbCB0cmFuc2xhdGUgdGhlIHBlbSBlbmNvZGVkIHN0cmluZyBpbiBhIGRlciBlbmNvZGVkIHN0cmluZyBhbmRcbiAgICAgKiB3aWxsIHBhcnNlIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5IHBhcmFtZXRlcnMuIFRoaXMgbWV0aG9kIGFjY2VwdHMgcHVibGljIGtleVxuICAgICAqIGluIHRoZSByc2FlbmNyeXB0aW9uIHBrY3MgIzEgZm9ybWF0IChvaWQ6IDEuMi44NDAuMTEzNTQ5LjEuMS4xKS5cbiAgICAgKlxuICAgICAqIEB0b2RvIENoZWNrIGhvdyBtYW55IHJzYSBmb3JtYXRzIHVzZSB0aGUgc2FtZSBmb3JtYXQgb2YgcGtjcyAjMS5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgaXMgZGVmaW5lZCBhczpcbiAgICAgKiBQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBhbGdvcml0aG0gICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAgICAgKiAgIFB1YmxpY0tleSAgICAgICBCSVQgU1RSSU5HXG4gICAgICogfVxuICAgICAqIFdoZXJlIEFsZ29yaXRobUlkZW50aWZpZXIgaXM6XG4gICAgICogQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgYWxnb3JpdGhtICAgICAgIE9CSkVDVCBJREVOVElGSUVSLCAgICAgdGhlIE9JRCBvZiB0aGUgZW5jIGFsZ29yaXRobVxuICAgICAqICAgcGFyYW1ldGVycyAgICAgIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTCAoTlVMTCBmb3IgUEtDUyAjMSlcbiAgICAgKiB9XG4gICAgICogYW5kIFB1YmxpY0tleSBpcyBhIFNFUVVFTkNFIGVuY2Fwc3VsYXRlZCBpbiBhIEJJVCBTVFJJTkdcbiAgICAgKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIG1vZHVsdXMgICAgICAgICAgIElOVEVHRVIsICAtLSBuXG4gICAgICogICBwdWJsaWNFeHBvbmVudCAgICBJTlRFR0VSICAgLS0gZVxuICAgICAqIH1cbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRvIGV4YW1pbmUgdGhlIHN0cnVjdHVyZSBvZiB0aGUga2V5cyBvYnRhaW5lZCBmcm9tIG9wZW5zc2wgdXNpbmdcbiAgICAgKiBhbiBhc24uMSBkdW1wZXIgYXMgdGhlIG9uZSB1c2VkIGhlcmUgdG8gcGFyc2UgdGhlIGNvbXBvbmVudHM6IGh0dHA6Ly9sYXBvLml0L2FzbjFqcy9cbiAgICAgKiBAYXJndW1lbnQge3N0cmluZ30gcGVtIHRoZSBwZW0gZW5jb2RlZCBzdHJpbmcsIGNhbiBpbmNsdWRlIHRoZSBCRUdJTi9FTkQgaGVhZGVyL2Zvb3RlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5wYXJzZUtleSA9IGZ1bmN0aW9uIChwZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtb2R1bHVzID0gMDtcbiAgICAgICAgICAgIHZhciBwdWJsaWNfZXhwb25lbnQgPSAwO1xuICAgICAgICAgICAgdmFyIHJlSGV4ID0gL15cXHMqKD86WzAtOUEtRmEtZl1bMC05QS1GYS1mXVxccyopKyQvO1xuICAgICAgICAgICAgdmFyIGRlciA9IHJlSGV4LnRlc3QocGVtKSA/IEhleC5kZWNvZGUocGVtKSA6IEJhc2U2NC51bmFybW9yKHBlbSk7XG4gICAgICAgICAgICB2YXIgYXNuMSA9IEFTTjEuZGVjb2RlKGRlcik7XG4gICAgICAgICAgICAvLyBGaXhlcyBhIGJ1ZyB3aXRoIE9wZW5TU0wgMS4wKyBwcml2YXRlIGtleXNcbiAgICAgICAgICAgIGlmIChhc24xLnN1Yi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBhc24xID0gYXNuMS5zdWJbMl0uc3ViWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzbjEuc3ViLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBwcml2YXRlIGtleS5cbiAgICAgICAgICAgICAgICBtb2R1bHVzID0gYXNuMS5zdWJbMV0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5uID0gcGFyc2VCaWdJbnQobW9kdWx1cywgMTYpO1xuICAgICAgICAgICAgICAgIHB1YmxpY19leHBvbmVudCA9IGFzbjEuc3ViWzJdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGludFxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KHB1YmxpY19leHBvbmVudCwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBwcml2YXRlX2V4cG9uZW50ID0gYXNuMS5zdWJbM10uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5kID0gcGFyc2VCaWdJbnQocHJpdmF0ZV9leHBvbmVudCwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBwcmltZTEgPSBhc24xLnN1Yls0XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBwYXJzZUJpZ0ludChwcmltZTEsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWUyID0gYXNuMS5zdWJbNV0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5xID0gcGFyc2VCaWdJbnQocHJpbWUyLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50MSA9IGFzbjEuc3ViWzZdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxuICAgICAgICAgICAgICAgIHRoaXMuZG1wMSA9IHBhcnNlQmlnSW50KGV4cG9uZW50MSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudDIgPSBhc24xLnN1Yls3XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmRtcTEgPSBwYXJzZUJpZ0ludChleHBvbmVudDIsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgY29lZmZpY2llbnQgPSBhc24xLnN1Yls4XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmID0gcGFyc2VCaWdJbnQoY29lZmZpY2llbnQsIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFzbjEuc3ViLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBwdWJsaWMga2V5LlxuICAgICAgICAgICAgICAgIHZhciBiaXRfc3RyaW5nID0gYXNuMS5zdWJbMV07XG4gICAgICAgICAgICAgICAgdmFyIHNlcXVlbmNlID0gYml0X3N0cmluZy5zdWJbMF07XG4gICAgICAgICAgICAgICAgbW9kdWx1cyA9IHNlcXVlbmNlLnN1YlswXS5nZXRIZXhTdHJpbmdWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubiA9IHBhcnNlQmlnSW50KG1vZHVsdXMsIDE2KTtcbiAgICAgICAgICAgICAgICBwdWJsaWNfZXhwb25lbnQgPSBzZXF1ZW5jZS5zdWJbMV0uZ2V0SGV4U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChwdWJsaWNfZXhwb25lbnQsIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGUgcnNhIHBhcmFtZXRlcnMgaW4gYSBoZXggZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByc2Ega2V5LlxuICAgICAqXG4gICAgICogVGhlIHRyYW5zbGF0aW9uIGZvbGxvdyB0aGUgQVNOLjEgbm90YXRpb24gOlxuICAgICAqIFJTQVByaXZhdGVLZXkgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIHZlcnNpb24gICAgICAgICAgIFZlcnNpb24sXG4gICAgICogICBtb2R1bHVzICAgICAgICAgICBJTlRFR0VSLCAgLS0gblxuICAgICAqICAgcHVibGljRXhwb25lbnQgICAgSU5URUdFUiwgIC0tIGVcbiAgICAgKiAgIHByaXZhdGVFeHBvbmVudCAgIElOVEVHRVIsICAtLSBkXG4gICAgICogICBwcmltZTEgICAgICAgICAgICBJTlRFR0VSLCAgLS0gcFxuICAgICAqICAgcHJpbWUyICAgICAgICAgICAgSU5URUdFUiwgIC0tIHFcbiAgICAgKiAgIGV4cG9uZW50MSAgICAgICAgIElOVEVHRVIsICAtLSBkIG1vZCAocDEpXG4gICAgICogICBleHBvbmVudDIgICAgICAgICBJTlRFR0VSLCAgLS0gZCBtb2QgKHEtMSlcbiAgICAgKiAgIGNvZWZmaWNpZW50ICAgICAgIElOVEVHRVIsICAtLSAoaW52ZXJzZSBvZiBxKSBtb2QgcFxuICAgICAqIH1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgREVSIEVuY29kZWQgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnNhIHByaXZhdGUga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFByaXZhdGVCYXNlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFycmF5OiBbXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgaW50OiAwIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5uIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGludDogdGhpcy5lIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5wIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5xIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kbXAxIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kbXExIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5jb2VmZiB9KVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VxID0gbmV3IEtKVVIuYXNuMS5ERVJTZXF1ZW5jZShvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHNlcS5nZXRFbmNvZGVkSGV4KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBiYXNlNjQgKHBlbSkgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBERVIgZW5jb2RlZCByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQcml2YXRlQmFzZUtleUI2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhleDJiNjQodGhpcy5nZXRQcml2YXRlQmFzZUtleSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZSByc2EgcGFyYW1ldGVycyBpbiBhIGhleCBlbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJzYSBwdWJsaWMga2V5LlxuICAgICAqIFRoZSByZXByZXNlbnRhdGlvbiBmb2xsb3cgdGhlIEFTTi4xIG5vdGF0aW9uIDpcbiAgICAgKiBQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBhbGdvcml0aG0gICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAgICAgKiAgIFB1YmxpY0tleSAgICAgICBCSVQgU1RSSU5HXG4gICAgICogfVxuICAgICAqIFdoZXJlIEFsZ29yaXRobUlkZW50aWZpZXIgaXM6XG4gICAgICogQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgYWxnb3JpdGhtICAgICAgIE9CSkVDVCBJREVOVElGSUVSLCAgICAgdGhlIE9JRCBvZiB0aGUgZW5jIGFsZ29yaXRobVxuICAgICAqICAgcGFyYW1ldGVycyAgICAgIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTCAoTlVMTCBmb3IgUEtDUyAjMSlcbiAgICAgKiB9XG4gICAgICogYW5kIFB1YmxpY0tleSBpcyBhIFNFUVVFTkNFIGVuY2Fwc3VsYXRlZCBpbiBhIEJJVCBTVFJJTkdcbiAgICAgKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIG1vZHVsdXMgICAgICAgICAgIElOVEVHRVIsICAtLSBuXG4gICAgICogICBwdWJsaWNFeHBvbmVudCAgICBJTlRFR0VSICAgLS0gZVxuICAgICAqIH1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBERVIgRW5jb2RlZCBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByc2EgcHVibGljIGtleVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQdWJsaWNCYXNlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlyc3Rfc2VxdWVuY2UgPSBuZXcgS0pVUi5hc24xLkRFUlNlcXVlbmNlKHtcbiAgICAgICAgICAgIGFycmF5OiBbXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyKHsgb2lkOiBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCIgfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJOdWxsKClcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZWNvbmRfc2VxdWVuY2UgPSBuZXcgS0pVUi5hc24xLkRFUlNlcXVlbmNlKHtcbiAgICAgICAgICAgIGFycmF5OiBbXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgYmlnaW50OiB0aGlzLm4gfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgaW50OiB0aGlzLmUgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBiaXRfc3RyaW5nID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoe1xuICAgICAgICAgICAgaGV4OiBcIjAwXCIgKyBzZWNvbmRfc2VxdWVuY2UuZ2V0RW5jb2RlZEhleCgpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2VxID0gbmV3IEtKVVIuYXNuMS5ERVJTZXF1ZW5jZSh7XG4gICAgICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgICAgIGZpcnN0X3NlcXVlbmNlLFxuICAgICAgICAgICAgICAgIGJpdF9zdHJpbmdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXEuZ2V0RW5jb2RlZEhleCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYmFzZTY0IChwZW0pIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgREVSIGVuY29kZWQgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiB3aXRob3V0IGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHVibGljQmFzZUtleUI2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhleDJiNjQodGhpcy5nZXRQdWJsaWNCYXNlS2V5KCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogd3JhcCB0aGUgc3RyaW5nIGluIGJsb2NrIG9mIHdpZHRoIGNoYXJzLiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgcnNhIGtleXMgaXMgNjRcbiAgICAgKiBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHBlbSBlbmNvZGVkIHN0cmluZyB3aXRob3V0IGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD02NF0gLSB0aGUgbGVuZ3RoIHRoZSBzdHJpbmcgaGFzIHRvIGJlIHdyYXBwZWQgYXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LndvcmR3cmFwID0gZnVuY3Rpb24gKHN0ciwgd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCA2NDtcbiAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZ2V4ID0gXCIoLnsxLFwiICsgd2lkdGggKyBcIn0pKCArfCRcXG4/KXwoLnsxLFwiICsgd2lkdGggKyBcIn0pXCI7XG4gICAgICAgIHJldHVybiBzdHIubWF0Y2goUmVnRXhwKHJlZ2V4LCBcImdcIikpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcGVtIGVuY29kZWQgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcGVtIGVuY29kZWQgcHJpdmF0ZSBrZXkgd2l0aCBoZWFkZXIvZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleSA9IFwiLS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLVxcblwiO1xuICAgICAgICBrZXkgKz0gSlNFbmNyeXB0UlNBS2V5LndvcmR3cmFwKHRoaXMuZ2V0UHJpdmF0ZUJhc2VLZXlCNjQoKSkgKyBcIlxcblwiO1xuICAgICAgICBrZXkgKz0gXCItLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLVwiO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHBlbSBlbmNvZGVkIHB1YmxpYyBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcGVtIGVuY29kZWQgcHVibGljIGtleSB3aXRoIGhlYWRlci9mb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXkgPSBcIi0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuXCI7XG4gICAgICAgIGtleSArPSBKU0VuY3J5cHRSU0FLZXkud29yZHdyYXAodGhpcy5nZXRQdWJsaWNCYXNlS2V5QjY0KCkpICsgXCJcXG5cIjtcbiAgICAgICAga2V5ICs9IFwiLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXCI7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcGFyYW1ldGVycyB0byBwb3B1bGF0ZSB0aGUgcnNhIG1vZHVsdXNcbiAgICAgKiBhbmQgcHVibGljIGV4cG9uZW50IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmo9e31dIC0gQW4gb2JqZWN0IHRoYXQgbWF5IGNvbnRhaW4gdGhlIHR3byBwdWJsaWMga2V5XG4gICAgICogcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYm90aCB0aGUgbW9kdWx1cyBhbmQgdGhlIHB1YmxpYyBleHBvbmVudFxuICAgICAqIHByb3BlcnRpZXMgKG4gYW5kIGUpXG4gICAgICogQHRvZG8gY2hlY2sgZm9yIHR5cGVzIG9mIG4gYW5kIGUuIE4gc2hvdWxkIGJlIGEgcGFyc2VhYmxlIGJpZ0ludCBvYmplY3QsIEUgc2hvdWxkXG4gICAgICogYmUgYSBwYXJzZWFibGUgaW50ZWdlciBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5oYXNQdWJsaWNLZXlQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgb2JqID0gb2JqIHx8IHt9O1xuICAgICAgICByZXR1cm4gKG9iai5oYXNPd25Qcm9wZXJ0eShcIm5cIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImVcIikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIG9iamVjdCBjb250YWlucyBBTEwgdGhlIHBhcmFtZXRlcnMgb2YgYW4gUlNBIGtleS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iaj17fV0gLSBBbiBvYmplY3QgdGhhdCBtYXkgY29udGFpbiBuaW5lIHJzYSBrZXlcbiAgICAgKiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBjb250YWlucyBhbGwgdGhlIHBhcmFtZXRlcnMgbmVlZGVkXG4gICAgICogQHRvZG8gY2hlY2sgZm9yIHR5cGVzIG9mIHRoZSBwYXJhbWV0ZXJzIGFsbCB0aGUgcGFyYW1ldGVycyBidXQgdGhlIHB1YmxpYyBleHBvbmVudFxuICAgICAqIHNob3VsZCBiZSBwYXJzZWFibGUgYmlnaW50IG9iamVjdHMsIHRoZSBwdWJsaWMgZXhwb25lbnQgc2hvdWxkIGJlIGEgcGFyc2VhYmxlIGludGVnZXIgbnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkuaGFzUHJpdmF0ZUtleVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBvYmogPSBvYmogfHwge307XG4gICAgICAgIHJldHVybiAob2JqLmhhc093blByb3BlcnR5KFwiblwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiZVwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiZFwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwicFwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwicVwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiZG1wMVwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiZG1xMVwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiY29lZmZcIikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIHByb3BlcnRpZXMgb2Ygb2JqIGluIHRoZSBjdXJyZW50IHJzYSBvYmplY3QuIE9iaiBzaG91bGQgQVQgTEVBU1RcbiAgICAgKiBpbmNsdWRlIHRoZSBtb2R1bHVzIGFuZCBwdWJsaWMgZXhwb25lbnQgKG4sIGUpIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgY29udGFpbmluZyByc2EgcGFyYW1ldGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5wYXJzZVByb3BlcnRpZXNGcm9tID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0aGlzLm4gPSBvYmoubjtcbiAgICAgICAgdGhpcy5lID0gb2JqLmU7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoXCJkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmQgPSBvYmouZDtcbiAgICAgICAgICAgIHRoaXMucCA9IG9iai5wO1xuICAgICAgICAgICAgdGhpcy5xID0gb2JqLnE7XG4gICAgICAgICAgICB0aGlzLmRtcDEgPSBvYmouZG1wMTtcbiAgICAgICAgICAgIHRoaXMuZG1xMSA9IG9iai5kbXExO1xuICAgICAgICAgICAgdGhpcy5jb2VmZiA9IG9iai5jb2VmZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEpTRW5jcnlwdFJTQUtleTtcbn0oUlNBS2V5KSk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucyA9IHt9XSAtIEFuIG9iamVjdCB0byBjdXN0b21pemUgSlNFbmNyeXB0IGJlaGF2aW91clxuICogcG9zc2libGUgcGFyYW1ldGVycyBhcmU6XG4gKiAtIGRlZmF1bHRfa2V5X3NpemUgICAgICAgIHtudW1iZXJ9ICBkZWZhdWx0OiAxMDI0IHRoZSBrZXkgc2l6ZSBpbiBiaXRcbiAqIC0gZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQge3N0cmluZ30gIGRlZmF1bHQ6ICcwMTAwMDEnIHRoZSBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGV4cG9uZW50XG4gKiAtIGxvZyAgICAgICAgICAgICAgICAgICAgIHtib29sZWFufSBkZWZhdWx0OiBmYWxzZSB3aGV0aGVyIGxvZyB3YXJuL2Vycm9yIG9yIG5vdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBKU0VuY3J5cHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNFbmNyeXB0KG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuZGVmYXVsdF9rZXlfc2l6ZSA9IHBhcnNlSW50KG9wdGlvbnMuZGVmYXVsdF9rZXlfc2l6ZSwgMTApIHx8IDEwMjQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQgPSBvcHRpb25zLmRlZmF1bHRfcHVibGljX2V4cG9uZW50IHx8IFwiMDEwMDAxXCI7IC8vIDY1NTM3IGRlZmF1bHQgb3BlbnNzbCBwdWJsaWMgZXhwb25lbnQgZm9yIHJzYSBrZXkgdHlwZVxuICAgICAgICB0aGlzLmxvZyA9IG9wdGlvbnMubG9nIHx8IGZhbHNlO1xuICAgICAgICAvLyBUaGUgcHJpdmF0ZSBhbmQgcHVibGljIGtleS5cbiAgICAgICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gc2V0IHRoZSByc2Ega2V5IHBhcmFtZXRlciAob25lIG1ldGhvZCBpcyBlbm91Z2ggdG8gc2V0IGJvdGggdGhlIHB1YmxpY1xuICAgICAqIGFuZCB0aGUgcHJpdmF0ZSBrZXksIHNpbmNlIHRoZSBwcml2YXRlIGtleSBjb250YWlucyB0aGUgcHVibGljIGtleSBwYXJhbWVudGVycylcbiAgICAgKiBMb2cgYSB3YXJuaW5nIGlmIGxvZ3MgYXJlIGVuYWJsZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleSB0aGUgcGVtIGVuY29kZWQgc3RyaW5nIG9yIGFuIG9iamVjdCAod2l0aCBvciB3aXRob3V0IGhlYWRlci9mb290ZXIpXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5sb2cgJiYgdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkEga2V5IHdhcyBhbHJlYWR5IHNldCwgb3ZlcnJpZGluZyBleGlzdGluZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXkgPSBuZXcgSlNFbmNyeXB0UlNBS2V5KGtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIHNldEtleSwgZm9yIGFwaSBjb21wYXRpYmlsaXR5XG4gICAgICogQHNlZSBzZXRLZXlcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5zZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKHByaXZrZXkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBrZXkuXG4gICAgICAgIHRoaXMuc2V0S2V5KHByaXZrZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBzZXRLZXksIGZvciBhcGkgY29tcGF0aWJpbGl0eVxuICAgICAqIEBzZWUgc2V0S2V5XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuc2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKHB1YmtleSkge1xuICAgICAgICAvLyBTZXRzIHRoZSBwdWJsaWMga2V5LlxuICAgICAgICB0aGlzLnNldEtleShwdWJrZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3MgZGVjcnlwdCwgZGVjcnlwdCB0aGUgc3RyaW5nIHVzaW5nIHRoZSBwcml2YXRlXG4gICAgICogY29tcG9uZW50cyBvZiB0aGUgcnNhIGtleSBvYmplY3QuIE5vdGUgdGhhdCBpZiB0aGUgb2JqZWN0IHdhcyBub3Qgc2V0IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIG9uIHRoZSBmbHkgKGJ5IHRoZSBnZXRLZXkgbWV0aG9kKSB1c2luZyB0aGUgcGFyYW1ldGVycyBwYXNzZWQgaW4gdGhlIEpTRW5jcnlwdCBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgYmFzZTY0IGVuY29kZWQgY3J5cHRlZCBzdHJpbmcgdG8gZGVjcnlwdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRlY3J5cHRlZCBzdHJpbmdcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGRlY3J5cHRlZCBzdHJpbmcuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS5kZWNyeXB0KGI2NHRvaGV4KHN0cikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIFJTQUtleSBvYmplY3QncyBlbmNyeXB0LCBlbmNyeXB0IHRoZSBzdHJpbmcgdXNpbmcgdGhlIHB1YmxpY1xuICAgICAqIGNvbXBvbmVudHMgb2YgdGhlIHJzYSBrZXkgb2JqZWN0LiBOb3RlIHRoYXQgaWYgdGhlIG9iamVjdCB3YXMgbm90IHNldCB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBvbiB0aGUgZmx5IChieSB0aGUgZ2V0S2V5IG1ldGhvZCkgdXNpbmcgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIGluIHRoZSBKU0VuY3J5cHQgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gZW5jcnlwdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVuY3J5cHRlZCBzdHJpbmcgZW5jb2RlZCBpbiBiYXNlNjRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGVuY3J5cHRlZCBzdHJpbmcuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4MmI2NCh0aGlzLmdldEtleSgpLmVuY3J5cHQoc3RyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3h5IG1ldGhvZCBmb3IgUlNBS2V5IG9iamVjdCdzIHNpZ24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHNpZ25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaWdlc3RNZXRob2QgaGFzaCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlnZXN0TmFtZSB0aGUgbmFtZSBvZiB0aGUgaGFzaCBhbGdvcml0aG1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBzaWduYXR1cmUgZW5jb2RlZCBpbiBiYXNlNjRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKHN0ciwgZGlnZXN0TWV0aG9kLCBkaWdlc3ROYW1lKSB7XG4gICAgICAgIC8vIHJldHVybiB0aGUgUlNBIHNpZ25hdHVyZSBvZiAnc3RyJyBpbiAnaGV4JyBmb3JtYXQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4MmI2NCh0aGlzLmdldEtleSgpLnNpZ24oc3RyLCBkaWdlc3RNZXRob2QsIGRpZ2VzdE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3MgdmVyaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB2ZXJpZnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgZW5jb2RlZCBpbiBiYXNlNjQgdG8gY29tcGFyZSB0aGUgc3RyaW5nIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlnZXN0TWV0aG9kIGhhc2ggbWV0aG9kXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZGF0YSBhbmQgc2lnbmF0dXJlIG1hdGNoXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKHN0ciwgc2lnbmF0dXJlLCBkaWdlc3RNZXRob2QpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBkZWNyeXB0ZWQgJ2RpZ2VzdCcgb2YgdGhlIHNpZ25hdHVyZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLnZlcmlmeShzdHIsIGI2NHRvaGV4KHNpZ25hdHVyZSksIGRpZ2VzdE1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHRlciBmb3IgdGhlIGN1cnJlbnQgSlNFbmNyeXB0UlNBS2V5IG9iamVjdC4gSWYgaXQgZG9lc24ndCBleGlzdHMgYSBuZXcgb2JqZWN0XG4gICAgICogd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZFxuICAgICAqIEBwYXJhbSB7Y2FsbGJhY2t9IFtjYl0gdGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBpZiB3ZSB3YW50IHRoZSBrZXkgdG8gYmUgZ2VuZXJhdGVkXG4gICAgICogaW4gYW4gYXN5bmMgZmFzaGlvblxuICAgICAqIEByZXR1cm5zIHtKU0VuY3J5cHRSU0FLZXl9IHRoZSBKU0VuY3J5cHRSU0FLZXkgb2JqZWN0XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIG5ldyBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgICAgICAgLy8gR2V0IGEgbmV3IHByaXZhdGUga2V5LlxuICAgICAgICAgICAgdGhpcy5rZXkgPSBuZXcgSlNFbmNyeXB0UlNBS2V5KCk7XG4gICAgICAgICAgICBpZiAoY2IgJiYge30udG9TdHJpbmcuY2FsbChjYikgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIikge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5LmdlbmVyYXRlQXN5bmModGhpcy5kZWZhdWx0X2tleV9zaXplLCB0aGlzLmRlZmF1bHRfcHVibGljX2V4cG9uZW50LCBjYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGtleS5cbiAgICAgICAgICAgIHRoaXMua2V5LmdlbmVyYXRlKHRoaXMuZGVmYXVsdF9rZXlfc2l6ZSwgdGhpcy5kZWZhdWx0X3B1YmxpY19leHBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5XG4gICAgICogSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0cyBhIG5ldyBrZXkgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5IFdJVEggaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmdldFByaXZhdGVLZXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleVxuICAgICAqIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdHMgYSBuZXcga2V5IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleSBXSVRIT1VUIGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleUI2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwcml2YXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMga2V5LlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS5nZXRQcml2YXRlQmFzZUtleUI2NCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICAgKiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IGtleSB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBXSVRIIGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmdldFB1YmxpY0tleSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICAgKiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IGtleSB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBXSVRIT1VUIGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0UHVibGljS2V5QjY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmdldFB1YmxpY0Jhc2VLZXlCNjQoKTtcbiAgICB9O1xuICAgIEpTRW5jcnlwdC52ZXJzaW9uID0gXCIzLjAuMC1yYy4xXCI7XG4gICAgcmV0dXJuIEpTRW5jcnlwdDtcbn0oKSk7XG5cbndpbmRvdy5KU0VuY3J5cHQgPSBKU0VuY3J5cHQ7XG5cbmV4cG9ydHMuSlNFbmNyeXB0ID0gSlNFbmNyeXB0O1xuZXhwb3J0cy5kZWZhdWx0ID0gSlNFbmNyeXB0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcblxuLy8gVGhpcyB3aWxsIGJlIGEgcHJvcGVyIGl0ZXJhYmxlICdNYXAnIGluIGVuZ2luZXMgdGhhdCBzdXBwb3J0IGl0LFxuLy8gb3IgYSBmYWtleS1mYWtlIFBzZXVkb01hcCBpbiBvbGRlciB2ZXJzaW9ucy5cbnZhciBNYXAgPSByZXF1aXJlKCdwc2V1ZG9tYXAnKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xudmFyIFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcblxuLy8gdXNlIHN5bWJvbHMgaWYgcG9zc2libGUsIG90aGVyd2lzZSBqdXN0IF9wcm9wc1xudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvY2Vzcy5lbnYuX25vZGVMUlVDYWNoZUZvcmNlTm9TeW1ib2wgIT09ICcxJ1xudmFyIG1ha2VTeW1ib2xcbmlmIChoYXNTeW1ib2wpIHtcbiAgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gU3ltYm9sKGtleSlcbiAgfVxufSBlbHNlIHtcbiAgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gJ18nICsga2V5XG4gIH1cbn1cblxudmFyIE1BWCA9IG1ha2VTeW1ib2woJ21heCcpXG52YXIgTEVOR1RIID0gbWFrZVN5bWJvbCgnbGVuZ3RoJylcbnZhciBMRU5HVEhfQ0FMQ1VMQVRPUiA9IG1ha2VTeW1ib2woJ2xlbmd0aENhbGN1bGF0b3InKVxudmFyIEFMTE9XX1NUQUxFID0gbWFrZVN5bWJvbCgnYWxsb3dTdGFsZScpXG52YXIgTUFYX0FHRSA9IG1ha2VTeW1ib2woJ21heEFnZScpXG52YXIgRElTUE9TRSA9IG1ha2VTeW1ib2woJ2Rpc3Bvc2UnKVxudmFyIE5PX0RJU1BPU0VfT05fU0VUID0gbWFrZVN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKVxudmFyIExSVV9MSVNUID0gbWFrZVN5bWJvbCgnbHJ1TGlzdCcpXG52YXIgQ0FDSEUgPSBtYWtlU3ltYm9sKCdjYWNoZScpXG5cbmZ1bmN0aW9uIG5haXZlTGVuZ3RoICgpIHsgcmV0dXJuIDEgfVxuXG4vLyBscnVMaXN0IGlzIGEgeWFsbGlzdCB3aGVyZSB0aGUgaGVhZCBpcyB0aGUgeW91bmdlc3Rcbi8vIGl0ZW0sIGFuZCB0aGUgdGFpbCBpcyB0aGUgb2xkZXN0LiAgdGhlIGxpc3QgY29udGFpbnMgdGhlIEhpdFxuLy8gb2JqZWN0cyBhcyB0aGUgZW50cmllcy5cbi8vIEVhY2ggSGl0IG9iamVjdCBoYXMgYSByZWZlcmVuY2UgdG8gaXRzIFlhbGxpc3QuTm9kZS4gIFRoaXNcbi8vIG5ldmVyIGNoYW5nZXMuXG4vL1xuLy8gY2FjaGUgaXMgYSBNYXAgKG9yIFBzZXVkb01hcCkgdGhhdCBtYXRjaGVzIHRoZSBrZXlzIHRvXG4vLyB0aGUgWWFsbGlzdC5Ob2RlIG9iamVjdC5cbmZ1bmN0aW9uIExSVUNhY2hlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMUlVDYWNoZSkpIHtcbiAgICByZXR1cm4gbmV3IExSVUNhY2hlKG9wdGlvbnMpXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdmFyIG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4XG4gIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgaWYgKCFtYXggfHxcbiAgICAgICEodHlwZW9mIG1heCA9PT0gJ251bWJlcicpIHx8XG4gICAgICBtYXggPD0gMCkge1xuICAgIHRoaXNbTUFYXSA9IEluZmluaXR5XG4gIH1cblxuICB2YXIgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICBpZiAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgbGMgPSBuYWl2ZUxlbmd0aFxuICB9XG4gIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbGNcblxuICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDBcbiAgdGhpc1tESVNQT1NFXSA9IG9wdGlvbnMuZGlzcG9zZVxuICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgdGhpcy5yZXNldCgpXG59XG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbWF4Jywge1xuICBzZXQ6IGZ1bmN0aW9uIChtTCkge1xuICAgIGlmICghbUwgfHwgISh0eXBlb2YgbUwgPT09ICdudW1iZXInKSB8fCBtTCA8PSAwKSB7XG4gICAgICBtTCA9IEluZmluaXR5XG4gICAgfVxuICAgIHRoaXNbTUFYXSA9IG1MXG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdhbGxvd1N0YWxlJywge1xuICBzZXQ6IGZ1bmN0aW9uIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdtYXhBZ2UnLCB7XG4gIHNldDogZnVuY3Rpb24gKG1BKSB7XG4gICAgaWYgKCFtQSB8fCAhKHR5cGVvZiBtQSA9PT0gJ251bWJlcicpIHx8IG1BIDwgMCkge1xuICAgICAgbUEgPSAwXG4gICAgfVxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYX0FHRV1cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbGVuZ3RoQ2FsY3VsYXRvcicsIHtcbiAgc2V0OiBmdW5jdGlvbiAobEMpIHtcbiAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG4gICAgfVxuICAgIGlmIChsQyAhPT0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0pIHtcbiAgICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbENcbiAgICAgIHRoaXNbTEVOR1RIXSA9IDBcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgICBoaXQubGVuZ3RoID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0oaGl0LnZhbHVlLCBoaXQua2V5KVxuICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdpdGVtQ291bnQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbkxSVUNhY2hlLnByb3RvdHlwZS5yZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICB2YXIgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgd2Fsa2VyID0gcHJldlxuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdGVwIChzZWxmLCBmbiwgbm9kZSwgdGhpc3ApIHtcbiAgdmFyIGhpdCA9IG5vZGUudmFsdWVcbiAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgIGRlbChzZWxmLCBub2RlKVxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pIHtcbiAgICAgIGhpdCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuICBpZiAoaGl0KSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKVxuICB9XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHZhciBuZXh0ID0gd2Fsa2VyLm5leHRcbiAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICB3YWxrZXIgPSBuZXh0XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsua2V5XG4gIH0sIHRoaXMpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsudmFsdWVcbiAgfSwgdGhpcylcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpc1tESVNQT1NFXSAmJlxuICAgICAgdGhpc1tMUlVfTElTVF0gJiZcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gIHRoaXNbTEVOR1RIXSA9IDAgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGZ1bmN0aW9uIChoaXQpIHtcbiAgICBpZiAoIWlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpLnRvQXJyYXkoKS5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICByZXR1cm4gaFxuICB9KVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcExydSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5MUlVDYWNoZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIChuLCBvcHRzKSB7XG4gIHZhciBzdHIgPSAnTFJVQ2FjaGUgeydcbiAgdmFyIGV4dHJhcyA9IGZhbHNlXG5cbiAgdmFyIGFzID0gdGhpc1tBTExPV19TVEFMRV1cbiAgaWYgKGFzKSB7XG4gICAgc3RyICs9ICdcXG4gIGFsbG93U3RhbGU6IHRydWUnXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIG1heCA9IHRoaXNbTUFYXVxuICBpZiAobWF4ICYmIG1heCAhPT0gSW5maW5pdHkpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBtYXg6ICcgKyB1dGlsLmluc3BlY3QobWF4LCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBtYXhBZ2UgPSB0aGlzW01BWF9BR0VdXG4gIGlmIChtYXhBZ2UpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBtYXhBZ2U6ICcgKyB1dGlsLmluc3BlY3QobWF4QWdlLCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBsYyA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdXG4gIGlmIChsYyAmJiBsYyAhPT0gbmFpdmVMZW5ndGgpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBsZW5ndGg6ICcgKyB1dGlsLmluc3BlY3QodGhpc1tMRU5HVEhdLCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBkaWRGaXJzdCA9IGZhbHNlXG4gIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoZGlkRmlyc3QpIHtcbiAgICAgIHN0ciArPSAnLFxcbiAgJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXh0cmFzKSB7XG4gICAgICAgIHN0ciArPSAnLFxcbidcbiAgICAgIH1cbiAgICAgIGRpZEZpcnN0ID0gdHJ1ZVxuICAgICAgc3RyICs9ICdcXG4gICdcbiAgICB9XG4gICAgdmFyIGtleSA9IHV0aWwuaW5zcGVjdChpdGVtLmtleSkuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgJylcbiAgICB2YXIgdmFsID0geyB2YWx1ZTogaXRlbS52YWx1ZSB9XG4gICAgaWYgKGl0ZW0ubWF4QWdlICE9PSBtYXhBZ2UpIHtcbiAgICAgIHZhbC5tYXhBZ2UgPSBpdGVtLm1heEFnZVxuICAgIH1cbiAgICBpZiAobGMgIT09IG5haXZlTGVuZ3RoKSB7XG4gICAgICB2YWwubGVuZ3RoID0gaXRlbS5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGlzU3RhbGUodGhpcywgaXRlbSkpIHtcbiAgICAgIHZhbC5zdGFsZSA9IHRydWVcbiAgICB9XG5cbiAgICB2YWwgPSB1dGlsLmluc3BlY3QodmFsLCBvcHRzKS5zcGxpdCgnXFxuJykuam9pbignXFxuICAnKVxuICAgIHN0ciArPSBrZXkgKyAnID0+ICcgKyB2YWxcbiAgfSlcblxuICBpZiAoZGlkRmlyc3QgfHwgZXh0cmFzKSB7XG4gICAgc3RyICs9ICdcXG4nXG4gIH1cbiAgc3RyICs9ICd9J1xuXG4gIHJldHVybiBzdHJcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICB2YXIgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgdmFyIGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KVxuICAgIHZhciBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAvLyBzcGxpdCBvdXQgaW50byAyIGlmcyBmb3IgYmV0dGVyIGNvdmVyYWdlIHRyYWNraW5nXG4gICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pIHtcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaXRlbS5ub3cgPSBub3dcbiAgICBpdGVtLm1heEFnZSA9IG1heEFnZVxuICAgIGl0ZW0udmFsdWUgPSB2YWx1ZVxuICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgIGl0ZW0ubGVuZ3RoID0gbGVuXG4gICAgdGhpcy5nZXQoa2V5KVxuICAgIHRyaW0odGhpcylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdmFyIGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdClcbiAgdGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZClcbiAgdHJpbSh0aGlzKVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2VcbiAgdmFyIGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gIGlmIChpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gIGlmICghbm9kZSkgcmV0dXJuIG51bGxcbiAgZGVsKHRoaXMsIG5vZGUpXG4gIHJldHVybiBub2RlLnZhbHVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIC8vIHJlc2V0IHRoZSBjYWNoZVxuICB0aGlzLnJlc2V0KClcblxuICB2YXIgbm93ID0gRGF0ZS5ub3coKVxuICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICBmb3IgKHZhciBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgdmFyIGhpdCA9IGFycltsXVxuICAgIHZhciBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgaWYgKGV4cGlyZXNBdCA9PT0gMCkge1xuICAgICAgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgLy8gZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBydW5lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpc1tDQUNIRV0uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGdldChzZWxmLCBrZXksIGZhbHNlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXQgKHNlbGYsIGtleSwgZG9Vc2UpIHtcbiAgdmFyIG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KVxuICBpZiAobm9kZSkge1xuICAgIHZhciBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoaXQpIGhpdCA9IGhpdC52YWx1ZVxuICB9XG4gIHJldHVybiBoaXRcbn1cblxuZnVuY3Rpb24gaXNTdGFsZSAoc2VsZiwgaGl0KSB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZltNQVhfQUdFXSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgc3RhbGUgPSBmYWxzZVxuICB2YXIgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIGlmIChoaXQubWF4QWdlKSB7XG4gICAgc3RhbGUgPSBkaWZmID4gaGl0Lm1heEFnZVxuICB9IGVsc2Uge1xuICAgIHN0YWxlID0gc2VsZltNQVhfQUdFXSAmJiAoZGlmZiA+IHNlbGZbTUFYX0FHRV0pXG4gIH1cbiAgcmV0dXJuIHN0YWxlXG59XG5cbmZ1bmN0aW9uIHRyaW0gKHNlbGYpIHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAodmFyIHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7XG4gICAgICBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICB2YXIgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBkZWwoc2VsZiwgd2Fsa2VyKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWwgKHNlbGYsIG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChzZWxmW0RJU1BPU0VdKSB7XG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcbiAgICB9XG4gICAgc2VsZltMRU5HVEhdIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSlcbiAgICBzZWxmW0xSVV9MSVNUXS5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cbn1cblxuLy8gY2xhc3N5LCBzaW5jZSBWOCBwcmVmZXJzIHByZWRpY3RhYmxlIG9iamVjdHMuXG5mdW5jdGlvbiBFbnRyeSAoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICB0aGlzLmtleSA9IGtleVxuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5ub3cgPSBub3dcbiAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIFByb21pc2VXaW5kb3dcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWVyY2llci9wcm9taXNlLXdpbmRvd1xuICogQGlnbm9yZVxuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgcm9vdCA9IHdpbmRvdyxcbiAgICAgIHByb3RvdHlwZSxcbiAgICAgIGh0bWwgPSByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAvKipcbiAgICogTWVyZ2UgdGhlIGNvbnRlbnRzIG9mIHR3byBvciBtb3JlIG9iamVjdHMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuICAgKlxuICAgKiAgICAgbWVyZ2UoIHRhcmdldCBbLCBvYmplY3QxIF0gWywgb2JqZWN0TiBdIClcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgQW4gb2JqZWN0IHRoYXQgd2lsbCByZWNlaXZlIHRoZSBuZXcgcHJvcGVydGllcyBpZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsIG9iamVjdHMgYXJlIHBhc3NlZCBpbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdDEgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIG1lcmdlIGluLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0TiBBbiBvYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gbWVyZ2UgaW4uXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgZmlyc3Qgb2JqZWN0LlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIGV4dGVuZGVkID0gYXJndW1lbnRzWzBdLCBrZXksIGk7XG4gICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChrZXkgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbaV0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGV4dGVuZGVkW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcHNldWRvLXVuaXF1ZSBTdHJpbmdcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIHBzZXVkby11bmlxdWUgc3RyaW5nIHByZWZpeGVkIHdpdGggdGhlIGdpdmVuIHByZWZpeCwgaWYgYW55LlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZVN0cmluZyhwcmVmaXgpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBcIi1cIiArIE1hdGguZmxvb3IoMTBlMTIgKiBNYXRoLnJhbmRvbSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUHJvbWlzZVdpbmRvdyBvYmplY3RcbiAgICpcbiAgICogRHVyaW5nIHRoZSBsaWZlY3ljbGUgb2YgdGhpcyBvYmplY3QsIHBvcHVwIHdpbmRvd3MgY2FuIGJlIG9wZW5lZCwgY2xvc2VkLFxuICAgKiBhbmQgcmVvcGVuZWQgYWdhaW4uIEhvd2V2ZXIsIGl0J1xuICAgKlxuICAgKiBJbnN0YW5jaWF0aW5nIHRoaXMgcHJvdG90eXBlIGRvZXMgbm90IGltbWVkaWF0ZWx5IG9wZW5zIGEgbmV3IHBvcHVwIHdpbmRvdy5cbiAgICogVG8gb3BlbiB0aGUgd2luZG93LCB1c2UgYG9wZW4oKWAgb24gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gICB1cmkgICAgICAgICAgICAgICAgICAgIERlc3RpbmF0aW9uIFVSSVxuICAgKiBAcGFyYW0ge09iamVjdH0gICBjb25maWcgICAgICAgICAgICAgICAgIENvbmZpZ3VyYXRpb24gb2JqZWN0LiBTZWUgZGVzY3JpcHRpb24gYmVsb3cuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgIGNvbmZpZy53aWR0aCAgICAgICAgICAgV2lkdGggb2YgdGhlIHBvcHVwIHdpbmRvdy4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgIGNvbmZpZy5oZWlnaHQgICAgICAgICAgSGVpZ2h0IG9mIHRoZSBwb3B1cCB3aW5kb3cuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50IGhlaWdodC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLnByb21pc2VQcm92aWRlciBQcm9taXNlIHByb3ZpZGVyLiBTaG91bGQgcmV0dXJuIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgMyBmaWVsZHM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgcHJvbWlzZWAge1Byb21pc2V9ICBhIG5ldyBQcm9taXNlIG9iamVjdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYHJlc29sdmVgIHtGdW5jdGlvbn0gdGhlIG1ldGhvZCB0byByZXNvbHZlIHRoZSBnaXZlbiBQcm9taXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgcmVqZWN0YCAge0Z1bmN0aW9ufSB0aGUgbWV0aG9kIHRvIHJlamVjdCB0aGUgZ2l2ZW4gUHJvbWlzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcub25Qb3N0TWVzc2FnZSAgIEhhbmRsZXIgZm9yIHJlY2VpdmluZyBhIHBvc3RNZXNzYWdlIGZyb20gdGhlIG9wZW5lZCB3aW5kb3cuIERlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiByZXNvbHZlcyB0aGUgcHJvbWlzZSB3aXRoIHRoZSBkYXRhIHBhc3NlZCBpbiB0aGUgcG9zdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsIGV4Y2VwdCBpZiB0aGlzIGRhdGEgY29udGFpbnMgYW4gYGVycm9yYCBmaWVsZC4gSW4gdGhpcyBjYXNlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0IHJlamVjdHMgdGhlIFByb21pc2Ugd2l0aCB0aGUgdmFsdWUgb2YgdGhhdCBmaWVsZC4gSW4gYWxsIGNhc2VzLCBjbG9zZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcG9wdXAgd2luZG93LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcub25Qb3N0TWVzc2FnZS5ldmVudCBFdmVudCBUaGUgcG9zdE1lc3NhZ2UgZXZlbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICAgY29uZmlnLndhdGNoZXJEZWxheSAgICBUaGVyZSBpcyBubyBwcm9ncmFtbWF0aWMgd2F5IG9mIGtub3dpbmcgd2hlbiBhIHBvcHVwIHdpbmRvdyBpcyBjbG9zZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZWl0aGVyIG1hbnVhbGx5IG9yIHByb2dyYW1hdGljYWxseSkuIEZvciB0aGlzIHJlYXNvbiwgZXZlcnkgdGltZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2VXaW5kb3cgb3BlbnMgYSBwb3B1cCwgYSBuZXcgd2F0Y2hlciBpcyBjcmVhdGVkLiBUaGUgd2F0Y2hlciBjaGVja3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWd1bGFybHkgaWYgdGhlIHdpbmRvdyBpcyBzdGlsbCBvcGVuLiBUaGlzIHZhbHVlIGRlZmluZXMgYXQgd2hpY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCB0aGlzIGNoZWNrIGlzIGRvbmUuIERlZmF1bHRzIHRvIDEwMG1zLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gICBjb25maWcud2luZG93TmFtZSAgICAgIE5hbWUgdG8gYmUgZ2ludmVuIHRvIHRoZSBwb3B1cCB3aW5kb3cuIFNlZSBgd2luZG93Lm9wZW5gIHJlZmVyZW5jZXMgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscy4gSWYgYG51bGxgLCBhIHJhbmRvbSBuYW1lIGlzIGdlbmVyYXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9ICAgY29uZmlnLndpbmRvdyAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB3aW5kb3cgY29uZmlndXJhdGlvbiBzZXR0aW5ncy4gU2Nyb2xsYmFycyBhcmUgZW5hYmxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IGRlZmF1bHQuIEFsbCBgd2luZG93Lm9wZW5gIHB0aW9ucyBhcmUgYWNjZXB0ZWQsIGJ1dCBwbGVhc2Ugbm90ZSB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFueSBvZiB0aGVtIGhhdmUgbm8gZWZmZWN0IGluIG1vc3QgbW9kZXJuIGJyb3dzZXJzLiBTZWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L29wZW4gZm9yIG1vcmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcub25DbG9zZSAgICAgICAgIEZ1bmN0aW9uIGJlaW5nIGNhbGxlZCB3aGVuZXZlciB0aGUgcG9wdXAgaXMgYmVpbmcgY2xvc2VkIChlaXRoZXIgYWZ0ZXIgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3QgbWVzc2FnZSBoYXMgYmVlbiByZWNlaXZlZCwgb3Igd2luZG93IGhhcyBiZWVuIGNsb3NlZCBieSB1c2VyLCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAuY2xvc2UoKWAgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZC4gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjbG9zZXMgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXAgd2luZG93IGJ5IGNhbGxpbmcgYHRoaXMuX3dpbmRvdy5jbG9zZSgpYCkuXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBjb25maWcub3JpZ2luUmVnZXhwICAgICAgUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyB0aGUgb3JpZ2luIHBhcnQgb2YgYW4gVVJJLiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBuZXcgUmVnRXhwKCdeW146Lz9dKzovL1teL10qJylgLiBJZiBkb2Vzbid0IG1hdGNoIChleDogcmVsYXRpdmUgVVJJcyksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlIGBsb2NhdGlvbi5vcmlnaW5gLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFByb21pc2VXaW5kb3codXJpLCBjb25maWcpIHtcbiAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICB0aGlzLmNvbmZpZyA9IGV4dGVuZCh7fSwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0Q29uZmlnLCBjb25maWcpO1xuICAgIHRoaXMuY29uZmlnLndpbmRvd05hbWUgPSB0aGlzLmNvbmZpZy53aW5kb3dOYW1lIHx8IGdlbmVyYXRlVW5pcXVlU3RyaW5nKCdwcm9taXNlLXdpbmRvdy0nKTtcbiAgICB0aGlzLl9vblBvc3RNZXNzYWdlID0gdGhpcy5fb25Qb3N0TWVzc2FnZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFByb21pc2UgcHJvdmlkZXIgZnJvbSBhIFByb21pc2UvQSsgY29uc3RydWN0b3IgdG8gYmUgdXNlZCB3aXRoXG4gICAqIGBjb25maWcucHJvbWlzZVByb3ZpZGVyYC5cbiAgICpcbiAgICogICAgIG5ldyBQcm9taXNlV2luZG93KC4uLiwge1xuICAgKiAgICAgICAuLi4sXG4gICAqICAgICAgIHByb21pc2VQcm92aWRlcjogUHJvbWlzZVdpbmRvdy5nZXRBUGx1c1Byb21pc2VQcm92aWRlcihNeUN1c3RvbVByb21pc2UpXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IEN1c3RvbVByb21pc2UgUHJvbWlzZS9BKyBjb250cnVjdG9yXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIGEgcHJvbWlzZSBwcm92aWRlclxuICAgKiBAc3RhdGljXG4gICAqL1xuICBQcm9taXNlV2luZG93LmdldEFQbHVzUHJvbWlzZVByb3ZpZGVyID0gZnVuY3Rpb24gZ2V0QVBsdXNQcm9taXNlUHJvdmlkZXIoQ3VzdG9tUHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBwcm9taXNlUHJvdmlkZXIoKSB7XG4gICAgICB2YXIgbW9kdWxlID0ge307XG4gICAgICBtb2R1bGUucHJvbWlzZSA9IG5ldyBDdXN0b21Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBtb2R1bGUucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIG1vZHVsZS5yZWplY3QgPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvcjpcbiAgICpcbiAgICogICAgIG5ldyBQcm9taXNlV2luZG93KHVyaSwgY29uZmlnKS5vcGVuKClcbiAgICpcbiAgICogVXNlIHRoaXMgbWV0aG9kIG9ubHkgaWYgeW91IG5ldmVyIG5lZWQgdG8gY2xvc2UgdGhlIHdpbmRvdyBwcm9ncmFtYXRpY2FsbHkuXG4gICAqIElmIHlvdSBkbywgcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBjbGFzc2ljIHdheTpcbiAgICpcbiAgICogICAgIHZhciB3ID0gbmV3IFByb21pc2VXaW5kb3codXJpLCBjb25maWcpXG4gICAqICAgICB3Lm9wZW4oKTtcbiAgICogICAgIC8vIC4uLlxuICAgKiAgICAgdy5jbG9zZSgpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgUHJvbWlzZSBlcXVpdmFsZW50IHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkgYG9wZW4oKWBcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgUHJvbWlzZVdpbmRvdy5vcGVuID0gZnVuY3Rpb24gb3Blbih1cmksIGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVdpbmRvdyh1cmksIGNvbmZpZykub3BlbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIFByb21pc2VXaW5kb3cuZGVmYXVsdENvbmZpZyA9IHtcbiAgICB3aWR0aDogaHRtbC5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGh0bWwuY2xpZW50SGVpZ2h0LFxuICAgIHdpbmRvdzoge1xuICAgICAgc2Nyb2xsYmFyczogdHJ1ZVxuICAgIH0sXG4gICAgd2F0Y2hlckRlbGF5OiAxMDAsXG4gICAgcHJvbWlzZVByb3ZpZGVyOiBudWxsLFxuICAgIG9uUG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIG9uUG9zdE1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhLmVycm9yKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChldmVudC5kYXRhLmVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoZXZlbnQuZGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSxcbiAgICB3aW5kb3dOYW1lOiBudWxsLFxuICAgIG9uQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fd2luZG93LmNsb3NlKCk7XG4gICAgfSxcbiAgICBvcmlnaW5SZWdleHA6IG5ldyBSZWdFeHAoJ15bXjovP10rOi8vW14vXSonKVxuICB9O1xuXG4gIC8vIENvbmZpZ3VyZSBkZWZhdWx0IFByb21pc2UgcHJvdmlkZXIgZnJvbSBjdXJyZW50IGludmlyb25tZW50XG4gIGlmIChyb290LlByb21pc2UpIHtcbiAgICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcucHJvbWlzZVByb3ZpZGVyID0gUHJvbWlzZVdpbmRvdy5nZXRBUGx1c1Byb21pc2VQcm92aWRlcihyb290LlByb21pc2UpO1xuICB9XG4gIGVsc2UgaWYgKHJvb3QuUlNWUCkge1xuICAgIFByb21pc2VXaW5kb3cuZGVmYXVsdENvbmZpZy5wcm9taXNlUHJvdmlkZXIgPSBQcm9taXNlV2luZG93LmdldEFQbHVzUHJvbWlzZVByb3ZpZGVyKHJvb3QuUlNWUC5Qcm9taXNlKTtcbiAgfVxuICBlbHNlIGlmIChyb290LlEpIHtcbiAgICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcucHJvbWlzZVByb3ZpZGVyID0gUHJvbWlzZVdpbmRvdy5nZXRBUGx1c1Byb21pc2VQcm92aWRlcihyb290LlEuUHJvbWlzZSk7XG4gIH1cbiAgZWxzZSBpZiAocm9vdC5qUXVlcnkpIHtcbiAgICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcucHJvbWlzZVByb3ZpZGVyID0gZnVuY3Rpb24gcHJvbWlzZVByb3ZpZGVyKCkge1xuICAgICAgdmFyIGRlZmVycmVkID0gcm9vdC5qUXVlcnkuRGVmZXJyZWQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IGRlZmVycmVkLnByb21pc2UoKSxcbiAgICAgICAgcmVzb2x2ZTogZGVmZXJyZWQucmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBkZWZlcnJlZC5yZWplY3RcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcucHJvbWlzZVByb3ZpZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJvbWlzZVByb3ZpZGVyIGluIFByb21pc2VXaW5kb3cgY29uZmlndXJhdGlvbicpO1xuICAgIH07XG4gIH1cblxuICBwcm90b3R5cGUgPSBQcm9taXNlV2luZG93LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIGJvb2xlYW5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHZhbHVlIGlzIGEgYm9vbGVhbiwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9pc0Jvb2xlYW4gPSBmdW5jdGlvbiBfaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgYSBjb25maWcgdmFsdWUgaW50byBhIHZhbHVlIGNvbXBhdGlibGUgd2l0aCBgd2luZG93Lm9wZW5gLlxuICAgKiBJZiB2YWx1ZSBpcyBhIGJvb2xlYW4sIGNvbnZlcnQgaXQgdG8gJ3llcycgb3IgJ25vJywgb3RoZXJ3aXNlIHNpbXBseVxuICAgKiBjYXN0cyBpdCBpbnRvIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbnZlcnRlZCB2YWx1ZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX3NlcmlhbGl6ZUZlYXR1cmVWYWx1ZSA9IGZ1bmN0aW9uIF9zZXJpYWxpemVGZWF0dXJlVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyAneWVzJyA6ICdubyc7XG4gICAgfVxuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxlZnQgYW5kIHRvcCBwb3NpdGlvbiBpbiB0aGUgc2NyZWVuIGZvciBhIHJlY3RhbmdsZSwgdGFraW5nXG4gICAqIGR1YWwtc2NyZWVuIHBvc2l0aW9uIGludG8gYWNjb3VudFxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEByZXR1cm4ge09iamVjdH0gcG9zaXRpb24gQSBuZXcgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZSwgY2VudGVyZWRcbiAgICogQHJldHVybiB7TnVtYmVyfSBwb3NpdGlvbi5sZWZ0IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlcmVkIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBvc2l0aW9uLnRvcCBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXJlZCByZWN0YW5nbGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBwb3NpdGlvbi53aWR0aCBUaGUgd2lkdGggb2YgdGhlIGNlbnRlcmVkIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBvc2l0aW9uLmhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBjZW50ZXJlZCByZWN0YW5nbGVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9nZXRDZW50ZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gX2dldENlbnRlcmVkUG9zaXRpb24od2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBkdWFsU2NyZWVuTGVmdCA9IHJvb3Quc2NyZWVuTGVmdCAhPT0gdW5kZWZpbmVkID8gcm9vdC5zY3JlZW5MZWZ0IDogc2NyZWVuLmxlZnQsXG4gICAgICAgIGR1YWxTY3JlZW5Ub3AgPSByb290LnNjcmVlblRvcCAhPT0gdW5kZWZpbmVkID8gcm9vdC5zY3JlZW5Ub3AgOiBzY3JlZW4udG9wLFxuICAgICAgICB3ID0gcm9vdC5pbm5lcldpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGggfHwgc2NyZWVuLndpZHRoLFxuICAgICAgICBoID0gcm9vdC5pbm5lckhlaWdodCB8fCBodG1sLmNsaWVudEhlaWdodCB8fCBzY3JlZW4uaGVpZ2h0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6ICh3IC8gMikgLSAod2lkdGggLyAyKSArIGR1YWxTY3JlZW5MZWZ0LFxuICAgICAgdG9wOiAgKGggLyAyKSAtIChoZWlnaHQgLyAyKSArIGR1YWxTY3JlZW5Ub3AsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB3aW5kb3cgZmVhdHVyZXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgd2luZG93IGZlYXR1cmVzIGNvbXBhdGlibGUgd2l0aCBgd2luZG93Lm9wZW5gXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fZ2V0RmVhdHVyZXMgPSBmdW5jdGlvbiBfZ2V0RmVhdHVyZXMoKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuX2dldENlbnRlcmVkUG9zaXRpb24odGhpcy5jb25maWcud2lkdGgsIHRoaXMuY29uZmlnLmhlaWdodCk7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29uZmlnLndpbmRvdykge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLndpbmRvdy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbmZpZ1trZXldID0gdGhpcy5jb25maWcud2luZG93W2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbmZpZylcbiAgICAgIC5tYXAoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBrZXkgKyAnPScgKyB0aGlzLl9zZXJpYWxpemVGZWF0dXJlVmFsdWUoa2V5LCBjb25maWdba2V5XSk7IH0uYmluZCh0aGlzKSlcbiAgICAgIC5qb2luKCcsJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUHJvbWlzZSwgdXNpbmcgYGNvbmZpZy5wcm9taXNlUHJvdmlkZXJgLCBhbmQgc2F2ZSByZWplY3QgYW5kXG4gICAqIHJlc29sdmUgbWV0aG9kcyBmb3IgbGF0ZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgdGhlIG5ldyBQcm9taXNlIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBjb25maWd1cmVkXG4gICAqICAgICAgICAgICAgICAgICAgIFByb21pc2UgUHJvdmlkZXIuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fY3JlYXRlUHJvbWlzZSA9IGZ1bmN0aW9uIF9jcmVhdGVQcm9taXNlKCkge1xuICAgIHZhciBtb2R1bGUgPSB0aGlzLmNvbmZpZy5wcm9taXNlUHJvdmlkZXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlID0gbW9kdWxlLnJlc29sdmU7XG4gICAgdGhpcy5fcmVqZWN0ID0gbW9kdWxlLnJlamVjdDtcbiAgICByZXR1cm4gbW9kdWxlLnByb21pc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB3aW5kb3cgaXMgYWxpdmUgb3Igbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB3aW5kb3cgaXMgYWxpdmUsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5faXNXaW5kb3dBbGl2ZSA9IGZ1bmN0aW9uIF9pc1dpbmRvd0FsaXZlKCkge1xuICAgIHJldHVybiB0aGlzLl93aW5kb3cgJiYgIXRoaXMuX3dpbmRvdy5jbG9zZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcG9wdXAgd2luZG93IHdhdGNoZXIuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fc3RhcnRXYXRjaGVyID0gZnVuY3Rpb24gX3N0YXJ0V2F0Y2hlcigpIHtcbiAgICBpZiAodGhpcy5fd2F0Y2hlclJ1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2F0Y2hlciBpcyBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICB9XG4gICAgdGhpcy5fd2F0Y2hlciA9IHJvb3Quc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3dhdGNoZXJSdW5uaW5nICYmICF0aGlzLl9pc1dpbmRvd0FsaXZlKCkpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSwgdGhpcy5jb25maWcud2F0Y2hlckRlbGF5KTtcbiAgICB0aGlzLl93YXRjaGVyUnVubmluZyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBwb3B1cCB3aW5kb3cgd2F0Y2hlci5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9zdG9wV2F0Y2hlciA9IGZ1bmN0aW9uIF9zdG9wV2F0Y2hlcigpIHtcbiAgICBpZiAoIXRoaXMuX3dhdGNoZXJSdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhdGNoZXIgaXMgYWxyZWFkeSBzdG9wcGVkJyk7XG4gICAgfVxuICAgIHRoaXMuX3dhdGNoZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgcm9vdC5jbGVhckludGVydmFsKHRoaXMuX3dhdGNoZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgcG9zdCBtZXNzYWdlIGV2ZW50cy4gSWYgYW5kIG9ubHkgb2YgdGhlIGV2ZW50IGhhcyBiZWVuXG4gICAqIGdlbmVyYXRlZCBmcm9tIHRoZSBvcGVuZWQgcG9wdXAgd2luZG93LCBpdCBwcm9wYWdhdGVzIGl0IHRvIHRoZSBjb25maWd1cmVkXG4gICAqIHBvc3QgbWVzc2FnZSBoYW5kbGVyIChgY29uZmlnLm9uUG9zdE1lc3NhZ2VgKS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIHBvc3RNZXNzYWdlIGV2ZW50XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fb25Qb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIF9vblBvc3RNZXNzYWdlKGV2ZW50KSB7XG4gICAgdmFyIGV4cGVjdGVkT3JpZ2luTWF0Y2hlcyA9IHRoaXMuY29uZmlnLm9yaWdpblJlZ2V4cC5leGVjKHRoaXMudXJpKTtcbiAgICB2YXIgZXhwZWN0ZWRPcmlnaW4gPSBleHBlY3RlZE9yaWdpbk1hdGNoZXMgJiYgZXhwZWN0ZWRPcmlnaW5NYXRjaGVzWzBdIHx8IGxvY2F0aW9uLm9yaWdpbjtcbiAgICBpZiAodGhpcy5fd2luZG93ID09PSBldmVudC5zb3VyY2UgJiYgZXZlbnQub3JpZ2luID09PSBleHBlY3RlZE9yaWdpbikge1xuICAgICAgdGhpcy5jb25maWcub25Qb3N0TWVzc2FnZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIFVSSVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJpIFRoZSBuZXcgVVJJXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgd2luZG93IGlzIG9wZW5cbiAgICogQHJldHVybiB7UHJvbWlzZVdpbmRvd30gUmV0dXJucyB0aGlzIG9iamVjdCB0byBhbGxvdyBjaGFpbmluZ1xuICAgKi9cbiAgcHJvdG90eXBlLnNldFVSSSA9IGZ1bmN0aW9uIHNldFVSSSh1cmkpIHtcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2hhbmdlIHRoZSBVUkkgd2hpbGUgdGhlIHdpbmRvdyBpcyBvcGVuJyk7XG4gICAgfVxuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcGVucyBhIG5ldyBwb3B1cCB3aW5kb3cuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgYSBuZXcgYFByb21pc2VgIG9iamVjdC4gVGhpcyBwcm9taXNlIHdpbGwgYmU6XG4gICAqICAgICAgICAgICAgICAgICAgIC0gcmVqZWN0ZWQgd2l0aCBgXCJibG9ja2VkXCJgIG1lc3NhZ2UgaWYgdGhlIHBvcHVwIHdpbmRvd1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGRvZXMgbm90IG9wZW4gZm9yIGFueSByZWFzb24gKHBvcHVwIGJsb2NrZXIsIGV0Yy4uLilcbiAgICogICAgICAgICAgICAgICAgICAgLSByZWplY3RlZCB3aXRoIGBcImNsb3NlZFwiYCBpZiBjbG9zZWQgZWl0aGVyIG1hbnVhbGx5IGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgdGhlIHVzZXIsIG9yIHByb2dyYW1hdGljYWxseVxuICAgKiAgICAgICAgICAgICAgICAgICAtIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGVycm9yIGlmIHRoZSB3ZWIgcGFnZSBvcGVuZWQgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9wdXAgc2VuZHMgYSBwb3N0IG1lc3NhZ2Ugd2l0aCBhIGBlcnJvcmAgZGF0YSBmaWVsZC5cbiAgICogICAgICAgICAgICAgICAgICAgLSByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiBkYXRhIGlmIHRoZSB3ZWIgcGFnZSBvcGVuZWQgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9wdXAgc2VuZHMgYSBwb3N0IG1lc3NhZ2Ugd2l0aG91dCBhIGBlcnJvcmAgZGF0YVxuICAgKiAgICAgICAgICAgICAgICAgICAgIGZpZWxkLlxuICAgKi9cbiAgcHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKCkge1xuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpbmRvdyBpcyBhbHJlYWR5IG9wZW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl93aW5kb3dPcGVuID0gdHJ1ZTtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX2NyZWF0ZVByb21pc2UoKTtcbiAgICB0aGlzLl93aW5kb3cgPSByb290Lm9wZW4oXG4gICAgICB0aGlzLnVyaSxcbiAgICAgIHRoaXMuY29uZmlnLndpbmRvd05hbWUsXG4gICAgICB0aGlzLl9nZXRGZWF0dXJlcygpXG4gICAgKTtcbiAgICBpZiAoIXRoaXMuX3dpbmRvdykge1xuICAgICAgdGhpcy5fcmVqZWN0KFwiYmxvY2tlZFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uUG9zdE1lc3NhZ2UsIHRydWUpO1xuICAgICAgdGhpcy5fc3RhcnRXYXRjaGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHBvcHVwIHdpbmRvdy5cbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaW5kb3cgaXMgYWxyZWFkeSBjbG9zZWQnKTtcbiAgICB9XG4gICAgdGhpcy5fc3RvcFdhdGNoZXIoKTtcbiAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uUG9zdE1lc3NhZ2UpO1xuICAgIGlmICh0aGlzLl9pc1dpbmRvd0FsaXZlKCkpIHtcbiAgICAgIHRoaXMuY29uZmlnLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcmVqZWN0KFwiY2xvc2VkXCIpO1xuICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gICAgdGhpcy5fd2luZG93T3BlbiA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgd2luZG93IGlzIG9wZW4gb3Igbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB3aW5kb3cgaXMgb3BlbmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd09wZW47XG4gIH07XG5cbiAgLy8gRXhwb3J0cyBQcm9taXNlV2luZG93IHRvIHRoZSBnbG9iYWwgc2NvcGVcbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdwcm9taXNlLXdpbmRvdycsIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIFByb21pc2VXaW5kb3cgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlV2luZG93O1xuICB9IGVsc2Uge1xuICAgIHJvb3QuUHJvbWlzZVdpbmRvdyA9IFByb21pc2VXaW5kb3c7XG4gIH1cbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxufSkoKTtcbiIsImlmIChwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9uYW1lID09PSAncHNldWRvbWFwJyAmJlxuICAgIHByb2Nlc3MuZW52Lm5wbV9saWZlY3ljbGVfc2NyaXB0ID09PSAndGVzdCcpXG4gIHByb2Nlc3MuZW52LlRFU1RfUFNFVURPTUFQID0gJ3RydWUnXG5cbmlmICh0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmICFwcm9jZXNzLmVudi5URVNUX1BTRVVET01BUCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IE1hcFxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BzZXVkb21hcCcpXG59XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gUHNldWRvTWFwXG5cbmZ1bmN0aW9uIFBzZXVkb01hcCAoc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQc2V1ZG9NYXApKSAvLyB3aHl5eXl5eXlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3IgUHNldWRvTWFwIHJlcXVpcmVzICduZXcnXCIpXG5cbiAgdGhpcy5jbGVhcigpXG5cbiAgaWYgKHNldCkge1xuICAgIGlmICgoc2V0IGluc3RhbmNlb2YgUHNldWRvTWFwKSB8fFxuICAgICAgICAodHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXQgaW5zdGFuY2VvZiBNYXApKVxuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXQpKVxuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKGt2KSB7XG4gICAgICAgIHRoaXMuc2V0KGt2WzBdLCBrdlsxXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpXG4gIH1cbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgT2JqZWN0LmtleXModGhpcy5fZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChrICE9PSAnc2l6ZScpXG4gICAgICBmbi5jYWxsKHRoaXNwLCB0aGlzLl9kYXRhW2tdLnZhbHVlLCB0aGlzLl9kYXRhW2tdLmtleSlcbiAgfSwgdGhpcylcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoaykge1xuICByZXR1cm4gISFmaW5kKHRoaXMuX2RhdGEsIGspXG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGspIHtcbiAgdmFyIHJlcyA9IGZpbmQodGhpcy5fZGF0YSwgaylcbiAgcmV0dXJuIHJlcyAmJiByZXMudmFsdWVcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaywgdikge1xuICBzZXQodGhpcy5fZGF0YSwgaywgdilcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoaykge1xuICB2YXIgcmVzID0gZmluZCh0aGlzLl9kYXRhLCBrKVxuICBpZiAocmVzKSB7XG4gICAgZGVsZXRlIHRoaXMuX2RhdGFbcmVzLl9pbmRleF1cbiAgICB0aGlzLl9kYXRhLnNpemUtLVxuICB9XG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBkYXRhLnNpemUgPSAwXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfZGF0YScsIHtcbiAgICB2YWx1ZTogZGF0YSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQc2V1ZG9NYXAucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChuKSB7fSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLnZhbHVlcyA9XG5Qc2V1ZG9NYXAucHJvdG90eXBlLmtleXMgPVxuUHNldWRvTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9ycyBhcmUgbm90IGltcGxlbWVudGVkIGluIHRoaXMgdmVyc2lvbicpXG59XG5cbi8vIEVpdGhlciBpZGVudGljYWwsIG9yIGJvdGggTmFOXG5mdW5jdGlvbiBzYW1lIChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IGEgIT09IGEgJiYgYiAhPT0gYlxufVxuXG5mdW5jdGlvbiBFbnRyeSAoaywgdiwgaSkge1xuICB0aGlzLmtleSA9IGtcbiAgdGhpcy52YWx1ZSA9IHZcbiAgdGhpcy5faW5kZXggPSBpXG59XG5cbmZ1bmN0aW9uIGZpbmQgKGRhdGEsIGspIHtcbiAgZm9yICh2YXIgaSA9IDAsIHMgPSAnXycgKyBrLCBrZXkgPSBzO1xuICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICAgICBrZXkgPSBzICsgaSsrKSB7XG4gICAgaWYgKHNhbWUoZGF0YVtrZXldLmtleSwgaykpXG4gICAgICByZXR1cm4gZGF0YVtrZXldXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0IChkYXRhLCBrLCB2KSB7XG4gIGZvciAodmFyIGkgPSAwLCBzID0gJ18nICsgaywga2V5ID0gcztcbiAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgICAga2V5ID0gcyArIGkrKykge1xuICAgIGlmIChzYW1lKGRhdGFba2V5XS5rZXksIGspKSB7XG4gICAgICBkYXRhW2tleV0udmFsdWUgPSB2XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgZGF0YS5zaXplKytcbiAgZGF0YVtrZXldID0gbmV3IEVudHJ5KGssIHYsIGtleSlcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmKTtcbiAgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBZYWxsaXN0XG5cbllhbGxpc3QuTm9kZSA9IE5vZGVcbllhbGxpc3QuY3JlYXRlID0gWWFsbGlzdFxuXG5mdW5jdGlvbiBZYWxsaXN0IChsaXN0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgWWFsbGlzdCkpIHtcbiAgICBzZWxmID0gbmV3IFlhbGxpc3QoKVxuICB9XG5cbiAgc2VsZi50YWlsID0gbnVsbFxuICBzZWxmLmhlYWQgPSBudWxsXG4gIHNlbGYubGVuZ3RoID0gMFxuXG4gIGlmIChsaXN0ICYmIHR5cGVvZiBsaXN0LmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHNlbGYucHVzaChpdGVtKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNlbGYucHVzaChhcmd1bWVudHNbaV0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92aW5nIG5vZGUgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgbGlzdCcpXG4gIH1cblxuICB2YXIgbmV4dCA9IG5vZGUubmV4dFxuICB2YXIgcHJldiA9IG5vZGUucHJldlxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldlxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0XG4gIH1cblxuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbmV4dFxuICB9XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBwcmV2XG4gIH1cblxuICBub2RlLmxpc3QubGVuZ3RoLS1cbiAgbm9kZS5uZXh0ID0gbnVsbFxuICBub2RlLnByZXYgPSBudWxsXG4gIG5vZGUubGlzdCA9IG51bGxcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2XG4gICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dFxuICAgIHdhbGtlci5uZXh0ID0gcFxuICB9XG4gIHRoaXMuaGVhZCA9IHRhaWxcbiAgdGhpcy50YWlsID0gaGVhZFxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuIiwiaW1wb3J0IERpc2NvdXJzZUF1dGggZnJvbSAnLi9kaXNjb3Vyc2VBdXRoJztcbmltcG9ydCBEaXNjb3Vyc2VBcGkgZnJvbSAnLi9kaXNjb3Vyc2VBcGknO1xuaW1wb3J0IFByb21pc2VXaW5kb3cgZnJvbSAncHJvbWlzZS13aW5kb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXNjb3Vyc2VDbGllbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5fcmVxdWlyZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5fZm9ybWF0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmF1dGggPSBuZXcgRGlzY291cnNlQXV0aCh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuYXBpID0gbmV3IERpc2NvdXJzZUFwaSh0aGlzLm9wdGlvbnMuYXBpQmFzZVVybCk7XG4gIH1cblxuICBhc3luYyBpbml0KCkge1xuICAgIGF3YWl0IHRoaXMuYXV0aC5pbml0KCk7XG4gIH1cblxuICBfcmVxdWlyZU9wdGlvbnMob3B0aW9ucykge1xuICAgIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgfHxcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICh0eXBlb2Ygb3B0aW9ucy5hcHBOYW1lID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmFwcE5hbWUubGVuZ3RoID4gMCkgfHxcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5hcHBOYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgKHR5cGVvZiBvcHRpb25zLmFwaUJhc2VVcmwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuYXBpQmFzZVVybC5sZW5ndGggPiAwKSB8fFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zLmFwaUJhc2VVcmwgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAob3B0aW9ucy5zY29wZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBvcHRpb25zLnNjb3Blcy5sZW5ndGggPiAwKSB8fFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zLnNjb3BlcyBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5Jyk7XG4gIH1cblxuICBfZm9ybWF0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgZm9ybWF0dGVkT3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gICAgZm9ybWF0dGVkT3B0aW9ucy5hcGlCYXNlVXJsID0gb3B0aW9ucy5hcGlCYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgZm9ybWF0dGVkT3B0aW9ucy5zY29wZXMgPSBvcHRpb25zLnNjb3Blcy5qb2luKCcsJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlZE9wdGlvbnM7XG4gIH1cblxuICBnZXRBcGlCYXNlVXJsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXBpQmFzZVVybDtcbiAgfVxuXG4gIGFzeW5jIGlzTG9nZ2VkSW4oKSB7XG4gICAgaWYgKCF0aGlzLmF1dGguX2hhc1VzZXJBcGlLZXkoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9yZWZyZXNoQ3VycmVudFVzZXIoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q3VycmVudFVzZXIoKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2N1cnJlbnRVc2VyJykpO1xuICB9XG5cbiAgZ2V0Q3VycmVudFVzZXJOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRVc2VyKClbJ3VzZXJuYW1lJ107XG4gIH1cblxuICBnZXRDdXJyZW50VXNlckRpc3BsYXlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRVc2VyKClbJ25hbWUnXTtcbiAgfVxuXG4gIGlzQ3VycmVudFVzZXJTaWxlbmNlZCgpIHtcbiAgICByZXR1cm4gIXRoaXMuZ2V0Q3VycmVudFVzZXIoKVsnY2FuX2NyZWF0ZV90b3BpYyddO1xuICB9XG5cbiAgZ2V0Q3VycmVudFVzZXJBdmF0YXJVcmwoc2l6ZSkge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLm9wdGlvbnMuYXBpQmFzZVVybCxcbiAgICAgIHRoaXMuZ2V0Q3VycmVudFVzZXIoKVsnYXZhdGFyX3RlbXBsYXRlJ10ucmVwbGFjZSgne3NpemV9JywgKHNpemUgfHwgMTEwKSlcbiAgICBdLmpvaW4oJy8nKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VyTm90aWZpY2F0aW9uc1VybCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdGhpcy5vcHRpb25zLmFwaUJhc2VVcmwsXG4gICAgICAndScsXG4gICAgICB0aGlzLmdldEN1cnJlbnRVc2VyTmFtZSgpLFxuICAgICAgJ25vdGlmaWNhdGlvbnMnXG4gICAgXS5qb2luKCcvJyk7XG4gIH1cblxuICBhc3luYyBfcmVmcmVzaEN1cnJlbnRVc2VyKCkge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY3VycmVudFVzZXInLCBKU09OLnN0cmluZ2lmeShhd2FpdCB0aGlzLmFwaS5nZXRDdXJyZW50U2Vzc2lvblVzZXIoKSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ291dCgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgbG9nZ2VkIGluLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGxvZ2luKCkge1xuICAgIGlmIChhd2FpdCB0aGlzLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2VXaW5kb3cub3Blbihhd2FpdCB0aGlzLmF1dGguX2dldExvZ2luVXJsKCksIHtcbiAgICAgIHdpZHRoOiA3MDAsXG4gICAgICBoZWlnaHQ6IDY1MCxcbiAgICAgIG9yaWdpblJlZ2V4cDogbmV3IFJlZ0V4cCgnXicgKyBsb2NhdGlvbi5vcmlnaW4pXG4gICAgfSkudGhlbihhc3luYyBkYXRhID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuYXBpLl9zZXRVc2VyQXBpS2V5KGRhdGEucmVzdWx0LmtleSk7XG4gICAgICBhd2FpdCB0aGlzLl9yZWZyZXNoQ3VycmVudFVzZXIoKTtcbiAgICB9LFxuXG4gICAgLy8gRXJyb3JcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIHN3aXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZGlzY291cnNlTG9naW5DYW5jZWxlZCcpKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHBvcHVwIHdpbmRvdyBjbG9zZWQgYnkgdGhlIHVzZXInKTtcbiAgICAgICAgY2FzZSAnYmxvY2tlZCc6XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Rpc2NvdXJzZUxvZ2luQmxvY2tlZCcpKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHBvcHVwIHdpbmRvdyBibG9ja2VkIGJ5IHRoZSBicm93c2VyJyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiBwb3B1cCB3aW5kb3cgcmV0dXJuZWQgYW4gZXJyb3I6ICcsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KS50aGVuKCgpID0+IGRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdkaXNjb3Vyc2VMb2dnZWRJbicpKSk7XG4gIH1cblxuICBhc3luYyBsb2dvdXQoKSB7XG4gICAgYXdhaXQgdGhpcy5hcGkubG9nb3V0KHRoaXMuZ2V0Q3VycmVudFVzZXJOYW1lKCkpO1xuICAgIHRoaXMuYXV0aC5fY2xlYXJBdXRoRGF0YSgpO1xuICAgIGRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdkaXNjb3Vyc2VMb2dnZWRPdXQnKSk7XG4gIH1cbn1cblxuLy8gRGVidWcgb25seVxud2luZG93LkRpc2NvdXJzZUNsaWVudCA9IERpc2NvdXJzZUNsaWVudDtcbiIsImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBjYWNoZUFkYXB0ZXJFbmhhbmNlciwgdGhyb3R0bGVBZGFwdGVyRW5oYW5jZXIgfSBmcm9tICdheGlvcy1leHRlbnNpb25zJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlzY291cnNlQXBpIHtcbiAgY29uc3RydWN0b3IoYXBpQmFzZVVybCkge1xuICAgIHRoaXMuYXBpQmFzZVVybCA9IGFwaUJhc2VVcmw7XG4gICAgdGhpcy5hcGkgPSBheGlvcy5jcmVhdGUoe1xuICAgICAgYmFzZVVSTDogdGhpcy5hcGlCYXNlVXJsLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSxcbiAgICAgIGFkYXB0ZXI6IHRocm90dGxlQWRhcHRlckVuaGFuY2VyKFxuICAgICAgICBjYWNoZUFkYXB0ZXJFbmhhbmNlcihheGlvcy5kZWZhdWx0cy5hZGFwdGVyKSxcbiAgICAgICAgeyB0aHJlc2hvbGQ6IDUwMCB9IC8vIDIwMCByZXFzL21pblxuICAgICAgKVxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0VXNlckFwaUtleShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcl9hcGlfa2V5JykpO1xuICB9XG5cbiAgYXN5bmMgX2dldENhbGxSZXN1bHQoZW5kcG9pbnQsIHByb3AsIG5vY2FjaGUgPSBmYWxzZSkge1xuICAgIGxldCByZXNwb25zZTtcblxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IChhd2FpdCB0aGlzLmFwaS5nZXQoZW5kcG9pbnQsIHsgZm9yY2VVcGRhdGU6IG5vY2FjaGUgfSkpLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHByb3ApIHtcbiAgICAgIHJlc3BvbnNlID0gcHJvcC5zcGxpdCgnLicpLnJlZHVjZSgocmV0dXJuZWRSZXNwb25zZSwgY3VycmVudFByb3ApID0+XG4gICAgICAgIHJldHVybmVkUmVzcG9uc2VbY3VycmVudFByb3BdLCByZXNwb25zZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgYXN5bmMgX3Bvc3RDYWxsUmVzdWx0KGVuZHBvaW50LCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLmFwaS5wb3N0KGVuZHBvaW50LCBwYXlsb2FkKSkuZGF0YTtcbiAgfVxuXG4gIGFzeW5jIF9zZXRVc2VyQXBpS2V5KHVzZXJBcGlLZXkpIHtcbiAgICBpZiAoIXVzZXJBcGlLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hcGkuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1VzZXItQXBpLUtleSddID0gdXNlckFwaUtleTtcbiAgICBhd2FpdCB0aGlzLl9zZXRDc3JmVG9rZW4oKTtcbiAgfVxuXG4gIGFzeW5jIF9zZXRDc3JmVG9rZW4oKSB7XG4gICAgdGhpcy5hcGkuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtQ1NSRi1Ub2tlbiddID0gYXdhaXQgdGhpcy5fZ2V0Q2FsbFJlc3VsdCgnL3Nlc3Npb24vY3NyZi5qc29uJywgJ2NzcmYnKTtcbiAgfVxuXG4gIF9lbmZvcmNlVXNlckFwaUtleSgpIHtcbiAgICB0aGlzLmFwaS5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnVXNlci1BcGktS2V5J10gfHwgdGhyb3cgbmV3IEVycm9yKCdVc2VyIEFQSSBrZXkgbm90IHNldCcpO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q3VycmVudFNlc3Npb25Vc2VyKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRDYWxsUmVzdWx0KCcvc2Vzc2lvbi9jdXJyZW50Lmpzb24nLCAnY3VycmVudF91c2VyJywgdHJ1ZSk7XG4gIH1cblxuICBhc3luYyBnZXRMYXRlc3RQb3N0cyhkZXNjZW5kaW5nKSB7XG4gICAgbGV0IHBvc3RzO1xuXG4gICAgdHJ5IHtcbiAgICAgIHBvc3RzID0gYXdhaXQgdGhpcy5fZ2V0Q2FsbFJlc3VsdCgnL3Bvc3RzLmpzb24nLCAnbGF0ZXN0X3Bvc3RzJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgIHBvc3RzID0gcG9zdHMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3N0cy5maWx0ZXIocG9zdCA9PiBwb3N0LnBvc3RfdHlwZSA9PT0gMSk7XG4gIH1cblxuICBhc3luYyBnZXRQb3N0c0luVG9waWModG9waWNJZCwgZGVzY2VuZGluZywgbm9jYWNoZSkge1xuICAgIGxldCBwb3N0cyA9IGF3YWl0IHRoaXMuX2dldENhbGxSZXN1bHQoJy90LycgKyB0b3BpY0lkICsgJy9wb3N0cy5qc29uP2luY2x1ZGVfcmF3PXRydWUnLFxuICAgICAgJ3Bvc3Rfc3RyZWFtLnBvc3RzJywgbm9jYWNoZSk7XG5cbiAgICBpZiAoZGVzY2VuZGluZykge1xuICAgICAgcG9zdHMgPSBwb3N0cy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc3RzLmZpbHRlcihwb3N0ID0+IHBvc3QucG9zdF90eXBlID09PSAxKTtcbiAgfVxuXG4gIGFzeW5jIGdldFRvcGljKHRvcGljSWQsIGRlc2NlbmRpbmcpIHtcbiAgICBsZXQgdG9waWMgPSBhd2FpdCB0aGlzLl9nZXRDYWxsUmVzdWx0KCcvdC8nICsgdG9waWNJZCArICcuanNvbj9pbmNsdWRlX3Jhdz10cnVlJyk7XG5cbiAgICB0b3BpYy5wb3N0X3N0cmVhbS5wb3N0cyA9IHRvcGljLnBvc3Rfc3RyZWFtLnBvc3RzLmZpbHRlcihwb3N0ID0+IHBvc3QucG9zdF90eXBlID09PSAxKTtcblxuICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICB0b3BpYy5wb3N0X3N0cmVhbS5wb3N0cyA9IHRvcGljLnBvc3Rfc3RyZWFtLnBvc3RzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9waWM7XG4gIH1cblxuICBhc3luYyBnZXRQdWJsaWNVc2VyRmllbGRzKHVzZXJuYW1lKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldENhbGxSZXN1bHQoJy91LycgKyB1c2VybmFtZSArICcuanNvbj9zdGF0cz1mYWxzZScsICd1c2VyLnVzZXJfZmllbGRzJyk7XG4gIH1cblxuICBhc3luYyBnZXRGaXJzdFB1YmxpY1VzZXJGaWVsZCh1c2VybmFtZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRDYWxsUmVzdWx0KCcvdS8nICsgdXNlcm5hbWUgKyAnLmpzb24/c3RhdHM9ZmFsc2UnLCAndXNlci51c2VyX2ZpZWxkcy4xJyk7XG4gIH1cblxuICBhc3luYyBwb3N0TWVzc2FnZSh0b3BpY0lkLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5fZW5mb3JjZVVzZXJBcGlLZXkoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcG9zdENhbGxSZXN1bHQoJy9wb3N0cy5qc29uJywge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICB0b3BpY19pZDogdG9waWNJZCxcbiAgICAgIHJhdzogbWVzc2FnZVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIHJlc3BvbnNlLmhpZGRlbiAmJiBQcm9taXNlLnJlamVjdChyZXNwb25zZS5oaWRkZW5fcmVhc29uX2lkKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiBQcm9taXNlLnJlamVjdChlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycykpO1xuICB9XG5cbiAgYXN5bmMgbG9nb3V0KHVzZXJuYW1lKSB7XG4gICAgdGhpcy5fZW5mb3JjZVVzZXJBcGlLZXkoKTtcbiAgICAvLyBhd2FpdCB0aGlzLmFwaS5kZWxldGUoJy9zZXNzaW9uLycgKyB1c2VybmFtZSk7IC8vIE5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgYXdhaXQgdGhpcy5hcGkucG9zdCgnL3VzZXItYXBpLWtleS9yZXZva2UnKTtcbiAgICBkZWxldGUgdGhpcy5hcGkuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1VzZXItQXBpLUtleSddO1xuICAgIGRlbGV0ZSB0aGlzLmFwaS5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnWC1DU1JGLVRva2VuJ107XG4gIH1cbn1cbiIsImltcG9ydCBLZXlNYW5hZ2VyIGZyb20gJy4va2V5TWFuYWdlcic7XG5pbXBvcnQgVVJMU2VhcmNoUGFyYW1zIGZyb20gJ0B1bmdhcC91cmwtc2VhcmNoLXBhcmFtcyc7IC8vIHBvbHlmaWxsXG4vLyBpbXBvcnQgTW9iaWxlRGV0ZWN0IGZyb20gJ21vYmlsZS1kZXRlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXNjb3Vyc2VBdXRoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuYXBwSWQgPSB0aGlzLl9zbHVnaWZ5KG9wdGlvbnMuYXBwTmFtZSk7XG4gICAgdGhpcy5rbSA9IG5ldyBLZXlNYW5hZ2VyKHRoaXMuYXBwSWQpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBhc3luYyBpbml0KCkge1xuICAgIGF3YWl0IHRoaXMua20uZ2V0S2V5cygpO1xuICAgIHRoaXMuX2hhc1VzZXJBcGlLZXkoKSB8fCB0aGlzLl9tYW5hZ2VQYXlsb2FkKCk7XG4gIH1cblxuICBfaGFzVXNlckFwaUtleSgpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfYXBpX2tleScpICE9PSBudWxsO1xuICB9XG5cbiAgYXN5bmMgX2dldExvZ2luVXJsKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgYXBwbGljYXRpb25fbmFtZTogdGhpcy5vcHRpb25zLmFwcE5hbWUsXG4gICAgICBwdWJsaWNfa2V5OiBhd2FpdCB0aGlzLmttLmdldFB1YmxpY0tleSgpLFxuICAgICAgbm9uY2U6IHRoaXMuX2dlbmVyYXRlU3RvcmVkUmFuZG9tKCdub25jZScpLFxuICAgICAgY2xpZW50X2lkOiB0aGlzLl9nZXRTdG9yZWRSYW5kb20oJ2NsaWVudElkJykgfHwgdGhpcy5fZ2VuZXJhdGVTdG9yZWRSYW5kb20oJ2NsaWVudElkJyksXG4gICAgICBhdXRoX3JlZGlyZWN0OiBsb2NhdGlvbi5ocmVmLFxuICAgICAgc2NvcGVzOiB0aGlzLm9wdGlvbnMuc2NvcGVzXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFwaUJhc2VVcmwgKyAnL3VzZXItYXBpLWtleS9uZXc/JyArIHRoaXMuX3NlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpO1xuICB9XG5cbiAgX3NlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1zKVxuICAgICAgLm1hcCgoaykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KGspICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trXSkpXG4gICAgICAuam9pbignJicpO1xuICB9O1xuXG4gIF9nZW5lcmF0ZVN0b3JlZFJhbmRvbShuYW1lKSB7XG4gICAgY29uc3Qgc3RvcmVkUmFuZG9tID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc3Vic3RyKDIpO1xuXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5hcHBJZCArICdfJyArIG5hbWUsIHN0b3JlZFJhbmRvbSk7XG4gICAgcmV0dXJuIHN0b3JlZFJhbmRvbTtcbiAgfVxuXG4gIF9nZXRTdG9yZWRSYW5kb20obmFtZSkge1xuICAgIGNvbnN0IHN0b3JlZFJhbmRvbSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuYXBwSWQgKyAnXycgKyBuYW1lKTtcblxuICAgIHJldHVybiBzdG9yZWRSYW5kb207XG4gIH1cblxuICBfcmVtb3ZlU3RvcmVkUmFuZG9tKG5hbWUpIHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmFwcElkICsgJ18nICsgbmFtZSk7XG4gIH1cblxuICBfZ2V0VXNlckFwaUtleSgpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfYXBpX2tleScpO1xuICB9XG5cbiAgX2NsZWFyQXV0aERhdGEoKSB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXJfYXBpX2tleScpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdjdXJyZW50VXNlcicpO1xuICAgIHRoaXMuX3JlbW92ZVN0b3JlZFJhbmRvbSgnY2xpZW50SWQnKTtcbiAgfVxuXG4gIF9tYW5hZ2VQYXlsb2FkKCkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCB8fCB3aW5kb3cubG9jYXRpb24uaGFzaC5zcGxpdCgnPycpWzFdKTtcblxuICAgIGlmICh1cmwuaGFzKCdwYXlsb2FkJykgJiYgb3BlbmVyKSB7XG4gICAgICB0aGlzLmttLmRlY3J5cHRQYXlsb2FkKHVybC5nZXQoJ3BheWxvYWQnKSkudGhlbihwYXlsb2FkT2JqZWN0ID0+IHtcbiAgICAgICAgcGF5bG9hZE9iamVjdC5ub25jZSA9PT0gdGhpcy5fZ2V0U3RvcmVkUmFuZG9tKCdub25jZScpIHx8XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmV0dXJuZWQgcGF5bG9hZCBpcyBpbnZhbGlkLicpO1xuICAgICAgICBwYXlsb2FkT2JqZWN0LmFwaSA9PT0gMyB8fFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgQVBJIHZlcnNpb246ICcgKyBwYXlsb2FkT2JqZWN0LmFwaSArICcuIERpc2NvdXJzZS1qcyB3b3JrcyB3aXRoIEFQSSB2ZXJzaW9uIDMuJyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyX2FwaV9rZXknLCBwYXlsb2FkT2JqZWN0LmtleSk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVN0b3JlZFJhbmRvbSgnbm9uY2UnKTtcbiAgICAgICAgb3BlbmVyLnBvc3RNZXNzYWdlKHsgcmVzdWx0OiBwYXlsb2FkT2JqZWN0IH0sIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdmFyIG1kID0gbmV3IE1vYmlsZURldGVjdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICBfc2x1Z2lmeSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnLScpXG4gICAgICAucmVwbGFjZSgvW15cXHdcXC1dKy9nLCAnJylcbiAgICAgIC5yZXBsYWNlKC9cXC1cXC0rL2csICctJylcbiAgICAgIC5yZXBsYWNlKC9eLSsvLCAnJylcbiAgICAgIC5yZXBsYWNlKC8tKyQvLCAnJyk7XG4gIH1cbn1cbiIsImxldCBmb3JnZSA9IHJlcXVpcmUoJy4vdmVuZG9yL2ZvcmdlLXBraScpO1xuXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4ge1xuICBjb25zdCBnZW5lcmF0ZSA9IChhcHBJZCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmb3JnZS5yc2EuZ2VuZXJhdGVLZXlQYWlyKHtcbiAgICAgICAgd29ya2VyU2NyaXB0OiAnL3ByaW1lLXdvcmtlci5taW4uanMnXG4gICAgICB9LFxuICAgICAgKGVycm9yLCBnZW5lcmF0ZWRLZXlwYWlyKSA9PiB7XG4gICAgICAgIGdlbmVyYXRlZEtleXBhaXIgPyAoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGtleXBhaXIgPSB7XG4gICAgICAgICAgICBwdWJsaWM6IGZvcmdlLnBraS5wdWJsaWNLZXlUb1BlbShnZW5lcmF0ZWRLZXlwYWlyLnB1YmxpY0tleSwgNzIpLnJlcGxhY2UoL1xcci9nLCAnJyksXG4gICAgICAgICAgICBwcml2YXRlOiBmb3JnZS5wa2kucHJpdmF0ZUtleVRvUGVtKGdlbmVyYXRlZEtleXBhaXIucHJpdmF0ZUtleSwgNzIpLnJlcGxhY2UoL1xcci9nLCAnJylcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYXBwSWQgKyAnX3B1YmxpY0tleScsIGtleXBhaXIucHVibGljKTtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhcHBJZCArICdfcHJpdmF0ZUtleScsIGtleXBhaXIucHJpdmF0ZSk7XG4gICAgICAgICAgcmVzb2x2ZShrZXlwYWlyKTtcbiAgICAgICAgfSkoKSA6IHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4geyBnZW5lcmF0ZSB9O1xufSkoKTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihhcHBJZCkge1xuICAgIHRoaXMuYXBwSWQgPSBhcHBJZDtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlTmV3S2V5cGFpcigpIHtcbiAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgLypcbiAgICAgICAgd2VicGFja0NodW5rTmFtZTogXCJrZXlHZW5lcmF0b3JcIixcbiAgICAgICAgd2VicGFja1ByZWxvYWQ6IHRydWVcbiAgICAgICovXG4gICAgICAnLi9rZXlHZW5lcmF0b3InKS50aGVuKCh7IGRlZmF1bHQ6IGtleUdlbmVyYXRvciB9KSA9PiB7XG4gICAgICByZXR1cm4ga2V5R2VuZXJhdG9yLmdlbmVyYXRlKHRoaXMuYXBwSWQpLnRoZW4oKGtleXBhaXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGtleXBhaXI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEtleXNGcm9tU3RvcmFnZSgpIHx8IGF3YWl0IHRoaXMuZ2VuZXJhdGVOZXdLZXlwYWlyKCk7XG4gIH1cblxuICByZWFkS2V5c0Zyb21TdG9yYWdlKCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuYXBwSWQgKyAnX3B1YmxpY0tleScpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmFwcElkICsgJ19wcml2YXRlS2V5Jyk7XG5cbiAgICByZXR1cm4gKHB1YmxpY0tleSAmJiBwcml2YXRlS2V5KSA/XG4gICAgICB7XG4gICAgICAgIHB1YmxpYzogcHVibGljS2V5LFxuICAgICAgICBwcml2YXRlOiBwcml2YXRlS2V5XG4gICAgICB9IDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldFB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0S2V5cygpKVsncHVibGljJ107XG4gIH1cblxuICBhc3luYyBnZXRQcml2YXRlS2V5KCkge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRLZXlzKCkpWydwcml2YXRlJ107XG4gIH1cblxuICBhc3luYyBkZWNyeXB0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJpdmF0ZUtleSgpLnRoZW4ocHJpdmF0ZUtleSA9PiB7XG4gICAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgICAvKlxuICAgICAgICAgIHdlYnBhY2tDaHVua05hbWU6IFwianNlbmNyeXB0XCIsXG4gICAgICAgICAgd2VicGFja1ByZWxvYWQ6IHRydWVcbiAgICAgICAgKi9cbiAgICAgICAgJ2pzZW5jcnlwdCcpLnRoZW4oKHsgZGVmYXVsdDogSnNlbmNyeXB0IH0pID0+IHtcbiAgICAgICAgY29uc3QganNlbmNyeXB0ID0gbmV3IEpzZW5jcnlwdCgpO1xuXG4gICAgICAgIGpzZW5jcnlwdC5zZXRQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc2VuY3J5cHQuZGVjcnlwdChwYXlsb2FkKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZvcmdlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImZvcmdlXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnM6IHtcbiAgICB1c2VQdXJlSmF2YVNjcmlwdDogZmFsc2VcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE4IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgYmFzZU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxuLyogVXRpbGl0aWVzIEFQSSAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnV0aWwgPSBmb3JnZS51dGlsIHx8IHt9O1xuXG4vLyBkZWZpbmUgc2V0SW1tZWRpYXRlIGFuZCBuZXh0VGlja1xuKGZ1bmN0aW9uKCkge1xuICAvLyB1c2UgbmF0aXZlIG5leHRUaWNrICh1bmxlc3Mgd2UncmUgaW4gd2VicGFjaylcbiAgLy8gd2VicGFjayAob3IgYmV0dGVyIG5vZGUtbGlicy1icm93c2VyIHBvbHlmaWxsKSBzZXRzIHByb2Nlc3MuYnJvd3Nlci5cbiAgLy8gdGhpcyB3YXkgd2UgY2FuIGRldGVjdCB3ZWJwYWNrIHByb3Blcmx5XG4gIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrICYmICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB1dGlsLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggbmV4dFRpY2ssIG9sZGVyIHZlcnNpb25zIG9mIG5vZGVcbiAgICAgIC8vICh0aG9zZSB3L28gc2V0SW1tZWRpYXRlKSB3b24ndCB0b3RhbGx5IHN0YXJ2ZSBJT1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSB1dGlsLm5leHRUaWNrO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwb2x5ZmlsbCBuZXh0VGljayB3aXRoIG5hdGl2ZSBzZXRJbW1lZGlhdGVcbiAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbW1lZGlhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpOyB9O1xuICAgIHV0aWwubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBOb3RlOiBBIHBvbHlmaWxsIHVwZ3JhZGUgcGF0dGVybiBpcyB1c2VkIGhlcmUgdG8gYWxsb3cgY29tYmluaW5nXG4gIHBvbHlmaWxscy4gRm9yIGV4YW1wbGUsIE11dGF0aW9uT2JzZXJ2ZXIgaXMgZmFzdCwgYnV0IGJsb2NrcyBVSSB1cGRhdGVzLFxuICBzbyBpdCBuZWVkcyB0byBhbGxvdyBVSSB1cGRhdGVzIHBlcmlvZGljYWxseSwgc28gaXQgZmFsbHMgYmFjayBvblxuICBwb3N0TWVzc2FnZSBvciBzZXRUaW1lb3V0LiAqL1xuXG4gIC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dFxuICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH07XG5cbiAgLy8gdXBncmFkZSBwb2x5ZmlsbCB0byB1c2UgcG9zdE1lc3NhZ2VcbiAgaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG1zZyA9ICdmb3JnZS5zZXRJbW1lZGlhdGUnO1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAvLyBvbmx5IHNlbmQgbWVzc2FnZSB3aGVuIG9uZSBoYXNuJ3QgYmVlbiBzZW50IGluXG4gICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICBpZihjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBpZihldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhID09PSBtc2cpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfVxuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgaWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gcG9seWZpbGwgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGF0dHIgPSB0cnVlO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0pLm9ic2VydmUoZGl2LCB7YXR0cmlidXRlczogdHJ1ZX0pO1xuICAgIHZhciBvbGRTZXRJbW1lZGlhdGUgPSB1dGlsLnNldEltbWVkaWF0ZTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZihEYXRlLm5vdygpIC0gbm93ID4gMTUpIHtcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgb2xkU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG9ic2VydmVyIHdoZW4gaXQgaGFzbid0IGJlZW4gdHJpZ2dlcmVkIGluXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHR1cm4gb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2EnLCBhdHRyID0gIWF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHV0aWwubmV4dFRpY2sgPSB1dGlsLnNldEltbWVkaWF0ZTtcbn0pKCk7XG5cbi8vIGNoZWNrIGlmIHJ1bm5pbmcgdW5kZXIgTm9kZS5qc1xudXRpbC5pc05vZGVqcyA9XG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcblxuLy8gZGVmaW5lIGlzQXJyYXlcbnV0aWwuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJcbnV0aWwuaXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJWaWV3XG51dGlsLmlzQXJyYXlCdWZmZXJWaWV3ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAmJiB1dGlsLmlzQXJyYXlCdWZmZXIoeC5idWZmZXIpICYmIHguYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgYSBiaXRzIHBhcmFtIGlzIDgsIDE2LCAyNCwgb3IgMzIuIFVzZWQgdG8gdmFsaWRhdGUgaW5wdXQgZm9yXG4gKiBhbGdvcml0aG1zIHdoZXJlIGJpdCBtYW5pcHVsYXRpb24sIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIGFuZC9vciBhbGdvcml0aG1cbiAqIGRlc2lnbiBvbmx5IGFsbG93IGZvciBieXRlIG9wZXJhdGlvbnMgb2YgYSBsaW1pdGVkIHNpemUuXG4gKlxuICogQHBhcmFtIG4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogVGhyb3cgRXJyb3IgaWYgbiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCaXRzUGFyYW0obikge1xuICBpZighKG4gPT09IDggfHwgbiA9PT0gMTYgfHwgbiA9PT0gMjQgfHwgbiA9PT0gMzIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IDgsIDE2LCAyNCwgb3IgMzIgYml0cyBzdXBwb3J0ZWQ6ICcgKyBuKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBzZXQgQnl0ZUJ1ZmZlciB0byBiZXN0IGF2YWlsYWJsZSBiYWNraW5nXG51dGlsLkJ5dGVCdWZmZXIgPSBCeXRlU3RyaW5nQnVmZmVyO1xuXG4vKiogQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBmb3IgYSBiaW5hcnkgc3RyaW5nIGJhY2tlZCBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gW2JdIHRoZSBieXRlcyB0byB3cmFwIChlaXRoZXIgZW5jb2RlZCBhcyBzdHJpbmcsIG9uZSBieXRlIHBlclxuICogICAgICAgICAgY2hhcmFjdGVyLCBvciBhcyBhbiBBcnJheUJ1ZmZlciBvciBUeXBlZCBBcnJheSkuXG4gKi9cbmZ1bmN0aW9uIEJ5dGVTdHJpbmdCdWZmZXIoYikge1xuICAvLyBUT0RPOiB1cGRhdGUgdG8gbWF0Y2ggRGF0YUJ1ZmZlciBBUElcblxuICAvLyB0aGUgZGF0YSBpbiB0aGlzIGJ1ZmZlclxuICB0aGlzLmRhdGEgPSAnJztcbiAgLy8gdGhlIHBvaW50ZXIgZm9yIHJlYWRpbmcgZnJvbSB0aGlzIGJ1ZmZlclxuICB0aGlzLnJlYWQgPSAwO1xuXG4gIGlmKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuZGF0YSA9IGI7XG4gIH0gZWxzZSBpZih1dGlsLmlzQXJyYXlCdWZmZXIoYikgfHwgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhiKSkge1xuICAgIGlmKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGIgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb252ZXJ0IG5hdGl2ZSBidWZmZXIgdG8gZm9yZ2UgYnVmZmVyXG4gICAgICAvLyBGSVhNRTogc3VwcG9ydCBuYXRpdmUgYnVmZmVycyBpbnRlcm5hbGx5IGluc3RlYWRcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhpcy5wdXRCeXRlKGFycltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihiIGluc3RhbmNlb2YgQnl0ZVN0cmluZ0J1ZmZlciB8fFxuICAgICh0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIuZGF0YSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgYi5yZWFkID09PSAnbnVtYmVyJykpIHtcbiAgICAvLyBjb3B5IGV4aXN0aW5nIGJ1ZmZlclxuICAgIHRoaXMuZGF0YSA9IGIuZGF0YTtcbiAgICB0aGlzLnJlYWQgPSBiLnJlYWQ7XG4gIH1cblxuICAvLyB1c2VkIGZvciB2OCBvcHRpbWl6YXRpb25cbiAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xufVxudXRpbC5CeXRlU3RyaW5nQnVmZmVyID0gQnl0ZVN0cmluZ0J1ZmZlcjtcblxuLyogTm90ZTogVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gZm9yIFY4LWJhc2VkIGJyb3dzZXJzLiBXaGVuIFY4IGNvbmNhdGVuYXRlc1xuICBhIHN0cmluZywgdGhlIHN0cmluZ3MgYXJlIG9ubHkgam9pbmVkIGxvZ2ljYWxseSB1c2luZyBhIFwiY29ucyBzdHJpbmdcIiBvclxuICBcImNvbnN0cnVjdGVkL2NvbmNhdGVuYXRlZCBzdHJpbmdcIi4gVGhlc2UgY29udGFpbmVycyBrZWVwIHJlZmVyZW5jZXMgdG8gb25lXG4gIGFub3RoZXIgYW5kIGNhbiByZXN1bHQgaW4gdmVyeSBsYXJnZSBtZW1vcnkgdXNhZ2UuIEZvciBleGFtcGxlLCBpZiBhIDJNQlxuICBzdHJpbmcgaXMgY29uc3RydWN0ZWQgYnkgY29uY2F0ZW5hdGluZyA0IGJ5dGVzIHRvZ2V0aGVyIGF0IGEgdGltZSwgdGhlXG4gIG1lbW9yeSB1c2FnZSB3aWxsIGJlIH40NE1COyBzbyB+MjJ4IGluY3JlYXNlLiBUaGUgc3RyaW5ncyBhcmUgb25seSBqb2luZWRcbiAgdG9nZXRoZXIgd2hlbiBhbiBvcGVyYXRpb24gcmVxdWlyaW5nIHRoZWlyIGpvaW5pbmcgdGFrZXMgcGxhY2UsIHN1Y2ggYXNcbiAgc3Vic3RyKCkuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYWRkaW5nIGRhdGEgdG8gdGhpcyBidWZmZXIgdG8gZW5zdXJlXG4gIHRoZXNlIHR5cGVzIG9mIHN0cmluZ3MgYXJlIHBlcmlvZGljYWxseSBqb2luZWQgdG8gcmVkdWNlIHRoZSBtZW1vcnlcbiAgZm9vdHByaW50LiAqL1xudmFyIF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCA9IDQwOTY7XG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nID0gZnVuY3Rpb24oeCkge1xuICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCArPSB4O1xuICBpZih0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCA+IF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCkge1xuICAgIC8vIHRoaXMgc3Vic3RyKCkgc2hvdWxkIGNhdXNlIHRoZSBjb25zdHJ1Y3RlZCBzdHJpbmcgdG8gam9pblxuICAgIHRoaXMuZGF0YS5zdWJzdHIoMCwgMSk7XG4gICAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShiKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyIE4gdGltZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyBvZiB2YWx1ZSBiIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgYiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gIHZhciBkID0gdGhpcy5kYXRhO1xuICB3aGlsZShuID4gMCkge1xuICAgIGlmKG4gJiAxKSB7XG4gICAgICBkICs9IGI7XG4gICAgfVxuICAgIG4gPj4+PSAxO1xuICAgIGlmKG4gPiAwKSB7XG4gICAgICBiICs9IGI7XG4gICAgfVxuICB9XG4gIHRoaXMuZGF0YSA9IGQ7XG4gIHRoaXMuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcobik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgKGFzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcpIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdGhpcy5kYXRhICs9IGJ5dGVzO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKGJ5dGVzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgVVRGLTE2IGVuY29kZWQgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyh1dGlsLmVuY29kZVV0Zjgoc3RyKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYW4gbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgYnl0ZXMgPSAnJztcbiAgZG8ge1xuICAgIG4gLT0gODtcbiAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IG4pICYgMHhGRik7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhieXRlcyk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgLy8gcHV0SW50IGNoZWNrcyBuXG4gIGlmKGkgPCAwKSB7XG4gICAgaSArPSAyIDw8IChuIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBnaXZlbiBidWZmZXIgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gcHV0IGludG8gdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnVmZmVyLmdldEJ5dGVzKCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBmcm9tIHRoaXMgYnVmZmVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IDEuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAyNCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNik7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAzKSA8PCAyNCk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlXG4gKiByZWFkIHBvaW50ZXIgYnkgY2VpbChuLzgpLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIHJ2YWwgPSAwO1xuICBkbyB7XG4gICAgLy8gVE9ETzogVXNlIChydmFsICogMHgxMDApIGlmIGFkZGluZyBzdXBwb3J0IGZvciAzMyB0byA1MyBiaXRzLlxuICAgIHJ2YWwgPSAocnZhbCA8PCA4KSArIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbiAgICBuIC09IDg7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciwgdXNpbmdcbiAqIHR3bydzIGNvbXBsZW1lbnQsIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0U2lnbmVkSW50ID0gZnVuY3Rpb24obikge1xuICAvLyBnZXRJbnQgY2hlY2tzIG5cbiAgdmFyIHggPSB0aGlzLmdldEludChuKTtcbiAgdmFyIG1heCA9IDIgPDwgKG4gLSAyKTtcbiAgaWYoeCA+PSBtYXgpIHtcbiAgICB4IC09IG1heCA8PCAxO1xuICB9XG4gIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlcyBvdXQgaW50byBhIFVURi04IHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIFVURi04IHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZihjb3VudCkge1xuICAgIC8vIHJlYWQgY291bnQgYnl0ZXNcbiAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpO1xuICAgIHRoaXMucmVhZCArPSBjb3VudDtcbiAgfSBlbHNlIGlmKGNvdW50ID09PSAwKSB7XG4gICAgcnZhbCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgYWxsIGJ5dGVzLCBvcHRpbWl6ZSB0byBvbmx5IGNvcHkgd2hlbiBuZWVkZWRcbiAgICBydmFsID0gKHRoaXMucmVhZCA9PT0gMCkgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYnl0ZXMgZnJvbSB0aGlzIGJ1ZmZlciB3aXRob3V0IG1vZGlmeWluZ1xuICogdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZXQsIG9taXQgdG8gZ2V0IGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgc3RyaW5nIGZ1bGwgb2YgVVRGLTggZW5jb2RlZCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgcmV0dXJuICh0eXBlb2YoY291bnQpID09PSAndW5kZWZpbmVkJyA/XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCkgOlxuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyBpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cigwLCB0aGlzLnJlYWQgKyBpKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShiKSArXG4gICAgdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQgKyBpICsgMSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5kYXRhLmxlbmd0aCAtIDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjb3B5LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGMgPSB1dGlsLmNyZWF0ZUJ1ZmZlcih0aGlzLmRhdGEpO1xuICBjLnJlYWQgPSB0aGlzLnJlYWQ7XG4gIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9ICcnO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hvcnRlbnMgdGhpcyBidWZmZXIgYnkgdHJpbWluZyBieXRlcyBvZmYgb2YgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byB0cmltIG9mZi5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoKCkgLSBjb3VudCk7XG4gIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHIodGhpcy5yZWFkLCBsZW4pO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYiA9IHRoaXMuZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmKGIgPCAxNikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgVVRGLTE2IHN0cmluZyAoc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICpcbiAqIEByZXR1cm4gYSBVVEYtMTYgc3RyaW5nLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgodGhpcy5ieXRlcygpKTtcbn07XG5cbi8qKiBFbmQgQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqIEJ1ZmZlciB3L1VJbnQ4QXJyYXkgYmFja2luZyAqL1xuXG4vKipcbiAqIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxuICpcbiAqIENvbnN0cnVjdG9yIGZvciBhbiBBcnJheUJ1ZmZlci1iYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogVGhlIGJ1ZmZlciBtYXkgYmUgY29uc3RydWN0ZWQgZnJvbSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBhXG4gKiBUeXBlZEFycmF5LlxuICpcbiAqIElmIGEgc3RyaW5nIGlzIGdpdmVuLCBpdHMgZW5jb2Rpbmcgc2hvdWxkIGJlIHByb3ZpZGVkIGFzIGFuIG9wdGlvbixcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGRlZmF1bHQgdG8gJ2JpbmFyeScuIEEgJ2JpbmFyeScgc3RyaW5nIGlzIGVuY29kZWQgc3VjaFxuICogdGhhdCBlYWNoIGNoYXJhY3RlciBpcyBvbmUgYnl0ZSBpbiBsZW5ndGggYW5kIHNpemUuXG4gKlxuICogSWYgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBUeXBlZEFycmF5IGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWRcbiAqICpkaXJlY3RseSogd2l0aG91dCBhbnkgY29weWluZy4gTm90ZSB0aGF0LCBpZiBhIHdyaXRlIHRvIHRoZSBidWZmZXIgcmVxdWlyZXNcbiAqIG1vcmUgc3BhY2UsIHRoZSBidWZmZXIgd2lsbCBhbGxvY2F0ZSBhIG5ldyBiYWNraW5nIEFycmF5QnVmZmVyIHRvXG4gKiBhY2NvbW1vZGF0ZS4gVGhlIHN0YXJ0aW5nIHJlYWQgYW5kIHdyaXRlIG9mZnNldHMgZm9yIHRoZSBidWZmZXIgbWF5IGJlXG4gKiBnaXZlbiBhcyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBbYl0gdGhlIGluaXRpYWwgYnl0ZXMgZm9yIHRoaXMgYnVmZmVyLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW3JlYWRPZmZzZXRdIHRoZSBzdGFydGluZyByZWFkIG9mZnNldCB0byB1c2UgKGRlZmF1bHQ6IDApLlxuICogICAgICAgICAgW3dyaXRlT2Zmc2V0XSB0aGUgc3RhcnRpbmcgd3JpdGUgb2Zmc2V0IHRvIHVzZSAoZGVmYXVsdDogdGhlXG4gKiAgICAgICAgICAgIGxlbmd0aCBvZiB0aGUgZmlyc3QgcGFyYW1ldGVyKS5cbiAqICAgICAgICAgIFtncm93U2l6ZV0gdGhlIG1pbmltdW0gYW1vdW50LCBpbiBieXRlcywgdG8gZ3JvdyB0aGUgYnVmZmVyIGJ5IHRvXG4gKiAgICAgICAgICAgIGFjY29tbW9kYXRlIHdyaXRlcyAoZGVmYXVsdDogMTAyNCkuXG4gKiAgICAgICAgICBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyAoJ2JpbmFyeScsICd1dGY4JywgJ3V0ZjE2JywgJ2hleCcpIGZvciB0aGVcbiAqICAgICAgICAgICAgZmlyc3QgcGFyYW1ldGVyLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICovXG5mdW5jdGlvbiBEYXRhQnVmZmVyKGIsIG9wdGlvbnMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvaW50ZXJzIGZvciByZWFkIGZyb20vd3JpdGUgdG8gYnVmZmVyXG4gIHRoaXMucmVhZCA9IG9wdGlvbnMucmVhZE9mZnNldCB8fCAwO1xuICB0aGlzLmdyb3dTaXplID0gb3B0aW9ucy5ncm93U2l6ZSB8fCAxMDI0O1xuXG4gIHZhciBpc0FycmF5QnVmZmVyID0gdXRpbC5pc0FycmF5QnVmZmVyKGIpO1xuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGIpO1xuICBpZihpc0FycmF5QnVmZmVyIHx8IGlzQXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgLy8gdXNlIEFycmF5QnVmZmVyIGRpcmVjdGx5XG4gICAgaWYoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGp1c3QgcmVhZC93cml0ZSBvZmZzZXQgYmFzZWQgb24gdGhlIHR5cGUgb2Ygdmlld1xuICAgICAgLy8gb3Igc3BlY2lmeSB0aGF0IHRoaXMgbXVzdCBiZSBkb25lIGluIHRoZSBvcHRpb25zIC4uLiB0aGF0IHRoZVxuICAgICAgLy8gb2Zmc2V0cyBhcmUgYnl0ZS1iYXNlZFxuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMud3JpdGUgPSAoJ3dyaXRlT2Zmc2V0JyBpbiBvcHRpb25zID9cbiAgICAgIG9wdGlvbnMud3JpdGVPZmZzZXQgOiB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB0byBlbXB0eSBhcnJheSBidWZmZXIgYW5kIGFkZCBhbnkgZ2l2ZW4gYnl0ZXMgdXNpbmcgcHV0Qnl0ZXNcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIHRoaXMud3JpdGUgPSAwO1xuXG4gIGlmKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wdXRCeXRlcyhiKTtcbiAgfVxuXG4gIGlmKCd3cml0ZU9mZnNldCcgaW4gb3B0aW9ucykge1xuICAgIHRoaXMud3JpdGUgPSBvcHRpb25zLndyaXRlT2Zmc2V0O1xuICB9XG59XG51dGlsLkRhdGFCdWZmZXIgPSBEYXRhQnVmZmVyO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndyaXRlIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogRW5zdXJlcyB0aGlzIGJ1ZmZlciBoYXMgZW5vdWdoIGVtcHR5IHNwYWNlIHRvIGFjY29tbW9kYXRlIHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGJ5dGVzLiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgbWF5IGJlIGdpdmVuIHRoYXQgaW5kaWNhdGVzIGEgbWluaW11bVxuICogYW1vdW50IHRvIGdyb3cgdGhlIGJ1ZmZlciBpZiBuZWNlc3NhcnkuIElmIHRoZSBwYXJhbWV0ZXIgaXMgbm90IGdpdmVuLFxuICogdGhlIGJ1ZmZlciB3aWxsIGJlIGdyb3duIGJ5IHNvbWUgcHJldmlvdXNseS1zcGVjaWZpZWQgZGVmYXVsdCBhbW91bnRcbiAqIG9yIGhldXJpc3RpYy5cbiAqXG4gKiBAcGFyYW0gYW1vdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gYWNjb21tb2RhdGUuXG4gKiBAcGFyYW0gW2dyb3dTaXplXSB0aGUgbWluaW11bSBhbW91bnQsIGluIGJ5dGVzLCB0byBncm93IHRoZSBidWZmZXIgYnkgaWZcbiAqICAgICAgICAgIG5lY2Vzc2FyeS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5hY2NvbW1vZGF0ZSA9IGZ1bmN0aW9uKGFtb3VudCwgZ3Jvd1NpemUpIHtcbiAgaWYodGhpcy5sZW5ndGgoKSA+PSBhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm93U2l6ZSA9IE1hdGgubWF4KGdyb3dTaXplIHx8IHRoaXMuZ3Jvd1NpemUsIGFtb3VudCk7XG5cbiAgLy8gZ3JvdyBidWZmZXJcbiAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KFxuICAgIHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5ieXRlT2Zmc2V0LCB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICsgZ3Jvd1NpemUpO1xuICBkc3Quc2V0KHNyYyk7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QuYnVmZmVyKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgxKTtcbiAgdGhpcy5kYXRhLnNldFVpbnQ4KHRoaXMud3JpdGUrKywgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUobik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB0aGlzLmRhdGEuc2V0VWludDgoYik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYnl0ZXMgaW4gdGhpcyBidWZmZXIuIFRoZSBieXRlcyBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcsIGFuXG4gKiBBcnJheUJ1ZmZlciwgYSBEYXRhVmlldywgb3IgYSBUeXBlZEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gcHV0LlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyICgnYmluYXJ5JywgJ3V0ZjgnLFxuICogICAgICAgICAgJ3V0ZjE2JywgJ2hleCcpLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcywgZW5jb2RpbmcpIHtcbiAgaWYodXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gc3JjLmJ5dGVMZW5ndGggLSBzcmMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmFjY29tbW9kYXRlKGxlbik7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLndyaXRlICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmKHV0aWwuaXNBcnJheUJ1ZmZlcihieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIHRoaXMuYWNjb21tb2RhdGUoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyKTtcbiAgICBkc3Quc2V0KHNyYywgdGhpcy53cml0ZSk7XG4gICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGJ5dGVzIGlzIGEgdXRpbC5EYXRhQnVmZmVyIG9yIGVxdWl2YWxlbnRcbiAgaWYoYnl0ZXMgaW5zdGFuY2VvZiB1dGlsLkRhdGFCdWZmZXIgfHxcbiAgICAodHlwZW9mIGJ5dGVzID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBieXRlcy5yZWFkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYnl0ZXMud3JpdGUgPT09ICdudW1iZXInICYmXG4gICAgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcy5kYXRhKSkpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuZGF0YS5ieXRlTGVuZ3RoLCBieXRlcy5yZWFkLCBieXRlcy5sZW5ndGgoKSk7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmRhdGEuYnl0ZUxlbmd0aCwgdGhpcy53cml0ZSk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMud3JpdGUgKz0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZihieXRlcyBpbnN0YW5jZW9mIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlcikge1xuICAgIC8vIGNvcHkgYmluYXJ5IHN0cmluZyBhbmQgcHJvY2VzcyBhcyB0aGUgc2FtZSBhcyBhIHN0cmluZyBwYXJhbWV0ZXIgYmVsb3dcbiAgICBieXRlcyA9IGJ5dGVzLmRhdGE7XG4gICAgZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgfVxuXG4gIC8vIHN0cmluZyBjb252ZXJzaW9uXG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ2JpbmFyeSc7XG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmlldztcblxuICAgIC8vIGRlY29kZSBmcm9tIHN0cmluZ1xuICAgIGlmKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gMikpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5oZXguZGVjb2RlKGJ5dGVzLCB2aWV3LCB0aGlzLndyaXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZihlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJ5dGVzLmxlbmd0aCAvIDQpICogMyk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTggYnl0ZXNcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAvLyBlbmNvZGUgYXMgVVRGLTggdGhlbiBkZWNvZGUgc3RyaW5nIGFzIHJhdyBiaW5hcnlcbiAgICAgIGJ5dGVzID0gdXRpbC5lbmNvZGVVdGY4KGJ5dGVzKTtcbiAgICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIHN0cmluZyBhcyByYXcgYmluYXJ5XG4gICAgaWYoZW5jb2RpbmcgPT09ICdiaW5hcnknIHx8IGVuY29kaW5nID09PSAncmF3Jykge1xuICAgICAgLy8gb25lIGJ5dGUgcGVyIGNoYXJhY3RlclxuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShieXRlcy5sZW5ndGgpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5yYXcuZGVjb2RlKHZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTE2IGJ5dGVzXG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGYxNicpIHtcbiAgICAgIC8vIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCAqIDIpO1xuICAgICAgdmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC50ZXh0LnV0ZjE2LmVuY29kZSh2aWV3KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxuXG4gIHRocm93IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogJyArIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogUHV0cyB0aGUgZ2l2ZW4gYnVmZmVyIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHB1dCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHRoaXMucHV0Qnl0ZXMoYnVmZmVyKTtcbiAgYnVmZmVyLmNsZWFyKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyBmb3IgdGhlIHN0cmluZyAoZGVmYXVsdDogJ3V0ZjE2JykuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoc3RyLCAndXRmMTYnKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpID4+IDggJiAweEZGRkYpO1xuICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlLCBpID4+IDE2ICYgMHhGRik7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGEuc2V0SW50MzIodGhpcy53cml0ZSwgaSk7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDB4RkYpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgMHhGRkZGLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGksIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGFuIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuIC8gOCk7XG4gIGRvIHtcbiAgICBuIC09IDg7XG4gICAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSsrLCAoaSA+PiBuKSAmIDB4RkYpO1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHRoaXMuYWNjb21tb2RhdGUobiAvIDgpO1xuICBpZihpIDwgMCkge1xuICAgIGkgKz0gMiA8PCAobiAtIDEpO1xuICB9XG4gIHJldHVybiB0aGlzLnB1dEludChpLCBuKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgZnJvbSB0aGlzIGJ1ZmZlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSAxLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQsIHRydWUpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQgKyAxLCB0cnVlKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkLCB0cnVlKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGVcbiAqIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICAvLyBUT0RPOiBVc2UgKHJ2YWwgKiAweDEwMCkgaWYgYWRkaW5nIHN1cHBvcnQgZm9yIDMzIHRvIDUzIGJpdHMuXG4gICAgcnZhbCA9IChydmFsIDw8IDgpICsgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xuICAgIG4gLT0gODtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLCB1c2luZ1xuICogdHdvJ3MgY29tcGxlbWVudCwgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIC8vIGdldEludCBjaGVja3MgblxuICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICB2YXIgbWF4ID0gMiA8PCAobiAtIDIpO1xuICBpZih4ID49IG1heCkge1xuICAgIHggLT0gbWF4IDw8IDE7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIFJlYWRzIGJ5dGVzIG91dCBpbnRvIGEgVVRGLTggc3RyaW5nIGFuZCBjbGVhcnMgdGhlbSBmcm9tIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZCwgdW5kZWZpbmVkIG9yIG51bGwgZm9yIGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgVVRGLTggc3RyaW5nIG9mIGJ5dGVzLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlIHRoaXMgbWV0aG9kLCBpdCBpcyBwb29ybHkgbmFtZWQgYW5kXG4gIC8vIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScpIHJlcGxhY2VzIGl0XG4gIC8vIGFkZCBhIHRvVHlwZWRBcnJheSgpL3RvQXJyYXlCdWZmZXIoKSBmdW5jdGlvblxuICB2YXIgcnZhbDtcbiAgaWYoY291bnQpIHtcbiAgICAvLyByZWFkIGNvdW50IGJ5dGVzXG4gICAgY291bnQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBjb3VudCk7XG4gICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB0aGlzLnJlYWQgKz0gY291bnQ7XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMCkge1xuICAgIHJ2YWwgPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGFsbCBieXRlcywgb3B0aW1pemUgdG8gb25seSBjb3B5IHdoZW4gbmVlZGVkXG4gICAgcnZhbCA9ICh0aGlzLnJlYWQgPT09IDApID8gdGhpcy5kYXRhIDogdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dCBtb2RpZnlpbmdcbiAqIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIFVURi04IGVuY29kZWQgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkLCBhZGQgXCJnZXRTdHJpbmcoKVwiXG4gIHJldHVybiAodHlwZW9mKGNvdW50KSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpIDpcbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEuc2V0VWludDgoaSwgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMud3JpdGUgLSAxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY29weS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgdXRpbC5EYXRhQnVmZmVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLnJlYWQpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QpO1xuICAgIHRoaXMud3JpdGUgLT0gdGhpcy5yZWFkO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0ZW5zIHRoaXMgYnVmZmVyIGJ5IHRyaW1pbmcgYnl0ZXMgb2ZmIG9mIHRoZSBlbmQgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gdHJpbSBvZmYuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHRoaXMud3JpdGUgPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEuYnl0ZUxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGIgPSB0aGlzLmRhdGEuZ2V0VWludDgoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBzdHJpbmcsIHVzaW5nIHRoZSBnaXZlbiBlbmNvZGluZy4gSWYgbm9cbiAqIGVuY29kaW5nIGlzIGdpdmVuLCAndXRmOCcgKFVURi04KSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyB0byB1c2U6ICdiaW5hcnknLCAndXRmOCcsICd1dGYxNicsICdoZXgnLFxuICogICAgICAgICAgJ2Jhc2U2NCcgKGRlZmF1bHQ6ICd1dGY4JykuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgdGhpcy5yZWFkLCB0aGlzLmxlbmd0aCgpKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gZW5jb2RlIHRvIHN0cmluZ1xuICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LnJhdy5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmhleC5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUodmlldyk7XG4gIH1cblxuICAvLyBkZWNvZGUgdG8gdGV4dFxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgcmV0dXJuIHV0aWwudGV4dC51dGY4LmRlY29kZSh2aWV3KTtcbiAgfVxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmMTYuZGVjb2RlKHZpZXcpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9VSW50OEFycmF5IGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYnVmZmVyIHRoYXQgc3RvcmVzIGJ5dGVzLiBBIHZhbHVlIG1heSBiZSBnaXZlbiB0byBwdXQgaW50byB0aGVcbiAqIGJ1ZmZlciB0aGF0IGlzIGVpdGhlciBhIHN0cmluZyBvZiBieXRlcyBvciBhIFVURi0xNiBzdHJpbmcgdGhhdCB3aWxsXG4gKiBiZSBlbmNvZGVkIHVzaW5nIFVURi04ICh0byBkbyB0aGUgbGF0dGVyLCBzcGVjaWZ5ICd1dGY4JyBhcyB0aGUgZW5jb2RpbmcpLlxuICpcbiAqIEBwYXJhbSBbaW5wdXRdIHRoZSBieXRlcyB0byB3cmFwIChhcyBhIHN0cmluZykgb3IgYSBVVEYtMTYgc3RyaW5nIHRvIGVuY29kZVxuICogICAgICAgICAgYXMgVVRGLTguXG4gKiBAcGFyYW0gW2VuY29kaW5nXSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICovXG51dGlsLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGlucHV0LCBlbmNvZGluZykge1xuICAvLyBUT0RPOiBkZXByZWNhdGUsIHVzZSBuZXcgQnl0ZUJ1ZmZlcigpIGluc3RlYWRcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAncmF3JztcbiAgaWYoaW5wdXQgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgaW5wdXQgPSB1dGlsLmVuY29kZVV0ZjgoaW5wdXQpO1xuICB9XG4gIHJldHVybiBuZXcgdXRpbC5CeXRlQnVmZmVyKGlucHV0KTtcbn07XG5cbi8qKlxuICogRmlsbHMgYSBzdHJpbmcgd2l0aCBhIHBhcnRpY3VsYXIgdmFsdWUuIElmIHlvdSB3YW50IHRoZSBzdHJpbmcgdG8gYmUgYSBieXRlXG4gKiBzdHJpbmcsIHBhc3MgaW4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGVCeXRlKS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY2hhcmFjdGVyIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoLCB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICogICAgICAgICAgdG8gZmlsbCB0aGUgc3RyaW5nIHdpdGggYSBieXRlIHZhbHVlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHZhbHVlIGMgdG8gZmlsbCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbGxlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZmlsbFN0cmluZyA9IGZ1bmN0aW9uKGMsIG4pIHtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgcyArPSBjO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYyArPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBwZXIgYnl0ZSBYT1IgYmV0d2VlbiB0d28gYnl0ZSBzdHJpbmdzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYVxuICogc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzMSBmaXJzdCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gczIgc2Vjb25kIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gWE9SLlxuICpcbiAqIEByZXR1cm4gdGhlIFhPUidkIHJlc3VsdC5cbiAqL1xudXRpbC54b3JCeXRlcyA9IGZ1bmN0aW9uKHMxLCBzMiwgbikge1xuICB2YXIgczMgPSAnJztcbiAgdmFyIGIgPSAnJztcbiAgdmFyIHQgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB2YXIgYyA9IDA7XG4gIGZvcig7IG4gPiAwOyAtLW4sICsraSkge1xuICAgIGIgPSBzMS5jaGFyQ29kZUF0KGkpIF4gczIuY2hhckNvZGVBdChpKTtcbiAgICBpZihjID49IDEwKSB7XG4gICAgICBzMyArPSB0O1xuICAgICAgdCA9ICcnO1xuICAgICAgYyA9IDA7XG4gICAgfVxuICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICArK2M7XG4gIH1cbiAgczMgKz0gdDtcbiAgcmV0dXJuIHMzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5oZXhUb0J5dGVzID0gZnVuY3Rpb24oaGV4KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmRlY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBydmFsID0gJyc7XG4gIHZhciBpID0gMDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEgPT0gMSkge1xuICAgIC8vIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgY29udmVydCBmaXJzdCBjaGFyYWN0ZXIgYWxvbmVcbiAgICBpID0gMTtcbiAgICBydmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4WzBdLCAxNikpO1xuICB9XG4gIC8vIGNvbnZlcnQgMiBjaGFyYWN0ZXJzICgxIGJ5dGUpIGF0IGEgdGltZVxuICBmb3IoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gaGV4LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5ieXRlc1RvSGV4ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5oZXguZW5jb2RlIGluc3RlYWQuXCJcbiAgcmV0dXJuIHV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKS50b0hleCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiAzMi1iaXQgaW50ZWdlciB0byA0LWJpZy1lbmRpYW4gYnl0ZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGkgdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBzdHJpbmcuXG4gKi9cbnV0aWwuaW50MzJUb0J5dGVzID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLy8gYmFzZTY0IGNoYXJhY3RlcnMsIHJldmVyc2UgbWFwcGluZ1xudmFyIF9iYXNlNjQgPVxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xudmFyIF9iYXNlNjRJZHggPSBbXG4vKjQzIC00MyA9IDAqL1xuLyonKycsICAxLCAgMiwgIDMsJy8nICovXG4gICA2MiwgLTEsIC0xLCAtMSwgNjMsXG5cbi8qJzAnLCcxJywnMicsJzMnLCc0JywnNScsJzYnLCc3JywnOCcsJzknICovXG4gICA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksIDYwLCA2MSxcblxuLyoxNSwgMTYsIDE3LCc9JywgMTksIDIwLCAyMSAqL1xuICAtMSwgLTEsIC0xLCA2NCwgLTEsIC0xLCAtMSxcblxuLyo2NSAtIDQzID0gMjIqL1xuLyonQScsJ0InLCdDJywnRCcsJ0UnLCdGJywnRycsJ0gnLCdJJywnSicsJ0snLCdMJywnTScsICovXG4gICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLFxuXG4vKidOJywnTycsJ1AnLCdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJyAqL1xuICAgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsXG5cbi8qOTEgLSA0MyA9IDQ4ICovXG4vKjQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMgKi9cbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcblxuLyo5NyAtIDQzID0gNTQqL1xuLyonYScsJ2InLCdjJywnZCcsJ2UnLCdmJywnZycsJ2gnLCdpJywnaicsJ2snLCdsJywnbScgKi9cbiAgIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LFxuXG4vKiduJywnbycsJ3AnLCdxJywncicsJ3MnLCd0JywndScsJ3YnLCd3JywneCcsJ3knLCd6JyAqL1xuICAgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTFcbl07XG5cbi8vIGJhc2U1OCBjaGFyYWN0ZXJzIChCaXRjb2luIGFscGhhYmV0KVxudmFyIF9iYXNlNTggPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG5cbi8qKlxuICogQmFzZTY0IGVuY29kZXMgYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcyB0byBiYXNlNjQtZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dC5cbiAqL1xudXRpbC5lbmNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQgZGVjb2RlcyBhIHN0cmluZyBpbnRvIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlNjQtZW5jb2RlZCBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZGVjb2RlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgaW5zdGVhZC5cIlxuXG4gIC8vIHJlbW92ZSBhbGwgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcblxuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCkpO1xuICAgIGlmKGVuYzMgIT09IDY0KSB7XG4gICAgICAvLyBkZWNvZGVkIGF0IGxlYXN0IDIgYnl0ZXNcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFVURi04IGVuY29kZXMgdGhlIGdpdmVuIFVURi0xNiBlbmNvZGVkIHN0cmluZyAoYSBzdGFuZGFyZCBKYXZhU2NyaXB0XG4gKiBzdHJpbmcpLiBOb24tQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlIGVuY29kZWQgYXMgbXVsdGlwbGUgYnl0ZXMgYWNjb3JkaW5nXG4gKiB0byBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmVuY29kZVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIFVURi04IGVuY29kZWQgc3RyaW5nIGludG8gYSBVVEYtMTYgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgVVRGLTE2IGVuY29kZWQgc3RyaW5nIChzdGFuZGFyZCBKYXZhU2NyaXB0IHN0cmluZykuXG4gKi9cbnV0aWwuZGVjb2RlVXRmOCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn07XG5cbi8vIGJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyB0b29sc1xuLy8gRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG51dGlsLmJpbmFyeSA9IHtcbiAgcmF3OiB7fSxcbiAgaGV4OiB7fSxcbiAgYmFzZTY0OiB7fSxcbiAgYmFzZTU4OiB7fSxcbiAgYmFzZU4gOiB7XG4gICAgZW5jb2RlOiBiYXNlTi5lbmNvZGUsXG4gICAgZGVjb2RlOiBiYXNlTi5kZWNvZGVcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgVWludDhBcnJheSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy4gVGhpcyBlbmNvZGluZyB1c2VzXG4gKiBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1IGZvciBlYWNoIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5iaW5hcnkucmF3LmVuY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuIFRoaXMgZW5jb2RpbmcgdXNlc1xuICogYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgYmluYXJ5LWVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LnJhdy5kZWNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSAnYmluYXJ5JyBzdHJpbmcsIEFycmF5QnVmZmVyLCBEYXRhVmlldywgVHlwZWRBcnJheSwgb3JcbiAqIEJ5dGVCdWZmZXIgYXMgYSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuYmluYXJ5LmhleC5lbmNvZGUgPSB1dGlsLmJ5dGVzVG9IZXg7XG5cbi8qKlxuICogRGVjb2RlcyBhIGhleC1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGhleCB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5oZXguZGVjb2RlID0gZnVuY3Rpb24oaGV4LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBpID0gMCwgaiA9IG9mZnNldDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEpIHtcbiAgICAvLyBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGNvbnZlcnQgZmlyc3QgY2hhcmFjdGVyIGFsb25lXG4gICAgaSA9IDE7XG4gICAgb3V0W2orK10gPSBwYXJzZUludChoZXhbMF0sIDE2KTtcbiAgfVxuICAvLyBjb252ZXJ0IDIgY2hhcmFjdGVycyAoMSBieXRlKSBhdCBhIHRpbWVcbiAgZm9yKDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgIG91dFtqKytdID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEJhc2U2NC1lbmNvZGVzIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dCBzdHJpbmcuXG4gKi9cbnV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCBpbnB1dC5ieXRlTGVuZ3RoKSB7XG4gICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgY2hyMyA9IGlucHV0W2krK107XG5cbiAgICAvLyBlbmNvZGUgNCBjaGFyYWN0ZXIgZ3JvdXBcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KGNocjEgPj4gMik7XG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpKTtcbiAgICBpZihpc05hTihjaHIyKSkge1xuICAgICAgbGluZSArPSAnPT0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKTtcbiAgICAgIGxpbmUgKz0gaXNOYU4oY2hyMykgPyAnPScgOiBfYmFzZTY0LmNoYXJBdChjaHIzICYgNjMpO1xuICAgIH1cblxuICAgIGlmKG1heGxpbmUgJiYgbGluZS5sZW5ndGggPiBtYXhsaW5lKSB7XG4gICAgICBvdXRwdXQgKz0gbGluZS5zdWJzdHIoMCwgbWF4bGluZSkgKyAnXFxyXFxuJztcbiAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cihtYXhsaW5lKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0ICs9IGxpbmU7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZTY0LWVuY29kZWQgaW5wdXQgc3RyaW5nLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDQpICogMyk7XG4gIH1cblxuICAvLyByZW1vdmUgYWxsIG5vbi1iYXNlNjQgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dFtqKytdID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICBpZihlbmMzICE9PSA2NCkge1xuICAgICAgLy8gZGVjb2RlZCBhdCBsZWFzdCAyIGJ5dGVzXG4gICAgICBvdXRbaisrXSA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xuICAgICAgaWYoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgLy8gZGVjb2RlZCAzIGJ5dGVzXG4gICAgICAgIG91dFtqKytdID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSByZXN1bHQgaXMgdGhlIGV4YWN0IGRlY29kZWQgbGVuZ3RoXG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQuc3ViYXJyYXkoMCwgaik7XG59O1xuXG4vLyBhZGQgc3VwcG9ydCBmb3IgYmFzZTU4IGVuY29kaW5nL2RlY29kaW5nIHdpdGggQml0Y29pbiBhbHBoYWJldFxudXRpbC5iaW5hcnkuYmFzZTU4LmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlTi5lbmNvZGUoaW5wdXQsIF9iYXNlNTgsIG1heGxpbmUpO1xufTtcbnV0aWwuYmluYXJ5LmJhc2U1OC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZU4uZGVjb2RlKGlucHV0LCBfYmFzZTU4LCBtYXhsaW5lKTtcbn07XG5cbi8vIHRleHQgZW5jb2RpbmcvZGVjb2RpbmcgdG9vbHNcbi8vIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxudXRpbC50ZXh0ID0ge1xuICB1dGY4OiB7fSxcbiAgdXRmMTY6IHt9XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtOCBpbiBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwudGV4dC51dGY4LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgc3RyID0gdXRpbC5lbmNvZGVVdGY4KHN0cik7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi04IGNvbnRlbnRzIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgVWludDhBcnJheSB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAqL1xudXRpbC50ZXh0LnV0ZjguZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWwuZGVjb2RlVXRmOChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKSk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtMTYgaW4gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLnRleHQudXRmMTYuZW5jb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCAqIDIpO1xuICB9XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KG91dC5idWZmZXIpO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIHZhciBrID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgdmlld1trKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaiArPSAyO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi0xNiBjb250ZW50cyBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gKi9cbnV0aWwudGV4dC51dGYxNi5kZWNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnl0ZXMuYnVmZmVyKSk7XG59O1xuXG4vKipcbiAqIERlZmxhdGVzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIGEgZmxhc2ggaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBieXRlcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSByYXcgdHJ1ZSB0byByZXR1cm4gb25seSByYXcgZGVmbGF0ZSBkYXRhLCBmYWxzZSB0byBpbmNsdWRlIHpsaWJcbiAqICAgICAgICAgIGhlYWRlciBhbmQgdHJhaWxlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLlxuICovXG51dGlsLmRlZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgYnl0ZXMgPSB1dGlsLmRlY29kZTY0KGFwaS5kZWZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsKTtcblxuICAvLyBzdHJpcCB6bGliIGhlYWRlciBhbmQgdHJhaWxlciBpZiBuZWNlc3NhcnlcbiAgaWYocmF3KSB7XG4gICAgLy8gemxpYiBoZWFkZXIgaXMgMiBieXRlcyAoQ01GLEZMRykgd2hlcmUgRkxHIGluZGljYXRlcyB0aGF0XG4gICAgLy8gdGhlcmUgaXMgYSA0LWJ5dGUgRElDVCAoYWxkZXItMzIpIGJsb2NrIGJlZm9yZSB0aGUgZGF0YSBpZlxuICAgIC8vIGl0cyA1dGggYml0IGlzIHNldFxuICAgIHZhciBzdGFydCA9IDI7XG4gICAgdmFyIGZsZyA9IGJ5dGVzLmNoYXJDb2RlQXQoMSk7XG4gICAgaWYoZmxnICYgMHgyMCkge1xuICAgICAgc3RhcnQgPSA2O1xuICAgIH1cbiAgICAvLyB6bGliIHRyYWlsZXIgaXMgNCBieXRlcyBvZiBhZGxlci0zMlxuICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKHN0YXJ0LCBieXRlcy5sZW5ndGggLSA0KTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn07XG5cbi8qKlxuICogSW5mbGF0ZXMgdGhlIGdpdmVuIGRhdGEgdXNpbmcgYSBmbGFzaCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBkYXRhLlxuICogQHBhcmFtIHJhdyB0cnVlIGlmIHRoZSBpbmNvbWluZyBkYXRhIGhhcyBubyB6bGliIGhlYWRlciBvciB0cmFpbGVyIGFuZCBpc1xuICogICAgICAgICAgcmF3IERFRkxBVEUgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbmZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLCBudWxsIG9uIGVycm9yLlxuICovXG51dGlsLmluZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgLy8gVE9ETzogYWRkIHpsaWIgaGVhZGVyIGFuZCB0cmFpbGVyIGlmIG5lY2Vzc2FyeS9wb3NzaWJsZVxuICB2YXIgcnZhbCA9IGFwaS5pbmZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsO1xuICByZXR1cm4gKHJ2YWwgPT09IG51bGwpID8gbnVsbCA6IHV0aWwuZGVjb2RlNjQocnZhbCk7XG59O1xuXG4vKipcbiAqIFNldHMgYSBzdG9yYWdlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0gb2JqIHRoZSBzdG9yYWdlIG9iamVjdCwgbnVsbCB0byByZW1vdmUuXG4gKi9cbnZhciBfc2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQsIG9iaikge1xuICBpZighYXBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gIH1cblxuICB2YXIgcnZhbDtcbiAgaWYob2JqID09PSBudWxsKSB7XG4gICAgcnZhbCA9IGFwaS5yZW1vdmVJdGVtKGlkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBqc29uLWVuY29kZSBhbmQgYmFzZTY0LWVuY29kZSBvYmplY3RcbiAgICBvYmogPSB1dGlsLmVuY29kZTY0KEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIHJ2YWwgPSBhcGkuc2V0SXRlbShpZCwgb2JqKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBwb3RlbnRpYWwgZmxhc2ggZXJyb3JcbiAgaWYodHlwZW9mKHJ2YWwpICE9PSAndW5kZWZpbmVkJyAmJiBydmFsLnJ2YWwgIT09IHRydWUpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocnZhbC5lcnJvci5tZXNzYWdlKTtcbiAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgZXJyb3IubmFtZSA9IHJ2YWwuZXJyb3IubmFtZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIGEgc3RvcmFnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIHN0b3JhZ2Ugb2JqZWN0IGVudHJ5IG9yIG51bGwgaWYgbm9uZSBleGlzdHMuXG4gKi9cbnZhciBfZ2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQpIHtcbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBleGlzdGluZyBlbnRyeVxuICB2YXIgcnZhbCA9IGFwaS5nZXRJdGVtKGlkKTtcblxuICAvKiBOb3RlOiBXZSBjaGVjayBhcGkuaW5pdCBiZWNhdXNlIHdlIGNhbid0IGRvIChhcGkgPT0gbG9jYWxTdG9yYWdlKVxuICAgIG9uIElFIGJlY2F1c2Ugb2YgXCJDbGFzcyBkb2Vzbid0IHN1cHBvcnQgQXV0b21hdGlvblwiIGV4Y2VwdGlvbi4gT25seVxuICAgIHRoZSBmbGFzaCBhcGkgaGFzIGFuIGluaXQgbWV0aG9kIHNvIHRoaXMgd29ya3MgdG9vLCBidXQgd2UgbmVlZCBhXG4gICAgYmV0dGVyIHNvbHV0aW9uIGluIHRoZSBmdXR1cmUuICovXG5cbiAgLy8gZmxhc2ggcmV0dXJucyBpdGVtIHdyYXBwZWQgaW4gYW4gb2JqZWN0LCBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gIGlmKGFwaS5pbml0KSB7XG4gICAgaWYocnZhbC5ydmFsID09PSBudWxsKSB7XG4gICAgICBpZihydmFsLmVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihydmFsLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gbm8gZXJyb3IsIGJ1dCBhbHNvIG5vIGl0ZW1cbiAgICAgIHJ2YWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsID0gcnZhbC5ydmFsO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSBkZWNvZGluZ1xuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgLy8gYmFzZTY0LWRlY29kZSBhbmQganNvbi1kZWNvZGUgZGF0YVxuICAgIHJ2YWwgPSBKU09OLnBhcnNlKHV0aWwuZGVjb2RlNjQocnZhbCkpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFN0b3JlcyBhbiBpdGVtIGluIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKi9cbnZhciBfc2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgZGF0YSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogPT09IG51bGwpIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc3RvcmFnZSBvYmplY3RcbiAgICBvYmogPSB7fTtcbiAgfVxuICAvLyB1cGRhdGUga2V5XG4gIG9ialtrZXldID0gZGF0YTtcblxuICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgb2JqKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnZhciBfZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIHJ2YWwgPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIC8vIHJldHVybiBkYXRhIGF0IGtleVxuICAgIHJ2YWwgPSAoa2V5IGluIHJ2YWwpID8gcnZhbFtrZXldIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKi9cbnZhciBfcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogIT09IG51bGwgJiYga2V5IGluIG9iaikge1xuICAgIC8vIHJlbW92ZSBrZXlcbiAgICBkZWxldGUgb2JqW2tleV07XG5cbiAgICAvLyBzZWUgaWYgZW50cnkgaGFzIG5vIGtleXMgcmVtYWluaW5nXG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKGVtcHR5KSB7XG4gICAgICAvLyByZW1vdmUgZW50cnkgZW50aXJlbHkgaWYgbm8ga2V5cyBhcmUgbGVmdFxuICAgICAgb2JqID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqL1xudmFyIF9jbGVhckl0ZW1zID0gZnVuY3Rpb24oYXBpLCBpZCkge1xuICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBudWxsKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBzdG9yYWdlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBmdW5jIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICogQHBhcmFtIGFyZ3MgdGhlIGFyZ3VtZW50cyBmb3IgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIGxvY2F0aW9uIHRoZSBsb2NhdGlvbiBhcmd1bWVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXG4gKi9cbnZhciBfY2FsbFN0b3JhZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIGxvY2F0aW9uKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBkZWZhdWx0IHN0b3JhZ2UgdHlwZXNcbiAgaWYodHlwZW9mKGxvY2F0aW9uKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhdGlvbiA9IFsnd2ViJywgJ2ZsYXNoJ107XG4gIH1cblxuICAvLyBhcHBseSBzdG9yYWdlIHR5cGVzIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcbiAgdmFyIHR5cGU7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciBleGNlcHRpb24gPSBudWxsO1xuICBmb3IodmFyIGlkeCBpbiBsb2NhdGlvbikge1xuICAgIHR5cGUgPSBsb2NhdGlvbltpZHhdO1xuICAgIHRyeSB7XG4gICAgICBpZih0eXBlID09PSAnZmxhc2gnIHx8IHR5cGUgPT09ICdib3RoJykge1xuICAgICAgICBpZihhcmdzWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGFzaCBsb2NhbCBzdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSAodHlwZSA9PT0gJ2ZsYXNoJyk7XG4gICAgICB9XG4gICAgICBpZih0eXBlID09PSAnd2ViJyB8fCB0eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgYXJnc1swXSA9IGxvY2FsU3RvcmFnZTtcbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgIGV4Y2VwdGlvbiA9IGV4O1xuICAgIH1cbiAgICBpZihkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZighZG9uZSkge1xuICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTdG9yZXMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFRoZSBhdmFpbGFibGUgdHlwZXMgb2YgbG9jYWwgc3RvcmFnZSBpbmNsdWRlICdmbGFzaCcsICd3ZWInLCBhbmQgJ2JvdGgnLlxuICpcbiAqIFRoZSB0eXBlICdmbGFzaCcgcmVmZXJzIHRvIGZsYXNoIGxvY2FsIHN0b3JhZ2UgKFNoYXJlZE9iamVjdCkuIEluIG9yZGVyXG4gKiB0byB1c2UgZmxhc2ggbG9jYWwgc3RvcmFnZSwgdGhlICdhcGknIHBhcmFtZXRlciBtdXN0IGJlIHZhbGlkLiBUaGUgdHlwZVxuICogJ3dlYicgcmVmZXJzIHRvIFdlYlN0b3JhZ2UsIGlmIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci4gVGhlIHR5cGUgJ2JvdGgnXG4gKiByZWZlcnMgdG8gc3RvcmluZyB1c2luZyBib3RoICdmbGFzaCcgYW5kICd3ZWInLCBub3QganVzdCBvbmUgb3IgdGhlXG4gKiBvdGhlci5cbiAqXG4gKiBUaGUgbG9jYXRpb24gYXJyYXkgc2hvdWxkIGxpc3QgdGhlIHN0b3JhZ2UgdHlwZXMgdG8gdXNlIGluIG9yZGVyIG9mXG4gKiBwcmVmZXJlbmNlOlxuICpcbiAqIFsnZmxhc2gnXTogZmxhc2ggb25seSBzdG9yYWdlXG4gKiBbJ3dlYiddOiB3ZWIgb25seSBzdG9yYWdlXG4gKiBbJ2JvdGgnXTogdHJ5IHRvIHN0b3JlIGluIGJvdGhcbiAqIFsnZmxhc2gnLCd3ZWInXTogc3RvcmUgaW4gZmxhc2ggZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnd2ViJ1xuICogWyd3ZWInLCdmbGFzaCddOiBzdG9yZSBpbiB3ZWIgZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnZmxhc2gnXG4gKlxuICogVGhlIGxvY2F0aW9uIGFycmF5IGRlZmF1bHRzIHRvOiBbJ3dlYicsICdmbGFzaCddXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLCBudWxsIHRvIHVzZSBvbmx5IFdlYlN0b3JhZ2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLnNldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9zZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSwgbnVsbCB0byB1c2Ugb25seSBXZWJTdG9yYWdlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnV0aWwuZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9nZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5yZW1vdmVJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfcmVtb3ZlSXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UgaWYgZmxhc2ggaXMgYXZhaWxhYmxlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwuY2xlYXJJdGVtcyA9IGZ1bmN0aW9uKGFwaSwgaWQsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9jbGVhckl0ZW1zLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBzY2hlbWUsIGhvc3QsIGFuZCBwb3J0IGZyb20gYW4gaHR0cChzKSB1cmwuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgdXJsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgdXJsIG9iamVjdCBvciBudWxsIGlmIHRoZSB1cmwgaXMgaW52YWxpZC5cbiAqL1xudXRpbC5wYXJzZVVybCA9IGZ1bmN0aW9uKHN0cikge1xuICAvLyBGSVhNRTogdGhpcyByZWdleCBsb29rcyBhIGJpdCBicm9rZW5cbiAgdmFyIHJlZ2V4ID0gL14oaHR0cHM/KTpcXC9cXC8oW146Jl5cXC9dKik6PyhcXGQqKSguKikkL2c7XG4gIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gIHZhciBtID0gcmVnZXguZXhlYyhzdHIpO1xuICB2YXIgdXJsID0gKG0gPT09IG51bGwpID8gbnVsbCA6IHtcbiAgICBmdWxsOiBzdHIsXG4gICAgc2NoZW1lOiBtWzFdLFxuICAgIGhvc3Q6IG1bMl0sXG4gICAgcG9ydDogbVszXSxcbiAgICBwYXRoOiBtWzRdXG4gIH07XG4gIGlmKHVybCkge1xuICAgIHVybC5mdWxsSG9zdCA9IHVybC5ob3N0O1xuICAgIGlmKHVybC5wb3J0KSB7XG4gICAgICBpZih1cmwucG9ydCAhPT0gODAgJiYgdXJsLnNjaGVtZSA9PT0gJ2h0dHAnKSB7XG4gICAgICAgIHVybC5mdWxsSG9zdCArPSAnOicgKyB1cmwucG9ydDtcbiAgICAgIH0gZWxzZSBpZih1cmwucG9ydCAhPT0gNDQzICYmIHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgICAgdXJsLmZ1bGxIb3N0ICs9ICc6JyArIHVybC5wb3J0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih1cmwuc2NoZW1lID09PSAnaHR0cCcpIHtcbiAgICAgIHVybC5wb3J0ID0gODA7XG4gICAgfSBlbHNlIGlmKHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgIHVybC5wb3J0ID0gNDQzO1xuICAgIH1cbiAgICB1cmwuZnVsbCA9IHVybC5zY2hlbWUgKyAnOi8vJyArIHVybC5mdWxsSG9zdDtcbiAgfVxuICByZXR1cm4gdXJsO1xufTtcblxuLyogU3RvcmFnZSBmb3IgcXVlcnkgdmFyaWFibGVzICovXG52YXIgX3F1ZXJ5VmFyaWFibGVzID0gbnVsbDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB3aW5kb3cgbG9jYXRpb24gcXVlcnkgdmFyaWFibGVzLiBRdWVyeSBpcyBwYXJzZWQgb24gdGhlIGZpcnN0XG4gKiBjYWxsIGFuZCB0aGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgb24gc3Vic2VxdWVudCBjYWxscy4gVGhlIG1hcHBpbmdcbiAqIGlzIGZyb20ga2V5cyB0byBhbiBhcnJheSBvZiB2YWx1ZXMuIFBhcmFtZXRlcnMgd2l0aG91dCB2YWx1ZXMgd2lsbCBoYXZlXG4gKiBhbiBvYmplY3Qga2V5IHNldCBidXQgbm8gdmFsdWUgYWRkZWQgdG8gdGhlIHZhbHVlIGFycmF5LiBWYWx1ZXMgYXJlXG4gKiB1bmVzY2FwZWQuXG4gKlxuICogLi4uP2sxPXYxJmsyPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCJdLFxuICogICBcImsyXCI6IFtcInYyXCJdXG4gKiB9XG4gKlxuICogLi4uP2sxPXYxJmsxPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCIsIFwidjJcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazI6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl0sXG4gKiAgIFwiazJcIjogW11cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW11cbiAqIH1cbiAqXG4gKiBAcGFyYW0gcXVlcnkgdGhlIHF1ZXJ5IHN0cmluZyB0byBwYXJzZSAob3B0aW9uYWwsIGRlZmF1bHQgdG8gY2FjaGVkXG4gKiAgICAgICAgICByZXN1bHRzIGZyb20gcGFyc2luZyB3aW5kb3cgbG9jYXRpb24gc2VhcmNoIHF1ZXJ5KS5cbiAqXG4gKiBAcmV0dXJuIG9iamVjdCBtYXBwaW5nIGtleXMgdG8gdmFyaWFibGVzLlxuICovXG51dGlsLmdldFF1ZXJ5VmFyaWFibGVzID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24ocSkge1xuICAgIHZhciBydmFsID0ge307XG4gICAgdmFyIGt2cGFpcnMgPSBxLnNwbGl0KCcmJyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGt2cGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb3MgPSBrdnBhaXJzW2ldLmluZGV4T2YoJz0nKTtcbiAgICAgIHZhciBrZXk7XG4gICAgICB2YXIgdmFsO1xuICAgICAgaWYocG9zID4gMCkge1xuICAgICAgICBrZXkgPSBrdnBhaXJzW2ldLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICB2YWwgPSBrdnBhaXJzW2ldLnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGt2cGFpcnNbaV07XG4gICAgICAgIHZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZighKGtleSBpbiBydmFsKSkge1xuICAgICAgICBydmFsW2tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIC8vIGRpc2FsbG93IG92ZXJyaWRpbmcgb2JqZWN0IHByb3RvdHlwZSBrZXlzXG4gICAgICBpZighKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgcnZhbFtrZXldLnB1c2godW5lc2NhcGUodmFsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gICB2YXIgcnZhbDtcbiAgIGlmKHR5cGVvZihxdWVyeSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgIC8vIHNldCBjYWNoZWQgdmFyaWFibGVzIGlmIG5lZWRlZFxuICAgICBpZihfcXVlcnlWYXJpYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICBpZih0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgICAgICAvLyBwYXJzZSB3aW5kb3cgc2VhcmNoIHF1ZXJ5XG4gICAgICAgICAgX3F1ZXJ5VmFyaWFibGVzID0gcGFyc2Uod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gcXVlcnkgdmFyaWFibGVzIGF2YWlsYWJsZVxuICAgICAgICAgIF9xdWVyeVZhcmlhYmxlcyA9IHt9O1xuICAgICAgIH1cbiAgICAgfVxuICAgICBydmFsID0gX3F1ZXJ5VmFyaWFibGVzO1xuICAgfSBlbHNlIHtcbiAgICAgLy8gcGFyc2UgZ2l2ZW4gcXVlcnlcbiAgICAgcnZhbCA9IHBhcnNlKHF1ZXJ5KTtcbiAgIH1cbiAgIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBmcmFnbWVudCBpbnRvIGEgcGF0aCBhbmQgcXVlcnkuIFRoaXMgbWV0aG9kIHdpbGwgdGFrZSBhIFVSSVxuICogZnJhZ21lbnQgYW5kIGJyZWFrIGl0IHVwIGFzIGlmIGl0IHdlcmUgdGhlIG1haW4gVVJJLiBGb3IgZXhhbXBsZTpcbiAqICAgIC9iYXIvYmF6P2E9MSZiPTJcbiAqIHJlc3VsdHMgaW46XG4gKiAgICB7XG4gKiAgICAgICBwYXRoOiBbXCJiYXJcIiwgXCJiYXpcIl0sXG4gKiAgICAgICBxdWVyeToge1wiazFcIjogW1widjFcIl0sIFwiazJcIjogW1widjJcIl19XG4gKiAgICB9XG4gKlxuICogQHJldHVybiBvYmplY3Qgd2l0aCBhIHBhdGggYXJyYXkgYW5kIHF1ZXJ5IG9iamVjdC5cbiAqL1xudXRpbC5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgLy8gZGVmYXVsdCB0byB3aG9sZSBmcmFnbWVudFxuICB2YXIgZnAgPSBmcmFnbWVudDtcbiAgdmFyIGZxID0gJyc7XG4gIC8vIHNwbGl0IGludG8gcGF0aCBhbmQgcXVlcnkgaWYgcG9zc2libGUgYXQgdGhlIGZpcnN0ICc/J1xuICB2YXIgcG9zID0gZnJhZ21lbnQuaW5kZXhPZignPycpO1xuICBpZihwb3MgPiAwKSB7XG4gICAgZnAgPSBmcmFnbWVudC5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICBmcSA9IGZyYWdtZW50LnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgfVxuICAvLyBzcGxpdCBwYXRoIGJhc2VkIG9uICcvJyBhbmQgaWdub3JlIGZpcnN0IGVsZW1lbnQgaWYgZW1wdHlcbiAgdmFyIHBhdGggPSBmcC5zcGxpdCgnLycpO1xuICBpZihwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aFswXSA9PT0gJycpIHtcbiAgICBwYXRoLnNoaWZ0KCk7XG4gIH1cbiAgLy8gY29udmVydCBxdWVyeSBpbnRvIG9iamVjdFxuICB2YXIgcXVlcnkgPSAoZnEgPT09ICcnKSA/IHt9IDogdXRpbC5nZXRRdWVyeVZhcmlhYmxlcyhmcSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoU3RyaW5nOiBmcCxcbiAgICBxdWVyeVN0cmluZzogZnEsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnlcbiAgfTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSByZXF1ZXN0IG91dCBvZiBhIFVSSS1saWtlIHJlcXVlc3Qgc3RyaW5nLiBUaGlzIGlzIGludGVuZGVkIHRvXG4gKiBiZSB1c2VkIHdoZXJlIGEgZnJhZ21lbnQgaWQgKGFmdGVyIGEgVVJJICcjJykgaXMgcGFyc2VkIGFzIGEgVVJJIHdpdGhcbiAqIHBhdGggYW5kIHF1ZXJ5IHBhcnRzLiBUaGUgc3RyaW5nIHNob3VsZCBoYXZlIGEgcGF0aCBiZWdpbm5pbmcgYW5kXG4gKiBkZWxpbWl0ZWQgYnkgJy8nIGFuZCBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzIGZvbGxvd2luZyBhICc/Jy4gVGhlXG4gKiBxdWVyeSBzaG91bGQgYmUgYSBzdGFuZGFyZCBVUkwgc2V0IG9mIGtleSB2YWx1ZSBwYWlycyBkZWxpbWl0ZWQgYnlcbiAqICcmJy4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRoZSBpbml0aWFsICcvJyBvbiB0aGUgcGF0aCBpcyBub3RcbiAqIHJlcXVpcmVkLiBUaGUgcmVxdWVzdCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgQVBJLCAoZnVsbHkgZGVzY3JpYmVkXG4gKiBpbiB0aGUgbWV0aG9kIGNvZGUpOlxuICogICAge1xuICogICAgICAgcGF0aDogPHRoZSBwYXRoIHN0cmluZyBwYXJ0Pi5cbiAqICAgICAgIHF1ZXJ5OiA8dGhlIHF1ZXJ5IHN0cmluZyBwYXJ0PixcbiAqICAgICAgIGdldFBhdGgoaSk6IGdldCBwYXJ0IG9yIGFsbCBvZiB0aGUgc3BsaXQgcGF0aCBhcnJheSxcbiAqICAgICAgIGdldFF1ZXJ5KGssIGkpOiBnZXQgcGFydCBvciBhbGwgb2YgYSBxdWVyeSBrZXkgYXJyYXksXG4gKiAgICAgICBnZXRRdWVyeUxhc3QoaywgX2RlZmF1bHQpOiBnZXQgbGFzdCBlbGVtZW50IG9mIGEgcXVlcnkga2V5IGFycmF5LlxuICogICAgfVxuICpcbiAqIEByZXR1cm4gb2JqZWN0IHdpdGggcmVxdWVzdCBwYXJhbWV0ZXJzLlxuICovXG51dGlsLm1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxU3RyaW5nKSB7XG4gIHZhciBmcmFnID0gdXRpbC5wYXJzZUZyYWdtZW50KHJlcVN0cmluZyk7XG4gIHZhciByZXEgPSB7XG4gICAgLy8gZnVsbCBwYXRoIHN0cmluZ1xuICAgIHBhdGg6IGZyYWcucGF0aFN0cmluZyxcbiAgICAvLyBmdWxsIHF1ZXJ5IHN0cmluZ1xuICAgIHF1ZXJ5OiBmcmFnLnF1ZXJ5U3RyaW5nLFxuICAgIC8qKlxuICAgICAqIEdldCBwYXRoIG9yIGVsZW1lbnQgaW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHBhdGggaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHBhdGggb3IgcGFydCBvZiBwYXRoIGlmIGkgcHJvdmlkZWQuXG4gICAgICovXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuICh0eXBlb2YoaSkgPT09ICd1bmRlZmluZWQnKSA/IGZyYWcucGF0aCA6IGZyYWcucGF0aFtpXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBxdWVyeSwgdmFsdWVzIGZvciBhIGtleSwgb3IgdmFsdWUgZm9yIGEga2V5IGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGsgb3B0aW9uYWwgcXVlcnkga2V5LlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHF1ZXJ5IGtleSBpbmRleC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gcXVlcnksIHZhbHVlcyBmb3IgYSBrZXksIG9yIHZhbHVlIGZvciBhIGtleSBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRRdWVyeTogZnVuY3Rpb24oaywgaSkge1xuICAgICAgdmFyIHJ2YWw7XG4gICAgICBpZih0eXBlb2YoaykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJ2YWwgPSBmcmFnLnF1ZXJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IGZyYWcucXVlcnlba107XG4gICAgICAgIGlmKHJ2YWwgJiYgdHlwZW9mKGkpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICBydmFsID0gcnZhbFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcbiAgICBnZXRRdWVyeUxhc3Q6IGZ1bmN0aW9uKGssIF9kZWZhdWx0KSB7XG4gICAgICB2YXIgcnZhbDtcbiAgICAgIHZhciB2YWxzID0gcmVxLmdldFF1ZXJ5KGspO1xuICAgICAgaWYodmFscykge1xuICAgICAgICBydmFsID0gdmFsc1t2YWxzLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IF9kZWZhdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIFVSSSBvdXQgb2YgYSBwYXRoLCBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzLCBhbmQgYVxuICogZnJhZ21lbnQuIFVzZXMgalF1ZXJ5LnBhcmFtKCkgaW50ZXJuYWxseSBmb3IgcXVlcnkgc3RyaW5nIGNyZWF0aW9uLlxuICogSWYgdGhlIHBhdGggaXMgYW4gYXJyYXksIGl0IHdpbGwgYmUgam9pbmVkIHdpdGggJy8nLlxuICpcbiAqIEBwYXJhbSBwYXRoIHN0cmluZyBwYXRoIG9yIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gcXVlcnkgb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycy4gKG9wdGlvbmFsKVxuICogQHBhcmFtIGZyYWdtZW50IGZyYWdtZW50IHN0cmluZy4gKG9wdGlvbmFsKVxuICpcbiAqIEByZXR1cm4gc3RyaW5nIG9iamVjdCB3aXRoIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAqL1xudXRpbC5tYWtlTGluayA9IGZ1bmN0aW9uKHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCkge1xuICAvLyBqb2luIHBhdGggcGFydHMgaWYgbmVlZGVkXG4gIHBhdGggPSBqUXVlcnkuaXNBcnJheShwYXRoKSA/IHBhdGguam9pbignLycpIDogcGF0aDtcblxuICB2YXIgcXN0ciA9IGpRdWVyeS5wYXJhbShxdWVyeSB8fCB7fSk7XG4gIGZyYWdtZW50ID0gZnJhZ21lbnQgfHwgJyc7XG4gIHJldHVybiBwYXRoICtcbiAgICAoKHFzdHIubGVuZ3RoID4gMCkgPyAoJz8nICsgcXN0cikgOiAnJykgK1xuICAgICgoZnJhZ21lbnQubGVuZ3RoID4gMCkgPyAoJyMnICsgZnJhZ21lbnQpIDogJycpO1xufTtcblxuLyoqXG4gKiBGb2xsb3dzIGEgcGF0aCBvZiBrZXlzIGRlZXAgaW50byBhbiBvYmplY3QgaGllcmFyY2h5IGFuZCBzZXQgYSB2YWx1ZS5cbiAqIElmIGEga2V5IGRvZXMgbm90IGV4aXN0IG9yIGl0J3MgdmFsdWUgaXMgbm90IGFuIG9iamVjdCwgY3JlYXRlIGFuXG4gKiBvYmplY3QgaW4gaXQncyBwbGFjZS4gVGhpcyBjYW4gYmUgZGVzdHJ1Y3RpdmUgdG8gYSBvYmplY3QgdHJlZSBpZlxuICogbGVhZiBub2RlcyBhcmUgZ2l2ZW4gYXMgbm9uLWZpbmFsIHBhdGgga2V5cy5cbiAqIFVzZWQgdG8gYXZvaWQgZXhjZXB0aW9ucyBmcm9tIG1pc3NpbmcgcGFydHMgb2YgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtIG9iamVjdCB0aGUgc3RhcnRpbmcgb2JqZWN0LlxuICogQHBhcmFtIGtleXMgYW4gYXJyYXkgb2Ygc3RyaW5nIGtleXMuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHNldC5cbiAqL1xudXRpbC5zZXRQYXRoID0gZnVuY3Rpb24ob2JqZWN0LCBrZXlzLCB2YWx1ZSkge1xuICAvLyBuZWVkIHRvIHN0YXJ0IGF0IGFuIG9iamVjdFxuICBpZih0eXBlb2Yob2JqZWN0KSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICB2YXIgbmV4dCA9IGtleXNbaSsrXTtcbiAgICAgIGlmKGkgPT0gbGVuKSB7XG4gICAgICAgIC8vIGxhc3RcbiAgICAgICAgb2JqZWN0W25leHRdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3JlXG4gICAgICAgIHZhciBoYXNOZXh0ID0gKG5leHQgaW4gb2JqZWN0KTtcbiAgICAgICAgaWYoIWhhc05leHQgfHxcbiAgICAgICAgICAoaGFzTmV4dCAmJiB0eXBlb2Yob2JqZWN0W25leHRdKSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgKGhhc05leHQgJiYgb2JqZWN0W25leHRdID09PSBudWxsKSkge1xuICAgICAgICAgIG9iamVjdFtuZXh0XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtuZXh0XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9sbG93cyBhIHBhdGggb2Yga2V5cyBkZWVwIGludG8gYW4gb2JqZWN0IGhpZXJhcmNoeSBhbmQgcmV0dXJuIGEgdmFsdWUuXG4gKiBJZiBhIGtleSBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGFuIG9iamVjdCBpbiBpdCdzIHBsYWNlLlxuICogVXNlZCB0byBhdm9pZCBleGNlcHRpb25zIGZyb20gbWlzc2luZyBwYXJ0cyBvZiB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBzdGFydGluZyBvYmplY3QuXG4gKiBAcGFyYW0ga2V5cyBhbiBhcnJheSBvZiBzdHJpbmcga2V5cy5cbiAqIEBwYXJhbSBfZGVmYXVsdCB2YWx1ZSB0byByZXR1cm4gaWYgcGF0aCBub3QgZm91bmQuXG4gKlxuICogQHJldHVybiB0aGUgdmFsdWUgYXQgdGhlIHBhdGggaWYgZm91bmQsIGVsc2UgZGVmYXVsdCBpZiBnaXZlbiwgZWxzZVxuICogICAgICAgICB1bmRlZmluZWQuXG4gKi9cbnV0aWwuZ2V0UGF0aCA9IGZ1bmN0aW9uKG9iamVjdCwga2V5cywgX2RlZmF1bHQpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHZhciBoYXNOZXh0ID0gdHJ1ZTtcbiAgd2hpbGUoaGFzTmV4dCAmJiBpIDwgbGVuICYmXG4gICAgdHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0ID0ga2V5c1tpKytdO1xuICAgIGhhc05leHQgPSBuZXh0IGluIG9iamVjdDtcbiAgICBpZihoYXNOZXh0KSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbbmV4dF07XG4gICAgfVxuICB9XG4gIHJldHVybiAoaGFzTmV4dCA/IG9iamVjdCA6IF9kZWZhdWx0KTtcbn07XG5cbi8qKlxuICogRm9sbG93IGEgcGF0aCBvZiBrZXlzIGRlZXAgaW50byBhbiBvYmplY3QgaGllcmFyY2h5IGFuZCBkZWxldGUgdGhlXG4gKiBsYXN0IG9uZS4gSWYgYSBrZXkgZG9lcyBub3QgZXhpc3QsIGRvIG5vdGhpbmcuXG4gKiBVc2VkIHRvIGF2b2lkIGV4Y2VwdGlvbnMgZnJvbSBtaXNzaW5nIHBhcnRzIG9mIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgdGhlIHN0YXJ0aW5nIG9iamVjdC5cbiAqIEBwYXJhbSBrZXlzIGFuIGFycmF5IG9mIHN0cmluZyBrZXlzLlxuICovXG51dGlsLmRlbGV0ZVBhdGggPSBmdW5jdGlvbihvYmplY3QsIGtleXMpIHtcbiAgLy8gbmVlZCB0byBzdGFydCBhdCBhbiBvYmplY3RcbiAgaWYodHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgdmFyIG5leHQgPSBrZXlzW2krK107XG4gICAgICBpZihpID09IGxlbikge1xuICAgICAgICAvLyBsYXN0XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbmV4dF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3JlXG4gICAgICAgIGlmKCEobmV4dCBpbiBvYmplY3QpIHx8XG4gICAgICAgICAgKHR5cGVvZihvYmplY3RbbmV4dF0pICE9PSAnb2JqZWN0JykgfHxcbiAgICAgICAgICAob2JqZWN0W25leHRdID09PSBudWxsKSkge1xuICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3RbbmV4dF07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBlbXB0eS5cbiAqXG4gKiBUYWtlbiBmcm9tOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QtZnJvbS1qc29uLzY3OTkzNyM2Nzk5MzdcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY2hlY2suXG4gKi9cbnV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgd2l0aCBzaW1wbGUgcHJpbnRmLXN0eWxlIGludGVycG9sYXRpb24uXG4gKlxuICogJSU6IGxpdGVyYWwgJyUnXG4gKiAlcywlbzogY29udmVydCBuZXh0IGFyZ3VtZW50IGludG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGZvcm1hdCB0aGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSAuLi4gYXJndW1lbnRzIHRvIGludGVycG9sYXRlIGludG8gdGhlIGZvcm1hdCBzdHJpbmcuXG4gKi9cbnV0aWwuZm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gIHZhciByZSA9IC8lLi9nO1xuICAvLyBjdXJyZW50IG1hdGNoXG4gIHZhciBtYXRjaDtcbiAgLy8gY3VycmVudCBwYXJ0XG4gIHZhciBwYXJ0O1xuICAvLyBjdXJyZW50IGFyZyBpbmRleFxuICB2YXIgYXJnaSA9IDA7XG4gIC8vIGNvbGxlY3RlZCBwYXJ0cyB0byByZWNvbWJpbmUgbGF0ZXJcbiAgdmFyIHBhcnRzID0gW107XG4gIC8vIGxhc3QgaW5kZXggZm91bmRcbiAgdmFyIGxhc3QgPSAwO1xuICAvLyBsb29wIHdoaWxlIG1hdGNoZXMgcmVtYWluXG4gIHdoaWxlKChtYXRjaCA9IHJlLmV4ZWMoZm9ybWF0KSkpIHtcbiAgICBwYXJ0ID0gZm9ybWF0LnN1YnN0cmluZyhsYXN0LCByZS5sYXN0SW5kZXggLSAyKTtcbiAgICAvLyBkb24ndCBhZGQgZW1wdHkgc3RyaW5ncyAoaWUsIHBhcnRzIGJldHdlZW4gJXMlcylcbiAgICBpZihwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGxhc3QgPSByZS5sYXN0SW5kZXg7XG4gICAgLy8gc3dpdGNoIG9uICUgY29kZVxuICAgIHZhciBjb2RlID0gbWF0Y2hbMF1bMV07XG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICBjYXNlICdzJzpcbiAgICBjYXNlICdvJzpcbiAgICAgIC8vIGNoZWNrIGlmIGVub3VnaCBhcmd1bWVudHMgd2VyZSBnaXZlblxuICAgICAgaWYoYXJnaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChhcmd1bWVudHNbYXJnaSsrICsgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaCgnPD8+Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBGSVhNRTogZG8gcHJvcGVyIGZvcm1hdGluZyBmb3IgbnVtYmVycywgZXRjXG4gICAgLy9jYXNlICdmJzpcbiAgICAvL2Nhc2UgJ2QnOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcGFydHMucHVzaCgnJScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhcnRzLnB1c2goJzwlJyArIGNvZGUgKyAnPz4nKTtcbiAgICB9XG4gIH1cbiAgLy8gYWRkIHRyYWlsaW5nIHBhcnQgb2YgZm9ybWF0IHN0cmluZ1xuICBwYXJ0cy5wdXNoKGZvcm1hdC5zdWJzdHJpbmcobGFzdCkpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0NS9qYXZhc2NyaXB0LW51bWJlcmZvcm1hdC0tcG9ydGVkLWZyb20tcGhwL1xuICovXG51dGlsLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCkge1xuICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vY3Jlc3RpZGcuY29tKVxuICAvLyArICAgICBidWdmaXggYnk6IEJlbmphbWluIEx1cHRvblxuICAvLyArICAgICBidWdmaXggYnk6IEFsbGFuIEplbnNlbiAoaHR0cDovL3d3dy53aW50ZXJuZXQubm8pXG4gIC8vICsgICAgcmV2aXNlZCBieTogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuICAvLyAqICAgICBleGFtcGxlIDE6IG51bWJlcl9mb3JtYXQoMTIzNC41Njc4LCAyLCAnLicsICcnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjM0LjU3XG5cbiAgdmFyIG4gPSBudW1iZXIsIGMgPSBpc05hTihkZWNpbWFscyA9IE1hdGguYWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHM7XG4gIHZhciBkID0gZGVjX3BvaW50ID09PSB1bmRlZmluZWQgPyAnLCcgOiBkZWNfcG9pbnQ7XG4gIHZhciB0ID0gdGhvdXNhbmRzX3NlcCA9PT0gdW5kZWZpbmVkID9cbiAgICcuJyA6IHRob3VzYW5kc19zZXAsIHMgPSBuIDwgMCA/ICctJyA6ICcnO1xuICB2YXIgaSA9IHBhcnNlSW50KChuID0gTWF0aC5hYnMoK24gfHwgMCkudG9GaXhlZChjKSksIDEwKSArICcnO1xuICB2YXIgaiA9IChpLmxlbmd0aCA+IDMpID8gaS5sZW5ndGggJSAzIDogMDtcbiAgcmV0dXJuIHMgKyAoaiA/IGkuc3Vic3RyKDAsIGopICsgdCA6ICcnKSArXG4gICAgaS5zdWJzdHIoaikucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csICckMScgKyB0KSArXG4gICAgKGMgPyBkICsgTWF0aC5hYnMobiAtIGkpLnRvRml4ZWQoYykuc2xpY2UoMikgOiAnJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBieXRlIHNpemUuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0OS9mb3JtYXQtaHVtYW5pemUtZmlsZS1ieXRlLXNpemUtcHJlc2VudGF0aW9uLWluLWphdmFzY3JpcHQvXG4gKi9cbnV0aWwuZm9ybWF0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYoc2l6ZSA+PSAxMDczNzQxODI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDczNzQxODI0LCAyLCAnLicsICcnKSArICcgR2lCJztcbiAgfSBlbHNlIGlmKHNpemUgPj0gMTA0ODU3Nikge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA0ODU3NiwgMiwgJy4nLCAnJykgKyAnIE1pQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwMjQpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwMjQsIDApICsgJyBLaUInO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplLCAwKSArICcgYnl0ZXMnO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IG9yIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBvciBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSA0LWJ5dGUgSVB2NiBvciAxNi1ieXRlIElQdjYgYWRkcmVzcyBvciBudWxsIGlmIHRoZSBhZGRyZXNzIGNhbid0XG4gKiAgICAgICAgIGJlIHBhcnNlZC5cbiAqL1xudXRpbC5ieXRlc0Zyb21JUCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlmKGlwLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc0Zyb21JUHY0KGlwKTtcbiAgfVxuICBpZihpcC5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NihpcCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlwID0gaXAuc3BsaXQoJy4nKTtcbiAgaWYoaXAubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaXAubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbnVtID0gcGFyc2VJbnQoaXBbaV0sIDEwKTtcbiAgICBpZihpc05hTihudW0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYi5wdXRCeXRlKG51bSk7XG4gIH1cbiAgcmV0dXJuIGIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW50byBieXRlcyAoaW4gbmV0d29yayBvcmRlcikuXG4gKlxuICogQHBhcmFtIGlwIHRoZSBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSAxNi1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NiA9IGZ1bmN0aW9uKGlwKSB7XG4gIHZhciBibGFua3MgPSAwO1xuICBpcCA9IGlwLnNwbGl0KCc6JykuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICBpZihlLmxlbmd0aCA9PT0gMCkgKytibGFua3M7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICB2YXIgemVyb3MgPSAoOCAtIGlwLmxlbmd0aCArIGJsYW5rcykgKiAyO1xuICB2YXIgYiA9IHV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICBpZighaXBbaV0gfHwgaXBbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBiLmZpbGxXaXRoQnl0ZSgwLCB6ZXJvcyk7XG4gICAgICB6ZXJvcyA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGJ5dGVzID0gdXRpbC5oZXhUb0J5dGVzKGlwW2ldKTtcbiAgICBpZihieXRlcy5sZW5ndGggPCAyKSB7XG4gICAgICBiLnB1dEJ5dGUoMCk7XG4gICAgfVxuICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciAxNi1ieXRlcyBpbnRvXG4gKiBhbiBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmUgaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiA0IG9yIDE2IGJ5dGVzLFxuICogICAgICAgICByZXNwZWN0aXZlbHksIGFyZSBnaXZlbiwgb3RoZXJ3aXNlIG51bGwuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYoYnl0ZXMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjQoYnl0ZXMpO1xuICB9XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gMTYpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc1RvSVB2NihieXRlcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpcCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpcC5wdXNoKGJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICB9XG4gIHJldHVybiBpcC5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDE2LWJ5dGVzIGludG8gYW4gSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZXMgbXVzdCBiZVxuICogaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NiA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgdmFyIHplcm9Hcm91cHMgPSBbXTtcbiAgdmFyIHplcm9NYXhHcm91cCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBoZXggPSB1dGlsLmJ5dGVzVG9IZXgoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0pO1xuICAgIC8vIGNhbm9uaWNhbGl6ZSB6ZXJvIHJlcHJlc2VudGF0aW9uXG4gICAgd2hpbGUoaGV4WzBdID09PSAnMCcgJiYgaGV4ICE9PSAnMCcpIHtcbiAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGlmKGhleCA9PT0gJzAnKSB7XG4gICAgICB2YXIgbGFzdCA9IHplcm9Hcm91cHNbemVyb0dyb3Vwcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBpZHggPSBpcC5sZW5ndGg7XG4gICAgICBpZighbGFzdCB8fCBpZHggIT09IGxhc3QuZW5kICsgMSkge1xuICAgICAgICB6ZXJvR3JvdXBzLnB1c2goe3N0YXJ0OiBpZHgsIGVuZDogaWR4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0LmVuZCA9IGlkeDtcbiAgICAgICAgaWYoKGxhc3QuZW5kIC0gbGFzdC5zdGFydCkgPlxuICAgICAgICAgICh6ZXJvR3JvdXBzW3plcm9NYXhHcm91cF0uZW5kIC0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLnN0YXJ0KSkge1xuICAgICAgICAgIHplcm9NYXhHcm91cCA9IHplcm9Hcm91cHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpcC5wdXNoKGhleCk7XG4gIH1cbiAgaWYoemVyb0dyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGdyb3VwID0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdO1xuICAgIC8vIG9ubHkgc2hvcnRlbiBncm91cCBvZiBsZW5ndGggPiAwXG4gICAgaWYoZ3JvdXAuZW5kIC0gZ3JvdXAuc3RhcnQgPiAwKSB7XG4gICAgICBpcC5zcGxpY2UoZ3JvdXAuc3RhcnQsIGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ICsgMSwgJycpO1xuICAgICAgaWYoZ3JvdXAuc3RhcnQgPT09IDApIHtcbiAgICAgICAgaXAudW5zaGlmdCgnJyk7XG4gICAgICB9XG4gICAgICBpZihncm91cC5lbmQgPT09IDcpIHtcbiAgICAgICAgaXAucHVzaCgnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpcC5qb2luKCc6Jyk7XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHByb2Nlc3NlcyB0aGF0IGNhbiBiZSBydW4gY29uY3VycmVudGx5LiBJZlxuICogY3JlYXRpbmcgV2ViIFdvcmtlcnMsIGtlZXAgaW4gbWluZCB0aGF0IHRoZSBtYWluIEphdmFTY3JpcHQgcHJvY2VzcyBuZWVkc1xuICogaXRzIG93biBjb3JlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIHVwZGF0ZSB0cnVlIHRvIGZvcmNlIGFuIHVwZGF0ZSAobm90IHVzZSB0aGUgY2FjaGVkIHZhbHVlKS5cbiAqIEBwYXJhbSBjYWxsYmFjayhlcnIsIG1heCkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnV0aWwuZXN0aW1hdGVDb3JlcyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoJ2NvcmVzJyBpbiB1dGlsICYmICFvcHRpb25zLnVwZGF0ZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICdoYXJkd2FyZUNvbmN1cnJlbmN5JyBpbiBuYXZpZ2F0b3IgJiZcbiAgICBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSA+IDApIHtcbiAgICB1dGlsLmNvcmVzID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gd29ya2VycyBub3QgYXZhaWxhYmxlXG4gICAgdXRpbC5jb3JlcyA9IDE7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNhbid0IGVzdGltYXRlLCBkZWZhdWx0IHRvIDJcbiAgICB1dGlsLmNvcmVzID0gMjtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cblxuICAvLyBjcmVhdGUgd29ya2VyIGNvbmN1cnJlbmN5IGVzdGltYXRpb24gY29kZSBhcyBibG9iXG4gIHZhciBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnLFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBydW4gd29ya2VyIGZvciA0IG1zXG4gICAgICAgIHZhciBzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBldCA9IHN0ICsgNDtcbiAgICAgICAgd2hpbGUoRGF0ZS5ub3coKSA8IGV0KTtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7c3Q6IHN0LCBldDogZXR9KTtcbiAgICAgIH0pO1xuICAgIH0udG9TdHJpbmcoKSxcbiAgJykoKSddLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSkpO1xuXG4gIC8vIHRha2UgNSBzYW1wbGVzIHVzaW5nIDE2IHdvcmtlcnNcbiAgc2FtcGxlKFtdLCA1LCAxNik7XG5cbiAgZnVuY3Rpb24gc2FtcGxlKG1heCwgc2FtcGxlcywgbnVtV29ya2Vycykge1xuICAgIGlmKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIGdldCBvdmVybGFwIGF2ZXJhZ2VcbiAgICAgIHZhciBhdmcgPSBNYXRoLmZsb29yKG1heC5yZWR1Y2UoZnVuY3Rpb24oYXZnLCB4KSB7XG4gICAgICAgIHJldHVybiBhdmcgKyB4O1xuICAgICAgfSwgMCkgLyBtYXgubGVuZ3RoKTtcbiAgICAgIHV0aWwuY29yZXMgPSBNYXRoLm1heCgxLCBhdmcpO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgICB9XG4gICAgbWFwKG51bVdvcmtlcnMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgbWF4LnB1c2gocmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpKTtcbiAgICAgIHNhbXBsZShtYXgsIHNhbXBsZXMgLSAxLCBudW1Xb3JrZXJzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcChudW1Xb3JrZXJzLCBjYWxsYmFjaykge1xuICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZS5kYXRhKTtcbiAgICAgICAgaWYocmVzdWx0cy5sZW5ndGggPT09IG51bVdvcmtlcnMpIHtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgICB3b3JrZXJzW2ldLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3b3JrZXJzLnB1c2god29ya2VyKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5wb3N0TWVzc2FnZShpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWR1Y2UobnVtV29ya2VycywgcmVzdWx0cykge1xuICAgIC8vIGZpbmQgb3ZlcmxhcHBpbmcgdGltZSB3aW5kb3dzXG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IG51bVdvcmtlcnM7ICsrbikge1xuICAgICAgdmFyIHIxID0gcmVzdWx0c1tuXTtcbiAgICAgIHZhciBvdmVybGFwID0gb3ZlcmxhcHNbbl0gPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgICAgaWYobiA9PT0gaSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByMiA9IHJlc3VsdHNbaV07XG4gICAgICAgIGlmKChyMS5zdCA+IHIyLnN0ICYmIHIxLnN0IDwgcjIuZXQpIHx8XG4gICAgICAgICAgKHIyLnN0ID4gcjEuc3QgJiYgcjIuc3QgPCByMS5ldCkpIHtcbiAgICAgICAgICBvdmVybGFwLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZ2V0IG1heGltdW0gb3ZlcmxhcHMgLi4uIGRvbid0IGluY2x1ZGUgb3ZlcmxhcHBpbmcgd29ya2VyIGl0c2VsZlxuICAgIC8vIGFzIHRoZSBtYWluIEpTIHByb2Nlc3Mgd2FzIGFsc28gYmVpbmcgc2NoZWR1bGVkIGR1cmluZyB0aGUgd29yayBhbmRcbiAgICAvLyB3b3VsZCBoYXZlIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgZXN0aW1hdGUgYW55d2F5XG4gICAgcmV0dXJuIG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbihtYXgsIG92ZXJsYXApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIG92ZXJsYXAubGVuZ3RoKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBOdW1iZXIgT25lLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBbiBBUEkgZm9yIHN0b3JpbmcgZGF0YSB1c2luZyB0aGUgQWJzdHJhY3QgU3ludGF4IE5vdGF0aW9uIE51bWJlciBPbmVcbiAqIGZvcm1hdCB1c2luZyBERVIgKERpc3Rpbmd1aXNoZWQgRW5jb2RpbmcgUnVsZXMpIGVuY29kaW5nLiBUaGlzIGVuY29kaW5nIGlzXG4gKiBjb21tb25seSB1c2VkIHRvIHN0b3JlIGRhdGEgZm9yIFBLSSwgaS5lLiBYLjUwOSBDZXJ0aWZpY2F0ZXMsIGFuZCB0aGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBleGlzdHMgZm9yIHRoYXQgcHVycG9zZS5cbiAqXG4gKiBBYnN0cmFjdCBTeW50YXggTm90YXRpb24gTnVtYmVyIE9uZSAoQVNOLjEpIGlzIHVzZWQgdG8gZGVmaW5lIHRoZSBhYnN0cmFjdFxuICogc3ludGF4IG9mIGluZm9ybWF0aW9uIHdpdGhvdXQgcmVzdHJpY3RpbmcgdGhlIHdheSB0aGUgaW5mb3JtYXRpb24gaXMgZW5jb2RlZFxuICogZm9yIHRyYW5zbWlzc2lvbi4gSXQgcHJvdmlkZXMgYSBzdGFuZGFyZCB0aGF0IGFsbG93cyBmb3Igb3BlbiBzeXN0ZW1zXG4gKiBjb21tdW5pY2F0aW9uLiBBU04uMSBkZWZpbmVzIHRoZSBzeW50YXggb2YgaW5mb3JtYXRpb24gZGF0YSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNpbXBsZSBkYXRhIHR5cGVzIGFzIHdlbGwgYXMgYSBub3RhdGlvbiBmb3IgZGVzY3JpYmluZyB0aGVtIGFuZCBzcGVjaWZ5aW5nXG4gKiB2YWx1ZXMgZm9yIHRoZW0uXG4gKlxuICogVGhlIFJTQSBhbGdvcml0aG0gY3JlYXRlcyBwdWJsaWMgYW5kIHByaXZhdGUga2V5cyB0aGF0IGFyZSBvZnRlbiBzdG9yZWQgaW5cbiAqIFguNTA5IG9yIFBLQ1MjWCBmb3JtYXRzIC0tIHdoaWNoIHVzZSBBU04uMSAoZW5jb2RlZCBpbiBERVIgZm9ybWF0KS4gVGhpc1xuICogY2xhc3MgcHJvdmlkZXMgdGhlIG1vc3QgYmFzaWMgZnVuY3Rpb25hbGl0eSByZXF1aXJlZCB0byBzdG9yZSBhbmQgbG9hZCBEU0FcbiAqIGtleXMgdGhhdCBhcmUgZW5jb2RlZCBhY2NvcmRpbmcgdG8gQVNOLjEuXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIGJpbmFyeSBlbmNvZGluZ3MgZm9yIEFTTi4xIGFyZSBCRVIgKEJhc2ljIEVuY29kaW5nIFJ1bGVzKVxuICogYW5kIERFUiAoRGlzdGluZ3Vpc2hlZCBFbmNvZGluZyBSdWxlcykuIERFUiBpcyBqdXN0IGEgc3Vic2V0IG9mIEJFUiB0aGF0XG4gKiBoYXMgc3RyaWN0ZXIgcmVxdWlyZW1lbnRzIGZvciBob3cgZGF0YSBtdXN0IGJlIGVuY29kZWQuXG4gKlxuICogRWFjaCBBU04uMSBzdHJ1Y3R1cmUgaGFzIGEgdGFnIChhIGJ5dGUgaWRlbnRpZnlpbmcgdGhlIEFTTi4xIHN0cnVjdHVyZSB0eXBlKVxuICogYW5kIGEgYnl0ZSBhcnJheSBmb3IgdGhlIHZhbHVlIG9mIHRoaXMgQVNOMSBzdHJ1Y3R1cmUgd2hpY2ggbWF5IGJlIGRhdGEgb3IgYVxuICogbGlzdCBvZiBBU04uMSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEVhY2ggQVNOLjEgc3RydWN0dXJlIHVzaW5nIEJFUiBpcyAoVGFnLUxlbmd0aC1WYWx1ZSk6XG4gKlxuICogfCBieXRlIDAgfCBieXRlcyBYIHwgYnl0ZXMgWSB8XG4gKiB8LS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS1cbiAqIHwgIHRhZyAgIHwgbGVuZ3RoICB8ICB2YWx1ZSAgfFxuICpcbiAqIEFTTi4xIGFsbG93cyBmb3IgdGFncyB0byBiZSBvZiBcIkhpZ2gtdGFnLW51bWJlciBmb3JtXCIgd2hpY2ggYWxsb3dzIGEgdGFnIHRvXG4gKiBiZSB0d28gb3IgbW9yZSBvY3RldHMsIGJ1dCB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBjbGFzcy4gQSB0YWcgaXNcbiAqIG9ubHkgMSBieXRlLiBCaXRzIDEtNSBnaXZlIHRoZSB0YWcgbnVtYmVyIChpZSB0aGUgZGF0YSB0eXBlIHdpdGhpbiBhXG4gKiBwYXJ0aWN1bGFyICdjbGFzcycpLCA2IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgQVNOLjEgdmFsdWUgaXNcbiAqIGNvbnN0cnVjdGVkIGZyb20gb3RoZXIgQVNOLjEgdmFsdWVzLCBhbmQgYml0cyA3IGFuZCA4IGdpdmUgdGhlICdjbGFzcycuIElmXG4gKiBiaXRzIDcgYW5kIDggYXJlIGJvdGggemVybywgdGhlIGNsYXNzIGlzIFVOSVZFUlNBTC4gSWYgb25seSBiaXQgNyBpcyBzZXQsXG4gKiB0aGVuIHRoZSBjbGFzcyBpcyBBUFBMSUNBVElPTi4gSWYgb25seSBiaXQgOCBpcyBzZXQsIHRoZW4gdGhlIGNsYXNzIGlzXG4gKiBDT05URVhUX1NQRUNJRklDLiBJZiBib3RoIGJpdHMgNyBhbmQgOCBhcmUgc2V0LCB0aGVuIHRoZSBjbGFzcyBpcyBQUklWQVRFLlxuICogVGhlIHRhZyBudW1iZXJzIGZvciB0aGUgZGF0YSB0eXBlcyBmb3IgdGhlIGNsYXNzIFVOSVZFUlNBTCBhcmUgbGlzdGVkIGJlbG93OlxuICpcbiAqIFVOSVZFUlNBTCAwIFJlc2VydmVkIGZvciB1c2UgYnkgdGhlIGVuY29kaW5nIHJ1bGVzXG4gKiBVTklWRVJTQUwgMSBCb29sZWFuIHR5cGVcbiAqIFVOSVZFUlNBTCAyIEludGVnZXIgdHlwZVxuICogVU5JVkVSU0FMIDMgQml0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA0IE9jdGV0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA1IE51bGwgdHlwZVxuICogVU5JVkVSU0FMIDYgT2JqZWN0IGlkZW50aWZpZXIgdHlwZVxuICogVU5JVkVSU0FMIDcgT2JqZWN0IGRlc2NyaXB0b3IgdHlwZVxuICogVU5JVkVSU0FMIDggRXh0ZXJuYWwgdHlwZSBhbmQgSW5zdGFuY2Utb2YgdHlwZVxuICogVU5JVkVSU0FMIDkgUmVhbCB0eXBlXG4gKiBVTklWRVJTQUwgMTAgRW51bWVyYXRlZCB0eXBlXG4gKiBVTklWRVJTQUwgMTEgRW1iZWRkZWQtcGR2IHR5cGVcbiAqIFVOSVZFUlNBTCAxMiBVVEY4U3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCAxMyBSZWxhdGl2ZSBvYmplY3QgaWRlbnRpZmllciB0eXBlXG4gKiBVTklWRVJTQUwgMTQtMTUgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSBlZGl0aW9uc1xuICogVU5JVkVSU0FMIDE2IFNlcXVlbmNlIGFuZCBTZXF1ZW5jZS1vZiB0eXBlc1xuICogVU5JVkVSU0FMIDE3IFNldCBhbmQgU2V0LW9mIHR5cGVzXG4gKiBVTklWRVJTQUwgMTgtMjIsIDI1LTMwIENoYXJhY3RlciBzdHJpbmcgdHlwZXNcbiAqIFVOSVZFUlNBTCAyMy0yNCBUaW1lIHR5cGVzXG4gKlxuICogVGhlIGxlbmd0aCBvZiBhbiBBU04uMSBzdHJ1Y3R1cmUgaXMgc3BlY2lmaWVkIGFmdGVyIHRoZSB0YWcgaWRlbnRpZmllci5cbiAqIFRoZXJlIGlzIGEgZGVmaW5pdGUgZm9ybSBhbmQgYW4gaW5kZWZpbml0ZSBmb3JtLiBUaGUgaW5kZWZpbml0ZSBmb3JtIG1heVxuICogYmUgdXNlZCBpZiB0aGUgZW5jb2RpbmcgaXMgY29uc3RydWN0ZWQgYW5kIG5vdCBhbGwgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICogVGhlIGluZGVmaW5pdGUgZm9ybSBpcyBlbmNvZGVkIHVzaW5nIGEgbGVuZ3RoIGJ5dGUgd2l0aCBvbmx5IHRoZSA4dGggYml0XG4gKiBzZXQuIFRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdGVkIG9iamVjdCBpcyBtYXJrZWQgdXNpbmcgZW5kLW9mLWNvbnRlbnRzXG4gKiBvY3RldHMgKHR3byB6ZXJvIGJ5dGVzKS5cbiAqXG4gKiBUaGUgZGVmaW5pdGUgZm9ybSBsb29rcyBsaWtlIHRoaXM6XG4gKlxuICogVGhlIGxlbmd0aCBtYXkgdGFrZSB1cCAxIG9yIG1vcmUgYnl0ZXMsIGl0IGRlcGVuZHMgb24gdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHZhbHVlIG9mIHRoZSBBU04uMSBzdHJ1Y3R1cmUuIERFUiBlbmNvZGluZyByZXF1aXJlcyB0aGF0IGlmIHRoZSBBU04uMVxuICogc3RydWN0dXJlIGhhcyBhIHZhbHVlIHRoYXQgaGFzIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxMjcsIG1vcmUgdGhhbiAxIGJ5dGVcbiAqIHdpbGwgYmUgdXNlZCB0byBzdG9yZSBpdHMgbGVuZ3RoLCBvdGhlcndpc2UganVzdCBvbmUgYnl0ZSB3aWxsIGJlIHVzZWQuXG4gKiBUaGlzIGlzIHN0cmljdC5cbiAqXG4gKiBJbiB0aGUgY2FzZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIEFTTi4xIHZhbHVlIGlzIGxlc3MgdGhhbiAxMjcsIDEgb2N0ZXRcbiAqIChieXRlKSBpcyB1c2VkIHRvIHN0b3JlIHRoZSBcInNob3J0IGZvcm1cIiBsZW5ndGguIFRoZSA4dGggYml0IGhhcyBhIHZhbHVlIG9mXG4gKiAwIGluZGljYXRpbmcgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBhbmQgbm90IFwibG9uZyBmb3JtXCIgYW5kIGJpdHMgNy0xXG4gKiBnaXZlIHRoZSBsZW5ndGggb2YgdGhlIGRhdGEuIChUaGUgOHRoIGJpdCBpcyB0aGUgbGVmdC1tb3N0LCBtb3N0IHNpZ25pZmljYW50XG4gKiBiaXQ6IGFsc28ga25vd24gYXMgYmlnIGVuZGlhbiBvciBuZXR3b3JrIGZvcm1hdCkuXG4gKlxuICogSW4gdGhlIGNhc2UgdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZSBBU04uMSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMTI3LCAyIHRvXG4gKiAxMjcgb2N0ZXRzIChieXRlcykgYXJlIHVzZWQgdG8gc3RvcmUgdGhlIFwibG9uZyBmb3JtXCIgbGVuZ3RoLiBUaGUgZmlyc3RcbiAqIGJ5dGUncyA4dGggYml0IGlzIHNldCB0byAxIHRvIGluZGljYXRlIHRoZSBsZW5ndGggaXMgXCJsb25nIGZvcm0uXCIgQml0cyA3LTFcbiAqIGdpdmUgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG9jdGV0cy4gQWxsIGZvbGxvd2luZyBvY3RldHMgYXJlIGluIGJhc2UgMjU2XG4gKiB3aXRoIHRoZSBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0ICh0eXBpY2FsIGJpZy1lbmRpYW4gYmluYXJ5IHVuc2lnbmVkXG4gKiBpbnRlZ2VyIHN0b3JhZ2UpLiBTbywgZm9yIGluc3RhbmNlLCBpZiB0aGUgbGVuZ3RoIG9mIGEgdmFsdWUgd2FzIDI1NywgdGhlXG4gKiBmaXJzdCBieXRlIHdvdWxkIGJlIHNldCB0bzpcbiAqXG4gKiAxMDAwMDAxMCA9IDEzMCA9IDB4ODIuXG4gKlxuICogVGhpcyBpbmRpY2F0ZXMgdGhlcmUgYXJlIDIgb2N0ZXRzIChiYXNlIDI1NikgZm9yIHRoZSBsZW5ndGguIFRoZSBzZWNvbmQgYW5kXG4gKiB0aGlyZCBieXRlcyAodGhlIG9jdGV0cyBqdXN0IG1lbnRpb25lZCkgd291bGQgc3RvcmUgdGhlIGxlbmd0aCBpbiBiYXNlIDI1NjpcbiAqXG4gKiBvY3RldCAyOiAwMDAwMDAwMSA9IDEgKiAyNTZeMSA9IDI1NlxuICogb2N0ZXQgMzogMDAwMDAwMDEgPSAxICogMjU2XjAgPSAxXG4gKiB0b3RhbCA9IDI1N1xuICpcbiAqIFRoZSBhbGdvcml0aG0gZm9yIGNvbnZlcnRpbmcgYSBqcyBpbnRlZ2VyIHZhbHVlIG9mIDI1NyB0byBiYXNlLTI1NiBpczpcbiAqXG4gKiB2YXIgdmFsdWUgPSAyNTc7XG4gKiB2YXIgYnl0ZXMgPSBbXTtcbiAqIGJ5dGVzWzBdID0gKHZhbHVlID4+PiA4KSAmIDB4RkY7IC8vIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdFxuICogYnl0ZXNbMV0gPSB2YWx1ZSAmIDB4RkY7ICAgICAgICAvLyBsZWFzdCBzaWduaWZpY2FudCBieXRlIGxhc3RcbiAqXG4gKiBPbiB0aGUgQVNOLjEgVU5JVkVSU0FMIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIHR5cGU6XG4gKlxuICogQW4gT0lEIGNhbiBiZSB3cml0dGVuIGxpa2U6IFwidmFsdWUxLnZhbHVlMi52YWx1ZTMuLi52YWx1ZU5cIlxuICpcbiAqIFRoZSBERVIgZW5jb2RpbmcgcnVsZXM6XG4gKlxuICogVGhlIGZpcnN0IGJ5dGUgaGFzIHRoZSB2YWx1ZSA0MCAqIHZhbHVlMSArIHZhbHVlMi5cbiAqIFRoZSBmb2xsb3dpbmcgYnl0ZXMsIGlmIGFueSwgZW5jb2RlIHRoZSByZW1haW5pbmcgdmFsdWVzLiBFYWNoIHZhbHVlIGlzXG4gKiBlbmNvZGVkIGluIGJhc2UgMTI4LCBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0IChiaWcgZW5kaWFuKSwgd2l0aCBhc1xuICogZmV3IGRpZ2l0cyBhcyBwb3NzaWJsZSwgYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiBlYWNoIGJ5dGUgc2V0XG4gKiB0byAxIGV4Y2VwdCB0aGUgbGFzdCBpbiBlYWNoIHZhbHVlJ3MgZW5jb2RpbmcuIEZvciBleGFtcGxlOiBHaXZlbiB0aGVcbiAqIE9JRCBcIjEuMi44NDAuMTEzNTQ5XCIsIGl0cyBERVIgZW5jb2RpbmcgaXMgKHJlbWVtYmVyIGVhY2ggYnl0ZSBleGNlcHQgdGhlXG4gKiBsYXN0IG9uZSBpbiBlYWNoIGVuY29kaW5nIGlzIE9SJ2Qgd2l0aCAweDgwKTpcbiAqXG4gKiBieXRlIDE6IDQwICogMSArIDIgPSA0MiA9IDB4MkEuXG4gKiBieXRlcyAyLTM6IDEyOCAqIDYgKyA3MiA9IDg0MCA9IDYgNzIgPSA2IDcyID0gMHgwNjQ4ID0gMHg4NjQ4XG4gKiBieXRlcyA0LTY6IDE2Mzg0ICogNiArIDEyOCAqIDExOSArIDEzID0gNiAxMTkgMTMgPSAweDA2NzcwRCA9IDB4ODZGNzBEXG4gKlxuICogVGhlIGZpbmFsIHZhbHVlIGlzOiAweDJBODY0ODg2RjcwRC5cbiAqIFRoZSBmdWxsIE9JRCAoaW5jbHVkaW5nIEFTTi4xIHRhZyBhbmQgbGVuZ3RoIG9mIDYgYnl0ZXMpIGlzOlxuICogMHgwNjA2MkE4NjQ4ODZGNzBEXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLyogQVNOLjEgQVBJICovXG52YXIgYXNuMSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYXNuMSA9IGZvcmdlLmFzbjEgfHwge307XG5cbi8qKlxuICogQVNOLjEgY2xhc3Nlcy5cbiAqL1xuYXNuMS5DbGFzcyA9IHtcbiAgVU5JVkVSU0FMOiAgICAgICAgMHgwMCxcbiAgQVBQTElDQVRJT046ICAgICAgMHg0MCxcbiAgQ09OVEVYVF9TUEVDSUZJQzogMHg4MCxcbiAgUFJJVkFURTogICAgICAgICAgMHhDMFxufTtcblxuLyoqXG4gKiBBU04uMSB0eXBlcy4gTm90IGFsbCB0eXBlcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb24sIG9ubHlcbiAqIHRob3NlIG5lY2Vzc2FyeSB0byBpbXBsZW1lbnQgYSBzaW1wbGUgUEtJIGFyZSBpbXBsZW1lbnRlZC5cbiAqL1xuYXNuMS5UeXBlID0ge1xuICBOT05FOiAgICAgICAgICAgICAwLFxuICBCT09MRUFOOiAgICAgICAgICAxLFxuICBJTlRFR0VSOiAgICAgICAgICAyLFxuICBCSVRTVFJJTkc6ICAgICAgICAzLFxuICBPQ1RFVFNUUklORzogICAgICA0LFxuICBOVUxMOiAgICAgICAgICAgICA1LFxuICBPSUQ6ICAgICAgICAgICAgICA2LFxuICBPREVTQzogICAgICAgICAgICA3LFxuICBFWFRFUk5BTDogICAgICAgICA4LFxuICBSRUFMOiAgICAgICAgICAgICA5LFxuICBFTlVNRVJBVEVEOiAgICAgIDEwLFxuICBFTUJFRERFRDogICAgICAgIDExLFxuICBVVEY4OiAgICAgICAgICAgIDEyLFxuICBST0lEOiAgICAgICAgICAgIDEzLFxuICBTRVFVRU5DRTogICAgICAgIDE2LFxuICBTRVQ6ICAgICAgICAgICAgIDE3LFxuICBQUklOVEFCTEVTVFJJTkc6IDE5LFxuICBJQTVTVFJJTkc6ICAgICAgIDIyLFxuICBVVENUSU1FOiAgICAgICAgIDIzLFxuICBHRU5FUkFMSVpFRFRJTUU6IDI0LFxuICBCTVBTVFJJTkc6ICAgICAgIDMwXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRhZ0NsYXNzIHRoZSB0YWcgY2xhc3MgZm9yIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0gdHlwZSB0aGUgZGF0YSB0eXBlICh0YWcgbnVtYmVyKSBmb3IgdGhlIG9iamVjdC5cbiAqIEBwYXJhbSBjb25zdHJ1Y3RlZCB0cnVlIGlmIHRoZSBhc24xIG9iamVjdCBpcyBpbiBjb25zdHJ1Y3RlZCBmb3JtLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBmb3IgdGhlIG9iamVjdCwgaWYgaXQgaXMgbm90IGNvbnN0cnVjdGVkLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYml0U3RyaW5nQ29udGVudHNdIHRoZSBwbGFpbiBCSVQgU1RSSU5HIGNvbnRlbnQgaW5jbHVkaW5nIHBhZGRpbmdcbiAqICAgICAgICAgICAgYnl0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5jcmVhdGUgPSBmdW5jdGlvbih0YWdDbGFzcywgdHlwZSwgY29uc3RydWN0ZWQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIC8qIEFuIGFzbjEgb2JqZWN0IGhhcyBhIHRhZ0NsYXNzLCBhIHR5cGUsIGEgY29uc3RydWN0ZWQgZmxhZywgYW5kIGFcbiAgICB2YWx1ZS4gVGhlIHZhbHVlJ3MgdHlwZSBkZXBlbmRzIG9uIHRoZSBjb25zdHJ1Y3RlZCBmbGFnLiBJZlxuICAgIGNvbnN0cnVjdGVkLCBpdCB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIG90aGVyIGFzbjEgb2JqZWN0cy4gSWYgbm90LFxuICAgIGl0IHdpbGwgY29udGFpbiB0aGUgQVNOLjEgdmFsdWUgYXMgYW4gYXJyYXkgb2YgYnl0ZXMgZm9ybWF0dGVkXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBBU04uMSBkYXRhIHR5cGUuICovXG5cbiAgLy8gcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXNcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKHZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdG1wLnB1c2godmFsdWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHRtcDtcbiAgfVxuXG4gIHZhciBvYmogPSB7XG4gICAgdGFnQ2xhc3M6IHRhZ0NsYXNzLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29uc3RydWN0ZWQ6IGNvbnN0cnVjdGVkLFxuICAgIGNvbXBvc2VkOiBjb25zdHJ1Y3RlZCB8fCBmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xuICBpZihvcHRpb25zICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb3B0aW9ucykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICBvYmouYml0U3RyaW5nQ29udGVudHMgPSBvcHRpb25zLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgIC8vIFRPRE86IGFkZCByZWFkb25seSBmbGFnIHRvIGF2b2lkIHRoaXMgb3ZlcmhlYWRcbiAgICAvLyBzYXZlIGNvcHkgdG8gZGV0ZWN0IGNoYW5nZXNcbiAgICBvYmoub3JpZ2luYWwgPSBhc24xLmNvcHkob2JqKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgYW4gYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSBvYmplY3QuXG4gKiBAcGFyYW0gW29wdGlvbnNdIGNvcHkgb3B0aW9uczpcbiAqICAgICAgICAgIFtleGNsdWRlQml0U3RyaW5nQ29udGVudHNdIHRydWUgdG8gbm90IGNvcHkgYml0U3RyaW5nQ29udGVudHNcbiAqXG4gKiBAcmV0dXJuIHRoZSBhIGNvcHkgb2YgdGhlIGFzbjEgb2JqZWN0LlxuICovXG5hc24xLmNvcHkgPSBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGNvcHk7XG5cbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICBjb3B5ID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgY29weS5wdXNoKGFzbjEuY29weShvYmpbaV0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICBpZih0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgY29weSA9IHtcbiAgICB0YWdDbGFzczogb2JqLnRhZ0NsYXNzLFxuICAgIHR5cGU6IG9iai50eXBlLFxuICAgIGNvbnN0cnVjdGVkOiBvYmouY29uc3RydWN0ZWQsXG4gICAgY29tcG9zZWQ6IG9iai5jb21wb3NlZCxcbiAgICB2YWx1ZTogYXNuMS5jb3B5KG9iai52YWx1ZSwgb3B0aW9ucylcbiAgfTtcbiAgaWYob3B0aW9ucyAmJiAhb3B0aW9ucy5leGNsdWRlQml0U3RyaW5nQ29udGVudHMpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgY29weS5iaXRTdHJpbmdDb250ZW50cyA9IG9iai5iaXRTdHJpbmdDb250ZW50cztcbiAgfVxuICByZXR1cm4gY29weTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgYXNuMSBvYmplY3RzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBOb3RlIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcnVuIGluIGNvbnN0YW50IHRpbWUuXG4gKlxuICogQHBhcmFtIG9iajEgdGhlIGZpcnN0IGFzbjEgb2JqZWN0LlxuICogQHBhcmFtIG9iajIgdGhlIHNlY29uZCBhc24xIG9iamVjdC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gY29tcGFyZSBvcHRpb25zOlxuICogICAgICAgICAgW2luY2x1ZGVCaXRTdHJpbmdDb250ZW50c10gdHJ1ZSB0byBjb21wYXJlIGJpdFN0cmluZ0NvbnRlbnRzXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBhc24xIG9iamVjdHMgYXJlIGVxdWFsLlxuICovXG5hc24xLmVxdWFscyA9IGZ1bmN0aW9uKG9iajEsIG9iajIsIG9wdGlvbnMpIHtcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iajEpKSB7XG4gICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShvYmoyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZihvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iajEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKCFhc24xLmVxdWFscyhvYmoxW2ldLCBvYmoyW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgIT09IHR5cGVvZiBvYmoyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIH1cblxuICB2YXIgZXF1YWwgPSBvYmoxLnRhZ0NsYXNzID09PSBvYmoyLnRhZ0NsYXNzICYmXG4gICAgb2JqMS50eXBlID09PSBvYmoyLnR5cGUgJiZcbiAgICBvYmoxLmNvbnN0cnVjdGVkID09PSBvYmoyLmNvbnN0cnVjdGVkICYmXG4gICAgb2JqMS5jb21wb3NlZCA9PT0gb2JqMi5jb21wb3NlZCAmJlxuICAgIGFzbjEuZXF1YWxzKG9iajEudmFsdWUsIG9iajIudmFsdWUpO1xuICBpZihvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgZXF1YWwgPSBlcXVhbCAmJiAob2JqMS5iaXRTdHJpbmdDb250ZW50cyA9PT0gb2JqMi5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH1cblxuICByZXR1cm4gZXF1YWw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGIgdGhlIEJFUi1lbmNvZGVkIEFTTi4xIGJ5dGUgYnVmZmVyLCBzdGFydGluZyB3aXRoIHRoZSBmaXJzdFxuICogICAgICAgICAgbGVuZ3RoIGJ5dGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbmFzbjEuZ2V0QmVyVmFsdWVMZW5ndGggPSBmdW5jdGlvbihiKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIHZhciBiMiA9IGIuZ2V0Qnl0ZSgpO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgbGVuZ3RoID0gYi5nZXRJbnQoKGIyICYgMHg3RikgPDwgMyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJ5dGUgYnVmZmVyIGhhcyBlbm91Z2ggYnl0ZXMuIFRocm93cyBhbiBFcnJvciBpZiBub3QuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgbXVzdCBoYXZlLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgbikge1xuICBpZihuID4gcmVtYWluaW5nKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHBhcnNlIERFUi4nKTtcbiAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICBlcnJvci5yZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgZXJyb3IucmVxdWVzdGVkID0gbjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbnZhciBfZ2V0VmFsdWVMZW5ndGggPSBmdW5jdGlvbihieXRlcywgcmVtYWluaW5nKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIC8vIGZyb21EZXIgYWxyZWFkeSBjaGVja2VkIHRoYXQgdGhpcyBieXRlIGV4aXN0c1xuICB2YXIgYjIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIHJlbWFpbmluZy0tO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgdmFyIGxvbmdGb3JtQnl0ZXMgPSBiMiAmIDB4N0Y7XG4gICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIGxvbmdGb3JtQnl0ZXMpO1xuICAgIGxlbmd0aCA9IGJ5dGVzLmdldEludChsb25nRm9ybUJ5dGVzIDw8IDMpO1xuICB9XG4gIC8vIEZJWE1FOiB0aGlzIHdpbGwgb25seSBoYXBwZW4gZm9yIDMyIGJpdCBnZXRJbnQgd2l0aCBoaWdoIGJpdCBzZXRcbiAgaWYobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgbGVuZ3RoOiAnICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gYXNuMSBvYmplY3QgZnJvbSBhIGJ5dGUgYnVmZmVyIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICogQHBhcmFtIFtvcHRpb25zXSBvYmplY3Qgd2l0aCBvcHRpb25zIG9yIGJvb2xlYW4gc3RyaWN0IGZsYWdcbiAqICAgICAgICAgIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbZGVjb2RlQml0U3RyaW5nc10gdHJ1ZSB0byBhdHRlbXB0IHRvIGRlY29kZSB0aGUgY29udGVudCBvZlxuICogICAgICAgICAgICBCSVQgU1RSSU5HcyAobm90IE9DVEVUIFNUUklOR3MpIHVzaW5nIHN0cmljdCBtb2RlLiBOb3RlIHRoYXRcbiAqICAgICAgICAgICAgd2l0aG91dCBzY2hlbWEgc3VwcG9ydCB0byB1bmRlcnN0YW5kIHRoZSBkYXRhIGNvbnRleHQgdGhpcyBjYW5cbiAqICAgICAgICAgICAgZXJyb25lb3VzbHkgZGVjb2RlIHZhbHVlcyB0aGF0IGhhcHBlbiB0byBiZSB2YWxpZCBBU04uMS4gVGhpc1xuICogICAgICAgICAgICBmbGFnIHdpbGwgYmUgZGVwcmVjYXRlZCBvciByZW1vdmVkIGFzIHNvb24gYXMgc2NoZW1hIHN1cHBvcnQgaXNcbiAqICAgICAgICAgICAgYXZhaWxhYmxlLiAoZGVmYXVsdDogdHJ1ZSlcbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuZnJvbURlciA9IGZ1bmN0aW9uKGJ5dGVzLCBvcHRpb25zKSB7XG4gIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdDogb3B0aW9ucyxcbiAgICAgIGRlY29kZUJpdFN0cmluZ3M6IHRydWVcbiAgICB9O1xuICB9XG4gIGlmKCEoJ3N0cmljdCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnN0cmljdCA9IHRydWU7XG4gIH1cbiAgaWYoISgnZGVjb2RlQml0U3RyaW5ncycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmRlY29kZUJpdFN0cmluZ3MgPSB0cnVlO1xuICB9XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIHJldHVybiBfZnJvbURlcihieXRlcywgYnl0ZXMubGVuZ3RoKCksIDAsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBhbiBhc24xIG9iamVjdCBmcm9tIGEgYnl0ZSBidWZmZXIgaW4gREVSIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gcmVtYWluaW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGZvciB0aGlzIGNodW5rLlxuICogQHBhcmFtIGRlcHRoIHRoZSBjdXJyZW50IHBhcnNpbmcgZGVwdGguXG4gKiBAcGFyYW0gb3B0aW9ucyBvYmplY3Qgd2l0aCBzYW1lIG9wdGlvbnMgYXMgZnJvbURlcigpLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBhc24xIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGgsIG9wdGlvbnMpIHtcbiAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvbnN1bXB0aW9uIGNhbGN1bGF0aW9uc1xuICB2YXIgc3RhcnQ7XG5cbiAgLy8gbWluaW11bSBsZW5ndGggZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmUgaXMgMlxuICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG5cbiAgLy8gZ2V0IHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgLy8gY29uc3VtZWQgb25lIGJ5dGVcbiAgcmVtYWluaW5nLS07XG5cbiAgLy8gZ2V0IHRoZSB0YWcgY2xhc3NcbiAgdmFyIHRhZ0NsYXNzID0gKGIxICYgMHhDMCk7XG5cbiAgLy8gZ2V0IHRoZSB0eXBlIChiaXRzIDEtNSlcbiAgdmFyIHR5cGUgPSBiMSAmIDB4MUY7XG5cbiAgLy8gZ2V0IHRoZSB2YXJpYWJsZSB2YWx1ZSBsZW5ndGggYW5kIGFkanVzdCByZW1haW5pbmcgYnl0ZXNcbiAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgdmFyIGxlbmd0aCA9IF9nZXRWYWx1ZUxlbmd0aChieXRlcywgcmVtYWluaW5nKTtcbiAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG5cbiAgLy8gZW5zdXJlIHRoZXJlIGFyZSBlbm91Z2ggYnl0ZXMgdG8gZ2V0IHRoZSB2YWx1ZVxuICBpZihsZW5ndGggIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICBpZihvcHRpb25zLnN0cmljdCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHJlYWQgQVNOLjEgdmFsdWUuJyk7XG4gICAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIGVycm9yLnJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICAgIGVycm9yLnJlcXVlc3RlZCA9IGxlbmd0aDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBOb3RlOiBiZSBsZW5pZW50IHdpdGggdHJ1bmNhdGVkIHZhbHVlcyBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIC8vIHZhbHVlIHN0b3JhZ2VcbiAgdmFyIHZhbHVlO1xuICAvLyBwb3NzaWJsZSBCSVQgU1RSSU5HIGNvbnRlbnRzIHN0b3JhZ2VcbiAgdmFyIGJpdFN0cmluZ0NvbnRlbnRzO1xuXG4gIC8vIGNvbnN0cnVjdGVkIGZsYWcgaXMgYml0IDYgKDMyID0gMHgyMCkgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGNvbnN0cnVjdGVkID0gKChiMSAmIDB4MjApID09PSAweDIwKTtcbiAgaWYoY29uc3RydWN0ZWQpIHtcbiAgICAvLyBwYXJzZSBjaGlsZCBhc24xIG9iamVjdHMgZnJvbSB0aGUgdmFsdWVcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGlmKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhc24xIG9iamVjdCBvZiBpbmRlZmluaXRlIGxlbmd0aCwgcmVhZCB1bnRpbCBlbmQgdGFnXG4gICAgICBmb3IoOzspIHtcbiAgICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuICAgICAgICBpZihieXRlcy5ieXRlcygyKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAwKSkge1xuICAgICAgICAgIGJ5dGVzLmdldEJ5dGVzKDIpO1xuICAgICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIHZhbHVlLnB1c2goX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBvcHRpb25zKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJzaW5nIGFzbjEgb2JqZWN0IG9mIGRlZmluaXRlIGxlbmd0aFxuICAgICAgd2hpbGUobGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCBsZW5ndGgsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgbGVuZ3RoIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYSBCSVQgU1RSSU5HLCBzYXZlIHRoZSBjb250ZW50cyBpbmNsdWRpbmcgcGFkZGluZ1xuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRhZ0NsYXNzID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCAmJlxuICAgIHR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICBiaXRTdHJpbmdDb250ZW50cyA9IGJ5dGVzLmJ5dGVzKGxlbmd0aCk7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgaWYgYSBub24tY29uc3RydWN0ZWQgdmFsdWUgc2hvdWxkIGJlIGRlY29kZWQgYXMgYSBjb21wb3NlZFxuICAvLyB2YWx1ZSB0aGF0IGNvbnRhaW5zIG90aGVyIEFTTi4xIG9iamVjdHMuIEJJVCBTVFJJTkdzIChhbmQgT0NURVQgU1RSSU5HcylcbiAgLy8gY2FuIGJlIHVzZWQgdGhpcyB3YXkuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5kZWNvZGVCaXRTdHJpbmdzICYmXG4gICAgdGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMICYmXG4gICAgLy8gRklYTUU6IE9DVEVUIFNUUklOR3Mgbm90IHlldCBzdXBwb3J0ZWQgaGVyZVxuICAgIC8vIC4uIG90aGVyIHBhcnRzIG9mIGZvcmdlIGV4cGVjdCB0byBkZWNvZGUgT0NURVQgU1RSSU5HcyBtYW51YWxseVxuICAgICh0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HIC8qfHwgdHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKi8pICYmXG4gICAgbGVuZ3RoID4gMSkge1xuICAgIC8vIHNhdmUgcmVhZCBwb3NpdGlvblxuICAgIHZhciBzYXZlZFJlYWQgPSBieXRlcy5yZWFkO1xuICAgIHZhciBzYXZlZFJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICBpZih0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgICAvKiBUaGUgZmlyc3Qgb2N0ZXQgZ2l2ZXMgdGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgIGJpdCBzdHJpbmcgaXMgbGVzcyB0aGFuIHRoZSBuZXh0IG11bHRpcGxlIG9mIGVpZ2h0ICh0aGlzIGlzIGNhbGxlZFxuICAgICAgICB0aGUgXCJudW1iZXIgb2YgdW51c2VkIGJpdHNcIikuXG5cbiAgICAgICAgVGhlIHNlY29uZCBhbmQgZm9sbG93aW5nIG9jdGV0cyBnaXZlIHRoZSB2YWx1ZSBvZiB0aGUgYml0IHN0cmluZ1xuICAgICAgICBjb252ZXJ0ZWQgdG8gYW4gb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDEpO1xuICAgICAgdW51c2VkID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICAgICAgcmVtYWluaW5nLS07XG4gICAgfVxuICAgIC8vIGlmIGFsbCBiaXRzIGFyZSB1c2VkLCBtYXliZSB0aGUgQklUL09DVEVUIFNUUklORyBob2xkcyBBU04uMSBvYmpzXG4gICAgaWYodW51c2VkID09PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhdHRlbXB0IHRvIHBhcnNlIGNoaWxkIGFzbjEgb2JqZWN0IGZyb20gdGhlIHZhbHVlXG4gICAgICAgIC8vIChzdG9yZWQgaW4gYXJyYXkgdG8gc2lnbmFsIGNvbXBvc2VkIHZhbHVlKVxuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3ViT3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBlbmZvcmNlIHN0cmljdCBtb2RlIHRvIGF2b2lkIHBhcnNpbmcgQVNOLjEgZnJvbSBwbGFpbiBkYXRhXG4gICAgICAgICAgdmVyYm9zZTogb3B0aW9ucy52ZXJib3NlLFxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wb3NlZCA9IF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoICsgMSwgc3ViT3B0aW9ucyk7XG4gICAgICAgIHZhciB1c2VkID0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHVzZWQ7XG4gICAgICAgIGlmKHR5cGUgPT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgICAgIHVzZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBkYXRhIGFsbCBkZWNvZGVkIGFuZCB0aGUgY2xhc3MgaW5kaWNhdGVzIFVOSVZFUlNBTCBvclxuICAgICAgICAvLyBDT05URVhUX1NQRUNJRklDIHRoZW4gYXNzdW1lIHdlJ3ZlIGdvdCBhbiBlbmNhcHN1bGF0ZWQgQVNOLjEgb2JqZWN0XG4gICAgICAgIHZhciB0YyA9IGNvbXBvc2VkLnRhZ0NsYXNzO1xuICAgICAgICBpZih1c2VkID09PSBsZW5ndGggJiZcbiAgICAgICAgICAodGMgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8IHRjID09PSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMpKSB7XG4gICAgICAgICAgdmFsdWUgPSBbY29tcG9zZWRdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJlc3RvcmUgcmVhZCBwb3NpdGlvblxuICAgICAgYnl0ZXMucmVhZCA9IHNhdmVkUmVhZDtcbiAgICAgIHJlbWFpbmluZyA9IHNhdmVkUmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBhc24xIG5vdCBjb25zdHJ1Y3RlZCBvciBjb21wb3NlZCwgZ2V0IHJhdyB2YWx1ZVxuICAgIC8vIFRPRE86IGRvIERFUiB0byBPSUQgY29udmVyc2lvbiBhbmQgdmljZS12ZXJzYSBpbiAudG9EZXI/XG5cbiAgICBpZihsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tY29uc3RydWN0ZWQgQVNOLjEgb2JqZWN0IG9mIGluZGVmaW5pdGUgbGVuZ3RoLicpO1xuICAgICAgfVxuICAgICAgLy8gYmUgbGVuaWVudCBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cblxuICAgIGlmKHR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgICBmb3IoOyBsZW5ndGggPiAwOyBsZW5ndGggLT0gMikge1xuICAgICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG4gICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXMuZ2V0SW50MTYoKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGJ5dGVzLmdldEJ5dGVzKGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlXG4gIHZhciBhc24xT3B0aW9ucyA9IGJpdFN0cmluZ0NvbnRlbnRzID09PSB1bmRlZmluZWQgPyAgbnVsbCA6IHtcbiAgICBiaXRTdHJpbmdDb250ZW50czogYml0U3RyaW5nQ29udGVudHNcbiAgfTtcblxuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhc24xIG9iamVjdFxuICByZXR1cm4gYXNuMS5jcmVhdGUodGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgYXNuMU9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhc24xIG9iamVjdCB0byBhIGJ1ZmZlciBvZiBieXRlcyBpbiBERVIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBhc24xIHRoZSBhc24xIG9iamVjdCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ1ZmZlciBvZiBieXRlcy5cbiAqL1xuYXNuMS50b0RlciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGJ1aWxkIHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IG9iai50YWdDbGFzcyB8IG9iai50eXBlO1xuXG4gIC8vIGZvciBzdG9yaW5nIHRoZSBBU04uMSB2YWx1ZVxuICB2YXIgdmFsdWUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZSBCSVQgU1RSSU5HIGNvbnRlbnRzIGlmIGF2YWlsYWJsZSBhbmQgZGF0YSBub3QgY2hhbmdlZFxuICB2YXIgdXNlQml0U3RyaW5nQ29udGVudHMgPSBmYWxzZTtcbiAgaWYoJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvYmopIHtcbiAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IHRydWU7XG4gICAgaWYob2JqLm9yaWdpbmFsKSB7XG4gICAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGFzbjEuZXF1YWxzKG9iaiwgb2JqLm9yaWdpbmFsKTtcbiAgICB9XG4gIH1cblxuICBpZih1c2VCaXRTdHJpbmdDb250ZW50cykge1xuICAgIHZhbHVlLnB1dEJ5dGVzKG9iai5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH0gZWxzZSBpZihvYmouY29tcG9zZWQpIHtcbiAgICAvLyBpZiBjb21wb3NlZCwgdXNlIGVhY2ggY2hpbGQgYXNuMSBvYmplY3QncyBERVIgYnl0ZXMgYXMgdmFsdWVcbiAgICAvLyB0dXJuIG9uIDZ0aCBiaXQgKDB4MjAgPSAzMikgdG8gaW5kaWNhdGUgYXNuMSBpcyBjb25zdHJ1Y3RlZFxuICAgIC8vIGZyb20gb3RoZXIgYXNuMSBvYmplY3RzXG4gICAgaWYob2JqLmNvbnN0cnVjdGVkKSB7XG4gICAgICBiMSB8PSAweDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0eXBlIGlzIGEgYml0IHN0cmluZywgYWRkIHVudXNlZCBiaXRzIG9mIDB4MDBcbiAgICAgIHZhbHVlLnB1dEJ5dGUoMHgwMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGFsbCBvZiB0aGUgY2hpbGQgREVSIGJ5dGVzIHRvZ2V0aGVyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYob2JqLnZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUucHV0QnVmZmVyKGFzbjEudG9EZXIob2JqLnZhbHVlW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBhc24xLnZhbHVlIGRpcmVjdGx5XG4gICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUucHV0SW50MTYob2JqLnZhbHVlLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgaW50ZWdlciBpcyBtaW5pbWFsbHktZW5jb2RlZFxuICAgICAgLy8gVE9ETzogc2hvdWxkIGFsbCBsZWFkaW5nIGJ5dGVzIGJlIHN0cmlwcGVkIHZzIGp1c3Qgb25lP1xuICAgICAgLy8gLi4gZXggJzAwIDAwIDAxJyA9PiAnMDEnP1xuICAgICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSICYmXG4gICAgICAgIG9iai52YWx1ZS5sZW5ndGggPiAxICYmXG4gICAgICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAoKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAwICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAwKSB8fFxuICAgICAgICAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAweEZGICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICAgICAgdmFsdWUucHV0Qnl0ZXMob2JqLnZhbHVlLnN1YnN0cigxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5wdXRCeXRlcyhvYmoudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCB0YWcgYnl0ZVxuICBieXRlcy5wdXRCeXRlKGIxKTtcblxuICAvLyB1c2UgXCJzaG9ydCBmb3JtXCIgZW5jb2RpbmdcbiAgaWYodmFsdWUubGVuZ3RoKCkgPD0gMTI3KSB7XG4gICAgLy8gb25lIGJ5dGUgZGVzY3JpYmVzIHRoZSBsZW5ndGhcbiAgICAvLyBiaXQgOCA9IDAgYW5kIGJpdHMgNy0xID0gbGVuZ3RoXG4gICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZS5sZW5ndGgoKSAmIDB4N0YpO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBcImxvbmcgZm9ybVwiIGVuY29kaW5nXG4gICAgLy8gMiB0byAxMjcgYnl0ZXMgZGVzY3JpYmUgdGhlIGxlbmd0aFxuICAgIC8vIGZpcnN0IGJ5dGU6IGJpdCA4ID0gMSBhbmQgYml0cyA3LTEgPSAjIG9mIGFkZGl0aW9uYWwgYnl0ZXNcbiAgICAvLyBvdGhlciBieXRlczogbGVuZ3RoIGluIGJhc2UgMjU2LCBiaWctZW5kaWFuXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCgpO1xuICAgIHZhciBsZW5CeXRlcyA9ICcnO1xuICAgIGRvIHtcbiAgICAgIGxlbkJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuICYgMHhGRik7XG4gICAgICBsZW4gPSBsZW4gPj4+IDg7XG4gICAgfSB3aGlsZShsZW4gPiAwKTtcblxuICAgIC8vIHNldCBmaXJzdCBieXRlIHRvICMgYnl0ZXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIGFuZCB0dXJuIG9uXG4gICAgLy8gYml0IDggdG8gaW5kaWNhdGUgbG9uZy1mb3JtIGxlbmd0aCBpcyB1c2VkXG4gICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5sZW5ndGggfCAweDgwKTtcblxuICAgIC8vIGNvbmNhdGVuYXRlIGxlbmd0aCBieXRlcyBpbiByZXZlcnNlIHNpbmNlIHRoZXkgd2VyZSBnZW5lcmF0ZWRcbiAgICAvLyBsaXR0bGUgZW5kaWFuIGFuZCB3ZSBuZWVkIGJpZyBlbmRpYW5cbiAgICBmb3IodmFyIGkgPSBsZW5CeXRlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb25jYXRlbmF0ZSB2YWx1ZSBieXRlc1xuICBieXRlcy5wdXRCdWZmZXIodmFsdWUpO1xuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZyB0byBhIGJ5dGUgYnVmZmVyLiBUaGUgYnl0ZSBidWZmZXJcbiAqIGNvbnRhaW5zIG9ubHkgdGhlIERFUi1lbmNvZGVkIHZhbHVlLCBub3QgYW55IHRhZyBvciBsZW5ndGggYnl0ZXMuXG4gKlxuICogQHBhcmFtIG9pZCB0aGUgT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUgYnVmZmVyLlxuICovXG5hc24xLm9pZFRvRGVyID0gZnVuY3Rpb24ob2lkKSB7XG4gIC8vIHNwbGl0IE9JRCBpbnRvIGluZGl2aWR1YWwgdmFsdWVzXG4gIHZhciB2YWx1ZXMgPSBvaWQuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyBmaXJzdCBieXRlIGlzIDQwICogdmFsdWUxICsgdmFsdWUyXG4gIGJ5dGVzLnB1dEJ5dGUoNDAgKiBwYXJzZUludCh2YWx1ZXNbMF0sIDEwKSArIHBhcnNlSW50KHZhbHVlc1sxXSwgMTApKTtcbiAgLy8gb3RoZXIgYnl0ZXMgYXJlIGVhY2ggdmFsdWUgaW4gYmFzZSAxMjggd2l0aCA4dGggYml0IHNldCBleGNlcHQgZm9yXG4gIC8vIHRoZSBsYXN0IGJ5dGUgZm9yIGVhY2ggdmFsdWVcbiAgdmFyIGxhc3QsIHZhbHVlQnl0ZXMsIHZhbHVlLCBiO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gcHJvZHVjZSB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBob3cgbWFueVxuICAgIC8vIGJ5dGVzIGl0IHdpbGwgdGFrZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICBsYXN0ID0gdHJ1ZTtcbiAgICB2YWx1ZUJ5dGVzID0gW107XG4gICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZXNbaV0sIDEwKTtcbiAgICBkbyB7XG4gICAgICBiID0gdmFsdWUgJiAweDdGO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBsYXN0LCB0aGVuIHR1cm4gb24gOHRoIGJpdFxuICAgICAgaWYoIWxhc3QpIHtcbiAgICAgICAgYiB8PSAweDgwO1xuICAgICAgfVxuICAgICAgdmFsdWVCeXRlcy5wdXNoKGIpO1xuICAgICAgbGFzdCA9IGZhbHNlO1xuICAgIH0gd2hpbGUodmFsdWUgPiAwKTtcblxuICAgIC8vIGFkZCB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIChuZWVkcyB0byBiZSBpbiBiaWcgZW5kaWFuKVxuICAgIGZvcih2YXIgbiA9IHZhbHVlQnl0ZXMubGVuZ3RoIC0gMTsgbiA+PSAwOyAtLW4pIHtcbiAgICAgIGJ5dGVzLnB1dEJ5dGUodmFsdWVCeXRlc1tuXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIGJ5dGUgYnVmZmVyIHRvIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy4gVGhlXG4gKiBieXRlIGJ1ZmZlciBzaG91bGQgY29udGFpbiBvbmx5IHRoZSBERVItZW5jb2RlZCB2YWx1ZSwgbm90IGFueSB0YWcgb3JcbiAqIGxlbmd0aCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy5cbiAqL1xuYXNuMS5kZXJUb09pZCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhciBvaWQ7XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIC8vIGZpcnN0IGJ5dGUgaXMgNDAgKiB2YWx1ZTEgKyB2YWx1ZTJcbiAgdmFyIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIG9pZCA9IE1hdGguZmxvb3IoYiAvIDQwKSArICcuJyArIChiICUgNDApO1xuXG4gIC8vIG90aGVyIGJ5dGVzIGFyZSBlYWNoIHZhbHVlIGluIGJhc2UgMTI4IHdpdGggOHRoIGJpdCBzZXQgZXhjZXB0IGZvclxuICAvLyB0aGUgbGFzdCBieXRlIGZvciBlYWNoIHZhbHVlXG4gIHZhciB2YWx1ZSA9IDA7XG4gIHdoaWxlKGJ5dGVzLmxlbmd0aCgpID4gMCkge1xuICAgIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gICAgdmFsdWUgPSB2YWx1ZSA8PCA3O1xuICAgIC8vIG5vdCB0aGUgbGFzdCBieXRlIGZvciB0aGUgdmFsdWVcbiAgICBpZihiICYgMHg4MCkge1xuICAgICAgdmFsdWUgKz0gYiAmIDB4N0Y7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxhc3QgYnl0ZVxuICAgICAgb2lkICs9ICcuJyArICh2YWx1ZSArIGIpO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvaWQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVVRDVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogTm90ZTogR2VuZXJhbGl6ZWRUaW1lIGhhcyA0IGRpZ2l0cyBmb3IgdGhlIHllYXIgYW5kIGlzIHVzZWQgZm9yIFguNTA5XG4gKiBkYXRlcyBwYXN0IDIwNDkuIFBhcnNpbmcgdGhhdCBzdHJ1Y3R1cmUgaGFzbid0IGJlZW4gaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSB1dGMgdGhlIFVUQ1RpbWUgdmFsdWUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkYXRlLlxuICovXG5hc24xLnV0Y1RpbWVUb0RhdGUgPSBmdW5jdGlvbih1dGMpIHtcbiAgLyogVGhlIGZvbGxvd2luZyBmb3JtYXRzIGNhbiBiZSB1c2VkOlxuXG4gICAgWVlNTUREaGhtbVpcbiAgICBZWU1NRERoaG1tK2hoJ21tJ1xuICAgIFlZTU1ERGhobW0taGgnbW0nXG4gICAgWVlNTUREaGhtbXNzWlxuICAgIFlZTU1ERGhobW1zcytoaCdtbSdcbiAgICBZWU1NRERoaG1tc3MtaGgnbW0nXG5cbiAgICBXaGVyZTpcblxuICAgIFlZIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gZGlnaXRzIG9mIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIFogaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBHTVQsICsgaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpc1xuICAgIGxhdGVyIHRoYW4gR01ULCBhbmQgLSBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIGVhcmxpZXIgdGhhbiBHTVRcbiAgICBoaCcgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gaG91cnNcbiAgICBtbScgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gbWludXRlcyAqL1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgLy8gaWYgWVkgPj0gNTAgdXNlIDE5eHgsIGlmIFlZIDwgNTAgdXNlIDIweHhcbiAgdmFyIHllYXIgPSBwYXJzZUludCh1dGMuc3Vic3RyKDAsIDIpLCAxMCk7XG4gIHllYXIgPSAoeWVhciA+PSA1MCkgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xuICB2YXIgTU0gPSBwYXJzZUludCh1dGMuc3Vic3RyKDIsIDIpLCAxMCkgLSAxOyAvLyB1c2UgMC0xMSBmb3IgbW9udGhcbiAgdmFyIEREID0gcGFyc2VJbnQodXRjLnN1YnN0cig0LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludCh1dGMuc3Vic3RyKDYsIDIpLCAxMCk7XG4gIHZhciBtbSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoOCwgMiksIDEwKTtcbiAgdmFyIHNzID0gMDtcblxuICAvLyBub3QganVzdCBZWU1NRERoaG1tWlxuICBpZih1dGMubGVuZ3RoID4gMTEpIHtcbiAgICAvLyBnZXQgY2hhcmFjdGVyIGFmdGVyIG1pbnV0ZXNcbiAgICB2YXIgYyA9IHV0Yy5jaGFyQXQoMTApO1xuICAgIHZhciBlbmQgPSAxMDtcblxuICAgIC8vIHNlZSBpZiBzZWNvbmRzIGFyZSBwcmVzZW50XG4gICAgaWYoYyAhPT0gJysnICYmIGMgIT09ICctJykge1xuICAgICAgLy8gZ2V0IHNlY29uZHNcbiAgICAgIHNzID0gcGFyc2VJbnQodXRjLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgICAgIGVuZCArPSAyO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBkYXRlXG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgTU0sIEREKTtcbiAgZGF0ZS5zZXRVVENIb3VycyhoaCwgbW0sIHNzLCAwKTtcblxuICBpZihlbmQpIHtcbiAgICAvLyBnZXQgKy8tIGFmdGVyIGVuZCBvZiB0aW1lXG4gICAgYyA9IHV0Yy5jaGFyQXQoZW5kKTtcbiAgICBpZihjID09PSAnKycgfHwgYyA9PT0gJy0nKSB7XG4gICAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgMSwgMiksIDEwKTtcbiAgICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgNCwgMiksIDEwKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIG9mZnNldCBpbiBtaWxsaXNlY29uZHNcbiAgICAgIHZhciBvZmZzZXQgPSBoaG9mZnNldCAqIDYwICsgbW1vZmZzZXQ7XG4gICAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAgIC8vIGFwcGx5IG9mZnNldFxuICAgICAgaWYoYyA9PT0gJysnKSB7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSAtIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogQHBhcmFtIGdlbnRpbWUgdGhlIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUuXG4gKi9cbmFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlID0gZnVuY3Rpb24oZ2VudGltZSkge1xuICAvKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgY2FuIGJlIHVzZWQ6XG5cbiAgICBZWVlZTU1EREhITU1TU1xuICAgIFlZWVlNTURESEhNTVNTLmZmZlxuICAgIFlZWVlNTURESEhNTVNTWlxuICAgIFlZWVlNTURESEhNTVNTLmZmZlpcbiAgICBZWVlZTU1EREhITU1TUytoaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy5mZmYraGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MtaGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MuZmZmLWhoJ21tJ1xuXG4gICAgV2hlcmU6XG5cbiAgICBZWVlZIGlzIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIC5mZmYgaXMgdGhlIHNlY29uZCBmcmFjdGlvbiwgYWNjdXJhdGUgdG8gdGhyZWUgZGVjaW1hbCBwbGFjZXNcbiAgICBaIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXMgR01ULCArIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXNcbiAgICBsYXRlciB0aGFuIEdNVCwgYW5kIC0gaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBlYXJsaWVyIHRoYW4gR01UXG4gICAgaGgnIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIGhvdXJzXG4gICAgbW0nIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIG1pbnV0ZXMgKi9cbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gIHZhciBZWVlZID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMCwgNCksIDEwKTtcbiAgdmFyIE1NID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoNCwgMiksIDEwKSAtIDE7IC8vIHVzZSAwLTExIGZvciBtb250aFxuICB2YXIgREQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig2LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig4LCAyKSwgMTApO1xuICB2YXIgbW0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgdmFyIHNzID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMTIsIDIpLCAxMCk7XG4gIHZhciBmZmYgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGlzVVRDID0gZmFsc2U7XG5cbiAgaWYoZ2VudGltZS5jaGFyQXQoZ2VudGltZS5sZW5ndGggLSAxKSA9PT0gJ1onKSB7XG4gICAgaXNVVEMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGVuZCA9IGdlbnRpbWUubGVuZ3RoIC0gNSwgYyA9IGdlbnRpbWUuY2hhckF0KGVuZCk7XG4gIGlmKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcbiAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICB2YXIgaGhvZmZzZXQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cihlbmQgKyAxLCAyKSwgMTApO1xuICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDQsIDIpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBpZihjID09PSAnKycpIHtcbiAgICAgIG9mZnNldCAqPSAtMTtcbiAgICB9XG5cbiAgICBpc1VUQyA9IHRydWU7XG4gIH1cblxuICAvLyBjaGVjayBmb3Igc2Vjb25kIGZyYWN0aW9uXG4gIGlmKGdlbnRpbWUuY2hhckF0KDE0KSA9PT0gJy4nKSB7XG4gICAgZmZmID0gcGFyc2VGbG9hdChnZW50aW1lLnN1YnN0cigxNCksIDEwKSAqIDEwMDA7XG4gIH1cblxuICBpZihpc1VUQykge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldEhvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkYXRlIHRvIGEgVVRDVGltZSB2YWx1ZS5cbiAqXG4gKiBOb3RlOiBHZW5lcmFsaXplZFRpbWUgaGFzIDQgZGlnaXRzIGZvciB0aGUgeWVhciBhbmQgaXMgdXNlZCBmb3IgWC41MDlcbiAqIGRhdGVzIHBhc3QgMjA0OS4gQ29udmVydGluZyB0byBhIEdlbmVyYWxpemVkVGltZSBoYXNuJ3QgYmVlblxuICogaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgVVRDVGltZSB2YWx1ZS5cbiAqL1xuYXNuMS5kYXRlVG9VdGNUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWU1NRERoaG1tc3NaXG4gIHZhciBmb3JtYXQgPSBbXTtcbiAgZm9ybWF0LnB1c2goKCcnICsgZGF0ZS5nZXRVVENGdWxsWWVhcigpKS5zdWJzdHIoMikpO1xuICBmb3JtYXQucHVzaCgnJyArIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDSG91cnMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENNaW51dGVzKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDU2Vjb25kcygpKTtcblxuICAvLyBlbnN1cmUgMiBkaWdpdHMgYXJlIHVzZWQgZm9yIGVhY2ggZm9ybWF0IGVudHJ5XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBmb3JtYXQubGVuZ3RoOyArK2kpIHtcbiAgICBpZihmb3JtYXRbaV0ubGVuZ3RoIDwgMikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gZm9ybWF0W2ldO1xuICB9XG4gIHJ2YWwgKz0gJ1onO1xuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gYSBHZW5lcmFsaXplZFRpbWUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBHZW5lcmFsaXplZFRpbWUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKi9cbmFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWVlZTU1EREhITU1TU1pcbiAgdmFyIGZvcm1hdCA9IFtdO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuXG4gIC8vIGVuc3VyZSAyIGRpZ2l0cyBhcmUgdXNlZCBmb3IgZWFjaCBmb3JtYXQgZW50cnlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBmb3JtYXRbaV07XG4gIH1cbiAgcnZhbCArPSAnWic7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgamF2YXNjcmlwdCBpbnRlZ2VyIHRvIGEgREVSLWVuY29kZWQgYnl0ZSBidWZmZXIgdG8gYmUgdXNlZFxuICogYXMgdGhlIHZhbHVlIGZvciBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIHggdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBidWZmZXIuXG4gKi9cbmFzbjEuaW50ZWdlclRvRGVyID0gZnVuY3Rpb24oeCkge1xuICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGlmKHggPj0gLTB4ODAgJiYgeCA8IDB4ODApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgOCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwICYmIHggPCAweDgwMDApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgMTYpO1xuICB9XG4gIGlmKHggPj0gLTB4ODAwMDAwICYmIHggPCAweDgwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAyNCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwMDAwMCAmJiB4IDwgMHg4MDAwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAzMik7XG4gIH1cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIGVycm9yLmludGVnZXIgPSB4O1xuICB0aHJvdyBlcnJvcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBieXRlIGJ1ZmZlciB0byBhIGphdmFzY3JpcHQgaW50ZWdlci4gVGhpcyBpc1xuICogdHlwaWNhbGx5IHVzZWQgdG8gZGVjb2RlIHRoZSB2YWx1ZSBvZiBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG5hc24xLmRlclRvSW50ZWdlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8vIHdyYXAgaW4gYnVmZmVyIGlmIG5lZWRlZFxuICBpZih0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gIH1cblxuICB2YXIgbiA9IGJ5dGVzLmxlbmd0aCgpICogODtcbiAgaWYobiA+IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLmdldFNpZ25lZEludChuKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGdpdmVuIEFTTi4xIG9iamVjdCBpcyBhdCBsZWFzdCBhIHN1cGVyIHNldCBvZiB0aGVcbiAqIGdpdmVuIEFTTi4xIHN0cnVjdHVyZS4gT25seSB0YWcgY2xhc3NlcyBhbmQgdHlwZXMgYXJlIGNoZWNrZWQuIEFuXG4gKiBvcHRpb25hbCBtYXAgbWF5IGFsc28gYmUgcHJvdmlkZWQgdG8gY2FwdHVyZSBBU04uMSB2YWx1ZXMgd2hpbGUgdGhlXG4gKiBzdHJ1Y3R1cmUgaXMgY2hlY2tlZC5cbiAqXG4gKiBUbyBjYXB0dXJlIGFuIEFTTi4xIHZhbHVlLCBzZXQgYW4gb2JqZWN0IGluIHRoZSB2YWxpZGF0b3IncyAnY2FwdHVyZSdcbiAqIHBhcmFtZXRlciB0byB0aGUga2V5IHRvIHVzZSBpbiB0aGUgY2FwdHVyZSBtYXAuIFRvIGNhcHR1cmUgdGhlIGZ1bGxcbiAqIEFTTi4xIG9iamVjdCwgc3BlY2lmeSAnY2FwdHVyZUFzbjEnLiBUbyBjYXB0dXJlIEJJVCBTVFJJTkcgYnl0ZXMsIGluY2x1ZGluZ1xuICogdGhlIGxlYWRpbmcgdW51c2VkIGJpdHMgY291bnRlciBieXRlLCBzcGVjaWZ5ICdjYXB0dXJlQml0U3RyaW5nQ29udGVudHMnLlxuICogVG8gY2FwdHVyZSBCSVQgU1RSSU5HIGJ5dGVzLCB3aXRob3V0IHRoZSBsZWFkaW5nIHVudXNlZCBiaXRzIGNvdW50ZXIgYnl0ZSxcbiAqIHNwZWNpZnkgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZScuXG4gKlxuICogT2JqZWN0cyBpbiB0aGUgdmFsaWRhdG9yIG1heSBzZXQgYSBmaWVsZCAnb3B0aW9uYWwnIHRvIHRydWUgdG8gaW5kaWNhdGVcbiAqIHRoYXQgaXQgaXNuJ3QgbmVjZXNzYXJ5IHRvIHBhc3MgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gdiB0aGUgQVNOLjEgc3RydWN0dXJlIHZhbGlkYXRvci5cbiAqIEBwYXJhbSBjYXB0dXJlIGFuIG9wdGlvbmFsIG1hcCB0byBjYXB0dXJlIHZhbHVlcyBpbi5cbiAqIEBwYXJhbSBlcnJvcnMgYW4gb3B0aW9uYWwgYXJyYXkgZm9yIHN0b3JpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gKi9cbmFzbjEudmFsaWRhdGUgPSBmdW5jdGlvbihvYmosIHYsIGNhcHR1cmUsIGVycm9ycykge1xuICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gIC8vIGVuc3VyZSB0YWcgY2xhc3MgYW5kIHR5cGUgYXJlIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICBpZigob2JqLnRhZ0NsYXNzID09PSB2LnRhZ0NsYXNzIHx8IHR5cGVvZih2LnRhZ0NsYXNzKSA9PT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgKG9iai50eXBlID09PSB2LnR5cGUgfHwgdHlwZW9mKHYudHlwZSkgPT09ICd1bmRlZmluZWQnKSkge1xuICAgIC8vIGVuc3VyZSBjb25zdHJ1Y3RlZCBmbGFnIGlzIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICAgIGlmKG9iai5jb25zdHJ1Y3RlZCA9PT0gdi5jb25zdHJ1Y3RlZCB8fFxuICAgICAgdHlwZW9mKHYuY29uc3RydWN0ZWQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcnZhbCA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBzdWIgdmFsdWVzXG4gICAgICBpZih2LnZhbHVlICYmIGZvcmdlLnV0aWwuaXNBcnJheSh2LnZhbHVlKSkge1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgJiYgaSA8IHYudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBydmFsID0gdi52YWx1ZVtpXS5vcHRpb25hbCB8fCBmYWxzZTtcbiAgICAgICAgICBpZihvYmoudmFsdWVbal0pIHtcbiAgICAgICAgICAgIHJ2YWwgPSBhc24xLnZhbGlkYXRlKG9iai52YWx1ZVtqXSwgdi52YWx1ZVtpXSwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHYudmFsdWVbaV0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgcnZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCFydmFsICYmIGVycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAgICAgICAnVGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIHR5cGUgXCInICtcbiAgICAgICAgICAgICAgdi50eXBlICsgJ1wiIGV4cGVjdGVkIHZhbHVlIGxlbmd0aCBcIicgK1xuICAgICAgICAgICAgICB2LnZhbHVlLmxlbmd0aCArICdcIiwgZ290IFwiJyArXG4gICAgICAgICAgICAgIG9iai52YWx1ZS5sZW5ndGggKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocnZhbCAmJiBjYXB0dXJlKSB7XG4gICAgICAgIGlmKHYuY2FwdHVyZSkge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlXSA9IG9iai52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVBc24xKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVBc24xXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50cyAmJiAnYml0U3RyaW5nQ29udGVudHMnIGluIG9iaikge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nQ29udGVudHNdID0gb2JqLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb2JqKSB7XG4gICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgIGlmKG9iai5iaXRTdHJpbmdDb250ZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCB1bnVzZWQgYml0cyB3aXRoIGRhdGEgc2hpZnRpbmdcbiAgICAgICAgICAgIHZhciB1bnVzZWQgPSBvYmouYml0U3RyaW5nQ29udGVudHMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmKHVudXNlZCAhPT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZSBvbmx5IHN1cHBvcnRlZCBmb3IgemVybyB1bnVzZWQgYml0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdWYWx1ZV0gPSBvYmouYml0U3RyaW5nQ29udGVudHMuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgY29uc3RydWN0ZWQgXCInICsgdi5jb25zdHJ1Y3RlZCArICdcIiwgZ290IFwiJyArXG4gICAgICAgIG9iai5jb25zdHJ1Y3RlZCArICdcIicpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgIGlmKG9iai50YWdDbGFzcyAhPT0gdi50YWdDbGFzcykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIGdvdCBcIicgK1xuICAgICAgICBvYmoudGFnQ2xhc3MgKyAnXCInKTtcbiAgICB9XG4gICAgaWYob2JqLnR5cGUgIT09IHYudHlwZSkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdHlwZSBcIicgKyB2LnR5cGUgKyAnXCIsIGdvdCBcIicgKyBvYmoudHlwZSArICdcIicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8vIHJlZ2V4IGZvciB0ZXN0aW5nIGZvciBub24tbGF0aW4gY2hhcmFjdGVyc1xudmFyIF9ub25MYXRpblJlZ2V4ID0gL1teXFxcXHUwMDAwLVxcXFx1MDBmZl0vO1xuXG4vKipcbiAqIFByZXR0eSBwcmludHMgYW4gQVNOLjEgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIG9iamVjdCB0byB3cml0ZSBvdXQuXG4gKiBAcGFyYW0gbGV2ZWwgdGhlIGxldmVsIGluIHRoZSB0cmVlLlxuICogQHBhcmFtIGluZGVudGF0aW9uIHRoZSBpbmRlbnRhdGlvbiB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nLlxuICovXG5hc24xLnByZXR0eVByaW50ID0gZnVuY3Rpb24ob2JqLCBsZXZlbCwgaW5kZW50YXRpb24pIHtcbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBzZXQgZGVmYXVsdCBsZXZlbCBhbmQgaW5kZW50YXRpb25cbiAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuICBpbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uIHx8IDI7XG5cbiAgLy8gc3RhcnQgbmV3IGxpbmUgZm9yIGRlZXAgbGV2ZWxzXG4gIGlmKGxldmVsID4gMCkge1xuICAgIHJ2YWwgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBjcmVhdGUgaW5kZW50XG4gIHZhciBpbmRlbnQgPSAnJztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxldmVsICogaW5kZW50YXRpb247ICsraSkge1xuICAgIGluZGVudCArPSAnICc7XG4gIH1cblxuICAvLyBwcmludCBjbGFzczp0eXBlXG4gIHJ2YWwgKz0gaW5kZW50ICsgJ1RhZzogJztcbiAgc3dpdGNoKG9iai50YWdDbGFzcykge1xuICBjYXNlIGFzbjEuQ2xhc3MuVU5JVkVSU0FMOlxuICAgIHJ2YWwgKz0gJ1VuaXZlcnNhbDonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuQVBQTElDQVRJT046XG4gICAgcnZhbCArPSAnQXBwbGljYXRpb246JztcbiAgICBicmVhaztcbiAgY2FzZSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUM6XG4gICAgcnZhbCArPSAnQ29udGV4dC1TcGVjaWZpYzonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuUFJJVkFURTpcbiAgICBydmFsICs9ICdQcml2YXRlOic7XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZihvYmoudGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMKSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcblxuICAgIC8vIGtub3duIHR5cGVzXG4gICAgc3dpdGNoKG9iai50eXBlKSB7XG4gICAgY2FzZSBhc24xLlR5cGUuTk9ORTpcbiAgICAgIHJ2YWwgKz0gJyAoTm9uZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk9PTEVBTjpcbiAgICAgIHJ2YWwgKz0gJyAoQm9vbGVhbiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSU5URUdFUjpcbiAgICAgIHJ2YWwgKz0gJyAoSW50ZWdlciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQklUU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCaXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PQ1RFVFNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoT2N0ZXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5OVUxMOlxuICAgICAgcnZhbCArPSAnIChOdWxsKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PSUQ6XG4gICAgICBydmFsICs9ICcgKE9iamVjdCBJZGVudGlmaWVyKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PREVTQzpcbiAgICAgIHJ2YWwgKz0gJyAoT2JqZWN0IERlc2NyaXB0b3IpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkVYVEVSTkFMOlxuICAgICAgcnZhbCArPSAnIChFeHRlcm5hbCBvciBJbnN0YW5jZSBvZiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUkVBTDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVhbCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU5VTUVSQVRFRDpcbiAgICAgIHJ2YWwgKz0gJyAoRW51bWVyYXRlZCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU1CRURERUQ6XG4gICAgICBydmFsICs9ICcgKEVtYmVkZGVkIFBEViknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRGODpcbiAgICAgIHJ2YWwgKz0gJyAoVVRGOCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUk9JRDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVsYXRpdmUgT2JqZWN0IElkZW50aWZpZXIpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlNFUVVFTkNFOlxuICAgICAgcnZhbCArPSAnIChTZXF1ZW5jZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuU0VUOlxuICAgICAgcnZhbCArPSAnIChTZXQpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoUHJpbnRhYmxlIFN0cmluZyknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSUE1U3RyaW5nOlxuICAgICAgcnZhbCArPSAnIChJQTVTdHJpbmcgKEFTQ0lJKSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRDVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoVVRDIHRpbWUpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoR2VuZXJhbGl6ZWQgdGltZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk1QU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCTVAgU3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcbiAgfVxuXG4gIHJ2YWwgKz0gJ1xcbic7XG4gIHJ2YWwgKz0gaW5kZW50ICsgJ0NvbnN0cnVjdGVkOiAnICsgb2JqLmNvbnN0cnVjdGVkICsgJ1xcbic7XG5cbiAgaWYob2JqLmNvbXBvc2VkKSB7XG4gICAgdmFyIHN1YnZhbHVlcyA9IDA7XG4gICAgdmFyIHN1YiA9ICcnO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKG9iai52YWx1ZVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YnZhbHVlcyArPSAxO1xuICAgICAgICBzdWIgKz0gYXNuMS5wcmV0dHlQcmludChvYmoudmFsdWVbaV0sIGxldmVsICsgMSwgaW5kZW50YXRpb24pO1xuICAgICAgICBpZigoaSArIDEpIDwgb2JqLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHN1YiArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcnZhbCArPSBpbmRlbnQgKyAnU3ViIHZhbHVlczogJyArIHN1YnZhbHVlcyArIHN1YjtcbiAgfSBlbHNlIHtcbiAgICBydmFsICs9IGluZGVudCArICdWYWx1ZTogJztcbiAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLk9JRCkge1xuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQob2JqLnZhbHVlKTtcbiAgICAgIHJ2YWwgKz0gb2lkO1xuICAgICAgaWYoZm9yZ2UucGtpICYmIGZvcmdlLnBraS5vaWRzKSB7XG4gICAgICAgIGlmKG9pZCBpbiBmb3JnZS5wa2kub2lkcykge1xuICAgICAgICAgIHJ2YWwgKz0gJyAoJyArIGZvcmdlLnBraS5vaWRzW29pZF0gKyAnKSAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuSU5URUdFUikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnZhbCArPSBhc24xLmRlclRvSW50ZWdlcihvYmoudmFsdWUpO1xuICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICAgIC8vIFRPRE86IHNoaWZ0IGJpdHMgYXMgbmVlZGVkIHRvIGRpc3BsYXkgd2l0aG91dCBwYWRkaW5nXG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyByZW1vdmUgdW51c2VkIGJpdHMgZmllbGRcbiAgICAgICAgcnZhbCArPSAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZS5zbGljZSgxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsICs9ICcobm9uZSknO1xuICAgICAgfVxuICAgICAgLy8gc2hvdyB1bnVzZWQgYml0IGNvdW50XG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdW51c2VkID0gb2JqLnZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmKHVudXNlZCA9PSAxKSB7XG4gICAgICAgICAgcnZhbCArPSAnICgxIHVudXNlZCBiaXQgc2hvd24pJztcbiAgICAgICAgfSBlbHNlIGlmKHVudXNlZCA+IDEpIHtcbiAgICAgICAgICBydmFsICs9ICcgKCcgKyB1bnVzZWQgKyAnIHVudXNlZCBiaXRzIHNob3duKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgaWYoIV9ub25MYXRpblJlZ2V4LnRlc3Qob2JqLnZhbHVlKSkge1xuICAgICAgICBydmFsICs9ICcoJyArIG9iai52YWx1ZSArICcpICc7XG4gICAgICB9XG4gICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICBydmFsICs9IGZvcmdlLnV0aWwuZGVjb2RlVXRmOChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORyB8fFxuICAgICAgb2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JQTVTdHJpbmcpIHtcbiAgICAgIHJ2YWwgKz0gb2JqLnZhbHVlO1xuICAgIH0gZWxzZSBpZihfbm9uTGF0aW5SZWdleC50ZXN0KG9iai52YWx1ZSkpIHtcbiAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBydmFsICs9ICdbbnVsbF0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsICs9IG9iai52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogT2JqZWN0IElEcyBmb3IgQVNOLjEuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG52YXIgb2lkcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLm9pZHMgPSBmb3JnZS5vaWRzID0gZm9yZ2Uub2lkcyB8fCB7fTtcblxuLy8gc2V0IGlkIHRvIG5hbWUgbWFwcGluZyBhbmQgbmFtZSB0byBpZCBtYXBwaW5nXG5mdW5jdGlvbiBfSU4oaWQsIG5hbWUpIHtcbiAgb2lkc1tpZF0gPSBuYW1lO1xuICBvaWRzW25hbWVdID0gaWQ7XG59XG4vLyBzZXQgaWQgdG8gbmFtZSBtYXBwaW5nIG9ubHlcbmZ1bmN0aW9uIF9JXyhpZCwgbmFtZSkge1xuICBvaWRzW2lkXSA9IG5hbWU7XG59XG5cbi8vIGFsZ29yaXRobSBPSURzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xJywgJ3JzYUVuY3J5cHRpb24nKTtcbi8vIE5vdGU6IG1kMiAmIG1kNCBub3QgaW1wbGVtZW50ZWRcbi8vX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMicsICdtZDJXaXRoUlNBRW5jcnlwdGlvbicpO1xuLy9fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4zJywgJ21kNFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS40JywgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS41JywgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuNycsICdSU0FFUy1PQUVQJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS44JywgJ21nZjEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjknLCAncFNwZWNpZmllZCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTAnLCAnUlNBU1NBLVBTUycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTEnLCAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEyJywgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMycsICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbicpO1xuXG5fSU4oJzEuMi44NDAuMTAwNDAuNC4zJywgJ2RzYS13aXRoLXNoYTEnKTtcblxuX0lOKCcxLjMuMTQuMy4yLjcnLCAnZGVzQ0JDJyk7XG5cbl9JTignMS4zLjE0LjMuMi4yNicsICdzaGExJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjEnLCAnc2hhMjU2Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjInLCAnc2hhMzg0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjMnLCAnc2hhNTEyJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuNScsICdtZDUnKTtcblxuLy8gcGtjcyM3IGNvbnRlbnQgdHlwZXNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjEnLCAnZGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuMicsICdzaWduZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy4zJywgJ2VudmVsb3BlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjQnLCAnc2lnbmVkQW5kRW52ZWxvcGVkRGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuNScsICdkaWdlc3RlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjYnLCAnZW5jcnlwdGVkRGF0YScpO1xuXG4vLyBwa2NzIzkgb2lkc1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMScsICdlbWFpbEFkZHJlc3MnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjInLCAndW5zdHJ1Y3R1cmVkTmFtZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMycsICdjb250ZW50VHlwZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNCcsICdtZXNzYWdlRGlnZXN0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS41JywgJ3NpZ25pbmdUaW1lJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS42JywgJ2NvdW50ZXJTaWduYXR1cmUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjcnLCAnY2hhbGxlbmdlUGFzc3dvcmQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjgnLCAndW5zdHJ1Y3R1cmVkQWRkcmVzcycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMTQnLCAnZXh0ZW5zaW9uUmVxdWVzdCcpO1xuXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMCcsICdmcmllbmRseU5hbWUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIxJywgJ2xvY2FsS2V5SWQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIyLjEnLCAneDUwOUNlcnRpZmljYXRlJyk7XG5cbi8vIHBrY3MjMTIgc2FmZSBiYWdzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4xJywgJ2tleUJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMicsICdwa2NzOFNocm91ZGVkS2V5QmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4zJywgJ2NlcnRCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjQnLCAnY3JsQmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS41JywgJ3NlY3JldEJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuNicsICdzYWZlQ29udGVudHNCYWcnKTtcblxuLy8gcGFzc3dvcmQtYmFzZWQtZW5jcnlwdGlvbiBmb3IgcGtjcyMxMlxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTMnLCAncGtjczVQQkVTMicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTInLCAncGtjczVQQktERjInKTtcblxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMScsICdwYmVXaXRoU0hBQW5kMTI4Qml0UkM0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS4yJywgJ3BiZVdpdGhTSEFBbmQ0MEJpdFJDNCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMycsICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS40JywgJ3BiZVdpdGhTSEFBbmQyLUtleVRyaXBsZURFUy1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjUnLCAncGJlV2l0aFNIQUFuZDEyOEJpdFJDMi1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjYnLCAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQycpO1xuXG4vLyBobWFjIE9JRHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMi43JywgJ2htYWNXaXRoU0hBMScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjgnLCAnaG1hY1dpdGhTSEEyMjQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi45JywgJ2htYWNXaXRoU0hBMjU2Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuMTAnLCAnaG1hY1dpdGhTSEEzODQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi4xMScsICdobWFjV2l0aFNIQTUxMicpO1xuXG4vLyBzeW1tZXRyaWMga2V5IGFsZ29yaXRobSBvaWRzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjMuNycsICdkZXMtRURFMy1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuMicsICdhZXMxMjgtQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjIyJywgJ2FlczE5Mi1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuNDInLCAnYWVzMjU2LUNCQycpO1xuXG4vLyBjZXJ0aWZpY2F0ZSBpc3N1ZXIvc3ViamVjdCBPSURzXG5fSU4oJzIuNS40LjMnLCAnY29tbW9uTmFtZScpO1xuX0lOKCcyLjUuNC41JywgJ3NlcmlhbE5hbWUnKTtcbl9JTignMi41LjQuNicsICdjb3VudHJ5TmFtZScpO1xuX0lOKCcyLjUuNC43JywgJ2xvY2FsaXR5TmFtZScpO1xuX0lOKCcyLjUuNC44JywgJ3N0YXRlT3JQcm92aW5jZU5hbWUnKTtcbl9JTignMi41LjQuMTAnLCAnb3JnYW5pemF0aW9uTmFtZScpO1xuX0lOKCcyLjUuNC4xMScsICdvcmdhbml6YXRpb25hbFVuaXROYW1lJyk7XG5fSU4oJzIuNS40LjEzJywgJ2Rlc2NyaXB0aW9uJyk7XG5cbi8vIFguNTA5IGV4dGVuc2lvbiBPSURzXG5fSU4oJzIuMTYuODQwLjEuMTEzNzMwLjEuMScsICduc0NlcnRUeXBlJyk7XG5fSV8oJzIuNS4yOS4xJywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zNVxuX0lfKCcyLjUuMjkuMicsICdrZXlBdHRyaWJ1dGVzJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS4zJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zMlxuX0lfKCcyLjUuMjkuNCcsICdrZXlVc2FnZVJlc3RyaWN0aW9uJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS41JywgJ3BvbGljeU1hcHBpbmcnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMzXG5fSV8oJzIuNS4yOS42JywgJ3N1YnRyZWVzQ29uc3RyYWludCcpOyAvLyBvYnNvbGV0ZSB1c2UgLjMwXG5fSV8oJzIuNS4yOS43JywgJ3N1YmplY3RBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xN1xuX0lfKCcyLjUuMjkuOCcsICdpc3N1ZXJBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xOFxuX0lfKCcyLjUuMjkuOScsICdzdWJqZWN0RGlyZWN0b3J5QXR0cmlidXRlcycpO1xuX0lfKCcyLjUuMjkuMTAnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JXygnMi41LjI5LjExJywgJ25hbWVDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzBcbl9JXygnMi41LjI5LjEyJywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zNlxuX0lfKCcyLjUuMjkuMTMnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JTignMi41LjI5LjE0JywgJ3N1YmplY3RLZXlJZGVudGlmaWVyJyk7XG5fSU4oJzIuNS4yOS4xNScsICdrZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuMTYnLCAncHJpdmF0ZUtleVVzYWdlUGVyaW9kJyk7XG5fSU4oJzIuNS4yOS4xNycsICdzdWJqZWN0QWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTgnLCAnaXNzdWVyQWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTknLCAnYmFzaWNDb25zdHJhaW50cycpO1xuX0lfKCcyLjUuMjkuMjAnLCAnY1JMTnVtYmVyJyk7XG5fSV8oJzIuNS4yOS4yMScsICdjUkxSZWFzb24nKTtcbl9JXygnMi41LjI5LjIyJywgJ2V4cGlyYXRpb25EYXRlJyk7XG5fSV8oJzIuNS4yOS4yMycsICdpbnN0cnVjdGlvbkNvZGUnKTtcbl9JXygnMi41LjI5LjI0JywgJ2ludmFsaWRpdHlEYXRlJyk7XG5fSV8oJzIuNS4yOS4yNScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMxXG5fSV8oJzIuNS4yOS4yNicsICdpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnQnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjI4XG5fSV8oJzIuNS4yOS4yNycsICdkZWx0YUNSTEluZGljYXRvcicpO1xuX0lfKCcyLjUuMjkuMjgnLCAnaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50Jyk7XG5fSV8oJzIuNS4yOS4yOScsICdjZXJ0aWZpY2F0ZUlzc3VlcicpO1xuX0lfKCcyLjUuMjkuMzAnLCAnbmFtZUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zMScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTtcbl9JTignMi41LjI5LjMyJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTtcbl9JXygnMi41LjI5LjMzJywgJ3BvbGljeU1hcHBpbmdzJyk7XG5fSV8oJzIuNS4yOS4zNCcsICdwb2xpY3lDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzZcbl9JTignMi41LjI5LjM1JywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTtcbl9JXygnMi41LjI5LjM2JywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zNycsICdleHRLZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuNDYnLCAnZnJlc2hlc3RDUkwnKTtcbl9JXygnMi41LjI5LjU0JywgJ2luaGliaXRBbnlQb2xpY3knKTtcblxuLy8gZXh0S2V5VXNhZ2UgcHVycG9zZXNcbl9JTignMS4zLjYuMS40LjEuMTExMjkuMi40LjInLCAndGltZXN0YW1wTGlzdCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjEuMScsICdhdXRob3JpdHlJbmZvQWNjZXNzJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy4xJywgJ3NlcnZlckF1dGgnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjInLCAnY2xpZW50QXV0aCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuMycsICdjb2RlU2lnbmluZycpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuNCcsICdlbWFpbFByb3RlY3Rpb24nKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjgnLCAndGltZVN0YW1waW5nJyk7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlIG1lc3NhZ2UgZGlnZXN0cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAyMDExLTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZCA9IGZvcmdlLm1kIHx8IHt9O1xuZm9yZ2UubWQuYWxnb3JpdGhtcyA9IGZvcmdlLm1kLmFsZ29yaXRobXMgfHwge307XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQW4gQVBJIGZvciBnZXR0aW5nIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gYnl0ZXMuIFRoZSBieXRlcyBhcmVcbiAqIGdlbmVyYXRlZCB1c2luZyB0aGUgRm9ydHVuYSBhbGdvcml0aG0gZGV2aXNlZCBieSBCcnVjZSBTY2huZWllciBhbmRcbiAqIE5pZWxzIEZlcmd1c29uLlxuICpcbiAqIEdldHRpbmcgc3Ryb25nIHJhbmRvbSBieXRlcyBpcyBub3QgeWV0IGVhc3kgdG8gZG8gaW4gamF2YXNjcmlwdC4gVGhlIG9ubHlcbiAqIHRydWlzaCByYW5kb20gZW50cm9weSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgaXMgZnJvbSB0aGUgbW91c2UsIGtleWJvYXJkLCBvclxuICogZnJvbSB0aW1pbmcgd2l0aCByZXNwZWN0IHRvIHBhZ2UgbG9hZHMsIGV0Yy4gVGhpcyBnZW5lcmF0b3IgbWFrZXMgYSBwb29yXG4gKiBhdHRlbXB0IGF0IHByb3ZpZGluZyByYW5kb20gYnl0ZXMgd2hlbiB0aG9zZSBzb3VyY2VzIGhhdmVuJ3QgeWV0IHByb3ZpZGVkXG4gKiBlbm91Z2ggZW50cm9weSB0byBpbml0aWFsbHkgc2VlZCBvciB0byByZXNlZWQgdGhlIFBSTkcuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnJhbmRvbSBhbHJlYWR5IGRlZmluZWRcbmlmKGZvcmdlLnJhbmRvbSAmJiBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG4gIHJldHVybjtcbn1cblxuKGZ1bmN0aW9uKGpRdWVyeSkge1xuXG4vLyB0aGUgZGVmYXVsdCBwcm5nIHBsdWdpbiwgdXNlcyBBRVMtMTI4XG52YXIgcHJuZ19hZXMgPSB7fTtcbnZhciBfcHJuZ19hZXNfb3V0cHV0ID0gbmV3IEFycmF5KDQpO1xudmFyIF9wcm5nX2Flc19idWZmZXIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xucHJuZ19hZXMuZm9ybWF0S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIGNvbnZlcnQgdGhlIGtleSBpbnRvIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgdG1wID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoa2V5KTtcbiAga2V5ID0gbmV3IEFycmF5KDQpO1xuICBrZXlbMF0gPSB0bXAuZ2V0SW50MzIoKTtcbiAga2V5WzFdID0gdG1wLmdldEludDMyKCk7XG4gIGtleVsyXSA9IHRtcC5nZXRJbnQzMigpO1xuICBrZXlbM10gPSB0bXAuZ2V0SW50MzIoKTtcblxuICAvLyByZXR1cm4gdGhlIGV4cGFuZGVkIGtleVxuICByZXR1cm4gZm9yZ2UuYWVzLl9leHBhbmRLZXkoa2V5LCBmYWxzZSk7XG59O1xucHJuZ19hZXMuZm9ybWF0U2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgLy8gY29udmVydCBzZWVkIGludG8gMzItYml0IGludGVnZXJzXG4gIHZhciB0bXAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzZWVkKTtcbiAgc2VlZCA9IG5ldyBBcnJheSg0KTtcbiAgc2VlZFswXSA9IHRtcC5nZXRJbnQzMigpO1xuICBzZWVkWzFdID0gdG1wLmdldEludDMyKCk7XG4gIHNlZWRbMl0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgc2VlZFszXSA9IHRtcC5nZXRJbnQzMigpO1xuICByZXR1cm4gc2VlZDtcbn07XG5wcm5nX2Flcy5jaXBoZXIgPSBmdW5jdGlvbihrZXksIHNlZWQpIHtcbiAgZm9yZ2UuYWVzLl91cGRhdGVCbG9jayhrZXksIHNlZWQsIF9wcm5nX2Flc19vdXRwdXQsIGZhbHNlKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzBdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzFdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzJdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzNdKTtcbiAgcmV0dXJuIF9wcm5nX2Flc19idWZmZXIuZ2V0Qnl0ZXMoKTtcbn07XG5wcm5nX2Flcy5pbmNyZW1lbnQgPSBmdW5jdGlvbihzZWVkKSB7XG4gIC8vIEZJWE1FOiBkbyB3ZSBjYXJlIGFib3V0IGNhcnJ5IG9yIHNpZ25lZCBpc3N1ZXM/XG4gICsrc2VlZFszXTtcbiAgcmV0dXJuIHNlZWQ7XG59O1xucHJuZ19hZXMubWQgPSBmb3JnZS5tZC5zaGEyNTY7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HLlxuICovXG5mdW5jdGlvbiBzcGF3blBybmcoKSB7XG4gIHZhciBjdHggPSBmb3JnZS5wcm5nLmNyZWF0ZShwcm5nX2Flcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgcmFuZG9tIGJ5dGVzLiBJZiBhIG5hdGl2ZSBzZWN1cmUgY3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZSwgdGhpc1xuICAgKiBtZXRob2QgdHJpZXMgdG8gbWFrZSB0aGUgYnl0ZXMgbW9yZSB1bnByZWRpY3RhYmxlIGJ5IGRyYXdpbmcgZnJvbSBkYXRhIHRoYXRcbiAgICogY2FuIGJlIGNvbGxlY3RlZCBmcm9tIHRoZSB1c2VyIG9mIHRoZSBicm93c2VyLCBlZzogbW91c2UgbW92ZW1lbnQuXG4gICAqXG4gICAqIElmIGEgY2FsbGJhY2sgaXMgZ2l2ZW4sIHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwgYnl0ZXMpXSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgcmFuZG9tIGJ5dGVzIGluIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGN0eC5nZW5lcmF0ZShjb3VudCwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHJhbmRvbSBieXRlcyBhc3luY2hyb25vdXNseS4gSWYgYSBuYXRpdmUgc2VjdXJlIGNyeXB0byBBUEkgaXNcbiAgICogdW5hdmFpbGFibGUsIHRoaXMgbWV0aG9kIHRyaWVzIHRvIG1ha2UgdGhlIGJ5dGVzIG1vcmUgdW5wcmVkaWN0YWJsZSBieVxuICAgKiBkcmF3aW5nIGZyb20gZGF0YSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgZnJvbSB0aGUgdXNlciBvZiB0aGUgYnJvd3NlcixcbiAgICogZWc6IG1vdXNlIG1vdmVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMgaW4gYSBzdHJpbmcuXG4gICAqL1xuICBjdHguZ2V0Qnl0ZXNTeW5jID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICByZXR1cm4gY3R4LmdlbmVyYXRlKGNvdW50KTtcbiAgfTtcblxuICByZXR1cm4gY3R4O1xufVxuXG4vLyBjcmVhdGUgZGVmYXVsdCBwcm5nIGNvbnRleHRcbnZhciBfY3R4ID0gc3Bhd25Qcm5nKCk7XG5cbi8vIGFkZCBvdGhlciBzb3VyY2VzIG9mIGVudHJvcHkgb25seSBpZiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpcyBub3Rcbi8vIGF2YWlsYWJsZSAtLSBvdGhlcndpc2UgdGhpcyBzb3VyY2Ugd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVzZWQgYnkgdGhlIHBybmdcbnZhciBnZXRSYW5kb21WYWx1ZXMgPSBudWxsO1xuaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIF9jcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcbiAgaWYoX2NyeXB0byAmJiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIGdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgfTtcbiAgfVxufVxuaWYoZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCB8fFxuICAoIWZvcmdlLnV0aWwuaXNOb2RlanMgJiYgIWdldFJhbmRvbVZhbHVlcykpIHtcbiAgLy8gaWYgdGhpcyBpcyBhIHdlYiB3b3JrZXIsIGRvIG5vdCB1c2Ugd2VhayBlbnRyb3B5LCBpbnN0ZWFkIHJlZ2lzdGVyIHRvXG4gIC8vIHJlY2VpdmUgc3Ryb25nIGVudHJvcHkgYXN5bmNocm9ub3VzbHkgZnJvbSB0aGUgbWFpbiB0aHJlYWRcbiAgaWYodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgd2luZG93LmRvY3VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBGSVhNRTpcbiAgfVxuXG4gIC8vIGdldCBsb2FkIHRpbWUgZW50cm9weVxuICBfY3R4LmNvbGxlY3RJbnQoK25ldyBEYXRlKCksIDMyKTtcblxuICAvLyBhZGQgc29tZSBlbnRyb3B5IGZyb20gbmF2aWdhdG9yIG9iamVjdFxuICBpZih0eXBlb2YobmF2aWdhdG9yKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgX25hdkJ5dGVzID0gJyc7XG4gICAgZm9yKHZhciBrZXkgaW4gbmF2aWdhdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZih0eXBlb2YobmF2aWdhdG9yW2tleV0pID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgX25hdkJ5dGVzICs9IG5hdmlnYXRvcltrZXldO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLyogU29tZSBuYXZpZ2F0b3Iga2V5cyBtaWdodCBub3QgYmUgYWNjZXNzaWJsZSwgZS5nLiB0aGUgZ2VvbG9jYXRpb25cbiAgICAgICAgICBhdHRyaWJ1dGUgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0b3VjaGVkIGluIE1vemlsbGEgY2hyb21lOi8vXG4gICAgICAgICAgY29udGV4dC5cblxuICAgICAgICAgIFNpbGVudGx5IGlnbm9yZSB0aGlzIGFuZCBqdXN0IGRvbid0IHVzZSB0aGlzIGFzIGEgc291cmNlIG9mXG4gICAgICAgICAgZW50cm9weS4gKi9cbiAgICAgIH1cbiAgICB9XG4gICAgX2N0eC5jb2xsZWN0KF9uYXZCeXRlcyk7XG4gICAgX25hdkJ5dGVzID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFkZCBtb3VzZSBhbmQga2V5Ym9hcmQgY29sbGVjdG9ycyBpZiBqcXVlcnkgaXMgYXZhaWxhYmxlXG4gIGlmKGpRdWVyeSkge1xuICAgIC8vIHNldCB1cCBtb3VzZSBlbnRyb3B5IGNhcHR1cmVcbiAgICBqUXVlcnkoKS5tb3VzZW1vdmUoZnVuY3Rpb24oZSkge1xuICAgICAgLy8gYWRkIG1vdXNlIGNvb3Jkc1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WCwgMTYpO1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WSwgMTYpO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IHVwIGtleWJvYXJkIGVudHJvcHkgY2FwdHVyZVxuICAgIGpRdWVyeSgpLmtleXByZXNzKGZ1bmN0aW9uKGUpIHtcbiAgICAgIF9jdHguY29sbGVjdEludChlLmNoYXJDb2RlLCA4KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiBSYW5kb20gQVBJICovXG5pZighZm9yZ2UucmFuZG9tKSB7XG4gIGZvcmdlLnJhbmRvbSA9IF9jdHg7XG59IGVsc2Uge1xuICAvLyBleHRlbmQgZm9yZ2UucmFuZG9tIHdpdGggX2N0eFxuICBmb3IodmFyIGtleSBpbiBfY3R4KSB7XG4gICAgZm9yZ2UucmFuZG9tW2tleV0gPSBfY3R4W2tleV07XG4gIH1cbn1cblxuLy8gZXhwb3NlIHNwYXduIFBSTkdcbmZvcmdlLnJhbmRvbS5jcmVhdGVJbnN0YW5jZSA9IHNwYXduUHJuZztcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG5cbn0pKHR5cGVvZihqUXVlcnkpICE9PSAndW5kZWZpbmVkJyA/IGpRdWVyeSA6IG51bGwpO1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgUlNBIGFsZ29yaXRobXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBvbmx5IGFsZ29yaXRobSBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBQS0kgaXMgUlNBLlxuICpcbiAqIEFuIFJTQSBrZXkgaXMgb2Z0ZW4gc3RvcmVkIGluIEFTTi4xIERFUiBmb3JtYXQuIFRoZSBTdWJqZWN0UHVibGljS2V5SW5mb1xuICogQVNOLjEgc3RydWN0dXJlIGlzIGNvbXBvc2VkIG9mIGFuIGFsZ29yaXRobSBvZiB0eXBlIEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIGFuZCBhIHN1YmplY3RQdWJsaWNLZXkgb2YgdHlwZSBiaXQgc3RyaW5nLlxuICpcbiAqIFRoZSBBbGdvcml0aG1JZGVudGlmaWVyIGNvbnRhaW5zIGFuIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIGFuZCBwYXJhbWV0ZXJzXG4gKiBmb3IgdGhlIGFsZ29yaXRobSwgaWYgYW55LiBJbiB0aGUgY2FzZSBvZiBSU0EsIHRoZXJlIGFyZW4ndCBhbnkuXG4gKlxuICogU3ViamVjdFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgYWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgQklUIFNUUklOR1xuICogfVxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRm9yIGFuIFJTQSBwdWJsaWMga2V5LCB0aGUgc3ViamVjdFB1YmxpY0tleSBpczpcbiAqXG4gKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAqICAgbW9kdWx1cyAgICAgICAgICAgIElOVEVHRVIsICAgIC0tIG5cbiAqICAgcHVibGljRXhwb25lbnQgICAgIElOVEVHRVIgICAgIC0tIGVcbiAqIH1cbiAqXG4gKiBQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIHByaXZhdGVLZXlBbGdvcml0aG0gICAgICAgUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHByaXZhdGVLZXkgICAgICAgICAgICAgICAgUHJpdmF0ZUtleSxcbiAqICAgYXR0cmlidXRlcyAgICAgICAgICAgWzBdICBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICogUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIFByaXZhdGVLZXkgOjo9IE9DVEVUIFNUUklOR1xuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEFuIFJTQSBwcml2YXRlIGtleSBhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiBSU0FQcml2YXRlS2V5IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gVmVyc2lvbixcbiAqICAgbW9kdWx1cyBJTlRFR0VSLCAtLSBuXG4gKiAgIHB1YmxpY0V4cG9uZW50IElOVEVHRVIsIC0tIGVcbiAqICAgcHJpdmF0ZUV4cG9uZW50IElOVEVHRVIsIC0tIGRcbiAqICAgcHJpbWUxIElOVEVHRVIsIC0tIHBcbiAqICAgcHJpbWUyIElOVEVHRVIsIC0tIHFcbiAqICAgZXhwb25lbnQxIElOVEVHRVIsIC0tIGQgbW9kIChwLTEpXG4gKiAgIGV4cG9uZW50MiBJTlRFR0VSLCAtLSBkIG1vZCAocS0xKVxuICogICBjb2VmZmljaWVudCBJTlRFR0VSIC0tIChpbnZlcnNlIG9mIHEpIG1vZCBwXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICpcbiAqIFRoZSBPSUQgZm9yIHRoZSBSU0Ega2V5IGFsZ29yaXRobSBpczogMS4yLjg0MC4xMTM1NDkuMS4xLjFcbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmlmKHR5cGVvZiBCaWdJbnRlZ2VyID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcjtcbn1cblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKlxuICogUlNBIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24sIHNlZSBSRkMgMjMxMy5cbiAqL1xuZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2kucnNhID0gZm9yZ2UucnNhID0gZm9yZ2UucnNhIHx8IHt9O1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gZm9yIGZpbmRpbmcgcHJpbWVzLCB3aGljaCBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgUHJpdmF0ZUtleUluZm8gc3RydWN0dXJlXG52YXIgcHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdQcml2YXRlS2V5SW5mby52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5VmVyc2lvbidcbiAgfSwge1xuICAgIC8vIHByaXZhdGVLZXlBbGdvcml0aG1cbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlPaWQnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIFByaXZhdGVLZXlcbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5J1xuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBSU0EgcHJpdmF0ZSBrZXlcbnZhciByc2FQcml2YXRlS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQcml2YXRlS2V5XG4gIG5hbWU6ICdSU0FQcml2YXRlS2V5JyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlWZXJzaW9uJ1xuICB9LCB7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5tb2R1bHVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5TW9kdWx1cydcbiAgfSwge1xuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnB1YmxpY0V4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHVibGljRXhwb25lbnQnXG4gIH0sIHtcbiAgICAvLyBwcml2YXRlRXhwb25lbnQgKGQpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHJpdmF0ZUV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHJpdmF0ZUV4cG9uZW50J1xuICB9LCB7XG4gICAgLy8gcHJpbWUxIChwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnByaW1lMScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVByaW1lMSdcbiAgfSwge1xuICAgIC8vIHByaW1lMiAocSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wcmltZTInLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQcmltZTInXG4gIH0sIHtcbiAgICAvLyBleHBvbmVudDEgKGQgbW9kIChwLTEpKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmV4cG9uZW50MScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUV4cG9uZW50MSdcbiAgfSwge1xuICAgIC8vIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkuZXhwb25lbnQyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5RXhwb25lbnQyJ1xuICB9LCB7XG4gICAgLy8gY29lZmZpY2llbnQgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmNvZWZmaWNpZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5Q29lZmZpY2llbnQnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcnNhUHVibGljS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgbmFtZTogJ1JTQVB1YmxpY0tleScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5Lm1vZHVsdXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3B1YmxpY0tleU1vZHVsdXMnXG4gIH0sIHtcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5LmV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwdWJsaWNLZXlFeHBvbmVudCdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gU3ViamVjdFB1YmxpY0tleUluZm8gc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcHVibGljS2V5VmFsaWRhdG9yID0gZm9yZ2UucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdzdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAncHVibGljS2V5T2lkJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXknLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIFJTQVB1YmxpY0tleVxuICAgICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXkuUlNBUHVibGljS2V5JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ3JzYVB1YmxpY0tleSdcbiAgICB9XVxuICB9XVxufTtcblxuLyoqXG4gKiBXcmFwIGRpZ2VzdCBpbiBEaWdlc3RJbmZvIG9iamVjdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgRU1TQS1QS0NTMS12MV81LUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcuXG4gKlxuICogRGlnZXN0SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBkaWdlc3RBbGdvcml0aG0gRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZGlnZXN0IERpZ2VzdFxuICogfVxuICpcbiAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSAocmVhZHkgZm9yIFJTQSBlbmNyeXRpb24pXG4gKi9cbnZhciBlbXNhUGtjczF2MTVlbmNvZGUgPSBmdW5jdGlvbihtZCkge1xuICAvLyBnZXQgdGhlIG9pZCBmb3IgdGhlIGFsZ29yaXRobVxuICB2YXIgb2lkO1xuICBpZihtZC5hbGdvcml0aG0gaW4gcGtpLm9pZHMpIHtcbiAgICBvaWQgPSBwa2kub2lkc1ttZC5hbGdvcml0aG1dO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gbWQuYWxnb3JpdGhtO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHZhciBvaWRCeXRlcyA9IGFzbjEub2lkVG9EZXIob2lkKS5nZXRCeXRlcygpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgZGlnZXN0IGluZm9cbiAgdmFyIGRpZ2VzdEluZm8gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHZhciBkaWdlc3RBbGdvcml0aG0gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIGRpZ2VzdEFsZ29yaXRobS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSwgb2lkQnl0ZXMpKTtcbiAgZGlnZXN0QWxnb3JpdGhtLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpKTtcbiAgdmFyIGRpZ2VzdCA9IGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgZmFsc2UsIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICBkaWdlc3RJbmZvLnZhbHVlLnB1c2goZGlnZXN0QWxnb3JpdGhtKTtcbiAgZGlnZXN0SW5mby52YWx1ZS5wdXNoKGRpZ2VzdCk7XG5cbiAgLy8gZW5jb2RlIGRpZ2VzdCBpbmZvXG4gIHJldHVybiBhc24xLnRvRGVyKGRpZ2VzdEluZm8pLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHheYyBtb2QgbiAoUlNBIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBvcGVyYXRpb24pLlxuICpcbiAqIEBwYXJhbSB4IHRoZSBudW1iZXIgdG8gcmFpc2UgYW5kIG1vZC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBwdWJsaWMsIGZhbHNlIGlmIHByaXZhdGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0IG9mIHheYyBtb2Qgbi5cbiAqL1xudmFyIF9tb2RQb3cgPSBmdW5jdGlvbih4LCBrZXksIHB1Yikge1xuICBpZihwdWIpIHtcbiAgICByZXR1cm4geC5tb2RQb3coa2V5LmUsIGtleS5uKTtcbiAgfVxuXG4gIGlmKCFrZXkucCB8fCAha2V5LnEpIHtcbiAgICAvLyBhbGxvdyBjYWxjdWxhdGlvbiB3aXRob3V0IENSVCBwYXJhbXMgKHNsb3cpXG4gICAgcmV0dXJuIHgubW9kUG93KGtleS5kLCBrZXkubik7XG4gIH1cblxuICAvLyBwcmUtY29tcHV0ZSBkUCwgZFEsIGFuZCBxSW52IGlmIG5lY2Vzc2FyeVxuICBpZigha2V5LmRQKSB7XG4gICAga2V5LmRQID0ga2V5LmQubW9kKGtleS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKSk7XG4gIH1cbiAgaWYoIWtleS5kUSkge1xuICAgIGtleS5kUSA9IGtleS5kLm1vZChrZXkucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpO1xuICB9XG4gIGlmKCFrZXkucUludikge1xuICAgIGtleS5xSW52ID0ga2V5LnEubW9kSW52ZXJzZShrZXkucCk7XG4gIH1cblxuICAvKiBDaGluZXNlIHJlbWFpbmRlciB0aGVvcmVtIChDUlQpIHN0YXRlczpcblxuICAgIFN1cHBvc2UgbjEsIG4yLCAuLi4sIG5rIGFyZSBwb3NpdGl2ZSBpbnRlZ2VycyB3aGljaCBhcmUgcGFpcndpc2VcbiAgICBjb3ByaW1lIChuMSBhbmQgbjIgaGF2ZSBubyBjb21tb24gZmFjdG9ycyBvdGhlciB0aGFuIDEpLiBGb3IgYW55XG4gICAgaW50ZWdlcnMgeDEsIHgyLCAuLi4sIHhrIHRoZXJlIGV4aXN0cyBhbiBpbnRlZ2VyIHggc29sdmluZyB0aGVcbiAgICBzeXN0ZW0gb2Ygc2ltdWx0YW5lb3VzIGNvbmdydWVuY2VzICh3aGVyZSB+PSBtZWFucyBtb2R1bGFybHlcbiAgICBjb25ncnVlbnQgc28gYSB+PSBiIG1vZCBuIG1lYW5zIGEgbW9kIG4gPSBiIG1vZCBuKTpcblxuICAgIHggfj0geDEgbW9kIG4xXG4gICAgeCB+PSB4MiBtb2QgbjJcbiAgICAuLi5cbiAgICB4IH49IHhrIG1vZCBua1xuXG4gICAgVGhpcyBzeXN0ZW0gb2YgY29uZ3J1ZW5jZXMgaGFzIGEgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4XG4gICAgYmV0d2VlbiAwIGFuZCBuIC0gMS4gRnVydGhlcm1vcmUsIGVhY2ggeGsgc29sdXRpb24gYW5kIHggaXRzZWxmXG4gICAgaXMgY29uZ3J1ZW50IG1vZHVsbyB0aGUgcHJvZHVjdCBuID0gbjEqbjIqLi4uKm5rLlxuICAgIFNvIHgxIG1vZCBuID0geDIgbW9kIG4gPSB4ayBtb2QgbiA9IHggbW9kIG4uXG5cbiAgICBUaGUgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4IGNhbiBiZSBzb2x2ZWQgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgZXF1YXRpb246XG5cbiAgICB4ID0gc3VtKHhpKnJpKnNpKSBtb2QgbiB3aGVyZSByaSA9IG4vbmkgYW5kIHNpID0gcmleLTEgbW9kIG5pLlxuXG4gICAgV2hlcmUgeCBpcyBsZXNzIHRoYW4gbiwgeGkgPSB4IG1vZCBuaS5cblxuICAgIEZvciBSU0Egd2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggayA9IDIuIFRoZSBtb2R1bHVzIG4gPSBwcSwgd2hlcmVcbiAgICBwIGFuZCBxIGFyZSBjb3ByaW1lLiBUaGUgUlNBIGRlY3J5cHRpb24gYWxnb3JpdGhtIGlzOlxuXG4gICAgeSA9IHheZCBtb2QgblxuXG4gICAgR2l2ZW4gdGhlIGFib3ZlOlxuXG4gICAgeDEgPSB4XmQgbW9kIHBcbiAgICByMSA9IG4vcCA9IHFcbiAgICBzMSA9IHFeLTEgbW9kIHBcbiAgICB4MiA9IHheZCBtb2QgcVxuICAgIHIyID0gbi9xID0gcFxuICAgIHMyID0gcF4tMSBtb2QgcVxuXG4gICAgU28geSA9ICh4MXIxczEgKyB4MnIyczIpIG1vZCBuXG4gICAgICAgICA9ICgoeF5kIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kIG1vZCBxKXAocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBBY2NvcmRpbmcgdG8gRmVybWF0J3MgTGl0dGxlIFRoZW9yZW0sIGlmIHRoZSBtb2R1bHVzIFAgaXMgcHJpbWUsXG4gICAgZm9yIGFueSBpbnRlZ2VyIEEgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgUCwgQV4oUC0xKSB+PSAxIG1vZCBQLlxuICAgIFNpbmNlIEEgaXMgbm90IGRpdmlzaWJsZSBieSBQIGl0IGZvbGxvd3MgdGhhdCBpZjpcbiAgICBOIH49IE0gbW9kIChQIC0gMSksIHRoZW4gQV5OIG1vZCBQID0gQV5NIG1vZCBQLiBUaGVyZWZvcmU6XG5cbiAgICBBXk4gbW9kIFAgPSBBXihNIG1vZCAoUCAtIDEpKSBtb2QgUC4gKFRoZSBsYXR0ZXIgdGFrZXMgbGVzcyBlZmZvcnRcbiAgICB0byBjYWxjdWxhdGUpLiBJbiBvcmRlciB0byBjYWxjdWxhdGUgeF5kIG1vZCBwIG1vcmUgcXVpY2tseSB0aGVcbiAgICBleHBvbmVudCBkIG1vZCAocCAtIDEpIGlzIHN0b3JlZCBpbiB0aGUgUlNBIHByaXZhdGUga2V5ICh0aGUgc2FtZVxuICAgIGlzIGRvbmUgZm9yIHheZCBtb2QgcSkuIFRoZXNlIHZhbHVlcyBhcmUgcmVmZXJyZWQgdG8gYXMgZFAgYW5kIGRRXG4gICAgcmVzcGVjdGl2ZWx5LiBUaGVyZWZvcmUgd2Ugbm93IGhhdmU6XG5cbiAgICB5ID0gKCh4XmRQIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kUSBtb2QgcSlwKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgU2luY2Ugd2UnbGwgYmUgcmVkdWNpbmcgeF5kUCBieSBtb2R1bG8gcCAoc2FtZSBmb3IgcSkgd2UgY2FuIGFsc29cbiAgICByZWR1Y2UgeCBieSBwIChhbmQgcSByZXNwZWN0aXZlbHkpIGJlZm9yZSBoYW5kLiBUaGVyZWZvcmUsIGxldFxuXG4gICAgeHAgPSAoKHggbW9kIHApXmRQIG1vZCBwKSwgYW5kXG4gICAgeHEgPSAoKHggbW9kIHEpXmRRIG1vZCBxKSwgeWllbGRpbmc6XG5cbiAgICB5ID0gKHhwKnEqKHFeLTEgbW9kIHApICsgeHEqcCoocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBUaGlzIGNhbiBiZSBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW1wbGUgYWxnb3JpdGhtIHRoYXQgb25seVxuICAgIHJlcXVpcmVzIDEgaW52ZXJzZSAodGhlIHEgaW52ZXJzZSBpcyB1c2VkKSB0byBiZSB1c2VkIGFuZCBzdG9yZWQuXG4gICAgVGhlIGFsZ29yaXRobSBpcyBjYWxsZWQgR2FybmVyJ3MgYWxnb3JpdGhtLiBJZiBxSW52IGlzIHRoZVxuICAgIGludmVyc2Ugb2YgcSwgd2Ugc2ltcGx5IGNhbGN1bGF0ZTpcblxuICAgIHkgPSAocUludiooeHAgLSB4cSkgbW9kIHApICogcSArIHhxXG5cbiAgICBIb3dldmVyLCB0aGVyZSBhcmUgdHdvIGZ1cnRoZXIgY29tcGxpY2F0aW9ucy4gRmlyc3QsIHdlIG5lZWQgdG9cbiAgICBlbnN1cmUgdGhhdCB4cCA+IHhxIHRvIHByZXZlbnQgc2lnbmVkIEJpZ0ludGVnZXJzIGZyb20gYmVpbmcgdXNlZFxuICAgIHNvIHdlIGFkZCBwIHVudGlsIHRoaXMgaXMgdHJ1ZSAoc2luY2Ugd2Ugd2lsbCBiZSBtb2QnaW5nIHdpdGhcbiAgICBwIGFueXdheSkuIFRoZW4sIHRoZXJlIGlzIGEga25vd24gdGltaW5nIGF0dGFjayBvbiBhbGdvcml0aG1zXG4gICAgdXNpbmcgdGhlIENSVC4gVG8gbWl0aWdhdGUgdGhpcyByaXNrLCBcImNyeXB0b2dyYXBoaWMgYmxpbmRpbmdcIlxuICAgIHNob3VsZCBiZSB1c2VkLiBUaGlzIHJlcXVpcmVzIHNpbXBseSBnZW5lcmF0aW5nIGEgcmFuZG9tIG51bWJlciByXG4gICAgYmV0d2VlbiAwIGFuZCBuLTEgYW5kIGl0cyBpbnZlcnNlIGFuZCBtdWx0aXBseWluZyB4IGJ5IHJeZSBiZWZvcmVcbiAgICBjYWxjdWxhdGluZyB5IGFuZCB0aGVuIG11bHRpcGx5aW5nIHkgYnkgcl4tMSBhZnRlcndhcmRzLiBOb3RlIHRoYXRcbiAgICByIG11c3QgYmUgY29wcmltZSB3aXRoIG4gKGdjZChyLCBuKSA9PT0gMSkgaW4gb3JkZXIgdG8gaGF2ZSBhblxuICAgIGludmVyc2UuXG4gICovXG5cbiAgLy8gY3J5cHRvZ3JhcGhpYyBibGluZGluZ1xuICB2YXIgcjtcbiAgZG8ge1xuICAgIHIgPSBuZXcgQmlnSW50ZWdlcihcbiAgICAgIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KSksXG4gICAgICAxNik7XG4gIH0gd2hpbGUoci5jb21wYXJlVG8oa2V5Lm4pID49IDAgfHwgIXIuZ2NkKGtleS5uKS5lcXVhbHMoQmlnSW50ZWdlci5PTkUpKTtcbiAgeCA9IHgubXVsdGlwbHkoci5tb2RQb3coa2V5LmUsIGtleS5uKSkubW9kKGtleS5uKTtcblxuICAvLyBjYWxjdWxhdGUgeHAgYW5kIHhxXG4gIHZhciB4cCA9IHgubW9kKGtleS5wKS5tb2RQb3coa2V5LmRQLCBrZXkucCk7XG4gIHZhciB4cSA9IHgubW9kKGtleS5xKS5tb2RQb3coa2V5LmRRLCBrZXkucSk7XG5cbiAgLy8geHAgbXVzdCBiZSBsYXJnZXIgdGhhbiB4cSB0byBhdm9pZCBzaWduZWQgYml0IHVzYWdlXG4gIHdoaWxlKHhwLmNvbXBhcmVUbyh4cSkgPCAwKSB7XG4gICAgeHAgPSB4cC5hZGQoa2V5LnApO1xuICB9XG5cbiAgLy8gZG8gbGFzdCBzdGVwXG4gIHZhciB5ID0geHAuc3VidHJhY3QoeHEpXG4gICAgLm11bHRpcGx5KGtleS5xSW52KS5tb2Qoa2V5LnApXG4gICAgLm11bHRpcGx5KGtleS5xKS5hZGQoeHEpO1xuXG4gIC8vIHJlbW92ZSBlZmZlY3Qgb2YgcmFuZG9tIGZvciBjcnlwdG9ncmFwaGljIGJsaW5kaW5nXG4gIHkgPSB5Lm11bHRpcGx5KHIubW9kSW52ZXJzZShrZXkubikpLm1vZChrZXkubik7XG5cbiAgcmV0dXJuIHk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnc2lnbicgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICdlbmNyeXB0JyBvbiBhIHB1YmxpYyBrZXkgb2JqZWN0IGluc3RlYWQuXG4gKlxuICogUGVyZm9ybXMgUlNBIGVuY3J5cHRpb24uXG4gKlxuICogVGhlIHBhcmFtZXRlciBidCBjb250cm9scyB3aGV0aGVyIHRvIHB1dCBwYWRkaW5nIGJ5dGVzIGJlZm9yZSB0aGVcbiAqIG1lc3NhZ2UgcGFzc2VkIGluLiBTZXQgYnQgdG8gZWl0aGVyIHRydWUgb3IgZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nXG4gKiBjb21wbGV0ZWx5IChpbiBvcmRlciB0byBoYW5kbGUgZS5nLiBFTVNBLVBTUyBlbmNvZGluZyBzZXBlcmF0ZWx5IGJlZm9yZSksXG4gKiBzaWduYWxpbmcgd2hldGhlciB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYSBwdWJsaWMga2V5IG9wZXJhdGlvblxuICogKGkuZS4gZW5jcnlwdGluZyBkYXRhKSBvciBub3QsIGkuZS4gcHJpdmF0ZSBrZXkgb3BlcmF0aW9uIChkYXRhIHNpZ25pbmcpLlxuICpcbiAqIEZvciBQS0NTIzEgdjEuNSBwYWRkaW5nIHBhc3MgaW4gdGhlIGJsb2NrIHR5cGUgdG8gdXNlLCBpLmUuIGVpdGhlciAweDAxXG4gKiAoZm9yIHNpZ25pbmcpIG9yIDB4MDIgKGZvciBlbmNyeXB0aW9uKS4gVGhlIGtleSBvcGVyYXRpb24gbW9kZSAocHJpdmF0ZVxuICogb3IgcHVibGljKSBpcyBkZXJpdmVkIGZyb20gdGhpcyBmbGFnIGluIHRoYXQgY2FzZSkuXG4gKlxuICogQHBhcmFtIG0gdGhlIG1lc3NhZ2UgdG8gZW5jcnlwdCBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gYnQgZm9yIFBLQ1MjMSB2MS41IHBhZGRpbmcsIHRoZSBibG9jayB0eXBlIHRvIHVzZVxuICogICAoMHgwMSBmb3IgcHJpdmF0ZSBrZXksIDB4MDIgZm9yIHB1YmxpYyksXG4gKiAgIHRvIGRpc2FibGUgcGFkZGluZzogdHJ1ZSA9IHB1YmxpYyBrZXksIGZhbHNlID0gcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgZW5jcnlwdGVkIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICovXG5wa2kucnNhLmVuY3J5cHQgPSBmdW5jdGlvbihtLCBrZXksIGJ0KSB7XG4gIHZhciBwdWIgPSBidDtcbiAgdmFyIGViO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgaWYoYnQgIT09IGZhbHNlICYmIGJ0ICE9PSB0cnVlKSB7XG4gICAgLy8gbGVnYWN5LCBkZWZhdWx0IHRvIFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAgICBwdWIgPSAoYnQgPT09IDB4MDIpO1xuICAgIGViID0gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCk7XG4gIH0gZWxzZSB7XG4gICAgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGViLnB1dEJ5dGVzKG0pO1xuICB9XG5cbiAgLy8gbG9hZCBlbmNyeXB0aW9uIGJsb2NrIGFzIGJpZyBpbnRlZ2VyICd4J1xuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB4ID0gbmV3IEJpZ0ludGVnZXIoZWIudG9IZXgoKSwgMTYpO1xuXG4gIC8vIGRvIFJTQSBlbmNyeXB0aW9uXG4gIHZhciB5ID0gX21vZFBvdyh4LCBrZXksIHB1Yik7XG5cbiAgLy8gY29udmVydCB5IGludG8gdGhlIGVuY3J5cHRlZCBkYXRhIGJ5dGUgc3RyaW5nLCBpZiB5IGlzIHNob3J0ZXIgaW5cbiAgLy8gYnl0ZXMgdGhhbiBrLCB0aGVuIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGVkXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHloZXggPSB5LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh5aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlZC5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWQucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHloZXgpKTtcbiAgcmV0dXJuIGVkLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnZGVjcnlwdCcgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICd2ZXJpZnknIG9uIGEgcHVibGljIGtleSBvYmplY3QgaW5zdGVhZC5cbiAqXG4gKiBQZXJmb3JtcyBSU0EgZGVjcnlwdGlvbi5cbiAqXG4gKiBUaGUgcGFyYW1ldGVyIG1sIGNvbnRyb2xzIHdoZXRoZXIgdG8gYXBwbHkgUEtDUyMxIHYxLjUgcGFkZGluZ1xuICogb3Igbm90LiAgU2V0IG1sID0gZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nIHJlbW92YWwgY29tcGxldGVseVxuICogKGluIG9yZGVyIHRvIGhhbmRsZSBlLmcuIEVNU0EtUFNTIGxhdGVyIG9uKSBhbmQgc2ltcGx5IHBhc3MgYmFja1xuICogdGhlIFJTQSBlbmNyeXB0aW9uIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBlZCB0aGUgZW5jcnlwdGVkIGRhdGEgdG8gZGVjcnlwdCBpbiBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgZm9yIGEgcHVibGljIGtleSBvcGVyYXRpb24sIGZhbHNlIGZvciBwcml2YXRlLlxuICogQHBhcmFtIG1sIHRoZSBtZXNzYWdlIGxlbmd0aCwgaWYga25vd24sIGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNyeXB0ZWQgbWVzc2FnZSBhcyBhIGJ5dGUgc3RyaW5nLlxuICovXG5wa2kucnNhLmRlY3J5cHQgPSBmdW5jdGlvbihlZCwga2V5LCBwdWIsIG1sKSB7XG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLy8gZXJyb3IgaWYgdGhlIGxlbmd0aCBvZiB0aGUgZW5jcnlwdGVkIGRhdGEgRUQgaXMgbm90IGtcbiAgaWYoZWQubGVuZ3RoICE9PSBrKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlZC5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWQgPSBrO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY29udmVydCBlbmNyeXB0ZWQgZGF0YSBpbnRvIGEgYmlnIGludGVnZXJcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeSA9IG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVkKS50b0hleCgpLCAxNik7XG5cbiAgLy8geSBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgbW9kdWx1cyBvciBpdCB3YXNuJ3QgdGhlIHJlc3VsdCBvZlxuICAvLyBhIHByZXZpb3VzIG1vZCBvcGVyYXRpb24gKGVuY3J5cHRpb24pIHVzaW5nIHRoYXQgbW9kdWx1c1xuICBpZih5LmNvbXBhcmVUbyhrZXkubikgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIC8vIGRvIFJTQSBkZWNyeXB0aW9uXG4gIHZhciB4ID0gX21vZFBvdyh5LCBrZXksIHB1Yik7XG5cbiAgLy8gY3JlYXRlIHRoZSBlbmNyeXB0aW9uIGJsb2NrLCBpZiB4IGlzIHNob3J0ZXIgaW4gYnl0ZXMgdGhhbiBrLCB0aGVuXG4gIC8vIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGViXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHhoZXggPSB4LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh4aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlYi5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWIucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHhoZXgpKTtcblxuICBpZihtbCAhPT0gZmFsc2UpIHtcbiAgICAvLyBsZWdhY3ksIGRlZmF1bHQgdG8gUEtDUyMxIHYxLjUgcGFkZGluZ1xuICAgIHJldHVybiBfZGVjb2RlUGtjczFfdjFfNShlYi5nZXRCeXRlcygpLCBrZXksIHB1Yik7XG4gIH1cblxuICAvLyByZXR1cm4gbWVzc2FnZVxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSU0Ega2V5LXBhaXIgZ2VuZXJhdGlvbiBzdGF0ZSBvYmplY3QuIEl0IGlzIHVzZWQgdG8gYWxsb3dcbiAqIGtleS1nZW5lcmF0aW9uIHRvIGJlIHBlcmZvcm1lZCBpbiBzdGVwcy4gSXQgYWxzbyBhbGxvd3MgZm9yIGEgVUkgdG9cbiAqIGRpc3BsYXkgcHJvZ3Jlc3MgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgc2l6ZSBmb3IgdGhlIHByaXZhdGUga2V5IGluIGJpdHMsIGRlZmF1bHRzIHRvIDIwNDguXG4gKiBAcGFyYW0gZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcgKDB4MTAwMDEpLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdGF0ZSBvYmplY3QgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBrZXktcGFpci5cbiAqL1xucGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlID0gZnVuY3Rpb24oYml0cywgZSwgb3B0aW9ucykge1xuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG5cbiAgLy8gc2V0IGRlZmF1bHQgYml0c1xuICBpZih0eXBlb2YoYml0cykgPT09ICdzdHJpbmcnKSB7XG4gICAgYml0cyA9IHBhcnNlSW50KGJpdHMsIDEwKTtcbiAgfVxuICBiaXRzID0gYml0cyB8fCAyMDQ4O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBwcm5nID0gb3B0aW9ucy5wcm5nIHx8IGZvcmdlLnJhbmRvbTtcbiAgdmFyIHJuZyA9IHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGIgPSBwcm5nLmdldEJ5dGVzU3luYyh4Lmxlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4W2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcblxuICAvLyBjcmVhdGUgUFJJTUVJTkMgYWxnb3JpdGhtIHN0YXRlXG4gIHZhciBydmFsO1xuICBpZihhbGdvcml0aG0gPT09ICdQUklNRUlOQycpIHtcbiAgICBydmFsID0ge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBzdGF0ZTogMCxcbiAgICAgIGJpdHM6IGJpdHMsXG4gICAgICBybmc6IHJuZyxcbiAgICAgIGVJbnQ6IGUgfHwgNjU1MzcsXG4gICAgICBlOiBuZXcgQmlnSW50ZWdlcihudWxsKSxcbiAgICAgIHA6IG51bGwsXG4gICAgICBxOiBudWxsLFxuICAgICAgcUJpdHM6IGJpdHMgPj4gMSxcbiAgICAgIHBCaXRzOiBiaXRzIC0gKGJpdHMgPj4gMSksXG4gICAgICBwcVN0YXRlOiAwLFxuICAgICAgbnVtOiBudWxsLFxuICAgICAga2V5czogbnVsbFxuICAgIH07XG4gICAgcnZhbC5lLmZyb21JbnQocnZhbC5lSW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IGdlbmVyYXRpb24gYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBydW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gZm9yIGF0IG1vc3QgbiBzZWNvbmRzXG4gKiAoYXBwcm94aW1hdGVseSkgdXNpbmcgdGhlIGdpdmVuIHN0YXRlLiBXaGVuIGtleS1nZW5lcmF0aW9uIGhhcyBjb21wbGV0ZWQsXG4gKiB0aGUga2V5cyB3aWxsIGJlIHN0b3JlZCBpbiBzdGF0ZS5rZXlzLlxuICpcbiAqIFRvIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIHVwZGF0ZSBhIFVJIHdoaWxlIGdlbmVyYXRpbmcgYSBrZXkgb3IgdG8gcHJldmVudFxuICogY2F1c2luZyBicm93c2VyIGxvY2t1cHMvd2FybmluZ3MsIHNldCBcIm5cIiB0byBhIHZhbHVlIG90aGVyIHRoYW4gMC4gQVxuICogc2ltcGxlIHBhdHRlcm4gZm9yIGdlbmVyYXRpbmcgYSBrZXkgYW5kIHNob3dpbmcgYSBwcm9ncmVzcyBpbmRpY2F0b3IgaXM6XG4gKlxuICogdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKDIwNDgpO1xuICogdmFyIHN0ZXAgPSBmdW5jdGlvbigpIHtcbiAqICAgLy8gc3RlcCBrZXktZ2VuZXJhdGlvbiwgcnVuIGFsZ29yaXRobSBmb3IgMTAwIG1zLCByZXBlYXRcbiAqICAgaWYoIWZvcmdlLnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUoc3RhdGUsIDEwMCkpIHtcbiAqICAgICBzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuICogICB9IGVsc2Uge1xuICogICAgIC8vIGtleS1nZW5lcmF0aW9uIGNvbXBsZXRlXG4gKiAgICAgLy8gVE9ETzogdHVybiBvZmYgcHJvZ3Jlc3MgaW5kaWNhdG9yIGhlcmVcbiAqICAgICAvLyBUT0RPOiB1c2UgdGhlIGdlbmVyYXRlZCBrZXktcGFpciBpbiBcInN0YXRlLmtleXNcIlxuICogICB9XG4gKiB9O1xuICogLy8gVE9ETzogdHVybiBvbiBwcm9ncmVzcyBpbmRpY2F0b3IgaGVyZVxuICogc2V0VGltZW91dChzdGVwLCAwKTtcbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIHVzZS5cbiAqIEBwYXJhbSBuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gcnVuIHRoZSBhbGdvcml0aG0gZm9yLCAwXG4gKiAgICAgICAgICB0byBydW4gdGhlIGFsZ29yaXRobSB0byBjb21wbGV0aW9uLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUga2V5LWdlbmVyYXRpb24gY29tcGxldGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbikge1xuICAvLyBzZXQgZGVmYXVsdCBhbGdvcml0aG0gaWYgbm90IHNldFxuICBpZighKCdhbGdvcml0aG0nIGluIHN0YXRlKSkge1xuICAgIHN0YXRlLmFsZ29yaXRobSA9ICdQUklNRUlOQyc7XG4gIH1cblxuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG4gIC8vIFRPRE86IGFic3RyYWN0IGFzIFBSSU1FSU5DIGFsZ29yaXRobVxuXG4gIC8vIGRvIGtleSBnZW5lcmF0aW9uIChiYXNlZCBvbiBUb20gV3UncyByc2EuanMsIHNlZSBqc2JuLmpzIGxpY2Vuc2UpXG4gIC8vIHdpdGggc29tZSBtaW5vciBvcHRpbWl6YXRpb25zIGFuZCBkZXNpZ25lZCB0byBydW4gaW4gc3RlcHNcblxuICAvLyBsb2NhbCBzdGF0ZSB2YXJzXG4gIHZhciBUSElSVFkgPSBuZXcgQmlnSW50ZWdlcihudWxsKTtcbiAgVEhJUlRZLmZyb21JbnQoMzApO1xuICB2YXIgZGVsdGFJZHggPSAwO1xuICB2YXIgb3Bfb3IgPSBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4fHk7IH07XG5cbiAgLy8ga2VlcCBzdGVwcGluZyB1bnRpbCB0aW1lIGxpbWl0IGlzIHJlYWNoZWQgb3IgZG9uZVxuICB2YXIgdDEgPSArbmV3IERhdGUoKTtcbiAgdmFyIHQyO1xuICB2YXIgdG90YWwgPSAwO1xuICB3aGlsZShzdGF0ZS5rZXlzID09PSBudWxsICYmIChuIDw9IDAgfHwgdG90YWwgPCBuKSkge1xuICAgIC8vIGdlbmVyYXRlIHAgb3IgcVxuICAgIGlmKHN0YXRlLnN0YXRlID09PSAwKSB7XG4gICAgICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybTpcblxuICAgICAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xLCB3aGVyZSB0aGVyZSBhcmUgOCB2YWx1ZXMgZm9yIGlcblxuICAgICAgICBXaGVuIHdlIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciwgd2UgYWx3YXlzIGFsaWduIGl0IGF0IDMwayArIDEuIEVhY2hcbiAgICAgICAgdGltZSB0aGUgbnVtYmVyIGlzIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlXG4gICAgICAgIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlciB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgICAgIHZhciBiaXRzID0gKHN0YXRlLnAgPT09IG51bGwpID8gc3RhdGUucEJpdHMgOiBzdGF0ZS5xQml0cztcbiAgICAgIHZhciBiaXRzMSA9IGJpdHMgLSAxO1xuXG4gICAgICAvLyBnZXQgYSByYW5kb20gbnVtYmVyXG4gICAgICBpZihzdGF0ZS5wcVN0YXRlID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHN0YXRlLnJuZyk7XG4gICAgICAgIC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgaWYoIXN0YXRlLm51bS50ZXN0Qml0KGJpdHMxKSkge1xuICAgICAgICAgIHN0YXRlLm51bS5iaXR3aXNlVG8oXG4gICAgICAgICAgICBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYml0czEpLCBvcF9vciwgc3RhdGUubnVtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGlnbiBudW1iZXIgb24gMzBrKzEgYm91bmRhcnlcbiAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoMzEgLSBzdGF0ZS5udW0ubW9kKFRISVJUWSkuYnl0ZVZhbHVlKCksIDApO1xuICAgICAgICBkZWx0YUlkeCA9IDA7XG5cbiAgICAgICAgKytzdGF0ZS5wcVN0YXRlO1xuICAgICAgfSBlbHNlIGlmKHN0YXRlLnBxU3RhdGUgPT09IDEpIHtcbiAgICAgICAgLy8gdHJ5IHRvIG1ha2UgdGhlIG51bWJlciBhIHByaW1lXG4gICAgICAgIGlmKHN0YXRlLm51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgICAgICAvLyBvdmVyZmxvdywgdHJ5IGFnYWluXG4gICAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgICAgLy8gZG8gcHJpbWFsaXR5IHRlc3RcbiAgICAgICAgfSBlbHNlIGlmKHN0YXRlLm51bS5pc1Byb2JhYmxlUHJpbWUoXG4gICAgICAgICAgX2dldE1pbGxlclJhYmluVGVzdHMoc3RhdGUubnVtLmJpdExlbmd0aCgpKSkpIHtcbiAgICAgICAgICArK3N0YXRlLnBxU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0IG5leHQgcG90ZW50aWFsIHByaW1lXG4gICAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoR0NEXzMwX0RFTFRBW2RlbHRhSWR4KysgJSA4XSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5wcVN0YXRlID09PSAyKSB7XG4gICAgICAgIC8vIGVuc3VyZSBudW1iZXIgaXMgY29wcmltZSB3aXRoIGVcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9XG4gICAgICAgICAgKHN0YXRlLm51bS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAgICAgLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT09IDApID8gMyA6IDA7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMykge1xuICAgICAgICAvLyBzdG9yZSBwIG9yIHFcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgIGlmKHN0YXRlLnAgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5wID0gc3RhdGUubnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIHN0YXRlIGlmIGJvdGggcCBhbmQgcSBhcmUgcmVhZHlcbiAgICAgICAgaWYoc3RhdGUucCAhPT0gbnVsbCAmJiBzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5udW0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gMSkge1xuICAgICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBzdGF0ZS5wO1xuICAgICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgICAgc3RhdGUucSA9IHN0YXRlLm51bTtcbiAgICAgIH1cbiAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSAyKSB7XG4gICAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICBzdGF0ZS5xMSA9IHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIGVuc3VyZSBlIGFuZCBwaGkgYXJlIGNvcHJpbWVcbiAgICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PT0gMCkge1xuICAgICAgICAvLyBwaGkgYW5kIGUgYXJlIGNvcHJpbWUsIGFkdmFuY2VcbiAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBoaSBhbmQgZSBhcmVuJ3QgY29wcmltZSwgc28gZ2VuZXJhdGUgYSBuZXcgcCBhbmQgcVxuICAgICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDQpIHtcbiAgICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcblxuICAgICAgLy8gZW5zdXJlIG4gaXMgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICAgIGlmKHN0YXRlLm4uYml0TGVuZ3RoKCkgPT09IHN0YXRlLmJpdHMpIHtcbiAgICAgICAgLy8gc3VjY2VzcywgYWR2YW5jZVxuICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDUpIHtcbiAgICAgIC8vIHNldCBrZXlzXG4gICAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgICAgc3RhdGUua2V5cyA9IHtcbiAgICAgICAgcHJpdmF0ZUtleTogcGtpLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgICAgc3RhdGUucS5tb2RJbnZlcnNlKHN0YXRlLnApKSxcbiAgICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGltaW5nXG4gICAgdDIgPSArbmV3IERhdGUoKTtcbiAgICB0b3RhbCArPSB0MiAtIHQxO1xuICAgIHQxID0gdDI7XG4gIH1cblxuICByZXR1cm4gc3RhdGUua2V5cyAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIFJTQSBwdWJsaWMtcHJpdmF0ZSBrZXkgcGFpciBpbiBhIHNpbmdsZSBjYWxsLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgaW4gc3RlcHMgKHRvIGFsbG93IGZvciBwcm9ncmVzcyB1cGRhdGVzIGFuZCB0b1xuICogcHJldmVudCBibG9ja2luZyBvciB3YXJuaW5ncyBpbiBzbG93IGJyb3dzZXJzKSB0aGVuIHVzZSB0aGUga2V5LXBhaXJcbiAqIGdlbmVyYXRpb24gc3RhdGUgZnVuY3Rpb25zLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgYXN5bmNocm9ub3VzbHkgKGVpdGhlciB0aHJvdWdoIHdlYi13b3JrZXJzLCBpZlxuICogYXZhaWxhYmxlLCBvciBieSBicmVha2luZyB1cCB0aGUgd29yayBvbiB0aGUgbWFpbiB0aHJlYWQpLCBwYXNzIGFcbiAqIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBbYml0c10gdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIFtlXSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb24sIGlmIGdpdmVuIHRoZW4gJ2JpdHMnXG4gKiAgICAgICAgICBhbmQgJ2UnIG11c3QgKm5vdCogYmUgZ2l2ZW46XG4gKiAgICAgICAgICBiaXRzIHRoZSBzaXplIGZvciB0aGUgcHJpdmF0ZSBrZXkgaW4gYml0cywgKGRlZmF1bHQ6IDIwNDgpLlxuICogICAgICAgICAgZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgKGRlZmF1bHQ6IDY1NTM3ICgweDEwMDAxKSkuXG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIpLlxuICogICAgICAgICAgd29ya0xvYWQgdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgICAgICBudW1iZXJzIGZvciBlYWNoIHdlYiB3b3JrZXIgdG8gY2hlY2sgcGVyIHdvcmsgYXNzaWdubWVudCxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXlwYWlyKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKlxuICogQHJldHVybiBhbiBvYmplY3Qgd2l0aCBwcml2YXRlS2V5IGFuZCBwdWJsaWNLZXkgcHJvcGVydGllcy5cbiAqL1xucGtpLnJzYS5nZW5lcmF0ZUtleVBhaXIgPSBmdW5jdGlvbihiaXRzLCBlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyAoYml0cyksIChvcHRpb25zKSwgKGNhbGxiYWNrKVxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYodHlwZW9mIGJpdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0gYml0cztcbiAgICAgIGJpdHMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBiaXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGJpdHM7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyAoYml0cywgZSksIChiaXRzLCBvcHRpb25zKSwgKGJpdHMsIGNhbGxiYWNrKSwgKG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIGlmKHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgaWYodHlwZW9mIGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBlO1xuICAgICAgICBlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmKHR5cGVvZiBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICBvcHRpb25zID0gZTtcbiAgICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGJpdHM7XG4gICAgICBjYWxsYmFjayA9IGU7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgLy8gKGJpdHMsIGUsIG9wdGlvbnMpLCAoYml0cywgZSwgY2FsbGJhY2spLCAoYml0cywgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgaWYodHlwZW9mIGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBlO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKGJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGJpdHMgPSBvcHRpb25zLmJpdHMgfHwgMjA0ODtcbiAgfVxuICBpZihlID09PSB1bmRlZmluZWQpIHtcbiAgICBlID0gb3B0aW9ucy5lIHx8IDB4MTAwMDE7XG4gIH1cblxuICAvLyBpZiBuYXRpdmUgY29kZSBpcyBwZXJtaXR0ZWQgYW5kIGEgY2FsbGJhY2sgaXMgZ2l2ZW4sIHVzZSBuYXRpdmVcbiAgLy8ga2V5IGdlbmVyYXRpb24gY29kZSBpZiBhdmFpbGFibGUgYW5kIGlmIHBhcmFtZXRlcnMgYXJlIGFjY2VwdGFibGVcbiAgaWYoIWZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQgJiYgY2FsbGJhY2sgJiZcbiAgICBiaXRzID49IDI1NiAmJiBiaXRzIDw9IDE2Mzg0ICYmIChlID09PSAweDEwMDAxIHx8IGUgPT09IDMpKSB7XG4gICAgaWYoX2RldGVjdFN1YnRsZUNyeXB0bygnZ2VuZXJhdGVLZXknKSAmJiBfZGV0ZWN0U3VidGxlQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgLy8gdXNlIHN0YW5kYXJkIG5hdGl2ZSBnZW5lcmF0ZUtleVxuICAgICAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgcHVibGljRXhwb25lbnQ6IF9pbnRUb1VpbnQ4QXJyYXkoZSksXG4gICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9XG4gICAgICB9LCB0cnVlIC8qIGtleSBjYW4gYmUgZXhwb3J0ZWQqLywgWydzaWduJywgJ3ZlcmlmeSddKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocGFpcikge1xuICAgICAgICByZXR1cm4gd2luZG93LmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdwa2NzOCcsIHBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAvLyBhdm9pZGluZyBjYXRjaChmdW5jdGlvbihlcnIpIHsuLi59KSB0byBzdXBwb3J0IElFIDw9IDhcbiAgICAgIH0pLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocGtjczgpIHtcbiAgICAgICAgaWYocGtjczgpIHtcbiAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoXG4gICAgICAgICAgICBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGtjczgpKSk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGtpLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmKF9kZXRlY3RTdWJ0bGVNc0NyeXB0bygnZ2VuZXJhdGVLZXknKSAmJlxuICAgICAgX2RldGVjdFN1YnRsZU1zQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgdmFyIGdlbk9wID0gd2luZG93Lm1zQ3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgIHB1YmxpY0V4cG9uZW50OiBfaW50VG9VaW50OEFycmF5KGUpLFxuICAgICAgICBoYXNoOiB7bmFtZTogJ1NIQS0yNTYnfVxuICAgICAgfSwgdHJ1ZSAvKiBrZXkgY2FuIGJlIGV4cG9ydGVkKi8sIFsnc2lnbicsICd2ZXJpZnknXSk7XG4gICAgICBnZW5PcC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgcGFpciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgdmFyIGV4cG9ydE9wID0gd2luZG93Lm1zQ3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXG4gICAgICAgICAgJ3BrY3M4JywgcGFpci5wcml2YXRlS2V5KTtcbiAgICAgICAgZXhwb3J0T3Aub25jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgcGtjczggPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKFxuICAgICAgICAgICAgYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHBrY3M4KSkpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBraS5zZXRSc2FQdWJsaWNLZXkocHJpdmF0ZUtleS5uLCBwcml2YXRlS2V5LmUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGV4cG9ydE9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGdlbk9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25cbiAgdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKGJpdHMsIGUsIG9wdGlvbnMpO1xuICBpZighY2FsbGJhY2spIHtcbiAgICBwa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlKHN0YXRlLCAwKTtcbiAgICByZXR1cm4gc3RhdGUua2V5cztcbiAgfVxuICBfZ2VuZXJhdGVLZXlQYWlyKHN0YXRlLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gUlNBIHB1YmxpYyBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzIGFuZCBleHBvbmVudC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbW9kdWx1cy5cbiAqIEBwYXJhbSBlIHRoZSBleHBvbmVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kuc2V0UnNhUHVibGljS2V5ID0gcGtpLnJzYS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbihuLCBlKSB7XG4gIHZhciBrZXkgPSB7XG4gICAgbjogbixcbiAgICBlOiBlXG4gIH07XG5cbiAgLyoqXG4gICAqIEVuY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwdWJsaWMga2V5LiBOZXdlciBhcHBsaWNhdGlvbnNcbiAgICogc2hvdWxkIHVzZSB0aGUgJ1JTQS1PQUVQJyBkZWNyeXB0aW9uIHNjaGVtZSwgJ1JTQUVTLVBLQ1MxLVYxXzUnIGlzIGZvclxuICAgKiBsZWdhY3kgYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgYnl0ZSBzdHJpbmcgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgZW5jcnlwdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBRVMtUEtDUzEtVjFfNScgKGRlZmF1bHQpLFxuICAgKiAgICAgICAgICAnUlNBLU9BRVAnLFxuICAgKiAgICAgICAgICAnUkFXJywgJ05PTkUnLCBvciBudWxsIHRvIHBlcmZvcm0gcmF3IFJTQSBlbmNyeXB0aW9uLFxuICAgKiAgICAgICAgICBhbiBvYmplY3Qgd2l0aCBhbiAnZW5jb2RlJyBwcm9wZXJ0eSBzZXQgdG8gYSBmdW5jdGlvblxuICAgKiAgICAgICAgICB3aXRoIHRoZSBzaWduYXR1cmUgJ2Z1bmN0aW9uKGRhdGEsIGtleSknIHRoYXQgcmV0dXJuc1xuICAgKiAgICAgICAgICBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVuY29kZWQgZGF0YS5cbiAgICogQHBhcmFtIHNjaGVtZU9wdGlvbnMgYW55IHNjaGVtZS1zcGVjaWZpYyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBlbmNyeXB0ZWQgYnl0ZSBzdHJpbmcuXG4gICAqL1xuICBrZXkuZW5jcnlwdCA9IGZ1bmN0aW9uKGRhdGEsIHNjaGVtZSwgc2NoZW1lT3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjaGVtZSA9ICdSU0FFUy1QS0NTMS1WMV81JztcbiAgICB9XG5cbiAgICBpZihzY2hlbWUgPT09ICdSU0FFUy1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uKG0sIGtleSwgcHViKSB7XG4gICAgICAgICAgcmV0dXJuIF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgMHgwMikuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24obSwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmVuY29kZV9yc2Ffb2FlcChrZXksIG0sIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7IGVuY29kZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gZTsgfSB9O1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRvIHNjaGVtZS1iYXNlZCBlbmNvZGluZyB0aGVuIHJzYSBlbmNyeXB0aW9uXG4gICAgdmFyIGUgPSBzY2hlbWUuZW5jb2RlKGRhdGEsIGtleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChlLCBrZXksIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFnYWluc3QgdGhlIGdpdmVuIGRpZ2VzdC5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSwgaW4gd2hpY2ggY2FzZSBvbmNlIFJTQS1kZWNyeXB0ZWQsIHRoZVxuICAgKiBzaWduYXR1cmUgaXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaG9sZHMgYSBEaWdlc3RJbmZvLlxuICAgKlxuICAgKiBEaWdlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gICAqICAgZGlnZXN0IERpZ2VzdFxuICAgKiB9XG4gICAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAgICpcbiAgICogVG8gcGVyZm9ybSBQU1Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiwgcHJvdmlkZSBhbiBpbnN0YW5jZVxuICAgKiBvZiBGb3JnZSBQU1Mgb2JqZWN0IGFzIHRoZSBzY2hlbWUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gZGlnZXN0IHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLFxuICAgKiAgICAgICAgICBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBzY2hlbWUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBU1NBLVBLQ1MxLVYxXzUnIG9yIHVuZGVmaW5lZCBmb3IgUlNBU1NBIFBLQ1MjMSB2MS41LFxuICAgKiAgICAgICAgICBhIEZvcmdlIFBTUyBvYmplY3QgZm9yIFJTQVNTQS1QU1MsXG4gICAqICAgICAgICAgICdOT05FJyBvciBudWxsIGZvciBub25lLCBEaWdlc3RJbmZvIHdpbGwgbm90IGJlIGV4cGVjdGVkLCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICAga2V5LnZlcmlmeSA9IGZ1bmN0aW9uKGRpZ2VzdCwgc2lnbmF0dXJlLCBzY2hlbWUpIHtcbiAgICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgc2NoZW1lID0gJ1JTQVNTQS1QS0NTMS1WMV81JztcbiAgICAgfVxuXG4gICAgIGlmKHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgIC8vIHJlbW92ZSBwYWRkaW5nXG4gICAgICAgICAgIGQgPSBfZGVjb2RlUGtjczFfdjFfNShkLCBrZXksIHRydWUpO1xuICAgICAgICAgICAvLyBkIGlzIEFTTi4xIEJFUi1lbmNvZGVkIERpZ2VzdEluZm9cbiAgICAgICAgICAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihkKTtcbiAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgZ2l2ZW4gZGlnZXN0IHRvIHRoZSBkZWNyeXB0ZWQgb25lXG4gICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IG9iai52YWx1ZVsxXS52YWx1ZTtcbiAgICAgICAgIH1cbiAgICAgICB9O1xuICAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnTk9ORScgfHwgc2NoZW1lID09PSAnTlVMTCcgfHwgc2NoZW1lID09PSBudWxsKSB7XG4gICAgICAgc2NoZW1lID0ge1xuICAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbihkaWdlc3QsIGQpIHtcbiAgICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICAgZCA9IF9kZWNvZGVQa2NzMV92MV81KGQsIGtleSwgdHJ1ZSk7XG4gICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IGQ7XG4gICAgICAgICB9XG4gICAgICAgfTtcbiAgICAgfVxuXG4gICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmcsIHRoZW4gdmVyaWZ5IC0tIHdoaWNoIGRvZXMgZGVjb2RpbmdcbiAgICAgdmFyIGQgPSBwa2kucnNhLmRlY3J5cHQoc2lnbmF0dXJlLCBrZXksIHRydWUsIGZhbHNlKTtcbiAgICAgcmV0dXJuIHNjaGVtZS52ZXJpZnkoZGlnZXN0LCBkLCBrZXkubi5iaXRMZW5ndGgoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBSU0EgcHJpdmF0ZSBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzLCBleHBvbmVudCwgcHJpbWVzLFxuICogcHJpbWUgZXhwb25lbnRzLCBhbmQgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBtb2R1bHVzLlxuICogQHBhcmFtIGUgdGhlIHB1YmxpYyBleHBvbmVudC5cbiAqIEBwYXJhbSBkIHRoZSBwcml2YXRlIGV4cG9uZW50ICgoaW52ZXJzZSBvZiBlKSBtb2QgbikuXG4gKiBAcGFyYW0gcCB0aGUgZmlyc3QgcHJpbWUuXG4gKiBAcGFyYW0gcSB0aGUgc2Vjb25kIHByaW1lLlxuICogQHBhcmFtIGRQIGV4cG9uZW50MSAoZCBtb2QgKHAtMSkpLlxuICogQHBhcmFtIGRRIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpLlxuICogQHBhcmFtIHFJbnYgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kuc2V0UnNhUHJpdmF0ZUtleSA9IHBraS5yc2Euc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uKFxuICBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnYpIHtcbiAgdmFyIGtleSA9IHtcbiAgICBuOiBuLFxuICAgIGU6IGUsXG4gICAgZDogZCxcbiAgICBwOiBwLFxuICAgIHE6IHEsXG4gICAgZFA6IGRQLFxuICAgIGRROiBkUSxcbiAgICBxSW52OiBxSW52XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwcml2YXRlIGtleS4gVGhlIGRlY3J5cHRpb24gc2NoZW1lXG4gICAqIG11c3QgbWF0Y2ggdGhlIG9uZSB1c2VkIHRvIGVuY3J5cHQgdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBieXRlIHN0cmluZyB0byBkZWNyeXB0LlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBkZWNyeXB0aW9uIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FFUy1QS0NTMS1WMV81JyAoZGVmYXVsdCksXG4gICAqICAgICAgICAgICdSU0EtT0FFUCcsXG4gICAqICAgICAgICAgICdSQVcnLCAnTk9ORScsIG9yIG51bGwgdG8gcGVyZm9ybSByYXcgUlNBIGRlY3J5cHRpb24uXG4gICAqIEBwYXJhbSBzY2hlbWVPcHRpb25zIGFueSBzY2hlbWUtc3BlY2lmaWMgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZGVjcnlwdGVkIGJ5dGUgc3RyaW5nLlxuICAgKi9cbiAga2V5LmRlY3J5cHQgPSBmdW5jdGlvbihkYXRhLCBzY2hlbWUsIHNjaGVtZU9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2hlbWUgPSAnUlNBRVMtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgLy8gZG8gcnNhIGRlY3J5cHRpb24gdy9vIGFueSBkZWNvZGluZ1xuICAgIHZhciBkID0gcGtpLnJzYS5kZWNyeXB0KGRhdGEsIGtleSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIGlmKHNjaGVtZSA9PT0gJ1JTQUVTLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7IGRlY29kZTogX2RlY29kZVBrY3MxX3YxXzUgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24oZCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmRlY29kZV9yc2Ffb2FlcChrZXksIGQsIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7IGRlY29kZTogZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lOiBcIicgKyBzY2hlbWUgKyAnXCIuJyk7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIGFjY29yZGluZyB0byBzY2hlbWVcbiAgICByZXR1cm4gc2NoZW1lLmRlY29kZShkLCBrZXksIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhlIGdpdmVuIGRpZ2VzdCwgcHJvZHVjaW5nIGEgc2lnbmF0dXJlLlxuICAgKlxuICAgKiBQS0NTIzEgc3VwcG9ydHMgbXVsdGlwbGUgKGN1cnJlbnRseSB0d28pIHNpZ25hdHVyZSBzY2hlbWVzOlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSBhbmQgUlNBU1NBLVBTUy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIFwib2xkIHNjaGVtZVwiLCBpLmUuXG4gICAqIFJTQVNTQS1QS0NTMS1WMV81LiBJbiBvcmRlciB0byBnZW5lcmF0ZSBhIFBTUyBzaWduYXR1cmUsIHByb3ZpZGVcbiAgICogYW4gaW5zdGFuY2Ugb2YgRm9yZ2UgUFNTIG9iamVjdCBhcyB0aGUgc2NoZW1lIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBzaWduYXR1cmUgc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQVNTQS1QS0NTMS1WMV81JyBvciB1bmRlZmluZWQgZm9yIFJTQVNTQSBQS0NTIzEgdjEuNSxcbiAgICogICAgICAgICAgYSBGb3JnZSBQU1Mgb2JqZWN0IGZvciBSU0FTU0EtUFNTLFxuICAgKiAgICAgICAgICAnTk9ORScgb3IgbnVsbCBmb3Igbm9uZSwgRGlnZXN0SW5mbyB3aWxsIG5vdCBiZSB1c2VkIGJ1dFxuICAgKiAgICAgICAgICAgIFBLQ1MjMSB2MS41IHBhZGRpbmcgd2lsbCBzdGlsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBzaWduYXR1cmUgYXMgYSBieXRlIHN0cmluZy5cbiAgICovXG4gIGtleS5zaWduID0gZnVuY3Rpb24obWQsIHNjaGVtZSkge1xuICAgIC8qIE5vdGU6IFRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBSU0Egb3BlcmF0aW9ucyBpcyBiZWluZ1xuICAgICAgdHJhbnNpdGlvbmVkIGF3YXkgZnJvbSBhIFBLQ1MjMSB2MS41IGhhcmQtY29kZWQgc2NoZW1lLiBTb21lIGxlZ2FjeVxuICAgICAgY29kZSBsaWtlIHRoZSB1c2Ugb2YgYW4gZW5jb2RpbmcgYmxvY2sgaWRlbnRpZmllciAnYnQnIHdpbGwgZXZlbnR1YWxseVxuICAgICAgYmUgcmVtb3ZlZC4gKi9cblxuICAgIC8vIHByaXZhdGUga2V5IG9wZXJhdGlvblxuICAgIHZhciBidCA9IGZhbHNlO1xuXG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkIHx8IHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0geyBlbmNvZGU6IGVtc2FQa2NzMXYxNWVuY29kZSB9O1xuICAgICAgYnQgPSAweDAxO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdOT05FJyB8fCBzY2hlbWUgPT09ICdOVUxMJyB8fCBzY2hlbWUgPT09IG51bGwpIHtcbiAgICAgIHNjaGVtZSA9IHsgZW5jb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIG1kOyB9IH07XG4gICAgICBidCA9IDB4MDE7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIGFuZCB0aGVuIGVuY3J5cHRcbiAgICB2YXIgZCA9IHNjaGVtZS5lbmNvZGUobWQsIGtleS5uLmJpdExlbmd0aCgpKTtcbiAgICByZXR1cm4gcGtpLnJzYS5lbmNyeXB0KGQsIGtleSwgYnQpO1xuICB9O1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFdyYXBzIGFuIFJTQVByaXZhdGVLZXkgQVNOLjEgb2JqZWN0IGluIGFuIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kud3JhcFJzYVByaXZhdGVLZXkgPSBmdW5jdGlvbihyc2FLZXkpIHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uICgwKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcigwKS5nZXRCeXRlcygpKSxcbiAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgIF0pLFxuICAgIC8vIFByaXZhdGVLZXlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgIGFzbjEudG9EZXIocnNhS2V5KS5nZXRCeXRlcygpKVxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByaXZhdGUga2V5IGZyb20gYW4gQVNOLjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGEgUHJpdmF0ZUtleUluZm8gY29udGFpbmluZyBhblxuICogICAgICAgICAgUlNBUHJpdmF0ZUtleSBvciBhbiBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUZyb21Bc24xID0gZnVuY3Rpb24ob2JqKSB7XG4gIC8vIGdldCBQcml2YXRlS2V5SW5mb1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKGFzbjEudmFsaWRhdGUob2JqLCBwcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgb2JqID0gYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleSkpO1xuICB9XG5cbiAgLy8gZ2V0IFJTQVByaXZhdGVLZXlcbiAgY2FwdHVyZSA9IHt9O1xuICBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2FQcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYW4gUlNBUHJpdmF0ZUtleS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBOb3RlOiBWZXJzaW9uIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuICAvLyBjYXB0dXJlLnByaXZhdGVLZXlWZXJzaW9uXG4gIC8vIEZJWE1FOiBpbmVmZmljaWVudCwgZ2V0IGEgQmlnSW50ZWdlciB0aGF0IHVzZXMgYnl0ZSBzdHJpbmdzXG4gIHZhciBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnY7XG4gIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlNb2R1bHVzKS50b0hleCgpO1xuICBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5UHVibGljRXhwb25lbnQpLnRvSGV4KCk7XG4gIGQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcml2YXRlRXhwb25lbnQpLnRvSGV4KCk7XG4gIHAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTEpLnRvSGV4KCk7XG4gIHEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTIpLnRvSGV4KCk7XG4gIGRQID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5RXhwb25lbnQxKS50b0hleCgpO1xuICBkUSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUV4cG9uZW50MikudG9IZXgoKTtcbiAgcUludiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUNvZWZmaWNpZW50KS50b0hleCgpO1xuXG4gIC8vIHNldCBwcml2YXRlIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVByaXZhdGVLZXkoXG4gICAgbmV3IEJpZ0ludGVnZXIobiwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGUsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKHEsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkUCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGRRLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocUludiwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwcml2YXRlIGtleSB0byBhbiBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGFuIFJTQVByaXZhdGVLZXkuXG4gKi9cbnBraS5wcml2YXRlS2V5VG9Bc24xID0gcGtpLnByaXZhdGVLZXlUb1JTQVByaXZhdGVLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gUlNBUHJpdmF0ZUtleVxuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIHZlcnNpb24gKDAgPSBvbmx5IDIgcHJpbWVzLCAxIG11bHRpcGxlIHByaW1lcylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkubikpLFxuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5lKSksXG4gICAgLy8gcHJpdmF0ZUV4cG9uZW50IChkKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kKSksXG4gICAgLy8gcHJpdmF0ZUtleVByaW1lMSAocClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucCkpLFxuICAgIC8vIHByaXZhdGVLZXlQcmltZTIgKHEpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LnEpKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQxIChkUClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFApKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQyIChkUSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFEpKSxcbiAgICAvLyBjb2VmZmljaWVudCAocUludilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucUludikpXG4gIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgZnJvbSBhbiBBU04uMSBTdWJqZWN0UHVibGljS2V5SW5mbyBvciBSU0FQdWJsaWNLZXkuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvIG9yIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgLy8gZ2V0IFN1YmplY3RQdWJsaWNLZXlJbmZvXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoYXNuMS52YWxpZGF0ZShvYmosIHB1YmxpY0tleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIC8vIGdldCBvaWRcbiAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gICAgaWYob2lkICE9PSBwa2kub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIFVua25vd24gT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIG9iaiA9IGNhcHR1cmUucnNhUHVibGljS2V5O1xuICB9XG5cbiAgLy8gZ2V0IFJTQSBwYXJhbXNcbiAgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgcnNhUHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQdWJsaWNLZXkuJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gRklYTUU6IGluZWZmaWNpZW50LCBnZXQgYSBCaWdJbnRlZ2VyIHRoYXQgdXNlcyBieXRlIHN0cmluZ3NcbiAgdmFyIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnB1YmxpY0tleU1vZHVsdXMpLnRvSGV4KCk7XG4gIHZhciBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wdWJsaWNLZXlFeHBvbmVudCkudG9IZXgoKTtcblxuICAvLyBzZXQgcHVibGljIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVB1YmxpY0tleShcbiAgICBuZXcgQmlnSW50ZWdlcihuLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZSwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICovXG5wa2kucHVibGljS2V5VG9Bc24xID0gcGtpLnB1YmxpY0tleVRvU3ViamVjdFB1YmxpY0tleUluZm8gPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMucnNhRW5jcnlwdGlvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgXSksXG4gICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgW1xuICAgICAgcGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSlcbiAgICBdKVxuICBdKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBSU0FQdWJsaWNLZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1JTQVB1YmxpY0tleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5uKSksXG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmUpKVxuICBdKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gbSB0aGUgbWVzc2FnZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBidCB0aGUgYmxvY2sgdHlwZSB0byB1c2UsIGkuZS4gZWl0aGVyIDB4MDEgKGZvciBzaWduaW5nKSBvciAweDAyXG4gKiAgICAgICAgICAoZm9yIGVuY3J5cHRpb24pLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhZGRlZCBieXRlIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCkge1xuICB2YXIgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgKi9cbiAgaWYobS5sZW5ndGggPiAoayAtIDExKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyBmb3IgUEtDUyMxIHYxLjUgcGFkZGluZy4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBtLmxlbmd0aDtcbiAgICBlcnJvci5tYXggPSBrIC0gMTE7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvKiBBIGJsb2NrIHR5cGUgQlQsIGEgcGFkZGluZyBzdHJpbmcgUFMsIGFuZCB0aGUgZGF0YSBEIHNoYWxsIGJlXG4gICAgZm9ybWF0dGVkIGludG8gYW4gb2N0ZXQgc3RyaW5nIEVCLCB0aGUgZW5jcnlwdGlvbiBibG9jazpcblxuICAgIEVCID0gMDAgfHwgQlQgfHwgUFMgfHwgMDAgfHwgRFxuXG4gICAgVGhlIGJsb2NrIHR5cGUgQlQgc2hhbGwgYmUgYSBzaW5nbGUgb2N0ZXQgaW5kaWNhdGluZyB0aGUgc3RydWN0dXJlIG9mXG4gICAgdGhlIGVuY3J5cHRpb24gYmxvY2suIEZvciB0aGlzIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50IGl0IHNoYWxsIGhhdmVcbiAgICB2YWx1ZSAwMCwgMDEsIG9yIDAyLiBGb3IgYSBwcml2YXRlLWtleSBvcGVyYXRpb24sIHRoZSBibG9jayB0eXBlXG4gICAgc2hhbGwgYmUgMDAgb3IgMDEuIEZvciBhIHB1YmxpYy1rZXkgb3BlcmF0aW9uLCBpdCBzaGFsbCBiZSAwMi5cblxuICAgIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBzaGFsbCBjb25zaXN0IG9mIGstMy18fER8fCBvY3RldHMuIEZvciBibG9ja1xuICAgIHR5cGUgMDAsIHRoZSBvY3RldHMgc2hhbGwgaGF2ZSB2YWx1ZSAwMDsgZm9yIGJsb2NrIHR5cGUgMDEsIHRoZXlcbiAgICBzaGFsbCBoYXZlIHZhbHVlIEZGOyBhbmQgZm9yIGJsb2NrIHR5cGUgMDIsIHRoZXkgc2hhbGwgYmVcbiAgICBwc2V1ZG9yYW5kb21seSBnZW5lcmF0ZWQgYW5kIG5vbnplcm8uIFRoaXMgbWFrZXMgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBlbmNyeXB0aW9uIGJsb2NrIEVCIGVxdWFsIHRvIGsuICovXG5cbiAgLy8gYnVpbGQgdGhlIGVuY3J5cHRpb24gYmxvY2tcbiAgZWIucHV0Qnl0ZSgweDAwKTtcbiAgZWIucHV0Qnl0ZShidCk7XG5cbiAgLy8gY3JlYXRlIHRoZSBwYWRkaW5nXG4gIHZhciBwYWROdW0gPSBrIC0gMyAtIG0ubGVuZ3RoO1xuICB2YXIgcGFkQnl0ZTtcbiAgLy8gcHJpdmF0ZSBrZXkgb3BcbiAgaWYoYnQgPT09IDB4MDAgfHwgYnQgPT09IDB4MDEpIHtcbiAgICBwYWRCeXRlID0gKGJ0ID09PSAweDAwKSA/IDB4MDAgOiAweEZGO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgZWIucHV0Qnl0ZShwYWRCeXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcHVibGljIGtleSBvcFxuICAgIC8vIHBhZCB3aXRoIHJhbmRvbSBub24temVybyB2YWx1ZXNcbiAgICB3aGlsZShwYWROdW0gPiAwKSB7XG4gICAgICB2YXIgbnVtWmVyb3MgPSAwO1xuICAgICAgdmFyIHBhZEJ5dGVzID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKHBhZE51bSk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFkTnVtOyArK2kpIHtcbiAgICAgICAgcGFkQnl0ZSA9IHBhZEJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmKHBhZEJ5dGUgPT09IDApIHtcbiAgICAgICAgICArK251bVplcm9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGViLnB1dEJ5dGUocGFkQnl0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhZE51bSA9IG51bVplcm9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIHplcm8gZm9sbG93ZWQgYnkgbWVzc2FnZVxuICBlYi5wdXRCeXRlKDB4MDApO1xuICBlYi5wdXRCeXRlcyhtKTtcblxuICByZXR1cm4gZWI7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gZW0gdGhlIG1lc3NhZ2UgdG8gZGVjb2RlLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBhIHB1YmxpYyBrZXksIGZhbHNlIGlmIGl0IGlzIHByaXZhdGUuXG4gKiBAcGFyYW0gbWwgdGhlIG1lc3NhZ2UgbGVuZ3RoLCBpZiBzcGVjaWZpZWQuXG4gKlxuICogQHJldHVybiB0aGUgZGVjb2RlZCBieXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZVBrY3MxX3YxXzUoZW0sIGtleSwgcHViLCBtbCkge1xuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIC8qIEl0IGlzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgb2NjdXJzOlxuXG4gICAgMS4gVGhlIGVuY3J5cHRpb24gYmxvY2sgRUIgY2Fubm90IGJlIHBhcnNlZCB1bmFtYmlndW91c2x5LlxuICAgIDIuIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBjb25zaXN0cyBvZiBmZXdlciB0aGFuIGVpZ2h0IG9jdGV0c1xuICAgICAgb3IgaXMgaW5jb25zaXNlbnQgd2l0aCB0aGUgYmxvY2sgdHlwZSBCVC5cbiAgICAzLiBUaGUgZGVjcnlwdGlvbiBwcm9jZXNzIGlzIGEgcHVibGljLWtleSBvcGVyYXRpb24gYW5kIHRoZSBibG9ja1xuICAgICAgdHlwZSBCVCBpcyBub3QgMDAgb3IgMDEsIG9yIHRoZSBkZWNyeXB0aW9uIHByb2Nlc3MgaXMgYVxuICAgICAgcHJpdmF0ZS1rZXkgb3BlcmF0aW9uIGFuZCB0aGUgYmxvY2sgdHlwZSBpcyBub3QgMDIuXG4gICAqL1xuXG4gIC8vIHBhcnNlIHRoZSBlbmNyeXB0aW9uIGJsb2NrXG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVtKTtcbiAgdmFyIGZpcnN0ID0gZWIuZ2V0Qnl0ZSgpO1xuICB2YXIgYnQgPSBlYi5nZXRCeXRlKCk7XG4gIGlmKGZpcnN0ICE9PSAweDAwIHx8XG4gICAgKHB1YiAmJiBidCAhPT0gMHgwMCAmJiBidCAhPT0gMHgwMSkgfHxcbiAgICAoIXB1YiAmJiBidCAhPSAweDAyKSB8fFxuICAgIChwdWIgJiYgYnQgPT09IDB4MDAgJiYgdHlwZW9mKG1sKSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICB2YXIgcGFkTnVtID0gMDtcbiAgaWYoYnQgPT09IDB4MDApIHtcbiAgICAvLyBjaGVjayBhbGwgcGFkZGluZyBieXRlcyBmb3IgMHgwMFxuICAgIHBhZE51bSA9IGsgLSAzIC0gbWw7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICBpZihlYi5nZXRCeXRlKCkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDEpIHtcbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBieXRlIHRoYXQgaXNuJ3QgMHhGRiwgc2hvdWxkIGJlIGFmdGVyIGFsbCBwYWRkaW5nXG4gICAgcGFkTnVtID0gMDtcbiAgICB3aGlsZShlYi5sZW5ndGgoKSA+IDEpIHtcbiAgICAgIGlmKGViLmdldEJ5dGUoKSAhPT0gMHhGRikge1xuICAgICAgICAtLWViLnJlYWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgKytwYWROdW07XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDIpIHtcbiAgICAvLyBsb29rIGZvciAweDAwIGJ5dGVcbiAgICBwYWROdW0gPSAwO1xuICAgIHdoaWxlKGViLmxlbmd0aCgpID4gMSkge1xuICAgICAgaWYoZWIuZ2V0Qnl0ZSgpID09PSAweDAwKSB7XG4gICAgICAgIC0tZWIucmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BhZE51bTtcbiAgICB9XG4gIH1cblxuICAvLyB6ZXJvIG11c3QgYmUgMHgwMCBhbmQgcGFkTnVtIG11c3QgYmUgKGsgLSAzIC0gbWVzc2FnZSBsZW5ndGgpXG4gIHZhciB6ZXJvID0gZWIuZ2V0Qnl0ZSgpO1xuICBpZih6ZXJvICE9PSAweDAwIHx8IHBhZE51bSAhPT0gKGsgLSAzIC0gZWIubGVuZ3RoKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gYXN5bmNocm9ub3VzbHksIGVpdGhlciBpbiB0aGUgYmFja2dyb3VuZFxuICogdmlhIFdlYiBXb3JrZXJzLCBvciB1c2luZyB0aGUgbWFpbiB0aHJlYWQgYW5kIHNldEltbWVkaWF0ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGtleS1wYWlyIGdlbmVyYXRpb24gc3RhdGUuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb246XG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIsIC0xIHRvIHVzZSBlc3RpbWF0ZWQgY29yZXMgbWludXMgb25lKS5cbiAqICAgICAgICAgIHdvcmtMb2FkIHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgICAgICAgbnVtYmVycyBmb3IgZWFjaCB3ZWIgd29ya2VyIHRvIGNoZWNrIHBlciB3b3JrIGFzc2lnbm1lbnQsXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiAxMDApLlxuICogQHBhcmFtIGNhbGxiYWNrKGVyciwga2V5cGFpcikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9nZW5lcmF0ZUtleVBhaXIoc3RhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgb3B0cyA9IHtcbiAgICBhbGdvcml0aG06IHtcbiAgICAgIG5hbWU6IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdQUklNRUlOQycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHdvcmtlcnM6IG9wdGlvbnMud29ya2VycyB8fCAyLFxuICAgICAgICB3b3JrTG9hZDogb3B0aW9ucy53b3JrTG9hZCB8fCAxMDAsXG4gICAgICAgIHdvcmtlclNjcmlwdDogb3B0aW9ucy53b3JrZXJTY3JpcHRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmKCdwcm5nJyBpbiBvcHRpb25zKSB7XG4gICAgb3B0cy5wcm5nID0gb3B0aW9ucy5wcm5nO1xuICB9XG5cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyBmaW5kIHAgYW5kIHRoZW4gcSAoZG9uZSBpbiBzZXJpZXMgdG8gc2ltcGxpZnkpXG4gICAgZ2V0UHJpbWUoc3RhdGUucEJpdHMsIGZ1bmN0aW9uKGVyciwgbnVtKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wID0gbnVtO1xuICAgICAgaWYoc3RhdGUucSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmluaXNoKGVyciwgc3RhdGUucSk7XG4gICAgICB9XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByaW1lKGJpdHMsIGNhbGxiYWNrKSB7XG4gICAgZm9yZ2UucHJpbWUuZ2VuZXJhdGVQcm9iYWJsZVByaW1lKGJpdHMsIG9wdHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaChlcnIsIG51bSkge1xuICAgIGlmKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgLy8gc2V0IHFcbiAgICBzdGF0ZS5xID0gbnVtO1xuXG4gICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICBpZihzdGF0ZS5wLmNvbXBhcmVUbyhzdGF0ZS5xKSA8IDApIHtcbiAgICAgIHZhciB0bXAgPSBzdGF0ZS5wO1xuICAgICAgc3RhdGUucCA9IHN0YXRlLnE7XG4gICAgICBzdGF0ZS5xID0gdG1wO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBwIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucCA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBxIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICBzdGF0ZS5wMSA9IHN0YXRlLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgIHN0YXRlLnExID0gc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuXG4gICAgLy8gZW5zdXJlIGUgYW5kIHBoaSBhcmUgY29wcmltZVxuICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgLy8gcGhpIGFuZCBlIGFyZW4ndCBjb3ByaW1lLCBzbyBnZW5lcmF0ZSBhIG5ldyBwIGFuZCBxXG4gICAgICBzdGF0ZS5wID0gc3RhdGUucSA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgc3RhdGUubiA9IHN0YXRlLnAubXVsdGlwbHkoc3RhdGUucSk7XG4gICAgaWYoc3RhdGUubi5iaXRMZW5ndGgoKSAhPT0gc3RhdGUuYml0cykge1xuICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgIHN0YXRlLnEgPSBudWxsO1xuICAgICAgZ2V0UHJpbWUoc3RhdGUucUJpdHMsIGZpbmlzaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGtleXNcbiAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgIHN0YXRlLmtleXMgPSB7XG4gICAgICBwcml2YXRlS2V5OiBwa2kucnNhLnNldFByaXZhdGVLZXkoXG4gICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgIGQubW9kKHN0YXRlLnAxKSwgZC5tb2Qoc3RhdGUucTEpLFxuICAgICAgICBzdGF0ZS5xLm1vZEludmVyc2Uoc3RhdGUucCkpLFxuICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgIH07XG5cbiAgICBjYWxsYmFjayhudWxsLCBzdGF0ZS5rZXlzKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcG9zaXRpdmUgQmlnSW50ZWdlciBpbnRvIDIncy1jb21wbGVtZW50IGJpZy1lbmRpYW4gYnl0ZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJpZyBpbnRlZ2VyIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9iblRvQnl0ZXMoYikge1xuICAvLyBwcmVwZW5kIDB4MDAgaWYgZmlyc3QgYnl0ZSA+PSAweDgwXG4gIHZhciBoZXggPSBiLnRvU3RyaW5nKDE2KTtcbiAgaWYoaGV4WzBdID49ICc4Jykge1xuICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gIH1cbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGhleCk7XG5cbiAgLy8gZW5zdXJlIGludGVnZXIgaXMgbWluaW1hbGx5LWVuY29kZWRcbiAgaWYoYnl0ZXMubGVuZ3RoID4gMSAmJlxuICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICgoYnl0ZXMuY2hhckNvZGVBdCgwKSA9PT0gMCAmJlxuICAgIChieXRlcy5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDApIHx8XG4gICAgLy8gbGVhZGluZyAweEZGIGZvciBuZWdhdGl2ZSBpbnRlZ2VyXG4gICAgKGJ5dGVzLmNoYXJDb2RlQXQoMCkgPT09IDB4RkYgJiZcbiAgICAoYnl0ZXMuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICByZXR1cm4gYnl0ZXMuc3Vic3RyKDEpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgTWlsbGVyLVJhYmluIHRlc3RzIHRvIGdlbmVyYXRlIGFcbiAqIHByaW1lIHdpdGggYW4gZXJyb3IgcHJvYmFiaWxpdHkgb2YgKDEvMileODAuXG4gKlxuICogU2VlIEhhbmRib29rIG9mIEFwcGxpZWQgQ3J5cHRvZ3JhcGh5IENoYXB0ZXIgNCwgVGFibGUgNC40LlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gX2dldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgU3VidGxlQ3J5cHRvIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gZm4gdGhlIGZlYXR1cmUgKGZ1bmN0aW9uKSB0byBkZXRlY3QuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGRldGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9kZXRlY3RTdWJ0bGVDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvLnN1YnRsZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LmNyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgZGVwcmVjYXRlZCBNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIG91dGRhdGVkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgdXNlZCBhZnRlclxuICogY2hlY2tpbmcgZm9yIHRoZSBtb2Rlcm4sIHN0YW5kYXJkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8gPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gX2ludFRvVWludDhBcnJheSh4KSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4LnRvU3RyaW5nKDE2KSk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIF9wcml2YXRlS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGFsZ29yaXRobSBcIicgKyBqd2sua3R5ICsgJ1wiOyBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLm4pLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLnApLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2sucSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcCksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5xaSkpO1xufVxuXG5mdW5jdGlvbiBfcHVibGljS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2subiksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5lKSk7XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRUb0JpZ0ludChiNjQpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS51dGlsLmRlY29kZTY0KGI2NCkpLCAxNik7XG59XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQWR2YW5jZWQgRW5jcnlwdGlvbiBTdGFuZGFyZCAoQUVTKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBwdWJsaWMgZG9tYWluIGxpYnJhcnkgJ2pzY3J5cHRvJyB3aGljaFxuICogd2FzIHdyaXR0ZW4gYnk6XG4gKlxuICogRW1pbHkgU3RhcmsgKGVzdGFya0BzdGFuZm9yZC5lZHUpXG4gKiBNaWtlIEhhbWJ1cmcgKG1oYW1idXJnQHN0YW5mb3JkLmVkdSlcbiAqIERhbiBCb25laCAoZGFib0Bjcy5zdGFuZm9yZC5lZHUpXG4gKlxuICogUGFydHMgb2YgdGhpcyBjb2RlIGFyZSBiYXNlZCBvbiB0aGUgT3BlblNTTCBpbXBsZW1lbnRhdGlvbiBvZiBBRVM6XG4gKiBodHRwOi8vd3d3Lm9wZW5zc2wub3JnXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIEFFUyBBUEkgKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYWVzID0gZm9yZ2UuYWVzIHx8IHt9O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKiBjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZGVjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBRVMgY2lwaGVyIGFsZ29yaXRobSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBtb2RlIGZhY3RvcnkgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybiB0aGUgQUVTIGFsZ29yaXRobSBvYmplY3QuXG4gKi9cbmZvcmdlLmFlcy5BbGdvcml0aG0gPSBmdW5jdGlvbihuYW1lLCBtb2RlKSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5uYW1lID0gbmFtZTtcbiAgc2VsZi5tb2RlID0gbmV3IG1vZGUoe1xuICAgIGJsb2NrU2l6ZTogMTYsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX3csIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl93LCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIEFFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5hZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdG1wO1xuXG4gIC8qIE5vdGU6IFRoZSBrZXkgbWF5IGJlIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYSBieXRlXG4gICAgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMuIElmIHRoZSBrZXkgaXMgaW4gYnl0ZXMsIHRoZW5cbiAgICBpdCBtdXN0IGJlIDE2LCAyNCwgb3IgMzIgYnl0ZXMgaW4gbGVuZ3RoLiBJZiBpdCBpcyBpbiAzMi1iaXRcbiAgICBpbnRlZ2VycywgaXQgbXVzdCBiZSA0LCA2LCBvciA4IGludGVnZXJzIGxvbmcuICovXG5cbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgaW50ZWdlciBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdG1wID0ga2V5O1xuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAga2V5LnB1dEJ5dGUodG1wW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb252ZXJ0IGtleSBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSkge1xuICAgIHRtcCA9IGtleTtcbiAgICBrZXkgPSBbXTtcblxuICAgIC8vIGtleSBsZW5ndGhzIG9mIDE2LCAyNCwgMzIgYnl0ZXMgYWxsb3dlZFxuICAgIHZhciBsZW4gPSB0bXAubGVuZ3RoKCk7XG4gICAgaWYobGVuID09PSAxNiB8fCBsZW4gPT09IDI0IHx8IGxlbiA9PT0gMzIpIHtcbiAgICAgIGxlbiA9IGxlbiA+Pj4gMjtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBrZXkucHVzaCh0bXAuZ2V0SW50MzIoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2V5IG11c3QgYmUgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzIGJ5IG5vd1xuICBpZighZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgfHxcbiAgICAhKGtleS5sZW5ndGggPT09IDQgfHwga2V5Lmxlbmd0aCA9PT0gNiB8fCBrZXkubGVuZ3RoID09PSA4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgcGFyYW1ldGVyLicpO1xuICB9XG5cbiAgLy8gZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYWx3YXlzIHVzZWQgZm9yIHRoZXNlIG1vZGVzXG4gIHZhciBtb2RlID0gdGhpcy5tb2RlLm5hbWU7XG4gIHZhciBlbmNyeXB0T3AgPSAoWydDRkInLCAnT0ZCJywgJ0NUUicsICdHQ00nXS5pbmRleE9mKG1vZGUpICE9PSAtMSk7XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvblxuICB0aGlzLl93ID0gX2V4cGFuZEtleShrZXksIG9wdGlvbnMuZGVjcnlwdCAmJiAhZW5jcnlwdE9wKTtcbiAgdGhpcy5faW5pdCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEV4cGFuZHMgYSBrZXkuIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byBleHBhbmQsIGFzIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZXhwYW5kIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXkuXG4gKi9cbmZvcmdlLmFlcy5fZXhwYW5kS2V5ID0gZnVuY3Rpb24oa2V5LCBkZWNyeXB0KSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJldHVybiBfZXhwYW5kS2V5KGtleSwgZGVjcnlwdCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2suIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIHcgdGhlIGV4cGFuZGVkIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaW5wdXQgYW4gYXJyYXkgb2YgYmxvY2stc2l6ZSAzMi1iaXQgd29yZHMuXG4gKiBAcGFyYW0gb3V0cHV0IGFuIGFycmF5IG9mIGJsb2NrLXNpemUgMzItYml0IHdvcmRzLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0LCBmYWxzZSB0byBlbmNyeXB0LlxuICovXG5mb3JnZS5hZXMuX3VwZGF0ZUJsb2NrID0gX3VwZGF0ZUJsb2NrO1xuXG4vKiogUmVnaXN0ZXIgQUVTIGFsZ29yaXRobXMgKiovXG5cbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNCQycsIGZvcmdlLmNpcGhlci5tb2Rlcy5jYmMpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1DRkInLCBmb3JnZS5jaXBoZXIubW9kZXMuY2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNUUicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jdHIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1HQ00nLCBmb3JnZS5jaXBoZXIubW9kZXMuZ2NtKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuYWVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogQUVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgaW5pdCA9IGZhbHNlOyAvLyBub3QgeWV0IGluaXRpYWxpemVkXG52YXIgTmIgPSA0OyAgICAgICAvLyBudW1iZXIgb2Ygd29yZHMgY29tcHJpc2luZyB0aGUgc3RhdGUgKEFFUyA9IDQpXG52YXIgc2JveDsgICAgICAgICAvLyBub24tbGluZWFyIHN1YnN0aXR1dGlvbiB0YWJsZSB1c2VkIGluIGtleSBleHBhbnNpb25cbnZhciBpc2JveDsgICAgICAgIC8vIGludmVyc2lvbiBvZiBzYm94XG52YXIgcmNvbjsgICAgICAgICAvLyByb3VuZCBjb25zdGFudCB3b3JkIGFycmF5XG52YXIgbWl4OyAgICAgICAgICAvLyBtaXgtY29sdW1ucyB0YWJsZVxudmFyIGltaXg7ICAgICAgICAgLy8gaW52ZXJzZSBtaXgtY29sdW1ucyB0YWJsZVxuXG4vKipcbiAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uLCBpZTogcHJlY29tcHV0ZXMgdGFibGVzIHRvIG9wdGltaXplIGZvciBzcGVlZC5cbiAqXG4gKiBPbmUgd2F5IHRvIHVuZGVyc3RhbmQgaG93IEFFUyB3b3JrcyBpcyB0byBpbWFnaW5lIHRoYXQgJ2FkZGl0aW9uJyBhbmRcbiAqICdtdWx0aXBsaWNhdGlvbicgYXJlIGludGVyZmFjZXMgdGhhdCByZXF1aXJlIGNlcnRhaW4gbWF0aGVtYXRpY2FsXG4gKiBwcm9wZXJ0aWVzIHRvIGhvbGQgdHJ1ZSAoaWU6IHRoZXkgYXJlIGFzc29jaWF0aXZlKSBidXQgdGhleSBtaWdodCBoYXZlXG4gKiBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIGFuZCBwcm9kdWNlIGRpZmZlcmVudCBraW5kcyBvZiByZXN1bHRzIC4uLlxuICogcHJvdmlkZWQgdGhhdCB0aGVpciBtYXRoZW1hdGljYWwgcHJvcGVydGllcyByZW1haW4gdHJ1ZS4gQUVTIGRlZmluZXNcbiAqIGl0cyBvd24gbWV0aG9kcyBvZiBhZGRpdGlvbiBhbmQgbXVsdGlwbGljYXRpb24gYnV0IGtlZXBzIHNvbWUgaW1wb3J0YW50XG4gKiBwcm9wZXJ0aWVzIHRoZSBzYW1lLCBpZTogYXNzb2NpYXRpdml0eSBhbmQgZGlzdHJpYnV0aXZpdHkuIFRoZVxuICogZXhwbGFuYXRpb24gYmVsb3cgdHJpZXMgdG8gc2hlZCBzb21lIGxpZ2h0IG9uIGhvdyBBRVMgZGVmaW5lcyBhZGRpdGlvblxuICogYW5kIG11bHRpcGxpY2F0aW9uIG9mIGJ5dGVzIGFuZCAzMi1iaXQgd29yZHMgaW4gb3JkZXIgdG8gcGVyZm9ybSBpdHNcbiAqIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24gYWxnb3JpdGhtcy5cbiAqXG4gKiBUaGUgYmFzaWNzOlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHZpZXdzIGJ5dGVzIGFzIGJpbmFyeSByZXByZXNlbnRhdGlvbnMgb2YgcG9seW5vbWlhbHNcbiAqIHRoYXQgaGF2ZSBlaXRoZXIgMSBvciAwIGFzIHRoZSBjb2VmZmljaWVudHMuIEl0IGRlZmluZXMgdGhlIGFkZGl0aW9uXG4gKiBvciBzdWJ0cmFjdGlvbiBvZiB0d28gYnl0ZXMgYXMgdGhlIFhPUiBvcGVyYXRpb24uIEl0IGFsc28gZGVmaW5lcyB0aGVcbiAqIG11bHRpcGxpY2F0aW9uIG9mIHR3byBieXRlcyBhcyBhIGZpbml0ZSBmaWVsZCByZWZlcnJlZCB0byBhcyBHRigyXjgpXG4gKiAoTm90ZTogJ0dGJyBtZWFucyBcIkdhbG9pcyBGaWVsZFwiIHdoaWNoIGlzIGEgZmllbGQgdGhhdCBjb250YWlucyBhIGZpbml0ZVxuICogbnVtYmVyIG9mIGVsZW1lbnRzIHNvIEdGKDJeOCkgaGFzIDI1NiBlbGVtZW50cykuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IGFueSB0d28gYnl0ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGJpbmFyeSBwb2x5bm9taWFscztcbiAqIHdoZW4gdGhleSBtdWx0aXBsaWVkIHRvZ2V0aGVyIGFuZCBtb2R1bGFybHkgcmVkdWNlZCBieSBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiB0aGUgOHRoIGRlZ3JlZSwgdGhlIHJlc3VsdHMgYXJlIHRoZSBmaWVsZCBHRigyXjgpLiBUaGVcbiAqIHNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgdGhhdCBBRVMgdXNlcyBpbiBoZXhhZGVjaW1hbCBpcyAweDExYi5cbiAqIFRoaXMgbXVsdGlwbGljYXRpb24gaXMgYXNzb2NpYXRpdmUgd2l0aCAweDAxIGFzIHRoZSBpZGVudGl0eTpcbiAqXG4gKiAoYiAqIDB4MDEgPSBHRihiLCAweDAxKSA9IGIpLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gR0YoYiwgMHgwMikgY2FuIGJlIHBlcmZvcm1lZCBhdCB0aGUgYnl0ZSBsZXZlbCBieSBsZWZ0XG4gKiBzaGlmdGluZyBiIG9uY2UgYW5kIHRoZW4gWE9SJ2luZyBpdCAodG8gcGVyZm9ybSB0aGUgbW9kdWxhciByZWR1Y3Rpb24pXG4gKiB3aXRoIDB4MTFiIGlmIGIgaXMgPj0gMTI4LiBSZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB0aGUgbXVsdGlwbGljYXRpb25cbiAqIG9mIDB4MDIgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IHRoZSBtdWx0aXBsaWNhdGlvbiBvZiBhbnkgdHdvIGJ5dGVzLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgbXVsdGlwbHlpbmcgMHg1NyBhbmQgMHgxMywgZGVub3RlZCBhcyBHRigweDU3LCAweDEzKSwgY2FuXG4gKiBiZSBwZXJmb3JtZWQgYnkgZmFjdG9yaW5nIDB4MTMgaW50byAweDAxLCAweDAyLCBhbmQgMHgxMC4gVGhlbiB0aGVzZVxuICogZmFjdG9ycyBjYW4gZWFjaCBiZSBtdWx0aXBsaWVkIGJ5IDB4NTcgYW5kIHRoZW4gYWRkZWQgdG9nZXRoZXIuIFRvIGRvXG4gKiB0aGUgbXVsdGlwbGljYXRpb24sIHZhbHVlcyBmb3IgMHg1NyBtdWx0aXBsaWVkIGJ5IGVhY2ggb2YgdGhlc2UgMyBmYWN0b3JzXG4gKiBjYW4gYmUgcHJlY29tcHV0ZWQgYW5kIHN0b3JlZCBpbiBhIHRhYmxlLiBUbyBhZGQgdGhlbSwgdGhlIHZhbHVlcyBmcm9tXG4gKiB0aGUgdGFibGUgYXJlIFhPUidkIHRvZ2V0aGVyLlxuICpcbiAqIEFFUyBhbHNvIGRlZmluZXMgYWRkaXRpb24gYW5kIG11bHRpcGxpY2F0aW9uIG9mIHdvcmRzLCB0aGF0IGlzIDQtYnl0ZVxuICogbnVtYmVycyByZXByZXNlbnRlZCBhcyBwb2x5bm9taWFscyBvZiAzIGRlZ3JlZXMgd2hlcmUgdGhlIGNvZWZmaWNpZW50c1xuICogYXJlIHRoZSB2YWx1ZXMgb2YgdGhlIGJ5dGVzLlxuICpcbiAqIFRoZSB3b3JkIFthMCwgYTEsIGEyLCBhM10gaXMgYSBwb2x5bm9taWFsIGEzeF4zICsgYTJ4XjIgKyBhMXggKyBhMC5cbiAqXG4gKiBBZGRpdGlvbiBpcyBwZXJmb3JtZWQgYnkgWE9SJ2luZyBsaWtlIHBvd2VycyBvZiB4LiBNdWx0aXBsaWNhdGlvblxuICogaXMgcGVyZm9ybWVkIGluIHR3byBzdGVwcywgdGhlIGZpcnN0IGlzIGFuIGFsZ2VicmlhYyBleHBhbnNpb24gYXNcbiAqIHlvdSB3b3VsZCBkbyBub3JtYWxseSAod2hlcmUgYWRkaXRpb24gaXMgWE9SKS4gQnV0IHRoZSByZXN1bHQgaXNcbiAqIGEgcG9seW5vbWlhbCBsYXJnZXIgdGhhbiAzIGRlZ3JlZXMgYW5kIHRodXMgaXQgY2Fubm90IGZpdCBpbiBhIHdvcmQuIFNvXG4gKiBuZXh0IHRoZSByZXN1bHQgaXMgbW9kdWxhcmx5IHJlZHVjZWQgYnkgYW4gQUVTLXNwZWNpZmljIHBvbHlub21pYWwgb2ZcbiAqIGRlZ3JlZSA0IHdoaWNoIHdpbGwgYWx3YXlzIHByb2R1Y2UgYSBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiA0IGRlZ3JlZXNcbiAqIHN1Y2ggdGhhdCBpdCB3aWxsIGZpdCBpbiBhIHdvcmQuIEluIEFFUywgdGhpcyBwb2x5bm9taWFsIGlzIHheNCArIDEuXG4gKlxuICogVGhlIG1vZHVsYXIgcHJvZHVjdCBvZiB0d28gcG9seW5vbWlhbHMgJ2EnIGFuZCAnYicgaXMgdGh1czpcbiAqXG4gKiBkKHgpID0gZDN4XjMgKyBkMnheMiArIGQxeCArIGQwXG4gKiB3aXRoXG4gKiBkMCA9IEdGKGEwLCBiMCkgXiBHRihhMywgYjEpIF4gR0YoYTIsIGIyKSBeIEdGKGExLCBiMylcbiAqIGQxID0gR0YoYTEsIGIwKSBeIEdGKGEwLCBiMSkgXiBHRihhMywgYjIpIF4gR0YoYTIsIGIzKVxuICogZDIgPSBHRihhMiwgYjApIF4gR0YoYTEsIGIxKSBeIEdGKGEwLCBiMikgXiBHRihhMywgYjMpXG4gKiBkMyA9IEdGKGEzLCBiMCkgXiBHRihhMiwgYjEpIF4gR0YoYTEsIGIyKSBeIEdGKGEwLCBiMylcbiAqXG4gKiBBcyBhIG1hdHJpeDpcbiAqXG4gKiBbZDBdID0gW2EwIGEzIGEyIGExXVtiMF1cbiAqIFtkMV0gICBbYTEgYTAgYTMgYTJdW2IxXVxuICogW2QyXSAgIFthMiBhMSBhMCBhM11bYjJdXG4gKiBbZDNdICAgW2EzIGEyIGExIGEwXVtiM11cbiAqXG4gKiBTcGVjaWFsIHBvbHlub21pYWxzIGRlZmluZWQgYnkgQUVTICgweDAyID09IHswMn0pOlxuICogYSh4KSAgICA9IHswM314XjMgKyB7MDF9eF4yICsgezAxfXggKyB7MDJ9XG4gKiBhXi0xKHgpID0gezBifXheMyArIHswZH14XjIgKyB7MDl9eCArIHswZX0uXG4gKlxuICogVGhlc2UgcG9seW5vbWlhbHMgYXJlIHVzZWQgaW4gdGhlIE1peENvbHVtbnMoKSBhbmQgSW52ZXJzZU1peENvbHVtbnMoKVxuICogb3BlcmF0aW9ucywgcmVzcGVjdGl2ZWx5LCB0byBjYXVzZSBlYWNoIGVsZW1lbnQgaW4gdGhlIHN0YXRlIHRvIGFmZmVjdFxuICogdGhlIG91dHB1dCAocmVmZXJyZWQgdG8gYXMgZGlmZnVzaW5nKS5cbiAqXG4gKiBSb3RXb3JkKCkgdXNlczogYTAgPSBhMSA9IGEyID0gezAwfSBhbmQgYTMgPSB7MDF9LCB3aGljaCBpcyB0aGVcbiAqIHBvbHlub21pYWwgeDMuXG4gKlxuICogVGhlIFNoaWZ0Um93cygpIG1ldGhvZCBtb2RpZmllcyB0aGUgbGFzdCAzIHJvd3MgaW4gdGhlIHN0YXRlICh3aGVyZVxuICogdGhlIHN0YXRlIGlzIDQgd29yZHMgd2l0aCA0IGJ5dGVzIHBlciB3b3JkKSBieSBzaGlmdGluZyBieXRlcyBjeWNsaWNhbGx5LlxuICogVGhlIDFzdCBieXRlIGluIHRoZSBzZWNvbmQgcm93IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHJvdy4gVGhlIDFzdFxuICogYW5kIDJuZCBieXRlcyBpbiB0aGUgdGhpcmQgcm93IGFyZSBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoZSByb3cuIFRoZSAxc3QsXG4gKiAybmQsIGFuZCAzcmQgYnl0ZXMgYXJlIG1vdmVkIGluIHRoZSBmb3VydGggcm93LlxuICpcbiAqIE1vcmUgZGV0YWlscyBvbiBob3cgQUVTIGFyaXRobWV0aWMgd29ya3M6XG4gKlxuICogSW4gdGhlIHBvbHlub21pYWwgcmVwcmVzZW50YXRpb24gb2YgYmluYXJ5IG51bWJlcnMsIFhPUiBwZXJmb3JtcyBhZGRpdGlvblxuICogYW5kIHN1YnRyYWN0aW9uIGFuZCBtdWx0aXBsaWNhdGlvbiBpbiBHRigyXjgpIGRlbm90ZWQgYXMgR0YoYSwgYilcbiAqIGNvcnJlc3BvbmRzIHdpdGggdGhlIG11bHRpcGxpY2F0aW9uIG9mIHBvbHlub21pYWxzIG1vZHVsbyBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiBkZWdyZWUgOC4gSW4gb3RoZXIgd29yZHMsIGZvciBBRVMsIEdGKGEsIGIpIHdpbGwgbXVsdGlwbHlcbiAqIHBvbHlub21pYWwgJ2EnIHdpdGggcG9seW5vbWlhbCAnYicgYW5kIHRoZW4gZG8gYSBtb2R1bGFyIHJlZHVjdGlvbiBieVxuICogYW4gQUVTLXNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgb2YgZGVncmVlIDguXG4gKlxuICogQSBwb2x5bm9taWFsIGlzIGlycmVkdWNpYmxlIGlmIGl0cyBvbmx5IGRpdmlzb3JzIGFyZSBvbmUgYW5kIGl0c2VsZi4gRm9yXG4gKiB0aGUgQUVTIGFsZ29yaXRobSwgdGhpcyBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIGlzOlxuICpcbiAqIG0oeCkgPSB4XjggKyB4XjQgKyB4XjMgKyB4ICsgMSxcbiAqXG4gKiBvciB7MDF9ezFifSBpbiBoZXhhZGVjaW1hbCBub3RhdGlvbiwgd2hlcmUgZWFjaCBjb2VmZmljaWVudCBpcyBhIGJpdDpcbiAqIDEwMDAxMTAxMSA9IDI4MyA9IDB4MTFiLlxuICpcbiAqIEZvciBleGFtcGxlLCBHRigweDU3LCAweDgzKSA9IDB4YzEgYmVjYXVzZVxuICpcbiAqIDB4NTcgPSA4NyAgPSAwMTAxMDExMSA9IHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiAweDg1ID0gMTMxID0gMTAwMDAxMDEgPSB4XjcgKyB4ICsgMVxuICpcbiAqICh4XjYgKyB4XjQgKyB4XjIgKyB4ICsgMSkgKiAoeF43ICsgeCArIDEpXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNyArXG4gKiAgICB4XjcgKyB4XjUgKyB4XjMgKyB4XjIgKyB4ICtcbiAqICAgIHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNiArIHheNSArIHheNCArIHheMyArIDEgPSB5XG4gKiAgICB5IG1vZHVsbyAoeF44ICsgeF40ICsgeF4zICsgeCArIDEpXG4gKiA9ICB4XjcgKyB4XjYgKyAxLlxuICpcbiAqIFRoZSBtb2R1bGFyIHJlZHVjdGlvbiBieSBtKHgpIGd1YXJhbnRlZXMgdGhlIHJlc3VsdCB3aWxsIGJlIGEgYmluYXJ5XG4gKiBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiBkZWdyZWUgOCwgc28gdGhhdCBpdCBjYW4gZml0IGluIGEgYnl0ZS5cbiAqXG4gKiBUaGUgb3BlcmF0aW9uIHRvIG11bHRpcGx5IGEgYmluYXJ5IHBvbHlub21pYWwgYiB3aXRoIHggKHRoZSBwb2x5bm9taWFsXG4gKiB4IGluIGJpbmFyeSByZXByZXNlbnRhdGlvbiBpcyAwMDAwMDAxMCkgaXM6XG4gKlxuICogYl83eF44ICsgYl82eF43ICsgYl81eF42ICsgYl80eF41ICsgYl8zeF40ICsgYl8yeF4zICsgYl8xeF4yICsgYl8weF4xXG4gKlxuICogVG8gZ2V0IEdGKGIsIHgpIHdlIG11c3QgcmVkdWNlIHRoYXQgYnkgbSh4KS4gSWYgYl83IGlzIDAgKHRoYXQgaXMgdGhlXG4gKiBtb3N0IHNpZ25pZmljYW50IGJpdCBpcyAwIGluIGIpIHRoZW4gdGhlIHJlc3VsdCBpcyBhbHJlYWR5IHJlZHVjZWQuIElmXG4gKiBpdCBpcyAxLCB0aGVuIHdlIGNhbiByZWR1Y2UgaXQgYnkgc3VidHJhY3RpbmcgbSh4KSB2aWEgYW4gWE9SLlxuICpcbiAqIEl0IGZvbGxvd3MgdGhhdCBtdWx0aXBsaWNhdGlvbiBieSB4ICgwMDAwMDAxMCBvciAweDAyKSBjYW4gYmUgaW1wbGVtZW50ZWRcbiAqIGJ5IHBlcmZvcm1pbmcgYSBsZWZ0IHNoaWZ0IGZvbGxvd2VkIGJ5IGEgY29uZGl0aW9uYWwgYml0d2lzZSBYT1Igd2l0aFxuICogMHgxYi4gVGhpcyBvcGVyYXRpb24gb24gYnl0ZXMgaXMgZGVub3RlZCBieSB4dGltZSgpLiBNdWx0aXBsaWNhdGlvbiBieVxuICogaGlnaGVyIHBvd2VycyBvZiB4IGNhbiBiZSBpbXBsZW1lbnRlZCBieSByZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB4dGltZSgpLlxuICpcbiAqIEJ5IGFkZGluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cywgbXVsdGlwbGljYXRpb24gYnkgYW55IGNvbnN0YW50IGNhbiBiZVxuICogaW1wbGVtZW50ZWQuIEZvciBpbnN0YW5jZTpcbiAqXG4gKiBHRigweDU3LCAweDEzKSA9IDB4ZmUgYmVjYXVzZTpcbiAqXG4gKiB4dGltZShiKSA9IChiICYgMTI4KSA/IChiIDw8IDEgXiAweDExYikgOiAoYiA8PCAxKVxuICpcbiAqIE5vdGU6IFdlIFhPUiB3aXRoIDB4MTFiIGluc3RlYWQgb2YgMHgxYiBiZWNhdXNlIGluIGphdmFzY3JpcHQgb3VyXG4gKiBkYXRhdHlwZSBmb3IgYiBjYW4gYmUgbGFyZ2VyIHRoYW4gMSBieXRlLCBzbyBhIGxlZnQgc2hpZnQgd2lsbCBub3RcbiAqIGF1dG9tYXRpY2FsbHkgZWxpbWluYXRlIGJpdHMgdGhhdCBvdmVyZmxvdyBhIGJ5dGUgLi4uIGJ5IFhPUidpbmcgdGhlXG4gKiBvdmVyZmxvdyBiaXQgd2l0aCAxICh0aGUgZXh0cmEgb25lIGZyb20gMHgxMWIpIHdlIHplcm8gaXQgb3V0LlxuICpcbiAqIEdGKDB4NTcsIDB4MDIpID0geHRpbWUoMHg1NykgPSAweGFlXG4gKiBHRigweDU3LCAweDA0KSA9IHh0aW1lKDB4YWUpID0gMHg0N1xuICogR0YoMHg1NywgMHgwOCkgPSB4dGltZSgweDQ3KSA9IDB4OGVcbiAqIEdGKDB4NTcsIDB4MTApID0geHRpbWUoMHg4ZSkgPSAweDA3XG4gKlxuICogR0YoMHg1NywgMHgxMykgPSBHRigweDU3LCAoMHgwMSBeIDB4MDIgXiAweDEwKSlcbiAqXG4gKiBBbmQgYnkgdGhlIGRpc3RyaWJ1dGl2ZSBwcm9wZXJ0eSAoc2luY2UgWE9SIGlzIGFkZGl0aW9uIGFuZCBHRigpIGlzXG4gKiBtdWx0aXBsaWNhdGlvbik6XG4gKlxuICogPSBHRigweDU3LCAweDAxKSBeIEdGKDB4NTcsIDB4MDIpIF4gR0YoMHg1NywgMHgxMClcbiAqID0gMHg1NyBeIDB4YWUgXiAweDA3XG4gKiA9IDB4ZmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gIGluaXQgPSB0cnVlO1xuXG4gIC8qIFBvcHVsYXRlIHRoZSBSY29uIHRhYmxlLiBUaGVzZSBhcmUgdGhlIHZhbHVlcyBnaXZlbiBieVxuICAgIFt4XihpLTEpLHswMH0sezAwfSx7MDB9XSB3aGVyZSB4XihpLTEpIGFyZSBwb3dlcnMgb2YgeCAoYW5kIHggPSAweDAyKVxuICAgIGluIHRoZSBmaWVsZCBvZiBHRigyXjgpLCB3aGVyZSBpIHN0YXJ0cyBhdCAxLlxuXG4gICAgcmNvblswXSA9IFsweDAwLCAweDAwLCAweDAwLCAweDAwXVxuICAgIHJjb25bMV0gPSBbMHgwMSwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMS0xKSA9IDJeMCA9IDFcbiAgICByY29uWzJdID0gWzB4MDIsIDB4MDAsIDB4MDAsIDB4MDBdIDJeKDItMSkgPSAyXjEgPSAyXG4gICAgLi4uXG4gICAgcmNvbls5XSAgPSBbMHgxQiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oOS0xKSAgPSAyXjggPSAweDFCXG4gICAgcmNvblsxMF0gPSBbMHgzNiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMTAtMSkgPSAyXjkgPSAweDM2XG5cbiAgICBXZSBvbmx5IHN0b3JlIHRoZSBmaXJzdCBieXRlIGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgb25lIHVzZWQuXG4gICovXG4gIHJjb24gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxQiwgMHgzNl07XG5cbiAgLy8gY29tcHV0ZSB4dGltZSB0YWJsZSB3aGljaCBtYXBzIGkgb250byBHRihpLCAweDAyKVxuICB2YXIgeHRpbWUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgeHRpbWVbaV0gPSBpIDw8IDE7XG4gICAgeHRpbWVbaSArIDEyOF0gPSAoaSArIDEyOCkgPDwgMSBeIDB4MTFCO1xuICB9XG5cbiAgLy8gY29tcHV0ZSBhbGwgb3RoZXIgdGFibGVzXG4gIHNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgaXNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgbWl4ID0gbmV3IEFycmF5KDQpO1xuICBpbWl4ID0gbmV3IEFycmF5KDQpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgbWl4W2ldID0gbmV3IEFycmF5KDI1Nik7XG4gICAgaW1peFtpXSA9IG5ldyBBcnJheSgyNTYpO1xuICB9XG4gIHZhciBlID0gMCwgZWkgPSAwLCBlMiwgZTQsIGU4LCBzeCwgc3gyLCBtZSwgaW1lO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAvKiBXZSBuZWVkIHRvIGdlbmVyYXRlIHRoZSBTdWJCeXRlcygpIHNib3ggYW5kIGlzYm94IHRhYmxlcyBzbyB0aGF0XG4gICAgICB3ZSBjYW4gcGVyZm9ybSBieXRlIHN1YnN0aXR1dGlvbnMuIFRoaXMgcmVxdWlyZXMgdXMgdG8gdHJhdmVyc2VcbiAgICAgIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gR0YsIGZpbmQgdGhlaXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZXMsXG4gICAgICBhbmQgYXBwbHkgdG8gZWFjaCB0aGUgZm9sbG93aW5nIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjpcblxuICAgICAgYmknID0gYmkgXiBiKGkgKyA0KSBtb2QgOCBeIGIoaSArIDUpIG1vZCA4IF4gYihpICsgNikgbW9kIDggXlxuICAgICAgICAgICAgYihpICsgNykgbW9kIDggXiBjaVxuICAgICAgZm9yIDAgPD0gaSA8IDgsIHdoZXJlIGJpIGlzIHRoZSBpdGggYml0IG9mIHRoZSBieXRlLCBhbmQgY2kgaXMgdGhlXG4gICAgICBpdGggYml0IG9mIGEgYnl0ZSBjIHdpdGggdGhlIHZhbHVlIHs2M30gb3IgezAxMTAwMDExfS5cblxuICAgICAgSXQgaXMgcG9zc2libGUgdG8gdHJhdmVyc2UgZXZlcnkgcG9zc2libGUgdmFsdWUgaW4gYSBHYWxvaXMgZmllbGRcbiAgICAgIHVzaW5nIHdoYXQgaXMgcmVmZXJyZWQgdG8gYXMgYSAnZ2VuZXJhdG9yJy4gVGhlcmUgYXJlIG1hbnlcbiAgICAgIGdlbmVyYXRvcnMgKDEyOCBvdXQgb2YgMjU2KTogMyw1LDYsOSwxMSw4MiB0byBuYW1lIGEgZmV3LiBUbyBmdWxseVxuICAgICAgdHJhdmVyc2UgR0Ygd2UgaXRlcmF0ZSAyNTUgdGltZXMsIG11bHRpcGx5aW5nIGJ5IG91ciBnZW5lcmF0b3JcbiAgICAgIGVhY2ggdGltZS5cblxuICAgICAgT24gZWFjaCBpdGVyYXRpb24gd2UgY2FuIGRldGVybWluZSB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBmb3JcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQuXG5cbiAgICAgIFN1cHBvc2UgdGhlcmUgaXMgYW4gZWxlbWVudCBpbiBHRiAnZScuIEZvciBhIGdpdmVuIGdlbmVyYXRvciAnZycsXG4gICAgICBlID0gZ154LiBUaGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiBlIGlzIGdeKDI1NSAtIHgpLiBJdCB0dXJuc1xuICAgICAgb3V0IHRoYXQgaWYgdXNlIHRoZSBpbnZlcnNlIG9mIGEgZ2VuZXJhdG9yIGFzIGFub3RoZXIgZ2VuZXJhdG9yXG4gICAgICBpdCB3aWxsIHByb2R1Y2UgYWxsIG9mIHRoZSBjb3JyZXNwb25kaW5nIG11bHRpcGxpY2F0aXZlIGludmVyc2VzXG4gICAgICBhdCB0aGUgc2FtZSB0aW1lLiBGb3IgdGhpcyByZWFzb24sIHdlIGNob29zZSA1IGFzIG91ciBpbnZlcnNlXG4gICAgICBnZW5lcmF0b3IgYmVjYXVzZSBpdCBvbmx5IHJlcXVpcmVzIDIgbXVsdGlwbGllcyBhbmQgMSBhZGQgYW5kIGl0c1xuICAgICAgaW52ZXJzZSwgODIsIHJlcXVpcmVzIHJlbGF0aXZlbHkgZmV3IG9wZXJhdGlvbnMgYXMgd2VsbC5cblxuICAgICAgSW4gb3JkZXIgdG8gYXBwbHkgdGhlIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiwgdGhlIG11bHRpcGxpY2F0aXZlXG4gICAgICBpbnZlcnNlICdlaScgb2YgJ2UnIGNhbiBiZSByZXBlYXRlZGx5IFhPUidkICg0IHRpbWVzKSB3aXRoIGFcbiAgICAgIGJpdC1jeWNsaW5nIG9mICdlaScuIFRvIGRvIHRoaXMgJ2VpJyBpcyBmaXJzdCBzdG9yZWQgaW4gJ3MnIGFuZFxuICAgICAgJ3gnLiBUaGVuICdzJyBpcyBsZWZ0IHNoaWZ0ZWQgYW5kIHRoZSBoaWdoIGJpdCBvZiAncycgaXMgbWFkZSB0aGVcbiAgICAgIGxvdyBiaXQuIFRoZSByZXN1bHRpbmcgdmFsdWUgaXMgc3RvcmVkIGluICdzJy4gVGhlbiAneCcgaXMgWE9SJ2RcbiAgICAgIHdpdGggJ3MnIGFuZCBzdG9yZWQgaW4gJ3gnLiBPbiBlYWNoIHN1YnNlcXVlbnQgaXRlcmF0aW9uIHRoZSBzYW1lXG4gICAgICBvcGVyYXRpb24gaXMgcGVyZm9ybWVkLiBXaGVuIDQgaXRlcmF0aW9ucyBhcmUgY29tcGxldGUsICd4JyBpc1xuICAgICAgWE9SJ2Qgd2l0aCAnYycgKDB4NjMpIGFuZCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgaXMgc3RvcmVkIGluICd4Jy5cbiAgICAgIEZvciBleGFtcGxlOlxuXG4gICAgICBzID0gMDEwMDAwMDFcbiAgICAgIHggPSAwMTAwMDAwMVxuXG4gICAgICBpdGVyYXRpb24gMTogcyA9IDEwMDAwMDEwLCB4IF49IHNcbiAgICAgIGl0ZXJhdGlvbiAyOiBzID0gMDAwMDAxMDEsIHggXj0gc1xuICAgICAgaXRlcmF0aW9uIDM6IHMgPSAwMDAwMTAxMCwgeCBePSBzXG4gICAgICBpdGVyYXRpb24gNDogcyA9IDAwMDEwMTAwLCB4IF49IHNcbiAgICAgIHggXj0gMHg2M1xuXG4gICAgICBUaGlzIGNhbiBiZSBkb25lIHdpdGggYSBsb29wIHdoZXJlIHMgPSAocyA8PCAxKSB8IChzID4+IDcpLiBIb3dldmVyLFxuICAgICAgaXQgY2FuIGFsc28gYmUgZG9uZSBieSB1c2luZyBhIHNpbmdsZSAxNi1iaXQgKGluIHRoaXMgY2FzZSAzMi1iaXQpXG4gICAgICBudW1iZXIgJ3N4Jy4gU2luY2UgWE9SIGlzIGFuIGFzc29jaWF0aXZlIG9wZXJhdGlvbiwgd2UgY2FuIHNldCAnc3gnXG4gICAgICB0byAnZWknIGFuZCB0aGVuIFhPUiBpdCB3aXRoICdzeCcgbGVmdC1zaGlmdGVkIDEsMiwzLCBhbmQgNCB0aW1lcy5cbiAgICAgIFRoZSBtb3N0IHNpZ25pZmljYW50IGJpdHMgd2lsbCBmbG93IGludG8gdGhlIGhpZ2ggOCBiaXQgcG9zaXRpb25zXG4gICAgICBhbmQgYmUgY29ycmVjdGx5IFhPUidkIHdpdGggb25lIGFub3RoZXIuIEFsbCB0aGF0IHJlbWFpbnMgd2lsbCBiZVxuICAgICAgdG8gY3ljbGUgdGhlIGhpZ2ggOCBiaXRzIGJ5IFhPUidpbmcgdGhlbSBhbGwgd2l0aCB0aGUgbG93ZXIgOCBiaXRzXG4gICAgICBhZnRlcndhcmRzLlxuXG4gICAgICBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIHBvcHVsYXRpbmcgc2JveCBhbmQgaXNib3ggd2UgY2FuIHByZWNvbXB1dGVcbiAgICAgIHRoZSBtdWx0aXBsaWNhdGlvbiB3ZSdsbCBuZWVkIHRvIGRvIHRvIGRvIE1peENvbHVtbnMoKSBsYXRlci5cbiAgICAqL1xuXG4gICAgLy8gYXBwbHkgYWZmaW5lIHRyYW5zZm9ybWF0aW9uXG4gICAgc3ggPSBlaSBeIChlaSA8PCAxKSBeIChlaSA8PCAyKSBeIChlaSA8PCAzKSBeIChlaSA8PCA0KTtcbiAgICBzeCA9IChzeCA+PiA4KSBeIChzeCAmIDI1NSkgXiAweDYzO1xuXG4gICAgLy8gdXBkYXRlIHRhYmxlc1xuICAgIHNib3hbZV0gPSBzeDtcbiAgICBpc2JveFtzeF0gPSBlO1xuXG4gICAgLyogTWl4aW5nIGNvbHVtbnMgaXMgZG9uZSB1c2luZyBtYXRyaXggbXVsdGlwbGljYXRpb24uIFRoZSBjb2x1bW5zXG4gICAgICB0aGF0IGFyZSB0byBiZSBtaXhlZCBhcmUgZWFjaCBhIHNpbmdsZSB3b3JkIGluIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgVGhlIHN0YXRlIGhhcyBOYiBjb2x1bW5zICg0IGNvbHVtbnMpLiBUaGVyZWZvcmUgZWFjaCBjb2x1bW4gaXMgYVxuICAgICAgNCBieXRlIHdvcmQuIFNvIHRvIG1peCB0aGUgY29sdW1ucyBpbiBhIHNpbmdsZSBjb2x1bW4gJ2MnIHdoZXJlXG4gICAgICBpdHMgcm93cyBhcmUgcjAsIHIxLCByMiwgYW5kIHIzLCB3ZSB1c2UgdGhlIGZvbGxvd2luZyBtYXRyaXhcbiAgICAgIG11bHRpcGxpY2F0aW9uOlxuXG4gICAgICBbMiAzIDEgMV0qW3IwLGNdPVtyJzAsY11cbiAgICAgIFsxIDIgMyAxXSBbcjEsY10gW3InMSxjXVxuICAgICAgWzEgMSAyIDNdIFtyMixjXSBbcicyLGNdXG4gICAgICBbMyAxIDEgMl0gW3IzLGNdIFtyJzMsY11cblxuICAgICAgcjAsIHIxLCByMiwgYW5kIHIzIGFyZSBlYWNoIDEgYnl0ZSBvZiBvbmUgb2YgdGhlIHdvcmRzIGluIHRoZVxuICAgICAgc3RhdGUgKGEgY29sdW1uKS4gVG8gZG8gbWF0cml4IG11bHRpcGxpY2F0aW9uIGZvciBlYWNoIG1peGVkXG4gICAgICBjb2x1bW4gYycgd2UgbXVsdGlwbHkgdGhlIGNvcnJlc3BvbmRpbmcgcm93IGZyb20gdGhlIGxlZnQgbWF0cml4XG4gICAgICB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBmcm9tIHRoZSByaWdodCBtYXRyaXguIEluIHRvdGFsLCB3ZVxuICAgICAgZ2V0IDQgZXF1YXRpb25zOlxuXG4gICAgICByMCxjJyA9IDIqcjAsYyArIDMqcjEsYyArIDEqcjIsYyArIDEqcjMsY1xuICAgICAgcjEsYycgPSAxKnIwLGMgKyAyKnIxLGMgKyAzKnIyLGMgKyAxKnIzLGNcbiAgICAgIHIyLGMnID0gMSpyMCxjICsgMSpyMSxjICsgMipyMixjICsgMypyMyxjXG4gICAgICByMyxjJyA9IDMqcjAsYyArIDEqcjEsYyArIDEqcjIsYyArIDIqcjMsY1xuXG4gICAgICBBcyB1c3VhbCwgdGhlIG11bHRpcGxpY2F0aW9uIGlzIGFzIHByZXZpb3VzbHkgZGVmaW5lZCBhbmQgdGhlXG4gICAgICBhZGRpdGlvbiBpcyBYT1IuIEluIG9yZGVyIHRvIG9wdGltaXplIG1peGluZyBjb2x1bW5zIHdlIGNhbiBzdG9yZVxuICAgICAgdGhlIG11bHRpcGxpY2F0aW9uIHJlc3VsdHMgaW4gdGFibGVzLiBJZiB5b3UgdGhpbmsgb2YgdGhlIHdob2xlXG4gICAgICBjb2x1bW4gYXMgYSB3b3JkIChpdCBtaWdodCBoZWxwIHRvIHZpc3VhbGl6ZSBieSBtZW50YWxseSByb3RhdGluZ1xuICAgICAgdGhlIGVxdWF0aW9ucyBhYm92ZSBieSBjb3VudGVyY2xvY2t3aXNlIDkwIGRlZ3JlZXMpIHRoZW4geW91IGNhblxuICAgICAgc2VlIHRoYXQgaXQgd291bGQgYmUgdXNlZnVsIHRvIG1hcCB0aGUgbXVsdGlwbGljYXRpb25zIHBlcmZvcm1lZCBvblxuICAgICAgZWFjaCBieXRlIChyMCwgcjEsIHIyLCByMykgb250byBhIHdvcmQgYXMgd2VsbC4gRm9yIGluc3RhbmNlLCB3ZVxuICAgICAgY291bGQgbWFwIDIqcjAsMSpyMCwxKnIwLDMqcjAgb250byBhIHdvcmQgYnkgc3RvcmluZyAyKnIwIGluIHRoZVxuICAgICAgaGlnaGVzdCA4IGJpdHMgYW5kIDMqcjAgaW4gdGhlIGxvd2VzdCA4IGJpdHMgKHdpdGggdGhlIG90aGVyIHR3b1xuICAgICAgcmVzcGVjdGl2ZWx5IGluIHRoZSBtaWRkbGUpLiBUaGlzIG1lYW5zIHRoYXQgYSB0YWJsZSBjYW4gYmVcbiAgICAgIGNvbnN0cnVjdGVkIHRoYXQgdXNlcyByMCBhcyBhbiBpbmRleCB0byB0aGUgd29yZC4gV2UgY2FuIGRvIHRoZVxuICAgICAgc2FtZSB3aXRoIHIxLCByMiwgYW5kIHIzLCBjcmVhdGluZyBhIHRvdGFsIG9mIDQgdGFibGVzLlxuXG4gICAgICBUbyBjb25zdHJ1Y3QgYSBmdWxsIGMnLCB3ZSBjYW4ganVzdCBsb29rIHVwIGVhY2ggYnl0ZSBvZiBjIGluXG4gICAgICB0aGVpciByZXNwZWN0aXZlIHRhYmxlcyBhbmQgWE9SIHRoZSByZXN1bHRzIHRvZ2V0aGVyLlxuXG4gICAgICBBbHNvLCB0byBidWlsZCBlYWNoIHRhYmxlIHdlIG9ubHkgaGF2ZSB0byBjYWxjdWxhdGUgdGhlIHdvcmRcbiAgICAgIGZvciAyLDEsMSwzIGZvciBldmVyeSBieXRlIC4uLiB3aGljaCB3ZSBjYW4gZG8gb24gZWFjaCBpdGVyYXRpb25cbiAgICAgIG9mIHRoaXMgbG9vcCBzaW5jZSB3ZSB3aWxsIGl0ZXJhdGUgb3ZlciBldmVyeSBieXRlLiBBZnRlciB3ZSBoYXZlXG4gICAgICBjYWxjdWxhdGVkIDIsMSwxLDMgd2UgY2FuIGdldCB0aGUgcmVzdWx0cyBmb3IgdGhlIG90aGVyIHRhYmxlc1xuICAgICAgYnkgY3ljbGluZyB0aGUgYnl0ZSBhdCB0aGUgZW5kIHRvIHRoZSBiZWdpbm5pbmcuIEZvciBpbnN0YW5jZVxuICAgICAgd2UgY2FuIHRha2UgdGhlIHJlc3VsdCBvZiB0YWJsZSAyLDEsMSwzIGFuZCBwcm9kdWNlIHRhYmxlIDMsMiwxLDFcbiAgICAgIGJ5IG1vdmluZyB0aGUgcmlnaHQgbW9zdCBieXRlIHRvIHRoZSBsZWZ0IG1vc3QgcG9zaXRpb24ganVzdCBsaWtlXG4gICAgICBob3cgeW91IGNhbiBpbWFnaW5lIHRoZSAzIG1vdmVkIG91dCBvZiAyLDEsMSwzIGFuZCB0byB0aGUgZnJvbnRcbiAgICAgIHRvIHByb2R1Y2UgMywyLDEsMS5cblxuICAgICAgVGhlcmUgaXMgYW5vdGhlciBvcHRpbWl6YXRpb24gaW4gdGhhdCB0aGUgc2FtZSBtdWx0aXBsZXMgb2ZcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQgd2UgbmVlZCBpbiBvcmRlciB0byBhZHZhbmNlIG91ciBnZW5lcmF0b3JcbiAgICAgIHRvIHRoZSBuZXh0IGl0ZXJhdGlvbiBjYW4gYmUgcmV1c2VkIGluIHBlcmZvcm1pbmcgdGhlIDIsMSwxLDNcbiAgICAgIGNhbGN1bGF0aW9uLiBXZSBhbHNvIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZSBtaXggY29sdW1uIHRhYmxlcyxcbiAgICAgIHdpdGggZSw5LGQsYiBiZWluZyB0aGUgaW52ZXJzZSBvZiAyLDEsMSwzLlxuXG4gICAgICBXaGVuIHdlJ3JlIGRvbmUsIGFuZCB3ZSBuZWVkIHRvIGFjdHVhbGx5IG1peCBjb2x1bW5zLCB0aGUgZmlyc3RcbiAgICAgIGJ5dGUgb2YgZWFjaCBzdGF0ZSB3b3JkIHNob3VsZCBiZSBwdXQgdGhyb3VnaCBtaXhbMF0gKDIsMSwxLDMpLFxuICAgICAgdGhlIHNlY29uZCB0aHJvdWdoIG1peFsxXSAoMywyLDEsMSkgYW5kIHNvIGZvcnRoLiBUaGVuIHRoZXkgc2hvdWxkXG4gICAgICBiZSBYT1InZCB0b2dldGhlciB0byBwcm9kdWNlIHRoZSBmdWxseSBtaXhlZCBjb2x1bW4uXG4gICAgKi9cblxuICAgIC8vIGNhbGN1bGF0ZSBtaXggYW5kIGltaXggdGFibGUgdmFsdWVzXG4gICAgc3gyID0geHRpbWVbc3hdO1xuICAgIGUyID0geHRpbWVbZV07XG4gICAgZTQgPSB4dGltZVtlMl07XG4gICAgZTggPSB4dGltZVtlNF07XG4gICAgbWUgPVxuICAgICAgKHN4MiA8PCAyNCkgXiAgLy8gMlxuICAgICAgKHN4IDw8IDE2KSBeICAgLy8gMVxuICAgICAgKHN4IDw8IDgpIF4gICAgLy8gMVxuICAgICAgKHN4IF4gc3gyKTsgICAgLy8gM1xuICAgIGltZSA9XG4gICAgICAoZTIgXiBlNCBeIGU4KSA8PCAyNCBeICAvLyBFICgxNClcbiAgICAgIChlIF4gZTgpIDw8IDE2IF4gICAgICAgIC8vIDlcbiAgICAgIChlIF4gZTQgXiBlOCkgPDwgOCBeICAgIC8vIEQgKDEzKVxuICAgICAgKGUgXiBlMiBeIGU4KTsgICAgICAgICAgLy8gQiAoMTEpXG4gICAgLy8gcHJvZHVjZSBlYWNoIG9mIHRoZSBtaXggdGFibGVzIGJ5IHJvdGF0aW5nIHRoZSAyLDEsMSwzIHZhbHVlXG4gICAgZm9yKHZhciBuID0gMDsgbiA8IDQ7ICsrbikge1xuICAgICAgbWl4W25dW2VdID0gbWU7XG4gICAgICBpbWl4W25dW3N4XSA9IGltZTtcbiAgICAgIC8vIGN5Y2xlIHRoZSByaWdodCBtb3N0IGJ5dGUgdG8gdGhlIGxlZnQgbW9zdCBwb3NpdGlvblxuICAgICAgLy8gaWU6IDIsMSwxLDMgYmVjb21lcyAzLDIsMSwxXG4gICAgICBtZSA9IG1lIDw8IDI0IHwgbWUgPj4+IDg7XG4gICAgICBpbWUgPSBpbWUgPDwgMjQgfCBpbWUgPj4+IDg7XG4gICAgfVxuXG4gICAgLy8gZ2V0IG5leHQgZWxlbWVudCBhbmQgaW52ZXJzZVxuICAgIGlmKGUgPT09IDApIHtcbiAgICAgIC8vIDEgaXMgdGhlIGludmVyc2Ugb2YgMVxuICAgICAgZSA9IGVpID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZSA9IDJlICsgMioyKjIqKDEwZSkpID0gbXVsdGlwbHkgZSBieSA4MiAoY2hvc2VuIGdlbmVyYXRvcilcbiAgICAgIC8vIGVpID0gZWkgKyAyKjIqZWkgPSBtdWx0aXBseSBlaSBieSA1IChpbnZlcnNlIGdlbmVyYXRvcilcbiAgICAgIGUgPSBlMiBeIHh0aW1lW3h0aW1lW3h0aW1lW2UyIF4gZThdXV07XG4gICAgICBlaSBePSB4dGltZVt4dGltZVtlaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleSBzY2hlZHVsZSB1c2luZyB0aGUgQUVTIGtleSBleHBhbnNpb24gYWxnb3JpdGhtLlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHRha2VzIHRoZSBDaXBoZXIgS2V5LCBLLCBhbmQgcGVyZm9ybXMgYSBLZXkgRXhwYW5zaW9uXG4gKiByb3V0aW5lIHRvIGdlbmVyYXRlIGEga2V5IHNjaGVkdWxlLiBUaGUgS2V5IEV4cGFuc2lvbiBnZW5lcmF0ZXMgYSB0b3RhbFxuICogb2YgTmIqKE5yICsgMSkgd29yZHM6IHRoZSBhbGdvcml0aG0gcmVxdWlyZXMgYW4gaW5pdGlhbCBzZXQgb2YgTmIgd29yZHMsXG4gKiBhbmQgZWFjaCBvZiB0aGUgTnIgcm91bmRzIHJlcXVpcmVzIE5iIHdvcmRzIG9mIGtleSBkYXRhLiBUaGUgcmVzdWx0aW5nXG4gKiBrZXkgc2NoZWR1bGUgY29uc2lzdHMgb2YgYSBsaW5lYXIgYXJyYXkgb2YgNC1ieXRlIHdvcmRzLCBkZW5vdGVkIFt3aSBdLFxuICogd2l0aCBpIGluIHRoZSByYW5nZSAwIOKJpCBpIDwgTmIoTnIgKyAxKS5cbiAqXG4gKiBLZXlFeHBhbnNpb24oYnl0ZSBrZXlbNCpOa10sIHdvcmQgd1tOYiooTnIrMSldLCBOaylcbiAqIEFFUy0xMjggKE5iPTQsIE5rPTQsIE5yPTEwKVxuICogQUVTLTE5MiAoTmI9NCwgTms9NiwgTnI9MTIpXG4gKiBBRVMtMjU2IChOYj00LCBOaz04LCBOcj0xNClcbiAqIE5vdGU6IE5yPU5rKzYuXG4gKlxuICogTmIgaXMgdGhlIG51bWJlciBvZiBjb2x1bW5zICgzMi1iaXQgd29yZHMpIGNvbXByaXNpbmcgdGhlIFN0YXRlIChvclxuICogbnVtYmVyIG9mIGJ5dGVzIGluIGEgYmxvY2spLiBGb3IgQUVTLCBOYj00LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBzY2hlZHVsZSAoYXMgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gbW9kaWZ5IHRoZSBrZXkgc2NoZWR1bGUgdG8gZGVjcnlwdCwgZmFsc2Ugbm90IHRvLlxuICpcbiAqIEByZXR1cm4gdGhlIGdlbmVyYXRlZCBrZXkgc2NoZWR1bGUuXG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRLZXkoa2V5LCBkZWNyeXB0KSB7XG4gIC8vIGNvcHkgdGhlIGtleSdzIHdvcmRzIHRvIGluaXRpYWxpemUgdGhlIGtleSBzY2hlZHVsZVxuICB2YXIgdyA9IGtleS5zbGljZSgwKTtcblxuICAvKiBSb3RXb3JkKCkgd2lsbCByb3RhdGUgYSB3b3JkLCBtb3ZpbmcgdGhlIGZpcnN0IGJ5dGUgdG8gdGhlIGxhc3RcbiAgICBieXRlJ3MgcG9zaXRpb24gKHNoaWZ0aW5nIHRoZSBvdGhlciBieXRlcyBsZWZ0KS5cblxuICAgIFdlIHdpbGwgYmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgUmNvbiBhdCBpIC8gTmsuICdpJyB3aWxsIGl0ZXJhdGVcbiAgICBmcm9tIE5rIHRvIChOYiAqIE5yKzEpLiBOayA9IDQgKDQgYnl0ZSBrZXkpLCBOYiA9IDQgKDQgd29yZHMgaW5cbiAgICBhIGJsb2NrKSwgTnIgPSBOayArIDYgKDEwKS4gVGhlcmVmb3JlICdpJyB3aWxsIGl0ZXJhdGUgZnJvbVxuICAgIDQgdG8gNDQgKGV4Y2x1c2l2ZSkuIEVhY2ggdGltZSB3ZSBpdGVyYXRlIDQgdGltZXMsIGkgLyBOayB3aWxsXG4gICAgaW5jcmVhc2UgYnkgMS4gV2UgdXNlIGEgY291bnRlciBpTmsgdG8ga2VlcCB0cmFjayBvZiB0aGlzLlxuICAgKi9cblxuICAvLyBnbyB0aHJvdWdoIHRoZSByb3VuZHMgZXhwYW5kaW5nIHRoZSBrZXlcbiAgdmFyIHRlbXAsIGlOayA9IDE7XG4gIHZhciBOayA9IHcubGVuZ3RoO1xuICB2YXIgTnIxID0gTmsgKyA2ICsgMTtcbiAgdmFyIGVuZCA9IE5iICogTnIxO1xuICBmb3IodmFyIGkgPSBOazsgaSA8IGVuZDsgKytpKSB7XG4gICAgdGVtcCA9IHdbaSAtIDFdO1xuICAgIGlmKGkgJSBOayA9PT0gMCkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQoUm90V29yZCh0ZW1wKSkgXiBSY29uW2kgLyBOa11cbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDE2ICYgMjU1XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gOCAmIDI1NV0gPDwgMTYgXlxuICAgICAgICBzYm94W3RlbXAgJiAyNTVdIDw8IDggXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSBeIChyY29uW2lOa10gPDwgMjQpO1xuICAgICAgaU5rKys7XG4gICAgfSBlbHNlIGlmKE5rID4gNiAmJiAoaSAlIE5rID09PSA0KSkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQodGVtcClcbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gMTYgJiAyNTVdIDw8IDE2IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiA4ICYgMjU1XSA8PCA4IF5cbiAgICAgICAgc2JveFt0ZW1wICYgMjU1XTtcbiAgICB9XG4gICAgd1tpXSA9IHdbaSAtIE5rXSBeIHRlbXA7XG4gIH1cblxuICAgLyogV2hlbiB3ZSBhcmUgdXBkYXRpbmcgYSBjaXBoZXIgYmxvY2sgd2UgYWx3YXlzIHVzZSB0aGUgY29kZSBwYXRoIGZvclxuICAgICBlbmNyeXB0aW9uIHdoZXRoZXIgd2UgYXJlIGRlY3J5cHRpbmcgb3Igbm90ICh0byBzaG9ydGVuIGNvZGUgYW5kXG4gICAgIHNpbXBsaWZ5IHRoZSBnZW5lcmF0aW9uIG9mIGxvb2sgdXAgdGFibGVzKS4gSG93ZXZlciwgYmVjYXVzZSB0aGVyZVxuICAgICBhcmUgZGlmZmVyZW5jZXMgaW4gdGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtLCBvdGhlciB0aGFuIGp1c3Qgc3dhcHBpbmdcbiAgICAgaW4gZGlmZmVyZW50IGxvb2sgdXAgdGFibGVzLCB3ZSBtdXN0IHRyYW5zZm9ybSBvdXIga2V5IHNjaGVkdWxlIHRvXG4gICAgIGFjY291bnQgZm9yIHRoZXNlIGNoYW5nZXM6XG5cbiAgICAgMS4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGdldHMgaXRzIGtleSByb3VuZHMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgMi4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGFkZHMgdGhlIHJvdW5kIGtleSBiZWZvcmUgbWl4aW5nIGNvbHVtbnNcbiAgICAgICBpbnN0ZWFkIG9mIGFmdGVyd2FyZHMuXG5cbiAgICAgV2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgb3VyIGtleSBzY2hlZHVsZSB0byBoYW5kbGUgdGhlIGZpcnN0IGNhc2UsXG4gICAgIHdlIGNhbiBqdXN0IHRyYXZlcnNlIHRoZSBrZXkgc2NoZWR1bGUgaW4gcmV2ZXJzZSBvcmRlciB3aGVuIGRlY3J5cHRpbmcuXG5cbiAgICAgVGhlIHNlY29uZCBjYXNlIHJlcXVpcmVzIGEgbGl0dGxlIHdvcmsuXG5cbiAgICAgVGhlIHRhYmxlcyB3ZSBidWlsdCBmb3IgcGVyZm9ybWluZyByb3VuZHMgd2lsbCB0YWtlIGFuIGlucHV0IGFuZCB0aGVuXG4gICAgIHBlcmZvcm0gU3ViQnl0ZXMoKSBhbmQgTWl4Q29sdW1ucygpIG9yLCBmb3IgdGhlIGRlY3J5cHQgdmVyc2lvbixcbiAgICAgSW52U3ViQnl0ZXMoKSBhbmQgSW52TWl4Q29sdW1ucygpLiBCdXQgdGhlIGRlY3J5cHQgYWxnb3JpdGhtIHJlcXVpcmVzXG4gICAgIHVzIHRvIEFkZFJvdW5kS2V5KCkgYmVmb3JlIEludk1peENvbHVtbnMoKS4gVGhpcyBtZWFucyB3ZSdsbCBuZWVkIHRvXG4gICAgIGFwcGx5IHNvbWUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByb3VuZCBrZXkgdG8gaW52ZXJzZS1taXggaXRzIGNvbHVtbnNcbiAgICAgc28gdGhleSdsbCBiZSBjb3JyZWN0IGZvciBtb3ZpbmcgQWRkUm91bmRLZXkoKSB0byBhZnRlciB0aGUgc3RhdGUgaGFzXG4gICAgIGhhZCBpdHMgY29sdW1ucyBpbnZlcnNlLW1peGVkLlxuXG4gICAgIFRvIGludmVyc2UtbWl4IHRoZSBjb2x1bW5zIG9mIHRoZSBzdGF0ZSB3aGVuIHdlJ3JlIGRlY3J5cHRpbmcgd2UgdXNlIGFcbiAgICAgbG9va3VwIHRhYmxlIHRoYXQgd2lsbCBhcHBseSBJbnZTdWJCeXRlcygpIGFuZCBJbnZNaXhDb2x1bW5zKCkgYXQgdGhlXG4gICAgIHNhbWUgdGltZS4gSG93ZXZlciwgdGhlIHJvdW5kIGtleSdzIGJ5dGVzIGFyZSBub3QgaW52ZXJzZS1zdWJzdGl0dXRlZFxuICAgICBpbiB0aGUgZGVjcnlwdGlvbiBhbGdvcml0aG0uIFRvIGdldCBhcm91bmQgdGhpcyBwcm9ibGVtLCB3ZSBjYW4gZmlyc3RcbiAgICAgc3Vic3RpdHV0ZSB0aGUgYnl0ZXMgaW4gdGhlIHJvdW5kIGtleSBzbyB0aGF0IHdoZW4gd2UgYXBwbHkgdGhlXG4gICAgIHRyYW5zZm9ybWF0aW9uIHZpYSB0aGUgSW52U3ViQnl0ZXMoKStJbnZNaXhDb2x1bW5zKCkgdGFibGUsIGl0IHdpbGxcbiAgICAgdW5kbyBvdXIgc3Vic3RpdHV0aW9uIGxlYXZpbmcgdXMgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUgdGhhdCB3ZVxuICAgICB3YW50IC0tIGFuZCB0aGVuIGludmVyc2UtbWl4IHRoYXQgdmFsdWUuXG5cbiAgICAgVGhpcyBjaGFuZ2Ugd2lsbCBjb3JyZWN0bHkgYWx0ZXIgb3VyIGtleSBzY2hlZHVsZSBzbyB0aGF0IHdlIGNhbiBYT1JcbiAgICAgZWFjaCByb3VuZCBrZXkgd2l0aCBvdXIgYWxyZWFkeSB0cmFuc2Zvcm1lZCBkZWNyeXB0aW9uIHN0YXRlLiBUaGlzXG4gICAgIGFsbG93cyB1cyB0byB1c2UgdGhlIHNhbWUgY29kZSBwYXRoIGFzIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobS5cblxuICAgICBXZSBtYWtlIG9uZSBtb3JlIGNoYW5nZSB0byB0aGUgZGVjcnlwdGlvbiBrZXkuIFNpbmNlIHRoZSBkZWNyeXB0aW9uXG4gICAgIGFsZ29yaXRobSBydW5zIGluIHJldmVyc2UgZnJvbSB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0sIHdlIHJldmVyc2VcbiAgICAgdGhlIG9yZGVyIG9mIHRoZSByb3VuZCBrZXlzIHRvIGF2b2lkIGhhdmluZyB0byBpdGVyYXRlIG92ZXIgdGhlIGtleVxuICAgICBzY2hlZHVsZSBiYWNrd2FyZHMgd2hlbiBydW5uaW5nIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBsYXRlciBpblxuICAgICBkZWNyeXB0aW9uIG1vZGUuIEluIGFkZGl0aW9uIHRvIHJldmVyc2luZyB0aGUgb3JkZXIgb2YgdGhlIHJvdW5kIGtleXMsXG4gICAgIHdlIGFsc28gc3dhcCBlYWNoIHJvdW5kIGtleSdzIDJuZCBhbmQgNHRoIHJvd3MuIFNlZSB0aGUgY29tbWVudHNcbiAgICAgc2VjdGlvbiB3aGVyZSByb3VuZHMgYXJlIHBlcmZvcm1lZCBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoeSB0aGlzIGlzXG4gICAgIGRvbmUuIFRoZXNlIGNoYW5nZXMgYXJlIGRvbmUgaW5saW5lIHdpdGggdGhlIG90aGVyIHN1YnN0aXR1dGlvblxuICAgICBkZXNjcmliZWQgYWJvdmUuXG4gICovXG4gIGlmKGRlY3J5cHQpIHtcbiAgICB2YXIgdG1wO1xuICAgIHZhciBtMCA9IGltaXhbMF07XG4gICAgdmFyIG0xID0gaW1peFsxXTtcbiAgICB2YXIgbTIgPSBpbWl4WzJdO1xuICAgIHZhciBtMyA9IGltaXhbM107XG4gICAgdmFyIHduZXcgPSB3LnNsaWNlKDApO1xuICAgIGVuZCA9IHcubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIHdpID0gZW5kIC0gTmI7IGkgPCBlbmQ7IGkgKz0gTmIsIHdpIC09IE5iKSB7XG4gICAgICAvLyBkbyBub3Qgc3ViIHRoZSBmaXJzdCBvciBsYXN0IHJvdW5kIGtleSAocm91bmQga2V5cyBhcmUgTmJcbiAgICAgIC8vIHdvcmRzKSBhcyBubyBjb2x1bW4gbWl4aW5nIGlzIHBlcmZvcm1lZCBiZWZvcmUgdGhleSBhcmUgYWRkZWQsXG4gICAgICAvLyBidXQgZG8gY2hhbmdlIHRoZSBrZXkgb3JkZXJcbiAgICAgIGlmKGkgPT09IDAgfHwgaSA9PT0gKGVuZCAtIE5iKSkge1xuICAgICAgICB3bmV3W2ldID0gd1t3aV07XG4gICAgICAgIHduZXdbaSArIDFdID0gd1t3aSArIDNdO1xuICAgICAgICB3bmV3W2kgKyAyXSA9IHdbd2kgKyAyXTtcbiAgICAgICAgd25ld1tpICsgM10gPSB3W3dpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWJzdGl0dXRlIGVhY2ggcm91bmQga2V5IGJ5dGUgYmVjYXVzZSB0aGUgaW52ZXJzZS1taXhcbiAgICAgICAgLy8gdGFibGUgd2lsbCBpbnZlcnNlLXN1YnN0aXR1dGUgaXQgKGVmZmVjdGl2ZWx5IGNhbmNlbCB0aGVcbiAgICAgICAgLy8gc3Vic3RpdHV0aW9uIGJlY2F1c2Ugcm91bmQga2V5IGJ5dGVzIGFyZW4ndCBzdWInZCBpblxuICAgICAgICAvLyBkZWNyeXB0aW9uIG1vZGUpIGFuZCBzd2FwIGluZGV4ZXMgMyBhbmQgMVxuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgTmI7ICsrbikge1xuICAgICAgICAgIHRtcCA9IHdbd2kgKyBuXTtcbiAgICAgICAgICB3bmV3W2kgKyAoMyYtbildID1cbiAgICAgICAgICAgIG0wW3Nib3hbdG1wID4+PiAyNF1dIF5cbiAgICAgICAgICAgIG0xW3Nib3hbdG1wID4+PiAxNiAmIDI1NV1dIF5cbiAgICAgICAgICAgIG0yW3Nib3hbdG1wID4+PiA4ICYgMjU1XV0gXlxuICAgICAgICAgICAgbTNbc2JveFt0bXAgJiAyNTVdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3ID0gd25ldztcbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDE2IGJ5dGVzKSB1c2luZyBBRVMuIFRoZSB1cGRhdGUgd2lsbCBlaXRoZXJcbiAqIGVuY3J5cHQgb3IgZGVjcnlwdCB0aGUgYmxvY2suXG4gKlxuICogQHBhcmFtIHcgdGhlIGtleSBzY2hlZHVsZS5cbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgYmxvY2sgKGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSB1cGRhdGVkIG91dHB1dCBibG9jay5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZGVjcnlwdCB0aGUgYmxvY2ssIGZhbHNlIHRvIGVuY3J5cHQgaXQuXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayh3LCBpbnB1dCwgb3V0cHV0LCBkZWNyeXB0KSB7XG4gIC8qXG4gIENpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBmb3Igcm91bmQgPSAxIHN0ZXAgMSB0byBOcuKAkzFcbiAgICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgICAgTWl4Q29sdW1ucyhzdGF0ZSlcbiAgICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W3JvdW5kKk5iLCAocm91bmQrMSkqTmItMV0pXG4gICAgZW5kIGZvclxuICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuXG4gIEludkNpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIGZvciByb3VuZCA9IE5yLTEgc3RlcCAtMSBkb3dudG8gMVxuICAgICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgICAgSW52U3ViQnl0ZXMoc3RhdGUpXG4gICAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tyb3VuZCpOYiwgKHJvdW5kKzEpKk5iLTFdKVxuICAgICAgSW52TWl4Q29sdW1ucyhzdGF0ZSlcbiAgICBlbmQgZm9yXG4gICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgIEludlN1YkJ5dGVzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuICAqL1xuXG4gIC8vIEVuY3J5cHQ6IEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAvLyBEZWNyeXB0OiBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICB2YXIgTnIgPSB3Lmxlbmd0aCAvIDQgLSAxO1xuICB2YXIgbTAsIG0xLCBtMiwgbTMsIHN1YjtcbiAgaWYoZGVjcnlwdCkge1xuICAgIG0wID0gaW1peFswXTtcbiAgICBtMSA9IGltaXhbMV07XG4gICAgbTIgPSBpbWl4WzJdO1xuICAgIG0zID0gaW1peFszXTtcbiAgICBzdWIgPSBpc2JveDtcbiAgfSBlbHNlIHtcbiAgICBtMCA9IG1peFswXTtcbiAgICBtMSA9IG1peFsxXTtcbiAgICBtMiA9IG1peFsyXTtcbiAgICBtMyA9IG1peFszXTtcbiAgICBzdWIgPSBzYm94O1xuICB9XG4gIHZhciBhLCBiLCBjLCBkLCBhMiwgYjIsIGMyO1xuICBhID0gaW5wdXRbMF0gXiB3WzBdO1xuICBiID0gaW5wdXRbZGVjcnlwdCA/IDMgOiAxXSBeIHdbMV07XG4gIGMgPSBpbnB1dFsyXSBeIHdbMl07XG4gIGQgPSBpbnB1dFtkZWNyeXB0ID8gMSA6IDNdIF4gd1szXTtcbiAgdmFyIGkgPSAzO1xuXG4gIC8qIEluIG9yZGVyIHRvIHNoYXJlIGNvZGUgd2UgZm9sbG93IHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB3aGVuIGJvdGhcbiAgICBlbmNyeXB0aW5nIGFuZCBkZWNyeXB0aW5nLiBUbyBhY2NvdW50IGZvciB0aGUgY2hhbmdlcyByZXF1aXJlZCBpbiB0aGVcbiAgICBkZWNyeXB0aW9uIGFsZ29yaXRobSwgd2UgdXNlIGRpZmZlcmVudCBsb29rdXAgdGFibGVzIHdoZW4gZGVjcnlwdGluZ1xuICAgIGFuZCB1c2UgYSBtb2RpZmllZCBrZXkgc2NoZWR1bGUgdG8gYWNjb3VudCBmb3IgdGhlIGRpZmZlcmVuY2UgaW4gdGhlXG4gICAgb3JkZXIgb2YgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHJvdW5kcy4gV2UgYWxzbyBnZXRcbiAgICBrZXkgcm91bmRzIGluIHJldmVyc2Ugb3JkZXIgKHJlbGF0aXZlIHRvIGVuY3J5cHRpb24pLiAqL1xuICBmb3IodmFyIHJvdW5kID0gMTsgcm91bmQgPCBOcjsgKytyb3VuZCkge1xuICAgIC8qIEFzIGRlc2NyaWJlZCBhYm92ZSwgd2UnbGwgYmUgdXNpbmcgdGFibGUgbG9va3VwcyB0byBwZXJmb3JtIHRoZVxuICAgICAgY29sdW1uIG1peGluZy4gRWFjaCBjb2x1bW4gaXMgc3RvcmVkIGFzIGEgd29yZCBpbiB0aGUgc3RhdGUgKHRoZVxuICAgICAgYXJyYXkgJ2lucHV0JyBoYXMgb25lIGNvbHVtbiBhcyBhIHdvcmQgYXQgZWFjaCBpbmRleCkuIEluIG9yZGVyIHRvXG4gICAgICBtaXggYSBjb2x1bW4sIHdlIHBlcmZvcm0gdGhlc2UgdHJhbnNmb3JtYXRpb25zIG9uIGVhY2ggcm93IGluIGMsXG4gICAgICB3aGljaCBpcyAxIGJ5dGUgaW4gZWFjaCB3b3JkLiBUaGUgbmV3IGNvbHVtbiBmb3IgYzAgaXMgYycwOlxuXG4gICAgICAgICAgICAgICBtMCAgICAgIG0xICAgICAgbTIgICAgICBtM1xuICAgICAgcjAsYycwID0gMipyMCxjMCArIDMqcjEsYzAgKyAxKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjEsYycwID0gMSpyMCxjMCArIDIqcjEsYzAgKyAzKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjIsYycwID0gMSpyMCxjMCArIDEqcjEsYzAgKyAyKnIyLGMwICsgMypyMyxjMFxuICAgICAgcjMsYycwID0gMypyMCxjMCArIDEqcjEsYzAgKyAxKnIyLGMwICsgMipyMyxjMFxuXG4gICAgICBTbyB1c2luZyBtaXggdGFibGVzIHdoZXJlIGMwIGlzIGEgd29yZCB3aXRoIHIwIGJlaW5nIGl0cyB1cHBlclxuICAgICAgOCBiaXRzIGFuZCByMyBiZWluZyBpdHMgbG93ZXIgOCBiaXRzOlxuXG4gICAgICBtMFtjMCA+PiAyNF0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsyKnIwLDEqcjAsMSpyMCwzKnIwXVxuICAgICAgLi4uXG4gICAgICBtM1tjMCAmIDI1NV0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsxKnIzLDEqcjMsMypyMywyKnIzXVxuXG4gICAgICBUaGVyZWZvcmUgdG8gbWl4IHRoZSBjb2x1bW5zIGluIGVhY2ggd29yZCBpbiB0aGUgc3RhdGUgd2VcbiAgICAgIGRvIHRoZSBmb2xsb3dpbmcgKCYgMjU1IG9taXR0ZWQgZm9yIGJyZXZpdHkpOlxuICAgICAgYycwLHIwID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cbiAgICAgIGMnMCxyMSA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG4gICAgICBjJzAscjIgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuICAgICAgYycwLHIzID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cblxuICAgICAgSG93ZXZlciwgYmVmb3JlIG1peGluZywgdGhlIGFsZ29yaXRobSByZXF1aXJlcyB1cyB0byBwZXJmb3JtXG4gICAgICBTaGlmdFJvd3MoKS4gVGhlIFNoaWZ0Um93cygpIHRyYW5zZm9ybWF0aW9uIGN5Y2xpY2FsbHkgc2hpZnRzIHRoZVxuICAgICAgbGFzdCAzIHJvd3Mgb2YgdGhlIHN0YXRlIG92ZXIgZGlmZmVyZW50IG9mZnNldHMuIFRoZSBmaXJzdCByb3dcbiAgICAgIChyID0gMCkgaXMgbm90IHNoaWZ0ZWQuXG5cbiAgICAgIHMnX3IsYyA9IHNfciwoYyArIHNoaWZ0KHIsIE5iKSBtb2QgTmJcbiAgICAgIGZvciAwIDwgciA8IDQgYW5kIDAgPD0gYyA8IE5iIGFuZFxuICAgICAgc2hpZnQoMSwgNCkgPSAxXG4gICAgICBzaGlmdCgyLCA0KSA9IDJcbiAgICAgIHNoaWZ0KDMsIDQpID0gMy5cblxuICAgICAgVGhpcyBjYXVzZXMgdGhlIGZpcnN0IGJ5dGUgaW4gciA9IDEgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDIgYnl0ZXMgaW4gciA9IDIgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDMgYnl0ZXMgaW4gciA9IDMgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdzpcblxuICAgICAgcjE6IFtjMCBjMSBjMiBjM10gPT4gW2MxIGMyIGMzIGMwXVxuICAgICAgcjI6IFtjMCBjMSBjMiBjM10gICAgW2MyIGMzIGMwIGMxXVxuICAgICAgcjM6IFtjMCBjMSBjMiBjM10gICAgW2MzIGMwIGMxIGMyXVxuXG4gICAgICBXZSBjYW4gbWFrZSB0aGVzZSBzdWJzdGl0dXRpb25zIGlubGluZSB3aXRoIG91ciBjb2x1bW4gbWl4aW5nIHRvXG4gICAgICBnZW5lcmF0ZSBhbiB1cGRhdGVkIHNldCBvZiBlcXVhdGlvbnMgdG8gcHJvZHVjZSBlYWNoIHdvcmQgaW4gdGhlXG4gICAgICBzdGF0ZSAobm90ZSB0aGUgY29sdW1ucyBoYXZlIGNoYW5nZWQgcG9zaXRpb25zKTpcblxuICAgICAgYzAgYzEgYzIgYzMgPT4gYzAgYzEgYzIgYzNcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMxIGMyIGMzIGMwICAoY3ljbGVkIDEgYnl0ZSlcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMyIGMzIGMwIGMxICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMyBjMCBjMSBjMiAgKGN5Y2xlZCAzIGJ5dGVzKVxuXG4gICAgICBUaGVyZWZvcmU6XG5cbiAgICAgIGMnMCA9IDIqcjAsYzAgKyAzKnIxLGMxICsgMSpyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAyKnIxLGMxICsgMypyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAxKnIxLGMxICsgMipyMixjMiArIDMqcjMsYzNcbiAgICAgIGMnMCA9IDMqcjAsYzAgKyAxKnIxLGMxICsgMSpyMixjMiArIDIqcjMsYzNcblxuICAgICAgYycxID0gMipyMCxjMSArIDMqcjEsYzIgKyAxKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDIqcjEsYzIgKyAzKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDEqcjEsYzIgKyAyKnIyLGMzICsgMypyMyxjMFxuICAgICAgYycxID0gMypyMCxjMSArIDEqcjEsYzIgKyAxKnIyLGMzICsgMipyMyxjMFxuXG4gICAgICAuLi4gYW5kIHNvIGZvcnRoIGZvciBjJzIgYW5kIGMnMy4gVGhlIGltcG9ydGFudCBkaXN0aW5jdGlvbiBpc1xuICAgICAgdGhhdCB0aGUgY29sdW1ucyBhcmUgY3ljbGluZywgd2l0aCBjMCBiZWluZyB1c2VkIHdpdGggdGhlIG0wXG4gICAgICBtYXAgd2hlbiBjYWxjdWxhdGluZyBjMCwgYnV0IGMxIGJlaW5nIHVzZWQgd2l0aCB0aGUgbTAgbWFwIHdoZW5cbiAgICAgIGNhbGN1bGF0aW5nIGMxIC4uLiBhbmQgc28gZm9ydGguXG5cbiAgICAgIFdoZW4gcGVyZm9ybWluZyB0aGUgaW52ZXJzZSB3ZSB0cmFuc2Zvcm0gdGhlIG1pcnJvciBpbWFnZSBhbmRcbiAgICAgIHNraXAgdGhlIGJvdHRvbSByb3csIGluc3RlYWQgb2YgdGhlIHRvcCBvbmUsIGFuZCBtb3ZlIHVwd2FyZHM6XG5cbiAgICAgIGMzIGMyIGMxIGMwID0+IGMwIGMzIGMyIGMxICAoY3ljbGVkIDMgYnl0ZXMpICpzYW1lIGFzIGVuY3J5cHRpb25cbiAgICAgIGMzIGMyIGMxIGMwICAgIGMxIGMwIGMzIGMyICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMiBjMSBjMCBjMyAgKGN5Y2xlZCAxIGJ5dGUpICAqc2FtZSBhcyBlbmNyeXB0aW9uXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMyBjMiBjMSBjMFxuXG4gICAgICBJZiB5b3UgY29tcGFyZSB0aGUgcmVzdWx0aW5nIG1hdHJpY2VzIGZvciBTaGlmdFJvd3MoKStNaXhDb2x1bW5zKClcbiAgICAgIGFuZCBmb3IgSW52U2hpZnRSb3dzKCkrSW52TWl4Q29sdW1ucygpIHRoZSAybmQgYW5kIDR0aCBjb2x1bW5zIGFyZVxuICAgICAgZGlmZmVyZW50IChpbiBlbmNyeXB0IG1vZGUgdnMuIGRlY3J5cHQgbW9kZSkuIFNvIGluIG9yZGVyIHRvIHVzZVxuICAgICAgdGhlIHNhbWUgY29kZSB0byBoYW5kbGUgYm90aCBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLCB3ZSB3aWxsXG4gICAgICBuZWVkIHRvIGRvIHNvbWUgbWFwcGluZy5cblxuICAgICAgSWYgaW4gZW5jcnlwdGlvbiBtb2RlIHdlIGxldCBhPWMwLCBiPWMxLCBjPWMyLCBkPWMzLCBhbmQgcjxOPiBiZVxuICAgICAgYSByb3cgbnVtYmVyIGluIHRoZSBzdGF0ZSwgdGhlbiB0aGUgcmVzdWx0aW5nIG1hdHJpeCBpbiBlbmNyeXB0aW9uXG4gICAgICBtb2RlIGZvciBhcHBseWluZyB0aGUgYWJvdmUgdHJhbnNmb3JtYXRpb25zIHdvdWxkIGJlOlxuXG4gICAgICByMTogYSBiIGMgZFxuICAgICAgcjI6IGIgYyBkIGFcbiAgICAgIHIzOiBjIGQgYSBiXG4gICAgICByNDogZCBhIGIgY1xuXG4gICAgICBJZiB3ZSBkaWQgdGhlIHNhbWUgaW4gZGVjcnlwdGlvbiBtb2RlIHdlIHdvdWxkIGdldDpcblxuICAgICAgcjE6IGEgZCBjIGJcbiAgICAgIHIyOiBiIGEgZCBjXG4gICAgICByMzogYyBiIGEgZFxuICAgICAgcjQ6IGQgYyBiIGFcblxuICAgICAgSWYgaW5zdGVhZCB3ZSBzd2FwIGQgYW5kIGIgKHNldCBiPWMzIGFuZCBkPWMxKSwgdGhlbiB3ZSBnZXQ6XG5cbiAgICAgIHIxOiBhIGIgYyBkXG4gICAgICByMjogZCBhIGIgY1xuICAgICAgcjM6IGMgZCBhIGJcbiAgICAgIHI0OiBiIGMgZCBhXG5cbiAgICAgIE5vdyB0aGUgMXN0IGFuZCAzcmQgcm93cyBhcmUgdGhlIHNhbWUgYXMgdGhlIGVuY3J5cHRpb24gbWF0cml4LiBBbGxcbiAgICAgIHdlIG5lZWQgdG8gZG8gdGhlbiB0byBtYWtlIHRoZSBtYXBwaW5nIGV4YWN0bHkgdGhlIHNhbWUgaXMgdG8gc3dhcFxuICAgICAgdGhlIDJuZCBhbmQgNHRoIHJvd3Mgd2hlbiBpbiBkZWNyeXB0aW9uIG1vZGUuIFRvIGRvIHRoaXMgd2l0aG91dFxuICAgICAgaGF2aW5nIHRvIGRvIGl0IG9uIGVhY2ggaXRlcmF0aW9uLCB3ZSBzd2FwcGVkIHRoZSAybmQgYW5kIDR0aCByb3dzXG4gICAgICBpbiB0aGUgZGVjcnlwdGlvbiBrZXkgc2NoZWR1bGUuIFdlIGFsc28gaGF2ZSB0byBkbyB0aGUgc3dhcCBhYm92ZVxuICAgICAgd2hlbiB3ZSBmaXJzdCBwdWxsIGluIHRoZSBpbnB1dCBhbmQgd2hlbiB3ZSBzZXQgdGhlIGZpbmFsIG91dHB1dC4gKi9cbiAgICBhMiA9XG4gICAgICBtMFthID4+PiAyNF0gXlxuICAgICAgbTFbYiA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2MgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2QgJiAyNTVdIF4gd1srK2ldO1xuICAgIGIyID1cbiAgICAgIG0wW2IgPj4+IDI0XSBeXG4gICAgICBtMVtjID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbZCA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYSAmIDI1NV0gXiB3WysraV07XG4gICAgYzIgPVxuICAgICAgbTBbYyA+Pj4gMjRdIF5cbiAgICAgIG0xW2QgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMlthID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1tiICYgMjU1XSBeIHdbKytpXTtcbiAgICBkID1cbiAgICAgIG0wW2QgPj4+IDI0XSBeXG4gICAgICBtMVthID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbYiA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYyAmIDI1NV0gXiB3WysraV07XG4gICAgYSA9IGEyO1xuICAgIGIgPSBiMjtcbiAgICBjID0gYzI7XG4gIH1cblxuICAvKlxuICAgIEVuY3J5cHQ6XG4gICAgU3ViQnl0ZXMoc3RhdGUpXG4gICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W05yKk5iLCAoTnIrMSkqTmItMV0pXG5cbiAgICBEZWNyeXB0OlxuICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICBJbnZTdWJCeXRlcyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICovXG4gICAvLyBOb3RlOiByb3dzIGFyZSBzaGlmdGVkIGlubGluZVxuICBvdXRwdXRbMF0gPVxuICAgIChzdWJbYSA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltiID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2MgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2QgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0W2RlY3J5cHQgPyAzIDogMV0gPVxuICAgIChzdWJbYiA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltjID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2QgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2EgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0WzJdID1cbiAgICAoc3ViW2MgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbZCA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YlthID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltiICYgMjU1XSkgXiB3WysraV07XG4gIG91dHB1dFtkZWNyeXB0ID8gMSA6IDNdID1cbiAgICAoc3ViW2QgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbYSA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YltiID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltjICYgMjU1XSkgXiB3WysraV07XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBBRVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqICAgICAgICAgIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbW9kZSA9IChvcHRpb25zLm1vZGUgfHwgJ0NCQycpLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBhbGdvcml0aG0gPSAnQUVTLScgKyBtb2RlO1xuXG4gIHZhciBjaXBoZXI7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGlibGUgc3RhcnQgQVBJXG4gIHZhciBzdGFydCA9IGNpcGhlci5zdGFydDtcbiAgY2lwaGVyLnN0YXJ0ID0gZnVuY3Rpb24oaXYsIG9wdGlvbnMpIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogc3VwcG9ydCBzZWNvbmQgYXJnIGFzIG91dHB1dCBidWZmZXJcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZihvcHRpb25zIGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKSB7XG4gICAgICBvdXRwdXQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm91dHB1dCA9IG91dHB1dDtcbiAgICBvcHRpb25zLml2ID0gaXY7XG4gICAgc3RhcnQuY2FsbChjaXBoZXIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBiYXNpYyBQRU0gKFByaXZhY3kgRW5oYW5jZWQgTWFpbCkgYWxnb3JpdGhtcy5cbiAqXG4gKiBTZWU6IFJGQyAxNDIxLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBIEZvcmdlIFBFTSBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqIHR5cGU6IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgbWVzc2FnZSAoZWc6IFwiUlNBIFBSSVZBVEUgS0VZXCIpLlxuICpcbiAqIHByb2NUeXBlOiBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIHByb2Nlc3NpbmcgcGVyZm9ybWVkIG9uIHRoZSBtZXNzYWdlLFxuICogICBpdCBoYXMgdHdvIHN1YmZpZWxkczogdmVyc2lvbiBhbmQgdHlwZSwgZWc6IDQsRU5DUllQVEVELlxuICpcbiAqIGNvbnRlbnREb21haW46IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgY29udGVudCBpbiB0aGUgbWVzc2FnZSwgdHlwaWNhbGx5XG4gKiAgIG9ubHkgdXNlcyB0aGUgdmFsdWU6IFwiUkZDODIyXCIuXG4gKlxuICogZGVrSW5mbzogaWRlbnRpZmllcyB0aGUgbWVzc2FnZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBhbmQgbW9kZSBhbmQgaW5jbHVkZXNcbiAqICAgYW55IHBhcmFtZXRlcnMgZm9yIHRoZSBhbGdvcml0aG0sIGl0IGhhcyB0d28gc3ViZmllbGRzOiBhbGdvcml0aG0gYW5kXG4gKiAgIHBhcmFtZXRlcnMsIGVnOiBERVMtQ0JDLEY4MTQzRURFNTk2MEM1OTcuXG4gKlxuICogaGVhZGVyczogY29udGFpbnMgYWxsIG90aGVyIFBFTSBlbmNhcHN1bGF0ZWQgaGVhZGVycyAtLSB3aGVyZSBvcmRlciBpc1xuICogICBzaWduaWZpY2FudCAoZm9yIHBhaXJpbmcgZGF0YSBsaWtlIHJlY2lwaWVudCBJRCArIGtleSBpbmZvKS5cbiAqXG4gKiBib2R5OiB0aGUgYmluYXJ5LWVuY29kZWQgYm9keS5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIHNob3J0Y3V0IGZvciBwZW0gQVBJXG52YXIgcGVtID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wZW0gPSBmb3JnZS5wZW0gfHwge307XG5cbi8qKlxuICogRW5jb2RlcyAoc2VyaWFsaXplcykgdGhlIGdpdmVuIFBFTSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1zZyB0aGUgUEVNIG1lc3NhZ2Ugb2JqZWN0IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSBmb3IgdGhlIGJvZHksIChkZWZhdWx0OiA2NCkuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbnBlbS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBydmFsID0gJy0tLS0tQkVHSU4gJyArIG1zZy50eXBlICsgJy0tLS0tXFxyXFxuJztcblxuICAvLyBlbmNvZGUgc3BlY2lhbCBoZWFkZXJzXG4gIHZhciBoZWFkZXI7XG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIGhlYWRlciA9IHtcbiAgICAgIG5hbWU6ICdQcm9jLVR5cGUnLFxuICAgICAgdmFsdWVzOiBbU3RyaW5nKG1zZy5wcm9jVHlwZS52ZXJzaW9uKSwgbXNnLnByb2NUeXBlLnR5cGVdXG4gICAgfTtcbiAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgfVxuICBpZihtc2cuY29udGVudERvbWFpbikge1xuICAgIGhlYWRlciA9IHtuYW1lOiAnQ29udGVudC1Eb21haW4nLCB2YWx1ZXM6IFttc2cuY29udGVudERvbWFpbl19O1xuICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICB9XG4gIGlmKG1zZy5kZWtJbmZvKSB7XG4gICAgaGVhZGVyID0ge25hbWU6ICdERUstSW5mbycsIHZhbHVlczogW21zZy5kZWtJbmZvLmFsZ29yaXRobV19O1xuICAgIGlmKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpIHtcbiAgICAgIGhlYWRlci52YWx1ZXMucHVzaChtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgcnZhbCArPSBmb2xkSGVhZGVyKGhlYWRlcik7XG4gIH1cblxuICBpZihtc2cuaGVhZGVycykge1xuICAgIC8vIGVuY29kZSBhbGwgb3RoZXIgaGVhZGVyc1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cuaGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgcnZhbCArPSBmb2xkSGVhZGVyKG1zZy5oZWFkZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyB0ZXJtaW5hdGUgaGVhZGVyXG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIHJ2YWwgKz0gJ1xcclxcbic7XG4gIH1cblxuICAvLyBhZGQgYm9keVxuICBydmFsICs9IGZvcmdlLnV0aWwuZW5jb2RlNjQobXNnLmJvZHksIG9wdGlvbnMubWF4bGluZSB8fCA2NCkgKyAnXFxyXFxuJztcblxuICBydmFsICs9ICctLS0tLUVORCAnICsgbXNnLnR5cGUgKyAnLS0tLS1cXHJcXG4nO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyAoZGVzZXJpYWxpemVzKSBhbGwgUEVNIG1lc3NhZ2VzIGZvdW5kIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTSBtZXNzYWdlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gKi9cbnBlbS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBzcGxpdCBzdHJpbmcgaW50byBQRU0gbWVzc2FnZXMgKGJlIGxlbmllbnQgdy9FT0Ygb24gQkVHSU4gbGluZSlcbiAgdmFyIHJNZXNzYWdlID0gL1xccyotLS0tLUJFR0lOIChbQS1aMC05LSBdKyktLS0tLVxccj9cXG4/KFtcXHgyMS1cXHg3ZVxcc10rPyg/Olxccj9cXG5cXHI/XFxuKSk/KFs6QS1aYS16MC05K1xcLz1cXHNdKz8pLS0tLS1FTkQgXFwxLS0tLS0vZztcbiAgdmFyIHJIZWFkZXIgPSAvKFtcXHgyMS1cXHg3ZV0rKTpcXHMqKFtcXHgyMS1cXHg3ZVxcc146XSspLztcbiAgdmFyIHJDUkxGID0gL1xccj9cXG4vO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlKHRydWUpIHtcbiAgICBtYXRjaCA9IHJNZXNzYWdlLmV4ZWMoc3RyKTtcbiAgICBpZighbWF0Y2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtc2cgPSB7XG4gICAgICB0eXBlOiBtYXRjaFsxXSxcbiAgICAgIHByb2NUeXBlOiBudWxsLFxuICAgICAgY29udGVudERvbWFpbjogbnVsbCxcbiAgICAgIGRla0luZm86IG51bGwsXG4gICAgICBoZWFkZXJzOiBbXSxcbiAgICAgIGJvZHk6IGZvcmdlLnV0aWwuZGVjb2RlNjQobWF0Y2hbM10pXG4gICAgfTtcbiAgICBydmFsLnB1c2gobXNnKTtcblxuICAgIC8vIG5vIGhlYWRlcnNcbiAgICBpZighbWF0Y2hbMl0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGhlYWRlcnNcbiAgICB2YXIgbGluZXMgPSBtYXRjaFsyXS5zcGxpdChyQ1JMRik7XG4gICAgdmFyIGxpID0gMDtcbiAgICB3aGlsZShtYXRjaCAmJiBsaSA8IGxpbmVzLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0IGxpbmUsIHRyaW0gYW55IHJocyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xpXS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcblxuICAgICAgLy8gUkZDMjgyMiB1bmZvbGQgYW55IGZvbGxvd2luZyBmb2xkZWQgbGluZXNcbiAgICAgIGZvcih2YXIgbmwgPSBsaSArIDE7IG5sIDwgbGluZXMubGVuZ3RoOyArK25sKSB7XG4gICAgICAgIHZhciBuZXh0ID0gbGluZXNbbmxdO1xuICAgICAgICBpZighL1xccy8udGVzdChuZXh0WzBdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gbmV4dDtcbiAgICAgICAgbGkgPSBubDtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgaGVhZGVyXG4gICAgICBtYXRjaCA9IGxpbmUubWF0Y2gockhlYWRlcik7XG4gICAgICBpZihtYXRjaCkge1xuICAgICAgICB2YXIgaGVhZGVyID0ge25hbWU6IG1hdGNoWzFdLCB2YWx1ZXM6IFtdfTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG1hdGNoWzJdLnNwbGl0KCcsJyk7XG4gICAgICAgIGZvcih2YXIgdmkgPSAwOyB2aSA8IHZhbHVlcy5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsdWVzLnB1c2gobHRyaW0odmFsdWVzW3ZpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvYy1UeXBlIG11c3QgYmUgdGhlIGZpcnN0IGhlYWRlclxuICAgICAgICBpZighbXNnLnByb2NUeXBlKSB7XG4gICAgICAgICAgaWYoaGVhZGVyLm5hbWUgIT09ICdQcm9jLVR5cGUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICdlbmNhcHN1bGF0ZWQgaGVhZGVyIG11c3QgYmUgXCJQcm9jLVR5cGVcIi4nKTtcbiAgICAgICAgICB9IGVsc2UgaWYoaGVhZGVyLnZhbHVlcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIlByb2MtVHlwZVwiICcgK1xuICAgICAgICAgICAgICAnaGVhZGVyIG11c3QgaGF2ZSB0d28gc3ViZmllbGRzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cucHJvY1R5cGUgPSB7dmVyc2lvbjogdmFsdWVzWzBdLCB0eXBlOiB2YWx1ZXNbMV19O1xuICAgICAgICB9IGVsc2UgaWYoIW1zZy5jb250ZW50RG9tYWluICYmIGhlYWRlci5uYW1lID09PSAnQ29udGVudC1Eb21haW4nKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbC1jYXNlIENvbnRlbnQtRG9tYWluXG4gICAgICAgICAgbXNnLmNvbnRlbnREb21haW4gPSB2YWx1ZXNbMF0gfHwgJyc7XG4gICAgICAgIH0gZWxzZSBpZighbXNnLmRla0luZm8gJiYgaGVhZGVyLm5hbWUgPT09ICdERUstSW5mbycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsLWNhc2UgREVLLUluZm9cbiAgICAgICAgICBpZihoZWFkZXIudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiREVLLUluZm9cIiAnICtcbiAgICAgICAgICAgICAgJ2hlYWRlciBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHN1YmZpZWxkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cuZGVrSW5mbyA9IHthbGdvcml0aG06IHZhbHVlc1swXSwgcGFyYW1ldGVyczogdmFsdWVzWzFdIHx8IG51bGx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zZy5oZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICArK2xpO1xuICAgIH1cblxuICAgIGlmKG1zZy5wcm9jVHlwZSA9PT0gJ0VOQ1JZUFRFRCcgJiYgIW1zZy5kZWtJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgXCJERUstSW5mb1wiICcgK1xuICAgICAgICAnaGVhZGVyIG11c3QgYmUgcHJlc2VudCBpZiBcIlByb2MtVHlwZVwiIGlzIFwiRU5DUllQVEVEXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYocnZhbC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLicpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG5mdW5jdGlvbiBmb2xkSGVhZGVyKGhlYWRlcikge1xuICB2YXIgcnZhbCA9IGhlYWRlci5uYW1lICsgJzogJztcblxuICAvLyBlbnN1cmUgdmFsdWVzIHdpdGggQ1JMRiBhcmUgZm9sZGVkXG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGluc2VydFNwYWNlID0gZnVuY3Rpb24obWF0Y2gsICQxKSB7XG4gICAgcmV0dXJuICcgJyArICQxO1xuICB9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaGVhZGVyLnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhbHVlcy5wdXNoKGhlYWRlci52YWx1ZXNbaV0ucmVwbGFjZSgvXihcXFMrXFxyXFxuKS8sIGluc2VydFNwYWNlKSk7XG4gIH1cbiAgcnZhbCArPSB2YWx1ZXMuam9pbignLCcpICsgJ1xcclxcbic7XG5cbiAgLy8gZG8gZm9sZGluZ1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIGNhbmRpZGF0ZSA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgcnZhbC5sZW5ndGg7ICsraSwgKytsZW5ndGgpIHtcbiAgICBpZihsZW5ndGggPiA2NSAmJiBjYW5kaWRhdGUgIT09IC0xKSB7XG4gICAgICB2YXIgaW5zZXJ0ID0gcnZhbFtjYW5kaWRhdGVdO1xuICAgICAgaWYoaW5zZXJ0ID09PSAnLCcpIHtcbiAgICAgICAgKytjYW5kaWRhdGU7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICsgJ1xcclxcbiAnICsgcnZhbC5zdWJzdHIoY2FuZGlkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICtcbiAgICAgICAgICAnXFxyXFxuJyArIGluc2VydCArIHJ2YWwuc3Vic3RyKGNhbmRpZGF0ZSArIDEpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gKGkgLSBjYW5kaWRhdGUgLSAxKTtcbiAgICAgIGNhbmRpZGF0ZSA9IC0xO1xuICAgICAgKytpO1xuICAgIH0gZWxzZSBpZihydmFsW2ldID09PSAnICcgfHwgcnZhbFtpXSA9PT0gJ1xcdCcgfHwgcnZhbFtpXSA9PT0gJywnKSB7XG4gICAgICBjYW5kaWRhdGUgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuXG5mdW5jdGlvbiBsdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBQYXNzd29yZC1iYXNlZCBlbmNyeXB0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICogQGF1dGhvciBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBBbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbzpcbiAqXG4gKiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBlbmNyeXB0aW9uQWxnb3JpdGhtICBFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGF0YSAgICAgICAgRW5jcnlwdGVkRGF0YSB9XG4gKlxuICogRW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBPQ1RFVCBTVFJJTkdcbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbl9fd2VicGFja19yZXF1aXJlX18oNSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbl9fd2VicGFja19yZXF1aXJlX18oNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5pZih0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG59XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLyogUGFzc3dvcmQtYmFzZWQgZW5jcnlwdGlvbiBpbXBsZW1lbnRhdGlvbi4gKi9cbnZhciBwa2kgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG5tb2R1bGUuZXhwb3J0cyA9IHBraS5wYmUgPSBmb3JnZS5wYmUgPSBmb3JnZS5wYmUgfHwge307XG52YXIgb2lkcyA9IHBraS5vaWRzO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgdy9hbGdvcml0aG0gcGFyYW1zXG52YXIgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uZW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2VuY3J5cHRpb25PaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIucGFyYW1ldGVycycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGlvblBhcmFtcydcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gZW5jcnlwdGVkRGF0YVxuICAgIG5hbWU6ICdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5lbmNyeXB0ZWREYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnZW5jcnlwdGVkRGF0YSdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBQQkVTMkFsZ29yaXRobXMgc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3L1BCS0RGMiArIEFFUyBlbmNyeXB0aW9uIHNjaGVtZXNcbnZhciBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMua2V5RGVyaXZhdGlvbkZ1bmMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jLm9pZCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2tkZk9pZCdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5zYWx0JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2tkZlNhbHQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLml0ZXJhdGlvbkNvdW50JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAna2RmSXRlcmF0aW9uQ291bnQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLmtleUxlbmd0aCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdrZXlMZW5ndGgnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHByZlxuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYuYWxnb3JpdGhtJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogJ3ByZk9pZCdcbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZS5vaWQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5lbmNyeXB0aW9uU2NoZW1lLml2JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNJdidcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zLnNhbHQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzYWx0J1xuICB9LCB7XG4gICAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMuaXRlcmF0aW9ucycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnaXRlcmF0aW9ucydcbiAgfV1cbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QsIHByb2R1Y2luZyBhbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqXG4gKiBQQkVTMkFsZ29yaXRobXMgQUxHT1JJVEhNLUlERU5USUZJRVIgOjo9XG4gKiAgIHsge1BCRVMyLXBhcmFtcyBJREVOVElGSUVEIEJZIGlkLVBCRVMyfSwgLi4ufVxuICpcbiAqIGlkLVBCRVMyIE9CSkVDVCBJREVOVElGSUVSIDo6PSB7cGtjcy01IDEzfVxuICpcbiAqIFBCRVMyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBrZXlEZXJpdmF0aW9uRnVuYyBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJFUzItS0RGc319LFxuICogICBlbmNyeXB0aW9uU2NoZW1lIEFsZ29yaXRobUlkZW50aWZpZXIge3tQQkVTMi1FbmNzfX1cbiAqIH1cbiAqXG4gKiBQQkVTMi1LREZzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PVxuICogICB7IHtQQktERjItcGFyYW1zIElERU5USUZJRUQgQlkgaWQtUEJLREYyfSwgLi4uIH1cbiAqXG4gKiBQQkVTMi1FbmNzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PSB7IC4uLiB9XG4gKlxuICogUEJLREYyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBzYWx0IENIT0lDRSB7XG4gKiAgICAgc3BlY2lmaWVkIE9DVEVUIFNUUklORyxcbiAqICAgICBvdGhlclNvdXJjZSBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVNhbHRTb3VyY2VzfX1cbiAqICAgfSxcbiAqICAgaXRlcmF0aW9uQ291bnQgSU5URUdFUiAoMS4uTUFYKSxcbiAqICAga2V5TGVuZ3RoIElOVEVHRVIgKDEuLk1BWCkgT1BUSU9OQUwsXG4gKiAgIHByZiBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVBSRnN9fSBERUZBVUxUIGFsZ2lkLWhtYWNXaXRoU0hBMVxuICogfVxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZW5jcnlwdCB3aXRoLlxuICogQHBhcmFtIG9wdGlvbnM6XG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ2FlczEyOCcsICdhZXMxOTInLCAnYWVzMjU2JywgJzNkZXMnKSwgZGVmYXVsdHMgdG8gJ2FlczEyOCcuXG4gKiAgICAgICAgICBjb3VudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplIHRoZSBzYWx0IHNpemUgdG8gdXNlLlxuICogICAgICAgICAgcHJmQWxnb3JpdGhtIHRoZSBQUkYgbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJylcbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyA9IGZ1bmN0aW9uKG9iaiwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5zYWx0U2l6ZSA9IG9wdGlvbnMuc2FsdFNpemUgfHwgODtcbiAgb3B0aW9ucy5jb3VudCA9IG9wdGlvbnMuY291bnQgfHwgMjA0ODtcbiAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCAnYWVzMTI4JztcbiAgb3B0aW9ucy5wcmZBbGdvcml0aG0gPSBvcHRpb25zLnByZkFsZ29yaXRobSB8fCAnc2hhMSc7XG5cbiAgLy8gZ2VuZXJhdGUgUEJFIHBhcmFtc1xuICB2YXIgc2FsdCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMob3B0aW9ucy5zYWx0U2l6ZSk7XG4gIHZhciBjb3VudCA9IG9wdGlvbnMuY291bnQ7XG4gIHZhciBjb3VudEJ5dGVzID0gYXNuMS5pbnRlZ2VyVG9EZXIoY291bnQpO1xuICB2YXIgZGtMZW47XG4gIHZhciBlbmNyeXB0aW9uQWxnb3JpdGhtO1xuICB2YXIgZW5jcnlwdGVkRGF0YTtcbiAgaWYob3B0aW9ucy5hbGdvcml0aG0uaW5kZXhPZignYWVzJykgPT09IDAgfHwgb3B0aW9ucy5hbGdvcml0aG0gPT09ICdkZXMnKSB7XG4gICAgLy8gZG8gUEJFUzJcbiAgICB2YXIgaXZMZW4sIGVuY09pZCwgY2lwaGVyRm47XG4gICAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnYWVzMTI4JzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBpdkxlbiA9IDE2O1xuICAgICAgZW5jT2lkID0gb2lkc1snYWVzMTI4LUNCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FlczE5Mic6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgaXZMZW4gPSAxNjtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2FlczE5Mi1DQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZXMyNTYnOlxuICAgICAgZGtMZW4gPSAzMjtcbiAgICAgIGl2TGVuID0gMTY7XG4gICAgICBlbmNPaWQgPSBvaWRzWydhZXMyNTYtQ0JDJ107XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVzJzpcbiAgICAgIGRrTGVuID0gODtcbiAgICAgIGl2TGVuID0gODtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2Rlc0NCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHByaXZhdGUga2V5LiBVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gICAgdmFyIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aCcgKyBvcHRpb25zLnByZkFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBtZCA9IHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xuXG4gICAgLy8gZW5jcnlwdCBwcml2YXRlIGtleSB1c2luZyBwYmUgU0hBLTEgYW5kIEFFUy9ERVNcbiAgICB2YXIgZGsgPSBmb3JnZS5wa2NzNS5wYmtkZjIocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgbWQpO1xuICAgIHZhciBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoaXZMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIob2JqKSk7XG4gICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgIGVuY3J5cHRlZERhdGEgPSBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKCk7XG5cbiAgICAvLyBnZXQgUEJLREYyLXBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBjcmVhdGVQYmtkZjJQYXJhbXMoc2FsdCwgY291bnRCeXRlcywgZGtMZW4sIHByZkFsZ29yaXRobSk7XG5cbiAgICBlbmNyeXB0aW9uQWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQkVTMiddKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8ga2V5RGVyaXZhdGlvbkZ1bmNcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQktERjInXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gUEJLREYyLXBhcmFtc1xuICAgICAgICAgIHBhcmFtc1xuICAgICAgICBdKSxcbiAgICAgICAgLy8gZW5jcnlwdGlvblNjaGVtZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihlbmNPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgIC8vIGl2XG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgaXYpXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2UgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICczZGVzJykge1xuICAgIC8vIERvIFBLQ1MxMiBQQkVcbiAgICBka0xlbiA9IDI0O1xuXG4gICAgdmFyIHNhbHRCeXRlcyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoc2FsdCk7XG4gICAgdmFyIGRrID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdEJ5dGVzLCAxLCBjb3VudCwgZGtMZW4pO1xuICAgIHZhciBpdiA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHRCeXRlcywgMiwgY291bnQsIGRrTGVuKTtcbiAgICB2YXIgY2lwaGVyID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIoZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShhc24xLnRvRGVyKG9iaikpO1xuICAgIGNpcGhlci5maW5pc2goKTtcbiAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwa2NzLTEyUGJlUGFyYW1zXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIHNhbHRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNhbHQpLFxuICAgICAgICAvLyBpdGVyYXRpb24gY291bnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKCkpXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgcHJpdmF0ZSBrZXkuIFVua25vd24gZW5jcnlwdGlvbiBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBlbmNyeXB0aW9uQWxnb3JpdGhtXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSxcbiAgICAvLyBlbmNyeXB0ZWREYXRhXG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgZW5jcnlwdGVkRGF0YSlcbiAgXSk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mbyBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8gPSBmdW5jdGlvbihvYmosIHBhc3N3b3JkKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBjaXBoZXJcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNyeXB0aW9uT2lkKTtcbiAgdmFyIGNpcGhlciA9IHBraS5wYmUuZ2V0Q2lwaGVyKG9pZCwgY2FwdHVyZS5lbmNyeXB0aW9uUGFyYW1zLCBwYXNzd29yZCk7XG5cbiAgLy8gZ2V0IGVuY3J5cHRlZCBkYXRhXG4gIHZhciBlbmNyeXB0ZWQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmVuY3J5cHRlZERhdGEpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgcnZhbCA9IGFzbjEuZnJvbURlcihjaXBoZXIub3V0cHV0KTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGVwa2kgdGhlIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0gPSBmdW5jdGlvbihlcGtpLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKGVwa2kpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBFTS1lbmNvZGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIEFTTi4xIGZvcm1hdC4gRGVjcnlwdGlvblxuICogaXMgbm90IHBlcmZvcm1lZC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBpbiBQRU0tZm9ybWF0LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kuZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICByZXR1cm4gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYW4gUlNBIHByaXZhdGUga2V5LiBCeSBkZWZhdWx0LCB0aGUga2V5IHdpbGwgYmUgd3JhcHBlZCBpblxuICogYSBQcml2YXRlS2V5SW5mbyBhbmQgZW5jcnlwdGVkIHRvIHByb2R1Y2UgYSBQS0NTIzggRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKiBUaGlzIGlzIHRoZSBzdGFuZGFyZCwgcHJlZmVycmVkIHdheSB0byBlbmNyeXB0IGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogVG8gcHJvZHVjZSBhIG5vbi1zdGFuZGFyZCBQRU0tZW5jcnlwdGVkIHByaXZhdGUga2V5IHRoYXQgdXNlcyBlbmNhcHN1bGF0ZWRcbiAqIGhlYWRlcnMgdG8gaW5kaWNhdGUgdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIChvbGQtc3R5bGUgbm9uLVBLQ1MjOCBPcGVuU1NMXG4gKiBwcml2YXRlIGtleSBlbmNyeXB0aW9uKSwgc2V0IHRoZSAnbGVnYWN5JyBvcHRpb24gdG8gdHJ1ZS4gTm90ZTogVXNpbmcgdGhpc1xuICogb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byBiZSBmb3JjZWQgdG8gMS5cbiAqXG4gKiBOb3RlOiBUaGUgJ2RlcycgYWxnb3JpdGhtIGlzIHN1cHBvcnRlZCwgYnV0IGl0IGlzIG5vdCBjb25zaWRlcmVkIHRvIGJlXG4gKiBzZWN1cmUgYmVjYXVzZSBpdCBvbmx5IHVzZXMgYSBzaW5nbGUgNTYtYml0IGtleS4gSWYgcG9zc2libGUsIGl0IGlzIGhpZ2hseVxuICogcmVjb21tZW5kZWQgdGhhdCBhIGRpZmZlcmVudCBhbGdvcml0aG0gYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBSU0Ega2V5IHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtOiB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gdG8gdXNlXG4gKiAgICAgICAgICAgICgnYWVzMTI4JywgJ2FlczE5MicsICdhZXMyNTYnLCAnM2RlcycsICdkZXMnKS5cbiAqICAgICAgICAgIGNvdW50OiB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplOiB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIGxlZ2FjeTogb3V0cHV0IGFuIG9sZCBub24tUEtDUyM4IFBFTS1lbmNyeXB0ZWQrZW5jYXBzdWxhdGVkXG4gKiAgICAgICAgICAgIGhlYWRlcnMgKERFSy1JbmZvKSBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZW5jb2RlZCBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAvLyBzdGFuZGFyZCBQS0NTIzhcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCFvcHRpb25zLmxlZ2FjeSkge1xuICAgIC8vIGVuY3J5cHQgUHJpdmF0ZUtleUluZm9cbiAgICB2YXIgcnZhbCA9IHBraS53cmFwUnNhUHJpdmF0ZUtleShwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKTtcbiAgICBydmFsID0gcGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhydmFsLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0ocnZhbCk7XG4gIH1cblxuICAvLyBsZWdhY3kgbm9uLVBLQ1MjOFxuICB2YXIgYWxnb3JpdGhtO1xuICB2YXIgaXY7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgY2FzZSAnYWVzMTI4JzpcbiAgICBhbGdvcml0aG0gPSAnQUVTLTEyOC1DQkMnO1xuICAgIGRrTGVuID0gMTY7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMxOTInOlxuICAgIGFsZ29yaXRobSA9ICdBRVMtMTkyLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczI1Nic6XG4gICAgYWxnb3JpdGhtID0gJ0FFUy0yNTYtQ0JDJztcbiAgICBka0xlbiA9IDMyO1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYygxNik7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnM2Rlcyc6XG4gICAgYWxnb3JpdGhtID0gJ0RFUy1FREUzLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCk7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzJzpcbiAgICBhbGdvcml0aG0gPSAnREVTLUNCQyc7XG4gICAgZGtMZW4gPSA4O1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYyg4KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGVuY3J5cHQgUlNBIHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCAnICtcbiAgICAgICdlbmNyeXB0aW9uIGFsZ29yaXRobSBcIicgKyBvcHRpb25zLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgT3BlblNTTCBsZWdhY3kga2V5IGRlcml2YXRpb25cbiAgdmFyIGRrID0gZm9yZ2UucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyhwYXNzd29yZCwgaXYuc3Vic3RyKDAsIDgpLCBka0xlbik7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIGNpcGhlci51cGRhdGUoYXNuMS50b0Rlcihwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKSk7XG4gIGNpcGhlci5maW5pc2goKTtcblxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFJJVkFURSBLRVknLFxuICAgIHByb2NUeXBlOiB7XG4gICAgICB2ZXJzaW9uOiAnNCcsXG4gICAgICB0eXBlOiAnRU5DUllQVEVEJ1xuICAgIH0sXG4gICAgZGVrSW5mbzoge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBwYXJhbWV0ZXJzOiBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoaXYpLnRvVXBwZXJDYXNlKClcbiAgICB9LFxuICAgIGJvZHk6IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2cpO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhbiBSU0EgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBkZWNyeXB0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgUlNBIGtleSBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHBlbSwgcGFzc3dvcmQpIHtcbiAgdmFyIHJ2YWwgPSBudWxsO1xuXG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknICYmXG4gICAgbXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1JTQSBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgJyArXG4gICAgICAnaXMgbm90IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIsIFwiUFJJVkFURSBLRVlcIiwgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gZXJyb3I7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdmFyIGRrTGVuO1xuICAgIHZhciBjaXBoZXJGbjtcbiAgICBzd2l0Y2gobXNnLmRla0luZm8uYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnREVTLUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnREVTLUVERTMtQ0JDJzpcbiAgICAgIGRrTGVuID0gMjQ7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQUVTLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBRVMtMTkyLUNCQyc6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FFUy0yNTYtQ0JDJzpcbiAgICAgIGRrTGVuID0gMzI7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTQwLUNCQyc6XG4gICAgICBka0xlbiA9IDU7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTY0LUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA2NCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBmb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGRlY3J5cHQgcHJpdmF0ZSBrZXk7IHVuc3VwcG9ydGVkICcgK1xuICAgICAgICAnZW5jcnlwdGlvbiBhbGdvcml0aG0gXCInICsgbXNnLmRla0luZm8uYWxnb3JpdGhtICsgJ1wiLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gbXNnLmRla0luZm8uYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gdXNlIE9wZW5TU0wgbGVnYWN5IGtleSBkZXJpdmF0aW9uXG4gICAgdmFyIGl2ID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpO1xuICAgIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG1zZy5ib2R5KSk7XG4gICAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICBydmFsID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCA9IG1zZy5ib2R5O1xuICB9XG5cbiAgaWYobXNnLnR5cGUgPT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknKSB7XG4gICAgcnZhbCA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYXNuMS5mcm9tRGVyKHJ2YWwpLCBwYXNzd29yZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVjcnlwdGlvbiBhbHJlYWR5IHBlcmZvcm1lZCBhYm92ZVxuICAgIHJ2YWwgPSBhc24xLmZyb21EZXIocnZhbCk7XG4gIH1cblxuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgcnZhbCA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEocnZhbCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleSA9IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBpZCwgaXRlciwgbiwgbWQpIHtcbiAgdmFyIGosIGw7XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIGlmKCEoJ3NoYTEnIGluIGZvcmdlLm1kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNoYTFcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9XG5cbiAgdmFyIHUgPSBtZC5kaWdlc3RMZW5ndGg7XG4gIHZhciB2ID0gbWQuYmxvY2tMZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgLyogQ29udmVydCBwYXNzd29yZCB0byBVbmljb2RlIGJ5dGUgYnVmZmVyICsgdHJhaWxpbmcgMC1ieXRlLiAqL1xuICB2YXIgcGFzc0J1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgaWYocGFzc3dvcmQgIT09IG51bGwgJiYgcGFzc3dvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvcihsID0gMDsgbCA8IHBhc3N3b3JkLmxlbmd0aDsgbCsrKSB7XG4gICAgICBwYXNzQnVmLnB1dEludDE2KHBhc3N3b3JkLmNoYXJDb2RlQXQobCkpO1xuICAgIH1cbiAgICBwYXNzQnVmLnB1dEludDE2KDApO1xuICB9XG5cbiAgLyogTGVuZ3RoIG9mIHNhbHQgYW5kIHBhc3N3b3JkIGluIEJZVEVTLiAqL1xuICB2YXIgcCA9IHBhc3NCdWYubGVuZ3RoKCk7XG4gIHZhciBzID0gc2FsdC5sZW5ndGgoKTtcblxuICAvKiAxLiBDb25zdHJ1Y3QgYSBzdHJpbmcsIEQgKHRoZSBcImRpdmVyc2lmaWVyXCIpLCBieSBjb25jYXRlbmF0aW5nXG4gICAgICAgIHYgY29waWVzIG9mIElELiAqL1xuICB2YXIgRCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgRC5maWxsV2l0aEJ5dGUoaWQsIHYpO1xuXG4gIC8qIDIuIENvbmNhdGVuYXRlIGNvcGllcyBvZiB0aGUgc2FsdCB0b2dldGhlciB0byBjcmVhdGUgYSBzdHJpbmcgUyBvZiBsZW5ndGhcbiAgICAgICAgdiAqIGNlaWwocyAvIHYpIGJ5dGVzICh0aGUgZmluYWwgY29weSBvZiB0aGUgc2FsdCBtYXkgYmUgdHJ1bmFjdGVkXG4gICAgICAgIHRvIGNyZWF0ZSBTKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBzYWx0IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc28gaXMgUy4gKi9cbiAgdmFyIFNsZW4gPSB2ICogTWF0aC5jZWlsKHMgLyB2KTtcbiAgdmFyIFMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIGZvcihsID0gMDsgbCA8IFNsZW47IGwrKykge1xuICAgIFMucHV0Qnl0ZShzYWx0LmF0KGwgJSBzKSk7XG4gIH1cblxuICAvKiAzLiBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgdGhlIHBhc3N3b3JkIHRvZ2V0aGVyIHRvIGNyZWF0ZSBhIHN0cmluZyBQIG9mXG4gICAgICAgIGxlbmd0aCB2ICogY2VpbChwIC8gdikgYnl0ZXMgKHRoZSBmaW5hbCBjb3B5IG9mIHRoZSBwYXNzd29yZCBtYXkgYmVcbiAgICAgICAgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBQKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBwYXNzd29yZCBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNvIGlzIFAuICovXG4gIHZhciBQbGVuID0gdiAqIE1hdGguY2VpbChwIC8gdik7XG4gIHZhciBQID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICBmb3IobCA9IDA7IGwgPCBQbGVuOyBsKyspIHtcbiAgICBQLnB1dEJ5dGUocGFzc0J1Zi5hdChsICUgcCkpO1xuICB9XG5cbiAgLyogNC4gU2V0IEk9U3x8UCB0byBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBTIGFuZCBQLiAqL1xuICB2YXIgSSA9IFM7XG4gIEkucHV0QnVmZmVyKFApO1xuXG4gIC8qIDUuIFNldCBjPWNlaWwobiAvIHUpLiAqL1xuICB2YXIgYyA9IE1hdGguY2VpbChuIC8gdSk7XG5cbiAgLyogNi4gRm9yIGk9MSwgMiwgLi4uLCBjLCBkbyB0aGUgZm9sbG93aW5nOiAqL1xuICBmb3IodmFyIGkgPSAxOyBpIDw9IGM7IGkrKykge1xuICAgIC8qIGEpIFNldCBBaT1IXnIoRHx8SSkuIChsLmUuIHRoZSBydGggaGFzaCBvZiBEfHxJLCBIKEgoSCguLi5IKER8fEkpKSkpICovXG4gICAgdmFyIGJ1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBidWYucHV0Qnl0ZXMoRC5ieXRlcygpKTtcbiAgICBidWYucHV0Qnl0ZXMoSS5ieXRlcygpKTtcbiAgICBmb3IodmFyIHJvdW5kID0gMDsgcm91bmQgPCBpdGVyOyByb3VuZCsrKSB7XG4gICAgICBtZC5zdGFydCgpO1xuICAgICAgbWQudXBkYXRlKGJ1Zi5nZXRCeXRlcygpKTtcbiAgICAgIGJ1ZiA9IG1kLmRpZ2VzdCgpO1xuICAgIH1cblxuICAgIC8qIGIpIENvbmNhdGVuYXRlIGNvcGllcyBvZiBBaSB0byBjcmVhdGUgYSBzdHJpbmcgQiBvZiBsZW5ndGggdiBieXRlcyAodGhlXG4gICAgICAgICAgZmluYWwgY29weSBvZiBBaSBtYXkgYmUgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBCKS4gKi9cbiAgICB2YXIgQiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBmb3IobCA9IDA7IGwgPCB2OyBsKyspIHtcbiAgICAgIEIucHV0Qnl0ZShidWYuYXQobCAlIHUpKTtcbiAgICB9XG5cbiAgICAvKiBjKSBUcmVhdGluZyBJIGFzIGEgY29uY2F0ZW5hdGlvbiBJMCwgSTEsIC4uLiwgSWstMSBvZiB2LWJ5dGUgYmxvY2tzLFxuICAgICAgICAgIHdoZXJlIGs9Y2VpbChzIC8gdikgKyBjZWlsKHAgLyB2KSwgbW9kaWZ5IEkgYnkgc2V0dGluZ1xuICAgICAgICAgIElqPShJaitCKzEpIG1vZCAydiBmb3IgZWFjaCBqLiAgKi9cbiAgICB2YXIgayA9IE1hdGguY2VpbChzIC8gdikgKyBNYXRoLmNlaWwocCAvIHYpO1xuICAgIHZhciBJbmV3ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIGZvcihqID0gMDsgaiA8IGs7IGorKykge1xuICAgICAgdmFyIGNodW5rID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihJLmdldEJ5dGVzKHYpKTtcbiAgICAgIHZhciB4ID0gMHgxZmY7XG4gICAgICBmb3IobCA9IEIubGVuZ3RoKCkgLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICB4ID0geCA+PiA4O1xuICAgICAgICB4ICs9IEIuYXQobCkgKyBjaHVuay5hdChsKTtcbiAgICAgICAgY2h1bmsuc2V0QXQobCwgeCAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgSW5ldy5wdXRCdWZmZXIoY2h1bmspO1xuICAgIH1cbiAgICBJID0gSW5ldztcblxuICAgIC8qIEFkZCBBaSB0byBBLiAqL1xuICAgIHJlc3VsdC5wdXRCdWZmZXIoYnVmKTtcbiAgfVxuXG4gIHJlc3VsdC50cnVuY2F0ZShyZXN1bHQubGVuZ3RoKCkgLSBuKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvaWQgdGhlIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIHBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlciA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICBzd2l0Y2gob2lkKSB7XG4gIGNhc2UgcGtpLm9pZHNbJ3BrY3M1UEJFUzInXTpcbiAgICByZXR1cm4gcGtpLnBiZS5nZXRDaXBoZXJGb3JQQkVTMihvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGNhc2UgcGtpLm9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXTpcbiAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgIHJldHVybiBwa2kucGJlLmdldENpcGhlckZvclBLQ1MxMlBCRShvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGRlZmF1bHQ6XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgUEJFIGRhdGEgYmxvY2suIFVuc3VwcG9ydGVkIE9JRC4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcbiAgICAgICdwa2NzNVBCRVMyJyxcbiAgICAgICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyxcbiAgICAgICdwYmV3aXRoU0hBQW5kNDBCaXRSQzItQ0JDJ1xuICAgIF07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlIGFjY29yZGluZyB0byBQQkVTMiBwYXJhbXMgYmxvY2suXG4gKlxuICogVGhlIHJldHVybmVkIGNpcGhlciBpbnN0YW5jZSBpcyBhbHJlYWR5IHN0YXJ0ZWQgdXNpbmcgdGhlIElWXG4gKiBmcm9tIFBCRVMyIHBhcmFtZXRlciBibG9jay5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBQS0NTIzUgUEJLREYyIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIFBCRVMyLXBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlckZvclBCRVMyID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY2hlY2sgb2lkc1xuICBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUua2RmT2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkc1sncGtjczVQQktERjInXSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBPSUQuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIGVycm9yLnN1cHBvcnRlZE9pZHMgPSBbJ3BrY3M1UEJLREYyJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmVuY09pZCk7XG4gIGlmKG9pZCAhPT0gcGtpLm9pZHNbJ2FlczEyOC1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczE5Mi1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczI1Ni1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2Rlcy1FREUzLUNCQyddICYmXG4gICAgb2lkICE9PSBwa2kub2lkc1snZGVzQ0JDJ10pIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBzY2hlbWUgT0lELicpO1xuICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gW1xuICAgICAgJ2FlczEyOC1DQkMnLCAnYWVzMTkyLUNCQycsICdhZXMyNTYtQ0JDJywgJ2Rlcy1FREUzLUNCQycsICdkZXNDQkMnXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIHNldCBQQkUgcGFyYW1zXG4gIHZhciBzYWx0ID0gY2FwdHVyZS5rZGZTYWx0O1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmtkZkl0ZXJhdGlvbkNvdW50KTtcbiAgY291bnQgPSBjb3VudC5nZXRJbnQoY291bnQubGVuZ3RoKCkgPDwgMyk7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gocGtpLm9pZHNbb2lkXSkge1xuICBjYXNlICdhZXMxMjgtQ0JDJzpcbiAgICBka0xlbiA9IDE2O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczE5Mi1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnYWVzMjU2LUNCQyc6XG4gICAgZGtMZW4gPSAzMjtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdkZXMtRURFMy1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzQ0JDJzpcbiAgICBka0xlbiA9IDg7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGdldCBQUkYgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIG1kID0gcHJmT2lkVG9NZXNzYWdlRGlnZXN0KGNhcHR1cmUucHJmT2lkKTtcblxuICAvLyBkZWNyeXB0IHByaXZhdGUga2V5IHVzaW5nIHBiZSB3aXRoIGNob3NlbiBQUkYgYW5kIEFFUy9ERVNcbiAgdmFyIGRrID0gZm9yZ2UucGtjczUucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgdmFyIGl2ID0gY2FwdHVyZS5lbmNJdjtcbiAgdmFyIGNpcGhlciA9IGNpcGhlckZuKGRrKTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBHZXQgbmV3IEZvcmdlIGNpcGhlciBvYmplY3QgaW5zdGFuY2UgZm9yIFBLQ1MjMTIgUEJFLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjaXBoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBzdGFydGVkIHVzaW5nIHRoZSBrZXkgJiBJVlxuICogZGVyaXZlZCBmcm9tIHRoZSBwcm92aWRlZCBwYXNzd29yZCBhbmQgUEtDUyMxMiBQQkUgc2FsdC5cbiAqXG4gKiBAcGFyYW0gb2lkIFRoZSBQS0NTIzEyIFBCRSBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBBU04uMSBQS0NTIzEyIFBCRS1wYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgbmV3IGNpcGhlciBvYmplY3QgaW5zdGFuY2UuXG4gKi9cbnBraS5wYmUuZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHNhbHQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnNhbHQpO1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLml0ZXJhdGlvbnMpO1xuICBjb3VudCA9IGNvdW50LmdldEludChjb3VudC5sZW5ndGgoKSA8PCAzKTtcblxuICB2YXIgZGtMZW4sIGRJdkxlbiwgY2lwaGVyRm47XG4gIHN3aXRjaChvaWQpIHtcbiAgICBjYXNlIHBraS5vaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ106XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLnN0YXJ0RGVjcnlwdGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgICAgZGtMZW4gPSA1O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5LCBpdikge1xuICAgICAgICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICAgIGNpcGhlci5zdGFydChpdiwgbnVsbCk7XG4gICAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTICMxMiBQQkUgZGF0YSBibG9jay4gVW5zdXBwb3J0ZWQgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG4gIHZhciBrZXkgPSBwa2kucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0LCAxLCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgbWQuc3RhcnQoKTtcbiAgdmFyIGl2ID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdCwgMiwgY291bnQsIGRJdkxlbiwgbWQpO1xuXG4gIHJldHVybiBjaXBoZXJGbihrZXksIGl2KTtcbn07XG5cbi8qKlxuICogT3BlblNTTCdzIGxlZ2FjeSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBTZWU6IGh0dHA6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgZnJvbS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0IHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBka0xlbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGRlcml2ZWQga2V5LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbbWRdIGFuIG9wdGlvbmFsIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UuXG4gKi9cbnBraS5wYmUub3BlbnNzbERlcml2ZUJ5dGVzID0gZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIGRrTGVuLCBtZCkge1xuICBpZih0eXBlb2YgbWQgPT09ICd1bmRlZmluZWQnIHx8IG1kID09PSBudWxsKSB7XG4gICAgaWYoISgnbWQ1JyBpbiBmb3JnZS5tZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZDVcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gIH1cbiAgaWYoc2FsdCA9PT0gbnVsbCkge1xuICAgIHNhbHQgPSAnJztcbiAgfVxuICB2YXIgZGlnZXN0cyA9IFtoYXNoKG1kLCBwYXNzd29yZCArIHNhbHQpXTtcbiAgZm9yKHZhciBsZW5ndGggPSAxNiwgaSA9IDE7IGxlbmd0aCA8IGRrTGVuOyArK2ksIGxlbmd0aCArPSAxNikge1xuICAgIGRpZ2VzdHMucHVzaChoYXNoKG1kLCBkaWdlc3RzW2kgLSAxXSArIHBhc3N3b3JkICsgc2FsdCkpO1xuICB9XG4gIHJldHVybiBkaWdlc3RzLmpvaW4oJycpLnN1YnN0cigwLCBka0xlbik7XG59O1xuXG5mdW5jdGlvbiBoYXNoKG1kLCBieXRlcykge1xuICByZXR1cm4gbWQuc3RhcnQoKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG59XG5cbmZ1bmN0aW9uIHByZk9pZFRvTWVzc2FnZURpZ2VzdChwcmZPaWQpIHtcbiAgLy8gZ2V0IFBSRiBhbGdvcml0aG0sIGRlZmF1bHQgdG8gU0hBLTFcbiAgdmFyIHByZkFsZ29yaXRobTtcbiAgaWYoIXByZk9pZCkge1xuICAgIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aFNIQTEnO1xuICB9IGVsc2Uge1xuICAgIHByZkFsZ29yaXRobSA9IHBraS5vaWRzW2FzbjEuZGVyVG9PaWQocHJmT2lkKV07XG4gICAgaWYoIXByZkFsZ29yaXRobSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQUkYgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gcHJmT2lkO1xuICAgICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgICAnaG1hY1dpdGhTSEExJywgJ2htYWNXaXRoU0hBMjI0JywgJ2htYWNXaXRoU0hBMjU2JywgJ2htYWNXaXRoU0hBMzg0JyxcbiAgICAgICAgJ2htYWNXaXRoU0hBNTEyJ107XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xufVxuXG5mdW5jdGlvbiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKSB7XG4gIHZhciBmYWN0b3J5ID0gZm9yZ2UubWQ7XG4gIHN3aXRjaChwcmZBbGdvcml0aG0pIHtcbiAgY2FzZSAnaG1hY1dpdGhTSEEyMjQnOlxuICAgIGZhY3RvcnkgPSBmb3JnZS5tZC5zaGE1MTI7XG4gIGNhc2UgJ2htYWNXaXRoU0hBMSc6XG4gIGNhc2UgJ2htYWNXaXRoU0hBMjU2JzpcbiAgY2FzZSAnaG1hY1dpdGhTSEEzODQnOlxuICBjYXNlICdobWFjV2l0aFNIQTUxMic6XG4gICAgcHJmQWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFJGIGFsZ29yaXRobS4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBwcmZBbGdvcml0aG07XG4gICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgJ2htYWNXaXRoU0hBMScsICdobWFjV2l0aFNIQTIyNCcsICdobWFjV2l0aFNIQTI1NicsICdobWFjV2l0aFNIQTM4NCcsXG4gICAgICAnaG1hY1dpdGhTSEE1MTInXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZighZmFjdG9yeSB8fCAhKHByZkFsZ29yaXRobSBpbiBmYWN0b3J5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIHByZkFsZ29yaXRobSk7XG4gIH1cbiAgcmV0dXJuIGZhY3RvcnlbcHJmQWxnb3JpdGhtXS5jcmVhdGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGJrZGYyUGFyYW1zKHNhbHQsIGNvdW50Qnl0ZXMsIGRrTGVuLCBwcmZBbGdvcml0aG0pIHtcbiAgdmFyIHBhcmFtcyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBzYWx0XG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2FsdCksXG4gICAgLy8gaXRlcmF0aW9uIGNvdW50XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGNvdW50Qnl0ZXMuZ2V0Qnl0ZXMoKSlcbiAgXSk7XG4gIC8vIHdoZW4gUFJGIGFsZ29yaXRobSBpcyBub3QgU0hBLTEgZGVmYXVsdCwgYWRkIGtleSBsZW5ndGggYW5kIFBSRiBhbGdvcml0aG1cbiAgaWYocHJmQWxnb3JpdGhtICE9PSAnaG1hY1dpdGhTSEExJykge1xuICAgIHBhcmFtcy52YWx1ZS5wdXNoKFxuICAgICAgLy8ga2V5IGxlbmd0aFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGRrTGVuLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllclxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHNbcHJmQWxnb3JpdGhtXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgXSkpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENpcGhlciBiYXNlIEFQSS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlciA9IGZvcmdlLmNpcGhlciB8fCB7fTtcblxuLy8gcmVnaXN0ZXJlZCBhbGdvcml0aG1zXG5mb3JnZS5jaXBoZXIuYWxnb3JpdGhtcyA9IGZvcmdlLmNpcGhlci5hbGdvcml0aG1zIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjaXBoZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlblxuICogYWxnb3JpdGhtIGFuZCBrZXkuIFRoZSBhbGdvcml0aG0gbWF5IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHZhbHVlIGZvciBhXG4gKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWxnb3JpdGhtIG9yIGl0IG1heSBiZSBnaXZlbiBhcyBhIGNpcGhlciBhbGdvcml0aG1cbiAqIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSwgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFsZ29yaXRobSBBUElcbiAqICAgICAgICAgIG9iamVjdC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGFcbiAqICAgICAgICAgIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiBmYWxzZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlY2lwaGVyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW5cbiAqIGFsZ29yaXRobSBhbmQga2V5LiBUaGUgYWxnb3JpdGhtIG1heSBiZSBwcm92aWRlZCBhcyBhIHN0cmluZyB2YWx1ZSBmb3IgYVxuICogcHJldmlvdXNseSByZWdpc3RlcmVkIGFsZ29yaXRobSBvciBpdCBtYXkgYmUgZ2l2ZW4gYXMgYSBjaXBoZXIgYWxnb3JpdGhtXG4gKiBBUEkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UsIGVpdGhlciBhIHN0cmluZyBvciBhbiBhbGdvcml0aG0gQVBJXG4gKiAgICAgICAgICBvYmplY3QuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlLCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvciBhXG4gKiAgICAgICAgICBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gYWxnb3JpdGhtIGJ5IG5hbWUuIElmIHRoZSBuYW1lIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIHRoZVxuICogYWxnb3JpdGhtIEFQSSBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIEFQSSBvYmplY3QuXG4gKi9cbmZvcmdlLmNpcGhlci5yZWdpc3RlckFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIGFsZ29yaXRobSkge1xuICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXSA9IGFsZ29yaXRobTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHJlZ2lzdGVyZWQgYWxnb3JpdGhtIGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhbGdvcml0aG0sIGlmIGZvdW5kLCBudWxsIGlmIG5vdC5cbiAqL1xuZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgaWYobmFtZSBpbiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtcykge1xuICAgIHJldHVybiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBCbG9ja0NpcGhlciA9IGZvcmdlLmNpcGhlci5CbG9ja0NpcGhlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgdGhpcy5tb2RlID0gdGhpcy5hbGdvcml0aG0ubW9kZTtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLm1vZGUuYmxvY2tTaXplO1xuICB0aGlzLl9maW5pc2ggPSBmYWxzZTtcbiAgdGhpcy5faW5wdXQgPSBudWxsO1xuICB0aGlzLm91dHB1dCA9IG51bGw7XG4gIHRoaXMuX29wID0gb3B0aW9ucy5kZWNyeXB0ID8gdGhpcy5tb2RlLmRlY3J5cHQgOiB0aGlzLm1vZGUuZW5jcnlwdDtcbiAgdGhpcy5fZGVjcnlwdCA9IG9wdGlvbnMuZGVjcnlwdDtcbiAgdGhpcy5hbGdvcml0aG0uaW5pdGlhbGl6ZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIG9yIHJlc3RhcnRzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcywgd2hpY2hldmVyXG4gKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICpcbiAqIEZvciBub24tR0NNIG1vZGUsIHRoZSBJViBtYXkgYmUgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5XG4gKiBvZiBieXRlcywgYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzLiBJZiB0aGUgSVYgaXMgaW5cbiAqIGJ5dGVzLCB0aGVuIGl0IG11c3QgYmUgTmIgKDE2KSBieXRlcyBpbiBsZW5ndGguIElmIHRoZSBJViBpcyBnaXZlbiBpbiBhc1xuICogMzItYml0IGludGVnZXJzLCB0aGVuIGl0IG11c3QgYmUgNCBpbnRlZ2VycyBsb25nLlxuICpcbiAqIE5vdGU6IGFuIElWIGlzIG5vdCByZXF1aXJlZCBvciB1c2VkIGluIEVDQiBtb2RlLlxuICpcbiAqIEZvciBHQ00tbW9kZSwgdGhlIElWIG11c3QgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3JcbiAqIGEgYnl0ZSBidWZmZXIuIFRoZSBudW1iZXIgb2YgYnl0ZXMgc2hvdWxkIGJlIDEyICg5NiBiaXRzKSBhcyByZWNvbW1lbmRlZFxuICogYnkgTklTVCBTUC04MDAtMzhEIGJ1dCBhbm90aGVyIGxlbmd0aCBtYXkgYmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2ZcbiAqICAgICAgICAgICAgYnl0ZXMsIG51bGwgdG8gcmV1c2UgdGhlIGxhc3QgY2lwaGVyZWQgYmxvY2sgZnJvbSBhIHByZXZpb3VzXG4gKiAgICAgICAgICAgIHVwZGF0ZSgpICh0aGlzIFwicmVzaWR1ZVwiIG1ldGhvZCBpcyBmb3IgbGVnYWN5IHN1cHBvcnQgb25seSkuXG4gKiAgICAgICAgICBhZGRpdGlvbmFsRGF0YSBhZGRpdGlvbmFsIGF1dGhlbnRpY2F0aW9uIGRhdGEgYXMgYSBiaW5hcnktZW5jb2RlZFxuICogICAgICAgICAgICBzdHJpbmcgb2YgYnl0ZXMsIGZvciAnR0NNJyBtb2RlLCAoZGVmYXVsdDogbm9uZSkuXG4gKiAgICAgICAgICB0YWdMZW5ndGggZGVzaXJlZCBsZW5ndGggb2YgYXV0aGVudGljYXRpb24gdGFnLCBpbiBiaXRzLCBmb3JcbiAqICAgICAgICAgICAgJ0dDTScgbW9kZSAoMC0xMjgsIGRlZmF1bHQ6IDEyOCkuXG4gKiAgICAgICAgICB0YWcgdGhlIGF1dGhlbnRpY2F0aW9uIHRhZyB0byBjaGVjayBpZiBkZWNyeXB0aW5nLCBhcyBhXG4gKiAgICAgICAgICAgICBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiAgICAgICAgICBvdXRwdXQgdGhlIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBvcHRzID0ge307XG4gIGZvcih2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICBvcHRzW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgb3B0cy5kZWNyeXB0ID0gdGhpcy5fZGVjcnlwdDtcbiAgdGhpcy5fZmluaXNoID0gZmFsc2U7XG4gIHRoaXMuX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5vdXRwdXQgPSBvcHRpb25zLm91dHB1dCB8fCBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLm1vZGUuc3RhcnQob3B0cyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBjaXBoZXIgbW9kZS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZihpbnB1dCkge1xuICAgIC8vIGlucHV0IGdpdmVuLCBzbyBlbXB0eSBpdCBpbnRvIHRoZSBpbnB1dCBidWZmZXJcbiAgICB0aGlzLl9pbnB1dC5wdXRCdWZmZXIoaW5wdXQpO1xuICB9XG5cbiAgLy8gZG8gY2lwaGVyIG9wZXJhdGlvbiB1bnRpbCBpdCBuZWVkcyBtb3JlIGlucHV0IGFuZCBub3QgZmluaXNoZWRcbiAgd2hpbGUoIXRoaXMuX29wLmNhbGwodGhpcy5tb2RlLCB0aGlzLl9pbnB1dCwgdGhpcy5vdXRwdXQsIHRoaXMuX2ZpbmlzaCkgJiZcbiAgICAhdGhpcy5fZmluaXNoKSB7fVxuXG4gIC8vIGZyZWUgY29uc3VtZWQgbWVtb3J5IGZyb20gaW5wdXQgYnVmZmVyXG4gIHRoaXMuX2lucHV0LmNvbXBhY3QoKTtcbn07XG5cbi8qKlxuICogRmluaXNoZXMgZW5jcnlwdGluZyBvciBkZWNyeXB0aW5nLlxuICpcbiAqIEBwYXJhbSBwYWQgYSBwYWRkaW5nIGZ1bmN0aW9uIHRvIHVzZSBpbiBDQkMgbW9kZSwgbnVsbCBmb3IgZGVmYXVsdCxcbiAqICAgICAgICAgIHNpZ25hdHVyZShibG9ja1NpemUsIGJ1ZmZlciwgZGVjcnlwdCkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICovXG5CbG9ja0NpcGhlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24ocGFkKSB7XG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHcvZGVwcmVjYXRlZCBwYWRkaW5nIEFQSVxuICAvLyBOb3RlOiB3aWxsIG92ZXJ3cml0ZSBwYWRkaW5nIGZ1bmN0aW9ucyBldmVuIGFmdGVyIGFub3RoZXIgc3RhcnQoKSBjYWxsXG4gIGlmKHBhZCAmJiAodGhpcy5tb2RlLm5hbWUgPT09ICdFQ0InIHx8IHRoaXMubW9kZS5uYW1lID09PSAnQ0JDJykpIHtcbiAgICB0aGlzLm1vZGUucGFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIGlucHV0LCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLm1vZGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIG91dHB1dCwgdHJ1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGJ1aWxkIG9wdGlvbnMgZm9yIHBhZGRpbmcgYW5kIGFmdGVyRmluaXNoIGZ1bmN0aW9uc1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICBvcHRpb25zLmRlY3J5cHQgPSB0aGlzLl9kZWNyeXB0O1xuXG4gIC8vIGdldCAjIG9mIGJ5dGVzIHRoYXQgd29uJ3QgZmlsbCBhIGJsb2NrXG4gIG9wdGlvbnMub3ZlcmZsb3cgPSB0aGlzLl9pbnB1dC5sZW5ndGgoKSAlIHRoaXMuYmxvY2tTaXplO1xuXG4gIGlmKCF0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS5wYWQpIHtcbiAgICBpZighdGhpcy5tb2RlLnBhZCh0aGlzLl9pbnB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBkbyBmaW5hbCB1cGRhdGVcbiAgdGhpcy5fZmluaXNoID0gdHJ1ZTtcbiAgdGhpcy51cGRhdGUoKTtcblxuICBpZih0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS51bnBhZCkge1xuICAgIGlmKCF0aGlzLm1vZGUudW5wYWQodGhpcy5vdXRwdXQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYodGhpcy5tb2RlLmFmdGVyRmluaXNoKSB7XG4gICAgaWYoIXRoaXMubW9kZS5hZnRlckZpbmlzaCh0aGlzLm91dHB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIFN1cHBvcnRlZCBjaXBoZXIgbW9kZXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyBzdXBwb3J0ZWQgY2lwaGVyIG1vZGVzXG52YXIgbW9kZXMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlci5tb2RlcyA9IGZvcmdlLmNpcGhlci5tb2RlcyB8fCB7fTtcblxuLyoqIEVsZWN0cm9uaWMgY29kZWJvb2sgKEVDQikgKERvbid0IHVzZSB0aGlzOyBpdCdzIG5vdCBzZWN1cmUpICoqL1xuXG5tb2Rlcy5lY2IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnRUNCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge307XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGRlY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gIHZhciBwYWRkaW5nID0gKGlucHV0Lmxlbmd0aCgpID09PSB0aGlzLmJsb2NrU2l6ZSA/XG4gICAgdGhpcy5ibG9ja1NpemUgOiAodGhpcy5ibG9ja1NpemUgLSBpbnB1dC5sZW5ndGgoKSkpO1xuICBpbnB1dC5maWxsV2l0aEJ5dGUocGFkZGluZywgcGFkZGluZyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCwgb3B0aW9ucykge1xuICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2tTaXplXG4gIGlmKG9wdGlvbnMub3ZlcmZsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZW5zdXJlIHBhZGRpbmcgYnl0ZSBjb3VudCBpcyB2YWxpZFxuICB2YXIgbGVuID0gb3V0cHV0Lmxlbmd0aCgpO1xuICB2YXIgY291bnQgPSBvdXRwdXQuYXQobGVuIC0gMSk7XG4gIGlmKGNvdW50ID4gKHRoaXMuYmxvY2tTaXplIDw8IDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICBvdXRwdXQudHJ1bmNhdGUoY291bnQpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKiBDaXBoZXItYmxvY2sgQ2hhaW5pbmcgKENCQykgKiovXG5cbm1vZGVzLmNiYyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDQkMnO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIE5vdGU6IGxlZ2FjeSBzdXBwb3J0IGZvciB1c2luZyBJViByZXNpZHVlIChoYXMgc2VjdXJpdHkgZmxhd3MpXG4gIC8vIGlmIElWIGlzIG51bGwsIHJldXNlIGJsb2NrIGZyb20gcHJldmlvdXMgcHJvY2Vzc2luZ1xuICBpZihvcHRpb25zLml2ID09PSBudWxsKSB7XG4gICAgLy8gbXVzdCBoYXZlIGEgcHJldmlvdXMgYmxvY2tcbiAgICBpZighdGhpcy5fcHJldikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5faXYgPSB0aGlzLl9wcmV2LnNsaWNlKDApO1xuICB9IGVsc2UgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzYXZlIElWIGFzIFwicHJldmlvdXNcIiBibG9ja1xuICAgIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdik7XG4gICAgdGhpcy5fcHJldiA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB9XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgLy8gQ0JDIFhPUidzIElWIChvciBwcmV2aW91cyBibG9jaykgd2l0aCBwbGFpbnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wcmV2W2ldIF4gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0LCBzYXZlIHByZXZpb3VzIGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9vdXRCbG9jaztcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBkZWNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dCwgc2F2ZSBwcmV2aW91cyBjaXBoZXJlZCBibG9ja1xuICAvLyBDQkMgWE9SJ3MgSVYgKG9yIHByZXZpb3VzIGJsb2NrKSB3aXRoIGNpcGhlcnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9wcmV2W2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9pbkJsb2NrLnNsaWNlKDApO1xufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gIC8vIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcGFkIGJ5dGVzKVxuICB2YXIgcGFkZGluZyA9IChpbnB1dC5sZW5ndGgoKSA9PT0gdGhpcy5ibG9ja1NpemUgP1xuICAgIHRoaXMuYmxvY2tTaXplIDogKHRoaXMuYmxvY2tTaXplIC0gaW5wdXQubGVuZ3RoKCkpKTtcbiAgaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yOiBpbnB1dCBkYXRhIG5vdCBhIG11bHRpcGxlIG9mIGJsb2NrU2l6ZVxuICBpZihvcHRpb25zLm92ZXJmbG93ID4gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgdmFyIGNvdW50ID0gb3V0cHV0LmF0KGxlbiAtIDEpO1xuICBpZihjb3VudCA+ICh0aGlzLmJsb2NrU2l6ZSA8PCAyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiogQ2lwaGVyIGZlZWRiYWNrIChDRkIpICoqL1xuXG5tb2Rlcy5jZmIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnQ0ZCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX2luQmxvY2tbaV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgfVxuXG4gIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgcGFydGlhbCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIodGhpcy5fcGFydGlhbEJsb2NrW2ldKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmxvY2sgY29tcGxldGUsIHVwZGF0ZSBpbnB1dCBibG9ja1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wYXJ0aWFsQmxvY2tbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENGQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5faW5CbG9ja1tpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIHBhcnRpYWwgb3V0cHV0XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX3BhcnRpYWxCbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXJcbiAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIC8vIGJsb2NrIGNvbXBsZXRlLCB1cGRhdGUgaW5wdXQgYmxvY2tcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcGFydGlhbEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbi8qKiBPdXRwdXQgZmVlZGJhY2sgKE9GQikgKiovXG5cbm1vZGVzLm9mYiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdPRkInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKE9GQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCBhbmQgdXBkYXRlIG5leHQgaW5wdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX291dEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLm9mYi5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLm9mYi5wcm90b3R5cGUuZW5jcnlwdDtcblxuLyoqIENvdW50ZXIgKENUUikgKiovXG5cbm1vZGVzLmN0ciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDVFInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENUUiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIG91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgIH1cblxuICAgIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIGJsb2NrIGNvbXBsZXRlLCBpbmNyZW1lbnQgY291bnRlciAoaW5wdXQgYmxvY2spXG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5kZWNyeXB0ID0gbW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0O1xuXG4vKiogR2Fsb2lzL0NvdW50ZXIgTW9kZSAoR0NNKSAqKi9cblxubW9kZXMuZ2NtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0dDTSc7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcblxuICAvLyBSIGlzIGFjdHVhbGx5IHRoaXMgdmFsdWUgY29uY2F0ZW5hdGVkIHdpdGggMTIwIG1vcmUgemVybyBiaXRzLCBidXRcbiAgLy8gd2Ugb25seSBYT1IgYWdhaW5zdCBSIHNvIHRoZSBvdGhlciB6ZXJvcyBoYXZlIG5vIGVmZmVjdCAtLSB3ZSBqdXN0XG4gIC8vIGFwcGx5IHRoaXMgdmFsdWUgdG8gdGhlIGZpcnN0IGludGVnZXIgaW4gYSBibG9ja1xuICB0aGlzLl9SID0gMHhFMTAwMDAwMDtcbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gZW5zdXJlIElWIGlzIGEgYnl0ZSBidWZmZXJcbiAgdmFyIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5pdik7XG5cbiAgLy8gbm8gY2lwaGVyZWQgZGF0YSBwcm9jZXNzZWQgeWV0XG4gIHRoaXMuX2NpcGhlckxlbmd0aCA9IDA7XG5cbiAgLy8gZGVmYXVsdCBhZGRpdGlvbmFsIGRhdGEgaXMgbm9uZVxuICB2YXIgYWRkaXRpb25hbERhdGE7XG4gIGlmKCdhZGRpdGlvbmFsRGF0YScgaW4gb3B0aW9ucykge1xuICAgIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5hZGRpdGlvbmFsRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkaXRpb25hbERhdGEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0YWcgbGVuZ3RoIGlzIDEyOCBiaXRzXG4gIGlmKCd0YWdMZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSBvcHRpb25zLnRhZ0xlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSAxMjg7XG4gIH1cblxuICAvLyBpZiB0YWcgaXMgZ2l2ZW4sIGVuc3VyZSB0YWcgbWF0Y2hlcyB0YWcgbGVuZ3RoXG4gIHRoaXMuX3RhZyA9IG51bGw7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIC8vIHNhdmUgdGFnIHRvIGNoZWNrIGxhdGVyXG4gICAgdGhpcy5fdGFnID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy50YWcpLmdldEJ5dGVzKCk7XG4gICAgaWYodGhpcy5fdGFnLmxlbmd0aCAhPT0gKHRoaXMuX3RhZ0xlbmd0aCAvIDgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHRhZyBkb2VzIG5vdCBtYXRjaCB0YWcgbGVuZ3RoLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSB0bXAgc3RvcmFnZSBmb3IgaGFzaCBjYWxjdWxhdGlvblxuICB0aGlzLl9oYXNoQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG5cbiAgLy8gbm8gdGFnIGdlbmVyYXRlZCB5ZXRcbiAgdGhpcy50YWcgPSBudWxsO1xuXG4gIC8vIGdlbmVyYXRlIGhhc2ggc3Via2V5XG4gIC8vIChhcHBseSBibG9jayBjaXBoZXIgdG8gXCJ6ZXJvXCIgYmxvY2spXG4gIHRoaXMuX2hhc2hTdWJrZXkgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQoWzAsIDAsIDAsIDBdLCB0aGlzLl9oYXNoU3Via2V5KTtcblxuICAvLyBnZW5lcmF0ZSB0YWJsZSBNXG4gIC8vIHVzZSA0LWJpdCB0YWJsZXMgKDMyIGNvbXBvbmVudCBkZWNvbXBvc2l0aW9uIG9mIGEgMTYgYnl0ZSB2YWx1ZSlcbiAgLy8gOC1iaXQgdGFibGVzIHRha2UgbW9yZSBzcGFjZSBhbmQgYXJlIGtub3duIHRvIGhhdmUgc2VjdXJpdHlcbiAgLy8gdnVsbmVyYWJpbGl0aWVzIChpbiBuYXRpdmUgaW1wbGVtZW50YXRpb25zKVxuICB0aGlzLmNvbXBvbmVudEJpdHMgPSA0O1xuICB0aGlzLl9tID0gdGhpcy5nZW5lcmF0ZUhhc2hUYWJsZSh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLmNvbXBvbmVudEJpdHMpO1xuXG4gIC8vIE5vdGU6IHN1cHBvcnQgSVYgbGVuZ3RoIGRpZmZlcmVudCBmcm9tIDk2IGJpdHM/IChvbmx5IHN1cHBvcnRpbmdcbiAgLy8gOTYgYml0cyBpcyByZWNvbW1lbmRlZCBieSBOSVNUIFNQLTgwMC0zOEQpXG4gIC8vIGdlbmVyYXRlIEpfMFxuICB2YXIgaXZMZW5ndGggPSBpdi5sZW5ndGgoKTtcbiAgaWYoaXZMZW5ndGggPT09IDEyKSB7XG4gICAgLy8gOTYtYml0IElWXG4gICAgdGhpcy5fajAgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgMV07XG4gIH0gZWxzZSB7XG4gICAgLy8gSVYgaXMgTk9UIDk2LWJpdHNcbiAgICB0aGlzLl9qMCA9IFswLCAwLCAwLCAwXTtcbiAgICB3aGlsZShpdi5sZW5ndGgoKSA+IDApIHtcbiAgICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgICAgdGhpcy5faGFzaFN1YmtleSwgdGhpcy5fajAsXG4gICAgICAgIFtpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpXSk7XG4gICAgfVxuICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgIHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX2owLCBbMCwgMF0uY29uY2F0KGZyb202NFRvMzIoaXZMZW5ndGggKiA4KSkpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgSUNCIChpbml0aWFsIGNvdW50ZXIgYmxvY2spXG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9qMC5zbGljZSgwKTtcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG5cbiAgLy8gY29uc3VtZSBhdXRoZW50aWNhdGlvbiBkYXRhXG4gIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYWRkaXRpb25hbERhdGEpO1xuICAvLyBzYXZlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggYXMgYSBCRSA2NC1iaXQgbnVtYmVyXG4gIHRoaXMuX2FEYXRhTGVuZ3RoID0gZnJvbTY0VG8zMihhZGRpdGlvbmFsRGF0YS5sZW5ndGgoKSAqIDgpO1xuICAvLyBwYWQgYWRkaXRpb25hbCBkYXRhIHRvIDEyOCBiaXQgKDE2IGJ5dGUpIGJsb2NrIHNpemVcbiAgdmFyIG92ZXJmbG93ID0gYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYob3ZlcmZsb3cpIHtcbiAgICBhZGRpdGlvbmFsRGF0YS5maWxsV2l0aEJ5dGUoMCwgdGhpcy5ibG9ja1NpemUgLSBvdmVyZmxvdyk7XG4gIH1cbiAgdGhpcy5fcyA9IFswLCAwLCAwLCAwXTtcbiAgd2hpbGUoYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgPiAwKSB7XG4gICAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgW1xuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKVxuICAgIF0pO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXj0gaW5wdXQuZ2V0SW50MzIoKSk7XG4gICAgfVxuICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA9PT0gMCB8fCBmaW5pc2gpIHtcbiAgICAgIC8vIGhhbmRsZSBvdmVyZmxvdyBwcmlvciB0byBoYXNoaW5nXG4gICAgICBpZihmaW5pc2gpIHtcbiAgICAgICAgLy8gZ2V0IGJsb2NrIG92ZXJmbG93XG4gICAgICAgIHZhciBvdmVyZmxvdyA9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSBvdmVyZmxvdztcbiAgICAgICAgLy8gdHJ1bmNhdGUgZm9yIGhhc2ggZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZSAtIG92ZXJmbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IG91dHB1dCBibG9jayBmb3IgaGFzaGluZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICB0aGlzLl9vdXRCbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0SW50MzIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gICAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXIsIGdldCBwYXJ0aWFsIG91dHB1dCxcbiAgICAgIC8vIGFuZCByZXR1cm4gZWFybHlcbiAgICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBoYXNoIGJsb2NrIFNcbiAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0TGVuZ3RoID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKEdDTSBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG5cbiAgLy8gdXBkYXRlIGhhc2ggYmxvY2sgU1xuICB0aGlzLl9oYXNoQmxvY2tbMF0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMl0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbM10gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCB0aGlzLl9oYXNoQmxvY2spO1xuXG4gIC8vIFhPUiBoYXNoIGlucHV0IHdpdGggb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXiB0aGlzLl9oYXNoQmxvY2tbaV0pO1xuICB9XG5cbiAgLy8gaW5jcmVtZW50IGNpcGhlciBkYXRhIGxlbmd0aFxuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmFmdGVyRmluaXNoID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gIHZhciBydmFsID0gdHJ1ZTtcblxuICAvLyBoYW5kbGUgb3ZlcmZsb3dcbiAgaWYob3B0aW9ucy5kZWNyeXB0ICYmIG9wdGlvbnMub3ZlcmZsb3cpIHtcbiAgICBvdXRwdXQudHJ1bmNhdGUodGhpcy5ibG9ja1NpemUgLSBvcHRpb25zLm92ZXJmbG93KTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBhdXRoZW50aWNhdGlvbiB0YWdcbiAgdGhpcy50YWcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGNvbmNhdGVuYXRlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggd2l0aCBjaXBoZXIgbGVuZ3RoXG4gIHZhciBsZW5ndGhzID0gdGhpcy5fYURhdGFMZW5ndGguY29uY2F0KGZyb202NFRvMzIodGhpcy5fY2lwaGVyTGVuZ3RoICogOCkpO1xuXG4gIC8vIGluY2x1ZGUgbGVuZ3RocyBpbiBoYXNoXG4gIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIGxlbmd0aHMpO1xuXG4gIC8vIGRvIEdDVFIoSl8wLCBTKVxuICB2YXIgdGFnID0gW107XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5fajAsIHRhZyk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLnRhZy5wdXRJbnQzMih0aGlzLl9zW2ldIF4gdGFnW2ldKTtcbiAgfVxuXG4gIC8vIHRyaW0gdGFnIHRvIGxlbmd0aFxuICB0aGlzLnRhZy50cnVuY2F0ZSh0aGlzLnRhZy5sZW5ndGgoKSAlICh0aGlzLl90YWdMZW5ndGggLyA4KSk7XG5cbiAgLy8gY2hlY2sgYXV0aGVudGljYXRpb24gdGFnXG4gIGlmKG9wdGlvbnMuZGVjcnlwdCAmJiB0aGlzLnRhZy5ieXRlcygpICE9PSB0aGlzLl90YWcpIHtcbiAgICBydmFsID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU2VlIE5JU1QgU1AtODAwLTM4RCA2LjMgKEFsZ29yaXRobSAxKS4gVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBHYWxvaXNcbiAqIGZpZWxkIG11bHRpcGxpY2F0aW9uLiBUaGUgZmllbGQsIEdGKDJeMTI4KSwgaXMgZGVmaW5lZCBieSB0aGUgcG9seW5vbWlhbDpcbiAqXG4gKiB4XjEyOCArIHheNyArIHheMiArIHggKyAxXG4gKlxuICogV2hpY2ggaXMgcmVwcmVzZW50ZWQgaW4gbGl0dGxlLWVuZGlhbiBiaW5hcnkgZm9ybSBhczogMTExMDAwMDEgKDB4ZTEpLiBXaGVuXG4gKiB0aGUgdmFsdWUgb2YgYSBjb2VmZmljaWVudCBpcyAxLCBhIGJpdCBpcyBzZXQuIFRoZSB2YWx1ZSBSLCBpcyB0aGVcbiAqIGNvbmNhdGVuYXRpb24gb2YgdGhpcyB2YWx1ZSBhbmQgMTIwIHplcm8gYml0cywgeWllbGRpbmcgYSAxMjgtYml0IHZhbHVlXG4gKiB3aGljaCBtYXRjaGVzIHRoZSBibG9jayBzaXplLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtdWx0aXBseSB0d28gZWxlbWVudHMgKHZlY3RvcnMgb2YgYnl0ZXMpLCBYIGFuZCBZLCBpblxuICogdGhlIGZpZWxkIEdGKDJeMTI4KS4gVGhlIHJlc3VsdCBpcyBpbml0aWFsaXplZCB0byB6ZXJvLiBGb3IgZWFjaCBiaXQgb2ZcbiAqIFggKG91dCBvZiAxMjgpLCB4X2ksIGlmIHhfaSBpcyBzZXQsIHRoZW4gdGhlIHJlc3VsdCBpcyBtdWx0aXBsaWVkIChYT1InZClcbiAqIGJ5IHRoZSBjdXJyZW50IHZhbHVlIG9mIFkuIEZvciBlYWNoIGJpdCwgdGhlIHZhbHVlIG9mIFkgd2lsbCBiZSByYWlzZWQgYnlcbiAqIGEgcG93ZXIgb2YgeCAobXVsdGlwbGllZCBieSB0aGUgcG9seW5vbWlhbCB4KS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnlcbiAqIHNoaWZ0aW5nIFkgb25jZSB0byB0aGUgcmlnaHQuIElmIHRoZSBjdXJyZW50IHZhbHVlIG9mIFksIHByaW9yIHRvIGJlaW5nXG4gKiBtdWx0aXBsaWVkIGJ5IHgsIGhhcyAwIGFzIGl0cyBMU0IsIHRoZW4gaXQgaXMgYSAxMjd0aCBkZWdyZWUgcG9seW5vbWlhbC5cbiAqIE90aGVyd2lzZSwgd2UgbXVzdCBkaXZpZGUgYnkgUiBhZnRlciBzaGlmdGluZyB0byBmaW5kIHRoZSByZW1haW5kZXIuXG4gKlxuICogQHBhcmFtIHggdGhlIGZpcnN0IGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBzZWNvbmQuXG4gKiBAcGFyYW0geSB0aGUgc2Vjb25kIGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBmaXJzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBibG9jayByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgel9pID0gWzAsIDAsIDAsIDBdO1xuICB2YXIgdl9pID0geS5zbGljZSgwKTtcblxuICAvLyBjYWxjdWxhdGUgWl8xMjggKGJsb2NrIGhhcyAxMjggYml0cylcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgLy8gaWYgeF9pIGlzIDAsIFpfe2krMX0gPSBaX2kgKHVuY2hhbmdlZClcbiAgICAvLyBlbHNlIFpfe2krMX0gPSBaX2kgXiBWX2lcbiAgICAvLyBnZXQgeF9pIGJ5IGZpbmRpbmcgMzItYml0IGludCBwb3NpdGlvbiwgdGhlbiBsZWZ0IHNoaWZ0IDEgYnkgcmVtYWluZGVyXG4gICAgdmFyIHhfaSA9IHhbKGkgLyAzMikgfCAwXSAmICgxIDw8ICgzMSAtIGkgJSAzMikpO1xuICAgIGlmKHhfaSkge1xuICAgICAgel9pWzBdIF49IHZfaVswXTtcbiAgICAgIHpfaVsxXSBePSB2X2lbMV07XG4gICAgICB6X2lbMl0gXj0gdl9pWzJdO1xuICAgICAgel9pWzNdIF49IHZfaVszXTtcbiAgICB9XG5cbiAgICAvLyBpZiBMU0IoVl9pKSBpcyAxLCBWX2kgPSBWX2kgPj4gMVxuICAgIC8vIGVsc2UgVl9pID0gKFZfaSA+PiAxKSBeIFJcbiAgICB0aGlzLnBvdyh2X2ksIHZfaSk7XG4gIH1cblxuICByZXR1cm4gel9pO1xufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbih4LCBvdXQpIHtcbiAgLy8gaWYgTFNCKHgpIGlzIDEsIHggPSB4ID4+PiAxXG4gIC8vIGVsc2UgeCA9ICh4ID4+PiAxKSBeIFJcbiAgdmFyIGxzYiA9IHhbM10gJiAxO1xuXG4gIC8vIGFsd2F5cyBkbyB4ID4+PiAxOlxuICAvLyBzdGFydGluZyB3aXRoIHRoZSByaWdodG1vc3QgaW50ZWdlciwgc2hpZnQgZWFjaCBpbnRlZ2VyIHRvIHRoZSByaWdodFxuICAvLyBvbmUgYml0LCBwdWxsaW5nIGluIHRoZSBiaXQgZnJvbSB0aGUgaW50ZWdlciB0byB0aGUgbGVmdCBhcyBpdHMgdG9wXG4gIC8vIG1vc3QgYml0IChkbyB0aGlzIGZvciB0aGUgbGFzdCAzIGludGVnZXJzKVxuICBmb3IodmFyIGkgPSAzOyBpID4gMDsgLS1pKSB7XG4gICAgb3V0W2ldID0gKHhbaV0gPj4+IDEpIHwgKCh4W2kgLSAxXSAmIDEpIDw8IDMxKTtcbiAgfVxuICAvLyBzaGlmdCB0aGUgZmlyc3QgaW50ZWdlciBub3JtYWxseVxuICBvdXRbMF0gPSB4WzBdID4+PiAxO1xuXG4gIC8vIGlmIGxzYiB3YXMgbm90IHNldCwgdGhlbiBwb2x5bm9taWFsIGhhZCBhIGRlZ3JlZSBvZiAxMjcgYW5kIGRvZXNuJ3RcbiAgLy8gbmVlZCB0byBkaXZpZGVkOyBvdGhlcndpc2UsIFhPUiB3aXRoIFIgdG8gZmluZCB0aGUgcmVtYWluZGVyOyB3ZSBvbmx5XG4gIC8vIG5lZWQgdG8gWE9SIHRoZSBmaXJzdCBpbnRlZ2VyIHNpbmNlIFIgdGVjaG5pY2FsbHkgZW5kcyB3LzEyMCB6ZXJvIGJpdHNcbiAgaWYobHNiKSB7XG4gICAgb3V0WzBdIF49IHRoaXMuX1I7XG4gIH1cbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUudGFibGVNdWx0aXBseSA9IGZ1bmN0aW9uKHgpIHtcbiAgLy8gYXNzdW1lcyA0LWJpdCB0YWJsZXMgYXJlIHVzZWRcbiAgdmFyIHogPSBbMCwgMCwgMCwgMF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChpIC8gOCkgfCAwO1xuICAgIHZhciB4X2kgPSAoeFtpZHhdID4+PiAoKDcgLSAoaSAlIDgpKSAqIDQpKSAmIDB4RjtcbiAgICB2YXIgYWggPSB0aGlzLl9tW2ldW3hfaV07XG4gICAgelswXSBePSBhaFswXTtcbiAgICB6WzFdIF49IGFoWzFdO1xuICAgIHpbMl0gXj0gYWhbMl07XG4gICAgelszXSBePSBhaFszXTtcbiAgfVxuICByZXR1cm4gejtcbn07XG5cbi8qKlxuICogQSBjb250aW51aW5nIHZlcnNpb24gb2YgdGhlIEdIQVNIIGFsZ29yaXRobSB0aGF0IG9wZXJhdGVzIG9uIGEgc2luZ2xlXG4gKiBibG9jay4gVGhlIGhhc2ggYmxvY2ssIGxhc3QgaGFzaCB2YWx1ZSAoWW0pIGFuZCB0aGUgbmV3IGJsb2NrIHRvIGhhc2hcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBibG9jay5cbiAqIEBwYXJhbSB5IHRoZSBwcmV2aW91cyB2YWx1ZSBmb3IgWW0sIHVzZSBbMCwgMCwgMCwgMF0gZm9yIGEgbmV3IGhhc2guXG4gKiBAcGFyYW0geCB0aGUgYmxvY2sgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBoYXNoZWQgdmFsdWUgKFltKS5cbiAqL1xubW9kZXMuZ2NtLnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uKGgsIHksIHgpIHtcbiAgeVswXSBePSB4WzBdO1xuICB5WzFdIF49IHhbMV07XG4gIHlbMl0gXj0geFsyXTtcbiAgeVszXSBePSB4WzNdO1xuICByZXR1cm4gdGhpcy50YWJsZU11bHRpcGx5KHkpO1xuICAvL3JldHVybiB0aGlzLm11bHRpcGx5KHksIGgpO1xufTtcblxuLyoqXG4gKiBQcmVjb21wdXRlcyBhIHRhYmxlIGZvciBtdWx0aXBseWluZyBhZ2FpbnN0IHRoZSBoYXNoIHN1YmtleS4gVGhpc1xuICogbWVjaGFuaXNtIHByb3ZpZGVzIGEgc3Vic3RhbnRpYWwgc3BlZWQgaW5jcmVhc2Ugb3ZlciBtdWx0aXBsaWNhdGlvblxuICogcGVyZm9ybWVkIHdpdGhvdXQgYSB0YWJsZS4gVGhlIHRhYmxlLWJhc2VkIG11bHRpcGxpY2F0aW9uIHRoaXMgdGFibGUgaXNcbiAqIGZvciBzb2x2ZXMgWCAqIEggYnkgbXVsdGlwbHlpbmcgZWFjaCBjb21wb25lbnQgb2YgWCBieSBIIGFuZCB0aGVuXG4gKiBjb21wb3NpbmcgdGhlIHJlc3VsdHMgdG9nZXRoZXIgdXNpbmcgWE9SLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGFibGVzIHdpdGggZGlmZmVyZW50IGJpdCBzaXplc1xuICogZm9yIHRoZSBjb21wb25lbnRzLCBob3dldmVyLCB0aGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhlcmUgYXJlXG4gKiAzMiBjb21wb25lbnRzIG9mIFggKHdoaWNoIGlzIGEgMTYgYnl0ZSB2ZWN0b3IpLCB0aGVyZWZvcmUgZWFjaCBjb21wb25lbnRcbiAqIHRha2VzIDQtYml0cyAoc28gdGhlIHRhYmxlIGlzIGNvbnN0cnVjdGVkIHdpdGggYml0cz00KS5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBzdWJrZXkuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlSGFzaFRhYmxlID0gZnVuY3Rpb24oaCwgYml0cykge1xuICAvLyBUT0RPOiBUaGVyZSBhcmUgZnVydGhlciBvcHRpbWl6YXRpb25zIHRoYXQgd291bGQgdXNlIG9ubHkgdGhlXG4gIC8vIGZpcnN0IHRhYmxlIE1fMCAob3Igc29tZSB2YXJpYW50KSBhbG9uZyB3aXRoIGEgcmVtYWluZGVyIHRhYmxlO1xuICAvLyB0aGlzIGNhbiBiZSBleHBsb3JlZCBpbiB0aGUgZnV0dXJlXG4gIHZhciBtdWx0aXBsaWVyID0gOCAvIGJpdHM7XG4gIHZhciBwZXJJbnQgPSA0ICogbXVsdGlwbGllcjtcbiAgdmFyIHNpemUgPSAxNiAqIG11bHRpcGxpZXI7XG4gIHZhciBtID0gbmV3IEFycmF5KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgdmFyIHRtcCA9IFswLCAwLCAwLCAwXTtcbiAgICB2YXIgaWR4ID0gKGkgLyBwZXJJbnQpIHwgMDtcbiAgICB2YXIgc2hmdCA9ICgocGVySW50IC0gMSAtIChpICUgcGVySW50KSkgKiBiaXRzKTtcbiAgICB0bXBbaWR4XSA9ICgxIDw8IChiaXRzIC0gMSkpIDw8IHNoZnQ7XG4gICAgbVtpXSA9IHRoaXMuZ2VuZXJhdGVTdWJIYXNoVGFibGUodGhpcy5tdWx0aXBseSh0bXAsIGgpLCBiaXRzKTtcbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdGFibGUgZm9yIG11bHRpcGx5aW5nIGFnYWluc3QgdGhlIGhhc2ggc3Via2V5IGZvciBvbmVcbiAqIHBhcnRpY3VsYXIgY29tcG9uZW50IChvdXQgb2YgYWxsIHBvc3NpYmxlIGNvbXBvbmVudCB2YWx1ZXMpLlxuICpcbiAqIEBwYXJhbSBtaWQgdGhlIHByZS1tdWx0aXBsaWVkIHZhbHVlIGZvciB0aGUgbWlkZGxlIGtleSBvZiB0aGUgdGFibGUuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlU3ViSGFzaFRhYmxlID0gZnVuY3Rpb24obWlkLCBiaXRzKSB7XG4gIC8vIGNvbXB1dGUgdGhlIHRhYmxlIHF1aWNrbHkgYnkgbWluaW1pemluZyB0aGUgbnVtYmVyIG9mXG4gIC8vIFBPVyBvcGVyYXRpb25zIC0tIHRoZXkgb25seSBuZWVkIHRvIGJlIHBlcmZvcm1lZCBmb3IgcG93ZXJzIG9mIDIsXG4gIC8vIGFsbCBvdGhlciBlbnRyaWVzIGNhbiBiZSBjb21wb3NlZCBmcm9tIHRob3NlIHBvd2VycyB1c2luZyBYT1JcbiAgdmFyIHNpemUgPSAxIDw8IGJpdHM7XG4gIHZhciBoYWxmID0gc2l6ZSA+Pj4gMTtcbiAgdmFyIG0gPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIG1baGFsZl0gPSBtaWQuc2xpY2UoMCk7XG4gIHZhciBpID0gaGFsZiA+Pj4gMTtcbiAgd2hpbGUoaSA+IDApIHtcbiAgICAvLyByYWlzZSBtMFsyICogaV0gYW5kIHN0b3JlIGluIG0wW2ldXG4gICAgdGhpcy5wb3cobVsyICogaV0sIG1baV0gPSBbXSk7XG4gICAgaSA+Pj0gMTtcbiAgfVxuICBpID0gMjtcbiAgd2hpbGUoaSA8IGhhbGYpIHtcbiAgICBmb3IodmFyIGogPSAxOyBqIDwgaTsgKytqKSB7XG4gICAgICB2YXIgbV9pID0gbVtpXTtcbiAgICAgIHZhciBtX2ogPSBtW2pdO1xuICAgICAgbVtpICsgal0gPSBbXG4gICAgICAgIG1faVswXSBeIG1falswXSxcbiAgICAgICAgbV9pWzFdIF4gbV9qWzFdLFxuICAgICAgICBtX2lbMl0gXiBtX2pbMl0sXG4gICAgICAgIG1faVszXSBeIG1falszXVxuICAgICAgXTtcbiAgICB9XG4gICAgaSAqPSAyO1xuICB9XG4gIG1bMF0gPSBbMCwgMCwgMCwgMF07XG4gIC8qIE5vdGU6IFdlIGNvdWxkIGF2b2lkIHN0b3JpbmcgdGhlc2UgYnkgZG9pbmcgY29tcG9zaXRpb24gZHVyaW5nIG11bHRpcGx5XG4gIGNhbGN1bGF0ZSB0b3AgaGFsZiB1c2luZyBjb21wb3NpdGlvbiBieSBzcGVlZCBpcyBwcmVmZXJyZWQuICovXG4gIGZvcihpID0gaGFsZiArIDE7IGkgPCBzaXplOyArK2kpIHtcbiAgICB2YXIgYyA9IG1baSBeIGhhbGZdO1xuICAgIG1baV0gPSBbbWlkWzBdIF4gY1swXSwgbWlkWzFdIF4gY1sxXSwgbWlkWzJdIF4gY1syXSwgbWlkWzNdIF4gY1szXV07XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtSVYoaXYpIHtcbiAgaWYodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGNvbnZlcnQgaXYgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgfVxuXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShpdikgJiYgaXYubGVuZ3RoID4gNCkge1xuICAgIC8vIGNvbnZlcnQgaXYgYnl0ZSBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdmFyIHRtcCA9IGl2O1xuICAgIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICBpdi5wdXRCeXRlKHRtcFtpXSk7XG4gICAgfVxuICB9XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoaXYpKSB7XG4gICAgLy8gY29udmVydCBpdiBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gICAgaXYgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKV07XG4gIH1cblxuICByZXR1cm4gaXY7XG59XG5cbmZ1bmN0aW9uIGluYzMyKGJsb2NrKSB7XG4gIC8vIGluY3JlbWVudCBsYXN0IDMyIGJpdHMgb2YgYmxvY2sgb25seVxuICBibG9ja1tibG9jay5sZW5ndGggLSAxXSA9IChibG9ja1tibG9jay5sZW5ndGggLSAxXSArIDEpICYgMHhGRkZGRkZGRjtcbn1cblxuZnVuY3Rpb24gZnJvbTY0VG8zMihudW0pIHtcbiAgLy8gY29udmVydCA2NC1iaXQgbnVtYmVyIHRvIHR3byBCRSBJbnQzMnNcbiAgcmV0dXJuIFsobnVtIC8gMHgxMDAwMDAwMDApIHwgMCwgbnVtICYgMHhGRkZGRkZGRl07XG59XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIERFUyAoRGF0YSBFbmNyeXB0aW9uIFN0YW5kYXJkKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIHN1cHBvcnRzIERFUyBhcyB3ZWxsIGFzIDNERVMtRURFIGluIEVDQiBhbmQgQ0JDIG1vZGUuXG4gKiBJdCBpcyBiYXNlZCBvbiB0aGUgQlNELWxpY2Vuc2VkIGltcGxlbWVudGF0aW9uIGJ5IFBhdWwgVGVybzpcbiAqXG4gKiBQYXVsIFRlcm8sIEp1bHkgMjAwMVxuICogaHR0cDovL3d3dy50ZXJvLmNvLnVrL2Rlcy9cbiAqXG4gKiBPcHRpbWlzZWQgZm9yIHBlcmZvcm1hbmNlIHdpdGggbGFyZ2UgYmxvY2tzIGJ5IE1pY2hhZWwgSGF5d29ydGgsIE5vdmVtYmVyIDIwMDFcbiAqIGh0dHA6Ly93d3cubmV0ZGVhbGluZy5jb21cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICogSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1RcbiAqIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVlcbiAqIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAqIFNVQ0ggREFNQUdFLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBERVMgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmRlcyA9IGZvcmdlLmRlcyB8fCB7fTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gJ0VDQicgOiAnQ0JDJylcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqIGRlY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZSB8fCAoaXYgPT09IG51bGwgPyAnRUNCJyA6ICdDQkMnKVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgREVTIGNpcGhlciBhbGdvcml0aG0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gbW9kZSB0aGUgbW9kZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIERFUyBhbGdvcml0aG0gb2JqZWN0LlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYubmFtZSA9IG5hbWU7XG4gIHNlbGYubW9kZSA9IG5ldyBtb2RlKHtcbiAgICBibG9ja1NpemU6IDgsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX2tleXMsIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl9rZXlzLCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIERFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMua2V5KTtcbiAgaWYodGhpcy5uYW1lLmluZGV4T2YoJzNERVMnKSA9PT0gMCkge1xuICAgIGlmKGtleS5sZW5ndGgoKSAhPT0gMjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBUcmlwbGUtREVTIGtleSBzaXplOiAnICsga2V5Lmxlbmd0aCgpICogOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvbiB0byAxNiBvciA0OCBzdWJrZXlzIChzaW5nbGUgb3IgdHJpcGxlIERFUylcbiAgdGhpcy5fa2V5cyA9IF9jcmVhdGVLZXlzKGtleSk7XG4gIHRoaXMuX2luaXQgPSB0cnVlO1xufTtcblxuLyoqIFJlZ2lzdGVyIERFUyBhbGdvcml0aG1zICoqL1xuXG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUVDQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtQ0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLU9GQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuZGVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogREVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgc3BmdW5jdGlvbjEgPSBbMHgxMDEwNDAwLDAsMHgxMDAwMCwweDEwMTA0MDQsMHgxMDEwMDA0LDB4MTA0MDQsMHg0LDB4MTAwMDAsMHg0MDAsMHgxMDEwNDAwLDB4MTAxMDQwNCwweDQwMCwweDEwMDA0MDQsMHgxMDEwMDA0LDB4MTAwMDAwMCwweDQsMHg0MDQsMHgxMDAwNDAwLDB4MTAwMDQwMCwweDEwNDAwLDB4MTA0MDAsMHgxMDEwMDAwLDB4MTAxMDAwMCwweDEwMDA0MDQsMHgxMDAwNCwweDEwMDAwMDQsMHgxMDAwMDA0LDB4MTAwMDQsMCwweDQwNCwweDEwNDA0LDB4MTAwMDAwMCwweDEwMDAwLDB4MTAxMDQwNCwweDQsMHgxMDEwMDAwLDB4MTAxMDQwMCwweDEwMDAwMDAsMHgxMDAwMDAwLDB4NDAwLDB4MTAxMDAwNCwweDEwMDAwLDB4MTA0MDAsMHgxMDAwMDA0LDB4NDAwLDB4NCwweDEwMDA0MDQsMHgxMDQwNCwweDEwMTA0MDQsMHgxMDAwNCwweDEwMTAwMDAsMHgxMDAwNDA0LDB4MTAwMDAwNCwweDQwNCwweDEwNDA0LDB4MTAxMDQwMCwweDQwNCwweDEwMDA0MDAsMHgxMDAwNDAwLDAsMHgxMDAwNCwweDEwNDAwLDAsMHgxMDEwMDA0XTtcbnZhciBzcGZ1bmN0aW9uMiA9IFstMHg3ZmVmN2ZlMCwtMHg3ZmZmODAwMCwweDgwMDAsMHgxMDgwMjAsMHgxMDAwMDAsMHgyMCwtMHg3ZmVmZmZlMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwtMHg3ZmVmN2ZlMCwtMHg3ZmVmODAwMCwtMHg4MDAwMDAwMCwtMHg3ZmZmODAwMCwweDEwMDAwMCwweDIwLC0weDdmZWZmZmUwLDB4MTA4MDAwLDB4MTAwMDIwLC0weDdmZmY3ZmUwLDAsLTB4ODAwMDAwMDAsMHg4MDAwLDB4MTA4MDIwLC0weDdmZjAwMDAwLDB4MTAwMDIwLC0weDdmZmZmZmUwLDAsMHgxMDgwMDAsMHg4MDIwLC0weDdmZWY4MDAwLC0weDdmZjAwMDAwLDB4ODAyMCwwLDB4MTA4MDIwLC0weDdmZWZmZmUwLDB4MTAwMDAwLC0weDdmZmY3ZmUwLC0weDdmZjAwMDAwLC0weDdmZWY4MDAwLDB4ODAwMCwtMHg3ZmYwMDAwMCwtMHg3ZmZmODAwMCwweDIwLC0weDdmZWY3ZmUwLDB4MTA4MDIwLDB4MjAsMHg4MDAwLC0weDgwMDAwMDAwLDB4ODAyMCwtMHg3ZmVmODAwMCwweDEwMDAwMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwweDEwODAwMCwwLC0weDdmZmY4MDAwLDB4ODAyMCwtMHg4MDAwMDAwMCwtMHg3ZmVmZmZlMCwtMHg3ZmVmN2ZlMCwweDEwODAwMF07XG52YXIgc3BmdW5jdGlvbjMgPSBbMHgyMDgsMHg4MDIwMjAwLDAsMHg4MDIwMDA4LDB4ODAwMDIwMCwwLDB4MjAyMDgsMHg4MDAwMjAwLDB4MjAwMDgsMHg4MDAwMDA4LDB4ODAwMDAwOCwweDIwMDAwLDB4ODAyMDIwOCwweDIwMDA4LDB4ODAyMDAwMCwweDIwOCwweDgwMDAwMDAsMHg4LDB4ODAyMDIwMCwweDIwMCwweDIwMjAwLDB4ODAyMDAwMCwweDgwMjAwMDgsMHgyMDIwOCwweDgwMDAyMDgsMHgyMDIwMCwweDIwMDAwLDB4ODAwMDIwOCwweDgsMHg4MDIwMjA4LDB4MjAwLDB4ODAwMDAwMCwweDgwMjAyMDAsMHg4MDAwMDAwLDB4MjAwMDgsMHgyMDgsMHgyMDAwMCwweDgwMjAyMDAsMHg4MDAwMjAwLDAsMHgyMDAsMHgyMDAwOCwweDgwMjAyMDgsMHg4MDAwMjAwLDB4ODAwMDAwOCwweDIwMCwwLDB4ODAyMDAwOCwweDgwMDAyMDgsMHgyMDAwMCwweDgwMDAwMDAsMHg4MDIwMjA4LDB4OCwweDIwMjA4LDB4MjAyMDAsMHg4MDAwMDA4LDB4ODAyMDAwMCwweDgwMDAyMDgsMHgyMDgsMHg4MDIwMDAwLDB4MjAyMDgsMHg4LDB4ODAyMDAwOCwweDIwMjAwXTtcbnZhciBzcGZ1bmN0aW9uNCA9IFsweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODAsMHg4MDAwODEsMHg4MDAwMDEsMHgyMDAxLDAsMHg4MDIwMDAsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDB4ODAwMDgwLDB4ODAwMDAxLDB4MSwweDIwMDAsMHg4MDAwMDAsMHg4MDIwMDEsMHg4MCwweDgwMDAwMCwweDIwMDEsMHgyMDgwLDB4ODAwMDgxLDB4MSwweDIwODAsMHg4MDAwODAsMHgyMDAwLDB4ODAyMDgwLDB4ODAyMDgxLDB4ODEsMHg4MDAwODAsMHg4MDAwMDEsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDAsMHg4MDIwMDAsMHgyMDgwLDB4ODAwMDgwLDB4ODAwMDgxLDB4MSwweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODEsMHg4MSwweDEsMHgyMDAwLDB4ODAwMDAxLDB4MjAwMSwweDgwMjA4MCwweDgwMDA4MSwweDIwMDEsMHgyMDgwLDB4ODAwMDAwLDB4ODAyMDAxLDB4ODAsMHg4MDAwMDAsMHgyMDAwLDB4ODAyMDgwXTtcbnZhciBzcGZ1bmN0aW9uNSA9IFsweDEwMCwweDIwODAxMDAsMHgyMDgwMDAwLDB4NDIwMDAxMDAsMHg4MDAwMCwweDEwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQwMDgwMTAwLDB4ODAwMDAsMHgyMDAwMTAwLDB4NDAwODAxMDAsMHg0MjAwMDEwMCwweDQyMDgwMDAwLDB4ODAxMDAsMHg0MDAwMDAwMCwweDIwMDAwMDAsMHg0MDA4MDAwMCwweDQwMDgwMDAwLDAsMHg0MDAwMDEwMCwweDQyMDgwMTAwLDB4NDIwODAxMDAsMHgyMDAwMTAwLDB4NDIwODAwMDAsMHg0MDAwMDEwMCwwLDB4NDIwMDAwMDAsMHgyMDgwMTAwLDB4MjAwMDAwMCwweDQyMDAwMDAwLDB4ODAxMDAsMHg4MDAwMCwweDQyMDAwMTAwLDB4MTAwLDB4MjAwMDAwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQyMDAwMTAwLDB4NDAwODAxMDAsMHgyMDAwMTAwLDB4NDAwMDAwMDAsMHg0MjA4MDAwMCwweDIwODAxMDAsMHg0MDA4MDEwMCwweDEwMCwweDIwMDAwMDAsMHg0MjA4MDAwMCwweDQyMDgwMTAwLDB4ODAxMDAsMHg0MjAwMDAwMCwweDQyMDgwMTAwLDB4MjA4MDAwMCwwLDB4NDAwODAwMDAsMHg0MjAwMDAwMCwweDgwMTAwLDB4MjAwMDEwMCwweDQwMDAwMTAwLDB4ODAwMDAsMCwweDQwMDgwMDAwLDB4MjA4MDEwMCwweDQwMDAwMTAwXTtcbnZhciBzcGZ1bmN0aW9uNiA9IFsweDIwMDAwMDEwLDB4MjA0MDAwMDAsMHg0MDAwLDB4MjA0MDQwMTAsMHgyMDQwMDAwMCwweDEwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDQwNDAxMCwweDQwMDAwMCwweDIwMDAwMDEwLDB4NDAwMDEwLDB4MjAwMDQwMDAsMHgyMDAwMDAwMCwweDQwMTAsMCwweDQwMDAxMCwweDIwMDA0MDEwLDB4NDAwMCwweDQwNDAwMCwweDIwMDA0MDEwLDB4MTAsMHgyMDQwMDAxMCwweDIwNDAwMDEwLDAsMHg0MDQwMTAsMHgyMDQwNDAwMCwweDQwMTAsMHg0MDQwMDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4MjAwMDQwMDAsMHgxMCwweDIwNDAwMDEwLDB4NDA0MDAwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHg0MDEwLDB4MjAwMDAwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDIwMDAwMDAwLDB4NDAxMCwweDIwMDAwMDEwLDB4MjA0MDQwMTAsMHg0MDQwMDAsMHgyMDQwMDAwMCwweDQwNDAxMCwweDIwNDA0MDAwLDAsMHgyMDQwMDAxMCwweDEwLDB4NDAwMCwweDIwNDAwMDAwLDB4NDA0MDEwLDB4NDAwMCwweDQwMDAxMCwweDIwMDA0MDEwLDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4NDAwMDEwLDB4MjAwMDQwMTBdO1xudmFyIHNwZnVuY3Rpb243ID0gWzB4MjAwMDAwLDB4NDIwMDAwMiwweDQwMDA4MDIsMCwweDgwMCwweDQwMDA4MDIsMHgyMDA4MDIsMHg0MjAwODAwLDB4NDIwMDgwMiwweDIwMDAwMCwwLDB4NDAwMDAwMiwweDIsMHg0MDAwMDAwLDB4NDIwMDAwMiwweDgwMiwweDQwMDA4MDAsMHgyMDA4MDIsMHgyMDAwMDIsMHg0MDAwODAwLDB4NDAwMDAwMiwweDQyMDAwMDAsMHg0MjAwODAwLDB4MjAwMDAyLDB4NDIwMDAwMCwweDgwMCwweDgwMiwweDQyMDA4MDIsMHgyMDA4MDAsMHgyLDB4NDAwMDAwMCwweDIwMDgwMCwweDQwMDAwMDAsMHgyMDA4MDAsMHgyMDAwMDAsMHg0MDAwODAyLDB4NDAwMDgwMiwweDQyMDAwMDIsMHg0MjAwMDAyLDB4MiwweDIwMDAwMiwweDQwMDAwMDAsMHg0MDAwODAwLDB4MjAwMDAwLDB4NDIwMDgwMCwweDgwMiwweDIwMDgwMiwweDQyMDA4MDAsMHg4MDIsMHg0MDAwMDAyLDB4NDIwMDgwMiwweDQyMDAwMDAsMHgyMDA4MDAsMCwweDIsMHg0MjAwODAyLDAsMHgyMDA4MDIsMHg0MjAwMDAwLDB4ODAwLDB4NDAwMDAwMiwweDQwMDA4MDAsMHg4MDAsMHgyMDAwMDJdO1xudmFyIHNwZnVuY3Rpb244ID0gWzB4MTAwMDEwNDAsMHgxMDAwLDB4NDAwMDAsMHgxMDA0MTA0MCwweDEwMDAwMDAwLDB4MTAwMDEwNDAsMHg0MCwweDEwMDAwMDAwLDB4NDAwNDAsMHgxMDA0MDAwMCwweDEwMDQxMDQwLDB4NDEwMDAsMHgxMDA0MTAwMCwweDQxMDQwLDB4MTAwMCwweDQwLDB4MTAwNDAwMDAsMHgxMDAwMDA0MCwweDEwMDAxMDAwLDB4MTA0MCwweDQxMDAwLDB4NDAwNDAsMHgxMDA0MDA0MCwweDEwMDQxMDAwLDB4MTA0MCwwLDAsMHgxMDA0MDA0MCwweDEwMDAwMDQwLDB4MTAwMDEwMDAsMHg0MTA0MCwweDQwMDAwLDB4NDEwNDAsMHg0MDAwMCwweDEwMDQxMDAwLDB4MTAwMCwweDQwLDB4MTAwNDAwNDAsMHgxMDAwLDB4NDEwNDAsMHgxMDAwMTAwMCwweDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDQwMDQwLDB4MTAwMDAwMDAsMHg0MDAwMCwweDEwMDAxMDQwLDAsMHgxMDA0MTA0MCwweDQwMDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDAxMDAwLDB4MTAwMDEwNDAsMCwweDEwMDQxMDQwLDB4NDEwMDAsMHg0MTAwMCwweDEwNDAsMHgxMDQwLDB4NDAwNDAsMHgxMDAwMDAwMCwweDEwMDQxMDAwXTtcblxuLyoqXG4gKiBDcmVhdGUgbmVjZXNzYXJ5IHN1YiBrZXlzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIDY0LWJpdCBvciAxOTItYml0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXlzLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlS2V5cyhrZXkpIHtcbiAgdmFyIHBjMmJ5dGVzMCAgPSBbMCwweDQsMHgyMDAwMDAwMCwweDIwMDAwMDA0LDB4MTAwMDAsMHgxMDAwNCwweDIwMDEwMDAwLDB4MjAwMTAwMDQsMHgyMDAsMHgyMDQsMHgyMDAwMDIwMCwweDIwMDAwMjA0LDB4MTAyMDAsMHgxMDIwNCwweDIwMDEwMjAwLDB4MjAwMTAyMDRdLFxuICAgICAgcGMyYnl0ZXMxICA9IFswLDB4MSwweDEwMDAwMCwweDEwMDAwMSwweDQwMDAwMDAsMHg0MDAwMDAxLDB4NDEwMDAwMCwweDQxMDAwMDEsMHgxMDAsMHgxMDEsMHgxMDAxMDAsMHgxMDAxMDEsMHg0MDAwMTAwLDB4NDAwMDEwMSwweDQxMDAxMDAsMHg0MTAwMTAxXSxcbiAgICAgIHBjMmJ5dGVzMiAgPSBbMCwweDgsMHg4MDAsMHg4MDgsMHgxMDAwMDAwLDB4MTAwMDAwOCwweDEwMDA4MDAsMHgxMDAwODA4LDAsMHg4LDB4ODAwLDB4ODA4LDB4MTAwMDAwMCwweDEwMDAwMDgsMHgxMDAwODAwLDB4MTAwMDgwOF0sXG4gICAgICBwYzJieXRlczMgID0gWzAsMHgyMDAwMDAsMHg4MDAwMDAwLDB4ODIwMDAwMCwweDIwMDAsMHgyMDIwMDAsMHg4MDAyMDAwLDB4ODIwMjAwMCwweDIwMDAwLDB4MjIwMDAwLDB4ODAyMDAwMCwweDgyMjAwMDAsMHgyMjAwMCwweDIyMjAwMCwweDgwMjIwMDAsMHg4MjIyMDAwXSxcbiAgICAgIHBjMmJ5dGVzNCAgPSBbMCwweDQwMDAwLDB4MTAsMHg0MDAxMCwwLDB4NDAwMDAsMHgxMCwweDQwMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwXSxcbiAgICAgIHBjMmJ5dGVzNSAgPSBbMCwweDQwMCwweDIwLDB4NDIwLDAsMHg0MDAsMHgyMCwweDQyMCwweDIwMDAwMDAsMHgyMDAwNDAwLDB4MjAwMDAyMCwweDIwMDA0MjAsMHgyMDAwMDAwLDB4MjAwMDQwMCwweDIwMDAwMjAsMHgyMDAwNDIwXSxcbiAgICAgIHBjMmJ5dGVzNiAgPSBbMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDIsMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDJdLFxuICAgICAgcGMyYnl0ZXM3ICA9IFswLDB4MTAwMDAsMHg4MDAsMHgxMDgwMCwweDIwMDAwMDAwLDB4MjAwMTAwMDAsMHgyMDAwMDgwMCwweDIwMDEwODAwLDB4MjAwMDAsMHgzMDAwMCwweDIwODAwLDB4MzA4MDAsMHgyMDAyMDAwMCwweDIwMDMwMDAwLDB4MjAwMjA4MDAsMHgyMDAzMDgwMF0sXG4gICAgICBwYzJieXRlczggID0gWzAsMHg0MDAwMCwwLDB4NDAwMDAsMHgyLDB4NDAwMDIsMHgyLDB4NDAwMDIsMHgyMDAwMDAwLDB4MjA0MDAwMCwweDIwMDAwMDAsMHgyMDQwMDAwLDB4MjAwMDAwMiwweDIwNDAwMDIsMHgyMDAwMDAyLDB4MjA0MDAwMl0sXG4gICAgICBwYzJieXRlczkgID0gWzAsMHgxMDAwMDAwMCwweDgsMHgxMDAwMDAwOCwwLDB4MTAwMDAwMDAsMHg4LDB4MTAwMDAwMDgsMHg0MDAsMHgxMDAwMDQwMCwweDQwOCwweDEwMDAwNDA4LDB4NDAwLDB4MTAwMDA0MDAsMHg0MDgsMHgxMDAwMDQwOF0sXG4gICAgICBwYzJieXRlczEwID0gWzAsMHgyMCwwLDB4MjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgyMDAwLDB4MjAyMCwweDIwMDAsMHgyMDIwLDB4MTAyMDAwLDB4MTAyMDIwLDB4MTAyMDAwLDB4MTAyMDIwXSxcbiAgICAgIHBjMmJ5dGVzMTEgPSBbMCwweDEwMDAwMDAsMHgyMDAsMHgxMDAwMjAwLDB4MjAwMDAwLDB4MTIwMDAwMCwweDIwMDIwMCwweDEyMDAyMDAsMHg0MDAwMDAwLDB4NTAwMDAwMCwweDQwMDAyMDAsMHg1MDAwMjAwLDB4NDIwMDAwMCwweDUyMDAwMDAsMHg0MjAwMjAwLDB4NTIwMDIwMF0sXG4gICAgICBwYzJieXRlczEyID0gWzAsMHgxMDAwLDB4ODAwMDAwMCwweDgwMDEwMDAsMHg4MDAwMCwweDgxMDAwLDB4ODA4MDAwMCwweDgwODEwMDAsMHgxMCwweDEwMTAsMHg4MDAwMDEwLDB4ODAwMTAxMCwweDgwMDEwLDB4ODEwMTAsMHg4MDgwMDEwLDB4ODA4MTAxMF0sXG4gICAgICBwYzJieXRlczEzID0gWzAsMHg0LDB4MTAwLDB4MTA0LDAsMHg0LDB4MTAwLDB4MTA0LDB4MSwweDUsMHgxMDEsMHgxMDUsMHgxLDB4NSwweDEwMSwweDEwNV07XG5cbiAgLy8gaG93IG1hbnkgaXRlcmF0aW9ucyAoMSBmb3IgZGVzLCAzIGZvciB0cmlwbGUgZGVzKVxuICAvLyBjaGFuZ2VkIGJ5IFBhdWwgMTYvNi8yMDA3IHRvIHVzZSBUcmlwbGUgREVTIGZvciA5KyBieXRlIGtleXNcbiAgdmFyIGl0ZXJhdGlvbnMgPSBrZXkubGVuZ3RoKCkgPiA4ID8gMyA6IDE7XG5cbiAgLy8gc3RvcmVzIHRoZSByZXR1cm4ga2V5c1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIC8vIG5vdyBkZWZpbmUgdGhlIGxlZnQgc2hpZnRzIHdoaWNoIG5lZWQgdG8gYmUgZG9uZVxuICB2YXIgc2hpZnRzID0gWzAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDBdO1xuXG4gIHZhciBuID0gMCwgdG1wO1xuICBmb3IodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgdmFyIGxlZnQgPSBrZXkuZ2V0SW50MzIoKTtcbiAgICB2YXIgcmlnaHQgPSBrZXkuZ2V0SW50MzIoKTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gNCkgXiByaWdodCkgJiAweDBmMGYwZjBmO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMikgXiByaWdodCkgJiAweDMzMzMzMzMzO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMik7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgICBsZWZ0IF49IHRtcDtcbiAgICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICAgIC8vIHJpZ2h0IG5lZWRzIHRvIGJlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBsYXN0IGZvdXIgYml0cyBvZiBsZWZ0XG4gICAgdG1wID0gKGxlZnQgPDwgOCkgfCAoKHJpZ2h0ID4+PiAyMCkgJiAweDAwMDAwMGYwKTtcblxuICAgIC8vIGxlZnQgbmVlZHMgdG8gYmUgcHV0IHVwc2lkZSBkb3duXG4gICAgbGVmdCA9ICgocmlnaHQgPDwgMjQpIHwgKChyaWdodCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAoKHJpZ2h0ID4+PiA4KSAmIDB4ZmYwMCkgfCAoKHJpZ2h0ID4+PiAyNCkgJiAweGYwKSk7XG4gICAgcmlnaHQgPSB0bXA7XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGVzZSBzaGlmdHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IGtleXNcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2hpZnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvL3NoaWZ0IHRoZSBrZXlzIGVpdGhlciBvbmUgb3IgdHdvIGJpdHMgdG8gdGhlIGxlZnRcbiAgICAgIGlmKHNoaWZ0c1tpXSkge1xuICAgICAgICBsZWZ0ID0gKGxlZnQgPDwgMikgfCAobGVmdCA+Pj4gMjYpO1xuICAgICAgICByaWdodCA9IChyaWdodCA8PCAyKSB8IChyaWdodCA+Pj4gMjYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IChsZWZ0IDw8IDEpIHwgKGxlZnQgPj4+IDI3KTtcbiAgICAgICAgcmlnaHQgPSAocmlnaHQgPDwgMSkgfCAocmlnaHQgPj4+IDI3KTtcbiAgICAgIH1cbiAgICAgIGxlZnQgJj0gLTB4ZjtcbiAgICAgIHJpZ2h0ICY9IC0weGY7XG5cbiAgICAgIC8vIG5vdyBhcHBseSBQQy0yLCBpbiBzdWNoIGEgd2F5IHRoYXQgRSBpcyBlYXNpZXIgd2hlbiBlbmNyeXB0aW5nIG9yXG4gICAgICAvLyBkZWNyeXB0aW5nIHRoaXMgY29udmVyc2lvbiB3aWxsIGxvb2sgbGlrZSBQQy0yIGV4Y2VwdCBvbmx5IHRoZSBsYXN0IDZcbiAgICAgIC8vIGJpdHMgb2YgZWFjaCBieXRlIGFyZSB1c2VkIHJhdGhlciB0aGFuIDQ4IGNvbnNlY3V0aXZlIGJpdHMgYW5kIHRoZVxuICAgICAgLy8gb3JkZXIgb2YgbGluZXMgd2lsbCBiZSBhY2NvcmRpbmcgdG8gaG93IHRoZSBTIHNlbGVjdGlvbiBmdW5jdGlvbnMgd2lsbFxuICAgICAgLy8gYmUgYXBwbGllZDogUzIsIFM0LCBTNiwgUzgsIFMxLCBTMywgUzUsIFM3XG4gICAgICB2YXIgbGVmdHRtcCA9IChcbiAgICAgICAgcGMyYnl0ZXMwW2xlZnQgPj4+IDI4XSB8IHBjMmJ5dGVzMVsobGVmdCA+Pj4gMjQpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzMlsobGVmdCA+Pj4gMjApICYgMHhmXSB8IHBjMmJ5dGVzM1sobGVmdCA+Pj4gMTYpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzNFsobGVmdCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzNVsobGVmdCA+Pj4gOCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXM2WyhsZWZ0ID4+PiA0KSAmIDB4Zl0pO1xuICAgICAgdmFyIHJpZ2h0dG1wID0gKFxuICAgICAgICBwYzJieXRlczdbcmlnaHQgPj4+IDI4XSB8IHBjMmJ5dGVzOFsocmlnaHQgPj4+IDI0KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczlbKHJpZ2h0ID4+PiAyMCkgJiAweGZdIHwgcGMyYnl0ZXMxMFsocmlnaHQgPj4+IDE2KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczExWyhyaWdodCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzMTJbKHJpZ2h0ID4+PiA4KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczEzWyhyaWdodCA+Pj4gNCkgJiAweGZdKTtcbiAgICAgIHRtcCA9ICgocmlnaHR0bXAgPj4+IDE2KSBeIGxlZnR0bXApICYgMHgwMDAwZmZmZjtcbiAgICAgIGtleXNbbisrXSA9IGxlZnR0bXAgXiB0bXA7XG4gICAgICBrZXlzW24rK10gPSByaWdodHRtcCBeICh0bXAgPDwgMTYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDEgYnl0ZSkgdXNpbmcgREVTLiBUaGUgdXBkYXRlIHdpbGwgZWl0aGVyXG4gKiBlbmNyeXB0IG9yIGRlY3J5cHQgdGhlIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBrZXlzIHRoZSBleHBhbmRlZCBrZXlzLlxuICogQHBhcmFtIGlucHV0IHRoZSBpbnB1dCBibG9jayAoYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIHVwZGF0ZWQgb3V0cHV0IGJsb2NrLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0IHRoZSBibG9jaywgZmFsc2UgdG8gZW5jcnlwdCBpdC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKGtleXMsIGlucHV0LCBvdXRwdXQsIGRlY3J5cHQpIHtcbiAgLy8gc2V0IHVwIGxvb3BzIGZvciBzaW5nbGUgb3IgdHJpcGxlIERFU1xuICB2YXIgaXRlcmF0aW9ucyA9IGtleXMubGVuZ3RoID09PSAzMiA/IDMgOiA5O1xuICB2YXIgbG9vcGluZztcbiAgaWYoaXRlcmF0aW9ucyA9PT0gMykge1xuICAgIGxvb3BpbmcgPSBkZWNyeXB0ID8gWzMwLCAtMiwgLTJdIDogWzAsIDMyLCAyXTtcbiAgfSBlbHNlIHtcbiAgICBsb29waW5nID0gKGRlY3J5cHQgP1xuICAgICAgWzk0LCA2MiwgLTIsIDMyLCA2NCwgMiwgMzAsIC0yLCAtMl0gOlxuICAgICAgWzAsIDMyLCAyLCA2MiwgMzAsIC0yLCA2NCwgOTYsIDJdKTtcbiAgfVxuXG4gIHZhciB0bXA7XG5cbiAgdmFyIGxlZnQgPSBpbnB1dFswXTtcbiAgdmFyIHJpZ2h0ID0gaW5wdXRbMV07XG5cbiAgLy8gZmlyc3QgZWFjaCA2NCBiaXQgY2h1bmsgb2YgdGhlIG1lc3NhZ2UgbXVzdCBiZSBwZXJtdXRlZCBhY2NvcmRpbmcgdG8gSVBcbiAgdG1wID0gKChsZWZ0ID4+PiA0KSBeIHJpZ2h0KSAmIDB4MGYwZjBmMGY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDQpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gMTYpIF4gcmlnaHQpICYgMHgwMDAwZmZmZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMTYpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgOCk7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gIC8vIHJvdGF0ZSBsZWZ0IDEgYml0XG4gIGxlZnQgPSAoKGxlZnQgPDwgMSkgfCAobGVmdCA+Pj4gMzEpKTtcbiAgcmlnaHQgPSAoKHJpZ2h0IDw8IDEpIHwgKHJpZ2h0ID4+PiAzMSkpO1xuXG4gIGZvcih2YXIgaiA9IDA7IGogPCBpdGVyYXRpb25zOyBqICs9IDMpIHtcbiAgICB2YXIgZW5kbG9vcCA9IGxvb3BpbmdbaiArIDFdO1xuICAgIHZhciBsb29waW5jID0gbG9vcGluZ1tqICsgMl07XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uXG4gICAgZm9yKHZhciBpID0gbG9vcGluZ1tqXTsgaSAhPSBlbmRsb29wOyBpICs9IGxvb3BpbmMpIHtcbiAgICAgIHZhciByaWdodDEgPSByaWdodCBeIGtleXNbaV07XG4gICAgICB2YXIgcmlnaHQyID0gKChyaWdodCA+Pj4gNCkgfCAocmlnaHQgPDwgMjgpKSBeIGtleXNbaSArIDFdO1xuXG4gICAgICAvLyBwYXNzaW5nIHRoZXNlIGJ5dGVzIHRocm91Z2ggdGhlIFMgc2VsZWN0aW9uIGZ1bmN0aW9uc1xuICAgICAgdG1wID0gbGVmdDtcbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gdG1wIF4gKFxuICAgICAgICBzcGZ1bmN0aW9uMlsocmlnaHQxID4+PiAyNCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb240WyhyaWdodDEgPj4+IDE2KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjZbKHJpZ2h0MSA+Pj4gIDgpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uOFtyaWdodDEgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb24xWyhyaWdodDIgPj4+IDI0KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjNbKHJpZ2h0MiA+Pj4gMTYpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uNVsocmlnaHQyID4+PiAgOCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb243W3JpZ2h0MiAmIDB4M2ZdKTtcbiAgICB9XG4gICAgLy8gdW5yZXZlcnNlIGxlZnQgYW5kIHJpZ2h0XG4gICAgdG1wID0gbGVmdDtcbiAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgcmlnaHQgPSB0bXA7XG4gIH1cblxuICAvLyByb3RhdGUgcmlnaHQgMSBiaXRcbiAgbGVmdCA9ICgobGVmdCA+Pj4gMSkgfCAobGVmdCA8PCAzMSkpO1xuICByaWdodCA9ICgocmlnaHQgPj4+IDEpIHwgKHJpZ2h0IDw8IDMxKSk7XG5cbiAgLy8gbm93IHBlcmZvcm0gSVAtMSwgd2hpY2ggaXMgSVAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gOCkgXiBsZWZ0KSAmIDB4MDBmZjAwZmY7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDE2KSBeIHJpZ2h0KSAmIDB4MDAwMGZmZmY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDE2KTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDQpIF4gcmlnaHQpICYgMHgwZjBmMGYwZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgb3V0cHV0WzBdID0gbGVmdDtcbiAgb3V0cHV0WzFdID0gcmlnaHQ7XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBERVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogICAgICAgICAgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICogICAgICAgICAgbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlQ2lwaGVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCAnQ0JDJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIGFsZ29yaXRobSA9ICdERVMtJyArIG1vZGU7XG5cbiAgdmFyIGNpcGhlcjtcbiAgaWYob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH1cblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdGFydCBBUElcbiAgdmFyIHN0YXJ0ID0gY2lwaGVyLnN0YXJ0O1xuICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9ucykge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBzdXBwb3J0IHNlY29uZCBhcmcgYXMgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciBvdXRwdXQgPSBudWxsO1xuICAgIGlmKG9wdGlvbnMgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgIG91dHB1dCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMub3V0cHV0ID0gb3V0cHV0O1xuICAgIG9wdGlvbnMuaXYgPSBpdjtcbiAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24gIzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogU2VlIFJGQyAyODk4IGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBwa2NzNSA9IGZvcmdlLnBrY3M1ID0gZm9yZ2UucGtjczUgfHwge307XG5cbnZhciBjcnlwdG87XG5pZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0KSB7XG4gIGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xufVxuXG4vKipcbiAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBwIHRoZSBwYXNzd29yZCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBzIHRoZSBzYWx0IGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIGMgdGhlIGl0ZXJhdGlvbiBjb3VudCwgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICogQHBhcmFtIGRrTGVuIHRoZSBpbnRlbmRlZCBsZW5ndGgsIGluIGJ5dGVzLCBvZiB0aGUgZGVyaXZlZCBrZXksXG4gKiAgICAgICAgICAobWF4OiAyXjMyIC0gMSkgKiBoYXNoIGxlbmd0aCBvZiB0aGUgUFJGLlxuICogQHBhcmFtIFttZF0gdGhlIG1lc3NhZ2UgZGlnZXN0IChvciBhbGdvcml0aG0gaWRlbnRpZmllciBhcyBhIHN0cmluZykgdG8gdXNlXG4gKiAgICAgICAgICBpbiB0aGUgUFJGLCBkZWZhdWx0cyB0byBTSEEtMS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXkpXSBwcmVzZW5jZSB0cmlnZ2VycyBhc3luY2hyb25vdXMgdmVyc2lvbiwgY2FsbGVkXG4gKiAgICAgICAgICBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlcml2ZWQga2V5LCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcywgZm9yIHRoZVxuICogICAgICAgICAgIHN5bmNocm9ub3VzIHZlcnNpb24gKGlmIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCkuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGJrZGYyID0gcGtjczUucGJrZGYyID0gZnVuY3Rpb24oXG4gIHAsIHMsIGMsIGRrTGVuLCBtZCwgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG1kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtZDtcbiAgICBtZCA9IG51bGw7XG4gIH1cblxuICAvLyB1c2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlmIHBvc3NpYmxlIGFuZCBub3QgZGlzYWJsZWQsIG5vdGUgdGhhdFxuICAvLyBzb21lIG5vZGUgdmVyc2lvbnMgb25seSBzdXBwb3J0IFNIQS0xLCBvdGhlcnMgYWxsb3cgZGlnZXN0IHRvIGJlIGNoYW5nZWRcbiAgaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAgIGNyeXB0by5wYmtkZjIgJiYgKG1kID09PSBudWxsIHx8IHR5cGVvZiBtZCAhPT0gJ29iamVjdCcpICYmXG4gICAgKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA+IDQgfHwgKCFtZCB8fCBtZCA9PT0gJ3NoYTEnKSkpIHtcbiAgICBpZih0eXBlb2YgbWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkZWZhdWx0IHByZiB0byBTSEEtMVxuICAgICAgbWQgPSAnc2hhMSc7XG4gICAgfVxuICAgIHAgPSBuZXcgQnVmZmVyKHAsICdiaW5hcnknKTtcbiAgICBzID0gbmV3IEJ1ZmZlcihzLCAnYmluYXJ5Jyk7XG4gICAgaWYoIWNhbGxiYWNrKSB7XG4gICAgICBpZihjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjJTeW5jKHAsIHMsIGMsIGRrTGVuKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3J5cHRvLnBia2RmMlN5bmMocCwgcywgYywgZGtMZW4sIG1kKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgfVxuICAgIGlmKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjIocCwgcywgYywgZGtMZW4sIGZ1bmN0aW9uKGVyciwga2V5KSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcnlwdG8ucGJrZGYyKHAsIHMsIGMsIGRrTGVuLCBtZCwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIC8vIGRlZmF1bHQgcHJmIHRvIFNIQS0xXG4gICAgbWQgPSAnc2hhMSc7XG4gIH1cbiAgaWYodHlwZW9mIG1kID09PSAnc3RyaW5nJykge1xuICAgIGlmKCEobWQgaW4gZm9yZ2UubWQuYWxnb3JpdGhtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIG1kKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gIH1cblxuICB2YXIgaExlbiA9IG1kLmRpZ2VzdExlbmd0aDtcblxuICAvKiAxLiBJZiBka0xlbiA+ICgyXjMyIC0gMSkgKiBoTGVuLCBvdXRwdXQgXCJkZXJpdmVkIGtleSB0b28gbG9uZ1wiIGFuZFxuICAgIHN0b3AuICovXG4gIGlmKGRrTGVuID4gKDB4RkZGRkZGRkYgKiBoTGVuKSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Rlcml2ZWQga2V5IGlzIHRvbyBsb25nLicpO1xuICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgLyogMi4gTGV0IGxlbiBiZSB0aGUgbnVtYmVyIG9mIGhMZW4tb2N0ZXQgYmxvY2tzIGluIHRoZSBkZXJpdmVkIGtleSxcbiAgICByb3VuZGluZyB1cCwgYW5kIGxldCByIGJlIHRoZSBudW1iZXIgb2Ygb2N0ZXRzIGluIHRoZSBsYXN0XG4gICAgYmxvY2s6XG5cbiAgICBsZW4gPSBDRUlMKGRrTGVuIC8gaExlbiksXG4gICAgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbi4gKi9cbiAgdmFyIGxlbiA9IE1hdGguY2VpbChka0xlbiAvIGhMZW4pO1xuICB2YXIgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbjtcblxuICAvKiAzLiBGb3IgZWFjaCBibG9jayBvZiB0aGUgZGVyaXZlZCBrZXkgYXBwbHkgdGhlIGZ1bmN0aW9uIEYgZGVmaW5lZFxuICAgIGJlbG93IHRvIHRoZSBwYXNzd29yZCBQLCB0aGUgc2FsdCBTLCB0aGUgaXRlcmF0aW9uIGNvdW50IGMsIGFuZFxuICAgIHRoZSBibG9jayBpbmRleCB0byBjb21wdXRlIHRoZSBibG9jazpcblxuICAgIFRfMSA9IEYoUCwgUywgYywgMSksXG4gICAgVF8yID0gRihQLCBTLCBjLCAyKSxcbiAgICAuLi5cbiAgICBUX2xlbiA9IEYoUCwgUywgYywgbGVuKSxcblxuICAgIHdoZXJlIHRoZSBmdW5jdGlvbiBGIGlzIGRlZmluZWQgYXMgdGhlIGV4Y2x1c2l2ZS1vciBzdW0gb2YgdGhlXG4gICAgZmlyc3QgYyBpdGVyYXRlcyBvZiB0aGUgdW5kZXJseWluZyBwc2V1ZG9yYW5kb20gZnVuY3Rpb24gUFJGXG4gICAgYXBwbGllZCB0byB0aGUgcGFzc3dvcmQgUCBhbmQgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHNhbHQgU1xuICAgIGFuZCB0aGUgYmxvY2sgaW5kZXggaTpcblxuICAgIEYoUCwgUywgYywgaSkgPSB1XzEgWE9SIHVfMiBYT1IgLi4uIFhPUiB1X2NcblxuICAgIHdoZXJlXG5cbiAgICB1XzEgPSBQUkYoUCwgUyB8fCBJTlQoaSkpLFxuICAgIHVfMiA9IFBSRihQLCB1XzEpLFxuICAgIC4uLlxuICAgIHVfYyA9IFBSRihQLCB1X3tjLTF9KS5cblxuICAgIEhlcmUsIElOVChpKSBpcyBhIGZvdXItb2N0ZXQgZW5jb2Rpbmcgb2YgdGhlIGludGVnZXIgaSwgbW9zdFxuICAgIHNpZ25pZmljYW50IG9jdGV0IGZpcnN0LiAqL1xuICB2YXIgcHJmID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgcHJmLnN0YXJ0KG1kLCBwKTtcbiAgdmFyIGRrID0gJyc7XG4gIHZhciB4b3IsIHVfYywgdV9jMTtcblxuICAvLyBzeW5jIHZlcnNpb25cbiAgaWYoIWNhbGxiYWNrKSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8PSBsZW47ICsraSkge1xuICAgICAgLy8gUFJGKFAsIFMgfHwgSU5UKGkpKSAoZmlyc3QgaXRlcmF0aW9uKVxuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZShzKTtcbiAgICAgIHByZi51cGRhdGUoZm9yZ2UudXRpbC5pbnQzMlRvQnl0ZXMoaSkpO1xuICAgICAgeG9yID0gdV9jMSA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgICBmb3IodmFyIGogPSAyOyBqIDw9IGM7ICsraikge1xuICAgICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICAgIHByZi51cGRhdGUodV9jMSk7XG4gICAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgICAvLyBGKHAsIHMsIGMsIGkpXG4gICAgICAgIHhvciA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoeG9yLCB1X2MsIGhMZW4pO1xuICAgICAgICB1X2MxID0gdV9jO1xuICAgICAgfVxuXG4gICAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgICAgcHJvZHVjZSBhIGRlcml2ZWQga2V5IERLOlxuXG4gICAgICAgIERLID0gVF8xIHx8IFRfMiB8fCAgLi4uICB8fCBUX2xlbjwwLi5yLTE+ICovXG4gICAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuICAgIH1cbiAgICAvKiA1LiBPdXRwdXQgdGhlIGRlcml2ZWQga2V5IERLLiAqL1xuICAgIHJldHVybiBkaztcbiAgfVxuXG4gIC8vIGFzeW5jIHZlcnNpb25cbiAgdmFyIGkgPSAxLCBqO1xuICBmdW5jdGlvbiBvdXRlcigpIHtcbiAgICBpZihpID4gbGVuKSB7XG4gICAgICAvLyBkb25lXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGspO1xuICAgIH1cblxuICAgIC8vIFBSRihQLCBTIHx8IElOVChpKSkgKGZpcnN0IGl0ZXJhdGlvbilcbiAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgcHJmLnVwZGF0ZShzKTtcbiAgICBwcmYudXBkYXRlKGZvcmdlLnV0aWwuaW50MzJUb0J5dGVzKGkpKTtcbiAgICB4b3IgPSB1X2MxID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgaiA9IDI7XG4gICAgaW5uZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgIGlmKGogPD0gYykge1xuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZSh1X2MxKTtcbiAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgLy8gRihwLCBzLCBjLCBpKVxuICAgICAgeG9yID0gZm9yZ2UudXRpbC54b3JCeXRlcyh4b3IsIHVfYywgaExlbik7XG4gICAgICB1X2MxID0gdV9jO1xuICAgICAgKytqO1xuICAgICAgcmV0dXJuIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGlubmVyKTtcbiAgICB9XG5cbiAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgIHByb2R1Y2UgYSBkZXJpdmVkIGtleSBESzpcblxuICAgICAgREsgPSBUXzEgfHwgVF8yIHx8ICAuLi4gIHx8IFRfbGVuPDAuLnItMT4gKi9cbiAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuXG4gICAgKytpO1xuICAgIG91dGVyKCk7XG4gIH1cblxuICBvdXRlcigpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSGFzaC1iYXNlZCBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgaW1wbGVtZW50YXRpb24uIFJlcXVpcmVzIGEgbWVzc2FnZVxuICogZGlnZXN0IG9iamVjdCB0aGF0IGNhbiBiZSBvYnRhaW5lZCwgZm9yIGV4YW1wbGUsIGZyb20gZm9yZ2UubWQuc2hhMSBvclxuICogZm9yZ2UubWQubWQ1LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBITUFDIEFQSSAqL1xudmFyIGhtYWMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmhtYWMgPSBmb3JnZS5obWFjIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gSE1BQyBvYmplY3QgdGhhdCB1c2VzIHRoZSBnaXZlbiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhbiBITUFDIG9iamVjdC5cbiAqL1xuaG1hYy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gdGhlIGhtYWMga2V5IHRvIHVzZVxuICB2YXIgX2tleSA9IG51bGw7XG5cbiAgLy8gdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZVxuICB2YXIgX21kID0gbnVsbDtcblxuICAvLyB0aGUgaW5uZXIgcGFkZGluZ1xuICB2YXIgX2lwYWRkaW5nID0gbnVsbDtcblxuICAvLyB0aGUgb3V0ZXIgcGFkZGluZ1xuICB2YXIgX29wYWRkaW5nID0gbnVsbDtcblxuICAvLyBobWFjIGNvbnRleHRcbiAgdmFyIGN0eCA9IHt9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIEhNQUMgd2l0aCB0aGUgZ2l2ZW4ga2V5IGFuZCBtZXNzYWdlIGRpZ2VzdC5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2UsIG51bGwgdG8gcmV1c2UgdGhlIHByZXZpb3VzIG9uZSxcbiAgICogICAgICAgICAgIGEgc3RyaW5nIHRvIHVzZSBidWlsdGluICdzaGExJywgJ21kNScsICdzaGEyNTYnLlxuICAgKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGFzIGEgc3RyaW5nLCBhcnJheSBvZiBieXRlcywgYnl0ZSBidWZmZXIsXG4gICAqICAgICAgICAgICBvciBudWxsIHRvIHJldXNlIHRoZSBwcmV2aW91cyBrZXkuXG4gICAqL1xuICBjdHguc3RhcnQgPSBmdW5jdGlvbihtZCwga2V5KSB7XG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIGlmKHR5cGVvZiBtZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY3JlYXRlIGJ1aWx0aW4gbWVzc2FnZSBkaWdlc3RcbiAgICAgICAgbWQgPSBtZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZihtZCBpbiBmb3JnZS5tZC5hbGdvcml0aG1zKSB7XG4gICAgICAgICAgX21kID0gZm9yZ2UubWQuYWxnb3JpdGhtc1ttZF0uY3JlYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhhc2ggYWxnb3JpdGhtIFwiJyArIG1kICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0b3JlIG1lc3NhZ2UgZGlnZXN0XG4gICAgICAgIF9tZCA9IG1kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGtleSA9PT0gbnVsbCkge1xuICAgICAgLy8gcmV1c2UgcHJldmlvdXMga2V5XG4gICAgICBrZXkgPSBfa2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gICAgICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgLy8gY29udmVydCBieXRlIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICAgICAgdmFyIHRtcCA9IGtleTtcbiAgICAgICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleS5wdXRCeXRlKHRtcFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIGxvbmdlciB0aGFuIGJsb2Nrc2l6ZSwgaGFzaCBpdFxuICAgICAgdmFyIGtleWxlbiA9IGtleS5sZW5ndGgoKTtcbiAgICAgIGlmKGtleWxlbiA+IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICBfbWQuc3RhcnQoKTtcbiAgICAgICAgX21kLnVwZGF0ZShrZXkuYnl0ZXMoKSk7XG4gICAgICAgIGtleSA9IF9tZC5kaWdlc3QoKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWl4IGtleSBpbnRvIGlubmVyIGFuZCBvdXRlciBwYWRkaW5nXG4gICAgICAvLyBpcGFkZGluZyA9IFsweDM2ICogYmxvY2tzaXplXSBeIGtleVxuICAgICAgLy8gb3BhZGRpbmcgPSBbMHg1QyAqIGJsb2Nrc2l6ZV0gXiBrZXlcbiAgICAgIF9pcGFkZGluZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfb3BhZGRpbmcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGtleWxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0bXAgPSBrZXkuYXQoaSk7XG4gICAgICAgIF9pcGFkZGluZy5wdXRCeXRlKDB4MzYgXiB0bXApO1xuICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDIF4gdG1wKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIHNob3J0ZXIgdGhhbiBibG9ja3NpemUsIGFkZCBhZGRpdGlvbmFsIHBhZGRpbmdcbiAgICAgIGlmKGtleWxlbiA8IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICB2YXIgdG1wID0gX21kLmJsb2NrTGVuZ3RoIC0ga2V5bGVuO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wOyArK2kpIHtcbiAgICAgICAgICBfaXBhZGRpbmcucHV0Qnl0ZSgweDM2KTtcbiAgICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2tleSA9IGtleTtcbiAgICAgIF9pcGFkZGluZyA9IF9pcGFkZGluZy5ieXRlcygpO1xuICAgICAgX29wYWRkaW5nID0gX29wYWRkaW5nLmJ5dGVzKCk7XG4gICAgfVxuXG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcblxuICAgIC8vIHByZXBhcmUgdG8gZG8gaW5uZXIgaGFzaFxuICAgIC8vIGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKVxuICAgIF9tZC5zdGFydCgpO1xuICAgIF9tZC51cGRhdGUoX2lwYWRkaW5nKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgSE1BQyB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIHVwZGF0ZSB3aXRoLlxuICAgKi9cbiAgY3R4LnVwZGF0ZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgX21kLnVwZGF0ZShieXRlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgKE1BQykuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBjdHguZ2V0TWFjID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcbiAgICAvLyBoZXJlIHdlIGRvIHRoZSBvdXRlciBoYXNoaW5nXG4gICAgdmFyIGlubmVyID0gX21kLmRpZ2VzdCgpLmJ5dGVzKCk7XG4gICAgX21kLnN0YXJ0KCk7XG4gICAgX21kLnVwZGF0ZShfb3BhZGRpbmcpO1xuICAgIF9tZC51cGRhdGUoaW5uZXIpO1xuICAgIHJldHVybiBfbWQuZGlnZXN0KCk7XG4gIH07XG4gIC8vIGFsaWFzIGZvciBnZXRNYWNcbiAgY3R4LmRpZ2VzdCA9IGN0eC5nZXRNYWM7XG5cbiAgcmV0dXJuIGN0eDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiAoaWdub3JlZCkgKi9cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDUgIFRvbSBXdVxuLy8gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscy5cblxuLy8gQmFzaWMgSmF2YVNjcmlwdCBCTiBsaWJyYXJ5IC0gc3Vic2V0IHVzZWZ1bCBmb3IgUlNBIGVuY3J5cHRpb24uXG5cbi8qXG5MaWNlbnNpbmcgKExJQ0VOU0UpXG4tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblRoaXMgc29mdHdhcmUgaXMgY292ZXJlZCB1bmRlciB0aGUgZm9sbG93aW5nIGNvcHlyaWdodDpcbiovXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDAzLTIwMDUgIFRvbSBXdVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUy1JU1wiIEFORCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUywgSU1QTElFRCBPUiBPVEhFUldJU0UsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04sIEFOWVxuICogV0FSUkFOVFkgT0YgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLlxuICpcbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRPTSBXVSBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBJTkNJREVOVEFMLFxuICogSU5ESVJFQ1QgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9GIEFOWSBLSU5ELCBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSXG4gKiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIE9SIE5PVCBBRFZJU0VEIE9GXG4gKiBUSEUgUE9TU0lCSUxJVFkgT0YgREFNQUdFLCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIEFSSVNJTkcgT1VUXG4gKiBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqIEluIGFkZGl0aW9uLCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiBhcHBsaWVzOlxuICpcbiAqIEFsbCByZWRpc3RyaWJ1dGlvbnMgbXVzdCByZXRhaW4gYW4gaW50YWN0IGNvcHkgb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlXG4gKiBhbmQgZGlzY2xhaW1lci5cbiAqL1xuLypcbkFkZHJlc3MgYWxsIHF1ZXN0aW9ucyByZWdhcmRpbmcgdGhpcyBsaWNlbnNlIHRvOlxuXG4gIFRvbSBXdVxuICB0andAY3MuU3RhbmZvcmQuRURVXG4qL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5qc2JuID0gZm9yZ2UuanNibiB8fCB7fTtcblxuLy8gQml0cyBwZXIgZGlnaXRcbnZhciBkYml0cztcblxuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkmMHhmZmZmZmYpPT0weGVmY2FmZSk7XG5cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG5mdW5jdGlvbiBCaWdJbnRlZ2VyKGEsYixjKSB7XG4gIHRoaXMuZGF0YSA9IFtdO1xuICBpZihhICE9IG51bGwpXG4gICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICBlbHNlIGlmKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwyNTYpO1xuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYik7XG59XG5mb3JnZS5qc2JuLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuXG4vLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG5mdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxuXG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuXG4vLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4vLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKSB7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIHYgPSB4KnRoaXMuZGF0YVtpKytdK3cuZGF0YVtqXStjO1xuICAgIGMgPSBNYXRoLmZsb29yKHYvMHg0MDAwMDAwKTtcbiAgICB3LmRhdGFbaisrXSA9IHYmMHgzZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHg3ZmZmLCB4aCA9IHg+PjE1O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4N2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNTtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHg3ZmZmKTw8MTUpK3cuZGF0YVtqXSsoYyYweDNmZmZmZmZmKTtcbiAgICBjID0gKGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHgzZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4M2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNDtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHgzZmZmKTw8MTQpK3cuZGF0YVtqXStjO1xuICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHhmZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBub2RlLmpzIChubyBicm93c2VyKVxuaWYodHlwZW9mKG5hdmlnYXRvcikgPT09ICd1bmRlZmluZWQnKVxue1xuICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICBkYml0cyA9IDI4O1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICBkYml0cyA9IDMwO1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gIGRiaXRzID0gMjY7XG59IGVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gIGRiaXRzID0gMjg7XG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMTw8ZGJpdHMpLTEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMTw8ZGJpdHMpO1xuXG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMixCSV9GUCk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQLWRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyKmRiaXRzLUJJX0ZQO1xuXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbnZhciBCSV9SQyA9IG5ldyBBcnJheSgpO1xudmFyIHJyLHZ2O1xucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xucnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5cbmZ1bmN0aW9uIGludDJjaGFyKG4pIHsgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTsgfVxuZnVuY3Rpb24gaW50QXQocyxpKSB7XG4gIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgcmV0dXJuIChjPT1udWxsKT8tMTpjO1xufVxuXG4vLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gIHIudCA9IHRoaXMudDtcbiAgci5zID0gdGhpcy5zO1xufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbmZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICB0aGlzLnQgPSAxO1xuICB0aGlzLnMgPSAoeDwwKT8tMTowO1xuICBpZih4ID4gMCkgdGhpcy5kYXRhWzBdID0geDtcbiAgZWxzZSBpZih4IDwgLTEpIHRoaXMuZGF0YVswXSA9IHgrdGhpcy5EVjtcbiAgZWxzZSB0aGlzLnQgPSAwO1xufVxuXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkgeyB2YXIgciA9IG5iaSgpOyByLmZyb21JbnQoaSk7IHJldHVybiByOyB9XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbmZ1bmN0aW9uIGJucEZyb21TdHJpbmcocyxiKSB7XG4gIHZhciBrO1xuICBpZihiID09IDE2KSBrID0gNDtcbiAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICBlbHNlIGlmKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgZWxzZSB7IHRoaXMuZnJvbVJhZGl4KHMsYik7IHJldHVybjsgfVxuICB0aGlzLnQgPSAwO1xuICB0aGlzLnMgPSAwO1xuICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgdmFyIHggPSAoaz09OCk/c1tpXSYweGZmOmludEF0KHMsaSk7XG4gICAgaWYoeCA8IDApIHtcbiAgICAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbWkgPSBmYWxzZTtcbiAgICBpZihzaCA9PSAwKVxuICAgICAgdGhpcy5kYXRhW3RoaXMudCsrXSA9IHg7XG4gICAgZWxzZSBpZihzaCtrID4gdGhpcy5EQikge1xuICAgICAgdGhpcy5kYXRhW3RoaXMudC0xXSB8PSAoeCYoKDE8PCh0aGlzLkRCLXNoKSktMSkpPDxzaDtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAoeD4+KHRoaXMuREItc2gpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQtMV0gfD0geDw8c2g7XG4gICAgc2ggKz0gaztcbiAgICBpZihzaCA+PSB0aGlzLkRCKSBzaCAtPSB0aGlzLkRCO1xuICB9XG4gIGlmKGsgPT0gOCAmJiAoc1swXSYweDgwKSAhPSAwKSB7XG4gICAgdGhpcy5zID0gLTE7XG4gICAgaWYoc2ggPiAwKSB0aGlzLmRhdGFbdGhpcy50LTFdIHw9ICgoMTw8KHRoaXMuREItc2gpKS0xKTw8c2g7XG4gIH1cbiAgdGhpcy5jbGFtcCgpO1xuICBpZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gIHZhciBjID0gdGhpcy5zJnRoaXMuRE07XG4gIHdoaWxlKHRoaXMudCA+IDAgJiYgdGhpcy5kYXRhW3RoaXMudC0xXSA9PSBjKSAtLXRoaXMudDtcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIGlmKHRoaXMucyA8IDApIHJldHVybiBcIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgdmFyIGttID0gKDE8PGspLTEsIGQsIG0gPSBmYWxzZSwgciA9IFwiXCIsIGkgPSB0aGlzLnQ7XG4gIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSVrO1xuICBpZihpLS0gPiAwKSB7XG4gICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzLmRhdGFbaV0+PnApID4gMCkgeyBtID0gdHJ1ZTsgciA9IGludDJjaGFyKGQpOyB9XG4gICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICBpZihwIDwgaykge1xuICAgICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KGstcCk7XG4gICAgICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLWspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT1rKSkma207XG4gICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgfVxuICAgICAgaWYoZCA+IDApIG0gPSB0cnVlO1xuICAgICAgaWYobSkgciArPSBpbnQyY2hhcihkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0/cjpcIjBcIjtcbn1cblxuLy8gKHB1YmxpYykgLXRoaXNcbmZ1bmN0aW9uIGJuTmVnYXRlKCkgeyB2YXIgciA9IG5iaSgpOyBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyxyKTsgcmV0dXJuIHI7IH1cblxuLy8gKHB1YmxpYykgfHRoaXN8XG5mdW5jdGlvbiBibkFicygpIHsgcmV0dXJuICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzOyB9XG5cbi8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG5mdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gIHZhciByID0gdGhpcy5zLWEucztcbiAgaWYociAhPSAwKSByZXR1cm4gcjtcbiAgdmFyIGkgPSB0aGlzLnQ7XG4gIHIgPSBpLWEudDtcbiAgaWYociAhPSAwKSByZXR1cm4gKHRoaXMuczwwKT8tcjpyO1xuICB3aGlsZSgtLWkgPj0gMCkgaWYoKHI9dGhpcy5kYXRhW2ldLWEuZGF0YVtpXSkgIT0gMCkgcmV0dXJuIHI7XG4gIHJldHVybiAwO1xufVxuXG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICB2YXIgciA9IDEsIHQ7XG4gIGlmKCh0PXg+Pj4xNikgIT0gMCkgeyB4ID0gdDsgciArPSAxNjsgfVxuICBpZigodD14Pj44KSAhPSAwKSB7IHggPSB0OyByICs9IDg7IH1cbiAgaWYoKHQ9eD4+NCkgIT0gMCkgeyB4ID0gdDsgciArPSA0OyB9XG4gIGlmKCh0PXg+PjIpICE9IDApIHsgeCA9IHQ7IHIgKz0gMjsgfVxuICBpZigodD14Pj4xKSAhPSAwKSB7IHggPSB0OyByICs9IDE7IH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbmZ1bmN0aW9uIGJuQml0TGVuZ3RoKCkge1xuICBpZih0aGlzLnQgPD0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpcy5kYXRhW3RoaXMudC0xXV4odGhpcy5zJnRoaXMuRE0pKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4scikge1xuICB2YXIgaTtcbiAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpK25dID0gdGhpcy5kYXRhW2ldO1xuICBmb3IoaSA9IG4tMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpXSA9IDA7XG4gIHIudCA9IHRoaXMudCtuO1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbmZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpIHtcbiAgZm9yKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaS1uXSA9IHRoaXMuZGF0YVtpXTtcbiAgci50ID0gTWF0aC5tYXgodGhpcy50LW4sMCk7XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuZnVuY3Rpb24gYm5wTFNoaWZ0VG8obixyKSB7XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxjYnMpLTE7XG4gIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKSwgYyA9ICh0aGlzLnM8PGJzKSZ0aGlzLkRNLCBpO1xuICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkge1xuICAgIHIuZGF0YVtpK2RzKzFdID0gKHRoaXMuZGF0YVtpXT4+Y2JzKXxjO1xuICAgIGMgPSAodGhpcy5kYXRhW2ldJmJtKTw8YnM7XG4gIH1cbiAgZm9yKGkgPSBkcy0xOyBpID49IDA7IC0taSkgci5kYXRhW2ldID0gMDtcbiAgci5kYXRhW2RzXSA9IGM7XG4gIHIudCA9IHRoaXMudCtkcysxO1xuICByLnMgPSB0aGlzLnM7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKSB7XG4gIHIucyA9IHRoaXMucztcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICBpZihkcyA+PSB0aGlzLnQpIHsgci50ID0gMDsgcmV0dXJuOyB9XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxicyktMTtcbiAgci5kYXRhWzBdID0gdGhpcy5kYXRhW2RzXT4+YnM7XG4gIGZvcih2YXIgaSA9IGRzKzE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgIHIuZGF0YVtpLWRzLTFdIHw9ICh0aGlzLmRhdGFbaV0mYm0pPDxjYnM7XG4gICAgci5kYXRhW2ktZHNdID0gdGhpcy5kYXRhW2ldPj5icztcbiAgfVxuICBpZihicyA+IDApIHIuZGF0YVt0aGlzLnQtZHMtMV0gfD0gKHRoaXMucyZibSk8PGNicztcbiAgci50ID0gdGhpcy50LWRzO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5wU3ViVG8oYSxyKSB7XG4gIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgd2hpbGUoaSA8IG0pIHtcbiAgICBjICs9IHRoaXMuZGF0YVtpXS1hLmRhdGFbaV07XG4gICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICAgYyA+Pj0gdGhpcy5EQjtcbiAgfVxuICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICBjIC09IGEucztcbiAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyArPSB0aGlzLnM7XG4gIH0gZWxzZSB7XG4gICAgYyArPSB0aGlzLnM7XG4gICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgYyAtPSBhLmRhdGFbaV07XG4gICAgICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgfVxuICAgIGMgLT0gYS5zO1xuICB9XG4gIHIucyA9IChjPDApPy0xOjA7XG4gIGlmKGMgPCAtMSkgci5kYXRhW2krK10gPSB0aGlzLkRWK2M7XG4gIGVsc2UgaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbiAgci50ID0gaTtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVRvKGEscikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICB2YXIgaSA9IHgudDtcbiAgci50ID0gaSt5LnQ7XG4gIHdoaWxlKC0taSA+PSAwKSByLmRhdGFbaV0gPSAwO1xuICBmb3IoaSA9IDA7IGkgPCB5LnQ7ICsraSkgci5kYXRhW2kreC50XSA9IHguYW0oMCx5LmRhdGFbaV0scixpLDAseC50KTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xuICBpZih0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG5mdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgdmFyIGkgPSByLnQgPSAyKngudDtcbiAgd2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG4gIGZvcihpID0gMDsgaSA8IHgudC0xOyArK2kpIHtcbiAgICB2YXIgYyA9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgICBpZigoci5kYXRhW2kreC50XSs9eC5hbShpKzEsMip4LmRhdGFbaV0sciwyKmkrMSxjLHgudC1pLTEpKSA+PSB4LkRWKSB7XG4gICAgICByLmRhdGFbaSt4LnRdIC09IHguRFY7XG4gICAgICByLmRhdGFbaSt4LnQrMV0gPSAxO1xuICAgIH1cbiAgfVxuICBpZihyLnQgPiAwKSByLmRhdGFbci50LTFdICs9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpIHtcbiAgdmFyIHBtID0gbS5hYnMoKTtcbiAgaWYocG0udCA8PSAwKSByZXR1cm47XG4gIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgaWYocSAhPSBudWxsKSBxLmZyb21JbnQoMCk7XG4gICAgaWYociAhPSBudWxsKSB0aGlzLmNvcHlUbyhyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYociA9PSBudWxsKSByID0gbmJpKCk7XG4gIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgdmFyIG5zaCA9IHRoaXMuREItbmJpdHMocG0uZGF0YVtwbS50LTFdKTtcdC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gIGlmKG5zaCA+IDApIHsgcG0ubFNoaWZ0VG8obnNoLHkpOyBwdC5sU2hpZnRUbyhuc2gscik7IH0gZWxzZSB7IHBtLmNvcHlUbyh5KTsgcHQuY29weVRvKHIpOyB9XG4gIHZhciB5cyA9IHkudDtcbiAgdmFyIHkwID0geS5kYXRhW3lzLTFdO1xuICBpZih5MCA9PSAwKSByZXR1cm47XG4gIHZhciB5dCA9IHkwKigxPDx0aGlzLkYxKSsoKHlzPjEpP3kuZGF0YVt5cy0yXT4+dGhpcy5GMjowKTtcbiAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICB2YXIgaSA9IHIudCwgaiA9IGkteXMsIHQgPSAocT09bnVsbCk/bmJpKCk6cTtcbiAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHIuZGF0YVtyLnQrK10gPSAxO1xuICAgIHIuc3ViVG8odCxyKTtcbiAgfVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsdCk7XG4gIHQuc3ViVG8oeSx5KTtcdC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlKHkudCA8IHlzKSB5LmRhdGFbeS50KytdID0gMDtcbiAgd2hpbGUoLS1qID49IDApIHtcbiAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgIHZhciBxZCA9IChyLmRhdGFbLS1pXT09eTApP3RoaXMuRE06TWF0aC5mbG9vcihyLmRhdGFbaV0qZDErKHIuZGF0YVtpLTFdK2UpKmQyKTtcbiAgICBpZigoci5kYXRhW2ldKz15LmFtKDAscWQscixqLDAseXMpKSA8IHFkKSB7XHQvLyBUcnkgaXQgb3V0XG4gICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgci5zdWJUbyh0LHIpO1xuICAgICAgd2hpbGUoci5kYXRhW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgIH1cbiAgfVxuICBpZihxICE9IG51bGwpIHtcbiAgICByLmRyU2hpZnRUbyh5cyxxKTtcbiAgICBpZih0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSk7XG4gIH1cbiAgci50ID0geXM7XG4gIHIuY2xhbXAoKTtcbiAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7XHQvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5iaSgpO1xuICB0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtcbiAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG5mdW5jdGlvbiBDbGFzc2ljKG0pIHsgdGhpcy5tID0gbTsgfVxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gIGVsc2UgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkgeyB4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpOyB9XG5mdW5jdGlvbiBjTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5mdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbkNsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG5DbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmKHRoaXMudCA8IDEpIHJldHVybiAwO1xuICB2YXIgeCA9IHRoaXMuZGF0YVswXTtcbiAgaWYoKHgmMSkgPT0gMCkgcmV0dXJuIDA7XG4gIHZhciB5ID0geCYzO1x0XHQvLyB5ID09IDEveCBtb2QgMl4yXG4gIHkgPSAoeSooMi0oeCYweGYpKnkpKSYweGY7XHQvLyB5ID09IDEveCBtb2QgMl40XG4gIHkgPSAoeSooMi0oeCYweGZmKSp5KSkmMHhmZjtcdC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgeSA9ICh5KigyLSgoKHgmMHhmZmZmKSp5KSYweGZmZmYpKSkmMHhmZmZmO1x0Ly8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5KigyLXgqeSV0aGlzLkRWKSkldGhpcy5EVjtcdFx0Ly8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5PjApP3RoaXMuRFYteToteTtcbn1cblxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbmZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICB0aGlzLm0gPSBtO1xuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICB0aGlzLm1wbCA9IHRoaXMubXAmMHg3ZmZmO1xuICB0aGlzLm1waCA9IHRoaXMubXA+PjE1O1xuICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgdGhpcy5tdDIgPSAyKm0udDtcbn1cblxuLy8geFIgbW9kIG1cbmZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gIHIuZGl2UmVtVG8odGhpcy5tLG51bGwscik7XG4gIGlmKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5jb3B5VG8ocik7XG4gIHRoaXMucmVkdWNlKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gIHdoaWxlKHgudCA8PSB0aGlzLm10MilcdC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgIHguZGF0YVt4LnQrK10gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4LmRhdGFbaV0qbXAgbW9kIERWXG4gICAgdmFyIGogPSB4LmRhdGFbaV0mMHg3ZmZmO1xuICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHguZGF0YVtpXT4+MTUpKnRoaXMubXBsKSZ0aGlzLnVtKTw8MTUpKSZ4LkRNO1xuICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgIGogPSBpK3RoaXMubS50O1xuICAgIHguZGF0YVtqXSArPSB0aGlzLm0uYW0oMCx1MCx4LGksMCx0aGlzLm0udCk7XG4gICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgd2hpbGUoeC5kYXRhW2pdID49IHguRFYpIHsgeC5kYXRhW2pdIC09IHguRFY7IHguZGF0YVsrK2pdKys7IH1cbiAgfVxuICB4LmNsYW1wKCk7XG4gIHguZHJTaGlmdFRvKHRoaXMubS50LHgpO1xuICBpZih4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xufVxuXG4vLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbmZ1bmN0aW9uIG1vbnRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuZnVuY3Rpb24gbW9udE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnQ7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbk1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xuTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuZnVuY3Rpb24gYm5wSXNFdmVuKCkgeyByZXR1cm4gKCh0aGlzLnQ+MCk/KHRoaXMuZGF0YVswXSYxKTp0aGlzLnMpID09IDA7IH1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUseikge1xuICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICB2YXIgciA9IG5iaSgpLCByMiA9IG5iaSgpLCBnID0gei5jb252ZXJ0KHRoaXMpLCBpID0gbmJpdHMoZSktMTtcbiAgZy5jb3B5VG8ocik7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLHIyKTtcbiAgICBpZigoZSYoMTw8aSkpID4gMCkgei5tdWxUbyhyMixnLHIpO1xuICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLG0pIHtcbiAgdmFyIHo7XG4gIGlmKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pOyBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgcmV0dXJuIHRoaXMuZXhwKGUseik7XG59XG5cbi8vIHByb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcblxuLy8gcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBqc2JuMiBsaWJcblxuLy9Db3B5cmlnaHQgKGMpIDIwMDUtMjAwOSAgVG9tIFd1XG4vL0FsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1NlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscyAoU2VlIGpzYm4uanMgZm9yIExJQ0VOU0UpLlxuXG4vL0V4dGVuZGVkIEphdmFTY3JpcHQgQk4gZnVuY3Rpb25zLCByZXF1aXJlZCBmb3IgUlNBIHByaXZhdGUgb3BzLlxuXG4vL1ZlcnNpb24gMS4xOiBuZXcgQmlnSW50ZWdlcihcIjBcIiwgMTApIHJldHVybnMgXCJwcm9wZXJcIiB6ZXJvXG5cbi8vKHB1YmxpYylcbmZ1bmN0aW9uIGJuQ2xvbmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuY29weVRvKHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG5mdW5jdGlvbiBibkludFZhbHVlKCkge1xuaWYodGhpcy5zIDwgMCkge1xuIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdLXRoaXMuRFY7XG4gZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIC0xO1xufSBlbHNlIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdO1xuZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIDA7XG4vLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxucmV0dXJuICgodGhpcy5kYXRhWzFdJigoMTw8KDMyLXRoaXMuREIpKS0xKSk8PHRoaXMuREIpfHRoaXMuZGF0YVswXTtcbn1cblxuLy8ocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MjQpPj4yNDsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG5mdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MTYpPj4xNjsgfVxuXG4vLyhwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbmZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpOyB9XG5cbi8vKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbmZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuaWYodGhpcy5zIDwgMCkgcmV0dXJuIC0xO1xuZWxzZSBpZih0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpcy5kYXRhWzBdIDw9IDApKSByZXR1cm4gMDtcbmVsc2UgcmV0dXJuIDE7XG59XG5cbi8vKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuaWYoYiA9PSBudWxsKSBiID0gMTA7XG5pZih0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSByZXR1cm4gXCIwXCI7XG52YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbnZhciBhID0gTWF0aC5wb3coYixjcyk7XG52YXIgZCA9IG5idihhKSwgeSA9IG5iaSgpLCB6ID0gbmJpKCksIHIgPSBcIlwiO1xudGhpcy5kaXZSZW1UbyhkLHkseik7XG53aGlsZSh5LnNpZ251bSgpID4gMCkge1xuIHIgPSAoYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4geS5kaXZSZW1UbyhkLHkseik7XG59XG5yZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbn1cblxuLy8ocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBGcm9tUmFkaXgocyxiKSB7XG50aGlzLmZyb21JbnQoMCk7XG5pZihiID09IG51bGwpIGIgPSAxMDtcbnZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xudmFyIGQgPSBNYXRoLnBvdyhiLGNzKSwgbWkgPSBmYWxzZSwgaiA9IDAsIHcgPSAwO1xuZm9yKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiB2YXIgeCA9IGludEF0KHMsaSk7XG4gaWYoeCA8IDApIHtcbiAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHRoaXMuc2lnbnVtKCkgPT0gMCkgbWkgPSB0cnVlO1xuICAgY29udGludWU7XG4gfVxuIHcgPSBiKncreDtcbiBpZigrK2ogPj0gY3MpIHtcbiAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG4gICBqID0gMDtcbiAgIHcgPSAwO1xuIH1cbn1cbmlmKGogPiAwKSB7XG4gdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7XG4gdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG59XG5pZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsYixjKSB7XG5pZihcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gaWYoYSA8IDIpIHRoaXMuZnJvbUludCgxKTtcbiBlbHNlIHtcbiAgIHRoaXMuZnJvbU51bWJlcihhLGMpO1xuICAgaWYoIXRoaXMudGVzdEJpdChhLTEpKSAgLy8gZm9yY2UgTVNCIHNldFxuICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxvcF9vcix0aGlzKTtcbiAgIGlmKHRoaXMuaXNFdmVuKCkpIHRoaXMuZEFkZE9mZnNldCgxLDApOyAvLyBmb3JjZSBvZGRcbiAgIHdoaWxlKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICB0aGlzLmRBZGRPZmZzZXQoMiwwKTtcbiAgICAgaWYodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksdGhpcyk7XG4gICB9XG4gfVxufSBlbHNlIHtcbiAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuIHZhciB4ID0gbmV3IEFycmF5KCksIHQgPSBhJjc7XG4geC5sZW5ndGggPSAoYT4+MykrMTtcbiBiLm5leHRCeXRlcyh4KTtcbiBpZih0ID4gMCkgeFswXSAmPSAoKDE8PHQpLTEpOyBlbHNlIHhbMF0gPSAwO1xuIHRoaXMuZnJvbVN0cmluZyh4LDI1Nik7XG59XG59XG5cbi8vKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbnZhciBpID0gdGhpcy50LCByID0gbmV3IEFycmF5KCk7XG5yWzBdID0gdGhpcy5zO1xudmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJTgsIGQsIGsgPSAwO1xuaWYoaS0tID4gMCkge1xuIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldPj5wKSAhPSAodGhpcy5zJnRoaXMuRE0pPj5wKVxuICAgcltrKytdID0gZHwodGhpcy5zPDwodGhpcy5EQi1wKSk7XG4gd2hpbGUoaSA+PSAwKSB7XG4gICBpZihwIDwgOCkge1xuICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KDgtcCk7XG4gICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLTgpO1xuICAgfSBlbHNlIHtcbiAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT04KSkmMHhmZjtcbiAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICB9XG4gICBpZigoZCYweDgwKSAhPSAwKSBkIHw9IC0yNTY7XG4gICBpZihrID09IDAgJiYgKHRoaXMucyYweDgwKSAhPSAoZCYweDgwKSkgKytrO1xuICAgaWYoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHJbaysrXSA9IGQ7XG4gfVxufVxucmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJuRXF1YWxzKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPT0wKTsgfVxuZnVuY3Rpb24gYm5NaW4oYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk8MCk/dGhpczphOyB9XG5mdW5jdGlvbiBibk1heChhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT4wKT90aGlzOmE7IH1cblxuLy8ocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsb3Ascikge1xudmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbmZvcihpID0gMDsgaSA8IG07ICsraSkgci5kYXRhW2ldID0gb3AodGhpcy5kYXRhW2ldLGEuZGF0YVtpXSk7XG5pZihhLnQgPCB0aGlzLnQpIHtcbiBmID0gYS5zJnRoaXMuRE07XG4gZm9yKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHIuZGF0YVtpXSA9IG9wKHRoaXMuZGF0YVtpXSxmKTtcbiByLnQgPSB0aGlzLnQ7XG59IGVsc2Uge1xuIGYgPSB0aGlzLnMmdGhpcy5ETTtcbiBmb3IoaSA9IG07IGkgPCBhLnQ7ICsraSkgci5kYXRhW2ldID0gb3AoZixhLmRhdGFbaV0pO1xuIHIudCA9IGEudDtcbn1cbnIucyA9IG9wKHRoaXMucyxhLnMpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCx5KSB7IHJldHVybiB4Jnk7IH1cbmZ1bmN0aW9uIGJuQW5kKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmQscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyB8IGFcbmZ1bmN0aW9uIG9wX29yKHgseSkgeyByZXR1cm4geHx5OyB9XG5mdW5jdGlvbiBibk9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgseSkgeyByZXR1cm4geF55OyB9XG5mdW5jdGlvbiBiblhvcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfeG9yLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgseSkgeyByZXR1cm4geCZ+eTsgfVxuZnVuY3Rpb24gYm5BbmROb3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZG5vdCxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB+dGhpc1xuZnVuY3Rpb24gYm5Ob3QoKSB7XG52YXIgciA9IG5iaSgpO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaV0gPSB0aGlzLkRNJn50aGlzLmRhdGFbaV07XG5yLnQgPSB0aGlzLnQ7XG5yLnMgPSB+dGhpcy5zO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA8PCBuXG5mdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG52YXIgciA9IG5iaSgpO1xuaWYobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5sU2hpZnRUbyhuLHIpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA+PiBuXG5mdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xudmFyIHIgPSBuYmkoKTtcbmlmKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtcbnJldHVybiByO1xufVxuXG4vL3JldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuaWYoeCA9PSAwKSByZXR1cm4gLTE7XG52YXIgciA9IDA7XG5pZigoeCYweGZmZmYpID09IDApIHsgeCA+Pj0gMTY7IHIgKz0gMTY7IH1cbmlmKCh4JjB4ZmYpID09IDApIHsgeCA+Pj0gODsgciArPSA4OyB9XG5pZigoeCYweGYpID09IDApIHsgeCA+Pj0gNDsgciArPSA0OyB9XG5pZigoeCYzKSA9PSAwKSB7IHggPj49IDI7IHIgKz0gMjsgfVxuaWYoKHgmMSkgPT0gMCkgKytyO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG5mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbmZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiBpZih0aGlzLmRhdGFbaV0gIT0gMCkgcmV0dXJuIGkqdGhpcy5EQitsYml0KHRoaXMuZGF0YVtpXSk7XG5pZih0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50KnRoaXMuREI7XG5yZXR1cm4gLTE7XG59XG5cbi8vcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG52YXIgciA9IDA7XG53aGlsZSh4ICE9IDApIHsgeCAmPSB4LTE7ICsrcjsgfVxucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuZnVuY3Rpb24gYm5CaXRDb3VudCgpIHtcbnZhciByID0gMCwgeCA9IHRoaXMucyZ0aGlzLkRNO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpcy5kYXRhW2ldXngpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbmZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG52YXIgaiA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbmlmKGogPj0gdGhpcy50KSByZXR1cm4odGhpcy5zIT0wKTtcbnJldHVybigodGhpcy5kYXRhW2pdJigxPDwobiV0aGlzLkRCKSkpIT0wKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sb3ApIHtcbnZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xudGhpcy5iaXR3aXNlVG8ocixvcCxyKTtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgfCAoMTw8bilcbmZ1bmN0aW9uIGJuU2V0Qml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbmZ1bmN0aW9uIGJuQ2xlYXJCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuZnVuY3Rpb24gYm5GbGlwQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKTsgfVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuZnVuY3Rpb24gYm5wQWRkVG8oYSxyKSB7XG52YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG53aGlsZShpIDwgbSkge1xuIGMgKz0gdGhpcy5kYXRhW2ldK2EuZGF0YVtpXTtcbiByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiBjID4+PSB0aGlzLkRCO1xufVxuaWYoYS50IDwgdGhpcy50KSB7XG4gYyArPSBhLnM7XG4gd2hpbGUoaSA8IHRoaXMudCkge1xuICAgYyArPSB0aGlzLmRhdGFbaV07XG4gICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgIGMgPj49IHRoaXMuREI7XG4gfVxuIGMgKz0gdGhpcy5zO1xufSBlbHNlIHtcbiBjICs9IHRoaXMucztcbiB3aGlsZShpIDwgYS50KSB7XG4gICBjICs9IGEuZGF0YVtpXTtcbiAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgYyA+Pj0gdGhpcy5EQjtcbiB9XG4gYyArPSBhLnM7XG59XG5yLnMgPSAoYzwwKT8tMTowO1xuaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbmVsc2UgaWYoYyA8IC0xKSByLmRhdGFbaSsrXSA9IHRoaXMuRFYrYztcbnIudCA9IGk7XG5yLmNsYW1wKCk7XG59XG5cbi8vKHB1YmxpYykgdGhpcyArIGFcbmZ1bmN0aW9uIGJuQWRkKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5hZGRUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgLSBhXG5mdW5jdGlvbiBiblN1YnRyYWN0KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5zdWJUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgKiBhXG5mdW5jdGlvbiBibk11bHRpcGx5KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5tdWx0aXBseVRvKGEscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAvIGFcbmZ1bmN0aW9uIGJuRGl2aWRlKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAlIGFcbmZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLG51bGwscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG5mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG52YXIgcSA9IG5iaSgpLCByID0gbmJpKCk7XG50aGlzLmRpdlJlbVRvKGEscSxyKTtcbnJldHVybiBuZXcgQXJyYXkocSxyKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pIHtcbnRoaXMuZGF0YVt0aGlzLnRdID0gdGhpcy5hbSgwLG4tMSx0aGlzLDAsMCx0aGlzLnQpO1xuKyt0aGlzLnQ7XG50aGlzLmNsYW1wKCk7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpIHtcbmlmKG4gPT0gMCkgcmV0dXJuO1xud2hpbGUodGhpcy50IDw9IHcpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xudGhpcy5kYXRhW3ddICs9IG47XG53aGlsZSh0aGlzLmRhdGFbd10gPj0gdGhpcy5EVikge1xuIHRoaXMuZGF0YVt3XSAtPSB0aGlzLkRWO1xuIGlmKCsrdyA+PSB0aGlzLnQpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xuICsrdGhpcy5kYXRhW3ddO1xufVxufVxuXG4vL0EgXCJudWxsXCIgcmVkdWNlclxuZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG5mdW5jdGlvbiBuTm9wKHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIG5NdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgfVxuZnVuY3Rpb24gblNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB9XG5cbk51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbk51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvO1xuTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lXG5mdW5jdGlvbiBiblBvdyhlKSB7IHJldHVybiB0aGlzLmV4cChlLG5ldyBOdWxsRXhwKCkpOyB9XG5cbi8vKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSxuLHIpIHtcbnZhciBpID0gTWF0aC5taW4odGhpcy50K2EudCxuKTtcbnIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbnIudCA9IGk7XG53aGlsZShpID4gMCkgci5kYXRhWy0taV0gPSAwO1xudmFyIGo7XG5mb3IoaiA9IHIudC10aGlzLnQ7IGkgPCBqOyArK2kpIHIuZGF0YVtpK3RoaXMudF0gPSB0aGlzLmFtKDAsYS5kYXRhW2ldLHIsaSwwLHRoaXMudCk7XG5mb3IoaiA9IE1hdGgubWluKGEudCxuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLGEuZGF0YVtpXSxyLGksMCxuLWkpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSxuLHIpIHtcbi0tbjtcbnZhciBpID0gci50ID0gdGhpcy50K2EudC1uO1xuci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxud2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG5mb3IoaSA9IE1hdGgubWF4KG4tdGhpcy50LDApOyBpIDwgYS50OyArK2kpXG4gci5kYXRhW3RoaXMudCtpLW5dID0gdGhpcy5hbShuLWksYS5kYXRhW2ldLHIsMCwwLHRoaXMudCtpLW4pO1xuci5jbGFtcCgpO1xuci5kclNoaWZ0VG8oMSxyKTtcbn1cblxuLy9CYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG5mdW5jdGlvbiBCYXJyZXR0KG0pIHtcbi8vIHNldHVwIEJhcnJldHRcbnRoaXMucjIgPSBuYmkoKTtcbnRoaXMucTMgPSBuYmkoKTtcbkJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTtcbnRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbnRoaXMubSA9IG07XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbmlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG5lbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbmVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuXG4vL3ggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbnguZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7XG5pZih4LnQgPiB0aGlzLm0udCsxKSB7IHgudCA9IHRoaXMubS50KzE7IHguY2xhbXAoKTsgfVxudGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpO1xudGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7XG53aGlsZSh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO1xueC5zdWJUbyh0aGlzLnIyLHgpO1xud2hpbGUoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbn1cblxuLy9yID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy9yID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuZnVuY3Rpb24gYm5Nb2RQb3coZSxtKSB7XG52YXIgaSA9IGUuYml0TGVuZ3RoKCksIGssIHIgPSBuYnYoMSksIHo7XG5pZihpIDw9IDApIHJldHVybiByO1xuZWxzZSBpZihpIDwgMTgpIGsgPSAxO1xuZWxzZSBpZihpIDwgNDgpIGsgPSAzO1xuZWxzZSBpZihpIDwgMTQ0KSBrID0gNDtcbmVsc2UgaWYoaSA8IDc2OCkgayA9IDU7XG5lbHNlIGsgPSA2O1xuaWYoaSA8IDgpXG4geiA9IG5ldyBDbGFzc2ljKG0pO1xuZWxzZSBpZihtLmlzRXZlbigpKVxuIHogPSBuZXcgQmFycmV0dChtKTtcbmVsc2VcbiB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG5cbi8vIHByZWNvbXB1dGF0aW9uXG52YXIgZyA9IG5ldyBBcnJheSgpLCBuID0gMywgazEgPSBrLTEsIGttID0gKDE8PGspLTE7XG5nWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuaWYoayA+IDEpIHtcbiB2YXIgZzIgPSBuYmkoKTtcbiB6LnNxclRvKGdbMV0sZzIpO1xuIHdoaWxlKG4gPD0ga20pIHtcbiAgIGdbbl0gPSBuYmkoKTtcbiAgIHoubXVsVG8oZzIsZ1tuLTJdLGdbbl0pO1xuICAgbiArPSAyO1xuIH1cbn1cblxudmFyIGogPSBlLnQtMSwgdywgaXMxID0gdHJ1ZSwgcjIgPSBuYmkoKSwgdDtcbmkgPSBuYml0cyhlLmRhdGFbal0pLTE7XG53aGlsZShqID49IDApIHtcbiBpZihpID49IGsxKSB3ID0gKGUuZGF0YVtqXT4+KGktazEpKSZrbTtcbiBlbHNlIHtcbiAgIHcgPSAoZS5kYXRhW2pdJigoMTw8KGkrMSkpLTEpKTw8KGsxLWkpO1xuICAgaWYoaiA+IDApIHcgfD0gZS5kYXRhW2otMV0+Pih0aGlzLkRCK2ktazEpO1xuIH1cblxuIG4gPSBrO1xuIHdoaWxlKCh3JjEpID09IDApIHsgdyA+Pj0gMTsgLS1uOyB9XG4gaWYoKGkgLT0gbikgPCAwKSB7IGkgKz0gdGhpcy5EQjsgLS1qOyB9XG4gaWYoaXMxKSB7ICAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICBnW3ddLmNvcHlUbyhyKTtcbiAgIGlzMSA9IGZhbHNlO1xuIH0gZWxzZSB7XG4gICB3aGlsZShuID4gMSkgeyB6LnNxclRvKHIscjIpOyB6LnNxclRvKHIyLHIpOyBuIC09IDI7IH1cbiAgIGlmKG4gPiAwKSB6LnNxclRvKHIscjIpOyBlbHNlIHsgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICB6Lm11bFRvKHIyLGdbd10scik7XG4gfVxuXG4gd2hpbGUoaiA+PSAwICYmIChlLmRhdGFbal0mKDE8PGkpKSA9PSAwKSB7XG4gICB6LnNxclRvKHIscjIpOyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7XG4gICBpZigtLWkgPCAwKSB7IGkgPSB0aGlzLkRCLTE7IC0tajsgfVxuIH1cbn1cbnJldHVybiB6LnJldmVydChyKTtcbn1cblxuLy8ocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuZnVuY3Rpb24gYm5HQ0QoYSkge1xudmFyIHggPSAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpcy5jbG9uZSgpO1xudmFyIHkgPSAoYS5zPDApP2EubmVnYXRlKCk6YS5jbG9uZSgpO1xuaWYoeC5jb21wYXJlVG8oeSkgPCAwKSB7IHZhciB0ID0geDsgeCA9IHk7IHkgPSB0OyB9XG52YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCksIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuaWYoZyA8IDApIHJldHVybiB4O1xuaWYoaSA8IGcpIGcgPSBpO1xuaWYoZyA+IDApIHtcbiB4LnJTaGlmdFRvKGcseCk7XG4geS5yU2hpZnRUbyhnLHkpO1xufVxud2hpbGUoeC5zaWdudW0oKSA+IDApIHtcbiBpZigoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLHgpO1xuIGlmKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGkseSk7XG4gaWYoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgeC5zdWJUbyh5LHgpO1xuICAgeC5yU2hpZnRUbygxLHgpO1xuIH0gZWxzZSB7XG4gICB5LnN1YlRvKHgseSk7XG4gICB5LnJTaGlmdFRvKDEseSk7XG4gfVxufVxuaWYoZyA+IDApIHkubFNoaWZ0VG8oZyx5KTtcbnJldHVybiB5O1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbmlmKG4gPD0gMCkgcmV0dXJuIDA7XG52YXIgZCA9IHRoaXMuRFYlbiwgciA9ICh0aGlzLnM8MCk/bi0xOjA7XG5pZih0aGlzLnQgPiAwKVxuIGlmKGQgPT0gMCkgciA9IHRoaXMuZGF0YVswXSVuO1xuIGVsc2UgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByID0gKGQqcit0aGlzLmRhdGFbaV0pJW47XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG5mdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xudmFyIGFjID0gbS5pc0V2ZW4oKTtcbmlmKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG52YXIgdSA9IG0uY2xvbmUoKSwgdiA9IHRoaXMuY2xvbmUoKTtcbnZhciBhID0gbmJ2KDEpLCBiID0gbmJ2KDApLCBjID0gbmJ2KDApLCBkID0gbmJ2KDEpO1xud2hpbGUodS5zaWdudW0oKSAhPSAwKSB7XG4gd2hpbGUodS5pc0V2ZW4oKSkge1xuICAgdS5yU2hpZnRUbygxLHUpO1xuICAgaWYoYWMpIHtcbiAgICAgaWYoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHsgYS5hZGRUbyh0aGlzLGEpOyBiLnN1YlRvKG0sYik7IH1cbiAgICAgYS5yU2hpZnRUbygxLGEpO1xuICAgfSBlbHNlIGlmKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sYik7XG4gICBiLnJTaGlmdFRvKDEsYik7XG4gfVxuIHdoaWxlKHYuaXNFdmVuKCkpIHtcbiAgIHYuclNoaWZ0VG8oMSx2KTtcbiAgIGlmKGFjKSB7XG4gICAgIGlmKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7IGMuYWRkVG8odGhpcyxjKTsgZC5zdWJUbyhtLGQpOyB9XG4gICAgIGMuclNoaWZ0VG8oMSxjKTtcbiAgIH0gZWxzZSBpZighZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLGQpO1xuICAgZC5yU2hpZnRUbygxLGQpO1xuIH1cbiBpZih1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICB1LnN1YlRvKHYsdSk7XG4gICBpZihhYykgYS5zdWJUbyhjLGEpO1xuICAgYi5zdWJUbyhkLGIpO1xuIH0gZWxzZSB7XG4gICB2LnN1YlRvKHUsdik7XG4gICBpZihhYykgYy5zdWJUbyhhLGMpO1xuICAgZC5zdWJUbyhiLGQpO1xuIH1cbn1cbmlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuaWYoZC5jb21wYXJlVG8obSkgPj0gMCkgcmV0dXJuIGQuc3VidHJhY3QobSk7XG5pZihkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLGQpOyBlbHNlIHJldHVybiBkO1xuaWYoZC5zaWdudW0oKSA8IDApIHJldHVybiBkLmFkZChtKTsgZWxzZSByZXR1cm4gZDtcbn1cblxudmFyIGxvd3ByaW1lcyA9IFsyLDMsNSw3LDExLDEzLDE3LDE5LDIzLDI5LDMxLDM3LDQxLDQzLDQ3LDUzLDU5LDYxLDY3LDcxLDczLDc5LDgzLDg5LDk3LDEwMSwxMDMsMTA3LDEwOSwxMTMsMTI3LDEzMSwxMzcsMTM5LDE0OSwxNTEsMTU3LDE2MywxNjcsMTczLDE3OSwxODEsMTkxLDE5MywxOTcsMTk5LDIxMSwyMjMsMjI3LDIyOSwyMzMsMjM5LDI0MSwyNTEsMjU3LDI2MywyNjksMjcxLDI3NywyODEsMjgzLDI5MywzMDcsMzExLDMxMywzMTcsMzMxLDMzNywzNDcsMzQ5LDM1MywzNTksMzY3LDM3MywzNzksMzgzLDM4OSwzOTcsNDAxLDQwOSw0MTksNDIxLDQzMSw0MzMsNDM5LDQ0Myw0NDksNDU3LDQ2MSw0NjMsNDY3LDQ3OSw0ODcsNDkxLDQ5OSw1MDMsNTA5XTtcbnZhciBscGxpbSA9ICgxPDwyNikvbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV07XG5cbi8vKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG5mdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG52YXIgaSwgeCA9IHRoaXMuYWJzKCk7XG5pZih4LnQgPT0gMSAmJiB4LmRhdGFbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV0pIHtcbiBmb3IoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICBpZih4LmRhdGFbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZTtcbiByZXR1cm4gZmFsc2U7XG59XG5pZih4LmlzRXZlbigpKSByZXR1cm4gZmFsc2U7XG5pID0gMTtcbndoaWxlKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gdmFyIG0gPSBsb3dwcmltZXNbaV0sIGogPSBpKzE7XG4gd2hpbGUoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdO1xuIG0gPSB4Lm1vZEludChtKTtcbiB3aGlsZShpIDwgaikgaWYobSVsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2U7XG59XG5yZXR1cm4geC5taWxsZXJSYWJpbih0KTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xudmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG52YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuaWYoayA8PSAwKSByZXR1cm4gZmFsc2U7XG52YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG52YXIgcHJuZyA9IGJuR2V0UHJuZygpO1xudmFyIGE7XG5mb3IodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gLy8gc2VsZWN0IHdpdG5lc3MgJ2EnIGF0IHJhbmRvbSBmcm9tIGJldHdlZW4gMSBhbmQgbjFcbiBkbyB7XG4gICBhID0gbmV3IEJpZ0ludGVnZXIodGhpcy5iaXRMZW5ndGgoKSwgcHJuZyk7XG4gfVxuIHdoaWxlKGEuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA8PSAwIHx8IGEuY29tcGFyZVRvKG4xKSA+PSAwKTtcbiB2YXIgeSA9IGEubW9kUG93KHIsdGhpcyk7XG4gaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgIHZhciBqID0gMTtcbiAgIHdoaWxlKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgeSA9IHkubW9kUG93SW50KDIsdGhpcyk7XG4gICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBpZih5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlO1xuIH1cbn1cbnJldHVybiB0cnVlO1xufVxuXG4vLyBnZXQgcHNldWRvIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5mdW5jdGlvbiBibkdldFBybmcoKSB7XG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgcmV0dXJuIHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vL3Byb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gYm5wQWRkVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XG5cbi8vcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBiblNpZ051bTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gYm5TZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gYm5BZGQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBibkRpdmlkZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG5cbi8vQmlnSW50ZWdlciBpbnRlcmZhY2VzIG5vdCBpbXBsZW1lbnRlZCBpbiBqc2JuOlxuXG4vL0JpZ0ludGVnZXIoaW50IHNpZ251bSwgYnl0ZVtdIG1hZ25pdHVkZSlcbi8vZG91YmxlIGRvdWJsZVZhbHVlKClcbi8vZmxvYXQgZmxvYXRWYWx1ZSgpXG4vL2ludCBoYXNoQ29kZSgpXG4vL2xvbmcgbG9uZ1ZhbHVlKClcbi8vc3RhdGljIEJpZ0ludGVnZXIgdmFsdWVPZihsb25nIHZhbClcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMTYwLWJpdCBkaWdlc3QgKFNIQS0xKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHNoYTEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnNoYTEgPSBmb3JnZS5zaGExIHx8IHt9O1xuZm9yZ2UubWQuc2hhMSA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMSA9IHNoYTE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNIQS0xIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICovXG5zaGExLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMSBzdGF0ZSBjb250YWlucyBmaXZlIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg4MCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGExJyxcbiAgICBibG9ja0xlbmd0aDogNjQsXG4gICAgZGlnZXN0TGVuZ3RoOiAyMCxcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDY0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGg2NCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9zdGF0ZSA9IHtcbiAgICAgIGgwOiAweDY3NDUyMzAxLFxuICAgICAgaDE6IDB4RUZDREFCODksXG4gICAgICBoMjogMHg5OEJBRENGRSxcbiAgICAgIGgzOiAweDEwMzI1NDc2LFxuICAgICAgaDQ6IDB4QzNEMkUxRjBcbiAgICB9O1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgLy8gc3RhcnQgZGlnZXN0IGF1dG9tYXRpY2FsbHkgZm9yIGZpcnN0IHRpbWVcbiAgbWQuc3RhcnQoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGlnZXN0IHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgaW5wdXQuIFRoZSBnaXZlbiBpbnB1dCBjYW5cbiAgICogdHJlYXRlZCBhcyByYXcgaW5wdXQgKG5vIGVuY29kaW5nIHdpbGwgYmUgYXBwbGllZCkgb3IgYW4gZW5jb2Rpbmcgb2ZcbiAgICogJ3V0ZjgnIG1heWJlIGdpdmVuIHRvIGVuY29kZSB0aGUgaW5wdXQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgdGhlIG1lc3NhZ2UgaW5wdXQgdG8gdXBkYXRlIHdpdGguXG4gICAqIEBwYXJhbSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQudXBkYXRlID0gZnVuY3Rpb24obXNnLCBlbmNvZGluZykge1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIG1zZyA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtZXNzYWdlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgIG1kLm1lc3NhZ2VMZW5ndGggKz0gbGVuO1xuICAgIGxlbiA9IFsobGVuIC8gMHgxMDAwMDAwMDApID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICBsZW5bMV0gPSBsZW5bMF0gKyAoKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPj4+IDA7XG4gICAgICBsZW5bMF0gPSAoKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX3N0YXRlLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgIC8qKlxuICAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICAqXG4gICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgICovXG4gICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTEgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDggYnl0ZXMgKDY0XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSA1NiBieXRlc1xuICAgICg0NDggYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiBiZWNhdXNlXG4gICAgNTEyIC0gMTI4ID0gNDQ4LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiwgdGhlbiA1MTIgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeSBmcm9tIG5leHQgaW50XG4gICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgY2FycnkgPSAobmV4dCAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgYml0cyA9IG5leHQgPj4+IDA7XG4gICAgfVxuICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG5cbiAgICB2YXIgczIgPSB7XG4gICAgICBoMDogX3N0YXRlLmgwLFxuICAgICAgaDE6IF9zdGF0ZS5oMSxcbiAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICBoMzogX3N0YXRlLmgzLFxuICAgICAgaDQ6IF9zdGF0ZS5oNFxuICAgIH07XG4gICAgX3VwZGF0ZShzMiwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgxKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgyKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg0KTtcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtMSBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgNjQpO1xuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBTSEEtMSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gcyB0aGUgU0hBLTEgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQsIGEsIGIsIGMsIGQsIGUsIGYsIGk7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDY0KSB7XG4gICAgLy8gdGhlIHcgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBzaXh0ZWVuIDMyLWJpdCBiaWctZW5kaWFuIHdvcmRzXG4gICAgLy8gYW5kIHRoZW4gZXh0ZW5kZWQgaW50byA4MCAzMi1iaXQgd29yZHMgYWNjb3JkaW5nIHRvIFNIQS0xIGFsZ29yaXRobVxuICAgIC8vIGFuZCBmb3IgMzItNzkgdXNpbmcgTWF4IExvY2t0eXVraGluJ3Mgb3B0aW1pemF0aW9uXG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhID0gcy5oMDtcbiAgICBiID0gcy5oMTtcbiAgICBjID0gcy5oMjtcbiAgICBkID0gcy5oMztcbiAgICBlID0gcy5oNDtcblxuICAgIC8vIHJvdW5kIDFcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB0ID0gYnl0ZXMuZ2V0SW50MzIoKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIGZvcig7IGkgPCAyMDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDNdIF4gd1tpIC0gOF0gXiB3W2kgLSAxNF0gXiB3W2kgLSAxNl0pO1xuICAgICAgdCA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDJcbiAgICBmb3IoOyBpIDwgMzI7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSAzXSBeIHdbaSAtIDhdIF4gd1tpIC0gMTRdIF4gd1tpIC0gMTZdKTtcbiAgICAgIHQgPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NkVEOUVCQTEgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDQwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg2RUQ5RUJBMSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCAzXG4gICAgZm9yKDsgaSA8IDYwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIF4gYykpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDhGMUJCQ0RDICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDRcbiAgICBmb3IoOyBpIDwgODA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweENBNjJDMUQ2ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuXG4gICAgbGVuIC09IDY0O1xuICB9XG59XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgWC41MDkgYW5kIHJlbGF0ZWQgY29tcG9uZW50cyAoc3VjaCBhc1xuICogQ2VydGlmaWNhdGlvbiBTaWduaW5nIFJlcXVlc3RzKSBvZiBhIFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIGNlcnRpZmljYXRlIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDIDI0NTkpOlxuICpcbiAqIENlcnRpZmljYXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHRic0NlcnRpZmljYXRlICAgICAgIFRCU0NlcnRpZmljYXRlLFxuICogICBzaWduYXR1cmVBbGdvcml0aG0gICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBzaWduYXR1cmVWYWx1ZSAgICAgICBCSVQgU1RSSU5HXG4gKiB9XG4gKlxuICogVEJTQ2VydGlmaWNhdGUgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgIFswXSAgRVhQTElDSVQgVmVyc2lvbiBERUZBVUxUIHYxLFxuICogICBzZXJpYWxOdW1iZXIgICAgICAgICBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlcixcbiAqICAgc2lnbmF0dXJlICAgICAgICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgaXNzdWVyICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgdmFsaWRpdHkgICAgICAgICAgICAgVmFsaWRpdHksXG4gKiAgIHN1YmplY3QgICAgICAgICAgICAgIE5hbWUsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXlJbmZvIFN1YmplY3RQdWJsaWNLZXlJbmZvLFxuICogICBpc3N1ZXJVbmlxdWVJRCAgWzFdICBJTVBMSUNJVCBVbmlxdWVJZGVudGlmaWVyIE9QVElPTkFMLFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYyIG9yIHYzXG4gKiAgIHN1YmplY3RVbmlxdWVJRCBbMl0gIElNUExJQ0lUIFVuaXF1ZUlkZW50aWZpZXIgT1BUSU9OQUwsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIC0tIElmIHByZXNlbnQsIHZlcnNpb24gc2hhbGwgYmUgdjIgb3IgdjNcbiAqICAgZXh0ZW5zaW9ucyAgICAgIFszXSAgRVhQTElDSVQgRXh0ZW5zaW9ucyBPUFRJT05BTFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYzXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUiAgeyB2MSgwKSwgdjIoMSksIHYzKDIpIH1cbiAqXG4gKiBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlciA6Oj0gSU5URUdFUlxuICpcbiAqIE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIC8vIG9ubHkgb25lIHBvc3NpYmxlIGNob2ljZSBmb3Igbm93XG4gKiAgIFJETlNlcXVlbmNlXG4gKiB9XG4gKlxuICogUkROU2VxdWVuY2UgOjo9IFNFUVVFTkNFIE9GIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqXG4gKiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIDo6PSBTRVQgT0YgQXR0cmlidXRlVHlwZUFuZFZhbHVlXG4gKlxuICogQXR0cmlidXRlVHlwZUFuZFZhbHVlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICAgIEF0dHJpYnV0ZVR5cGUsXG4gKiAgIHZhbHVlICAgIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKiBBdHRyaWJ1dGVUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWSBERUZJTkVEIEJZIEF0dHJpYnV0ZVR5cGVcbiAqXG4gKiBWYWxpZGl0eSA6Oj0gU0VRVUVOQ0Uge1xuICogICBub3RCZWZvcmUgICAgICBUaW1lLFxuICogICBub3RBZnRlciAgICAgICBUaW1lXG4gKiB9XG4gKlxuICogVGltZSA6Oj0gQ0hPSUNFIHtcbiAqICAgdXRjVGltZSAgICAgICAgVVRDVGltZSxcbiAqICAgZ2VuZXJhbFRpbWUgICAgR2VuZXJhbGl6ZWRUaW1lXG4gKiB9XG4gKlxuICogVW5pcXVlSWRlbnRpZmllciA6Oj0gQklUIFNUUklOR1xuICpcbiAqIFN1YmplY3RQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSAgICAgICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgICAgIEJJVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBFeHRlbnNpb25zIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEV4dGVuc2lvblxuICpcbiAqIEV4dGVuc2lvbiA6Oj0gU0VRVUVOQ0Uge1xuICogICBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFLFxuICogICBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBUaGUgb25seSBrZXkgYWxnb3JpdGhtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIFBLSSBpcyBSU0EuXG4gKlxuICogUlNBU1NBLVBTUyBzaWduYXR1cmVzIGFyZSBkZXNjcmliZWQgaW4gUkZDIDM0NDcgYW5kIFJGQyA0MDU1LlxuICpcbiAqIFBLQ1MjMTAgdjEuNyBkZXNjcmliZXMgY2VydGlmaWNhdGUgc2lnbmluZyByZXF1ZXN0czpcbiAqXG4gKiBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm86XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgSU5URUdFUiB7IHYxKDApIH0gKHYxLC4uLiksXG4gKiAgIHN1YmplY3QgICAgICAgTmFtZSxcbiAqICAgc3ViamVjdFBLSW5mbyBTdWJqZWN0UHVibGljS2V5SW5mb3t7IFBLSW5mb0FsZ29yaXRobXMgfX0sXG4gKiAgIGF0dHJpYnV0ZXMgICAgWzBdIEF0dHJpYnV0ZXN7eyBDUklBdHRyaWJ1dGVzIH19XG4gKiB9XG4gKlxuICogQXR0cmlidXRlcyB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVQgT0YgQXR0cmlidXRle3sgSU9TZXQgfX1cbiAqXG4gKiBDUklBdHRyaWJ1dGVzICBBVFRSSUJVVEUgIDo6PSB7XG4gKiAgIC4uLiAtLSBhZGQgYW55IGxvY2FsbHkgZGVmaW5lZCBhdHRyaWJ1dGVzIGhlcmUgLS0gfVxuICpcbiAqIEF0dHJpYnV0ZSB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICBBVFRSSUJVVEUuJmlkKHtJT1NldH0pLFxuICogICB2YWx1ZXMgU0VUIFNJWkUoMS4uTUFYKSBPRiBBVFRSSUJVVEUuJlR5cGUoe0lPU2V0fXtAdHlwZX0pXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3QgOjo9IFNFUVVFTkNFIHtcbiAqICAgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyxcbiAqICAgc2lnbmF0dXJlQWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXJ7eyBTaWduYXR1cmVBbGdvcml0aG1zIH19LFxuICogICBzaWduYXR1cmUgICAgICAgICAgQklUIFNUUklOR1xuICogfVxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKiBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIChQS0kpIGltcGxlbWVudGF0aW9uLiAqL1xudmFyIHBraSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xudmFyIG9pZHMgPSBwa2kub2lkcztcblxuLy8gc2hvcnQgbmFtZSBPSUQgbWFwcGluZ3NcbnZhciBfc2hvcnROYW1lcyA9IHt9O1xuX3Nob3J0TmFtZXNbJ0NOJ10gPSBvaWRzWydjb21tb25OYW1lJ107XG5fc2hvcnROYW1lc1snY29tbW9uTmFtZSddID0gJ0NOJztcbl9zaG9ydE5hbWVzWydDJ10gPSBvaWRzWydjb3VudHJ5TmFtZSddO1xuX3Nob3J0TmFtZXNbJ2NvdW50cnlOYW1lJ10gPSAnQyc7XG5fc2hvcnROYW1lc1snTCddID0gb2lkc1snbG9jYWxpdHlOYW1lJ107XG5fc2hvcnROYW1lc1snbG9jYWxpdHlOYW1lJ10gPSAnTCc7XG5fc2hvcnROYW1lc1snU1QnXSA9IG9pZHNbJ3N0YXRlT3JQcm92aW5jZU5hbWUnXTtcbl9zaG9ydE5hbWVzWydzdGF0ZU9yUHJvdmluY2VOYW1lJ10gPSAnU1QnO1xuX3Nob3J0TmFtZXNbJ08nXSA9IG9pZHNbJ29yZ2FuaXphdGlvbk5hbWUnXTtcbl9zaG9ydE5hbWVzWydvcmdhbml6YXRpb25OYW1lJ10gPSAnTyc7XG5fc2hvcnROYW1lc1snT1UnXSA9IG9pZHNbJ29yZ2FuaXphdGlvbmFsVW5pdE5hbWUnXTtcbl9zaG9ydE5hbWVzWydvcmdhbml6YXRpb25hbFVuaXROYW1lJ10gPSAnT1UnO1xuX3Nob3J0TmFtZXNbJ0UnXSA9IG9pZHNbJ2VtYWlsQWRkcmVzcyddO1xuX3Nob3J0TmFtZXNbJ2VtYWlsQWRkcmVzcyddID0gJ0UnO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFN1YmplY3RQdWJsaWNLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCBhbiBSU0EgcHVibGljIGtleVxudmFyIHB1YmxpY0tleVZhbGlkYXRvciA9IGZvcmdlLnBraS5yc2EucHVibGljS2V5VmFsaWRhdG9yO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFguNTA5djMgY2VydGlmaWNhdGVcbnZhciB4NTA5Q2VydGlmaWNhdGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0ZScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAndGJzQ2VydGlmaWNhdGUnLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZlcnNpb24nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDAsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uLmludGVnZXInLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmVyc2lvbidcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNlcmlhbE51bWJlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjZXJ0U2VyaWFsTnVtYmVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRpbmZvU2lnbmF0dXJlT2lkJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlQXNuMTogJ2NlcnRpbmZvU2lnbmF0dXJlUGFyYW1zJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0SXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIC8vIE5vdGU6IFVUQyBhbmQgZ2VuZXJhbGl6ZWQgdGltZXMgbWF5IGJvdGggYXBwZWFyIHNvIHRoZSBjYXB0dXJlXG4gICAgICAvLyBuYW1lcyBhcmUgYmFzZWQgb24gdGhlaXIgZGV0ZWN0ZWQgb3JkZXIsIHRoZSBuYW1lcyB1c2VkIGJlbG93XG4gICAgICAvLyBhcmUgb25seSBmb3IgdGhlIGNvbW1vbiBjYXNlLCB3aGljaCB2YWxpZGl0eSB0aW1lIHJlYWxseSBtZWFuc1xuICAgICAgLy8gXCJub3RCZWZvcmVcIiBhbmQgd2hpY2ggbWVhbnMgXCJub3RBZnRlclwiIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBvcmRlclxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKFVUQyB0aW1lIGNhc2UpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKHV0YyknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5MVVUQ1RpbWUnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKGdlbmVyYWxpemVkIHRpbWUgY2FzZSlcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZSAoZ2VuZXJhbGl6ZWQpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZSdcbiAgICAgIH0sIHtcbiAgICAgICAgLy8gbm90QWZ0ZXIgKFRpbWUpIChvbmx5IFVUQyB0aW1lIGlzIHN1cHBvcnRlZClcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEFmdGVyICh1dGMpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTNVVENUaW1lJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBub3RBZnRlciAoVGltZSkgKG9ubHkgVVRDIHRpbWUgaXMgc3VwcG9ydGVkKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKGdlbmVyYWxpemVkKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWUnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zdWJqZWN0JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U3ViamVjdCdcbiAgICB9LFxuICAgICAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgICAgIHB1YmxpY0tleVZhbGlkYXRvcixcbiAgICB7XG4gICAgICAvLyBpc3N1ZXJVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSUQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDEsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJVbmlxdWVJRC5pZCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0SXNzdWVyVW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIHN1YmplY3RVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlEJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAyLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlELmlkJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTdWJqZWN0VW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIEV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmV4dGVuc2lvbnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDMsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydEV4dGVuc2lvbnMnLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllciAoc2lnbmF0dXJlIGFsZ29yaXRobSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2NlcnRTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U2lnbmF0dXJlUGFyYW1zJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5zaWduYXR1cmVWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTaWduYXR1cmUnXG4gIH1dXG59O1xuXG52YXIgcnNhc3NhUHNzUGFyYW1ldGVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAncnNhcHNzJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnaGFzaE9pZCdcbiAgICAgICAgLyogcGFyYW1ldGVyIGJsb2NrIG9taXR0ZWQsIGZvciBTSEExIE5VTEwgYW55aG93LiAqL1xuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ21hc2tHZW5PaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtcycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1zLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYXNrR2VuSGFzaE9pZCdcbiAgICAgICAgICAvKiBwYXJhbWV0ZXIgYmxvY2sgb21pdHRlZCwgZm9yIFNIQTEgTlVMTCBhbnlob3cuICovXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnNhbHRMZW5ndGgnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMixcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3Muc2FsdExlbmd0aC5zYWx0TGVuZ3RoJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdzYWx0TGVuZ3RoJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnRyYWlsZXJGaWVsZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAzLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ3JzYXBzcy50cmFpbGVyLnRyYWlsZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5DbGFzcy5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3RyYWlsZXInXG4gICAgfV1cbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICBjYXB0dXJlQXNuMTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uaW50ZWdlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmVyc2lvbidcbiAgfSwge1xuICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLnN1YmplY3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0J1xuICB9LFxuICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gIHtcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcycsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzLnR5cGUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMudmFsdWUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlXG4gICAgICB9XVxuICAgIH1dXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgQ2VydGlmaWNhdGlvblJlcXVlc3Qgc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdCcsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdjc3InLFxuICB2YWx1ZTogW1xuICAgIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvciwge1xuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjc3JTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjc3JTaWduYXR1cmVQYXJhbXMnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIHNpZ25hdHVyZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjc3JTaWduYXR1cmUnXG4gIH1dXG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJETlNlcXVlbmNlIG9mIEFTTi4xIERFUi1lbmNvZGVkIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqIHNldHMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kIHZhbHVlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHJkbiB0aGUgUkROU2VxdWVuY2UgdG8gY29udmVydC5cbiAqIEBwYXJhbSBtZCBhIG1lc3NhZ2UgZGlnZXN0IHRvIGFwcGVuZCB0eXBlIGFuZCB2YWx1ZSB0byBpZiBwcm92aWRlZC5cbiAqL1xucGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5ID0gZnVuY3Rpb24ocmRuLCBtZCkge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIGVhY2ggdmFsdWUgaW4gJ3JkbicgaW4gaXMgYSBTRVQgb2YgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZVxuICB2YXIgc2V0LCBhdHRyLCBvYmo7XG4gIGZvcih2YXIgc2kgPSAwOyBzaSA8IHJkbi52YWx1ZS5sZW5ndGg7ICsrc2kpIHtcbiAgICAvLyBnZXQgdGhlIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgc2V0ID0gcmRuLnZhbHVlW3NpXTtcblxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIFNFVCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgc2VxdWVuY2VcbiAgICAvLyBjb250YWluaW5nIGZpcnN0IGEgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIGEgdmFsdWUgKGRlZmluZWQgYnlcbiAgICAvLyB0aGUgT0lEKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXQudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIG9iaiA9IHt9O1xuICAgICAgYXR0ciA9IHNldC52YWx1ZVtpXTtcbiAgICAgIG9iai50eXBlID0gYXNuMS5kZXJUb09pZChhdHRyLnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgIG9iai52YWx1ZSA9IGF0dHIudmFsdWVbMV0udmFsdWU7XG4gICAgICBvYmoudmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVbMV0udHlwZTtcbiAgICAgIC8vIGlmIHRoZSBPSUQgaXMga25vd24sIGdldCBpdHMgbmFtZSBhbmQgc2hvcnQgbmFtZVxuICAgICAgaWYob2JqLnR5cGUgaW4gb2lkcykge1xuICAgICAgICBvYmoubmFtZSA9IG9pZHNbb2JqLnR5cGVdO1xuICAgICAgICBpZihvYmoubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICAgIG9iai5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1tvYmoubmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kKSB7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudHlwZSk7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudmFsdWUpO1xuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIEFTTi4xIENSSUF0dHJpYnV0ZXMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kXG4gKiB2YWx1ZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIHRoZSBDUklBdHRyaWJ1dGVzIHRvIGNvbnZlcnQuXG4gKi9cbnBraS5DUklBdHRyaWJ1dGVzQXNBcnJheSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBlYWNoIHZhbHVlIGluICdhdHRyaWJ1dGVzJyBpbiBpcyBhIFNFUVVFTkNFIHdpdGggYW4gT0lEIGFuZCBhIFNFVFxuICBmb3IodmFyIHNpID0gMDsgc2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytzaSkge1xuICAgIC8vIGdldCB0aGUgYXR0cmlidXRlIHNlcXVlbmNlXG4gICAgdmFyIHNlcSA9IGF0dHJpYnV0ZXNbc2ldO1xuXG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgU0VRVUVOQ0UgY29udGFpbmluZyBmaXJzdCBhIHR5cGUgKGFuIE9JRCkgYW5kXG4gICAgLy8gc2Vjb25kIGEgc2V0IG9mIHZhbHVlcyAoZGVmaW5lZCBieSB0aGUgT0lEKVxuICAgIHZhciB0eXBlID0gYXNuMS5kZXJUb09pZChzZXEudmFsdWVbMF0udmFsdWUpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXEudmFsdWVbMV0udmFsdWU7XG4gICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgdmFsdWVzLmxlbmd0aDsgKyt2aSkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgb2JqLnR5cGUgPSB0eXBlO1xuICAgICAgb2JqLnZhbHVlID0gdmFsdWVzW3ZpXS52YWx1ZTtcbiAgICAgIG9iai52YWx1ZVRhZ0NsYXNzID0gdmFsdWVzW3ZpXS50eXBlO1xuICAgICAgLy8gaWYgdGhlIE9JRCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lIGFuZCBzaG9ydCBuYW1lXG4gICAgICBpZihvYmoudHlwZSBpbiBvaWRzKSB7XG4gICAgICAgIG9iai5uYW1lID0gb2lkc1tvYmoudHlwZV07XG4gICAgICAgIGlmKG9iai5uYW1lIGluIF9zaG9ydE5hbWVzKSB7XG4gICAgICAgICAgb2JqLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW29iai5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcGFyc2UgZXh0ZW5zaW9uc1xuICAgICAgaWYob2JqLnR5cGUgPT09IG9pZHMuZXh0ZW5zaW9uUmVxdWVzdCkge1xuICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgb2JqLmV4dGVuc2lvbnMucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMShvYmoudmFsdWVbZWldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaChvYmopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGlzc3VlciBvciBzdWJqZWN0IGF0dHJpYnV0ZSBmcm9tIGl0cyBuYW1lLCB0eXBlLCBvciBzaG9ydCBuYW1lLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGlzc3VlciBvciBzdWJqZWN0IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIGEgc2hvcnQgbmFtZSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICBzaG9ydE5hbWUgdGhlIHNob3J0IG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIGZvciB0aGUgYXR0cmlidXRlLlxuICogICAgICAgICAgdHlwZSB0aGUgdHlwZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGUob2JqLCBvcHRpb25zKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7c2hvcnROYW1lOiBvcHRpb25zfTtcbiAgfVxuXG4gIHZhciBydmFsID0gbnVsbDtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IG9iai5hdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IG9iai5hdHRyaWJ1dGVzW2ldO1xuICAgIGlmKG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgPT09IGF0dHIudHlwZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMubmFtZSAmJiBvcHRpb25zLm5hbWUgPT09IGF0dHIubmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMuc2hvcnROYW1lICYmIG9wdGlvbnMuc2hvcnROYW1lID09PSBhdHRyLnNob3J0TmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGZyb20gQVNOLjEgc3RydWN0dXJlLlxuICpcbiAqIEN1cnJlbnRseSBvbmx5IFJTQVNTQS1QU1Mgc3VwcG9ydGVkLiAgVGhlIFBLQ1MjMSB2MS41IHNpZ25hdHVyZSBzY2hlbWUgaGFkXG4gKiBubyBwYXJhbWV0ZXJzLlxuICpcbiAqIFJTQVNTQS1QU1MtcGFyYW1zICA6Oj0gIFNFUVVFTkNFICB7XG4gKiAgIGhhc2hBbGdvcml0aG0gICAgICBbMF0gSGFzaEFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhMUlkZW50aWZpZXIsXG4gKiAgIG1hc2tHZW5BbGdvcml0aG0gICBbMV0gTWFza0dlbkFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWdmMVNIQTFJZGVudGlmaWVyLFxuICogICBzYWx0TGVuZ3RoICAgICAgICAgWzJdIElOVEVHRVIgREVGQVVMVCAyMCxcbiAqICAgdHJhaWxlckZpZWxkICAgICAgIFszXSBJTlRFR0VSIERFRkFVTFQgMVxuICogfVxuICpcbiAqIEhhc2hBbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIE1hc2tHZW5BbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQHBhcmFtIG9pZCBUaGUgT0lEIHNwZWNpZnlpbmcgdGhlIHNpZ25hdHVyZSBhbGdvcml0aG1cbiAqIEBwYXJhbSBvYmogVGhlIEFTTi4xIHN0cnVjdHVyZSBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gZmlsbERlZmF1bHRzIFdoZXRoZXIgdG8gdXNlIHJldHVybiBkZWZhdWx0IHZhbHVlcyB3aGVyZSBvbWl0dGVkXG4gKiBAcmV0dXJuIHNpZ25hdHVyZSBwYXJhbWV0ZXIgb2JqZWN0XG4gKi9cbnZhciBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihvaWQsIG9iaiwgZmlsbERlZmF1bHRzKSB7XG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBpZihvaWQgIT09IG9pZHNbJ1JTQVNTQS1QU1MnXSkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBpZihmaWxsRGVmYXVsdHMpIHtcbiAgICBwYXJhbXMgPSB7XG4gICAgICBoYXNoOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snc2hhMSddXG4gICAgICB9LFxuICAgICAgbWdmOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snbWdmMSddLFxuICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydzaGExJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNhbHRMZW5ndGg6IDIwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2Fzc2FQc3NQYXJhbWV0ZXJWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFJTQVNTQS1QU1MgcGFyYW1ldGVyIGJsb2NrLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuaGFzaE9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLmhhc2ggPSBwYXJhbXMuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuaGFzaE9pZCk7XG4gIH1cblxuICBpZihjYXB0dXJlLm1hc2tHZW5PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcy5tZ2YgPSBwYXJhbXMubWdmIHx8IHt9O1xuICAgIHBhcmFtcy5tZ2YuYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5PaWQpO1xuICAgIHBhcmFtcy5tZ2YuaGFzaCA9IHBhcmFtcy5tZ2YuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMubWdmLmhhc2guYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5IYXNoT2lkKTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnNhbHRMZW5ndGggPSBjYXB0dXJlLnNhbHRMZW5ndGguY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5IGNlcnRpZmljYXRlIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhpcyB3aWxsIHNjYW4gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWQgYmFja1xuICogdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY2VydGlmaWNhdGVGcm9tUGVtID0gZnVuY3Rpb24ocGVtLCBjb21wdXRlSGFzaCwgc3RyaWN0KSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdDRVJUSUZJQ0FURScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1g1MDkgQ0VSVElGSUNBVEUnICYmXG4gICAgbXNnLnR5cGUgIT09ICdUUlVTVEVEIENFUlRJRklDQVRFJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGUgZnJvbSBQRU07IFBFTSBoZWFkZXIgdHlwZSAnICtcbiAgICAgICdpcyBub3QgXCJDRVJUSUZJQ0FURVwiLCBcIlg1MDkgQ0VSVElGSUNBVEVcIiwgb3IgXCJUUlVTVEVEIENFUlRJRklDQVRFXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBjZXJ0aWZpY2F0ZSB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZVRvUGVtID0gZnVuY3Rpb24oY2VydCwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0NFUlRJRklDQVRFJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnB1YmxpY0tleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ1BVQkxJQyBLRVknICYmIG1zZy50eXBlICE9PSAnUlNBIFBVQkxJQyBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwdWJsaWMga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyICcgK1xuICAgICAgJ3R5cGUgaXMgbm90IFwiUFVCTElDIEtFWVwiIG9yIFwiUlNBIFBVQkxJQyBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcblxuICByZXR1cm4gcGtpLnB1YmxpY0tleUZyb21Bc24xKG9iaik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IHRvIFBFTSBmb3JtYXQgKHVzaW5nIGEgU3ViamVjdFB1YmxpY0tleUluZm8pLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1BlbSA9IGZ1bmN0aW9uKGtleSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BVQkxJQyBLRVknLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHB1YmxpYyBrZXkgdG8gUEVNIGZvcm1hdCAodXNpbmcgYW4gUlNBUHVibGljS2V5KS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXlQZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFVCTElDIEtFWScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBmaW5nZXJwcmludCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW21kXSB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSAoZGVmYXVsdHMgdG8gZm9yZ2UubWQuc2hhMSkuXG4gKiAgICAgICAgICBbdHlwZV0gdGhlIHR5cGUgb2YgZmluZ2VycHJpbnQsIHN1Y2ggYXMgJ1JTQVB1YmxpY0tleScsXG4gKiAgICAgICAgICAgICdTdWJqZWN0UHVibGljS2V5SW5mbycgKGRlZmF1bHRzIHRvICdSU0FQdWJsaWNLZXknKS5cbiAqICAgICAgICAgIFtlbmNvZGluZ10gYW4gYWx0ZXJuYXRpdmUgb3V0cHV0IGVuY29kaW5nLCBzdWNoIGFzICdoZXgnXG4gKiAgICAgICAgICAgIChkZWZhdWx0cyB0byBub25lLCBvdXRwdXRzIGEgYnl0ZSBidWZmZXIpLlxuICogICAgICAgICAgW2RlbGltaXRlcl0gdGhlIGRlbGltaXRlciB0byB1c2UgYmV0d2VlbiBieXRlcyBmb3IgJ2hleCcgZW5jb2RlZFxuICogICAgICAgICAgICBvdXRwdXQsIGVnOiAnOicgKGRlZmF1bHRzIHRvIG5vbmUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbmdlcnByaW50IGFzIGEgYnl0ZSBidWZmZXIgb3Igb3RoZXIgZW5jb2RpbmcgYmFzZWQgb24gb3B0aW9ucy5cbiAqL1xucGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50ID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbWQgPSBvcHRpb25zLm1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8ICdSU0FQdWJsaWNLZXknO1xuXG4gIHZhciBieXRlcztcbiAgc3dpdGNoKHR5cGUpIHtcbiAgY2FzZSAnUlNBUHVibGljS2V5JzpcbiAgICBieXRlcyA9IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSkpLmdldEJ5dGVzKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1N1YmplY3RQdWJsaWNLZXlJbmZvJzpcbiAgICBieXRlcyA9IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaW5nZXJwcmludCB0eXBlIFwiJyArIG9wdGlvbnMudHlwZSArICdcIi4nKTtcbiAgfVxuXG4gIC8vIGhhc2ggcHVibGljIGtleSBieXRlc1xuICBtZC5zdGFydCgpO1xuICBtZC51cGRhdGUoYnl0ZXMpO1xuICB2YXIgZGlnZXN0ID0gbWQuZGlnZXN0KCk7XG4gIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgdmFyIGhleCA9IGRpZ2VzdC50b0hleCgpO1xuICAgIGlmKG9wdGlvbnMuZGVsaW1pdGVyKSB7XG4gICAgICByZXR1cm4gaGV4Lm1hdGNoKC8uezJ9L2cpLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9IGVsc2UgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICByZXR1cm4gZGlnZXN0LmdldEJ5dGVzKCk7XG4gIH0gZWxzZSBpZihvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIFwiJyArIG9wdGlvbnMuZW5jb2RpbmcgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIGRpZ2VzdDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGlzIHdpbGwgc2NhbiB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2ZcbiAqIHRoZSBBU04uMSBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWRcbiAqIGJhY2sgdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKS5cbiAqL1xucGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbVBlbSA9IGZ1bmN0aW9uKHBlbSwgY29tcHV0ZUhhc2gsIHN0cmljdCkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnQ0VSVElGSUNBVEUgUkVRVUVTVCcpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRpb24gcmVxdWVzdCBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIG5vdCBcIkNFUlRJRklDQVRFIFJFUVVFU1RcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGZyb20gUEVNOyAnICtcbiAgICAgICdQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvUGVtID0gZnVuY3Rpb24oY3NyLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnQ0VSVElGSUNBVEUgUkVRVUVTVCcsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGlvblJlcXVlc3RUb0FzbjEoY3NyKSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgWC41MDl2MyBSU0EgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jcmVhdGVDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2VydCA9IHt9O1xuICBjZXJ0LnZlcnNpb24gPSAweDAyO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9ICcwMCc7XG4gIGNlcnQuc2lnbmF0dXJlT2lkID0gbnVsbDtcbiAgY2VydC5zaWduYXR1cmUgPSBudWxsO1xuICBjZXJ0LnNpZ2luZm8gPSB7fTtcbiAgY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IG51bGw7XG4gIGNlcnQudmFsaWRpdHkgPSB7fTtcbiAgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgPSBuZXcgRGF0ZSgpO1xuICBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyID0gbmV3IERhdGUoKTtcblxuICBjZXJ0Lmlzc3VlciA9IHt9O1xuICBjZXJ0Lmlzc3Vlci5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5pc3N1ZXIsIHNuKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gW107XG4gIGNlcnQuaXNzdWVyLmhhc2ggPSBudWxsO1xuXG4gIGNlcnQuc3ViamVjdCA9IHt9O1xuICBjZXJ0LnN1YmplY3QuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuc3ViamVjdCwgc24pO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBbXTtcbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuXG4gIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICBjZXJ0LnB1YmxpY0tleSA9IG51bGw7XG4gIGNlcnQubWQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2Ygc3ViamVjdCBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICogQHBhcmFtIHVuaXF1ZUlkIGFuIG9wdGlvbmFsIGEgdW5pcXVlIElEIHRvIHVzZS5cbiAgICovXG4gIGNlcnQuc2V0U3ViamVjdCA9IGZ1bmN0aW9uKGF0dHJzLCB1bmlxdWVJZCkge1xuICAgIC8vIHNldCBuZXcgYXR0cmlidXRlcywgY2xlYXIgaGFzaFxuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycyk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBkZWxldGUgY2VydC5zdWJqZWN0LnVuaXF1ZUlkO1xuICAgIGlmKHVuaXF1ZUlkKSB7XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgY2VydC5zdWJqZWN0LnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgfVxuICAgIGNlcnQuc3ViamVjdC5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgaXNzdWVyIG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2YgaXNzdWVyIGF0dHJpYnV0ZXMgdG8gdXNlLlxuICAgKiBAcGFyYW0gdW5pcXVlSWQgYW4gb3B0aW9uYWwgYSB1bmlxdWUgSUQgdG8gdXNlLlxuICAgKi9cbiAgY2VydC5zZXRJc3N1ZXIgPSBmdW5jdGlvbihhdHRycywgdW5pcXVlSWQpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXMsIGNsZWFyIGhhc2hcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBkZWxldGUgY2VydC5pc3N1ZXIudW5pcXVlSWQ7XG4gICAgaWYodW5pcXVlSWQpIHtcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICBjZXJ0Lmlzc3Vlci51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIH1cbiAgICBjZXJ0Lmlzc3Vlci5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgZXh0ZW5zaW9ucyBvZiB0aGlzIGNlcnRpZmljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gZXh0cyB0aGUgYXJyYXkgb2YgZXh0ZW5zaW9ucyB0byB1c2UuXG4gICAqL1xuICBjZXJ0LnNldEV4dGVuc2lvbnMgPSBmdW5jdGlvbihleHRzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhleHRzW2ldLCB7Y2VydDogY2VydH0pO1xuICAgIH1cbiAgICAvLyBzZXQgbmV3IGV4dGVuc2lvbnNcbiAgICBjZXJ0LmV4dGVuc2lvbnMgPSBleHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGV4dGVuc2lvbiBieSBpdHMgbmFtZSBvciBpZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG5hbWUgdG8gdXNlIG9yIGFuIG9iamVjdCB3aXRoOlxuICAgKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIHRvIHVzZS5cbiAgICogICAgICAgICAgaWQgdGhlIGlkIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgY2VydC5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0ge25hbWU6IG9wdGlvbnN9O1xuICAgIH1cblxuICAgIHZhciBydmFsID0gbnVsbDtcbiAgICB2YXIgZXh0O1xuICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IGNlcnQuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgZXh0ID0gY2VydC5leHRlbnNpb25zW2ldO1xuICAgICAgaWYob3B0aW9ucy5pZCAmJiBleHQuaWQgPT09IG9wdGlvbnMuaWQpIHtcbiAgICAgICAgcnZhbCA9IGV4dDtcbiAgICAgIH0gZWxzZSBpZihvcHRpb25zLm5hbWUgJiYgZXh0Lm5hbWUgPT09IG9wdGlvbnMubmFtZSkge1xuICAgICAgICBydmFsID0gZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhpcyBjZXJ0aWZpY2F0ZSB1c2luZyB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aC5cbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIChkZWZhdWx0cyB0byBmb3JnZS5tZC5zaGExKS5cbiAgICovXG4gIGNlcnQuc2lnbiA9IGZ1bmN0aW9uKGtleSwgbWQpIHtcbiAgICAvLyBUT0RPOiBnZXQgc2lnbmF0dXJlIE9JRCBmcm9tIHByaXZhdGUga2V5XG4gICAgY2VydC5tZCA9IG1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIGFsZ29yaXRobU9pZCA9IG9pZHNbY2VydC5tZC5hbGdvcml0aG0gKyAnV2l0aFJTQUVuY3J5cHRpb24nXTtcbiAgICBpZighYWxnb3JpdGhtT2lkKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSBPSUQuJyk7XG4gICAgICBlcnJvci5hbGdvcml0aG0gPSBjZXJ0Lm1kLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBhbGdvcml0aG1PaWQ7XG5cbiAgICAvLyBnZXQgVEJTQ2VydGlmaWNhdGUsIGNvbnZlcnQgdG8gREVSXG4gICAgY2VydC50YnNDZXJ0aWZpY2F0ZSA9IHBraS5nZXRUQlNDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNlcnQudGJzQ2VydGlmaWNhdGUpO1xuXG4gICAgLy8gZGlnZXN0IGFuZCBzaWduXG4gICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgY2VydC5zaWduYXR1cmUgPSBrZXkuc2lnbihjZXJ0Lm1kKTtcbiAgfTtcblxuICAvKipcbiAgICogQXR0ZW1wdHMgdmVyaWZ5IHRoZSBzaWduYXR1cmUgb24gdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSB1c2luZyB0aGlzXG4gICAqIGNlcnRpZmljYXRlJ3MgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGNoaWxkIHRoZSBjZXJ0aWZpY2F0ZSB0byB2ZXJpZnkuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnkgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIHZhciBydmFsID0gZmFsc2U7XG5cbiAgICBpZighY2VydC5pc3N1ZWQoY2hpbGQpKSB7XG4gICAgICB2YXIgaXNzdWVyID0gY2hpbGQuaXNzdWVyO1xuICAgICAgdmFyIHN1YmplY3QgPSBjZXJ0LnN1YmplY3Q7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1RoZSBwYXJlbnQgY2VydGlmaWNhdGUgZGlkIG5vdCBpc3N1ZSB0aGUgZ2l2ZW4gY2hpbGQgJyArXG4gICAgICAgICdjZXJ0aWZpY2F0ZTsgdGhlIGNoaWxkIGNlcnRpZmljYXRlXFwncyBpc3N1ZXIgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xuICAgICAgICAncGFyZW50XFwncyBzdWJqZWN0LicpO1xuICAgICAgZXJyb3IuZXhwZWN0ZWRJc3N1ZXIgPSBpc3N1ZXIuYXR0cmlidXRlcztcbiAgICAgIGVycm9yLmFjdHVhbElzc3VlciA9IHN1YmplY3QuYXR0cmlidXRlcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBtZCA9IGNoaWxkLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBpZihjaGlsZC5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgICB2YXIgb2lkID0gb2lkc1tjaGlsZC5zaWduYXR1cmVPaWRdO1xuICAgICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICAgIGNhc2UgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhMzg0V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihtZCA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICAgJ1Vua25vd24gc2lnbmF0dXJlIE9JRC4nKTtcbiAgICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY2hpbGQuc2lnbmF0dXJlT2lkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIFRCU0NlcnRpZmljYXRlIGFuZCBkaWdlc3QgaXRcbiAgICAgIHZhciB0YnNDZXJ0aWZpY2F0ZSA9IGNoaWxkLnRic0NlcnRpZmljYXRlIHx8IHBraS5nZXRUQlNDZXJ0aWZpY2F0ZShjaGlsZCk7XG4gICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKHRic0NlcnRpZmljYXRlKTtcbiAgICAgIG1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgICB9XG5cbiAgICBpZihtZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHNjaGVtZTtcblxuICAgICAgc3dpdGNoKGNoaWxkLnNpZ25hdHVyZU9pZCkge1xuICAgICAgY2FzZSBvaWRzLnNoYTFXaXRoUlNBRW5jcnlwdGlvbjpcbiAgICAgICAgc2NoZW1lID0gdW5kZWZpbmVkOyAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgc2NoZW1lICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICAgIHZhciBoYXNoLCBtZ2Y7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBtZ2YgKi9cbiAgICAgICAgaGFzaCA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgICAgZXJyb3Iub2lkID0gY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IGhhc2g7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICBtZ2YgPSBvaWRzW2NoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZF07XG4gICAgICAgIGlmKG1nZiA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1nZlttZ2ZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBlcnJvci5vaWQgPSBjaGlsZC5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgIGhhc2ggPSBvaWRzW2NoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdVbnN1cHBvcnRlZCBSU0FTU0EtUFNTIGhhc2ggZnVuY3Rpb24uJyxcbiAgICAgICAgICAgIG9pZDogY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZCxcbiAgICAgICAgICAgIG5hbWU6IGhhc2hcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2NoZW1lID0gZm9yZ2UucHNzLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSwgbWdmLFxuICAgICAgICAgIGNoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuc2FsdExlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyB2ZXJpZnkgc2lnbmF0dXJlIG9uIGNlcnQgdXNpbmcgcHVibGljIGtleVxuICAgICAgcnZhbCA9IGNlcnQucHVibGljS2V5LnZlcmlmeShcbiAgICAgICAgbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSwgY2hpbGQuc2lnbmF0dXJlLCBzY2hlbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIGlzc3VlciBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogY2VydGlmaWNhdGUncyBzdWJqZWN0LiBOb3RlIHRoYXQgbm8gc2lnbmF0dXJlIGNoZWNrIGlzIHBlcmZvcm1lZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3MgaXNzdWVyIG1hdGNoZXMgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSdzXG4gICAqICAgICAgICAgc3ViamVjdC5cbiAgICovXG4gIGNlcnQuaXNJc3N1ZXIgPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIGkgPSBjZXJ0Lmlzc3VlcjtcbiAgICB2YXIgcyA9IHBhcmVudC5zdWJqZWN0O1xuXG4gICAgLy8gY29tcGFyZSBoYXNoZXMgaWYgcHJlc2VudFxuICAgIGlmKGkuaGFzaCAmJiBzLmhhc2gpIHtcbiAgICAgIHJ2YWwgPSAoaS5oYXNoID09PSBzLmhhc2gpO1xuICAgIH0gZWxzZSBpZihpLmF0dHJpYnV0ZXMubGVuZ3RoID09PSBzLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBhbGwgYXR0cmlidXRlcyBhcmUgdGhlIHNhbWUgc28gaXNzdWVyIG1hdGNoZXMgc3ViamVjdFxuICAgICAgcnZhbCA9IHRydWU7XG4gICAgICB2YXIgaWF0dHIsIHNhdHRyO1xuICAgICAgZm9yKHZhciBuID0gMDsgcnZhbCAmJiBuIDwgaS5hdHRyaWJ1dGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGlhdHRyID0gaS5hdHRyaWJ1dGVzW25dO1xuICAgICAgICBzYXR0ciA9IHMuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgaWYoaWF0dHIudHlwZSAhPT0gc2F0dHIudHlwZSB8fCBpYXR0ci52YWx1ZSAhPT0gc2F0dHIudmFsdWUpIHtcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgbWlzbWF0Y2hcbiAgICAgICAgICBydmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2VydGlmaWNhdGUncyBzdWJqZWN0IG1hdGNoZXMgdGhlIGlzc3VlciBvZiB0aGVcbiAgICogZ2l2ZW4gY2VydGlmaWNhdGUpLiBOb3RlIHRoYXQgbm90IHNpZ25hdHVyZSBjaGVjayBpcyBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGlsZCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3Mgc3ViamVjdCBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogICAgICAgICBjZXJ0aWZpY2F0ZSdzIGlzc3Vlci5cbiAgICovXG4gIGNlcnQuaXNzdWVkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuaXNJc3N1ZXIoY2VydCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgc3ViamVjdEtleUlkZW50aWZpZXIgZm9yIHRoaXMgY2VydGlmaWNhdGUgYXMgYnl0ZSBidWZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGZvciB0aGlzIGNlcnRpZmljYXRlIGFzIGJ5dGUgYnVmZmVyLlxuICAgKi9cbiAgY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgLyogU2VlOiA0LjIuMS4yIHNlY3Rpb24gb2YgdGhlIHRoZSBSRkMzMjgwLCBrZXlJZGVudGlmaWVyIGlzIGVpdGhlcjpcblxuICAgICAgKDEpIFRoZSBrZXlJZGVudGlmaWVyIGlzIGNvbXBvc2VkIG9mIHRoZSAxNjAtYml0IFNIQS0xIGhhc2ggb2YgdGhlXG4gICAgICAgIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXkgKGV4Y2x1ZGluZyB0aGUgdGFnLFxuICAgICAgICBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdHMpLlxuXG4gICAgICAoMikgVGhlIGtleUlkZW50aWZpZXIgaXMgY29tcG9zZWQgb2YgYSBmb3VyIGJpdCB0eXBlIGZpZWxkIHdpdGhcbiAgICAgICAgdGhlIHZhbHVlIDAxMDAgZm9sbG93ZWQgYnkgdGhlIGxlYXN0IHNpZ25pZmljYW50IDYwIGJpdHMgb2YgdGhlXG4gICAgICAgIFNIQS0xIGhhc2ggb2YgdGhlIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgKGV4Y2x1ZGluZyB0aGUgdGFnLCBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdCBzdHJpbmcgYml0cykuXG4gICAgKi9cblxuICAgIC8vIHNraXBwaW5nIHRoZSB0YWcsIGxlbmd0aCwgYW5kIG51bWJlciBvZiB1bnVzZWQgYml0cyBpcyB0aGUgc2FtZVxuICAgIC8vIGFzIGp1c3QgdXNpbmcgdGhlIFJTQVB1YmxpY0tleSAoZm9yIFJTQSBrZXlzLCB3aGljaCBhcmUgdGhlXG4gICAgLy8gb25seSBvbmVzIHN1cHBvcnRlZClcbiAgICByZXR1cm4gcGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50KGNlcnQucHVibGljS2V5LCB7dHlwZTogJ1JTQVB1YmxpY0tleSd9KTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGV4dGVuc2lvbiB2YWx1ZSBmb3IgdGhpcyBjZXJ0aWZpY2F0ZVxuICAgKiBhZ2FpbnN0IGl0cyBwdWJsaWMga2V5LiBJZiBubyBleHRlbnNpb24gaXMgZm91bmQsIGZhbHNlIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnlTdWJqZWN0S2V5SWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvaWQgPSBvaWRzWydzdWJqZWN0S2V5SWRlbnRpZmllciddO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICBpZihleHQuaWQgPT09IG9pZCkge1xuICAgICAgICB2YXIgc2tpID0gY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIChmb3JnZS51dGlsLmhleFRvQnl0ZXMoZXh0LnN1YmplY3RLZXlJZGVudGlmaWVyKSA9PT0gc2tpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZSBmcm9tIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGltcGxlbWVudGF0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBhIGNlcnRpZmljYXRlIGJhY2sgdG8gQVNOLjEgc28gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNlcnQgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gIC8vIHZhbGlkYXRlIGNlcnRpZmljYXRlIGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgWC41MDkgY2VydGlmaWNhdGUuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYW4gWDUwOXYzIENlcnRpZmljYXRlLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRlXG4gIHZhciBjZXJ0ID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRlKCk7XG4gIGNlcnQudmVyc2lvbiA9IGNhcHR1cmUuY2VydFZlcnNpb24gP1xuICAgIGNhcHR1cmUuY2VydFZlcnNpb24uY2hhckNvZGVBdCgwKSA6IDA7XG4gIHZhciBzZXJpYWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmNlcnRTZXJpYWxOdW1iZXIpO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9IHNlcmlhbC50b0hleCgpO1xuICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0U2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNlcnQuc2lnbmF0dXJlT2lkLCBjYXB0dXJlLmNlcnRTaWduYXR1cmVQYXJhbXMsIHRydWUpO1xuICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCxcbiAgICBjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zLCBmYWxzZSk7XG4gIGNlcnQuc2lnbmF0dXJlID0gY2FwdHVyZS5jZXJ0U2lnbmF0dXJlO1xuXG4gIHZhciB2YWxpZGl0eSA9IFtdO1xuICBpZihjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEudXRjVGltZVRvRGF0ZShjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlKFxuICAgICAgY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLnV0Y1RpbWVUb0RhdGUoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShcbiAgICAgIGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSkpO1xuICB9XG4gIGlmKHZhbGlkaXR5Lmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIG5vdEJlZm9yZS9ub3RBZnRlciB2YWxpZGl0eSB0aW1lczsgbW9yZSAnICtcbiAgICAgICd0aGFuIHR3byB0aW1lcyB3ZXJlIHByb3ZpZGVkIGluIHRoZSBjZXJ0aWZpY2F0ZS4nKTtcbiAgfVxuICBpZih2YWxpZGl0eS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBub3RCZWZvcmUvbm90QWZ0ZXIgdmFsaWRpdHkgdGltZXM7IHRoZXkgJyArXG4gICAgICAnd2VyZSBub3QgcHJvdmlkZWQgYXMgZWl0aGVyIFVUQ1RpbWUgb3IgR2VuZXJhbGl6ZWRUaW1lLicpO1xuICB9XG4gIGNlcnQudmFsaWRpdHkubm90QmVmb3JlID0gdmFsaWRpdHlbMF07XG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSB2YWxpZGl0eVsxXTtcblxuICAvLyBrZWVwIFRCU0NlcnRpZmljYXRlIHRvIHByZXNlcnZlIHNpZ25hdHVyZSB3aGVuIGV4cG9ydGluZ1xuICBjZXJ0LnRic0NlcnRpZmljYXRlID0gY2FwdHVyZS50YnNDZXJ0aWZpY2F0ZTtcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICBjZXJ0Lm1kID0gbnVsbDtcbiAgICBpZihjZXJ0LnNpZ25hdHVyZU9pZCBpbiBvaWRzKSB7XG4gICAgICB2YXIgb2lkID0gb2lkc1tjZXJ0LnNpZ25hdHVyZU9pZF07XG4gICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUlNBU1NBLVBTUyc6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihjZXJ0Lm1kID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIHNpZ25hdHVyZSBPSUQuJyk7XG4gICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjZXJ0LnNpZ25hdHVyZU9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBUQlNDZXJ0aWZpY2F0ZSBhbmQgZGlnZXN0IGl0XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjZXJ0LnRic0NlcnRpZmljYXRlKTtcbiAgICBjZXJ0Lm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBpc3N1ZXIsIGJ1aWxkIGlzc3VlciBtZXNzYWdlIGRpZ2VzdFxuICB2YXIgaW1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgY2VydC5pc3N1ZXIuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuaXNzdWVyLCBzbik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRJc3N1ZXIsIGltZCk7XG4gIGlmKGNhcHR1cmUuY2VydElzc3VlclVuaXF1ZUlkKSB7XG4gICAgY2VydC5pc3N1ZXIudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRJc3N1ZXJVbmlxdWVJZDtcbiAgfVxuICBjZXJ0Lmlzc3Vlci5oYXNoID0gaW1kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNlcnQuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5zdWJqZWN0LCBzbik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRTdWJqZWN0LCBzbWQpO1xuICBpZihjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQpIHtcbiAgICBjZXJ0LnN1YmplY3QudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQ7XG4gIH1cbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBzbWQuZGlnZXN0KCkudG9IZXgoKTtcblxuICAvLyBoYW5kbGUgZXh0ZW5zaW9uc1xuICBpZihjYXB0dXJlLmNlcnRFeHRlbnNpb25zKSB7XG4gICAgY2VydC5leHRlbnNpb25zID0gcGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uc0Zyb21Bc24xKGNhcHR1cmUuY2VydEV4dGVuc2lvbnMpO1xuICB9IGVsc2Uge1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICB9XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNlcnQucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU04uMSBleHRlbnNpb25zIG9iamVjdCAod2l0aCBleHRlbnNpb24gc2VxdWVuY2VzIGFzIGl0c1xuICogdmFsdWVzKSBpbnRvIGFuIGFycmF5IG9mIGV4dGVuc2lvbiBvYmplY3RzIHdpdGggdHlwZXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBTdXBwb3J0ZWQgZXh0ZW5zaW9uczpcbiAqXG4gKiBpZC1jZS1rZXlVc2FnZSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTUgfVxuICogS2V5VXNhZ2UgOjo9IEJJVCBTVFJJTkcge1xuICogICBkaWdpdGFsU2lnbmF0dXJlICAgICAgICAoMCksXG4gKiAgIG5vblJlcHVkaWF0aW9uICAgICAgICAgICgxKSxcbiAqICAga2V5RW5jaXBoZXJtZW50ICAgICAgICAgKDIpLFxuICogICBkYXRhRW5jaXBoZXJtZW50ICAgICAgICAoMyksXG4gKiAgIGtleUFncmVlbWVudCAgICAgICAgICAgICg0KSxcbiAqICAga2V5Q2VydFNpZ24gICAgICAgICAgICAgKDUpLFxuICogICBjUkxTaWduICAgICAgICAgICAgICAgICAoNiksXG4gKiAgIGVuY2lwaGVyT25seSAgICAgICAgICAgICg3KSxcbiAqICAgZGVjaXBoZXJPbmx5ICAgICAgICAgICAgKDgpXG4gKiB9XG4gKlxuICogaWQtY2UtYmFzaWNDb25zdHJhaW50cyBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTkgfVxuICogQmFzaWNDb25zdHJhaW50cyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjQSAgICAgICAgICAgICAgICAgICAgICBCT09MRUFOIERFRkFVTFQgRkFMU0UsXG4gKiAgIHBhdGhMZW5Db25zdHJhaW50ICAgICAgIElOVEVHRVIgKDAuLk1BWCkgT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBzdWJqZWN0QWx0TmFtZSBFWFRFTlNJT04gOjo9IHtcbiAqICAgU1lOVEFYIEdlbmVyYWxOYW1lc1xuICogICBJREVOVElGSUVEIEJZIGlkLWNlLXN1YmplY3RBbHROYW1lXG4gKiB9XG4gKlxuICogR2VuZXJhbE5hbWVzIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEdlbmVyYWxOYW1lXG4gKlxuICogR2VuZXJhbE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIG90aGVyTmFtZSAgICAgIFswXSBJTlNUQU5DRSBPRiBPVEhFUi1OQU1FLFxuICogICByZmM4MjJOYW1lICAgICBbMV0gSUE1U3RyaW5nLFxuICogICBkTlNOYW1lICAgICAgICBbMl0gSUE1U3RyaW5nLFxuICogICB4NDAwQWRkcmVzcyAgICBbM10gT1JBZGRyZXNzLFxuICogICBkaXJlY3RvcnlOYW1lICBbNF0gTmFtZSxcbiAqICAgZWRpUGFydHlOYW1lICAgWzVdIEVESVBhcnR5TmFtZSxcbiAqICAgdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciBbNl0gSUE1U3RyaW5nLFxuICogICBJUEFkZHJlc3MgICAgICBbN10gT0NURVQgU1RSSU5HLFxuICogICByZWdpc3RlcmVkSUQgICBbOF0gT0JKRUNUIElERU5USUZJRVJcbiAqIH1cbiAqXG4gKiBPVEhFUi1OQU1FIDo6PSBUWVBFLUlERU5USUZJRVJcbiAqXG4gKiBFRElQYXJ0eU5hbWUgOjo9IFNFUVVFTkNFIHtcbiAqICAgbmFtZUFzc2lnbmVyIFswXSBEaXJlY3RvcnlTdHJpbmcge3ViLW5hbWV9IE9QVElPTkFMLFxuICogICBwYXJ0eU5hbWUgICAgWzFdIERpcmVjdG9yeVN0cmluZyB7dWItbmFtZX1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyBBU04uMSB3aXRoIGV4dGVuc2lvbiBzZXF1ZW5jZXMgdG8gcGFyc2UuXG4gKlxuICogQHJldHVybiB0aGUgYXJyYXkuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMSA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgZXh0ZW5zaW9uIHNlcXVlbmNlXG4gICAgdmFyIGV4dHNlcSA9IGV4dHMudmFsdWVbaV07XG4gICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgZXh0c2VxLnZhbHVlLmxlbmd0aDsgKytlaSkge1xuICAgICAgcnZhbC5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xKGV4dHNlcS52YWx1ZVtlaV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2luZ2xlIGNlcnRpZmljYXRlIGV4dGVuc2lvbiBmcm9tIEFTTi4xLlxuICpcbiAqIEBwYXJhbSBleHQgdGhlIGV4dGVuc2lvbiBpbiBBU04uMSBmb3JtYXQuXG4gKlxuICogQHJldHVybiB0aGUgcGFyc2VkIGV4dGVuc2lvbiBhcyBhbiBvYmplY3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGFuIGV4dGVuc2lvbiBoYXM6XG4gIC8vIFswXSBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUlxuICAvLyBbMV0gY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFXG4gIC8vIFsyXSBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAgdmFyIGUgPSB7fTtcbiAgZS5pZCA9IGFzbjEuZGVyVG9PaWQoZXh0LnZhbHVlWzBdLnZhbHVlKTtcbiAgZS5jcml0aWNhbCA9IGZhbHNlO1xuICBpZihleHQudmFsdWVbMV0udHlwZSA9PT0gYXNuMS5UeXBlLkJPT0xFQU4pIHtcbiAgICBlLmNyaXRpY2FsID0gKGV4dC52YWx1ZVsxXS52YWx1ZS5jaGFyQ29kZUF0KDApICE9PSAweDAwKTtcbiAgICBlLnZhbHVlID0gZXh0LnZhbHVlWzJdLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGUudmFsdWUgPSBleHQudmFsdWVbMV0udmFsdWU7XG4gIH1cbiAgLy8gaWYgdGhlIG9pZCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lXG4gIGlmKGUuaWQgaW4gb2lkcykge1xuICAgIGUubmFtZSA9IG9pZHNbZS5pZF07XG5cbiAgICAvLyBoYW5kbGUga2V5IHVzYWdlXG4gICAgaWYoZS5uYW1lID09PSAna2V5VXNhZ2UnKSB7XG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIHZhciBiMyA9IDB4MDA7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNraXAgZmlyc3QgYnl0ZSwganVzdCBpbmRpY2F0ZXMgdW51c2VkIGJpdHMgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBiZSBwYWRkZWQgd2l0aCAwcyBhbnl3YXlcbiAgICAgICAgLy8gZ2V0IGJ5dGVzIHdpdGggZmxhZyBiaXRzXG4gICAgICAgIGIyID0gZXYudmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgICAgYjMgPSBldi52YWx1ZS5sZW5ndGggPiAyID8gZXYudmFsdWUuY2hhckNvZGVBdCgyKSA6IDA7XG4gICAgICB9XG4gICAgICAvLyBzZXQgZmxhZ3NcbiAgICAgIGUuZGlnaXRhbFNpZ25hdHVyZSA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5ub25SZXB1ZGlhdGlvbiA9IChiMiAmIDB4NDApID09PSAweDQwO1xuICAgICAgZS5rZXlFbmNpcGhlcm1lbnQgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUuZGF0YUVuY2lwaGVybWVudCA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5rZXlBZ3JlZW1lbnQgPSAoYjIgJiAweDA4KSA9PT0gMHgwODtcbiAgICAgIGUua2V5Q2VydFNpZ24gPSAoYjIgJiAweDA0KSA9PT0gMHgwNDtcbiAgICAgIGUuY1JMU2lnbiA9IChiMiAmIDB4MDIpID09PSAweDAyO1xuICAgICAgZS5lbmNpcGhlck9ubHkgPSAoYjIgJiAweDAxKSA9PT0gMHgwMTtcbiAgICAgIGUuZGVjaXBoZXJPbmx5ID0gKGIzICYgMHg4MCkgPT09IDB4ODA7XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgICAvLyBoYW5kbGUgYmFzaWMgY29uc3RyYWludHNcbiAgICAgIC8vIGdldCB2YWx1ZSBhcyBTRVFVRU5DRVxuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgLy8gZ2V0IGNBIEJPT0xFQU4gZmxhZyAoZGVmYXVsdHMgdG8gZmFsc2UpXG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAwICYmIGV2LnZhbHVlWzBdLnR5cGUgPT09IGFzbjEuVHlwZS5CT09MRUFOKSB7XG4gICAgICAgIGUuY0EgPSAoZXYudmFsdWVbMF0udmFsdWUuY2hhckNvZGVBdCgwKSAhPT0gMHgwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLmNBID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBnZXQgcGF0aCBsZW5ndGggY29uc3RyYWludFxuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDAgJiYgZXYudmFsdWVbMF0udHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIpIHtcbiAgICAgICAgdmFsdWUgPSBldi52YWx1ZVswXS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gZXYudmFsdWVbMV0udmFsdWU7XG4gICAgICB9XG4gICAgICBpZih2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBlLnBhdGhMZW5Db25zdHJhaW50ID0gYXNuMS5kZXJUb0ludGVnZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihlLm5hbWUgPT09ICdleHRLZXlVc2FnZScpIHtcbiAgICAgIC8vIGhhbmRsZSBleHRLZXlVc2FnZVxuICAgICAgLy8gdmFsdWUgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBmb3IodmFyIHZpID0gMDsgdmkgPCBldi52YWx1ZS5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoZXYudmFsdWVbdmldLnZhbHVlKTtcbiAgICAgICAgaWYob2lkIGluIG9pZHMpIHtcbiAgICAgICAgICBlW29pZHNbb2lkXV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVbb2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnbnNDZXJ0VHlwZScpIHtcbiAgICAgIC8vIGhhbmRsZSBuc0NlcnRUeXBlXG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gc2tpcCBmaXJzdCBieXRlLCBqdXN0IGluZGljYXRlcyB1bnVzZWQgYml0cyB3aGljaFxuICAgICAgICAvLyB3aWxsIGJlIHBhZGRlZCB3aXRoIDBzIGFueXdheVxuICAgICAgICAvLyBnZXQgYnl0ZXMgd2l0aCBmbGFnIGJpdHNcbiAgICAgICAgYjIgPSBldi52YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGZsYWdzXG4gICAgICBlLmNsaWVudCA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5zZXJ2ZXIgPSAoYjIgJiAweDQwKSA9PT0gMHg0MDtcbiAgICAgIGUuZW1haWwgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUub2Jqc2lnbiA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5yZXNlcnZlZCA9IChiMiAmIDB4MDgpID09PSAweDA4O1xuICAgICAgZS5zc2xDQSA9IChiMiAmIDB4MDQpID09PSAweDA0O1xuICAgICAgZS5lbWFpbENBID0gKGIyICYgMHgwMikgPT09IDB4MDI7XG4gICAgICBlLm9iakNBID0gKGIyICYgMHgwMSkgPT09IDB4MDE7XG4gICAgfSBlbHNlIGlmKFxuICAgICAgZS5uYW1lID09PSAnc3ViamVjdEFsdE5hbWUnIHx8XG4gICAgICBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgICAgLy8gaGFuZGxlIHN1YmplY3RBbHROYW1lL2lzc3VlckFsdE5hbWVcbiAgICAgIGUuYWx0TmFtZXMgPSBbXTtcblxuICAgICAgLy8gZXYgaXMgYSBTWU5UQVggU0VRVUVOQ0VcbiAgICAgIHZhciBnbjtcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBldi52YWx1ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICAvLyBnZXQgR2VuZXJhbE5hbWVcbiAgICAgICAgZ24gPSBldi52YWx1ZVtuXTtcblxuICAgICAgICB2YXIgYWx0TmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBnbi50eXBlLFxuICAgICAgICAgIHZhbHVlOiBnbi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBlLmFsdE5hbWVzLnB1c2goYWx0TmFtZSk7XG5cbiAgICAgICAgLy8gTm90ZTogU3VwcG9ydCBmb3IgdHlwZXMgMSwyLDYsNyw4XG4gICAgICAgIHN3aXRjaChnbi50eXBlKSB7XG4gICAgICAgIC8vIHJmYzgyMk5hbWVcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAvLyBkTlNOYW1lXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciAoVVJJKVxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElQQWRkcmVzc1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgLy8gY29udmVydCB0byBJUHY0L0lQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgYWx0TmFtZS5pcCA9IGZvcmdlLnV0aWwuYnl0ZXNUb0lQKGduLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gcmVnaXN0ZXJlZElEXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBhbHROYW1lLm9pZCA9IGFzbjEuZGVyVG9PaWQoZ24udmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHVuc3VwcG9ydGVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnc3ViamVjdEtleUlkZW50aWZpZXInKSB7XG4gICAgICAvLyB2YWx1ZSBpcyBhbiBPQ1RFVFNUUklORyB3L3RoZSBoYXNoIG9mIHRoZSBrZXktdHlwZSBzcGVjaWZpY1xuICAgICAgLy8gcHVibGljIGtleSBzdHJ1Y3R1cmUgKGVnOiBSU0FQdWJsaWNLZXkpXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGV2LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gaW1wbGVtZW50YXRpb24gZm9yIGNvbnZlcnRpbmdcbiAqIGEgY2VydGlmaWNhdGUgYmFjayB0byBBU04uMSBzbyB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2YgdGhlXG4gKiBBU04uMSBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNzciBvYmplY3QgaXMgY3JlYXRlZC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaiwgY29tcHV0ZUhhc2gpIHtcbiAgLy8gdmFsaWRhdGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIGNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEwIGNlcnRpZmljYXRlIHJlcXVlc3QuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYSBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdFxuICB2YXIgY3NyID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0KCk7XG4gIGNzci52ZXJzaW9uID0gY2FwdHVyZS5jc3JWZXJzaW9uID8gY2FwdHVyZS5jc3JWZXJzaW9uLmNoYXJDb2RlQXQoMCkgOiAwO1xuICBjc3Iuc2lnbmF0dXJlT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNzci5zaWduYXR1cmVPaWQsIGNhcHR1cmUuY3NyU2lnbmF0dXJlUGFyYW1zLCB0cnVlKTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoXG4gICAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkLCBjYXB0dXJlLmNzclNpZ25hdHVyZVBhcmFtcywgZmFsc2UpO1xuICBjc3Iuc2lnbmF0dXJlID0gY2FwdHVyZS5jc3JTaWduYXR1cmU7XG5cbiAgLy8ga2VlcCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gdG8gcHJlc2VydmUgc2lnbmF0dXJlIHdoZW4gZXhwb3J0aW5nXG4gIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBjYXB0dXJlLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbztcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICBjc3IubWQgPSBudWxsO1xuICAgIGlmKGNzci5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgdmFyIG9pZCA9IG9pZHNbY3NyLnNpZ25hdHVyZU9pZF07XG4gICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTUxMldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihjc3IubWQgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIHNpZ25hdHVyZSBPSUQuJyk7XG4gICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnbmF0dXJlT2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBhbmQgZGlnZXN0IGl0XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcihjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKTtcbiAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICB9XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNzci5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3Iuc3ViamVjdCwgc24pO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBwa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoXG4gICAgY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0LCBzbWQpO1xuICBjc3Iuc3ViamVjdC5oYXNoID0gc21kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNzci5wdWJsaWNLZXkgPSBwa2kucHVibGljS2V5RnJvbUFzbjEoY2FwdHVyZS5zdWJqZWN0UHVibGljS2V5SW5mbyk7XG5cbiAgLy8gY29udmVydCBhdHRyaWJ1dGVzIGZyb20gQVNOLjFcbiAgY3NyLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLCBzbik7XG4gIH07XG4gIGNzci5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY3NyLmF0dHJpYnV0ZXMgPSBwa2kuQ1JJQXR0cmlidXRlc0FzQXJyYXkoXG4gICAgY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9BdHRyaWJ1dGVzIHx8IFtdKTtcblxuICByZXR1cm4gY3NyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IGNlcnRpZmljYXRpb24gcmVxdWVzdCAoYSBDU1Igb3IgY2VydGlmaWNhdGUgc2lnbmluZ1xuICogcmVxdWVzdCkuIE9uY2UgY3JlYXRlZCwgaXRzIHB1YmxpYyBrZXkgYW5kIGF0dHJpYnV0ZXMgY2FuIGJlIHNldCBhbmQgdGhlblxuICogaXQgY2FuIGJlIHNpZ25lZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBlbXB0eSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jcmVhdGVDZXJ0aWZpY2F0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3NyID0ge307XG4gIGNzci52ZXJzaW9uID0gMHgwMDtcbiAgY3NyLnNpZ25hdHVyZU9pZCA9IG51bGw7XG4gIGNzci5zaWduYXR1cmUgPSBudWxsO1xuICBjc3Iuc2lnaW5mbyA9IHt9O1xuICBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBudWxsO1xuXG4gIGNzci5zdWJqZWN0ID0ge307XG4gIGNzci5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3Iuc3ViamVjdCwgc24pO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBbXTtcbiAgY3NyLnN1YmplY3QuaGFzaCA9IG51bGw7XG5cbiAgY3NyLnB1YmxpY0tleSA9IG51bGw7XG4gIGNzci5hdHRyaWJ1dGVzID0gW107XG4gIGNzci5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNzciwgc24pO1xuICB9O1xuICBjc3IuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNzci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5tZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN1YmplY3Qgb2YgdGhpcyBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2Ygc3ViamVjdCBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICovXG4gIGNzci5zZXRTdWJqZWN0ID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXNcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBjc3Iuc3ViamVjdC5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIHRoZSBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICovXG4gIGNzci5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXNcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNzci5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoaXMgY2VydGlmaWNhdGlvbiByZXF1ZXN0IHVzaW5nIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoLlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgKGRlZmF1bHRzIHRvIGZvcmdlLm1kLnNoYTEpLlxuICAgKi9cbiAgY3NyLnNpZ24gPSBmdW5jdGlvbihrZXksIG1kKSB7XG4gICAgLy8gVE9ETzogZ2V0IHNpZ25hdHVyZSBPSUQgZnJvbSBwcml2YXRlIGtleVxuICAgIGNzci5tZCA9IG1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIGFsZ29yaXRobU9pZCA9IG9pZHNbY3NyLm1kLmFsZ29yaXRobSArICdXaXRoUlNBRW5jcnlwdGlvbiddO1xuICAgIGlmKCFhbGdvcml0aG1PaWQpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSBPSUQuJyk7XG4gICAgICBlcnJvci5hbGdvcml0aG0gPSBjc3IubWQuYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNzci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBhbGdvcml0aG1PaWQ7XG5cbiAgICAvLyBnZXQgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLCBjb252ZXJ0IHRvIERFUlxuICAgIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBwa2kuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGNzcik7XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcihjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKTtcblxuICAgIC8vIGRpZ2VzdCBhbmQgc2lnblxuICAgIGNzci5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgY3NyLnNpZ25hdHVyZSA9IGtleS5zaWduKGNzci5tZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHZlcmlmeSB0aGUgc2lnbmF0dXJlIG9uIHRoZSBwYXNzZWQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IHVzaW5nXG4gICAqIGl0cyBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBBIENTUiB0aGF0IGhhcyBiZWVuIGV4cG9ydGVkIHRvIGEgZmlsZSBpbiBQRU0gZm9ybWF0IGNhbiBiZSB2ZXJpZmllZCB1c2luZ1xuICAgKiBPcGVuU1NMIHVzaW5nIHRoaXMgY29tbWFuZDpcbiAgICpcbiAgICogb3BlbnNzbCByZXEgLWluIDx0aGUtY3NyLXBlbS1maWxlPiAtdmVyaWZ5IC1ub291dCAtdGV4dFxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNzci52ZXJpZnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIG1kID0gY3NyLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBpZihjc3Iuc2lnbmF0dXJlT2lkIGluIG9pZHMpIHtcbiAgICAgICAgLy8gVE9ETzogY3JlYXRlIERSWSBgT0lEIHRvIG1kYCBmdW5jdGlvblxuICAgICAgICB2YXIgb2lkID0gb2lkc1tjc3Iuc2lnbmF0dXJlT2lkXTtcbiAgICAgICAgc3dpdGNoKG9pZCkge1xuICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhNTEyV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSU0FTU0EtUFNTJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZGlnZXN0LiAnICtcbiAgICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnbmF0dXJlT2lkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBhbmQgZGlnZXN0IGl0XG4gICAgICB2YXIgY3JpID0gY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyB8fFxuICAgICAgICBwa2kuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGNzcik7XG4gICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNyaSk7XG4gICAgICBtZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgfVxuXG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBzY2hlbWU7XG5cbiAgICAgIHN3aXRjaChjc3Iuc2lnbmF0dXJlT2lkKSB7XG4gICAgICBjYXNlIG9pZHMuc2hhMVdpdGhSU0FFbmNyeXB0aW9uOlxuICAgICAgICAvKiB1c2UgUEtDUyMxIHYxLjUgcGFkZGluZyBzY2hlbWUgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9pZHNbJ1JTQVNTQS1QU1MnXTpcbiAgICAgICAgdmFyIGhhc2gsIG1nZjtcblxuICAgICAgICAvKiBpbml0aWFsaXplIG1nZiAqL1xuICAgICAgICBoYXNoID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgICAgZXJyb3Iub2lkID0gY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkO1xuICAgICAgICAgIGVycm9yLm5hbWUgPSBoYXNoO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgbWdmID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgaWYobWdmID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWdmW21nZl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIGVycm9yLm9pZCA9IGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgIGhhc2ggPSBvaWRzW2Nzci5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgaWYoaGFzaCA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1kW2hhc2hdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBlcnJvci5vaWQgPSBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZDtcbiAgICAgICAgICBlcnJvci5uYW1lID0gaGFzaDtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtZSA9IGZvcmdlLnBzcy5jcmVhdGUoZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCksIG1nZixcbiAgICAgICAgICBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHZlcmlmeSBzaWduYXR1cmUgb24gY3NyIHVzaW5nIGl0cyBwdWJsaWMga2V5XG4gICAgICBydmFsID0gY3NyLnB1YmxpY0tleS52ZXJpZnkoXG4gICAgICAgIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCksIGNzci5zaWduYXR1cmUsIHNjaGVtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIGNzcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDkgc3ViamVjdCBvciBpc3N1ZXIgdG8gYW4gQVNOLjEgUkROU2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgc3ViamVjdCBvciBpc3N1ZXIgKGRpc3Rpbmd1aXNoZWQgbmFtZSkuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgUkROU2VxdWVuY2UuXG4gKi9cbmZ1bmN0aW9uIF9kblRvQXNuMShvYmopIHtcbiAgLy8gY3JlYXRlIGFuIGVtcHR5IFJETlNlcXVlbmNlXG4gIHZhciBydmFsID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGl0ZXJhdGUgb3ZlciBhdHRyaWJ1dGVzXG4gIHZhciBhdHRyLCBzZXQ7XG4gIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgIC8vIHJldXNlIHRhZyBjbGFzcyBmb3IgYXR0cmlidXRlIHZhbHVlIGlmIGF2YWlsYWJsZVxuICAgIHZhciB2YWx1ZVRhZ0NsYXNzID0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORztcbiAgICBpZigndmFsdWVUYWdDbGFzcycgaW4gYXR0cikge1xuICAgICAgdmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVUYWdDbGFzcztcblxuICAgICAgaWYodmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gRklYTUU6IGhhbmRsZSBtb3JlIGVuY29kaW5nc1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgc2V0IGlzIGFuIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZSBmaXJzdFxuICAgIC8vIGNvbnRhaW5pbmcgdGhlIHR5cGUgKGFuIE9JRCkgYW5kIHNlY29uZCB0aGUgdmFsdWVcbiAgICBzZXQgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKGF0dHIudHlwZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIEF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCB2YWx1ZVRhZ0NsYXNzLCBmYWxzZSwgdmFsdWUpXG4gICAgICBdKVxuICAgIF0pO1xuICAgIHJ2YWwudmFsdWUucHVzaChzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogR2V0cyBhbGwgcHJpbnRhYmxlIGF0dHJpYnV0ZXMgKHR5cGljYWxseSBvZiBhbiBpc3N1ZXIgb3Igc3ViamVjdCkgaW4gYVxuICogc2ltcGxpZmllZCBKU09OIGZvcm1hdCBmb3IgZGlzcGxheS5cbiAqXG4gKiBAcGFyYW0gYXR0cnMgdGhlIGF0dHJpYnV0ZXMuXG4gKlxuICogQHJldHVybiB0aGUgSlNPTiBmb3IgZGlzcGxheS5cbiAqL1xuZnVuY3Rpb24gX2dldEF0dHJpYnV0ZXNBc0pzb24oYXR0cnMpIHtcbiAgdmFyIHJ2YWwgPSB7fTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZihhdHRyLnNob3J0TmFtZSAmJiAoXG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5VVEY4IHx8XG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5QUklOVEFCTEVTVFJJTkcgfHxcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLklBNVNUUklORykpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICBpZihhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KGF0dHIudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYoIShhdHRyLnNob3J0TmFtZSBpbiBydmFsKSkge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmKGZvcmdlLnV0aWwuaXNBcnJheShydmFsW2F0dHIuc2hvcnROYW1lXSkpIHtcbiAgICAgICAgcnZhbFthdHRyLnNob3J0TmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXSA9IFtydmFsW2F0dHIuc2hvcnROYW1lXSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBGaWxscyBpbiBtaXNzaW5nIGZpZWxkcyBpbiBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSBhdHRycyB0aGUgYXR0cmlidXRlcyB0byBmaWxsIG1pc3NpbmcgZmllbGRzIGluLlxuICovXG5mdW5jdGlvbiBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpIHtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcblxuICAgIC8vIHBvcHVsYXRlIG1pc3NpbmcgbmFtZVxuICAgIGlmKHR5cGVvZiBhdHRyLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZihhdHRyLnR5cGUgJiYgYXR0ci50eXBlIGluIHBraS5vaWRzKSB7XG4gICAgICAgIGF0dHIubmFtZSA9IHBraS5vaWRzW2F0dHIudHlwZV07XG4gICAgICB9IGVsc2UgaWYoYXR0ci5zaG9ydE5hbWUgJiYgYXR0ci5zaG9ydE5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gcGtpLm9pZHNbX3Nob3J0TmFtZXNbYXR0ci5zaG9ydE5hbWVdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3B1bGF0ZSBtaXNzaW5nIHR5cGUgKE9JRClcbiAgICBpZih0eXBlb2YgYXR0ci50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYoYXR0ci5uYW1lICYmIGF0dHIubmFtZSBpbiBwa2kub2lkcykge1xuICAgICAgICBhdHRyLnR5cGUgPSBwa2kub2lkc1thdHRyLm5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdBdHRyaWJ1dGUgdHlwZSBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgICBlcnJvci5hdHRyaWJ1dGUgPSBhdHRyO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3B1bGF0ZSBtaXNzaW5nIHNob3J0bmFtZVxuICAgIGlmKHR5cGVvZiBhdHRyLnNob3J0TmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmKGF0dHIubmFtZSAmJiBhdHRyLm5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgYXR0ci5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1thdHRyLm5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZXh0ZW5zaW9ucyB0byB2YWx1ZVxuICAgIGlmKGF0dHIudHlwZSA9PT0gb2lkcy5leHRlbnNpb25SZXF1ZXN0KSB7XG4gICAgICBhdHRyLnZhbHVlQ29uc3RydWN0ZWQgPSB0cnVlO1xuICAgICAgYXR0ci52YWx1ZVRhZ0NsYXNzID0gYXNuMS5UeXBlLlNFUVVFTkNFO1xuICAgICAgaWYoIWF0dHIudmFsdWUgJiYgYXR0ci5leHRlbnNpb25zKSB7XG4gICAgICAgIGF0dHIudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgYXR0ci5leHRlbnNpb25zLmxlbmd0aDsgKytlaSkge1xuICAgICAgICAgIGF0dHIudmFsdWUucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEoXG4gICAgICAgICAgICBfZmlsbE1pc3NpbmdFeHRlbnNpb25GaWVsZHMoYXR0ci5leHRlbnNpb25zW2VpXSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiBhdHRyLnZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdBdHRyaWJ1dGUgdmFsdWUgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgIGVycm9yLmF0dHJpYnV0ZSA9IGF0dHI7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGaWxscyBpbiBtaXNzaW5nIGZpZWxkcyBpbiBjZXJ0aWZpY2F0ZSBleHRlbnNpb25zLlxuICpcbiAqIEBwYXJhbSBlIHRoZSBleHRlbnNpb24uXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIFtjZXJ0XSB0aGUgY2VydGlmaWNhdGUgdGhlIGV4dGVuc2lvbnMgYXJlIGZvci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHRlbnNpb24uXG4gKi9cbmZ1bmN0aW9uIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvcHVsYXRlIG1pc3NpbmcgbmFtZVxuICBpZih0eXBlb2YgZS5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKGUuaWQgJiYgZS5pZCBpbiBwa2kub2lkcykge1xuICAgICAgZS5uYW1lID0gcGtpLm9pZHNbZS5pZF07XG4gICAgfVxuICB9XG5cbiAgLy8gcG9wdWxhdGUgbWlzc2luZyBpZFxuICBpZih0eXBlb2YgZS5pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZihlLm5hbWUgJiYgZS5uYW1lIGluIHBraS5vaWRzKSB7XG4gICAgICBlLmlkID0gcGtpLm9pZHNbZS5uYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFeHRlbnNpb24gSUQgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgIGVycm9yLmV4dGVuc2lvbiA9IGU7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBpZih0eXBlb2YgZS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBtaXNzaW5nIHZhbHVlOlxuXG4gIC8vIHZhbHVlIGlzIGEgQklUIFNUUklOR1xuICBpZihlLm5hbWUgPT09ICdrZXlVc2FnZScpIHtcbiAgICAvLyBidWlsZCBmbGFnc1xuICAgIHZhciB1bnVzZWQgPSAwO1xuICAgIHZhciBiMiA9IDB4MDA7XG4gICAgdmFyIGIzID0gMHgwMDtcbiAgICBpZihlLmRpZ2l0YWxTaWduYXR1cmUpIHtcbiAgICAgIGIyIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cbiAgICBpZihlLm5vblJlcHVkaWF0aW9uKSB7XG4gICAgICBiMiB8PSAweDQwO1xuICAgICAgdW51c2VkID0gNjtcbiAgICB9XG4gICAgaWYoZS5rZXlFbmNpcGhlcm1lbnQpIHtcbiAgICAgIGIyIHw9IDB4MjA7XG4gICAgICB1bnVzZWQgPSA1O1xuICAgIH1cbiAgICBpZihlLmRhdGFFbmNpcGhlcm1lbnQpIHtcbiAgICAgIGIyIHw9IDB4MTA7XG4gICAgICB1bnVzZWQgPSA0O1xuICAgIH1cbiAgICBpZihlLmtleUFncmVlbWVudCkge1xuICAgICAgYjIgfD0gMHgwODtcbiAgICAgIHVudXNlZCA9IDM7XG4gICAgfVxuICAgIGlmKGUua2V5Q2VydFNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MDQ7XG4gICAgICB1bnVzZWQgPSAyO1xuICAgIH1cbiAgICBpZihlLmNSTFNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MDI7XG4gICAgICB1bnVzZWQgPSAxO1xuICAgIH1cbiAgICBpZihlLmVuY2lwaGVyT25seSkge1xuICAgICAgYjIgfD0gMHgwMTtcbiAgICAgIHVudXNlZCA9IDA7XG4gICAgfVxuICAgIGlmKGUuZGVjaXBoZXJPbmx5KSB7XG4gICAgICBiMyB8PSAweDgwO1xuICAgICAgdW51c2VkID0gNztcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYml0IHN0cmluZ1xuICAgIHZhciB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodW51c2VkKTtcbiAgICBpZihiMyAhPT0gMCkge1xuICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiMikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGIzKTtcbiAgICB9IGVsc2UgaWYoYjIgIT09IDApIHtcbiAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjIpO1xuICAgIH1cbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgLy8gYmFzaWNDb25zdHJhaW50cyBpcyBhIFNFUVVFTkNFXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgIC8vIGNBIEJPT0xFQU4gZmxhZyBkZWZhdWx0cyB0byBmYWxzZVxuICAgIGlmKGUuY0EpIHtcbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CT09MRUFOLCBmYWxzZSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGKSkpO1xuICAgIH1cbiAgICBpZigncGF0aExlbkNvbnN0cmFpbnQnIGluIGUpIHtcbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoZS5wYXRoTGVuQ29uc3RyYWludCkuZ2V0Qnl0ZXMoKSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2V4dEtleVVzYWdlJykge1xuICAgIC8vIGV4dEtleVVzYWdlIGlzIGEgU0VRVUVOQ0Ugb2YgT0lEc1xuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcbiAgICBmb3IodmFyIGtleSBpbiBlKSB7XG4gICAgICBpZihlW2tleV0gIT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBrZXkgaXMgbmFtZSBpbiBPSUQgbWFwXG4gICAgICBpZihrZXkgaW4gb2lkcykge1xuICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSwgYXNuMS5vaWRUb0RlcihvaWRzW2tleV0pLmdldEJ5dGVzKCkpKTtcbiAgICAgIH0gZWxzZSBpZihrZXkuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAvLyBhc3N1bWUga2V5IGlzIGFuIE9JRFxuICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSwgYXNuMS5vaWRUb0RlcihrZXkpLmdldEJ5dGVzKCkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICduc0NlcnRUeXBlJykge1xuICAgIC8vIG5zQ2VydFR5cGUgaXMgYSBCSVQgU1RSSU5HXG4gICAgLy8gYnVpbGQgZmxhZ3NcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICB2YXIgYjIgPSAweDAwO1xuXG4gICAgaWYoZS5jbGllbnQpIHtcbiAgICAgIGIyIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cbiAgICBpZihlLnNlcnZlcikge1xuICAgICAgYjIgfD0gMHg0MDtcbiAgICAgIHVudXNlZCA9IDY7XG4gICAgfVxuICAgIGlmKGUuZW1haWwpIHtcbiAgICAgIGIyIHw9IDB4MjA7XG4gICAgICB1bnVzZWQgPSA1O1xuICAgIH1cbiAgICBpZihlLm9ianNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MTA7XG4gICAgICB1bnVzZWQgPSA0O1xuICAgIH1cbiAgICBpZihlLnJlc2VydmVkKSB7XG4gICAgICBiMiB8PSAweDA4O1xuICAgICAgdW51c2VkID0gMztcbiAgICB9XG4gICAgaWYoZS5zc2xDQSkge1xuICAgICAgYjIgfD0gMHgwNDtcbiAgICAgIHVudXNlZCA9IDI7XG4gICAgfVxuICAgIGlmKGUuZW1haWxDQSkge1xuICAgICAgYjIgfD0gMHgwMjtcbiAgICAgIHVudXNlZCA9IDE7XG4gICAgfVxuICAgIGlmKGUub2JqQ0EpIHtcbiAgICAgIGIyIHw9IDB4MDE7XG4gICAgICB1bnVzZWQgPSAwO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBiaXQgc3RyaW5nXG4gICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bnVzZWQpO1xuICAgIGlmKGIyICE9PSAwKSB7XG4gICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIyKTtcbiAgICB9XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICdzdWJqZWN0QWx0TmFtZScgfHwgZS5uYW1lID09PSAnaXNzdWVyQWx0TmFtZScpIHtcbiAgICAvLyBTWU5UQVggU0VRVUVOQ0VcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gICAgdmFyIGFsdE5hbWU7XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IGUuYWx0TmFtZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGFsdE5hbWUgPSBlLmFsdE5hbWVzW25dO1xuICAgICAgdmFyIHZhbHVlID0gYWx0TmFtZS52YWx1ZTtcbiAgICAgIC8vIGhhbmRsZSBJUFxuICAgICAgaWYoYWx0TmFtZS50eXBlID09PSA3ICYmIGFsdE5hbWUuaXApIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmJ5dGVzRnJvbUlQKGFsdE5hbWUuaXApO1xuICAgICAgICBpZih2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdFeHRlbnNpb24gXCJpcFwiIHZhbHVlIGlzIG5vdCBhIHZhbGlkIElQdjQgb3IgSVB2NiBhZGRyZXNzLicpO1xuICAgICAgICAgIGVycm9yLmV4dGVuc2lvbiA9IGU7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihhbHROYW1lLnR5cGUgPT09IDgpIHtcbiAgICAgICAgLy8gaGFuZGxlIE9JRFxuICAgICAgICBpZihhbHROYW1lLm9pZCkge1xuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcihhc24xLm9pZFRvRGVyKGFsdE5hbWUub2lkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVwcmVjYXRlZCAuLi4gY29udmVydCB2YWx1ZSB0byBPSURcbiAgICAgICAgICB2YWx1ZSA9IGFzbjEub2lkVG9EZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlLnZhbHVlLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgYWx0TmFtZS50eXBlLCBmYWxzZSxcbiAgICAgICAgdmFsdWUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICdzdWJqZWN0S2V5SWRlbnRpZmllcicgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgdmFyIHNraSA9IG9wdGlvbnMuY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCk7XG4gICAgZS5zdWJqZWN0S2V5SWRlbnRpZmllciA9IHNraS50b0hleCgpO1xuICAgIC8vIE9DVEVUU1RSSU5HIHcvZGlnZXN0XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNraS5nZXRCeXRlcygpKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2F1dGhvcml0eUtleUlkZW50aWZpZXInICYmIG9wdGlvbnMuY2VydCkge1xuICAgIC8vIFNZTlRBWCBTRVFVRU5DRVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgdmFyIHNlcSA9IGUudmFsdWUudmFsdWU7XG5cbiAgICBpZihlLmtleUlkZW50aWZpZXIpIHtcbiAgICAgIHZhciBrZXlJZGVudGlmaWVyID0gKGUua2V5SWRlbnRpZmllciA9PT0gdHJ1ZSA/XG4gICAgICAgIG9wdGlvbnMuY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKSA6XG4gICAgICAgIGUua2V5SWRlbnRpZmllcik7XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCBmYWxzZSwga2V5SWRlbnRpZmllcikpO1xuICAgIH1cblxuICAgIGlmKGUuYXV0aG9yaXR5Q2VydElzc3Vlcikge1xuICAgICAgdmFyIGF1dGhvcml0eUNlcnRJc3N1ZXIgPSBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgNCwgdHJ1ZSwgW1xuICAgICAgICAgIF9kblRvQXNuMShlLmF1dGhvcml0eUNlcnRJc3N1ZXIgPT09IHRydWUgP1xuICAgICAgICAgICAgb3B0aW9ucy5jZXJ0Lmlzc3VlciA6IGUuYXV0aG9yaXR5Q2VydElzc3VlcilcbiAgICAgICAgXSlcbiAgICAgIF07XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBhdXRob3JpdHlDZXJ0SXNzdWVyKSk7XG4gICAgfVxuXG4gICAgaWYoZS5zZXJpYWxOdW1iZXIpIHtcbiAgICAgIHZhciBzZXJpYWxOdW1iZXIgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoZS5zZXJpYWxOdW1iZXIgPT09IHRydWUgP1xuICAgICAgICBvcHRpb25zLmNlcnQuc2VyaWFsTnVtYmVyIDogZS5zZXJpYWxOdW1iZXIpO1xuICAgICAgc2VxLnB1c2goXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgZmFsc2UsIHNlcmlhbE51bWJlcikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKSB7XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcblxuICAgIC8vIENyZWF0ZSBzdWIgU0VRVUVOQ0Ugb2YgRGlzdHJpYnV0aW9uUG9pbnROYW1lXG4gICAgdmFyIHN1YlNlcSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcblxuICAgIC8vIENyZWF0ZSBmdWxsTmFtZSBDSE9JQ0VcbiAgICB2YXIgZnVsbE5hbWVHZW5lcmFsTmFtZXMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcbiAgICB2YXIgYWx0TmFtZTtcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgZS5hbHROYW1lcy5sZW5ndGg7ICsrbikge1xuICAgICAgYWx0TmFtZSA9IGUuYWx0TmFtZXNbbl07XG4gICAgICB2YXIgdmFsdWUgPSBhbHROYW1lLnZhbHVlO1xuICAgICAgLy8gaGFuZGxlIElQXG4gICAgICBpZihhbHROYW1lLnR5cGUgPT09IDcgJiYgYWx0TmFtZS5pcCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuYnl0ZXNGcm9tSVAoYWx0TmFtZS5pcCk7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4dGVuc2lvbiBcImlwXCIgdmFsdWUgaXMgbm90IGEgdmFsaWQgSVB2NCBvciBJUHY2IGFkZHJlc3MuJyk7XG4gICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGFsdE5hbWUudHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBoYW5kbGUgT0lEXG4gICAgICAgIGlmKGFsdE5hbWUub2lkKSB7XG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKGFzbjEub2lkVG9EZXIoYWx0TmFtZS5vaWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZXByZWNhdGVkIC4uLiBjb252ZXJ0IHZhbHVlIHRvIE9JRFxuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bGxOYW1lR2VuZXJhbE5hbWVzLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgYWx0TmFtZS50eXBlLCBmYWxzZSxcbiAgICAgICAgdmFsdWUpKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gdGhlIHBhcmVudCBTRVFVRU5DRVxuICAgIHN1YlNlcS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW2Z1bGxOYW1lR2VuZXJhbE5hbWVzXSkpO1xuICAgIHNlcS5wdXNoKHN1YlNlcSk7XG4gIH1cblxuICAvLyBlbnN1cmUgdmFsdWUgaGFzIGJlZW4gZGVmaW5lZCBieSBub3dcbiAgaWYodHlwZW9mIGUudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFeHRlbnNpb24gdmFsdWUgbm90IHNwZWNpZmllZC4nKTtcbiAgICBlcnJvci5leHRlbnNpb24gPSBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBvYmplY3QgdG8gQVNOLjFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2lkIFNpZ25hdHVyZSBhbGdvcml0aG0gT0lEXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBzaWduYXR1cmUgcGFyYW1ldHJzIG9iamVjdFxuICogQHJldHVybiBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIF9zaWduYXR1cmVQYXJhbWV0ZXJzVG9Bc24xKG9pZCwgcGFyYW1zKSB7XG4gIHN3aXRjaChvaWQpIHtcbiAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICBpZihwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFydHMucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgXSlcbiAgICAgIF0pKTtcbiAgICB9XG5cbiAgICBpZihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIF0pKTtcbiAgICB9XG5cbiAgICBpZihwYXJhbXMuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKHBhcmFtcy5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpKVxuICAgICAgXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBwYXJ0cyk7XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QncyBhdHRyaWJ1dGVzIHRvIGFuIEFTTi4xIHNldCBvZlxuICogQ1JJQXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0gY3NyIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBzZXQgb2YgQ1JJQXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gX0NSSUF0dHJpYnV0ZXNUb0FzbjEoY3NyKSB7XG4gIC8vIGNyZWF0ZSBhbiBlbXB0eSBjb250ZXh0LXNwZWNpZmljIGNvbnRhaW5lclxuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW10pO1xuXG4gIC8vIG5vIGF0dHJpYnV0ZXMsIHJldHVybiBlbXB0eSBjb250YWluZXJcbiAgaWYoY3NyLmF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cblxuICAvLyBlYWNoIGF0dHJpYnV0ZSBoYXMgYSBzZXF1ZW5jZSB3aXRoIGEgdHlwZSBhbmQgYSBzZXQgb2YgdmFsdWVzXG4gIHZhciBhdHRycyA9IGNzci5hdHRyaWJ1dGVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG5cbiAgICAvLyByZXVzZSB0YWcgY2xhc3MgZm9yIGF0dHJpYnV0ZSB2YWx1ZSBpZiBhdmFpbGFibGVcbiAgICB2YXIgdmFsdWVUYWdDbGFzcyA9IGFzbjEuVHlwZS5VVEY4O1xuICAgIGlmKCd2YWx1ZVRhZ0NsYXNzJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuICAgIH1cbiAgICBpZih2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgodmFsdWUpO1xuICAgIH1cbiAgICB2YXIgdmFsdWVDb25zdHJ1Y3RlZCA9IGZhbHNlO1xuICAgIGlmKCd2YWx1ZUNvbnN0cnVjdGVkJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZUNvbnN0cnVjdGVkID0gYXR0ci52YWx1ZUNvbnN0cnVjdGVkO1xuICAgIH1cbiAgICAvLyBGSVhNRTogaGFuZGxlIG1vcmUgZW5jb2RpbmdzXG5cbiAgICAvLyBjcmVhdGUgYSBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIHNldFxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIHNldCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgZmlyc3RcbiAgICAvLyBjb250YWluaW5nIHRoZSB0eXBlIChhbiBPSUQpIGFuZCBzZWNvbmQgdGhlIHZhbHVlXG4gICAgdmFyIHNlcSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIEF0dHJpYnV0ZVR5cGVcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0RlcihhdHRyLnR5cGUpLmdldEJ5dGVzKCkpLFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVQsIHRydWUsIFtcbiAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIHZhbHVlVGFnQ2xhc3MsIHZhbHVlQ29uc3RydWN0ZWQsIHZhbHVlKVxuICAgICAgXSlcbiAgICBdKTtcbiAgICBydmFsLnZhbHVlLnB1c2goc2VxKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuXG5jb25zdCBqYW5fMV8xOTUwID0gbmV3IERhdGUoJzE5NTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5jb25zdCBqYW5fMV8yMDUwID0gbmV3IERhdGUoJzIwNTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBEYXRlIG9iamVjdCB0byBBU04uMVxuICogSGFuZGxlcyB0aGUgZGlmZmVyZW50IGZvcm1hdCBiZWZvcmUgYW5kIGFmdGVyIDFzdCBKYW51YXJ5IDIwNTBcbiAqXG4gKiBAcGFyYW0gZGF0ZSBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRlLlxuICovXG4gZnVuY3Rpb24gX2RhdGVUb0FzbjEoZGF0ZSl7XG4gIGlmKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuVVRDVElNRSwgZmFsc2UsXG4gICAgICBhc24xLmRhdGVUb1V0Y1RpbWUoZGF0ZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLCBmYWxzZSxcbiAgICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGRhdGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIEFTTi4xIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBUQlNDZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmdldFRCU0NlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICB2YXIgbm90QmVmb3JlID0gX2RhdGVUb0FzbjEoY2VydC52YWxpZGl0eS5ub3RCZWZvcmUpO1xuICB2YXIgbm90QWZ0ZXIgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKTtcbiAgdmFyIHRicyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihjZXJ0LnZlcnNpb24pLmdldEJ5dGVzKCkpXG4gICAgXSksXG4gICAgLy8gc2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhjZXJ0LnNlcmlhbE51bWJlcikpLFxuICAgIC8vIHNpZ25hdHVyZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoXG4gICAgICAgIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzKVxuICAgIF0pLFxuICAgIC8vIGlzc3VlclxuICAgIF9kblRvQXNuMShjZXJ0Lmlzc3VlciksXG4gICAgLy8gdmFsaWRpdHlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBub3RCZWZvcmUsXG4gICAgICBub3RBZnRlclxuICAgIF0pLFxuICAgIC8vIHN1YmplY3RcbiAgICBfZG5Ub0FzbjEoY2VydC5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY2VydC5wdWJsaWNLZXkpXG4gIF0pO1xuXG4gIGlmKGNlcnQuaXNzdWVyLnVuaXF1ZUlkKSB7XG4gICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBpZihjZXJ0LnN1YmplY3QudW5pcXVlSWQpIHtcbiAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZFxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBpZihjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIGV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoY2VydC5leHRlbnNpb25zKSk7XG4gIH1cblxuICByZXR1cm4gdGJzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBBU04uMSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZiBhXG4gKiBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5cbiAqL1xucGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cbiAgdmFyIGNyaSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKGNzci52ZXJzaW9uKS5nZXRCeXRlcygpKSxcbiAgICAvLyBzdWJqZWN0XG4gICAgX2RuVG9Bc24xKGNzci5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY3NyLnB1YmxpY0tleSksXG4gICAgLy8gYXR0cmlidXRlc1xuICAgIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcilcbiAgXSk7XG5cbiAgcmV0dXJuIGNyaTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBEaXN0aW5ndWlzaGVkTmFtZSAoc3ViamVjdCBvciBpc3N1ZXIpIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZG4gdGhlIERpc3Rpbmd1aXNoZWROYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBEaXN0aW5ndWlzaGVkTmFtZS5cbiAqL1xucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xID0gZnVuY3Rpb24oZG4pIHtcbiAgcmV0dXJuIF9kblRvQXNuMShkbik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5djMgUlNBIGNlcnRpZmljYXRlIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlVG9Bc24xID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBwcmVmZXIgY2FjaGVkIFRCU0NlcnRpZmljYXRlIG92ZXIgZ2VuZXJhdGluZyBvbmVcbiAgdmFyIHRic0NlcnRpZmljYXRlID0gY2VydC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG5cbiAgLy8gQ2VydGlmaWNhdGVcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICAgIHRic0NlcnRpZmljYXRlLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY2VydC5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoY2VydC5zaWduYXR1cmVPaWQsIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgKyBjZXJ0LnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIFguNTA5djMgY2VydGlmaWNhdGUgZXh0ZW5zaW9ucyB0byBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbnMgaW4gQVNOLjEgZm9ybWF0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zVG9Bc24xID0gZnVuY3Rpb24oZXh0cykge1xuICAvLyBjcmVhdGUgdG9wLWxldmVsIGV4dGVuc2lvbiBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDMsIHRydWUsIFtdKTtcblxuICAvLyBjcmVhdGUgZXh0ZW5zaW9uIHNlcXVlbmNlIChzdG9yZXMgYSBzZXF1ZW5jZSBmb3IgZWFjaCBleHRlbnNpb24pXG4gIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHJ2YWwudmFsdWUucHVzaChzZXEpO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgc2VxLnZhbHVlLnB1c2gocGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xKGV4dHNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gdG8gQVNOLjEuXG4gKlxuICogQHBhcmFtIGV4dCB0aGUgZXh0ZW5zaW9uIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIGluIEFTTi4xIGZvcm1hdC5cbiAqL1xucGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGNyZWF0ZSBhIHNlcXVlbmNlIGZvciBlYWNoIGV4dGVuc2lvblxuICB2YXIgZXh0c2VxID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGV4dG5JRCAoT0lEKVxuICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgYXNuMS5vaWRUb0RlcihleHQuaWQpLmdldEJ5dGVzKCkpKTtcblxuICAvLyBjcml0aWNhbCBkZWZhdWx0cyB0byBmYWxzZVxuICBpZihleHQuY3JpdGljYWwpIHtcbiAgICAvLyBjcml0aWNhbCBCT09MRUFOIERFRkFVTFQgRkFMU0VcbiAgICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQk9PTEVBTiwgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBleHQudmFsdWU7XG4gIGlmKHR5cGVvZiBleHQudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUgaXMgYXNuLjFcbiAgICB2YWx1ZSA9IGFzbjEudG9EZXIodmFsdWUpLmdldEJ5dGVzKCk7XG4gIH1cblxuICAvLyBleHRuVmFsdWUgKE9DVEVUIFNUUklORylcbiAgZXh0c2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIGV4dHNlcTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCB0byBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBwcmVmZXIgY2FjaGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBvdmVyIGdlbmVyYXRpbmcgb25lXG4gIHZhciBjcmkgPSBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHx8XG4gICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuXG4gIC8vIENlcnRpZmljYXRlXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXG4gICAgY3JpLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY3NyLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzXG4gICAgICBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShjc3Iuc2lnbmF0dXJlT2lkLCBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBzaWduYXR1cmVcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApICsgY3NyLnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDQSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gY2VydHMgYW4gb3B0aW9uYWwgYXJyYXkgb2YgY2VydGlmaWNhdGUgb2JqZWN0cyBvciBQRU0tZm9ybWF0dGVkXG4gKiAgICAgICAgICBjZXJ0aWZpY2F0ZSBzdHJpbmdzIHRvIGFkZCB0byB0aGUgQ0Egc3RvcmUuXG4gKlxuICogQHJldHVybiB0aGUgQ0Egc3RvcmUuXG4gKi9cbnBraS5jcmVhdGVDYVN0b3JlID0gZnVuY3Rpb24oY2VydHMpIHtcbiAgLy8gY3JlYXRlIENBIHN0b3JlXG4gIHZhciBjYVN0b3JlID0ge1xuICAgIC8vIHN0b3JlZCBjZXJ0aWZpY2F0ZXNcbiAgICBjZXJ0czoge31cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY2VydGlmaWNhdGUgdGhhdCBpc3N1ZWQgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSBvciBpdHNcbiAgICogJ3BhcmVudCcuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBvciBudWxsIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cbiAgY2FTdG9yZS5nZXRJc3N1ZXIgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJ2YWwgPSBnZXRCeVN1YmplY3QoY2VydC5pc3N1ZXIpO1xuXG4gICAgLy8gc2VlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzXG4gICAgLyppZihmb3JnZS51dGlsLmlzQXJyYXkocnZhbCkpIHtcbiAgICAgIC8vIFRPRE86IHJlc29sdmUgbXVsdGlwbGUgbWF0Y2hlcyBieSBjaGVja2luZ1xuICAgICAgLy8gYXV0aG9yaXR5S2V5L3N1YmplY3RLZXkvaXNzdWVyVW5pcXVlSUQvb3RoZXIgaWRlbnRpZmllcnMsIGV0Yy5cbiAgICAgIC8vIEZJWE1FOiBvciBhbHRlcm5hdGl2ZWx5IGRvIGF1dGhvcml0eSBrZXkgbWFwcGluZ1xuICAgICAgLy8gaWYgcG9zc2libGUgKFguNTA5djEgY2VydHMgY2FuJ3Qgd29yaz8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBtdWx0aXBsZSBpc3N1ZXIgbWF0Y2hlcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH0qL1xuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0cnVzdGVkIGNlcnRpZmljYXRlIHRvIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGFkZCBhcyBhIHRydXN0ZWQgY2VydGlmaWNhdGUgKGVpdGhlciBhXG4gICAqICAgICAgICAgIHBraS5jZXJ0aWZpY2F0ZSBvYmplY3Qgb3IgYSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICovXG4gIGNhU3RvcmUuYWRkQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkgeyAgLy8gYXZvaWQgZHVwbGljYXRlIGNlcnRpZmljYXRlcyBpbiBzdG9yZVxuICAgICAgaWYoY2VydC5zdWJqZWN0Lmhhc2ggaW4gY2FTdG9yZS5jZXJ0cykge1xuICAgICAgICAvLyBzdWJqZWN0IGhhc2ggYWxyZWFkeSBleGlzdHMsIGFwcGVuZCB0byBhcnJheVxuICAgICAgICB2YXIgdG1wID0gY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkodG1wKSkge1xuICAgICAgICAgIHRtcCA9IFt0bXBdO1xuICAgICAgICB9XG4gICAgICAgIHRtcC5wdXNoKGNlcnQpO1xuICAgICAgICBjYVN0b3JlLmNlcnRzW2NlcnQuc3ViamVjdC5oYXNoXSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdID0gY2VydDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIGdpdmVuIGNlcnRpZmljYXRlIGlzIGluIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGNoZWNrIChlaXRoZXIgYSBwa2kuY2VydGlmaWNhdGUgb3IgYVxuICAgKiAgICAgICAgICBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBpbiB0aGUgc3RvcmUsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNhU3RvcmUuaGFzQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGdldEJ5U3ViamVjdChjZXJ0LnN1YmplY3QpO1xuICAgIGlmKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgbWF0Y2ggPSBbbWF0Y2hdO1xuICAgIH1cbiAgICAvLyBjb21wYXJlIERFUi1lbmNvZGluZyBvZiBjZXJ0aWZpY2F0ZXNcbiAgICB2YXIgZGVyMSA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKGNlcnQpKS5nZXRCeXRlcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGRlcjIgPSBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShtYXRjaFtpXSkpLmdldEJ5dGVzKCk7XG4gICAgICBpZihkZXIxID09PSBkZXIyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBvZiB0aGUgY2VydGlmaWNhdGVzIGtlcHQgaW4gdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUgcGtpLmNlcnRpZmljYXRlIG9iamVjdHMgaW4gdGhlIHN0b3JlLlxuICAgKi9cbiAgY2FTdG9yZS5saXN0QWxsQ2VydGlmaWNhdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNlcnRMaXN0ID0gW107XG5cbiAgICBmb3IodmFyIGhhc2ggaW4gY2FTdG9yZS5jZXJ0cykge1xuICAgICAgaWYoY2FTdG9yZS5jZXJ0cy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjYVN0b3JlLmNlcnRzW2hhc2hdO1xuICAgICAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGNlcnRMaXN0LnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlcnRMaXN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2VydGlmaWNhdGUgZnJvbSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byByZW1vdmUgKGVpdGhlciBhIHBraS5jZXJ0aWZpY2F0ZSBvciBhXG4gICAqICAgICAgICAgIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZSB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwgaWYgdGhlIGNlcnRpZmljYXRlXG4gICAqICAgICAgICAgICB3YXNuJ3QgaW4gc3RvcmUuXG4gICAqL1xuICBjYVN0b3JlLnJlbW92ZUNlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBjb252ZXJ0IGZyb20gcGVtIGlmIG5lY2Vzc2FyeVxuICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2VydCA9IGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgfVxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG4gICAgaWYoIWNhU3RvcmUuaGFzQ2VydGlmaWNhdGUoY2VydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGdldEJ5U3ViamVjdChjZXJ0LnN1YmplY3QpO1xuXG4gICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShtYXRjaCkpIHtcbiAgICAgIHJlc3VsdCA9IGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgICAgZGVsZXRlIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIERFUi1lbmNvZGluZyBvZiBjZXJ0aWZpY2F0ZXNcbiAgICB2YXIgZGVyMSA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKGNlcnQpKS5nZXRCeXRlcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGRlcjIgPSBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShtYXRjaFtpXSkpLmdldEJ5dGVzKCk7XG4gICAgICBpZihkZXIxID09PSBkZXIyKSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGNoW2ldO1xuICAgICAgICBtYXRjaC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG1hdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QnlTdWJqZWN0KHN1YmplY3QpIHtcbiAgICBlbnN1cmVTdWJqZWN0SGFzSGFzaChzdWJqZWN0KTtcbiAgICByZXR1cm4gY2FTdG9yZS5jZXJ0c1tzdWJqZWN0Lmhhc2hdIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdWJqZWN0SGFzSGFzaChzdWJqZWN0KSB7XG4gICAgLy8gcHJvZHVjZSBzdWJqZWN0IGhhc2ggaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmKCFzdWJqZWN0Lmhhc2gpIHtcbiAgICAgIHZhciBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBzdWJqZWN0LmF0dHJpYnV0ZXMgPSAgcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KF9kblRvQXNuMShzdWJqZWN0KSwgbWQpO1xuICAgICAgc3ViamVjdC5oYXNoID0gbWQuZGlnZXN0KCkudG9IZXgoKTtcbiAgICB9XG4gIH1cblxuICAvLyBhdXRvLWFkZCBwYXNzZWQgaW4gY2VydHNcbiAgaWYoY2VydHMpIHtcbiAgICAvLyBwYXJzZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlcyBhcyBuZWNlc3NhcnlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2VydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjZXJ0ID0gY2VydHNbaV07XG4gICAgICBjYVN0b3JlLmFkZENlcnRpZmljYXRlKGNlcnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYVN0b3JlO1xufTtcblxuLyoqXG4gKiBDZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24gZXJyb3JzLCBiYXNlZCBvbiBUTFMuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUVycm9yID0ge1xuICBiYWRfY2VydGlmaWNhdGU6ICdmb3JnZS5wa2kuQmFkQ2VydGlmaWNhdGUnLFxuICB1bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZTogJ2ZvcmdlLnBraS5VbnN1cHBvcnRlZENlcnRpZmljYXRlJyxcbiAgY2VydGlmaWNhdGVfcmV2b2tlZDogJ2ZvcmdlLnBraS5DZXJ0aWZpY2F0ZVJldm9rZWQnLFxuICBjZXJ0aWZpY2F0ZV9leHBpcmVkOiAnZm9yZ2UucGtpLkNlcnRpZmljYXRlRXhwaXJlZCcsXG4gIGNlcnRpZmljYXRlX3Vua25vd246ICdmb3JnZS5wa2kuQ2VydGlmaWNhdGVVbmtub3duJyxcbiAgdW5rbm93bl9jYTogJ2ZvcmdlLnBraS5Vbmtub3duQ2VydGlmaWNhdGVBdXRob3JpdHknXG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGEgY2VydGlmaWNhdGUgY2hhaW4gYWdhaW5zdCB0aGUgZ2l2ZW4gQ2VydGlmaWNhdGUgQXV0aG9yaXR5IHN0b3JlXG4gKiB3aXRoIGFuIG9wdGlvbmFsIGN1c3RvbSB2ZXJpZnkgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIGNhU3RvcmUgYSBjZXJ0aWZpY2F0ZSBzdG9yZSB0byB2ZXJpZnkgYWdhaW5zdC5cbiAqIEBwYXJhbSBjaGFpbiB0aGUgY2VydGlmaWNhdGUgY2hhaW4gdG8gdmVyaWZ5LCB3aXRoIHRoZSByb290IG9yIGhpZ2hlc3RcbiAqICAgICAgICAgIGF1dGhvcml0eSBhdCB0aGUgZW5kIChhbiBhcnJheSBvZiBjZXJ0aWZpY2F0ZXMpLlxuICogQHBhcmFtIHZlcmlmeSBjYWxsZWQgZm9yIGV2ZXJ5IGNlcnRpZmljYXRlIGluIHRoZSBjaGFpbi5cbiAqXG4gKiBUaGUgdmVyaWZ5IGNhbGxiYWNrIGhhcyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqXG4gKiB2ZXJpZmllZCAtIFNldCB0byB0cnVlIGlmIGNlcnRpZmljYXRlIHdhcyB2ZXJpZmllZCwgb3RoZXJ3aXNlIHRoZVxuICogICBwa2kuY2VydGlmaWNhdGVFcnJvciBmb3Igd2h5IHRoZSBjZXJ0aWZpY2F0ZSBmYWlsZWQuXG4gKiBkZXB0aCAtIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBjaGFpbiwgd2hlcmUgMCBpcyB0aGUgZW5kIHBvaW50J3MgY2VydC5cbiAqIGNlcnRzIC0gVGhlIGNlcnRpZmljYXRlIGNoYWluLCAqTk9URSogYW4gZW1wdHkgY2hhaW4gaW5kaWNhdGVzIGFuIGFub255bW91c1xuICogICBlbmQgcG9pbnQuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzIGFuZCBvbiBmYWlsdXJlIGVpdGhlciB0aGUgYXBwcm9wcmlhdGVcbiAqIHBraS5jZXJ0aWZpY2F0ZUVycm9yIG9yIGFuIG9iamVjdCB3aXRoICdlcnJvcicgc2V0IHRvIHRoZSBhcHByb3ByaWF0ZVxuICogcGtpLmNlcnRpZmljYXRlRXJyb3IgYW5kICdtZXNzYWdlJyBzZXQgdG8gYSBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZXJyb3IgdGhyb3duIGlmIG5vdC5cbiAqL1xucGtpLnZlcmlmeUNlcnRpZmljYXRlQ2hhaW4gPSBmdW5jdGlvbihjYVN0b3JlLCBjaGFpbiwgdmVyaWZ5KSB7XG4gIC8qIEZyb206IFJGQzMyODAgLSBJbnRlcm5ldCBYLjUwOSBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIENlcnRpZmljYXRlXG4gICAgU2VjdGlvbiA2OiBDZXJ0aWZpY2F0aW9uIFBhdGggVmFsaWRhdGlvblxuICAgIFNlZSBpbmxpbmUgcGFyZW50aGV0aWNhbHMgcmVsYXRlZCB0byB0aGlzIHBhcnRpY3VsYXIgaW1wbGVtZW50YXRpb24uXG5cbiAgICBUaGUgcHJpbWFyeSBnb2FsIG9mIHBhdGggdmFsaWRhdGlvbiBpcyB0byB2ZXJpZnkgdGhlIGJpbmRpbmcgYmV0d2VlblxuICAgIGEgc3ViamVjdCBkaXN0aW5ndWlzaGVkIG5hbWUgb3IgYSBzdWJqZWN0IGFsdGVybmF0aXZlIG5hbWUgYW5kIHN1YmplY3RcbiAgICBwdWJsaWMga2V5LCBhcyByZXByZXNlbnRlZCBpbiB0aGUgZW5kIGVudGl0eSBjZXJ0aWZpY2F0ZSwgYmFzZWQgb24gdGhlXG4gICAgcHVibGljIGtleSBvZiB0aGUgdHJ1c3QgYW5jaG9yLiBUaGlzIHJlcXVpcmVzIG9idGFpbmluZyBhIHNlcXVlbmNlIG9mXG4gICAgY2VydGlmaWNhdGVzIHRoYXQgc3VwcG9ydCB0aGF0IGJpbmRpbmcuIFRoYXQgc2VxdWVuY2Ugc2hvdWxkIGJlIHByb3ZpZGVkXG4gICAgaW4gdGhlIHBhc3NlZCAnY2hhaW4nLiBUaGUgdHJ1c3QgYW5jaG9yIHNob3VsZCBiZSBpbiB0aGUgZ2l2ZW4gQ0FcbiAgICBzdG9yZS4gVGhlICdlbmQgZW50aXR5JyBjZXJ0aWZpY2F0ZSBpcyB0aGUgY2VydGlmaWNhdGUgcHJvdmlkZWQgYnkgdGhlXG4gICAgZW5kIHBvaW50ICh0eXBpY2FsbHkgYSBzZXJ2ZXIpIGFuZCBpcyB0aGUgZmlyc3QgaW4gdGhlIGNoYWluLlxuXG4gICAgVG8gbWVldCB0aGlzIGdvYWwsIHRoZSBwYXRoIHZhbGlkYXRpb24gcHJvY2VzcyB2ZXJpZmllcywgYW1vbmcgb3RoZXJcbiAgICB0aGluZ3MsIHRoYXQgYSBwcm9zcGVjdGl2ZSBjZXJ0aWZpY2F0aW9uIHBhdGggKGEgc2VxdWVuY2Ugb2YgblxuICAgIGNlcnRpZmljYXRlcyBvciBhICdjaGFpbicpIHNhdGlzZmllcyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICAoYSkgZm9yIGFsbCB4IGluIHsxLCAuLi4sIG4tMX0sIHRoZSBzdWJqZWN0IG9mIGNlcnRpZmljYXRlIHggaXNcbiAgICAgICAgICB0aGUgaXNzdWVyIG9mIGNlcnRpZmljYXRlIHgrMTtcblxuICAgIChiKSBjZXJ0aWZpY2F0ZSAxIGlzIGlzc3VlZCBieSB0aGUgdHJ1c3QgYW5jaG9yO1xuXG4gICAgKGMpIGNlcnRpZmljYXRlIG4gaXMgdGhlIGNlcnRpZmljYXRlIHRvIGJlIHZhbGlkYXRlZDsgYW5kXG5cbiAgICAoZCkgZm9yIGFsbCB4IGluIHsxLCAuLi4sIG59LCB0aGUgY2VydGlmaWNhdGUgd2FzIHZhbGlkIGF0IHRoZVxuICAgICAgICAgIHRpbWUgaW4gcXVlc3Rpb24uXG5cbiAgICBOb3RlIHRoYXQgaGVyZSAnbicgaXMgaW5kZXggMCBpbiB0aGUgY2hhaW4gYW5kIDEgaXMgdGhlIGxhc3QgY2VydGlmaWNhdGVcbiAgICBpbiB0aGUgY2hhaW4gYW5kIGl0IG11c3QgYmUgc2lnbmVkIGJ5IGEgY2VydGlmaWNhdGUgaW4gdGhlIGNvbm5lY3Rpb24nc1xuICAgIENBIHN0b3JlLlxuXG4gICAgVGhlIHBhdGggdmFsaWRhdGlvbiBwcm9jZXNzIGFsc28gZGV0ZXJtaW5lcyB0aGUgc2V0IG9mIGNlcnRpZmljYXRlXG4gICAgcG9saWNpZXMgdGhhdCBhcmUgdmFsaWQgZm9yIHRoaXMgcGF0aCwgYmFzZWQgb24gdGhlIGNlcnRpZmljYXRlIHBvbGljaWVzXG4gICAgZXh0ZW5zaW9uLCBwb2xpY3kgbWFwcGluZyBleHRlbnNpb24sIHBvbGljeSBjb25zdHJhaW50cyBleHRlbnNpb24sIGFuZFxuICAgIGluaGliaXQgYW55LXBvbGljeSBleHRlbnNpb24uXG5cbiAgICBOb3RlOiBQb2xpY3kgbWFwcGluZyBleHRlbnNpb24gbm90IHN1cHBvcnRlZCAoTm90IFJlcXVpcmVkKS5cblxuICAgIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0ZSBoYXMgYW4gdW5zdXBwb3J0ZWQgY3JpdGljYWwgZXh0ZW5zaW9uLCB0aGVuIGl0XG4gICAgbXVzdCBiZSByZWplY3RlZC5cblxuICAgIE5vdGU6IEEgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgaWYgdGhlIEROcyB0aGF0IGFwcGVhciBpbiB0aGUgc3ViamVjdFxuICAgIGFuZCBpc3N1ZXIgZmllbGRzIGFyZSBpZGVudGljYWwgYW5kIGFyZSBub3QgZW1wdHkuXG5cbiAgICBUaGUgcGF0aCB2YWxpZGF0aW9uIGFsZ29yaXRobSBhc3N1bWVzIHRoZSBmb2xsb3dpbmcgc2V2ZW4gaW5wdXRzIGFyZVxuICAgIHByb3ZpZGVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmcgbG9naWMuIFdoYXQgdGhpcyBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuICAgIHdpbGwgdXNlIGlzIHByb3ZpZGVkIHBhcmVudGhldGljYWxseTpcblxuICAgIChhKSBhIHByb3NwZWN0aXZlIGNlcnRpZmljYXRpb24gcGF0aCBvZiBsZW5ndGggbiAodGhlICdjaGFpbicpXG4gICAgKGIpIHRoZSBjdXJyZW50IGRhdGUvdGltZTogKCdub3cnKS5cbiAgICAoYykgdXNlci1pbml0aWFsLXBvbGljeS1zZXQ6IEEgc2V0IG9mIGNlcnRpZmljYXRlIHBvbGljeSBpZGVudGlmaWVyc1xuICAgICAgICAgIG5hbWluZyB0aGUgcG9saWNpZXMgdGhhdCBhcmUgYWNjZXB0YWJsZSB0byB0aGUgY2VydGlmaWNhdGUgdXNlci5cbiAgICAgICAgICBUaGUgdXNlci1pbml0aWFsLXBvbGljeS1zZXQgY29udGFpbnMgdGhlIHNwZWNpYWwgdmFsdWUgYW55LXBvbGljeVxuICAgICAgICAgIGlmIHRoZSB1c2VyIGlzIG5vdCBjb25jZXJuZWQgYWJvdXQgY2VydGlmaWNhdGUgcG9saWN5XG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZC4gQW55IHBvbGljeSBpcyBhY2NlcHRlZCkuXG4gICAgKGQpIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvbiwgZGVzY3JpYmluZyBhIENBIHRoYXQgc2VydmVzIGFzIGEgdHJ1c3RcbiAgICAgICAgICBhbmNob3IgZm9yIHRoZSBjZXJ0aWZpY2F0aW9uIHBhdGguIFRoZSB0cnVzdCBhbmNob3IgaW5mb3JtYXRpb25cbiAgICAgICAgICBpbmNsdWRlczpcblxuICAgICAgKDEpICB0aGUgdHJ1c3RlZCBpc3N1ZXIgbmFtZSxcbiAgICAgICgyKSAgdGhlIHRydXN0ZWQgcHVibGljIGtleSBhbGdvcml0aG0sXG4gICAgICAoMykgIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXksIGFuZFxuICAgICAgKDQpICBvcHRpb25hbGx5LCB0aGUgdHJ1c3RlZCBwdWJsaWMga2V5IHBhcmFtZXRlcnMgYXNzb2NpYXRlZFxuICAgICAgICAgICAgIHdpdGggdGhlIHB1YmxpYyBrZXkuXG5cbiAgICAgIChUcnVzdCBhbmNob3JzIGFyZSBwcm92aWRlZCB2aWEgY2VydGlmaWNhdGVzIGluIHRoZSBDQSBzdG9yZSkuXG5cbiAgICAgIFRoZSB0cnVzdCBhbmNob3IgaW5mb3JtYXRpb24gbWF5IGJlIHByb3ZpZGVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmdcbiAgICAgIHByb2NlZHVyZSBpbiB0aGUgZm9ybSBvZiBhIHNlbGYtc2lnbmVkIGNlcnRpZmljYXRlLiBUaGUgdHJ1c3RlZCBhbmNob3JcbiAgICAgIGluZm9ybWF0aW9uIGlzIHRydXN0ZWQgYmVjYXVzZSBpdCB3YXMgZGVsaXZlcmVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmdcbiAgICAgIHByb2NlZHVyZSBieSBzb21lIHRydXN0d29ydGh5IG91dC1vZi1iYW5kIHByb2NlZHVyZS4gSWYgdGhlIHRydXN0ZWRcbiAgICAgIHB1YmxpYyBrZXkgYWxnb3JpdGhtIHJlcXVpcmVzIHBhcmFtZXRlcnMsIHRoZW4gdGhlIHBhcmFtZXRlcnMgYXJlXG4gICAgICBwcm92aWRlZCBhbG9uZyB3aXRoIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXkgKE5vIHBhcmFtZXRlcnMgdXNlZCBpbiB0aGlzXG4gICAgICBpbXBsZW1lbnRhdGlvbikuXG5cbiAgICAoZSkgaW5pdGlhbC1wb2xpY3ktbWFwcGluZy1pbmhpYml0LCB3aGljaCBpbmRpY2F0ZXMgaWYgcG9saWN5IG1hcHBpbmcgaXNcbiAgICAgICAgICBhbGxvd2VkIGluIHRoZSBjZXJ0aWZpY2F0aW9uIHBhdGguXG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZCwgbm8gcG9saWN5IGNoZWNraW5nKVxuXG4gICAgKGYpIGluaXRpYWwtZXhwbGljaXQtcG9saWN5LCB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIHBhdGggbXVzdCBiZSB2YWxpZFxuICAgICAgICAgIGZvciBhdCBsZWFzdCBvbmUgb2YgdGhlIGNlcnRpZmljYXRlIHBvbGljaWVzIGluIHRoZSB1c2VyLWluaXRpYWwtXG4gICAgICAgICAgcG9saWN5LXNldC5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBubyBwb2xpY3kgY2hlY2tpbmcpXG5cbiAgICAoZykgaW5pdGlhbC1hbnktcG9saWN5LWluaGliaXQsIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIHRoZVxuICAgICAgICAgIGFueVBvbGljeSBPSUQgc2hvdWxkIGJlIHByb2Nlc3NlZCBpZiBpdCBpcyBpbmNsdWRlZCBpbiBhXG4gICAgICAgICAgY2VydGlmaWNhdGUuXG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZCwgc28gYW55IHBvbGljeSBpcyB2YWxpZCBwcm92aWRlZCB0aGF0IGl0IGlzXG4gICAgICAgICAgbm90IG1hcmtlZCBhcyBjcml0aWNhbCkgKi9cblxuICAvKiBCYXNpYyBQYXRoIFByb2Nlc3Npbmc6XG5cbiAgICBGb3IgZWFjaCBjZXJ0aWZpY2F0ZSBpbiB0aGUgJ2NoYWluJywgdGhlIGZvbGxvd2luZyBpcyBjaGVja2VkOlxuXG4gICAgMS4gVGhlIGNlcnRpZmljYXRlIHZhbGlkaXR5IHBlcmlvZCBpbmNsdWRlcyB0aGUgY3VycmVudCB0aW1lLlxuICAgIDIuIFRoZSBjZXJ0aWZpY2F0ZSB3YXMgc2lnbmVkIGJ5IGl0cyBwYXJlbnQgKHdoZXJlIHRoZSBwYXJlbnQgaXMgZWl0aGVyXG4gICAgICAgdGhlIG5leHQgaW4gdGhlIGNoYWluIG9yIGZyb20gdGhlIENBIHN0b3JlKS4gQWxsb3cgcHJvY2Vzc2luZyB0b1xuICAgICAgIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHN0ZXAgaWYgbm8gcGFyZW50IGlzIGZvdW5kIGJ1dCB0aGUgY2VydGlmaWNhdGUgaXNcbiAgICAgICBpbiB0aGUgQ0Egc3RvcmUuXG4gICAgMy4gVE9ETzogVGhlIGNlcnRpZmljYXRlIGhhcyBub3QgYmVlbiByZXZva2VkLlxuICAgIDQuIFRoZSBjZXJ0aWZpY2F0ZSBpc3N1ZXIgbmFtZSBtYXRjaGVzIHRoZSBwYXJlbnQncyBzdWJqZWN0IG5hbWUuXG4gICAgNS4gVE9ETzogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHNlbGYtaXNzdWVkIGFuZCBub3QgdGhlIGZpbmFsIGNlcnRpZmljYXRlXG4gICAgICAgaW4gdGhlIGNoYWluLCBza2lwIHRoaXMgc3RlcCwgb3RoZXJ3aXNlIHZlcmlmeSB0aGF0IHRoZSBzdWJqZWN0IG5hbWVcbiAgICAgICBpcyB3aXRoaW4gb25lIG9mIHRoZSBwZXJtaXR0ZWQgc3VidHJlZXMgb2YgWC41MDAgZGlzdGluZ3Vpc2hlZCBuYW1lc1xuICAgICAgIGFuZCB0aGF0IGVhY2ggb2YgdGhlIGFsdGVybmF0aXZlIG5hbWVzIGluIHRoZSBzdWJqZWN0QWx0TmFtZSBleHRlbnNpb25cbiAgICAgICAoY3JpdGljYWwgb3Igbm9uLWNyaXRpY2FsKSBpcyB3aXRoaW4gb25lIG9mIHRoZSBwZXJtaXR0ZWQgc3VidHJlZXMgZm9yXG4gICAgICAgdGhhdCBuYW1lIHR5cGUuXG4gICAgNi4gVE9ETzogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHNlbGYtaXNzdWVkIGFuZCBub3QgdGhlIGZpbmFsIGNlcnRpZmljYXRlXG4gICAgICAgaW4gdGhlIGNoYWluLCBza2lwIHRoaXMgc3RlcCwgb3RoZXJ3aXNlIHZlcmlmeSB0aGF0IHRoZSBzdWJqZWN0IG5hbWVcbiAgICAgICBpcyBub3Qgd2l0aGluIG9uZSBvZiB0aGUgZXhjbHVkZWQgc3VidHJlZXMgZm9yIFguNTAwIGRpc3Rpbmd1aXNoZWRcbiAgICAgICBuYW1lcyBhbmQgbm9uZSBvZiB0aGUgc3ViamVjdEFsdE5hbWUgZXh0ZW5zaW9uIG5hbWVzIGFyZSBleGNsdWRlZCBmb3JcbiAgICAgICB0aGF0IG5hbWUgdHlwZS5cbiAgICA3LiBUaGUgb3RoZXIgc3RlcHMgaW4gdGhlIGFsZ29yaXRobSBmb3IgYmFzaWMgcGF0aCBwcm9jZXNzaW5nIGludm9sdmVcbiAgICAgICBoYW5kbGluZyB0aGUgcG9saWN5IGV4dGVuc2lvbiB3aGljaCBpcyBub3QgcHJlc2VudGx5IHN1cHBvcnRlZCBpbiB0aGlzXG4gICAgICAgaW1wbGVtZW50YXRpb24uIEluc3RlYWQsIGlmIGEgY3JpdGljYWwgcG9saWN5IGV4dGVuc2lvbiBpcyBmb3VuZCwgdGhlXG4gICAgICAgY2VydGlmaWNhdGUgaXMgcmVqZWN0ZWQgYXMgbm90IHN1cHBvcnRlZC5cbiAgICA4LiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgbm90IHRoZSBmaXJzdCBvciBpZiBpdHMgdGhlIG9ubHkgY2VydGlmaWNhdGUgaW5cbiAgICAgICB0aGUgY2hhaW4gKGhhdmluZyBubyBwYXJlbnQgZnJvbSB0aGUgQ0Egc3RvcmUgb3IgaXMgc2VsZi1zaWduZWQpIGFuZCBpdFxuICAgICAgIGhhcyBhIGNyaXRpY2FsIGtleSB1c2FnZSBleHRlbnNpb24sIHZlcmlmeSB0aGF0IHRoZSBrZXlDZXJ0U2lnbiBiaXQgaXNcbiAgICAgICBzZXQuIElmIHRoZSBrZXkgdXNhZ2UgZXh0ZW5zaW9uIGV4aXN0cywgdmVyaWZ5IHRoYXQgdGhlIGJhc2ljXG4gICAgICAgY29uc3RyYWludHMgZXh0ZW5zaW9uIGV4aXN0cy4gSWYgdGhlIGJhc2ljIGNvbnN0cmFpbnRzIGV4dGVuc2lvbiBleGlzdHMsXG4gICAgICAgdmVyaWZ5IHRoYXQgdGhlIGNBIGZsYWcgaXMgc2V0LiBJZiBwYXRoTGVuQ29uc3RyYWludCBpcyBzZXQsIGVuc3VyZSB0aGF0XG4gICAgICAgdGhlIG51bWJlciBvZiBjZXJ0aWZpY2F0ZXMgdGhhdCBwcmVjZWRlIGluIHRoZSBjaGFpbiAoY29tZSBlYXJsaWVyXG4gICAgICAgaW4gdGhlIGNoYWluIGFzIGltcGxlbWVudGVkIGJlbG93KSwgZXhjbHVkaW5nIHRoZSB2ZXJ5IGZpcnN0IGluIHRoZVxuICAgICAgIGNoYWluICh0eXBpY2FsbHkgdGhlIGVuZC1lbnRpdHkgb25lKSwgaXNuJ3QgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAgIHBhdGhMZW5Db25zdHJhaW50LiBUaGlzIGNvbnN0cmFpbnQgbGltaXRzIHRoZSBudW1iZXIgb2YgaW50ZXJtZWRpYXRlXG4gICAgICAgQ0FzIHRoYXQgbWF5IGFwcGVhciBiZWxvdyBhIENBIGJlZm9yZSBvbmx5IGVuZC1lbnRpdHkgY2VydGlmaWNhdGVzXG4gICAgICAgbWF5IGJlIGlzc3VlZC4gKi9cblxuICAvLyBjb3B5IGNlcnQgY2hhaW4gcmVmZXJlbmNlcyB0byBhbm90aGVyIGFycmF5IHRvIHByb3RlY3QgYWdhaW5zdCBjaGFuZ2VzXG4gIC8vIGluIHZlcmlmeSBjYWxsYmFja1xuICBjaGFpbiA9IGNoYWluLnNsaWNlKDApO1xuICB2YXIgY2VydHMgPSBjaGFpbi5zbGljZSgwKTtcblxuICAvLyBnZXQgY3VycmVudCBkYXRlXG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIC8vIHZlcmlmeSBlYWNoIGNlcnQgaW4gdGhlIGNoYWluIHVzaW5nIGl0cyBwYXJlbnQsIHdoZXJlIHRoZSBwYXJlbnRcbiAgLy8gaXMgZWl0aGVyIHRoZSBuZXh0IGluIHRoZSBjaGFpbiBvciBmcm9tIHRoZSBDQSBzdG9yZVxuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuICB2YXIgZGVwdGggPSAwO1xuICBkbyB7XG4gICAgdmFyIGNlcnQgPSBjaGFpbi5zaGlmdCgpO1xuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBzZWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICAvLyAxLiBjaGVjayB2YWxpZCB0aW1lXG4gICAgaWYobm93IDwgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgfHwgbm93ID4gY2VydC52YWxpZGl0eS5ub3RBZnRlcikge1xuICAgICAgZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdmFsaWQgeWV0IG9yIGhhcyBleHBpcmVkLicsXG4gICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5jZXJ0aWZpY2F0ZV9leHBpcmVkLFxuICAgICAgICBub3RCZWZvcmU6IGNlcnQudmFsaWRpdHkubm90QmVmb3JlLFxuICAgICAgICBub3RBZnRlcjogY2VydC52YWxpZGl0eS5ub3RBZnRlcixcbiAgICAgICAgbm93OiBub3dcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMi4gdmVyaWZ5IHdpdGggcGFyZW50IGZyb20gY2hhaW4gb3IgQ0Egc3RvcmVcbiAgICBpZihlcnJvciA9PT0gbnVsbCkge1xuICAgICAgcGFyZW50ID0gY2hhaW5bMF0gfHwgY2FTdG9yZS5nZXRJc3N1ZXIoY2VydCk7XG4gICAgICBpZihwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHNlbGYtc2lnbmVkIGNlcnRcbiAgICAgICAgaWYoY2VydC5pc0lzc3VlcihjZXJ0KSkge1xuICAgICAgICAgIHNlbGZTaWduZWQgPSB0cnVlO1xuICAgICAgICAgIHBhcmVudCA9IGNlcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocGFyZW50KSB7XG4gICAgICAgIC8vIEZJWE1FOiBjdXJyZW50IENBIHN0b3JlIGltcGxlbWVudGF0aW9uIG1pZ2h0IGhhdmUgbXVsdGlwbGVcbiAgICAgICAgLy8gY2VydGlmaWNhdGVzIHdoZXJlIHRoZSBpc3N1ZXIgY2FuJ3QgYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZVxuICAgICAgICAvLyBjZXJ0aWZpY2F0ZSAoaGFwcGVucyByYXJlbHkgd2l0aCwgZWc6IG9sZCBjZXJ0aWZpY2F0ZXMpIHNvIG5vcm1hbGl6ZVxuICAgICAgICAvLyBieSBhbHdheXMgcHV0dGluZyBwYXJlbnRzIGludG8gYW4gYXJyYXlcbiAgICAgICAgLy8gVE9ETzogdGhlcmUncyBtYXkgYmUgYW4gZXh0cmVtZSBkZWdlbmVyYXRlIGNhc2UgY3VycmVudGx5IHVuY292ZXJlZFxuICAgICAgICAvLyB3aGVyZSBhbiBvbGQgaW50ZXJtZWRpYXRlIGNlcnRpZmljYXRlIHNlZW1zIHRvIGhhdmUgYSBtYXRjaGluZyBwYXJlbnRcbiAgICAgICAgLy8gYnV0IG5vbmUgb2YgdGhlIHBhcmVudHMgYWN0dWFsbHkgdmVyaWZ5IC4uLiBidXQgdGhlIGludGVybWVkaWF0ZVxuICAgICAgICAvLyBpcyBpbiB0aGUgQ0EgYW5kIGl0IHNob3VsZCBwYXNzIHRoaXMgY2hlY2s7IG5lZWRzIGludmVzdGlnYXRpb25cbiAgICAgICAgdmFyIHBhcmVudHMgPSBwYXJlbnQ7XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkocGFyZW50cykpIHtcbiAgICAgICAgICBwYXJlbnRzID0gW3BhcmVudHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHZlcmlmeSB3aXRoIGVhY2ggcG9zc2libGUgcGFyZW50ICh0eXBpY2FsbHkgb25seSBvbmUpXG4gICAgICAgIHZhciB2ZXJpZmllZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSghdmVyaWZpZWQgJiYgcGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50cy5zaGlmdCgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2ZXJpZmllZCA9IHBhcmVudC52ZXJpZnkoY2VydCk7XG4gICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgLy8gZmFpbHVyZSB0byB2ZXJpZnksIGRvbid0IGNhcmUgd2h5LCB0cnkgbmV4dCBvbmVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZighdmVyaWZpZWQpIHtcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBzaWduYXR1cmUgaXMgaW52YWxpZC4nLFxuICAgICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYgKCFwYXJlbnQgfHwgc2VsZlNpZ25lZCkgJiZcbiAgICAgICAgIWNhU3RvcmUuaGFzQ2VydGlmaWNhdGUoY2VydCkpIHtcbiAgICAgICAgLy8gbm8gcGFyZW50IGlzc3VlciBhbmQgY2VydGlmaWNhdGUgaXRzZWxmIGlzIG5vdCB0cnVzdGVkXG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdHJ1c3RlZC4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci51bmtub3duX2NhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogMy4gY2hlY2sgcmV2b2tlZFxuXG4gICAgLy8gNC4gY2hlY2sgZm9yIG1hdGNoaW5nIGlzc3Vlci9zdWJqZWN0XG4gICAgaWYoZXJyb3IgPT09IG51bGwgJiYgcGFyZW50ICYmICFjZXJ0LmlzSXNzdWVyKHBhcmVudCkpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBub3QgaXNzdWVyXG4gICAgICBlcnJvciA9IHtcbiAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIGlzc3VlciBpcyBpbnZhbGlkLicsXG4gICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNS4gVE9ETzogY2hlY2sgbmFtZXMgd2l0aCBwZXJtaXR0ZWQgbmFtZXMgdHJlZVxuXG4gICAgLy8gNi4gVE9ETzogY2hlY2sgbmFtZXMgYWdhaW5zdCBleGNsdWRlZCBuYW1lcyB0cmVlXG5cbiAgICAvLyA3LiBjaGVjayBmb3IgdW5zdXBwb3J0ZWQgY3JpdGljYWwgZXh0ZW5zaW9uc1xuICAgIGlmKGVycm9yID09PSBudWxsKSB7XG4gICAgICAvLyBzdXBwb3J0ZWQgZXh0ZW5zaW9uc1xuICAgICAgdmFyIHNlID0ge1xuICAgICAgICBrZXlVc2FnZTogdHJ1ZSxcbiAgICAgICAgYmFzaWNDb25zdHJhaW50czogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGVycm9yID09PSBudWxsICYmIGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGV4dCA9IGNlcnQuZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgaWYoZXh0LmNyaXRpY2FsICYmICEoZXh0Lm5hbWUgaW4gc2UpKSB7XG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnQ2VydGlmaWNhdGUgaGFzIGFuIHVuc3VwcG9ydGVkIGNyaXRpY2FsIGV4dGVuc2lvbi4nLFxuICAgICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDguIGNoZWNrIGZvciBDQSBpZiBjZXJ0IGlzIG5vdCBmaXJzdCBvciBpcyB0aGUgb25seSBjZXJ0aWZpY2F0ZVxuICAgIC8vIHJlbWFpbmluZyBpbiBjaGFpbiB3aXRoIG5vIHBhcmVudCBvciBpcyBzZWxmLXNpZ25lZFxuICAgIGlmKGVycm9yID09PSBudWxsICYmXG4gICAgICAoIWZpcnN0IHx8IChjaGFpbi5sZW5ndGggPT09IDAgJiYgKCFwYXJlbnQgfHwgc2VsZlNpZ25lZCkpKSkge1xuICAgICAgLy8gZmlyc3QgY2hlY2sga2V5VXNhZ2UgZXh0ZW5zaW9uIGFuZCB0aGVuIGJhc2ljIGNvbnN0cmFpbnRzXG4gICAgICB2YXIgYmNFeHQgPSBjZXJ0LmdldEV4dGVuc2lvbignYmFzaWNDb25zdHJhaW50cycpO1xuICAgICAgdmFyIGtleVVzYWdlRXh0ID0gY2VydC5nZXRFeHRlbnNpb24oJ2tleVVzYWdlJyk7XG4gICAgICBpZihrZXlVc2FnZUV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBrZXlDZXJ0U2lnbiBtdXN0IGJlIHRydWUgYW5kIHRoZXJlIG11c3QgYmUgYSBiYXNpY1xuICAgICAgICAvLyBjb25zdHJhaW50cyBleHRlbnNpb25cbiAgICAgICAgaWYoIWtleVVzYWdlRXh0LmtleUNlcnRTaWduIHx8IGJjRXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gYmFkIGNlcnRpZmljYXRlXG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnQ2VydGlmaWNhdGUga2V5VXNhZ2Ugb3IgYmFzaWNDb25zdHJhaW50cyBjb25mbGljdCAnICtcbiAgICAgICAgICAgICAgJ29yIGluZGljYXRlIHRoYXQgdGhlIGNlcnRpZmljYXRlIGlzIG5vdCBhIENBLiAnICtcbiAgICAgICAgICAgICAgJ0lmIHRoZSBjZXJ0aWZpY2F0ZSBpcyB0aGUgb25seSBvbmUgaW4gdGhlIGNoYWluIG9yICcgK1xuICAgICAgICAgICAgICAnaXNuXFwndCB0aGUgZmlyc3QgdGhlbiB0aGUgY2VydGlmaWNhdGUgbXVzdCBiZSBhICcgK1xuICAgICAgICAgICAgICAndmFsaWQgQ0EuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBiYXNpYyBjb25zdHJhaW50cyBjQSBmbGFnIG11c3QgYmUgc2V0XG4gICAgICBpZihlcnJvciA9PT0gbnVsbCAmJiBiY0V4dCAhPT0gbnVsbCAmJiAhYmNFeHQuY0EpIHtcbiAgICAgICAgLy8gYmFkIGNlcnRpZmljYXRlXG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAnQ2VydGlmaWNhdGUgYmFzaWNDb25zdHJhaW50cyBpbmRpY2F0ZXMgdGhlIGNlcnRpZmljYXRlICcgK1xuICAgICAgICAgICAgJ2lzIG5vdCBhIENBLicsXG4gICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gaWYgZXJyb3IgaXMgbm90IG51bGwgYW5kIGtleVVzYWdlIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBrbm93IGl0XG4gICAgICAvLyBoYXMga2V5Q2VydFNpZ24gYW5kIHRoZXJlIGlzIGEgYmFzaWMgY29uc3RyYWludHMgZXh0ZW5zaW9uIHRvbyxcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHdlIGNhbiBjaGVjayBwYXRoTGVuQ29uc3RyYWludCAoaWYgaXQgZXhpc3RzKVxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYga2V5VXNhZ2VFeHQgIT09IG51bGwgJiZcbiAgICAgICAgJ3BhdGhMZW5Db25zdHJhaW50JyBpbiBiY0V4dCkge1xuICAgICAgICAvLyBwYXRoTGVuIGlzIHRoZSBtYXhpbXVtICMgb2YgaW50ZXJtZWRpYXRlIENBIGNlcnRzIHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGZvdW5kIGJldHdlZW4gdGhlIGN1cnJlbnQgY2VydGlmaWNhdGUgYW5kIHRoZSBlbmQtZW50aXR5IChkZXB0aCAwKVxuICAgICAgICAvLyBjZXJ0aWZpY2F0ZTsgdGhpcyBudW1iZXIgZG9lcyBub3QgaW5jbHVkZSB0aGUgZW5kLWVudGl0eSAoZGVwdGggMCxcbiAgICAgICAgLy8gbGFzdCBpbiB0aGUgY2hhaW4pIGV2ZW4gaWYgaXQgaGFwcGVucyB0byBiZSBhIENBIGNlcnRpZmljYXRlIGl0c2VsZlxuICAgICAgICB2YXIgcGF0aExlbiA9IGRlcHRoIC0gMTtcbiAgICAgICAgaWYocGF0aExlbiA+IGJjRXh0LnBhdGhMZW5Db25zdHJhaW50KSB7XG4gICAgICAgICAgLy8gcGF0aExlbkNvbnN0cmFpbnQgdmlvbGF0ZWQsIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGJhc2ljQ29uc3RyYWludHMgcGF0aExlbkNvbnN0cmFpbnQgdmlvbGF0ZWQuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsbCBhcHBsaWNhdGlvbiBjYWxsYmFja1xuICAgIHZhciB2ZmQgPSAoZXJyb3IgPT09IG51bGwpID8gdHJ1ZSA6IGVycm9yLmVycm9yO1xuICAgIHZhciByZXQgPSB2ZXJpZnkgPyB2ZXJpZnkodmZkLCBkZXB0aCwgY2VydHMpIDogdmZkO1xuICAgIGlmKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gY2xlYXIgYW55IHNldCBlcnJvclxuICAgICAgZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBwYXNzZWQgYmFzaWMgdGVzdHMsIHNldCBkZWZhdWx0IG1lc3NhZ2UgYW5kIGFsZXJ0XG4gICAgICBpZih2ZmQgPT09IHRydWUpIHtcbiAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgbWVzc2FnZTogJ1RoZSBhcHBsaWNhdGlvbiByZWplY3RlZCB0aGUgY2VydGlmaWNhdGUuJyxcbiAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBjdXN0b20gZXJyb3IgaW5mb1xuICAgICAgaWYocmV0IHx8IHJldCA9PT0gMCkge1xuICAgICAgICAvLyBzZXQgY3VzdG9tIG1lc3NhZ2UgYW5kIGVycm9yXG4gICAgICAgIGlmKHR5cGVvZiByZXQgPT09ICdvYmplY3QnICYmICFmb3JnZS51dGlsLmlzQXJyYXkocmV0KSkge1xuICAgICAgICAgIGlmKHJldC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IHJldC5tZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmVycm9yID0gcmV0LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gc2V0IGN1c3RvbSBlcnJvclxuICAgICAgICAgIGVycm9yLmVycm9yID0gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBubyBsb25nZXIgZmlyc3QgY2VydCBpbiBjaGFpblxuICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgKytkZXB0aDtcbiAgfSB3aGlsZShjaGFpbi5sZW5ndGggPiAwKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgUEtDUyMxIFBTUyBzaWduYXR1cmUgcGFkZGluZy5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIHNob3J0Y3V0IGZvciBQU1MgQVBJXG52YXIgcHNzID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wc3MgPSBmb3JnZS5wc3MgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIFBTUyBzaWduYXR1cmUgc2NoZW1lIG9iamVjdC5cbiAqXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCB3YXlzIHRvIHByb3ZpZGUgYSBzYWx0IGZvciBlbmNvZGluZzpcbiAqXG4gKiAxLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIG9ubHkgYW5kIHRoZSBidWlsdC1pbiBQUk5HIHdpbGwgZ2VuZXJhdGUgaXQuXG4gKiAyLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIGFuZCBhIGN1c3RvbSBQUk5HIHdpdGggJ2dldEJ5dGVzU3luYycgZGVmaW5lZCB0aGF0XG4gKiAgIHdpbGwgYmUgdXNlZC5cbiAqIDMuIFNwZWNpZnkgdGhlIHNhbHQgaXRzZWxmIGFzIGEgZm9yZ2UudXRpbC5CeXRlQnVmZmVyLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLCBhIGZvcmdlIG1kIGluc3RhbmNlLlxuICogICAgICAgICAgbWdmIHRoZSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gdG8gdXNlLCBhIGZvcmdlIG1nZiBpbnN0YW5jZS5cbiAqICAgICAgICAgIFtzYWx0TGVuZ3RoXSB0aGUgbGVuZ3RoIG9mIHRoZSBzYWx0IGluIG9jdGV0cy5cbiAqICAgICAgICAgIFtwcm5nXSB0aGUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSB0byBwcm9kdWNlIGEgc2FsdC5cbiAqICAgICAgICAgIFtzYWx0XSB0aGUgc2FsdCB0byB1c2Ugd2hlbiBlbmNvZGluZy5cbiAqXG4gKiBAcmV0dXJuIGEgc2lnbmF0dXJlIHNjaGVtZSBvYmplY3QuXG4gKi9cbnBzcy5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHcvbGVnYWN5IGFyZ3M6IGhhc2gsIG1nZiwgc0xlblxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1kOiBhcmd1bWVudHNbMF0sXG4gICAgICBtZ2Y6IGFyZ3VtZW50c1sxXSxcbiAgICAgIHNhbHRMZW5ndGg6IGFyZ3VtZW50c1syXVxuICAgIH07XG4gIH1cblxuICB2YXIgaGFzaCA9IG9wdGlvbnMubWQ7XG4gIHZhciBtZ2YgPSBvcHRpb25zLm1nZjtcbiAgdmFyIGhMZW4gPSBoYXNoLmRpZ2VzdExlbmd0aDtcblxuICB2YXIgc2FsdF8gPSBvcHRpb25zLnNhbHQgfHwgbnVsbDtcbiAgaWYodHlwZW9mIHNhbHRfID09PSAnc3RyaW5nJykge1xuICAgIC8vIGFzc3VtZSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICBzYWx0XyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNhbHRfKTtcbiAgfVxuXG4gIHZhciBzTGVuO1xuICBpZignc2FsdExlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgIHNMZW4gPSBvcHRpb25zLnNhbHRMZW5ndGg7XG4gIH0gZWxzZSBpZihzYWx0XyAhPT0gbnVsbCkge1xuICAgIHNMZW4gPSBzYWx0Xy5sZW5ndGgoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbHQgbGVuZ3RoIG5vdCBzcGVjaWZpZWQgb3Igc3BlY2lmaWMgc2FsdCBub3QgZ2l2ZW4uJyk7XG4gIH1cblxuICBpZihzYWx0XyAhPT0gbnVsbCAmJiBzYWx0Xy5sZW5ndGgoKSAhPT0gc0xlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gc2FsdCBsZW5ndGggZG9lcyBub3QgbWF0Y2ggbGVuZ3RoIG9mIGdpdmVuIHNhbHQuJyk7XG4gIH1cblxuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG5cbiAgdmFyIHBzc29iaiA9IHt9O1xuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgUFNTIHNpZ25hdHVyZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIEVNU0EtUFNTLUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcsIHNlY3Rpb24gOS4xLjEuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAgICogQHBhcmFtIG1vZHNCaXRzIHRoZSBsZW5ndGggb2YgdGhlIFJTQSBtb2R1bHVzIGluIGJpdHMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBsZW5ndGhcbiAgICogICAgICAgICAgIGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpLlxuICAgKi9cbiAgcHNzb2JqLmVuY29kZSA9IGZ1bmN0aW9uKG1kLCBtb2RCaXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgIHZhciBlbUxlbiA9IE1hdGguY2VpbChlbUJpdHMgLyA4KTtcblxuICAgIC8qIDIuIExldCBtSGFzaCA9IEhhc2goTSksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICB2YXIgbUhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogMy4gSWYgZW1MZW4gPCBoTGVuICsgc0xlbiArIDIsIG91dHB1dCBcImVuY29kaW5nIGVycm9yXCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyB0byBlbmNyeXB0LicpO1xuICAgIH1cblxuICAgIC8qIDQuIEdlbmVyYXRlIGEgcmFuZG9tIG9jdGV0IHN0cmluZyBzYWx0IG9mIGxlbmd0aCBzTGVuOyBpZiBzTGVuID0gMCxcbiAgICAgKiAgICB0aGVuIHNhbHQgaXMgdGhlIGVtcHR5IHN0cmluZy4gKi9cbiAgICB2YXIgc2FsdDtcbiAgICBpZihzYWx0XyA9PT0gbnVsbCkge1xuICAgICAgc2FsdCA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHNMZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYWx0ID0gc2FsdF8uYnl0ZXMoKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgTScgPSAoMHgpMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgfHwgbUhhc2ggfHwgc2FsdDsgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDYuIExldCBIID0gSGFzaChNJyksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUobV8uZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIGggPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiA3LiBHZW5lcmF0ZSBhbiBvY3RldCBzdHJpbmcgUFMgY29uc2lzdGluZyBvZiBlbUxlbiAtIHNMZW4gLSBoTGVuIC0gMlxuICAgICAqICAgIHplcm8gb2N0ZXRzLiAgVGhlIGxlbmd0aCBvZiBQUyBtYXkgYmUgMC4gKi9cbiAgICB2YXIgcHMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgcHMuZmlsbFdpdGhCeXRlKDAsIGVtTGVuIC0gc0xlbiAtIGhMZW4gLSAyKTtcblxuICAgIC8qIDguIExldCBEQiA9IFBTIHx8IDB4MDEgfHwgc2FsdDsgREIgaXMgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aFxuICAgICAqICAgIGVtTGVuIC0gaExlbiAtIDEuICovXG4gICAgcHMucHV0Qnl0ZSgweDAxKTtcbiAgICBwcy5wdXRCeXRlcyhzYWx0KTtcbiAgICB2YXIgZGIgPSBwcy5nZXRCeXRlcygpO1xuXG4gICAgLyogOS4gTGV0IGRiTWFzayA9IE1HRihILCBlbUxlbiAtIGhMZW4gLSAxKS4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIGRiTWFzayA9IG1nZi5nZW5lcmF0ZShoLCBtYXNrTGVuKTtcblxuICAgIC8qIDEwLiBMZXQgbWFza2VkREIgPSBEQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIG1hc2tlZERCID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBtYXNrZWREQiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRiLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogMTEuIFNldCB0aGUgbGVmdG1vc3QgOGVtTGVuIC0gZW1CaXRzIGJpdHMgb2YgdGhlIGxlZnRtb3N0IG9jdGV0IGluXG4gICAgICogICAgIG1hc2tlZERCIHRvIHplcm8uICovXG4gICAgdmFyIG1hc2sgPSAoMHhGRjAwID4+ICg4ICogZW1MZW4gLSBlbUJpdHMpKSAmIDB4RkY7XG4gICAgbWFza2VkREIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoMCkgJiB+bWFzaykgK1xuICAgICAgbWFza2VkREIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTIuIExldCBFTSA9IG1hc2tlZERCIHx8IEggfHwgMHhiYy5cbiAgICAgKiAxMy4gT3V0cHV0IEVNLiAqL1xuICAgIHJldHVybiBtYXNrZWREQiArIGggKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIFBTUyBzaWduYXR1cmUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBFTVNBLVBTUy1WRVJJRlkgYXMgcGVyIFJGQyAzNDQ3LCBzZWN0aW9uIDkuMS4yLlxuICAgKlxuICAgKiBAcGFyYW0gbUhhc2ggdGhlIG1lc3NhZ2UgZGlnZXN0IGhhc2gsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nLCB0b1xuICAgKiAgICAgICAgIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLlxuICAgKiBAcGFyYW0gZW0gdGhlIGVuY29kZWQgbWVzc2FnZSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICogICAgICAgICAgKFJTQSBkZWNyeXB0aW9uIHJlc3VsdCkuXG4gICAqIEBwYXJhbSBtb2RzQml0cyB0aGUgbGVuZ3RoIG9mIHRoZSBSU0EgbW9kdWx1cyBpbiBiaXRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHNpZ25hdHVyZSB3YXMgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIHBzc29iai52ZXJpZnkgPSBmdW5jdGlvbihtSGFzaCwgZW0sIG1vZEJpdHMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgZW1CaXRzID0gbW9kQml0cyAtIDE7XG4gICAgdmFyIGVtTGVuID0gTWF0aC5jZWlsKGVtQml0cyAvIDgpO1xuXG4gICAgLyogYy4gQ29udmVydCB0aGUgbWVzc2FnZSByZXByZXNlbnRhdGl2ZSBtIHRvIGFuIGVuY29kZWQgbWVzc2FnZSBFTVxuICAgICAqICAgIG9mIGxlbmd0aCBlbUxlbiA9IGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpIG9jdGV0cywgd2hlcmUgbW9kQml0c1xuICAgICAqICAgIGlzIHRoZSBsZW5ndGggaW4gYml0cyBvZiB0aGUgUlNBIG1vZHVsdXMgbiAqL1xuICAgIGVtID0gZW0uc3Vic3RyKC1lbUxlbik7XG5cbiAgICAvKiAzLiBJZiBlbUxlbiA8IGhMZW4gKyBzTGVuICsgMiwgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IHBhcmFtZXRlcnMgdG8gUFNTIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24uJyk7XG4gICAgfVxuXG4gICAgLyogNC4gSWYgdGhlIHJpZ2h0bW9zdCBvY3RldCBvZiBFTSBkb2VzIG5vdCBoYXZlIGhleGFkZWNpbWFsIHZhbHVlXG4gICAgICogICAgMHhiYywgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW0uY2hhckNvZGVBdChlbUxlbiAtIDEpICE9PSAweGJjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kZWQgbWVzc2FnZSBkb2VzIG5vdCBlbmQgaW4gMHhCQy4nKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgbWFza2VkREIgYmUgdGhlIGxlZnRtb3N0IGVtTGVuIC0gaExlbiAtIDEgb2N0ZXRzIG9mIEVNLCBhbmRcbiAgICAgKiAgICBsZXQgSCBiZSB0aGUgbmV4dCBoTGVuIG9jdGV0cy4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyKDAsIG1hc2tMZW4pO1xuICAgIHZhciBoID0gZW0uc3Vic3RyKG1hc2tMZW4sIGhMZW4pO1xuXG4gICAgLyogNi4gSWYgdGhlIGxlZnRtb3N0IDhlbUxlbiAtIGVtQml0cyBiaXRzIG9mIHRoZSBsZWZ0bW9zdCBvY3RldCBpblxuICAgICAqICAgIG1hc2tlZERCIGFyZSBub3QgYWxsIGVxdWFsIHRvIHplcm8sIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBtYXNrID0gKDB4RkYwMCA+PiAoOCAqIGVtTGVuIC0gZW1CaXRzKSkgJiAweEZGO1xuICAgIGlmKChtYXNrZWREQi5jaGFyQ29kZUF0KDApICYgbWFzaykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQml0cyBiZXlvbmQga2V5c2l6ZSBub3QgemVybyBhcyBleHBlY3RlZC4nKTtcbiAgICB9XG5cbiAgICAvKiA3LiBMZXQgZGJNYXNrID0gTUdGKEgsIGVtTGVuIC0gaExlbiAtIDEpLiAqL1xuICAgIHZhciBkYk1hc2sgPSBtZ2YuZ2VuZXJhdGUoaCwgbWFza0xlbik7XG5cbiAgICAvKiA4LiBMZXQgREIgPSBtYXNrZWREQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIGRiID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBkYiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogOS4gU2V0IHRoZSBsZWZ0bW9zdCA4ZW1MZW4gLSBlbUJpdHMgYml0cyBvZiB0aGUgbGVmdG1vc3Qgb2N0ZXRcbiAgICAgKiBpbiBEQiB0byB6ZXJvLiAqL1xuICAgIGRiID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYi5jaGFyQ29kZUF0KDApICYgfm1hc2spICsgZGIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTAuIElmIHRoZSBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMiBsZWZ0bW9zdCBvY3RldHMgb2YgREIgYXJlIG5vdCB6ZXJvXG4gICAgICogb3IgaWYgdGhlIG9jdGV0IGF0IHBvc2l0aW9uIGVtTGVuIC0gaExlbiAtIHNMZW4gLSAxICh0aGUgbGVmdG1vc3RcbiAgICAgKiBwb3NpdGlvbiBpcyBcInBvc2l0aW9uIDFcIikgZG9lcyBub3QgaGF2ZSBoZXhhZGVjaW1hbCB2YWx1ZSAweDAxLFxuICAgICAqIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBjaGVja0xlbiA9IGVtTGVuIC0gaExlbiAtIHNMZW4gLSAyO1xuICAgIGZvcihpID0gMDsgaSA8IGNoZWNrTGVuOyBpKyspIHtcbiAgICAgIGlmKGRiLmNoYXJDb2RlQXQoaSkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWZ0bW9zdCBvY3RldHMgbm90IHplcm8gYXMgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihkYi5jaGFyQ29kZUF0KGNoZWNrTGVuKSAhPT0gMHgwMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbnNpc3RlbnQgUFNTIHNpZ25hdHVyZSwgMHgwMSBtYXJrZXIgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgLyogMTEuIExldCBzYWx0IGJlIHRoZSBsYXN0IHNMZW4gb2N0ZXRzIG9mIERCLiAqL1xuICAgIHZhciBzYWx0ID0gZGIuc3Vic3RyKC1zTGVuKTtcblxuICAgIC8qIDEyLiAgTGV0IE0nID0gKDB4KTAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIHx8IG1IYXNoIHx8IHNhbHQgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDEzLiBMZXQgSCcgPSBIYXNoKE0nKSwgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aCBoTGVuLiAqL1xuICAgIGhhc2guc3RhcnQoKTtcbiAgICBoYXNoLnVwZGF0ZShtXy5nZXRCeXRlcygpKTtcbiAgICB2YXIgaF8gPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiAxNC4gSWYgSCA9IEgnLCBvdXRwdXQgXCJjb25zaXN0ZW50LlwiIE90aGVyd2lzZSwgb3V0cHV0IFwiaW5jb25zaXN0ZW50LlwiICovXG4gICAgcmV0dXJuIGggPT09IGhfO1xuICB9O1xuXG4gIHJldHVybiBwc3NvYmo7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBiYXNpYyBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAqIHN1cHBvcnQgZm9yIFJTQSBwdWJsaWMgYW5kIHByaXZhdGUga2V5cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbl9fd2VicGFja19yZXF1aXJlX18oOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbl9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKiBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIChQS0kpIGltcGxlbWVudGF0aW9uLiAqL1xudmFyIHBraSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQuIFVzZSBwZW0uZGVjb2RlKCkgaW5zdGVhZC5cbiAqXG4gKiBDb252ZXJ0cyBQRU0tZm9ybWF0dGVkIGRhdGEgdG8gREVSLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBERVItZm9ybWF0dGVkIGRhdGEuXG4gKi9cbnBraS5wZW1Ub0RlciA9IGZ1bmN0aW9uKHBlbSkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQRU0gdG8gREVSOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG4gIHJldHVybiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuYm9keSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwcml2YXRlIGtleSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwcml2YXRlIGtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiYgbXNnLnR5cGUgIT09ICdSU0EgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNICcgK1xuICAgICAgJ2hlYWRlciB0eXBlIGlzIG5vdCBcIlBSSVZBVEUgS0VZXCIgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG5cbiAgcmV0dXJuIHBraS5wcml2YXRlS2V5RnJvbUFzbjEob2JqKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHByaXZhdGUga2V5IHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleVRvUGVtID0gZnVuY3Rpb24oa2V5LCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5wcml2YXRlS2V5VG9Bc24xKGtleSkpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBraSB0aGUgUHJpdmF0ZUtleUluZm8uXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUluZm9Ub1BlbSA9IGZ1bmN0aW9uKHBraSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBCYXNlLU4vQmFzZS1YIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBmcm9tIGJhc2UteDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmFzZS14XG4gKlxuICogV2hpY2ggaXMgTUlUIGxpY2Vuc2VkOlxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCBiYXNlLXggY29udHJpYnV0b3JzIChjKSAyMDE2XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGJhc2VOIGFscGhhYmV0IGluZGV4ZXNcbnZhciBfcmV2ZXJzZUFscGhhYmV0cyA9IHt9O1xuXG4vKipcbiAqIEJhc2VOLWVuY29kZXMgYSBVaW50OEFycmF5IHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2VOLWVuY29kZWQgb3V0cHV0IHN0cmluZy5cbiAqL1xuYXBpLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCwgbWF4bGluZSkge1xuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYobWF4bGluZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBtYXhsaW5lICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibWF4bGluZVwiIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgaWYoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgLy8gYXNzdW1lIGZvcmdlIGJ5dGUgYnVmZmVyXG4gICAgb3V0cHV0ID0gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgICB2YXIgZGlnaXRzID0gWzBdO1xuICAgIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0W2ldOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIGJhc2U7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IoaSA9IDA7IGlucHV0W2ldID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG91dHB1dCArPSBmaXJzdDtcbiAgICB9XG4gICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gICAgfVxuICB9XG5cbiAgaWYobWF4bGluZSkge1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJy57MSwnICsgbWF4bGluZSArICd9JywgJ2cnKTtcbiAgICBvdXRwdXQgPSBvdXRwdXQubWF0Y2gocmVnZXgpLmpvaW4oJ1xcclxcbicpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2VOLWVuY29kZWQgKHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldCkgc3RyaW5nIHRvIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlTi1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5LlxuICovXG5hcGkuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIGFscGhhYmV0KSB7XG4gIGlmKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlucHV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF07XG4gIGlmKCF0YWJsZSkge1xuICAgIC8vIGNvbXB1dGUgcmV2ZXJzZSBhbHBoYWJldFxuICAgIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0YWJsZVthbHBoYWJldC5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgdmFyIGJ5dGVzID0gWzBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB0YWJsZVtpbnB1dC5jaGFyQ29kZUF0KGkpXTtcbiAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBieXRlc1tqXSAqIGJhc2U7XG4gICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgIGNhcnJ5ID4+PSA4O1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgY2FycnkgPj49IDg7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgZm9yKHZhciBrID0gMDsgaW5wdXRba10gPT09IGZpcnN0ICYmIGsgPCBpbnB1dC5sZW5ndGggLSAxOyArK2spIHtcbiAgICBieXRlcy5wdXNoKDApO1xuICB9XG5cbiAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpO1xufTtcblxuZnVuY3Rpb24gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCkge1xuICB2YXIgaSA9IDA7XG4gIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gIHZhciBkaWdpdHMgPSBbMF07XG4gIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCgpOyArK2kpIHtcbiAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0LmF0KGkpOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IoaSA9IDA7IGlucHV0LmF0KGkpID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGgoKSAtIDE7ICsraSkge1xuICAgIG91dHB1dCArPSBmaXJzdDtcbiAgfVxuICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIG91dHB1dCArPSBhbHBoYWJldFtkaWdpdHNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMjU2LWJpdCBkaWdlc3QgKFNIQS0yNTYpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFNlZSBGSVBTIDE4MC0yIGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgc2hhMjU2ID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGEyNTYgPSBmb3JnZS5zaGEyNTYgfHwge307XG5mb3JnZS5tZC5zaGEyNTYgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTI1NiA9IHNoYTI1NjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTI1NiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMjU2LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMjU2IHN0YXRlIGNvbnRhaW5zIGVpZ2h0IDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg2NCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICBkaWdlc3RMZW5ndGg6IDMyLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogOFxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoNjQgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDY0ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX3N0YXRlID0ge1xuICAgICAgaDA6IDB4NkEwOUU2NjcsXG4gICAgICBoMTogMHhCQjY3QUU4NSxcbiAgICAgIGgyOiAweDNDNkVGMzcyLFxuICAgICAgaDM6IDB4QTU0RkY1M0EsXG4gICAgICBoNDogMHg1MTBFNTI3RixcbiAgICAgIGg1OiAweDlCMDU2ODhDLFxuICAgICAgaDY6IDB4MUY4M0Q5QUIsXG4gICAgICBoNzogMHg1QkUwQ0QxOVxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtMjU2IHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDQsXG4gICAgICBoNTogX3N0YXRlLmg1LFxuICAgICAgaDY6IF9zdGF0ZS5oNixcbiAgICAgIGg3OiBfc3RhdGUuaDdcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNyk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTI1NiBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIHRhYmxlIG9mIGNvbnN0YW50c1xudmFyIF9rID0gbnVsbDtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gY3JlYXRlIEsgdGFibGUgZm9yIFNIQS0yNTZcbiAgX2sgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gICAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAgIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gICAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAgIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gICAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMl07XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS0yNTYgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0yNTYgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQxLCB0MiwgczAsIHMxLCBjaCwgbWFqLCBpLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gNjQgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMjU2XG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgd1tpXSA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgfVxuICAgIGZvcig7IGkgPCA2NDsgKytpKSB7XG4gICAgICAvLyBYT1Igd29yZCAyIHdvcmRzIGFnbyByb3QgcmlnaHQgMTcsIHJvdCByaWdodCAxOSwgc2hmdCByaWdodCAxMFxuICAgICAgdDEgPSB3W2kgLSAyXTtcbiAgICAgIHQxID1cbiAgICAgICAgKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXlxuICAgICAgICAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeXG4gICAgICAgICh0MSA+Pj4gMTApO1xuICAgICAgLy8gWE9SIHdvcmQgMTUgd29yZHMgYWdvIHJvdCByaWdodCA3LCByb3QgcmlnaHQgMTgsIHNoZnQgcmlnaHQgM1xuICAgICAgdDIgPSB3W2kgLSAxNV07XG4gICAgICB0MiA9XG4gICAgICAgICgodDIgPj4+IDcpIHwgKHQyIDw8IDI1KSkgXlxuICAgICAgICAoKHQyID4+PiAxOCkgfCAodDIgPDwgMTQpKSBeXG4gICAgICAgICh0MiA+Pj4gMyk7XG4gICAgICAvLyBzdW0odDEsIHdvcmQgNyBhZ28sIHQyLCB3b3JkIDE2IGFnbykgbW9kdWxvIDJeMzJcbiAgICAgIHdbaV0gPSAodDEgKyB3W2kgLSA3XSArIHQyICsgd1tpIC0gMTZdKSB8IDA7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG4gICAgZiA9IHMuaDU7XG4gICAgZyA9IHMuaDY7XG4gICAgaCA9IHMuaDc7XG5cbiAgICAvLyByb3VuZCBmdW5jdGlvblxuICAgIGZvcihpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIC8vIFN1bTEoZSlcbiAgICAgIHMxID1cbiAgICAgICAgKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXlxuICAgICAgICAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXlxuICAgICAgICAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgIC8vIENoKGUsIGYsIGcpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgY2ggPSBnIF4gKGUgJiAoZiBeIGcpKTtcbiAgICAgIC8vIFN1bTAoYSlcbiAgICAgIHMwID1cbiAgICAgICAgKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXlxuICAgICAgICAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXlxuICAgICAgICAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAvLyBNYWooYSwgYiwgYykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBtYWogPSAoYSAmIGIpIHwgKGMgJiAoYSBeIGIpKTtcblxuICAgICAgLy8gbWFpbiBhbGdvcml0aG1cbiAgICAgIHQxID0gaCArIHMxICsgY2ggKyBfa1tpXSArIHdbaV07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgaCA9IGc7XG4gICAgICBnID0gZjtcbiAgICAgIGYgPSBlO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICAvLyBjYW4ndCB0cnVuY2F0ZSB3aXRoIGB8IDBgXG4gICAgICBlID0gKGQgKyB0MSkgPj4+IDA7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiA9IGE7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIC8vIGNhbid0IHRydW5jYXRlIHdpdGggYHwgMGBcbiAgICAgIGEgPSAodDEgKyB0MikgPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuICAgIHMuaDUgPSAocy5oNSArIGYpIHwgMDtcbiAgICBzLmg2ID0gKHMuaDYgKyBnKSB8IDA7XG4gICAgcy5oNyA9IChzLmg3ICsgaCkgfCAwO1xuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmVcbiAqIFBzZXVkbyBSYW5kb20gTnVtYmVyIEdlbmVyYXRvciAoUFJORykuIFRoZSBGb3J0dW5hIGFsZ29yaXRobSBpcyBmb2xsb3dlZFxuICogaGVyZSB0aG91Z2ggdGhlIHVzZSBvZiBTSEEtMjU2IGlzIG5vdCBlbmZvcmNlZDsgd2hlbiBnZW5lcmF0aW5nIGFuXG4gKiBhIFBSTkcgY29udGV4dCwgdGhlIGhhc2hpbmcgYWxnb3JpdGhtIGFuZCBibG9jayBjaXBoZXIgdXNlZCBmb3JcbiAqIHRoZSBnZW5lcmF0b3IgYXJlIHNwZWNpZmllZCB2aWEgYSBwbHVnaW4uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcnlwdG8gPSBudWxsO1xuaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXSkge1xuICBfY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG59XG5cbi8qIFBSTkcgQVBJICovXG52YXIgcHJuZyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJuZyA9IGZvcmdlLnBybmcgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HIGNvbnRleHQuXG4gKlxuICogQSBQUk5HIHBsdWdpbiBtdXN0IGJlIHBhc3NlZCBpbiB0aGF0IHdpbGwgcHJvdmlkZTpcbiAqXG4gKiAxLiBBIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGtleSBhbmQgc2VlZCBvZiBhIFBSTkcgY29udGV4dC4gSXRcbiAqICAgd2lsbCBiZSBnaXZlbiBhIDE2IGJ5dGUga2V5IGFuZCBhIDE2IGJ5dGUgc2VlZC4gQW55IGtleSBleHBhbnNpb25cbiAqICAgb3IgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHNlZWQgZnJvbSBhIGJ5dGUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2ZcbiAqICAgaW50ZWdlcnMgKG9yIHNpbWlsYXIpIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gKiAyLiBUaGUgY3J5cHRvZ3JhcGhpYyBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBnZW5lcmF0b3IuIEl0IHRha2VzIGEga2V5IGFuZFxuICogICBhIHNlZWQuXG4gKiAzLiBBIHNlZWQgaW5jcmVtZW50IGZ1bmN0aW9uLiBJdCB0YWtlcyB0aGUgc2VlZCBhbmQgcmV0dXJucyBzZWVkICsgMS5cbiAqIDQuIEFuIGFwaSB0byBjcmVhdGUgYSBtZXNzYWdlIGRpZ2VzdC5cbiAqXG4gKiBGb3IgYW4gZXhhbXBsZSwgc2VlIHJhbmRvbS5qcy5cbiAqXG4gKiBAcGFyYW0gcGx1Z2luIHRoZSBQUk5HIHBsdWdpbiB0byB1c2UuXG4gKi9cbnBybmcuY3JlYXRlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gIHZhciBjdHggPSB7XG4gICAgcGx1Z2luOiBwbHVnaW4sXG4gICAga2V5OiBudWxsLFxuICAgIHNlZWQ6IG51bGwsXG4gICAgdGltZTogbnVsbCxcbiAgICAvLyBudW1iZXIgb2YgcmVzZWVkcyBzbyBmYXJcbiAgICByZXNlZWRzOiAwLFxuICAgIC8vIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBzbyBmYXJcbiAgICBnZW5lcmF0ZWQ6IDAsXG4gICAgLy8gbm8gaW5pdGlhbCBrZXkgYnl0ZXNcbiAgICBrZXlCeXRlczogJydcbiAgfTtcblxuICAvLyBjcmVhdGUgMzIgZW50cm9weSBwb29scyAoZWFjaCBpcyBhIG1lc3NhZ2UgZGlnZXN0KVxuICB2YXIgbWQgPSBwbHVnaW4ubWQ7XG4gIHZhciBwb29scyA9IG5ldyBBcnJheSgzMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgcG9vbHNbaV0gPSBtZC5jcmVhdGUoKTtcbiAgfVxuICBjdHgucG9vbHMgPSBwb29scztcblxuICAvLyBlbnRyb3B5IHBvb2xzIGFyZSB3cml0dGVuIHRvIGN5Y2xpY2FsbHksIHN0YXJ0aW5nIGF0IGluZGV4IDBcbiAgY3R4LnBvb2wgPSAwO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmFuZG9tIGJ5dGVzLiBUaGUgYnl0ZXMgbWF5IGJlIGdlbmVyYXRlZCBzeW5jaHJvbm91c2x5IG9yXG4gICAqIGFzeW5jaHJvbm91c2x5LiBXZWIgd29ya2VycyBtdXN0IHVzZSB0aGUgYXN5bmNocm9ub3VzIGludGVyZmFjZSBvclxuICAgKiBlbHNlIHRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGJ5dGVzKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4gY291bnQgcmFuZG9tIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdlbmVyYXRlID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgLy8gZG8gc3luY2hyb25vdXNseVxuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGN0eC5nZW5lcmF0ZVN5bmMoY291bnQpO1xuICAgIH1cblxuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHJlc2V0IGtleSBmb3IgZXZlcnkgcmVxdWVzdCB0byBwcm90ZWN0IHByZXZpb3VzbHlcbiAgICAvLyBnZW5lcmF0ZWQgcmFuZG9tIGJ5dGVzIHNob3VsZCB0aGUga2V5IGJlIGRpc2NvdmVyZWQ7XG4gICAgLy8gdGhlcmUgaXMgbm8gMTAwbXMgYmFzZWQgcmVzZWVkaW5nIGJlY2F1c2Ugb2YgdGhpc1xuICAgIC8vIGZvcmNlZCByZXNlZWQgZm9yIGV2ZXJ5IGBnZW5lcmF0ZWAgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgZ2VuZXJhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGVycikge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdWZmaWNpZW50IGJ5dGVzIGdlbmVyYXRlZFxuICAgICAgaWYoYi5sZW5ndGgoKSA+PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYi5nZXRCeXRlcyhjb3VudCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbW91bnQgb2YgZGF0YSBnZW5lcmF0ZWQgaXMgZ3JlYXRlciB0aGFuIDEgTWlCLCB0cmlnZ2VyIHJlc2VlZFxuICAgICAgaWYoY3R4LmdlbmVyYXRlZCA+IDB4ZmZmZmYpIHtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcHJldmVudCBzdGFjayBvdmVyZmxvd1xuICAgICAgICByZXR1cm4gZm9yZ2UudXRpbC5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVzZWVkKGdlbmVyYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG5cbiAgICAgIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGdlbmVyYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZXMgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIGNvdW50IHJhbmRvbSBieXRlcyBhcyBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZW5lcmF0ZVN5bmMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gcmVzZXQga2V5IGZvciBldmVyeSByZXF1ZXN0IHRvIHByb3RlY3QgcHJldmlvdXNseVxuICAgIC8vIGdlbmVyYXRlZCByYW5kb20gYnl0ZXMgc2hvdWxkIHRoZSBrZXkgYmUgZGlzY292ZXJlZDtcbiAgICAvLyB0aGVyZSBpcyBubyAxMDBtcyBiYXNlZCByZXNlZWRpbmcgYmVjYXVzZSBvZiB0aGlzXG4gICAgLy8gZm9yY2VkIHJlc2VlZCBmb3IgZXZlcnkgYGdlbmVyYXRlU3luY2AgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHdoaWxlKGIubGVuZ3RoKCkgPCBjb3VudCkge1xuICAgICAgLy8gaWYgYW1vdW50IG9mIGRhdGEgZ2VuZXJhdGVkIGlzIGdyZWF0ZXIgdGhhbiAxIE1pQiwgdHJpZ2dlciByZXNlZWRcbiAgICAgIGlmKGN0eC5nZW5lcmF0ZWQgPiAweGZmZmZmKSB7XG4gICAgICAgIGN0eC5rZXkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZihjdHgua2V5ID09PSBudWxsKSB7XG4gICAgICAgIF9yZXNlZWRTeW5jKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMoY291bnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrKGVycikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzZWVkKGNhbGxiYWNrKSB7XG4gICAgaWYoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgIF9zZWVkKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LnNlZWRGaWxlKG5lZWRlZCwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICAgICAgX3NlZWQoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNlZWRTeW5jKCkge1xuICAgIGlmKGN0eC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoID49IDMyKSB7XG4gICAgICByZXR1cm4gX3NlZWQoKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LmNvbGxlY3QoY3R4LnNlZWRGaWxlU3luYyhuZWVkZWQpKTtcbiAgICBfc2VlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBzZWVkcyBhIGdlbmVyYXRvciBvbmNlIGVub3VnaCBieXRlcyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3NlZWQoKSB7XG4gICAgLy8gdXBkYXRlIHJlc2VlZCBjb3VudFxuICAgIGN0eC5yZXNlZWRzID0gKGN0eC5yZXNlZWRzID09PSAweGZmZmZmZmZmKSA/IDAgOiBjdHgucmVzZWVkcyArIDE7XG5cbiAgICAvLyBnb2FsIGlzIHRvIHVwZGF0ZSBga2V5YCB2aWE6XG4gICAgLy8ga2V5ID0gaGFzaChrZXkgKyBzKVxuICAgIC8vICAgd2hlcmUgJ3MnIGlzIGFsbCBjb2xsZWN0ZWQgZW50cm9weSBmcm9tIHNlbGVjdGVkIHBvb2xzLCB0aGVuLi4uXG5cbiAgICAvLyBjcmVhdGUgYSBwbHVnaW4tYmFzZWQgbWVzc2FnZSBkaWdlc3RcbiAgICB2YXIgbWQgPSBjdHgucGx1Z2luLm1kLmNyZWF0ZSgpO1xuXG4gICAgLy8gY29uc3VtZSBjdXJyZW50IGtleSBieXRlc1xuICAgIG1kLnVwZGF0ZShjdHgua2V5Qnl0ZXMpO1xuXG4gICAgLy8gZGlnZXN0IHRoZSBlbnRyb3B5IG9mIHBvb2xzIHdob3NlIGluZGV4IGsgbWVldCB0aGVcbiAgICAvLyBjb25kaXRpb24gJ24gbW9kIDJeayA9PSAwJyB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcmVzZWVkc1xuICAgIHZhciBfMnBvd0sgPSAxO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCAzMjsgKytrKSB7XG4gICAgICBpZihjdHgucmVzZWVkcyAlIF8ycG93SyA9PT0gMCkge1xuICAgICAgICBtZC51cGRhdGUoY3R4LnBvb2xzW2tdLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICAgICAgICBjdHgucG9vbHNba10uc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIF8ycG93SyA9IF8ycG93SyA8PCAxO1xuICAgIH1cblxuICAgIC8vIGdldCBkaWdlc3QgZm9yIGtleSBieXRlc1xuICAgIGN0eC5rZXlCeXRlcyA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHVwZGF0ZSBgc2VlZGAgdmlhIGBzZWVkID0gaGFzaChrZXkpYFxuICAgIC8vIGluc3RlYWQgb2YgaW5pdGlhbGl6aW5nIHRvIHplcm8gb25jZSBhbmQgb25seVxuICAgIC8vIGV2ZXIgaW5jcmVtZW50aW5nIGl0XG4gICAgbWQuc3RhcnQoKTtcbiAgICBtZC51cGRhdGUoY3R4LmtleUJ5dGVzKTtcbiAgICB2YXIgc2VlZEJ5dGVzID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIHVwZGF0ZSBzdGF0ZVxuICAgIGN0eC5rZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleShjdHgua2V5Qnl0ZXMpO1xuICAgIGN0eC5zZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkKHNlZWRCeXRlcyk7XG4gICAgY3R4LmdlbmVyYXRlZCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgc2VlZEZpbGUuIFRoaXMgc2VlZEZpbGUgaXMgdXNlZCB3aGVuIGVudHJvcHlcbiAgICogaXMgbmVlZGVkIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gbmVlZGVkIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0U2VlZEZpbGUobmVlZGVkKSB7XG4gICAgLy8gdXNlIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHN0cm9uZyBzb3VyY2Ugb2YgZW50cm9weSBpZiBhdmFpbGFibGVcbiAgICB2YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbiAgICBpZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIF9jcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcbiAgICAgIGlmKF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGlmKGdldFJhbmRvbVZhbHVlcykge1xuICAgICAgd2hpbGUoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgICAvLyBtYXggYnl0ZSBsZW5ndGggaXMgNjU1MzYgYmVmb3JlIFF1b3RhRXhjZWVkZWRFcnJvciBpcyB0aHJvd25cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLyNSYW5kb21Tb3VyY2UtbWV0aG9kLWdldFJhbmRvbVZhbHVlc1xuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihuZWVkZWQgLSBiLmxlbmd0aCgpLCA2NTUzNikgLyA0KTtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5mbG9vcihjb3VudCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdldFJhbmRvbVZhbHVlcyhlbnRyb3B5KTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYi5wdXRJbnQzMihlbnRyb3B5W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8qIG9ubHkgaWdub3JlIFF1b3RhRXhjZWVkZWRFcnJvciAqL1xuICAgICAgICAgIGlmKCEodHlwZW9mIFF1b3RhRXhjZWVkZWRFcnJvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBRdW90YUV4Y2VlZGVkRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJlIHNhZCBhbmQgYWRkIHNvbWUgd2VhayByYW5kb20gZGF0YVxuICAgIGlmKGIubGVuZ3RoKCkgPCBuZWVkZWQpIHtcbiAgICAgIC8qIERyYXdzIGZyb20gUGFyay1NaWxsZXIgXCJtaW5pbWFsIHN0YW5kYXJkXCIgMzEgYml0IFBSTkcsXG4gICAgICBpbXBsZW1lbnRlZCB3aXRoIERhdmlkIEcuIENhcnRhJ3Mgb3B0aW1pemF0aW9uOiB3aXRoIDMyIGJpdCBtYXRoXG4gICAgICBhbmQgd2l0aG91dCBkaXZpc2lvbiAoUHVibGljIERvbWFpbikuICovXG4gICAgICB2YXIgaGksIGxvLCBuZXh0O1xuICAgICAgdmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDAwMCk7XG4gICAgICB3aGlsZShiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgIGxvID0gMTY4MDcgKiAoc2VlZCAmIDB4RkZGRik7XG4gICAgICAgIGhpID0gMTY4MDcgKiAoc2VlZCA+PiAxNik7XG4gICAgICAgIGxvICs9IChoaSAmIDB4N0ZGRikgPDwgMTY7XG4gICAgICAgIGxvICs9IGhpID4+IDE1O1xuICAgICAgICBsbyA9IChsbyAmIDB4N0ZGRkZGRkYpICsgKGxvID4+IDMxKTtcbiAgICAgICAgc2VlZCA9IGxvICYgMHhGRkZGRkZGRjtcblxuICAgICAgICAvLyBjb25zdW1lIGxvd2VyIDMgYnl0ZXMgb2Ygc2VlZFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgLy8gdGhyb3cgaW4gbW9yZSBwc2V1ZG8gcmFuZG9tXG4gICAgICAgICAgbmV4dCA9IHNlZWQgPj4+IChpIDw8IDMpO1xuICAgICAgICAgIG5leHQgXj0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgwMTAwKTtcbiAgICAgICAgICBiLnB1dEJ5dGUoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0ICYgMHhGRikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMobmVlZGVkKTtcbiAgfVxuICAvLyBpbml0aWFsaXplIHNlZWQgZmlsZSBBUElzXG4gIGlmKF9jcnlwdG8pIHtcbiAgICAvLyB1c2Ugbm9kZWpzIGFzeW5jIEFQSVxuICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzLnRvU3RyaW5nKCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1c2Ugbm9kZWpzIHN5bmMgQVBJXG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGZ1bmN0aW9uKG5lZWRlZCkge1xuICAgICAgcmV0dXJuIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkKS50b1N0cmluZygpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNlZWRGaWxlID0gZnVuY3Rpb24obmVlZGVkLCBjYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGVmYXVsdFNlZWRGaWxlKG5lZWRlZCkpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGRlZmF1bHRTZWVkRmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGVudHJvcHkgdG8gYSBwcm5nIGN0eCdzIGFjY3VtdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIG9mIGVudHJvcHkgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjdHguY29sbGVjdCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBvb2xzIGRpc3RyaWJ1dGluZyBlbnRyb3B5IGN5Y2xpY2FsbHlcbiAgICB2YXIgY291bnQgPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGN0eC5wb29sc1tjdHgucG9vbF0udXBkYXRlKGJ5dGVzLnN1YnN0cihpLCAxKSk7XG4gICAgICBjdHgucG9vbCA9IChjdHgucG9vbCA9PT0gMzEpID8gMCA6IGN0eC5wb29sICsgMTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbGxlY3RzIGFuIGludGVnZXIgb2YgbiBiaXRzLlxuICAgKlxuICAgKiBAcGFyYW0gaSB0aGUgaW50ZWdlciBlbnRyb3B5LlxuICAgKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gICAqL1xuICBjdHguY29sbGVjdEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgICB2YXIgYnl0ZXMgPSAnJztcbiAgICBmb3IodmFyIHggPSAwOyB4IDwgbjsgeCArPSA4KSB7XG4gICAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IHgpICYgMHhGRik7XG4gICAgfVxuICAgIGN0eC5jb2xsZWN0KGJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgV2ViIFdvcmtlciB0byByZWNlaXZlIGltbWVkaWF0ZSBlbnRyb3B5IGZyb20gdGhlIG1haW4gdGhyZWFkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB1bnRpbCBXZWIgV29ya2VycyBjYW4gYWNjZXNzIHRoZSBuYXRpdmUgY3J5cHRvXG4gICAqIEFQSS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0d2ljZSBmb3IgZWFjaCBjcmVhdGVkIHdvcmtlciwgb25jZSBpblxuICAgKiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBvbmNlIGluIHRoZSB3b3JrZXIgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gd29ya2VyIHRoZSB3b3JrZXIgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBjdHgucmVnaXN0ZXJXb3JrZXIgPSBmdW5jdGlvbih3b3JrZXIpIHtcbiAgICAvLyB3b3JrZXIgcmVjZWl2ZXMgcmFuZG9tIGJ5dGVzXG4gICAgaWYod29ya2VyID09PSBzZWxmKSB7XG4gICAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YS5mb3JnZS5wcm5nLmVyciwgZGF0YS5mb3JnZS5wcm5nLmJ5dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtmb3JnZToge3Bybmc6IHtuZWVkZWQ6IG5lZWRlZH19fSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWluIHRocmVhZCBzZW5kcyByYW5kb20gYnl0ZXMgdXBvbiByZXF1ZXN0XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgIGN0eC5zZWVkRmlsZShkYXRhLmZvcmdlLnBybmcubmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe2ZvcmdlOiB7cHJuZzoge2VycjogZXJyLCBieXRlczogYnl0ZXN9fX0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhlIHdvcmtlciBkaWVzP1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjdHg7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBSQzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBJbmZvcm1hdGlvbiBvbiB0aGUgUkMyIGNpcGhlciBpcyBhdmFpbGFibGUgZnJvbSBSRkMgIzIyNjgsXG4gKiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjY4LnR4dFxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHBpVGFibGUgPSBbXG4gIDB4ZDksIDB4NzgsIDB4ZjksIDB4YzQsIDB4MTksIDB4ZGQsIDB4YjUsIDB4ZWQsIDB4MjgsIDB4ZTksIDB4ZmQsIDB4NzksIDB4NGEsIDB4YTAsIDB4ZDgsIDB4OWQsXG4gIDB4YzYsIDB4N2UsIDB4MzcsIDB4ODMsIDB4MmIsIDB4NzYsIDB4NTMsIDB4OGUsIDB4NjIsIDB4NGMsIDB4NjQsIDB4ODgsIDB4NDQsIDB4OGIsIDB4ZmIsIDB4YTIsXG4gIDB4MTcsIDB4OWEsIDB4NTksIDB4ZjUsIDB4ODcsIDB4YjMsIDB4NGYsIDB4MTMsIDB4NjEsIDB4NDUsIDB4NmQsIDB4OGQsIDB4MDksIDB4ODEsIDB4N2QsIDB4MzIsXG4gIDB4YmQsIDB4OGYsIDB4NDAsIDB4ZWIsIDB4ODYsIDB4YjcsIDB4N2IsIDB4MGIsIDB4ZjAsIDB4OTUsIDB4MjEsIDB4MjIsIDB4NWMsIDB4NmIsIDB4NGUsIDB4ODIsXG4gIDB4NTQsIDB4ZDYsIDB4NjUsIDB4OTMsIDB4Y2UsIDB4NjAsIDB4YjIsIDB4MWMsIDB4NzMsIDB4NTYsIDB4YzAsIDB4MTQsIDB4YTcsIDB4OGMsIDB4ZjEsIDB4ZGMsXG4gIDB4MTIsIDB4NzUsIDB4Y2EsIDB4MWYsIDB4M2IsIDB4YmUsIDB4ZTQsIDB4ZDEsIDB4NDIsIDB4M2QsIDB4ZDQsIDB4MzAsIDB4YTMsIDB4M2MsIDB4YjYsIDB4MjYsXG4gIDB4NmYsIDB4YmYsIDB4MGUsIDB4ZGEsIDB4NDYsIDB4NjksIDB4MDcsIDB4NTcsIDB4MjcsIDB4ZjIsIDB4MWQsIDB4OWIsIDB4YmMsIDB4OTQsIDB4NDMsIDB4MDMsXG4gIDB4ZjgsIDB4MTEsIDB4YzcsIDB4ZjYsIDB4OTAsIDB4ZWYsIDB4M2UsIDB4ZTcsIDB4MDYsIDB4YzMsIDB4ZDUsIDB4MmYsIDB4YzgsIDB4NjYsIDB4MWUsIDB4ZDcsXG4gIDB4MDgsIDB4ZTgsIDB4ZWEsIDB4ZGUsIDB4ODAsIDB4NTIsIDB4ZWUsIDB4ZjcsIDB4ODQsIDB4YWEsIDB4NzIsIDB4YWMsIDB4MzUsIDB4NGQsIDB4NmEsIDB4MmEsXG4gIDB4OTYsIDB4MWEsIDB4ZDIsIDB4NzEsIDB4NWEsIDB4MTUsIDB4NDksIDB4NzQsIDB4NGIsIDB4OWYsIDB4ZDAsIDB4NWUsIDB4MDQsIDB4MTgsIDB4YTQsIDB4ZWMsXG4gIDB4YzIsIDB4ZTAsIDB4NDEsIDB4NmUsIDB4MGYsIDB4NTEsIDB4Y2IsIDB4Y2MsIDB4MjQsIDB4OTEsIDB4YWYsIDB4NTAsIDB4YTEsIDB4ZjQsIDB4NzAsIDB4MzksXG4gIDB4OTksIDB4N2MsIDB4M2EsIDB4ODUsIDB4MjMsIDB4YjgsIDB4YjQsIDB4N2EsIDB4ZmMsIDB4MDIsIDB4MzYsIDB4NWIsIDB4MjUsIDB4NTUsIDB4OTcsIDB4MzEsXG4gIDB4MmQsIDB4NWQsIDB4ZmEsIDB4OTgsIDB4ZTMsIDB4OGEsIDB4OTIsIDB4YWUsIDB4MDUsIDB4ZGYsIDB4MjksIDB4MTAsIDB4NjcsIDB4NmMsIDB4YmEsIDB4YzksXG4gIDB4ZDMsIDB4MDAsIDB4ZTYsIDB4Y2YsIDB4ZTEsIDB4OWUsIDB4YTgsIDB4MmMsIDB4NjMsIDB4MTYsIDB4MDEsIDB4M2YsIDB4NTgsIDB4ZTIsIDB4ODksIDB4YTksXG4gIDB4MGQsIDB4MzgsIDB4MzQsIDB4MWIsIDB4YWIsIDB4MzMsIDB4ZmYsIDB4YjAsIDB4YmIsIDB4NDgsIDB4MGMsIDB4NWYsIDB4YjksIDB4YjEsIDB4Y2QsIDB4MmUsXG4gIDB4YzUsIDB4ZjMsIDB4ZGIsIDB4NDcsIDB4ZTUsIDB4YTUsIDB4OWMsIDB4NzcsIDB4MGEsIDB4YTYsIDB4MjAsIDB4NjgsIDB4ZmUsIDB4N2YsIDB4YzEsIDB4YWRcbl07XG5cbnZhciBzID0gWzEsIDIsIDMsIDVdO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHdvcmQgbGVmdCBieSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBCaXRzIHRoYXQgYXJlIHNoaWZ0ZWQgb3V0IG9uIHRoZSBsZWZ0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgcmlnaHRcbiAqIGhhbmQgc2lkZS5cbiAqXG4gKiBAcGFyYW0gd29yZCBUaGUgd29yZCB0byBzaGlmdCBsZWZ0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9sID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkIDw8IGJpdHMpICYgMHhmZmZmKSB8ICgod29yZCAmIDB4ZmZmZikgPj4gKDE2IC0gYml0cykpO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB3b3JkIHJpZ2h0IGJ5IGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIEJpdHMgdGhhdCBhcmUgc2hpZnRlZCBvdXQgb24gdGhlIHJpZ2h0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgbGVmdFxuICogaGFuZCBzaWRlLlxuICpcbiAqIEBwYXJhbSB3b3JkIFRoZSB3b3JkIHRvIHNoaWZ0IHJpZ2h0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9yID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkICYgMHhmZmZmKSA+PiBiaXRzKSB8ICgod29yZCA8PCAoMTYgLSBiaXRzKSkgJiAweGZmZmYpO1xufTtcblxuLyogUkMyIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYzIgPSBmb3JnZS5yYzIgfHwge307XG5cbi8qKlxuICogUGVyZm9ybSBSQzIga2V5IGV4cGFuc2lvbiBhcyBwZXIgUkZDICMyMjY4LCBzZWN0aW9uIDIuXG4gKlxuICogQHBhcmFtIGtleSB2YXJpYWJsZS1sZW5ndGggdXNlciBrZXkgKGJldHdlZW4gMSBhbmQgMTI4IGJ5dGVzKVxuICogQHBhcmFtIGVmZktleUJpdHMgbnVtYmVyIG9mIGVmZmVjdGl2ZSBrZXkgYml0cyAoZGVmYXVsdDogMTI4KVxuICogQHJldHVybiB0aGUgZXhwYW5kZWQgUkMyIGtleSAoQnl0ZUJ1ZmZlciBvZiAxMjggYnl0ZXMpXG4gKi9cbmZvcmdlLnJjMi5leHBhbmRLZXkgPSBmdW5jdGlvbihrZXksIGVmZktleUJpdHMpIHtcbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9XG4gIGVmZktleUJpdHMgPSBlZmZLZXlCaXRzIHx8IDEyODtcblxuICAvKiBpbnRyb2R1Y2UgdmFyaWFibGVzIHRoYXQgbWF0Y2ggdGhlIG5hbWVzIHVzZWQgaW4gUkZDICMyMjY4ICovXG4gIHZhciBMID0ga2V5O1xuICB2YXIgVCA9IGtleS5sZW5ndGgoKTtcbiAgdmFyIFQxID0gZWZmS2V5Qml0cztcbiAgdmFyIFQ4ID0gTWF0aC5jZWlsKFQxIC8gOCk7XG4gIHZhciBUTSA9IDB4ZmYgPj4gKFQxICYgMHgwNyk7XG4gIHZhciBpO1xuXG4gIGZvcihpID0gVDsgaSA8IDEyODsgaSsrKSB7XG4gICAgTC5wdXRCeXRlKHBpVGFibGVbKEwuYXQoaSAtIDEpICsgTC5hdChpIC0gVCkpICYgMHhmZl0pO1xuICB9XG5cbiAgTC5zZXRBdCgxMjggLSBUOCwgcGlUYWJsZVtMLmF0KDEyOCAtIFQ4KSAmIFRNXSk7XG5cbiAgZm9yKGkgPSAxMjcgLSBUODsgaSA+PSAwOyBpLS0pIHtcbiAgICBMLnNldEF0KGksIHBpVGFibGVbTC5hdChpICsgMSkgXiBMLmF0KGkgKyBUOCldKTtcbiAgfVxuXG4gIHJldHVybiBMO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUkMyIGNpcGhlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKGFzIGJhc2UgZm9yIGtleSBnZW5lcmF0aW9uKS5cbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgZWZmZWN0aXZlIGtleSBiaXRzLlxuICogQHBhcmFtIGVuY3J5cHQgZmFsc2UgZm9yIGRlY3J5cHRpb24sIHRydWUgZm9yIGVuY3J5cHRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG52YXIgY3JlYXRlQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzLCBlbmNyeXB0KSB7XG4gIHZhciBfZmluaXNoID0gZmFsc2UsIF9pbnB1dCA9IG51bGwsIF9vdXRwdXQgPSBudWxsLCBfaXYgPSBudWxsO1xuICB2YXIgbWl4Um91bmQsIG1hc2hSb3VuZDtcbiAgdmFyIGksIGosIEsgPSBbXTtcblxuICAvKiBFeHBhbmQga2V5IGFuZCBmaWxsIGludG8gS1tdIEFycmF5ICovXG4gIGtleSA9IGZvcmdlLnJjMi5leHBhbmRLZXkoa2V5LCBiaXRzKTtcbiAgZm9yKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIEsucHVzaChrZXkuZ2V0SW50MTZMZSgpKTtcbiAgfVxuXG4gIGlmKGVuY3J5cHQpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtaXhpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1peGluZyBvbi5cbiAgICAgKi9cbiAgICBtaXhSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgUltpXSA9IHJvbChSW2ldLCBzW2ldKTtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtYXNoaW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtYXNoaW5nIG9uLlxuICAgICAqL1xuICAgIG1hc2hSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1peGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWl4aW5nIG9uLlxuICAgICAqL1xuICAgIG1peFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldID0gcm9yKFJbaV0sIHNbaV0pO1xuICAgICAgICBSW2ldIC09IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1hc2hpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1hc2hpbmcgb24uXG4gICAgICovXG4gICAgbWFzaFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldIC09IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhlIHNwZWNpZmllZCBjaXBoZXIgZXhlY3V0aW9uIHBsYW4uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgZm91ciB3b3JkcyBmcm9tIHRoZSBpbnB1dCBidWZmZXIsIGFwcGxpZXMgdGhlIElWIG9uXG4gICAqIGl0IChpZiByZXF1ZXN0ZWQpIGFuZCBydW5zIHRoZSBwcm92aWRlZCBleGVjdXRpb24gcGxhbi5cbiAgICpcbiAgICogVGhlIHBsYW4gbXVzdCBiZSBwdXQgdG9nZXRoZXIgaW4gZm9ybSBvZiBhIGFycmF5IG9mIGFycmF5cy4gIFdoZXJlIHRoZVxuICAgKiBvdXRlciBvbmUgaXMgc2ltcGx5IGEgbGlzdCBvZiBzdGVwcyB0byBwZXJmb3JtIGFuZCB0aGUgaW5uZXIgb25lIG5lZWRzXG4gICAqIHRvIGhhdmUgdHdvIGVsZW1lbnRzOiB0aGUgZmlyc3Qgb25lIHRlbGxpbmcgaG93IG1hbnkgcm91bmRzIHRvIHBlcmZvcm0sXG4gICAqIHRoZSBzZWNvbmQgb25lIHRlbGxpbmcgd2hhdCB0byBkbyAoaS5lLiB0aGUgZnVuY3Rpb24gdG8gY2FsbCkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBsYW4gVGhlIHBsYW4gdG8gZXhlY3V0ZS5cbiAgICovXG4gIHZhciBydW5QbGFuID0gZnVuY3Rpb24ocGxhbikge1xuICAgIHZhciBSID0gW107XG5cbiAgICAvKiBHZXQgZGF0YSBmcm9tIGlucHV0IGJ1ZmZlciBhbmQgZmlsbCB0aGUgZm91ciB3b3JkcyBpbnRvIFIgKi9cbiAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSBfaW5wdXQuZ2V0SW50MTZMZSgpO1xuXG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcsIGFwcGx5IHRoZSBJViBmaXJzdC4gKi9cbiAgICAgICAgICB2YWwgXj0gX2l2LmdldEludDE2TGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBXZSdyZSBkZWNyeXB0aW9uLCBrZWVwIGNpcGhlciB0ZXh0IGZvciBuZXh0IGJsb2NrLiAqL1xuICAgICAgICAgIF9pdi5wdXRJbnQxNkxlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUi5wdXNoKHZhbCAmIDB4ZmZmZik7XG4gICAgfVxuXG4gICAgLyogUmVzZXQgZ2xvYmFsIFwialwiIHZhcmlhYmxlIGFzIHBlciBzcGVjLiAqL1xuICAgIGogPSBlbmNyeXB0ID8gMCA6IDYzO1xuXG4gICAgLyogUnVuIGV4ZWN1dGlvbiBwbGFuLiAqL1xuICAgIGZvcih2YXIgcHRyID0gMDsgcHRyIDwgcGxhbi5sZW5ndGg7IHB0cisrKSB7XG4gICAgICBmb3IodmFyIGN0ciA9IDA7IGN0ciA8IHBsYW5bcHRyXVswXTsgY3RyKyspIHtcbiAgICAgICAgcGxhbltwdHJdWzFdKFIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFdyaXRlIGJhY2sgcmVzdWx0IHRvIG91dHB1dCBidWZmZXIuICovXG4gICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcgaW4gQ0JDLW1vZGUsIGZlZWQgYmFjayBlbmNyeXB0ZWQgYnl0ZXMgaW50b1xuICAgICAgICAgICAgIElWIGJ1ZmZlciB0byBjYXJyeSBpdCBmb3J3YXJkIHRvIG5leHQgYmxvY2suICovXG4gICAgICAgICAgX2l2LnB1dEludDE2TGUoUltpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUltpXSBePSBfaXYuZ2V0SW50MTZMZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vdXRwdXQucHV0SW50MTZMZShSW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyogQ3JlYXRlIGNpcGhlciBvYmplY3QgKi9cbiAgdmFyIGNpcGhlciA9IG51bGw7XG4gIGNpcGhlciA9IHtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLCB3aGljaGV2ZXJcbiAgICAgKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICAgICAqXG4gICAgICogVG8gdXNlIHRoZSBjaXBoZXIgaW4gQ0JDIG1vZGUsIGl2IG1heSBiZSBnaXZlbiBlaXRoZXIgYXMgYSBzdHJpbmdcbiAgICAgKiBvZiBieXRlcywgb3IgYXMgYSBieXRlIGJ1ZmZlci4gIEZvciBFQ0IgbW9kZSwgZ2l2ZSBudWxsIGFzIGl2LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLCBudWxsIGZvciBFQ0IgbW9kZS5cbiAgICAgKiBAcGFyYW0gb3V0cHV0IHRoZSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbihpdiwgb3V0cHV0KSB7XG4gICAgICBpZihpdikge1xuICAgICAgICAvKiBDQkMgbW9kZSAqL1xuICAgICAgICBpZih0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihpdik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2ZpbmlzaCA9IGZhbHNlO1xuICAgICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9vdXRwdXQgPSBvdXRwdXQgfHwgbmV3IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfaXYgPSBpdjtcblxuICAgICAgY2lwaGVyLm91dHB1dCA9IF9vdXRwdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYoIV9maW5pc2gpIHtcbiAgICAgICAgLy8gbm90IGZpbmlzaGluZywgc28gZmlsbCB0aGUgaW5wdXQgYnVmZmVyIHdpdGggbW9yZSBpbnB1dFxuICAgICAgICBfaW5wdXQucHV0QnVmZmVyKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoX2lucHV0Lmxlbmd0aCgpID49IDgpIHtcbiAgICAgICAgcnVuUGxhbihbXG4gICAgICAgICAgICBbIDUsIG1peFJvdW5kIF0sXG4gICAgICAgICAgICBbIDEsIG1hc2hSb3VuZCBdLFxuICAgICAgICAgICAgWyA2LCBtaXhSb3VuZCBdLFxuICAgICAgICAgICAgWyAxLCBtYXNoUm91bmQgXSxcbiAgICAgICAgICAgIFsgNSwgbWl4Um91bmQgXVxuICAgICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2hlcyBlbmNyeXB0aW5nIG9yIGRlY3J5cHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFkIGEgcGFkZGluZyBmdW5jdGlvbiB0byB1c2UsIG51bGwgZm9yIFBLQ1MjNyBwYWRkaW5nLFxuICAgICAqICAgICAgICAgICBzaWduYXR1cmUoYmxvY2tTaXplLCBidWZmZXIsIGRlY3J5cHQpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICAgICAqL1xuICAgIGZpbmlzaDogZnVuY3Rpb24ocGFkKSB7XG4gICAgICB2YXIgcnZhbCA9IHRydWU7XG5cbiAgICAgIGlmKGVuY3J5cHQpIHtcbiAgICAgICAgaWYocGFkKSB7XG4gICAgICAgICAgcnZhbCA9IHBhZCg4LCBfaW5wdXQsICFlbmNyeXB0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gICAgICAgICAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSAoX2lucHV0Lmxlbmd0aCgpID09PSA4KSA/IDggOiAoOCAtIF9pbnB1dC5sZW5ndGgoKSk7XG4gICAgICAgICAgX2lucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nLCBwYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihydmFsKSB7XG4gICAgICAgIC8vIGRvIGZpbmFsIHVwZGF0ZVxuICAgICAgICBfZmluaXNoID0gdHJ1ZTtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZighZW5jcnlwdCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2sgc2l6ZVxuICAgICAgICBydmFsID0gKF9pbnB1dC5sZW5ndGgoKSA9PT0gMCk7XG4gICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICBpZihwYWQpIHtcbiAgICAgICAgICAgIHJ2YWwgPSBwYWQoOCwgX291dHB1dCwgIWVuY3J5cHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgcGFkZGluZyBieXRlIGNvdW50IGlzIHZhbGlkXG4gICAgICAgICAgICB2YXIgbGVuID0gX291dHB1dC5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IF9vdXRwdXQuYXQobGVuIC0gMSk7XG5cbiAgICAgICAgICAgIGlmKGNvdW50ID4gbGVuKSB7XG4gICAgICAgICAgICAgIHJ2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgICAgICAgICAgICAgX291dHB1dC50cnVuY2F0ZShjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXJcbiAqIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKiBUaGUgY2lwaGVyIGlzIGluaXRpYWxpemVkIHRvIHVzZSAxMjggZWZmZWN0aXZlIGtleSBiaXRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuc3RhcnRFbmNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0KSB7XG4gIHZhciBjaXBoZXIgPSBmb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gIGNpcGhlci5zdGFydChpdiwgb3V0cHV0KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIFRvIHN0YXJ0IGVuY3J5cHRpbmcgY2FsbCBzdGFydCgpIG9uIHRoZSBjaXBoZXIgd2l0aCBhbiBpdiBhbmQgb3B0aW9uYWxcbiAqIG91dHB1dCBidWZmZXIuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgYml0cykge1xuICByZXR1cm4gY3JlYXRlQ2lwaGVyKGtleSwgYml0cywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlclxuICogb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqIFRoZSBjaXBoZXIgaXMgaW5pdGlhbGl6ZWQgdG8gdXNlIDEyOCBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQpIHtcbiAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgY2lwaGVyLnN0YXJ0KGl2LCBvdXRwdXQpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogVG8gc3RhcnQgZGVjcnlwdGluZyBjYWxsIHN0YXJ0KCkgb24gdGhlIGNpcGhlciB3aXRoIGFuIGl2IGFuZCBvcHRpb25hbFxuICogb3V0cHV0IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzKSB7XG4gIHJldHVybiBjcmVhdGVDaXBoZXIoa2V5LCBiaXRzLCBmYWxzZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBQYXJ0aWFsIGltcGxlbWVudGF0aW9uIG9mIFBLQ1MjMSB2Mi4yOiBSU0EtT0VBUFxuICpcbiAqIE1vZGlmaWVkIGJ1dCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIE1JVCBhbmQgQlNEIGxpY2Vuc2VkIGNvZGU6XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2tqdXIvanNqd3MvYmxvYi9tYXN0ZXIvcnNhLmpzOlxuICpcbiAqIFRoZSAnanNqd3MnKEpTT04gV2ViIFNpZ25hdHVyZSBKYXZhU2NyaXB0IExpYnJhcnkpIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgS2VuamkgVXJ1c2hpbWFcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIGh0dHA6Ly93ZWJyc2EuY3ZzLnNvdXJjZWZvcmdlLm5ldC92aWV3dmMvd2VicnNhL0NsaWVudC9SU0FFUy1PQUVQLmpzP2NvbnRlbnQtdHlwZT10ZXh0JTJGcGxhaW46XG4gKlxuICogUlNBRVMtT0FFUC5qc1xuICogJElkOiBSU0FFUy1PQUVQLmpzLHYgMS4xLjEuMSAyMDAzLzAzLzE5IDE1OjM3OjIwIGVsbGlzcHJpdGNoYXJkIEV4cCAkXG4gKiBKYXZhU2NyaXB0IEltcGxlbWVudGF0aW9uIG9mIFBLQ1MgIzEgdjIuMSBSU0EgQ1JZUFRPR1JBUEhZIFNUQU5EQVJEIChSU0EgTGFib3JhdG9yaWVzLCBKdW5lIDE0LCAyMDAyKVxuICogQ29weXJpZ2h0IChDKSBFbGxpcyBQcml0Y2hhcmQsIEd1YXJkaWFuIFVubGltaXRlZCAyMDAzLlxuICogQ29udGFjdDogZWxsaXNAbnVraW5ldGljcy5jb21cbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbiAqXG4gKiBPZmZpY2lhbCBkb2N1bWVudGF0aW9uOiBodHRwOi8vd3d3LnJzYS5jb20vcnNhbGFicy9ub2RlLmFzcD9pZD0yMTI1XG4gKlxuICogQGF1dGhvciBFdmFuIEpvbmVzIChodHRwOi8vZXZhbmpvbmVzLmNhLylcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbi8vIHNob3J0Y3V0IGZvciBQS0NTIzEgQVBJXG52YXIgcGtjczEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3MxID0gZm9yZ2UucGtjczEgfHwge307XG5cbi8qKlxuICogRW5jb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIG1lc3NhZ2UgKE0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbCBsYWJlbCAoTClcbiAqIGFuZCBzZWVkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGVuY3J5cHRpb24sIGl0IG9ubHkgZW5jb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIHNlZWQgdGhlIHNlZWQgdG8gdXNlLlxuICogICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UsIHVuZGVmaW5lZCBmb3IgU0hBLTEuXG4gKiAgICAgICAgICBtZ2YxIG9wdGlvbmFsIG1nZjEgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE1HRjEuXG4gKlxuICogQHJldHVybiB0aGUgZW5jb2RlZCBtZXNzYWdlIGJ5dGVzLlxuICovXG5wa2NzMS5lbmNvZGVfcnNhX29hZXAgPSBmdW5jdGlvbihrZXksIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgLy8gcGFyc2UgYXJndW1lbnRzXG4gIHZhciBsYWJlbDtcbiAgdmFyIHNlZWQ7XG4gIHZhciBtZDtcbiAgdmFyIG1nZjFNZDtcbiAgLy8gbGVnYWN5IGFyZ3MgKGxhYmVsLCBzZWVkLCBtZClcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zO1xuICAgIHNlZWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gYXJndW1lbnRzWzRdIHx8IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmKG9wdGlvbnMpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgdW5kZWZpbmVkO1xuICAgIHNlZWQgPSBvcHRpb25zLnNlZWQgfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gb3B0aW9ucy5tZCB8fCB1bmRlZmluZWQ7XG4gICAgaWYob3B0aW9ucy5tZ2YxICYmIG9wdGlvbnMubWdmMS5tZCkge1xuICAgICAgbWdmMU1kID0gb3B0aW9ucy5tZ2YxLm1kO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlZmF1bHQgT0FFUCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZighbWQpIHtcbiAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgbWQuc3RhcnQoKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgTUdGLTEgdG8gc2FtZSBhcyBPQUVQXG4gIGlmKCFtZ2YxTWQpIHtcbiAgICBtZ2YxTWQgPSBtZDtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgbGVuZ3RoIGluIGJ5dGVzIGFuZCBjaGVjayBvdXRwdXRcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICB2YXIgbWF4TGVuZ3RoID0ga2V5TGVuZ3RoIC0gMiAqIG1kLmRpZ2VzdExlbmd0aCAtIDI7XG4gIGlmKG1lc3NhZ2UubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGlucHV0IG1lc3NhZ2UgbGVuZ3RoIGlzIHRvbyBsb25nLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoO1xuICAgIGVycm9yLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKCFsYWJlbCkge1xuICAgIGxhYmVsID0gJyc7XG4gIH1cbiAgbWQudXBkYXRlKGxhYmVsLCAncmF3Jyk7XG4gIHZhciBsSGFzaCA9IG1kLmRpZ2VzdCgpO1xuXG4gIHZhciBQUyA9ICcnO1xuICB2YXIgUFNfbGVuZ3RoID0gbWF4TGVuZ3RoIC0gbWVzc2FnZS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgUFNfbGVuZ3RoOyBpKyspIHtcbiAgICBQUyArPSAnXFx4MDAnO1xuICB9XG5cbiAgdmFyIERCID0gbEhhc2guZ2V0Qnl0ZXMoKSArIFBTICsgJ1xceDAxJyArIG1lc3NhZ2U7XG5cbiAgaWYoIXNlZWQpIHtcbiAgICBzZWVkID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG1kLmRpZ2VzdExlbmd0aCk7XG4gIH0gZWxzZSBpZihzZWVkLmxlbmd0aCAhPT0gbWQuZGlnZXN0TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIFJTQUVTLU9BRVAgc2VlZC4gVGhlIHNlZWQgbGVuZ3RoIG11c3QgJyArXG4gICAgICAnbWF0Y2ggdGhlIGRpZ2VzdCBsZW5ndGguJyk7XG4gICAgZXJyb3Iuc2VlZExlbmd0aCA9IHNlZWQubGVuZ3RoO1xuICAgIGVycm9yLmRpZ2VzdExlbmd0aCA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgbWFza2VkREIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKERCLCBkYk1hc2ssIERCLmxlbmd0aCk7XG5cbiAgdmFyIHNlZWRNYXNrID0gcnNhX21nZjEobWFza2VkREIsIG1kLmRpZ2VzdExlbmd0aCwgbWdmMU1kKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHNlZWQsIHNlZWRNYXNrLCBzZWVkLmxlbmd0aCk7XG5cbiAgLy8gcmV0dXJuIGVuY29kZWQgbWVzc2FnZVxuICByZXR1cm4gJ1xceDAwJyArIG1hc2tlZFNlZWQgKyBtYXNrZWREQjtcbn07XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSAoRU0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbFxuICogbGFiZWwgKEwpLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGRlY3J5cHRpb24sIGl0IG9ubHkgZGVjb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBlbSB0aGUgZW5jb2RlZCBtZXNzYWdlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBPQUVQLCB1bmRlZmluZWQgZm9yIFNIQS0xLlxuICogICAgICAgICAgbWdmMSBvcHRpb25hbCBtZ2YxIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBNR0YxLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgbWVzc2FnZSBieXRlcy5cbiAqL1xucGtjczEuZGVjb2RlX3JzYV9vYWVwID0gZnVuY3Rpb24oa2V5LCBlbSwgb3B0aW9ucykge1xuICAvLyBwYXJzZSBhcmdzXG4gIHZhciBsYWJlbDtcbiAgdmFyIG1kO1xuICB2YXIgbWdmMU1kO1xuICAvLyBsZWdhY3kgYXJnc1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnM7XG4gICAgbWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYob3B0aW9ucykge1xuICAgIGxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCB1bmRlZmluZWQ7XG4gICAgbWQgPSBvcHRpb25zLm1kIHx8IHVuZGVmaW5lZDtcbiAgICBpZihvcHRpb25zLm1nZjEgJiYgb3B0aW9ucy5tZ2YxLm1kKSB7XG4gICAgICBtZ2YxTWQgPSBvcHRpb25zLm1nZjEubWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcHV0ZSBsZW5ndGggaW4gYnl0ZXNcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIGlmKGVtLmxlbmd0aCAhPT0ga2V5TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlbS5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWRMZW5ndGggPSBrZXlMZW5ndGg7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBkZWZhdWx0IE9BRVAgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYobWQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBtZC5zdGFydCgpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCBNR0YtMSB0byBzYW1lIGFzIE9BRVBcbiAgaWYoIW1nZjFNZCkge1xuICAgIG1nZjFNZCA9IG1kO1xuICB9XG5cbiAgaWYoa2V5TGVuZ3RoIDwgMiAqIG1kLmRpZ2VzdExlbmd0aCArIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JTQUVTLU9BRVAga2V5IGlzIHRvbyBzaG9ydCBmb3IgdGhlIGhhc2ggZnVuY3Rpb24uJyk7XG4gIH1cblxuICBpZighbGFiZWwpIHtcbiAgICBsYWJlbCA9ICcnO1xuICB9XG4gIG1kLnVwZGF0ZShsYWJlbCwgJ3JhdycpO1xuICB2YXIgbEhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gIC8vIHNwbGl0IHRoZSBtZXNzYWdlIGludG8gaXRzIHBhcnRzXG4gIHZhciB5ID0gZW0uY2hhckF0KDApO1xuICB2YXIgbWFza2VkU2VlZCA9IGVtLnN1YnN0cmluZygxLCBtZC5kaWdlc3RMZW5ndGggKyAxKTtcbiAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyaW5nKDEgKyBtZC5kaWdlc3RMZW5ndGgpO1xuXG4gIHZhciBzZWVkTWFzayA9IHJzYV9tZ2YxKG1hc2tlZERCLCBtZC5kaWdlc3RMZW5ndGgsIG1nZjFNZCk7XG4gIHZhciBzZWVkID0gZm9yZ2UudXRpbC54b3JCeXRlcyhtYXNrZWRTZWVkLCBzZWVkTWFzaywgbWFza2VkU2VlZC5sZW5ndGgpO1xuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgZGIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKG1hc2tlZERCLCBkYk1hc2ssIG1hc2tlZERCLmxlbmd0aCk7XG5cbiAgdmFyIGxIYXNoUHJpbWUgPSBkYi5zdWJzdHJpbmcoMCwgbWQuZGlnZXN0TGVuZ3RoKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIHRoYXQgYWxsIHZhbHVlcyBtYXRjaCB3aGF0IGlzIGV4cGVjdGVkXG4gIHZhciBlcnJvciA9ICh5ICE9PSAnXFx4MDAnKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIGxIYXNoIHZzIGxIYXNoUHJpbWVcbiAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmRpZ2VzdExlbmd0aDsgKytpKSB7XG4gICAgZXJyb3IgfD0gKGxIYXNoLmNoYXJBdChpKSAhPT0gbEhhc2hQcmltZS5jaGFyQXQoaSkpO1xuICB9XG5cbiAgLy8gXCJjb25zdGFudCB0aW1lXCIgZmluZCB0aGUgMHgxIGJ5dGUgc2VwYXJhdGluZyB0aGUgcGFkZGluZyAoemVyb3MpIGZyb20gdGhlXG4gIC8vIG1lc3NhZ2VcbiAgLy8gVE9ETzogSXQgbXVzdCBiZSBwb3NzaWJsZSB0byBkbyB0aGlzIGluIGEgYmV0dGVyL3NtYXJ0ZXIgd2F5P1xuICB2YXIgaW5fcHMgPSAxO1xuICB2YXIgaW5kZXggPSBtZC5kaWdlc3RMZW5ndGg7XG4gIGZvcih2YXIgaiA9IG1kLmRpZ2VzdExlbmd0aDsgaiA8IGRiLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGNvZGUgPSBkYi5jaGFyQ29kZUF0KGopO1xuXG4gICAgdmFyIGlzXzAgPSAoY29kZSAmIDB4MSkgXiAweDE7XG5cbiAgICAvLyBub24temVybyBpZiBub3QgMCBvciAxIGluIHRoZSBwcyBzZWN0aW9uXG4gICAgdmFyIGVycm9yX21hc2sgPSBpbl9wcyA/IDB4ZmZmZSA6IDB4MDAwMDtcbiAgICBlcnJvciB8PSAoY29kZSAmIGVycm9yX21hc2spO1xuXG4gICAgLy8gbGF0Y2ggaW5fcHMgdG8gemVybyBhZnRlciB3ZSBmaW5kIDB4MVxuICAgIGluX3BzID0gaW5fcHMgJiBpc18wO1xuICAgIGluZGV4ICs9IGluX3BzO1xuICB9XG5cbiAgaWYoZXJyb3IgfHwgZGIuY2hhckNvZGVBdChpbmRleCkgIT09IDB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSU0FFUy1PQUVQIHBhZGRpbmcuJyk7XG4gIH1cblxuICByZXR1cm4gZGIuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG59O1xuXG5mdW5jdGlvbiByc2FfbWdmMShzZWVkLCBtYXNrTGVuZ3RoLCBoYXNoKSB7XG4gIC8vIGRlZmF1bHQgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYoIWhhc2gpIHtcbiAgICBoYXNoID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfVxuICB2YXIgdCA9ICcnO1xuICB2YXIgY291bnQgPSBNYXRoLmNlaWwobWFza0xlbmd0aCAvIGhhc2guZGlnZXN0TGVuZ3RoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAoaSA+PiAyNCkgJiAweEZGLCAoaSA+PiAxNikgJiAweEZGLCAoaSA+PiA4KSAmIDB4RkYsIGkgJiAweEZGKTtcbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUoc2VlZCArIGMpO1xuICAgIHQgKz0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICB9XG4gIHJldHVybiB0LnN1YnN0cmluZygwLCBtYXNrTGVuZ3RoKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogUHJpbWUgbnVtYmVyIGdlbmVyYXRpb24gQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnByaW1lIGFscmVhZHkgZGVmaW5lZFxuaWYoZm9yZ2UucHJpbWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcmltZTtcbiAgcmV0dXJuO1xufVxuXG4vKiBQUklNRSBBUEkgKi9cbnZhciBwcmltZSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJpbWUgPSBmb3JnZS5wcmltZSB8fCB7fTtcblxudmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG5cbi8vIHByaW1lcyBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xudmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuVEhJUlRZLmZyb21JbnQoMzApO1xudmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4fHk7fTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcHJvYmFibGUgcHJpbWUgd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQWx0ZXJuYXRpdmUgYWxnb3JpdGhtcyBjYW4gYmUgc3BlY2lmaWVkIGJ5IG5hbWUgYXMgYSBzdHJpbmcgb3IgYXMgYW5cbiAqIG9iamVjdCB3aXRoIGN1c3RvbSBvcHRpb25zIGxpa2Ugc286XG4gKlxuICoge1xuICogICBuYW1lOiAnUFJJTUVJTkMnLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgbWF4QmxvY2tUaW1lOiA8dGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gYmxvY2sgdGhlIG1haW5cbiAqICAgICAgIHRocmVhZCBiZWZvcmUgYWxsb3dpbmcgSS9PIG90aGVyIEpTIHRvIHJ1bj4sXG4gKiAgICAgbWlsbGVyUmFiaW5UZXN0czogPHRoZSBudW1iZXIgb2YgbWlsbGVyLXJhYmluIHRlc3RzIHRvIHJ1bj4sXG4gKiAgICAgd29ya2VyU2NyaXB0OiA8dGhlIHdvcmtlciBzY3JpcHQgVVJMPixcbiAqICAgICB3b3JrZXJzOiA8dGhlIG51bWJlciBvZiB3ZWIgd29ya2VycyAoaWYgc3VwcG9ydGVkKSB0byB1c2UsXG4gKiAgICAgICAtMSB0byB1c2UgZXN0aW1hdGVkIGNvcmVzIG1pbnVzIG9uZT4uXG4gKiAgICAgd29ya0xvYWQ6IHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgbnVtYmVyIG9mIGJpdHMgZm9yIHRoZSBwcmltZSBudW1iZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBbYWxnb3JpdGhtXSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiAgICAgICAgICBbcHJuZ10gYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuXG4gKlxuICogQHJldHVybiBjYWxsYmFjayhlcnIsIG51bSkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnByaW1lLmdlbmVyYXRlUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBkZWZhdWx0IHRvIFBSSU1FSU5DIGFsZ29yaXRobVxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcbiAgaWYodHlwZW9mIGFsZ29yaXRobSA9PT0gJ3N0cmluZycpIHtcbiAgICBhbGdvcml0aG0gPSB7bmFtZTogYWxnb3JpdGhtfTtcbiAgfVxuICBhbGdvcml0aG0ub3B0aW9ucyA9IGFsZ29yaXRobS5vcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICB2YXIgcm5nID0ge1xuICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgYiA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHgubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHhbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmKGFsZ29yaXRobS5uYW1lID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcmV0dXJuIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgYWxnb3JpdGhtLm9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmltZSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobS5uYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoJ3dvcmtlcnMnIGluIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIGluaXRpYWxpemUgcmFuZG9tIG51bWJlclxuICB2YXIgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcblxuICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybSAzMGsraSBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEuIFRoZVxuICBudW1iZXIgd2UgYXJlIGdpdmVuIGlzIGFsd2F5cyBhbGlnbmVkIGF0IDMwayArIDEuIEVhY2ggdGltZSB0aGUgbnVtYmVyIGlzXG4gIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlclxuICB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgdmFyIGRlbHRhSWR4ID0gMDtcblxuICAvLyBnZXQgcmVxdWlyZWQgbnVtYmVyIG9mIE1SIHRlc3RzXG4gIHZhciBtclRlc3RzID0gZ2V0TWlsbGVyUmFiaW5UZXN0cyhudW0uYml0TGVuZ3RoKCkpO1xuICBpZignbWlsbGVyUmFiaW5UZXN0cycgaW4gb3B0aW9ucykge1xuICAgIG1yVGVzdHMgPSBvcHRpb25zLm1pbGxlclJhYmluVGVzdHM7XG4gIH1cblxuICAvLyBmaW5kIHByaW1lIG5lYXJlc3QgdG8gJ251bScgZm9yIG1heEJsb2NrVGltZSBtc1xuICAvLyAxMCBtcyBnaXZlcyA1bXMgb2YgbGVld2F5IGZvciBvdGhlciBjYWxjdWxhdGlvbnMgYmVmb3JlIGRyb3BwaW5nXG4gIC8vIGJlbG93IDYwZnBzICgxMDAwLzYwID09IDE2LjY3KSwgYnV0IGluIHJlYWxpdHksIHRoZSBudW1iZXIgd2lsbFxuICAvLyBsaWtlbHkgYmUgaGlnaGVyIGR1ZSB0byBhbiAnYXRvbWljJyBiaWcgaW50IG1vZFBvd1xuICB2YXIgbWF4QmxvY2tUaW1lID0gMTA7XG4gIGlmKCdtYXhCbG9ja1RpbWUnIGluIG9wdGlvbnMpIHtcbiAgICBtYXhCbG9ja1RpbWUgPSBvcHRpb25zLm1heEJsb2NrVGltZTtcbiAgfVxuXG4gIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGFydCA9ICtuZXcgRGF0ZSgpO1xuICBkbyB7XG4gICAgLy8gb3ZlcmZsb3csIHJlZ2VuZXJhdGUgcmFuZG9tIG51bWJlclxuICAgIGlmKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgfVxuICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgaWYobnVtLmlzUHJvYmFibGVQcmltZShtclRlc3RzKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bSk7XG4gICAgfVxuICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgIG51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICB9IHdoaWxlKG1heEJsb2NrVGltZSA8IDAgfHwgKCtuZXcgRGF0ZSgpIC0gc3RhcnQgPCBtYXhCbG9ja1RpbWUpKTtcblxuICAvLyBrZWVwIHRyeWluZyBsYXRlclxuICBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8vIE5PVEU6IFRoaXMgYWxnb3JpdGhtIGlzIGluZGV0ZXJtaW5hdGUgaW4gbmF0dXJlIGJlY2F1c2Ugd29ya2Vyc1xuLy8gcnVuIGluIHBhcmFsbGVsIGxvb2tpbmcgYXQgZGlmZmVyZW50IHNlZ21lbnRzIG9mIG51bWJlcnMuIEV2ZW4gaWYgdGhpc1xuLy8gYWxnb3JpdGhtIGlzIHJ1biB0d2ljZSB3aXRoIHRoZSBzYW1lIGlucHV0IGZyb20gYSBwcmVkaWN0YWJsZSBSTkcsIGl0XG4vLyBtYXkgcHJvZHVjZSBkaWZmZXJlbnQgb3V0cHV0cy5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lV2l0aFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyB3ZWIgd29ya2VycyB1bmF2YWlsYWJsZVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSByYW5kb20gbnVtYmVyXG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuXG4gIC8vIHVzZSB3ZWIgd29ya2VycyB0byBnZW5lcmF0ZSBrZXlzXG4gIHZhciBudW1Xb3JrZXJzID0gb3B0aW9ucy53b3JrZXJzO1xuICB2YXIgd29ya0xvYWQgPSBvcHRpb25zLndvcmtMb2FkIHx8IDEwMDtcbiAgdmFyIHJhbmdlID0gd29ya0xvYWQgKiAzMCAvIDg7XG4gIHZhciB3b3JrZXJTY3JpcHQgPSBvcHRpb25zLndvcmtlclNjcmlwdCB8fCAnZm9yZ2UvcHJpbWUud29ya2VyLmpzJztcbiAgaWYobnVtV29ya2VycyA9PT0gLTEpIHtcbiAgICByZXR1cm4gZm9yZ2UudXRpbC5lc3RpbWF0ZUNvcmVzKGZ1bmN0aW9uKGVyciwgY29yZXMpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIDJcbiAgICAgICAgY29yZXMgPSAyO1xuICAgICAgfVxuICAgICAgbnVtV29ya2VycyA9IGNvcmVzIC0gMTtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyByZXF1aXJlIGF0IGxlYXN0IDEgd29ya2VyXG4gICAgbnVtV29ya2VycyA9IE1hdGgubWF4KDEsIG51bVdvcmtlcnMpO1xuXG4gICAgLy8gVE9ETzogY29uc2lkZXIgb3B0aW1pemluZyBieSBzdGFydGluZyB3b3JrZXJzIG91dHNpZGUgZ2V0UHJpbWUoKSAuLi5cbiAgICAvLyBub3RlIHRoYXQgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhleSB3aWxsIGhhdmUgdG8gYmUgbWFkZSBpbnRlcm5hbGx5XG4gICAgLy8gYXN5bmNocm9ub3VzIHdoaWNoIG1heSBhY3R1YWxseSBiZSBzbG93ZXJcblxuICAgIC8vIHN0YXJ0IHdvcmtlcnMgaW1tZWRpYXRlbHlcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIC8vIEZJWE1FOiBmaXggcGF0aCBvciB1c2UgYmxvYiBVUkxzXG4gICAgICB3b3JrZXJzW2ldID0gbmV3IFdvcmtlcih3b3JrZXJTY3JpcHQpO1xuICAgIH1cbiAgICB2YXIgcnVubmluZyA9IG51bVdvcmtlcnM7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHJlcXVlc3RzIGZyb20gd29ya2VycyBhbmQgYXNzaWduIHJhbmdlcyB0byBmaW5kIHByaW1lXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyogTm90ZTogVGhlIGRpc3RyaWJ1dGlvbiBvZiByYW5kb20gbnVtYmVycyBpcyB1bmtub3duLiBUaGVyZWZvcmUsIGVhY2hcbiAgICB3ZWIgd29ya2VyIGlzIGNvbnRpbnVvdXNseSBhbGxvY2F0ZWQgYSByYW5nZSBvZiBudW1iZXJzIHRvIGNoZWNrIGZvciBhXG4gICAgcmFuZG9tIG51bWJlciB1bnRpbCBvbmUgaXMgZm91bmQuXG5cbiAgICBFdmVyeSAzMCBudW1iZXJzIHdpbGwgYmUgY2hlY2tlZCBqdXN0IDggdGltZXMsIGJlY2F1c2UgcHJpbWUgbnVtYmVyc1xuICAgIGhhdmUgdGhlIGZvcm06XG5cbiAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xICh0aGVyZSBhcmUgOCB2YWx1ZXMgb2YgaSBmb3IgdGhpcylcblxuICAgIFRoZXJlZm9yZSwgaWYgd2Ugd2FudCBhIHdlYiB3b3JrZXIgdG8gcnVuIE4gY2hlY2tzIGJlZm9yZSBhc2tpbmcgZm9yXG4gICAgYSBuZXcgcmFuZ2Ugb2YgbnVtYmVycywgZWFjaCByYW5nZSBtdXN0IGNvbnRhaW4gTiozMC84IG51bWJlcnMuXG5cbiAgICBGb3IgMTAwIGNoZWNrcyAod29ya0xvYWQpLCB0aGlzIGlzIGEgcmFuZ2Ugb2YgMzc1LiAqL1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gd29ya2VyTWVzc2FnZShlKSB7XG4gICAgICAvLyBpZ25vcmUgbWVzc2FnZSwgcHJpbWUgYWxyZWFkeSBmb3VuZFxuICAgICAgaWYoZm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAtLXJ1bm5pbmc7XG4gICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgIGlmKGRhdGEuZm91bmQpIHtcbiAgICAgICAgLy8gdGVybWluYXRlIGFsbCB3b3JrZXJzXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB3b3JrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQmlnSW50ZWdlcihkYXRhLnByaW1lLCAxNikpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVyZmxvdywgcmVnZW5lcmF0ZSByYW5kb20gbnVtYmVyXG4gICAgICBpZihudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc2lnbiBuZXcgcmFuZ2UgdG8gY2hlY2tcbiAgICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuXG4gICAgICAvLyBzdGFydCBwcmltZSBzZWFyY2hcbiAgICAgIGUudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaGV4OiBoZXgsXG4gICAgICAgIHdvcmtMb2FkOiB3b3JrTG9hZFxuICAgICAgfSk7XG5cbiAgICAgIG51bS5kQWRkT2Zmc2V0KHJhbmdlLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIHVzaW5nIHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cyBhbmQgUk5HLlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgYml0cyBmb3IgdGhlIG51bWJlci5cbiAqIEBwYXJhbSBybmcgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpIHtcbiAgdmFyIG51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHJuZyk7XG4gIC8vIGZvcmNlIE1TQiBzZXRcbiAgdmFyIGJpdHMxID0gYml0cyAtIDE7XG4gIGlmKCFudW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICBudW0uYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChiaXRzMSksIG9wX29yLCBudW0pO1xuICB9XG4gIC8vIGFsaWduIG51bWJlciBvbiAzMGsrMSBib3VuZGFyeVxuICBudW0uZEFkZE9mZnNldCgzMSAtIG51bS5tb2QoVEhJUlRZKS5ieXRlVmFsdWUoKSwgMCk7XG4gIHJldHVybiBudW07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIE1pbGxlci1SYWJpbiB0ZXN0cyB0byBnZW5lcmF0ZSBhXG4gKiBwcmltZSB3aXRoIGFuIGVycm9yIHByb2JhYmlsaXR5IG9mICgxLzIpXjgwLlxuICpcbiAqIFNlZSBIYW5kYm9vayBvZiBBcHBsaWVkIENyeXB0b2dyYXBoeSBDaGFwdGVyIDQsIFRhYmxlIDQuNC5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUuXG4gKlxuICogQHJldHVybiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBQS0NTIzEyLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBQS0NTIzEyIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgZnRwOi8vZnRwLnJzYXNlY3VyaXR5LmNvbS9wdWIvcGtjcy9wa2NzLTEyL3BrY3MtMTItdGMxLnBkZiBmb3IgZGV0YWlscylcbiAqXG4gKiBQRlggOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgSU5URUdFUiB7djMoMyl9KHYzLC4uLiksXG4gKiAgIGF1dGhTYWZlIENvbnRlbnRJbmZvLFxuICogICBtYWNEYXRhICBNYWNEYXRhIE9QVElPTkFMXG4gKiB9XG4gKlxuICogTWFjRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICBtYWMgRGlnZXN0SW5mbyxcbiAqICAgbWFjU2FsdCBPQ1RFVCBTVFJJTkcsXG4gKiAgIGl0ZXJhdGlvbnMgSU5URUdFUiBERUZBVUxUIDFcbiAqIH1cbiAqIE5vdGU6IFRoZSBpdGVyYXRpb25zIGRlZmF1bHQgaXMgZm9yIGhpc3RvcmljYWwgcmVhc29ucyBhbmQgaXRzIHVzZSBpc1xuICogZGVwcmVjYXRlZC4gQSBoaWdoZXIgdmFsdWUsIGxpa2UgMTAyNCwgaXMgcmVjb21tZW5kZWQuXG4gKlxuICogRGlnZXN0SW5mbyBpcyBkZWZpbmVkIGluIFBLQ1MjNyBhcyBmb2xsb3dzOlxuICpcbiAqIERpZ2VzdEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGRpZ2VzdCBEaWdlc3RcbiAqIH1cbiAqXG4gKiBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIFNIQTEgdGhlcmUgaXMgbm9uZS5cbiAqXG4gKiBBbGdvcml0aG1JZGVudGlmZXIgOjo9IFNFUVVFTkNFIHtcbiAqICAgIGFsZ29yaXRobSBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAqXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgIFswXSBFWFBMSUNJVCBBTlkgREVGSU5FRCBCWSBjb250ZW50VHlwZSBPUFRJT05BTFxuICogfVxuICpcbiAqIENvbnRlbnRUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICpcbiAqIEF1dGhlbnRpY2F0ZWRTYWZlIDo6PSBTRVFVRU5DRSBPRiBDb250ZW50SW5mb1xuICogLS0gRGF0YSBpZiB1bmVuY3J5cHRlZFxuICogLS0gRW5jcnlwdGVkRGF0YSBpZiBwYXNzd29yZC1lbmNyeXB0ZWRcbiAqIC0tIEVudmVsb3BlZERhdGEgaWYgcHVibGljIGtleS1lbmNyeXB0ZWRcbiAqXG4gKlxuICogU2FmZUNvbnRlbnRzIDo6PSBTRVFVRU5DRSBPRiBTYWZlQmFnXG4gKlxuICogU2FmZUJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBiYWdJZCAgICAgQkFHLVRZUEUuJmlkICh7UEtDUzEyQmFnU2V0fSlcbiAqICAgYmFnVmFsdWUgIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSh7UEtDUzEyQmFnU2V0fXtAYmFnSWR9KSxcbiAqICAgYmFnQXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogUEtDUzEyQXR0cmlidXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGF0dHJJZCBBVFRSSUJVVEUuJmlkICh7UEtDUzEyQXR0clNldH0pLFxuICogICBhdHRyVmFsdWVzIFNFVCBPRiBBVFRSSUJVVEUuJlR5cGUgKHtQS0NTMTJBdHRyU2V0fXtAYXR0cklkfSlcbiAqIH0gLS0gVGhpcyB0eXBlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgWC41MDAgdHlwZSDigJlBdHRyaWJ1dGXigJlcbiAqXG4gKiBQS0NTMTJBdHRyU2V0IEFUVFJJQlVURSA6Oj0ge1xuICogICBmcmllbmRseU5hbWUgfCAtLSBmcm9tIFBLQ1MgIzlcbiAqICAgbG9jYWxLZXlJZCwgLS0gZnJvbSBQS0NTICM5XG4gKiAgIC4uLiAtLSBPdGhlciBhdHRyaWJ1dGVzIGFyZSBhbGxvd2VkXG4gKiB9XG4gKlxuICogQ2VydEJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjZXJ0SWQgICAgQkFHLVRZUEUuJmlkICAgKHtDZXJ0VHlwZXN9KSxcbiAqICAgY2VydFZhbHVlIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSAoe0NlcnRUeXBlc317QGNlcnRJZH0pXG4gKiB9XG4gKlxuICogeDUwOUNlcnRpZmljYXRlIEJBRy1UWVBFIDo6PSB7T0NURVQgU1RSSU5HIElERU5USUZJRUQgQlkge2NlcnRUeXBlcyAxfX1cbiAqICAgLS0gREVSLWVuY29kZWQgWC41MDkgY2VydGlmaWNhdGUgc3RvcmVkIGluIE9DVEVUIFNUUklOR1xuICpcbiAqIHNkc2lDZXJ0aWZpY2F0ZSBCQUctVFlQRSA6Oj0ge0lBNVN0cmluZyBJREVOVElGSUVEIEJZIHtjZXJ0VHlwZXMgMn19XG4gKiAtLSBCYXNlNjQtZW5jb2RlZCBTRFNJIGNlcnRpZmljYXRlIHN0b3JlZCBpbiBJQTVTdHJpbmdcbiAqXG4gKiBDZXJ0VHlwZXMgQkFHLVRZUEUgOjo9IHtcbiAqICAgeDUwOUNlcnRpZmljYXRlIHxcbiAqICAgc2RzaUNlcnRpZmljYXRlLFxuICogICAuLi4gLS0gRm9yIGZ1dHVyZSBleHRlbnNpb25zXG4gKiB9XG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xICYgUEtJIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjMTIgQVBJXG52YXIgcDEyID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2NzMTIgPSBmb3JnZS5wa2NzMTIgfHwge307XG5cbnZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsICAvLyBhIENvbnRlbnRJbmZvXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NvbnRlbnQnXG4gIH1dXG59O1xuXG52YXIgcGZ4VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUEZYJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUEZYLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sXG4gIGNvbnRlbnRJbmZvVmFsaWRhdG9yLCB7XG4gICAgbmFtZTogJ1BGWC5tYWNEYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnbWFjJyxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLCAgLy8gRGlnZXN0SW5mb1xuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ1BGWC5tYWNEYXRhLm1hYy5kaWdlc3RBbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSwgIC8vIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMuZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYWNBbGdvcml0aG0nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6ICdtYWNBbGdvcml0aG1QYXJhbWV0ZXJzJ1xuICAgICAgICB9XVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdtYWNEaWdlc3QnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWNTYWx0JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdtYWNTYWx0J1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5pdGVyYXRpb25zJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlOiAnbWFjSXRlcmF0aW9ucydcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHNhZmVCYWdWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTYWZlQmFnJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdJZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdiYWdJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdTYWZlQmFnLmJhZ1ZhbHVlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnYmFnVmFsdWUnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnYmFnQXR0cmlidXRlcydcbiAgfV1cbn07XG5cbnZhciBhdHRyaWJ1dGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdBdHRyaWJ1dGUnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0cklkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ29pZCdcbiAgfSwge1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0clZhbHVlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZTogJ3ZhbHVlcydcbiAgfV1cbn07XG5cbnZhciBjZXJ0QmFnVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydEJhZycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NlcnRCYWcuY2VydElkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NlcnRJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdDZXJ0QmFnLmNlcnRWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAvKiBTbyBmYXIgd2Ugb25seSBzdXBwb3J0IFguNTA5IGNlcnRpZmljYXRlcyAod2hpY2ggYXJlIHdyYXBwZWQgaW5cbiAgICAgICBhbiBPQ1RFVCBTVFJJTkcsIGhlbmNlIGhhcmQgY29kZSB0aGF0IGhlcmUpLiAqL1xuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRCYWcuY2VydFZhbHVlWzBdJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnY2VydCdcbiAgICB9XVxuICB9XVxufTtcblxuLyoqXG4gKiBTZWFyY2ggU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSBmb3IgYmFncyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhlIHNlYXJjaCBjYW4gb3B0aW9uYWxseSBiZSBuYXJyb3dlZCBieSBhIGNlcnRhaW4gYmFnIHR5cGUuXG4gKlxuICogQHBhcmFtIHNhZmVDb250ZW50cyB0aGUgU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0gYXR0ck5hbWUgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gKiBAcGFyYW0gYXR0clZhbHVlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAqXG4gKiBAcmV0dXJuIGFuIGFycmF5IG9mIG1hdGNoaW5nIGJhZ3MuXG4gKi9cbmZ1bmN0aW9uIF9nZXRCYWdzQnlBdHRyaWJ1dGUoc2FmZUNvbnRlbnRzLCBhdHRyTmFtZSwgYXR0clZhbHVlLCBiYWdUeXBlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgc2FmZUNvbnRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHNhZmVDb250ZW50c1tpXS5zYWZlQmFncy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGJhZyA9IHNhZmVDb250ZW50c1tpXS5zYWZlQmFnc1tqXTtcbiAgICAgIGlmKGJhZ1R5cGUgIT09IHVuZGVmaW5lZCAmJiBiYWcudHlwZSAhPT0gYmFnVHlwZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgZmlsdGVyIGJ5IGJhZyB0eXBlLCBubyBhdHRyaWJ1dGUgc3BlY2lmaWVkXG4gICAgICBpZihhdHRyTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXS5pbmRleE9mKGF0dHJWYWx1ZSkgPj0gMCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbiBpbnRvIGEgUEZYIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbi5cbiAqIEBwYXJhbSBzdHJpY3QgdHJ1ZSB0byB1c2Ugc3RyaWN0IERFUiBkZWNvZGluZywgZmFsc2Ugbm90IHRvIChkZWZhdWx0OiB0cnVlKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIFBLQ1MjMTIgUEZYIG9iamVjdC5cbiAqL1xucDEyLnBrY3MxMkZyb21Bc24xID0gZnVuY3Rpb24ob2JqLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGhhbmRsZSBhcmdzXG4gIGlmKHR5cGVvZiBzdHJpY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBzdHJpY3Q7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmKHN0cmljdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIFBGWCBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBwZnhWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFBLQ1MjMTIgUEZYLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjMTIgUEZYLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9yO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHBmeCA9IHtcbiAgICB2ZXJzaW9uOiBjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSxcbiAgICBzYWZlQ29udGVudHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBiYWdzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgdGhlIGF0dHJpYnV0ZXMgdG8gZmlsdGVyIGJ5OlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkXSB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkSGV4XSB0aGUgbG9jYWxLZXlJZCBpbiBoZXggdG8gc2VhcmNoIGZvci5cbiAgICAgKiAgICAgICAgICBbZnJpZW5kbHlOYW1lXSB0aGUgZnJpZW5kbHkgbmFtZSB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtiYWdUeXBlXSBiYWcgdHlwZSB0byBuYXJyb3cgZWFjaCBhdHRyaWJ1dGUgc2VhcmNoIGJ5LlxuICAgICAqXG4gICAgICogQHJldHVybiBhIG1hcCBvZiBhdHRyaWJ1dGUgdHlwZSB0byBhbiBhcnJheSBvZiBtYXRjaGluZyBiYWdzIG9yLCBpZiBub1xuICAgICAqICAgICAgICAgICBhdHRyaWJ1dGUgd2FzIGdpdmVuIGJ1dCBhIGJhZyB0eXBlLCB0aGUgbWFwIGtleSB3aWxsIGJlIHRoZVxuICAgICAqICAgICAgICAgICBiYWcgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRCYWdzOiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgIHZhciBydmFsID0ge307XG5cbiAgICAgIHZhciBsb2NhbEtleUlkO1xuICAgICAgaWYoJ2xvY2FsS2V5SWQnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZmlsdGVyLmxvY2FsS2V5SWQ7XG4gICAgICB9IGVsc2UgaWYoJ2xvY2FsS2V5SWRIZXgnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGZpbHRlci5sb2NhbEtleUlkSGV4KTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIG9uIGJhZ1R5cGUgb25seVxuICAgICAgaWYobG9jYWxLZXlJZCA9PT0gdW5kZWZpbmVkICYmICEoJ2ZyaWVuZGx5TmFtZScgaW4gZmlsdGVyKSAmJlxuICAgICAgICAnYmFnVHlwZScgaW4gZmlsdGVyKSB7XG4gICAgICAgIHJ2YWxbZmlsdGVyLmJhZ1R5cGVdID0gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCBudWxsLCBudWxsLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGxvY2FsS2V5SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBydmFsLmxvY2FsS2V5SWQgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdsb2NhbEtleUlkJyxcbiAgICAgICAgICBsb2NhbEtleUlkLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG4gICAgICBpZignZnJpZW5kbHlOYW1lJyBpbiBmaWx0ZXIpIHtcbiAgICAgICAgcnZhbC5mcmllbmRseU5hbWUgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdmcmllbmRseU5hbWUnLFxuICAgICAgICAgIGZpbHRlci5mcmllbmRseU5hbWUsIGZpbHRlci5iYWdUeXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgZnJpZW5kbHlOYW1lIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcmllbmRseU5hbWUgdGhlIGZyaWVuZGx5IG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gW2JhZ1R5cGVdIGJhZyB0eXBlIHRvIG5hcnJvdyBzZWFyY2ggYnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGJhZ3Mgd2l0aCBtYXRjaGluZyBmcmllbmRseU5hbWUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUZyaWVuZGx5TmFtZTogZnVuY3Rpb24oZnJpZW5kbHlOYW1lLCBiYWdUeXBlKSB7XG4gICAgICByZXR1cm4gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgcGZ4LnNhZmVDb250ZW50cywgJ2ZyaWVuZGx5TmFtZScsIGZyaWVuZGx5TmFtZSwgYmFnVHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgbG9jYWxLZXlJZCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxLZXlJZCB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYmFncyB3aXRoIG1hdGNoaW5nIGxvY2FsS2V5SWQgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUxvY2FsS2V5SWQ6IGZ1bmN0aW9uKGxvY2FsS2V5SWQsIGJhZ1R5cGUpIHtcbiAgICAgIHJldHVybiBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCAnbG9jYWxLZXlJZCcsIGxvY2FsS2V5SWQsIGJhZ1R5cGUpO1xuICAgIH1cbiAgfTtcblxuICBpZihjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSAhPT0gMykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignUEtDUyMxMiBQRlggb2YgdmVyc2lvbiBvdGhlciB0aGFuIDMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci52ZXJzaW9uID0gY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpICE9PSBwa2kub2lkcy5kYXRhKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdPbmx5IFBLQ1MjMTIgUEZYIGluIHBhc3N3b3JkIGludGVncml0eSBtb2RlIHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci5vaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gIGlmKGRhdGEudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGRhdGEudHlwZSAhPT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIGF1dGhTYWZlIGNvbnRlbnQgZGF0YSBpcyBub3QgYW4gT0NURVQgU1RSSU5HLicpO1xuICB9XG4gIGRhdGEgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpO1xuXG4gIC8vIGNoZWNrIGZvciBNQUNcbiAgaWYoY2FwdHVyZS5tYWMpIHtcbiAgICB2YXIgbWQgPSBudWxsO1xuICAgIHZhciBtYWNLZXlCeXRlcyA9IDA7XG4gICAgdmFyIG1hY0FsZ29yaXRobSA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5tYWNBbGdvcml0aG0pO1xuICAgIHN3aXRjaChtYWNBbGdvcml0aG0pIHtcbiAgICBjYXNlIHBraS5vaWRzLnNoYTE6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDIwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5zaGEyNTY6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHBraS5vaWRzLnNoYTM4NDpcbiAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgbWFjS2V5Qnl0ZXMgPSA0ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcGtpLm9pZHMuc2hhNTEyOlxuICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5tZDU6XG4gICAgICBtZCA9IGZvcmdlLm1kLm1kNS5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMTY7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiB1c2VzIHVuc3VwcG9ydGVkIE1BQyBhbGdvcml0aG06ICcgKyBtYWNBbGdvcml0aG0pO1xuICAgIH1cblxuICAgIC8vIHZlcmlmeSBNQUMgKGl0ZXJhdGlvbnMgZGVmYXVsdCB0byAxKVxuICAgIHZhciBtYWNTYWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihjYXB0dXJlLm1hY1NhbHQpO1xuICAgIHZhciBtYWNJdGVyYXRpb25zID0gKCgnbWFjSXRlcmF0aW9ucycgaW4gY2FwdHVyZSkgP1xuICAgICAgcGFyc2VJbnQoZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGNhcHR1cmUubWFjSXRlcmF0aW9ucyksIDE2KSA6IDEpO1xuICAgIHZhciBtYWNLZXkgPSBwMTIuZ2VuZXJhdGVLZXkoXG4gICAgICBwYXNzd29yZCwgbWFjU2FsdCwgMywgbWFjSXRlcmF0aW9ucywgbWFjS2V5Qnl0ZXMsIG1kKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQobWQsIG1hY0tleSk7XG4gICAgbWFjLnVwZGF0ZShkYXRhLnZhbHVlKTtcbiAgICB2YXIgbWFjVmFsdWUgPSBtYWMuZ2V0TWFjKCk7XG4gICAgaWYobWFjVmFsdWUuZ2V0Qnl0ZXMoKSAhPT0gY2FwdHVyZS5tYWNEaWdlc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBNQUMgY291bGQgbm90IGJlIHZlcmlmaWVkLiBJbnZhbGlkIHBhc3N3b3JkPycpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWNvZGVBdXRoZW50aWNhdGVkU2FmZShwZngsIGRhdGEudmFsdWUsIHN0cmljdCwgcGFzc3dvcmQpO1xuICByZXR1cm4gcGZ4O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIFBLQ1MjNyBEYXRhLiBQS0NTIzcgKFJGQyAyMzE1KSBkZWZpbmVzIFwiRGF0YVwiIGFzIGFuIE9DVEVUIFNUUklORyxcbiAqIGJ1dCBpdCBpcyBzb21ldGltZXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaXMgY29tcG9zZWQvY29uc3RydWN0ZWQgb2YgY2h1bmtzLFxuICogZWFjaCBpdHMgb3duIE9DVEVUIFNUUklORy4gVGhpcyBpcyBCRVItZW5jb2RpbmcgdnMuIERFUi1lbmNvZGluZy4gVGhpc1xuICogZnVuY3Rpb24gdHJhbnNmb3JtcyB0aGlzIGNvcm5lci1jYXNlIGludG8gdGhlIHVzdWFsIHNpbXBsZSxcbiAqIG5vbi1jb21wb3NlZC9jb25zdHJ1Y3RlZCBPQ1RFVCBTVFJJTkcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXkgYmUgbW92ZWQgdG8gQVNOLjEgYXQgc29tZSBwb2ludCB0byBiZXR0ZXIgZGVhbCB3aXRoXG4gKiBtb3JlIEJFUi1lbmNvZGluZyBpc3N1ZXMsIHNob3VsZCB0aGV5IGFyaXNlLlxuICpcbiAqIEBwYXJhbSBkYXRhIHRoZSBBU04uMSBEYXRhIG9iamVjdCB0byB0cmFuc2Zvcm0uXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVQa2NzN0RhdGEoZGF0YSkge1xuICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIFwiY2h1bmtlZFwiIGRhdGEgY29udGVudDogYW4gb2N0ZXQgc3RyaW5nIGNvbXBvc2VkXG4gIC8vIG9mIG90aGVyIG9jdGV0IHN0cmluZ3NcbiAgaWYoZGF0YS5jb21wb3NlZCB8fCBkYXRhLmNvbnN0cnVjdGVkKSB7XG4gICAgdmFyIHZhbHVlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsdWUucHV0Qnl0ZXMoZGF0YS52YWx1ZVtpXS52YWx1ZSk7XG4gICAgfVxuICAgIGRhdGEuY29tcG9zZWQgPSBkYXRhLmNvbnN0cnVjdGVkID0gZmFsc2U7XG4gICAgZGF0YS52YWx1ZSA9IHZhbHVlLmdldEJ5dGVzKCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlIFBLQ1MjMTIgQXV0aGVudGljYXRlZFNhZmUgKEJFUiBlbmNvZGVkKSBpbnRvIFBGWCBvYmplY3QuXG4gKlxuICogVGhlIEF1dGhlbnRpY2F0ZWRTYWZlIGlzIGEgQkVSLWVuY29kZWQgU0VRVUVOQ0UgT0YgQ29udGVudEluZm8uXG4gKlxuICogQHBhcmFtIHBmeCBUaGUgUEtDUyMxMiBQRlggb2JqZWN0IHRvIGZpbGwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYXV0aFNhZmUgQkVSLWVuY29kZWQgQXV0aGVudGljYXRlZFNhZmUuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUF1dGhlbnRpY2F0ZWRTYWZlKHBmeCwgYXV0aFNhZmUsIHN0cmljdCwgcGFzc3dvcmQpIHtcbiAgYXV0aFNhZmUgPSBhc24xLmZyb21EZXIoYXV0aFNhZmUsIHN0cmljdCk7ICAvKiBhY3R1YWxseSBpdCdzIEJFUiBlbmNvZGVkICovXG5cbiAgaWYoYXV0aFNhZmUudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGF1dGhTYWZlLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgICBhdXRoU2FmZS5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBBdXRoZW50aWNhdGVkU2FmZSBleHBlY3RlZCB0byBiZSBhICcgK1xuICAgICAgJ1NFUVVFTkNFIE9GIENvbnRlbnRJbmZvJyk7XG4gIH1cblxuICBmb3IodmFyIGkgPSAwOyBpIDwgYXV0aFNhZmUudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGVudEluZm8gPSBhdXRoU2FmZS52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIGNvbnRlbnRJbmZvIGFuZCBjYXB0dXJlIGRhdGFcbiAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZighYXNuMS52YWxpZGF0ZShjb250ZW50SW5mbywgY29udGVudEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgQ29udGVudEluZm8uJyk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge1xuICAgICAgZW5jcnlwdGVkOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIHNhZmVDb250ZW50cyA9IG51bGw7XG4gICAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gICAgc3dpdGNoKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jb250ZW50VHlwZSkpIHtcbiAgICBjYXNlIHBraS5vaWRzLmRhdGE6XG4gICAgICBpZihkYXRhLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fFxuICAgICAgICAgZGF0YS50eXBlICE9PSBhc24xLlR5cGUuT0NURVRTVFJJTkcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIFNhZmVDb250ZW50cyBEYXRhIGlzIG5vdCBhbiBPQ1RFVCBTVFJJTkcuJyk7XG4gICAgICB9XG4gICAgICBzYWZlQ29udGVudHMgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5lbmNyeXB0ZWREYXRhOlxuICAgICAgc2FmZUNvbnRlbnRzID0gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpO1xuICAgICAgb2JqLmVuY3J5cHRlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQS0NTIzEyIGNvbnRlbnRUeXBlLicpO1xuICAgICAgZXJyb3IuY29udGVudFR5cGUgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgb2JqLnNhZmVCYWdzID0gX2RlY29kZVNhZmVDb250ZW50cyhzYWZlQ29udGVudHMsIHN0cmljdCwgcGFzc3dvcmQpO1xuICAgIHBmeC5zYWZlQ29udGVudHMucHVzaChvYmopO1xuICB9XG59XG5cbi8qKlxuICogRGVjcnlwdCBQS0NTIzcgRW5jcnlwdGVkRGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIGRhdGEgQVNOLjEgZW5jb2RlZCBFbmNyeXB0ZWRDb250ZW50SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHVzZXItcHJvdmlkZWQgcGFzc3dvcmQuXG4gKlxuICogQHJldHVybiBUaGUgZGVjcnlwdGVkIFNhZmVDb250ZW50cyAoQVNOLjEgb2JqZWN0KS5cbiAqL1xuZnVuY3Rpb24gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShcbiAgICBkYXRhLCBmb3JnZS5wa2NzNy5hc24xLmVuY3J5cHRlZERhdGFWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIEVuY3J5cHRlZENvbnRlbnRJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLmRhdGEpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAnUEtDUyMxMiBFbmNyeXB0ZWRDb250ZW50SW5mbyBDb250ZW50VHlwZSBpcyBub3QgRGF0YS4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgY2lwaGVyXG4gIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNBbGdvcml0aG0pO1xuICB2YXIgY2lwaGVyID0gcGtpLnBiZS5nZXRDaXBoZXIob2lkLCBjYXB0dXJlLmVuY1BhcmFtZXRlciwgcGFzc3dvcmQpO1xuXG4gIC8vIGdldCBlbmNyeXB0ZWQgZGF0YVxuICB2YXIgZW5jcnlwdGVkQ29udGVudEFzbjEgPSBfZGVjb2RlUGtjczdEYXRhKGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudEFzbjEpO1xuICB2YXIgZW5jcnlwdGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZW5jcnlwdGVkQ29udGVudEFzbjEudmFsdWUpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoIWNpcGhlci5maW5pc2goKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgUEtDUyMxMiBTYWZlQ29udGVudHMuJyk7XG4gIH1cblxuICByZXR1cm4gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNhZmVDb250ZW50cyAoQkVSLWVuY29kZWQpIGludG8gYXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKlxuICogVGhlIHNhZmVDb250ZW50cyBpcyBhIEJFUi1lbmNvZGVkIFNFUVVFTkNFIE9GIFNhZmVCYWcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNhZmVDb250ZW50cyBCRVItZW5jb2RlZCBzYWZlQ29udGVudHMuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVTYWZlQ29udGVudHMoc2FmZUNvbnRlbnRzLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGlmIHN0cmljdCBhbmQgbm8gc2FmZSBjb250ZW50cywgcmV0dXJuIGVtcHR5IHNhZmVzXG4gIGlmKCFzdHJpY3QgJiYgc2FmZUNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIGFjdHVhbGx5IGl0J3MgQkVSLWVuY29kZWRcbiAgc2FmZUNvbnRlbnRzID0gYXNuMS5mcm9tRGVyKHNhZmVDb250ZW50cywgc3RyaWN0KTtcblxuICBpZihzYWZlQ29udGVudHMudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgc2FmZUNvbnRlbnRzLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgIHNhZmVDb250ZW50cy5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdQS0NTIzEyIFNhZmVDb250ZW50cyBleHBlY3RlZCB0byBiZSBhIFNFUVVFTkNFIE9GIFNhZmVCYWcuJyk7XG4gIH1cblxuICB2YXIgcmVzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzYWZlQ29udGVudHMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2FmZUJhZyA9IHNhZmVDb250ZW50cy52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIFNhZmVCYWcgYW5kIGNhcHR1cmUgZGF0YVxuICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGlmKCFhc24xLnZhbGlkYXRlKHNhZmVCYWcsIHNhZmVCYWdWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgU2FmZUJhZy4nKTtcbiAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8qIENyZWF0ZSBiYWcgb2JqZWN0IGFuZCBwdXNoIHRvIHJlc3VsdCBhcnJheS4gKi9cbiAgICB2YXIgYmFnID0ge1xuICAgICAgdHlwZTogYXNuMS5kZXJUb09pZChjYXB0dXJlLmJhZ0lkKSxcbiAgICAgIGF0dHJpYnV0ZXM6IF9kZWNvZGVCYWdBdHRyaWJ1dGVzKGNhcHR1cmUuYmFnQXR0cmlidXRlcylcbiAgICB9O1xuICAgIHJlcy5wdXNoKGJhZyk7XG5cbiAgICB2YXIgdmFsaWRhdG9yLCBkZWNvZGVyO1xuICAgIHZhciBiYWdBc24xID0gY2FwdHVyZS5iYWdWYWx1ZS52YWx1ZVswXTtcbiAgICBzd2l0Y2goYmFnLnR5cGUpIHtcbiAgICAgIGNhc2UgcGtpLm9pZHMucGtjczhTaHJvdWRlZEtleUJhZzpcbiAgICAgICAgLyogYmFnQXNuMSBoYXMgYSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbywgd2hpY2ggd2UgbmVlZCB0byBkZWNyeXB0LlxuICAgICAgICAgICBBZnRlcndhcmRzIHdlIGNhbiBoYW5kbGUgaXQgbGlrZSBhIGtleUJhZyxcbiAgICAgICAgICAgd2hpY2ggaXMgYSBQcml2YXRlS2V5SW5mby4gKi9cbiAgICAgICAgYmFnQXNuMSA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYmFnQXNuMSwgcGFzc3dvcmQpO1xuICAgICAgICBpZihiYWdBc24xID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1VuYWJsZSB0byBkZWNyeXB0IFBLQ1MjOCBTaHJvdWRlZEtleUJhZywgd3JvbmcgcGFzc3dvcmQ/Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgcGtpLm9pZHMua2V5QmFnOlxuICAgICAgICAvKiBBIFBLQ1MjMTIga2V5QmFnIGlzIGEgc2ltcGxlIFByaXZhdGVLZXlJbmZvIGFzIHVuZGVyc3Rvb2QgYnkgb3VyXG4gICAgICAgICAgIFBLSSBtb2R1bGUsIGhlbmNlIHdlIGRvbid0IGhhdmUgdG8gZG8gdmFsaWRhdGlvbi9jYXB0dXJpbmcgaGVyZSxcbiAgICAgICAgICAganVzdCBwYXNzIHdoYXQgd2UgYWxyZWFkeSBnb3QuICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYmFnLmtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoYmFnQXNuMSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSB1bmtub3duIGtleSB0eXBlLCBwYXNzIGFzbjEgdmFsdWVcbiAgICAgICAgICBiYWcua2V5ID0gbnVsbDtcbiAgICAgICAgICBiYWcuYXNuMSA9IGJhZ0FzbjE7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7ICAvKiBOb3RoaW5nIG1vcmUgdG8gZG8uICovXG5cbiAgICAgIGNhc2UgcGtpLm9pZHMuY2VydEJhZzpcbiAgICAgICAgLyogQSBQS0NTIzEyIGNlcnRCYWcgY2FuIHdyYXAgYm90aCBYLjUwOSBhbmQgc2RzaSBjZXJ0aWZpY2F0ZXMuXG4gICAgICAgICAgIFRoZXJlZm9yZSBwdXQgdGhlIFNhZmVCYWcgY29udGVudCB0aHJvdWdoIGFub3RoZXIgdmFsaWRhdG9yIHRvXG4gICAgICAgICAgIGNhcHR1cmUgdGhlIGZpZWxkcy4gIEFmdGVyd2FyZHMgY2hlY2sgJiBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICAgICAgdmFsaWRhdG9yID0gY2VydEJhZ1ZhbGlkYXRvcjtcbiAgICAgICAgZGVjb2RlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0SWQpICE9PSBwa2kub2lkcy54NTA5Q2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1Vuc3VwcG9ydGVkIGNlcnRpZmljYXRlIHR5cGUsIG9ubHkgWC41MDkgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRJZCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0cnVlPXByb2R1Y2UgY2VydCBoYXNoXG4gICAgICAgICAgdmFyIGNlcnRBc24xID0gYXNuMS5mcm9tRGVyKGNhcHR1cmUuY2VydCwgc3RyaWN0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmFnLmNlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tQXNuMShjZXJ0QXNuMSwgdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBjZXJ0IHR5cGUsIHBhc3MgYXNuMSB2YWx1ZVxuICAgICAgICAgICAgYmFnLmNlcnQgPSBudWxsO1xuICAgICAgICAgICAgYmFnLmFzbjEgPSBjZXJ0QXNuMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBLQ1MjMTIgU2FmZUJhZyB0eXBlLicpO1xuICAgICAgICBlcnJvci5vaWQgPSBiYWcudHlwZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLyogVmFsaWRhdGUgU2FmZUJhZyB2YWx1ZSAoaS5lLiBDZXJ0QmFnLCBldGMuKSBhbmQgY2FwdHVyZSBkYXRhIGlmIG5lZWRlZC4gKi9cbiAgICBpZih2YWxpZGF0b3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICFhc24xLnZhbGlkYXRlKGJhZ0FzbjEsIHZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyICcgKyB2YWxpZGF0b3IubmFtZSk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvKiBDYWxsIGRlY29kZXIgZnVuY3Rpb24gZnJvbSBhYm92ZSB0byBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICBkZWNvZGVyKCk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNFVCBPRiBQS0NTMTJBdHRyaWJ1dGUgaW50byBKYXZhU2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIChBU04uMSBvYmplY3QpLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUJhZ0F0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICB2YXIgZGVjb2RlZEF0dHJzID0ge307XG5cbiAgaWYoYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZighYXNuMS52YWxpZGF0ZShhdHRyaWJ1dGVzW2ldLCBhdHRyaWJ1dGVWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyIEJhZ0F0dHJpYnV0ZS4nKTtcbiAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5vaWQpO1xuICAgICAgaWYocGtpLm9pZHNbb2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlLCBpZ25vcmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0gPSBbXTtcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBjYXB0dXJlLnZhbHVlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0ucHVzaChjYXB0dXJlLnZhbHVlc1tqXS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZWRBdHRycztcbn1cblxuLyoqXG4gKiBXcmFwcyBhIHByaXZhdGUga2V5IGFuZCBjZXJ0aWZpY2F0ZSBpbiBhIFBLQ1MjMTIgUEZYIHdyYXBwZXIuIElmIGFcbiAqIHBhc3N3b3JkIGlzIHByb3ZpZGVkIHRoZW4gdGhlIHByaXZhdGUga2V5IHdpbGwgYmUgZW5jcnlwdGVkLlxuICpcbiAqIEFuIGVudGlyZSBjZXJ0aWZpY2F0ZSBjaGFpbiBtYXkgYWxzbyBiZSBpbmNsdWRlZC4gVG8gZG8gdGhpcywgcGFzc1xuICogYW4gYXJyYXkgZm9yIHRoZSBcImNlcnRcIiBwYXJhbWV0ZXIgd2hlcmUgdGhlIGZpcnN0IGNlcnRpZmljYXRlIGlzXG4gKiB0aGUgb25lIHRoYXQgaXMgcGFpcmVkIHdpdGggdGhlIHByaXZhdGUga2V5IGFuZCBlYWNoIHN1YnNlcXVlbnQgb25lXG4gKiB2ZXJpZmllcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgY2VydGlmaWNhdGVzIG1heSBiZSBpbiBQRU0gZm9ybWF0IG9yXG4gKiBoYXZlIGJlZW4gYWxyZWFkeSBwYXJzZWQgYnkgRm9yZ2UuXG4gKlxuICogQHRvZG8gaW1wbGVtZW50IHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gZm9yIHRoZSB3aG9sZSBwYWNrYWdlXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgKG1heSBiZSBhbiBhcnJheSBvZiBjZXJ0aWZpY2F0ZXMgaW4gb3JkZXJcbiAqICAgICAgICAgIHRvIHNwZWNpZnkgYSBjZXJ0aWZpY2F0ZSBjaGFpbikuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdhZXMxMjgnLCAnYWVzMTkyJywgJ2FlczI1NicsICczZGVzJyksIGRlZmF1bHRzIHRvICdhZXMxMjgnLlxuICogICAgICAgICAgY291bnQgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZSB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIHVzZU1hYyB0cnVlIHRvIGluY2x1ZGUgYSBNQUMsIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqICAgICAgICAgIGxvY2FsS2V5SWQgdGhlIGxvY2FsIGtleSBJRCB0byB1c2UsIGluIGhleC5cbiAqICAgICAgICAgIGZyaWVuZGx5TmFtZSB0aGUgZnJpZW5kbHkgbmFtZSB0byB1c2UuXG4gKiAgICAgICAgICBnZW5lcmF0ZUxvY2FsS2V5SWQgdHJ1ZSB0byBnZW5lcmF0ZSBhIHJhbmRvbSBsb2NhbCBrZXkgSUQsXG4gKiAgICAgICAgICAgIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQS0NTIzEyIFBGWCBBU04uMSBvYmplY3QuXG4gKi9cbnAxMi50b1BrY3MxMkFzbjEgPSBmdW5jdGlvbihrZXksIGNlcnQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc2FsdFNpemUgPSBvcHRpb25zLnNhbHRTaXplIHx8IDg7XG4gIG9wdGlvbnMuY291bnQgPSBvcHRpb25zLmNvdW50IHx8IDIwNDg7XG4gIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgb3B0aW9ucy5lbmNBbGdvcml0aG0gfHwgJ2FlczEyOCc7XG4gIGlmKCEoJ3VzZU1hYycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnVzZU1hYyA9IHRydWU7XG4gIH1cbiAgaWYoISgnbG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmxvY2FsS2V5SWQgPSBudWxsO1xuICB9XG4gIGlmKCEoJ2dlbmVyYXRlTG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmdlbmVyYXRlTG9jYWxLZXlJZCA9IHRydWU7XG4gIH1cblxuICB2YXIgbG9jYWxLZXlJZCA9IG9wdGlvbnMubG9jYWxLZXlJZDtcbiAgdmFyIGJhZ0F0dHJzO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgbG9jYWxLZXlJZCA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhsb2NhbEtleUlkKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZ2VuZXJhdGVMb2NhbEtleUlkKSB7XG4gICAgLy8gdXNlIFNIQS0xIG9mIHBhaXJlZCBjZXJ0LCBpZiBhdmFpbGFibGVcbiAgICBpZihjZXJ0KSB7XG4gICAgICB2YXIgcGFpcmVkQ2VydCA9IGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSA/IGNlcnRbMF0gOiBjZXJ0O1xuICAgICAgaWYodHlwZW9mIHBhaXJlZENlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhaXJlZENlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tUGVtKHBhaXJlZENlcnQpO1xuICAgICAgfVxuICAgICAgdmFyIHNoYTEgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgc2hhMS51cGRhdGUoYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEocGFpcmVkQ2VydCkpLmdldEJ5dGVzKCkpO1xuICAgICAgbG9jYWxLZXlJZCA9IHNoYTEuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IGNvbnNpZGVyIHVzaW5nIFNIQS0xIG9mIHB1YmxpYyBrZXkgKHdoaWNoIGNhbiBiZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGZyb20gcHJpdmF0ZSBrZXkgY29tcG9uZW50cyksIHNlZTogY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyXG4gICAgICAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXNcbiAgICAgIGxvY2FsS2V5SWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoMjApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRycyA9IFtdO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgYXR0cnMucHVzaChcbiAgICAgIC8vIGxvY2FsS2V5SURcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYXR0cklkXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmxvY2FsS2V5SWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgICBsb2NhbEtleUlkKVxuICAgICAgICBdKVxuICAgICAgXSkpO1xuICB9XG4gIGlmKCdmcmllbmRseU5hbWUnIGluIG9wdGlvbnMpIHtcbiAgICBhdHRycy5wdXNoKFxuICAgICAgLy8gZnJpZW5kbHlOYW1lXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGF0dHJJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5mcmllbmRseU5hbWUpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CTVBTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9ucy5mcmllbmRseU5hbWUpXG4gICAgICAgIF0pXG4gICAgICBdKSk7XG4gIH1cblxuICBpZihhdHRycy5sZW5ndGggPiAwKSB7XG4gICAgYmFnQXR0cnMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgYXR0cnMpO1xuICB9XG5cbiAgLy8gY29sbGVjdCBjb250ZW50cyBmb3IgQXV0aGVudGljYXRlZFNhZmVcbiAgdmFyIGNvbnRlbnRzID0gW107XG5cbiAgLy8gY3JlYXRlIHNhZmUgYmFnKHMpIGZvciBjZXJ0aWZpY2F0ZSBjaGFpblxuICB2YXIgY2hhaW4gPSBbXTtcbiAgaWYoY2VydCAhPT0gbnVsbCkge1xuICAgIGlmKGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSkge1xuICAgICAgY2hhaW4gPSBjZXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFpbiA9IFtjZXJ0XTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2VydFNhZmVCYWdzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjaGFpbi5sZW5ndGg7ICsraSkge1xuICAgIC8vIGNvbnZlcnQgY2VydCBmcm9tIFBFTSBhcyBuZWNlc3NhcnlcbiAgICBjZXJ0ID0gY2hhaW5baV07XG4gICAgaWYodHlwZW9mIGNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjZXJ0ID0gcGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICB9XG5cbiAgICAvLyBTYWZlQmFnXG4gICAgdmFyIGNlcnRCYWdBdHRycyA9IChpID09PSAwKSA/IGJhZ0F0dHJzIDogdW5kZWZpbmVkO1xuICAgIHZhciBjZXJ0QXNuMSA9IHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KTtcbiAgICB2YXIgY2VydFNhZmVCYWcgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5jZXJ0QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gQ2VydEJhZ1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIC8vIGNlcnRJZFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLng1MDlDZXJ0aWZpY2F0ZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgICAvLyBjZXJ0VmFsdWUgKHg1MDlDZXJ0aWZpY2F0ZSlcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLnRvRGVyKGNlcnRBc24xKS5nZXRCeXRlcygpKVxuICAgICAgICAgICAgXSldKV0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgY2VydEJhZ0F0dHJzXG4gICAgICBdKTtcbiAgICBjZXJ0U2FmZUJhZ3MucHVzaChjZXJ0U2FmZUJhZyk7XG4gIH1cblxuICBpZihjZXJ0U2FmZUJhZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBjZXJ0U2FmZUNvbnRlbnRzID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBjZXJ0U2FmZUJhZ3MpO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIgY2VydENJID1cbiAgICAgIC8vIFBLQ1MjNyBDb250ZW50SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBjb250ZW50VHlwZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEudG9EZXIoY2VydFNhZmVDb250ZW50cykuZ2V0Qnl0ZXMoKSlcbiAgICAgICAgXSlcbiAgICAgIF0pO1xuICAgIGNvbnRlbnRzLnB1c2goY2VydENJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBzYWZlIGNvbnRlbnRzIGZvciBwcml2YXRlIGtleVxuICB2YXIga2V5QmFnID0gbnVsbDtcbiAgaWYoa2V5ICE9PSBudWxsKSB7XG4gICAgLy8gU2FmZUJhZ1xuICAgIHZhciBwa0FzbjEgPSBwa2kud3JhcFJzYVByaXZhdGVLZXkocGtpLnByaXZhdGVLZXlUb0FzbjEoa2V5KSk7XG4gICAgaWYocGFzc3dvcmQgPT09IG51bGwpIHtcbiAgICAgIC8vIG5vIGVuY3J5cHRpb25cbiAgICAgIGtleUJhZyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYmFnSWRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMua2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa0FzbjFcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGJhZ0F0dHJpYnV0ZXMgKE9QVElPTkFMKVxuICAgICAgICBiYWdBdHRyc1xuICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuY3J5cHRlZCBQcml2YXRlS2V5SW5mb1xuICAgICAga2V5QmFnID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5wa2NzOFNocm91ZGVkS2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa2kuZW5jcnlwdFByaXZhdGVLZXlJbmZvKHBrQXNuMSwgcGFzc3dvcmQsIG9wdGlvbnMpXG4gICAgICAgIF0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgYmFnQXR0cnNcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBrZXlTYWZlQ29udGVudHMgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW2tleUJhZ10pO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIga2V5Q0kgPVxuICAgICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGNvbnRlbnRUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAvLyBPSUQgZm9yIHRoZSBjb250ZW50IHR5cGUgaXMgJ2RhdGEnXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5kYXRhKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gY29udGVudFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS50b0RlcihrZXlTYWZlQ29udGVudHMpLmdldEJ5dGVzKCkpXG4gICAgICAgIF0pXG4gICAgICBdKTtcbiAgICBjb250ZW50cy5wdXNoKGtleUNJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBBdXRoZW50aWNhdGVkU2FmZSBieSBzdHJpbmdpbmcgdG9nZXRoZXIgdGhlIGNvbnRlbnRzXG4gIHZhciBzYWZlID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgY29udGVudHMpO1xuXG4gIHZhciBtYWNEYXRhO1xuICBpZihvcHRpb25zLnVzZU1hYykge1xuICAgIC8vIE1hY0RhdGFcbiAgICB2YXIgc2hhMSA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIG1hY1NhbHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKFxuICAgICAgZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG9wdGlvbnMuc2FsdFNpemUpKTtcbiAgICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgIC8vIDE2MC1iaXQga2V5XG4gICAgdmFyIGtleSA9IHAxMi5nZW5lcmF0ZUtleShwYXNzd29yZCwgbWFjU2FsdCwgMywgY291bnQsIDIwKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQoc2hhMSwga2V5KTtcbiAgICBtYWMudXBkYXRlKGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIG1hY1ZhbHVlID0gbWFjLmdldE1hYygpO1xuICAgIG1hY0RhdGEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBtYWMgRGlnZXN0SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBkaWdlc3RBbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIGFsZ29yaXRobSA9IFNIQS0xXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5zaGExKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAvLyBwYXJhbWV0ZXJzID0gTnVsbFxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgICBdKSxcbiAgICAgICAgLy8gZGlnZXN0XG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgICAgZmFsc2UsIG1hY1ZhbHVlLmdldEJ5dGVzKCkpXG4gICAgICBdKSxcbiAgICAgIC8vIG1hY1NhbHQgT0NURVQgU1RSSU5HXG4gICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIG1hY1NhbHQuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBpdGVyYXRpb25zIElOVEVHRVIgKFhYWDogT25seSBzdXBwb3J0IGNvdW50IDwgNjU1MzYpXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0Rlcihjb3VudCkuZ2V0Qnl0ZXMoKVxuICAgICAgKVxuICAgIF0pO1xuICB9XG5cbiAgLy8gUEZYXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMykuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gY29udGVudFR5cGVcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmRhdGEpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gY29udGVudFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgIGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSlcbiAgICAgIF0pXG4gICAgXSksXG4gICAgbWFjRGF0YVxuICBdKTtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucDEyLmdlbmVyYXRlS2V5ID0gZm9yZ2UucGJlLmdlbmVyYXRlUGtjczEyS2V5O1xuXG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFTTi4xIHZhbGlkYXRvcnMgZm9yIFBLQ1MjNyB2MS41LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgUEtDUyM3IGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDICMyMzE1IGZvciBkZXRhaWxzLCBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzE1LnR4dCk6XG4gKlxuICogQSBQS0NTIzcgbWVzc2FnZSBjb25zaXN0cyBvZiBhIENvbnRlbnRJbmZvIG9uIHJvb3QgbGV2ZWwsIHdoaWNoIG1heVxuICogY29udGFpbiBhbnkgbnVtYmVyIG9mIGZ1cnRoZXIgQ29udGVudEluZm8gbmVzdGVkIGludG8gaXQuXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgICAgICAgICAgICBbMF0gIEVYUExJQ0lUIEFOWSBERUZJTkVEIEJZIGNvbnRlbnRUeXBlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudFR5cGUgOjo9IE9CSkVDVCBJREVOVElGSUVSXG4gKlxuICogRW52ZWxvcGVkRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICByZWNpcGllbnRJbmZvcyAgICAgICAgICAgICBSZWNpcGllbnRJbmZvcyxcbiAqICAgZW5jcnlwdGVkQ29udGVudEluZm8gICAgICAgRW5jcnlwdGVkQ29udGVudEluZm9cbiAqIH1cbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGVuY3J5cHRlZENvbnRlbnRJbmZvICAgICAgIEVuY3J5cHRlZENvbnRlbnRJbmZvXG4gKiB9XG4gKlxuICogaWQtc2lnbmVkRGF0YSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0geyBpc28oMSkgbWVtYmVyLWJvZHkoMilcbiAqICAgdXMoODQwKSByc2Fkc2koMTEzNTQ5KSBwa2NzKDEpIHBrY3M3KDcpIDIgfVxuICpcbiAqIFNpZ25lZERhdGEgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgSU5URUdFUixcbiAqICAgZGlnZXN0QWxnb3JpdGhtcyAgRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMsXG4gKiAgIGNvbnRlbnRJbmZvICAgICAgIENvbnRlbnRJbmZvLFxuICogICBjZXJ0aWZpY2F0ZXMgICAgICBbMF0gSU1QTElDSVQgQ2VydGlmaWNhdGVzIE9QVElPTkFMLFxuICogICBjcmxzICAgICAgICAgICAgICBbMV0gSU1QTElDSVQgQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMgT1BUSU9OQUwsXG4gKiAgIHNpZ25lckluZm9zICAgICAgIFNpZ25lckluZm9zXG4gKiB9XG4gKlxuICogU2lnbmVySW5mb3MgOjo9IFNFVCBPRiBTaWduZXJJbmZvXG4gKlxuICogU2lnbmVySW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICBpc3N1ZXJBbmRTZXJpYWxOdW1iZXIgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGRpZ2VzdEFsZ29yaXRobSAgICAgICAgICAgIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICAgIFswXSBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMLFxuICogICBkaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtICBEaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGlnZXN0ICAgICAgICAgICAgRW5jcnlwdGVkRGlnZXN0LFxuICogICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICBbMV0gSU1QTElDSVQgQXR0cmlidXRlcyBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEF0dHJpYnV0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICBhdHRyVHlwZSAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgYXR0clZhbHVlcyAgU0VUIE9GIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqXG4gKiBSZWNpcGllbnRJbmZvcyA6Oj0gU0VUIE9GIFJlY2lwaWVudEluZm9cbiAqXG4gKiBFbmNyeXB0ZWRDb250ZW50SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjb250ZW50VHlwZSAgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtICBDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGVuY3J5cHRlZENvbnRlbnQgICAgICAgWzBdICBJTVBMSUNJVCBFbmNyeXB0ZWRDb250ZW50IE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIEFFUyBhbmQgREVTMywgdGhlcmUgaXMgb25seSBvbmUsXG4gKiB0aGUgSVYuXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZENvbnRlbnQgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIFJlY2lwaWVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGlzc3VlckFuZFNlcmlhbE51bWJlciAgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGtleUVuY3J5cHRpb25BbGdvcml0aG0gICAgICBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkS2V5ICAgICAgICAgICAgICAgIEVuY3J5cHRlZEtleVxuICogfVxuICpcbiAqIElzc3VlckFuZFNlcmlhbE51bWJlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBpc3N1ZXIgICAgICAgICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgICAgICAgIENlcnRpZmljYXRlU2VyaWFsTnVtYmVyXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZEtleSA6Oj0gT0NURVQgU1RSSU5HXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gc2hvcnRjdXQgZm9yIEFTTi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vLyBzaG9ydGN1dCBmb3IgUEtDUyM3IEFQSVxudmFyIHA3diA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtjczdhc24xID0gZm9yZ2UucGtjczdhc24xIHx8IHt9O1xuZm9yZ2UucGtjczcgPSBmb3JnZS5wa2NzNyB8fCB7fTtcbmZvcmdlLnBrY3M3LmFzbjEgPSBwN3Y7XG5cbnZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ29udGVudEluZm8uQ29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAwLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY29udGVudCdcbiAgfV1cbn07XG5wN3YuY29udGVudEluZm9WYWxpZGF0b3IgPSBjb250ZW50SW5mb1ZhbGlkYXRvcjtcblxudmFyIGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50VHlwZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdjb250ZW50VHlwZSdcbiAgfSwge1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNBbGdvcml0aG0nXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvLmNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtLnBhcmFtZXRlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICBjYXB0dXJlQXNuMTogJ2VuY1BhcmFtZXRlcidcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvLmVuY3J5cHRlZENvbnRlbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICAvKiBUaGUgUEtDUyM3IHN0cnVjdHVyZSBvdXRwdXQgYnkgT3BlblNTTCBzb21ld2hhdCBkaWZmZXJzIGZyb20gd2hhdFxuICAgICAqIG90aGVyIGltcGxlbWVudGF0aW9ucyBkbyBnZW5lcmF0ZS5cbiAgICAgKlxuICAgICAqIE9wZW5TU0wgZ2VuZXJhdGVzIGEgc3RydWN0dXJlIGxpa2UgdGhpczpcbiAgICAgKiBTRVFVRU5DRSB7XG4gICAgICogICAgLi4uXG4gICAgICogICAgWzBdXG4gICAgICogICAgICAgMjYgREEgNjcgRDIgMTcgOUMgNDUgM0MgQjEgMkEgQTggNTkgMkYgMjkgMzMgMzhcbiAgICAgKiAgICAgICBDMyBDMyBERiA4NiA3MSA3NCA3QSAxOSA5RiA0MCBEMCAyOSBCRSA4NSA5MCA0NVxuICAgICAqICAgICAgIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFdoZXJlYXMgb3RoZXIgaW1wbGVtZW50YXRpb25zIChhbmQgdGhpcyBQS0NTIzcgbW9kdWxlKSBnZW5lcmF0ZTpcbiAgICAgKiBTRVFVRU5DRSB7XG4gICAgICogICAgLi4uXG4gICAgICogICAgWzBdIHtcbiAgICAgKiAgICAgICBPQ1RFVCBTVFJJTkdcbiAgICAgKiAgICAgICAgICAyNiBEQSA2NyBEMiAxNyA5QyA0NSAzQyBCMSAyQSBBOCA1OSAyRiAyOSAzMyAzOFxuICAgICAqICAgICAgICAgIEMzIEMzIERGIDg2IDcxIDc0IDdBIDE5IDlGIDQwIEQwIDI5IEJFIDg1IDkwIDQ1XG4gICAgICogICAgICAgICAgLi4uXG4gICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIHN1cHBvcnQgYm90aCwgd2UganVzdCBjYXB0dXJlIHRoZSBjb250ZXh0IHNwZWNpZmljXG4gICAgICogZmllbGQgaGVyZS4gIFRoZSBPQ1RFVCBTVFJJTkcgYml0IGlzIHJlbW92ZWQgYmVsb3cuXG4gICAgICovXG4gICAgY2FwdHVyZTogJ2VuY3J5cHRlZENvbnRlbnQnLFxuICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGVkQ29udGVudEFzbjEnXG4gIH1dXG59O1xuXG5wN3YuZW52ZWxvcGVkRGF0YVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VudmVsb3BlZERhdGEnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdFbnZlbG9wZWREYXRhLlZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAnRW52ZWxvcGVkRGF0YS5SZWNpcGllbnRJbmZvcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdyZWNpcGllbnRJbmZvcydcbiAgfV0uY29uY2F0KGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yKVxufTtcblxucDd2LmVuY3J5cHRlZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbmNyeXB0ZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9XS5jb25jYXQoZW5jcnlwdGVkQ29udGVudEluZm9WYWxpZGF0b3IpXG59O1xuXG52YXIgc2lnbmVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnU2lnbmVySW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1NpZ25lckluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1NpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnaXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlci5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2VyaWFsJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZGlnZXN0QWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdkaWdlc3RQYXJhbWV0ZXInLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmU6ICdzaWduYXR1cmVBbGdvcml0aG0nXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5lbmNyeXB0ZWREaWdlc3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzaWduYXR1cmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby51bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ3VuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnXG4gIH1dXG59O1xuXG5wN3Yuc2lnbmVkRGF0YVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1NpZ25lZERhdGEnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTaWduZWREYXRhLlZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5EaWdlc3RBbGdvcml0aG1zJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2RpZ2VzdEFsZ29yaXRobXMnXG4gIH0sXG4gIGNvbnRlbnRJbmZvVmFsaWRhdG9yLFxuICB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuQ2VydGlmaWNhdGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0ZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5DZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0cycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY3JscydcbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZWREYXRhLlNpZ25lckluZm9zJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjYXB0dXJlOiAnc2lnbmVySW5mb3MnLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbc2lnbmVyVmFsaWRhdG9yXVxuICB9XVxufTtcblxucDd2LnJlY2lwaWVudEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdSZWNpcGllbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnaXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2VyaWFsJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5rZXlFbmNyeXB0aW9uQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNBbGdvcml0aG0nXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdlbmNQYXJhbWV0ZXInXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmVuY3J5cHRlZEtleScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2VuY0tleSdcbiAgfV1cbn07XG5cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIE5vZGUuanMgbW9kdWxlIGZvciBGb3JnZSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKlxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZiA9IGZvcmdlLm1nZiB8fCB7fTtcbmZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMTtcblxuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gTUdGMS5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZm9yZ2UubWdmID0gZm9yZ2UubWdmIHx8IHt9O1xudmFyIG1nZjEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMSA9IGZvcmdlLm1nZjEgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIE1HRjEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IEFQSSB0byB1c2UgKGVnOiBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpKS5cbiAqXG4gKiBAcmV0dXJuIGEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqL1xubWdmMS5jcmVhdGUgPSBmdW5jdGlvbihtZCkge1xuICB2YXIgbWdmID0ge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG1hc2sgb2Ygc3BlY2lmaWVkIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWVkIFRoZSBzZWVkIGZvciBtYXNrIGdlbmVyYXRpb24uXG4gICAgICogQHBhcmFtIG1hc2tMZW4gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCBtYXNrLlxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihzZWVkLCBtYXNrTGVuKSB7XG4gICAgICAvKiAyLiBMZXQgVCBiZSB0aGUgZW1wdHkgb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgdmFyIHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgICAgIC8qIDMuIEZvciBjb3VudGVyIGZyb20gMCB0byBjZWlsKG1hc2tMZW4gLyBoTGVuKSwgZG8gdGhlIGZvbGxvd2luZzogKi9cbiAgICAgIHZhciBsZW4gPSBNYXRoLmNlaWwobWFza0xlbiAvIG1kLmRpZ2VzdExlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLyogYS4gQ29udmVydCBjb3VudGVyIHRvIGFuIG9jdGV0IHN0cmluZyBDIG9mIGxlbmd0aCA0IG9jdGV0cyAqL1xuICAgICAgICB2YXIgYyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgICAgYy5wdXRJbnQzMihpKTtcblxuICAgICAgICAvKiBiLiBDb25jYXRlbmF0ZSB0aGUgaGFzaCBvZiB0aGUgc2VlZCBtZ2ZTZWVkIGFuZCBDIHRvIHRoZSBvY3RldFxuICAgICAgICAgKiBzdHJpbmcgVDogKi9cbiAgICAgICAgbWQuc3RhcnQoKTtcbiAgICAgICAgbWQudXBkYXRlKHNlZWQgKyBjLmdldEJ5dGVzKCkpO1xuICAgICAgICB0LnB1dEJ1ZmZlcihtZC5kaWdlc3QoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qIE91dHB1dCB0aGUgbGVhZGluZyBtYXNrTGVuIG9jdGV0cyBvZiBUIGFzIHRoZSBvY3RldCBzdHJpbmcgbWFzay4gKi9cbiAgICAgIHQudHJ1bmNhdGUodC5sZW5ndGgoKSAtIG1hc2tMZW4pO1xuICAgICAgcmV0dXJuIHQuZ2V0Qnl0ZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIG1nZjtcbn07XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9