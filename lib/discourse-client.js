(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("discourse-client", [], factory);
	else if(typeof exports === 'object')
		exports["discourse-client"] = factory();
	else
		root["discourse-client"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"discourse-client.js": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// The chunk loading function for additional chunks
/******/ 	// Since all referenced chunks are already included
/******/ 	// in this file, this function is empty here.
/******/ 	__webpack_require__.e = function requireEnsure() {
/******/ 		return Promise.resolve();
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonpdiscourse_client"] = window["webpackJsonpdiscourse_client"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/discourse.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@ungap/url-search-params/esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ungap/url-search-params/esm/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*! (c) Andrea Giammarchi - ISC */
var self = undefined || /* istanbul ignore next */ {};
try {
  (function (URLSearchParams, plus) {
    if (
      new URLSearchParams('q=%2B').get('q') !== plus ||
      new URLSearchParams({q: plus}).get('q') !== plus ||
      new URLSearchParams([['q', plus]]).get('q') !== plus ||
      new URLSearchParams('q=\n').toString() !== 'q=%0A' ||
      new URLSearchParams({q: ' &'}).toString() !== 'q=+%26'
    )
      throw URLSearchParams;
    self.URLSearchParams = URLSearchParams;
  }(URLSearchParams, '+'));
} catch(URLSearchParams) {
  (function (Object, String, isArray) {'use strict';
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var find = /[!'\(\)~]|%20|%00/g;
    var plus = /\+/g;
    var replace = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    var proto = {
      append: function (key, value) {
        appendTo(this._ungap, key, value);
      },
      delete: function (key) {
        delete this._ungap[key];
      },
      get: function (key) {
        return this.has(key) ? this._ungap[key][0] : null;
      },
      getAll: function (key) {
        return this.has(key) ? this._ungap[key].slice(0) : [];
      },
      has: function (key) {
        return key in this._ungap;
      },
      set: function (key, value) {
        this._ungap[key] = [String(value)];
      },
      forEach: function (callback, thisArg) {
        var self = this;
        for (var key in self._ungap)
          self._ungap[key].forEach(invoke, key);
        function invoke(value) {
          callback.call(thisArg, value, String(key), self);
        }
      },
      toJSON: function () {
        return {};
      },
      toString: function () {
        var query = [];
        for (var key in this._ungap) {
          var encoded = encode(key);
          for (var
            i = 0,
            value = this._ungap[key];
            i < value.length; i++
          ) {
            query.push(encoded + '=' + encode(value[i]));
          }
        }
        return query.join('&');
      }
    };
    for (var key in proto)
      defineProperty(URLSearchParams.prototype, key, {
        configurable: true,
        writable: true,
        value: proto[key]
      });
    self.URLSearchParams = URLSearchParams;
    function URLSearchParams(query) {
      var dict = create(null);
      defineProperty(this, '_ungap', {value: dict});
      switch (true) {
        case !query:
          break;
        case typeof query === 'string':
          if (query.charAt(0) === '?') {
            query = query.slice(1);
          }
          for (var
            pairs = query.split('&'),
            i = 0,
            length = pairs.length; i < length; i++
          ) {
            var value = pairs[i];
            var index = value.indexOf('=');
            if (-1 < index) {
              appendTo(
                dict,
                decode(value.slice(0, index)),
                decode(value.slice(index + 1))
              );
            } else if (value.length){
              appendTo(
                dict,
                decode(value),
                ''
              );
            }
          }
          break;
        case isArray(query):
          for (var
            i = 0,
            length = query.length; i < length; i++
          ) {
            var value = query[i];
            appendTo(dict, value[0], value[1]);
          }
          break;
        case 'forEach' in query:
          query.forEach(addEach, dict);
          break;
        default:
          for (var key in query)
            appendTo(dict, key, query[key]);
      }
    }

    function addEach(value, key) {
      appendTo(this, key, value);
    }
    
    function appendTo(dict, key, value) {
      var res = isArray(value) ? value.join(',') : value;
      if (key in dict)
        dict[key].push(res);
      else
        dict[key] = [res];
    }
    
    function decode(str) {
      return decodeURIComponent(str.replace(plus, ' '));
    }
    
    function encode(str) {
      return encodeURIComponent(str).replace(find, replacer);
    }

    function replacer(match) {
      return replace[match];
    }

  }(Object, String, Array.isArray));
}

(function (URLSearchParamsProto) {

  var iterable = false;
  try { iterable = !!Symbol.iterator; } catch (o_O) {}

  /* istanbul ignore else */
  if (!('forEach' in URLSearchParamsProto)) {
    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
      var self = this;
      var names = Object.create(null);
      this.toString()
          .replace(/=[\s\S]*?(?:&|$)/g, '=')
          .split('=')
          .forEach(function (name) {
            if (!name.length || name in names)
              return;
            (names[name] = self.getAll(name)).forEach(function(value) {
              callback.call(thisArg, value, name, self);
            });
          });
    };
  }

  /* istanbul ignore else */
  if (!('keys' in URLSearchParamsProto)) {
    URLSearchParamsProto.keys = function keys() {
      return iterator(this, function(value, key) { this.push(key); });
    };
  }

   /* istanbul ignore else */
  if (!('values' in URLSearchParamsProto)) {
    URLSearchParamsProto.values = function values() {
      return iterator(this, function(value, key) { this.push(value); });
    };
  }

  /* istanbul ignore else */
  if (!('entries' in URLSearchParamsProto)) {
    URLSearchParamsProto.entries = function entries() {
      return iterator(this, function(value, key) { this.push([key, value]); });
    };
  }

  /* istanbul ignore else */
  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {
    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
  }

  /* istanbul ignore else */
  if (!('sort' in URLSearchParamsProto)) {
    URLSearchParamsProto.sort = function sort() {
      var
        entries = this.entries(),
        entry = entries.next(),
        done = entry.done,
        keys = [],
        values = Object.create(null),
        i, key, value
      ;
      while (!done) {
        value = entry.value;
        key = value[0];
        keys.push(key);
        if (!(key in values)) {
          values[key] = [];
        }
        values[key].push(value[1]);
        entry = entries.next();
        done = entry.done;
      }
      // not the champion in efficiency
      // but these two bits just do the job
      keys.sort();
      for (i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        this.append(key, values[key].shift());
      }
    };
  }

  function iterator(self, callback) {
    var items = [];
    self.forEach(callback, items);
    return iterable ?
      items[Symbol.iterator]() :
      {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value};
        }
      };
  }

  /* istanbul ignore next */
  (function (Object) {
    var
      dP = Object.defineProperty,
      gOPD = Object.getOwnPropertyDescriptor,
      createSearchParamsPollute = function (search) {
        function append(name, value) {
          URLSearchParamsProto.append.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function del(name) {
          URLSearchParamsProto.delete.call(this, name);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function set(name, value) {
          URLSearchParamsProto.set.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        return function (sp, value) {
          sp.append = append;
          sp.delete = del;
          sp.set = set;
          return dP(sp, '_usp', {
            configurable: true,
            writable: true,
            value: value
          });
        };
      },
      createSearchParamsCreate = function (polluteSearchParams) {
        return function (obj, sp) {
          dP(
            obj, '_searchParams', {
              configurable: true,
              writable: true,
              value: polluteSearchParams(sp, obj)
            }
          );
          return sp;
        };
      },
      updateSearchParams = function (sp) {
        var append = sp.append;
        sp.append = URLSearchParamsProto.append;
        URLSearchParams.call(sp, sp._usp.search.slice(1));
        sp.append = append;
      },
      verifySearchParams = function (obj, Class) {
        if (!(obj instanceof Class)) throw new TypeError(
          "'searchParams' accessed on an object that " +
          "does not implement interface " + Class.name
        );
      },
      upgradeClass = function (Class) {
        var
          ClassProto = Class.prototype,
          searchParams = gOPD(ClassProto, 'searchParams'),
          href = gOPD(ClassProto, 'href'),
          search = gOPD(ClassProto, 'search'),
          createSearchParams
        ;
        if (!searchParams && search && search.set) {
          createSearchParams = createSearchParamsCreate(
            createSearchParamsPollute(search)
          );
          Object.defineProperties(
            ClassProto,
            {
              href: {
                get: function () {
                  return href.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  href.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              search: {
                get: function () {
                  return search.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  search.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              searchParams: {
                get: function () {
                  verifySearchParams(this, Class);
                  return this._searchParams || createSearchParams(
                    this,
                    new URLSearchParams(this.search.slice(1))
                  );
                },
                set: function (sp) {
                  verifySearchParams(this, Class);
                  createSearchParams(this, sp);
                }
              }
            }
          );
        }
      }
    ;
    try {
      upgradeClass(HTMLAnchorElement);
      if (/^function|object$/.test(typeof URL) && URL.prototype)
        upgradeClass(URL);
    } catch (meh) {}
  }(Object));

}(self.URLSearchParams.prototype, Object));
/* harmony default export */ __webpack_exports__["default"] = (self.URLSearchParams);


/***/ }),

/***/ "./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cacheAdapterEnhancer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buildSortedURL */ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js");
/* harmony import */ var _utils_isCacheLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/isCacheLike */ "./node_modules/axios-extensions/esm/utils/isCacheLike.js");
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-12
 */




var FIVE_MINUTES = 1000 * 60 * 5;
var CAPACITY = 100;
function cacheAdapterEnhancer(adapter, options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    var _a = options.enabledByDefault, enabledByDefault = _a === void 0 ? true : _a, _b = options.cacheFlag, cacheFlag = _b === void 0 ? 'cache' : _b, _c = options.defaultCache, defaultCache = _c === void 0 ? new lru_cache__WEBPACK_IMPORTED_MODULE_1___default.a({ maxAge: FIVE_MINUTES, max: CAPACITY }) : _c;
    return function (config) {
        var url = config.url, method = config.method, params = config.params, paramsSerializer = config.paramsSerializer, forceUpdate = config.forceUpdate;
        var useCache = (config[cacheFlag] !== void 0 && config[cacheFlag] !== null) ? config[cacheFlag] : enabledByDefault;
        if (method === 'get' && useCache) {
            // if had provide a specified cache, then use it instead
            var cache_1 = Object(_utils_isCacheLike__WEBPACK_IMPORTED_MODULE_3__["default"])(useCache) ? useCache : defaultCache;
            // build the index according to the url and params
            var index_1 = Object(_utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__["default"])(url, params, paramsSerializer);
            var responsePromise = cache_1.get(index_1);
            if (!responsePromise || forceUpdate) {
                responsePromise = (function () { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
                    var reason_1;
                    return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, adapter(config)];
                            case 1: return [2 /*return*/, _a.sent()];
                            case 2:
                                reason_1 = _a.sent();
                                cache_1.del(index_1);
                                throw reason_1;
                            case 3: return [2 /*return*/];
                        }
                    });
                }); })();
                // put the promise for the non-transformed response into cache as a placeholder
                cache_1.set(index_1, responsePromise);
                return responsePromise;
            }
            /* istanbul ignore next */
            if (process.env.LOGGER_LEVEL === 'info') {
                // eslint-disable-next-line no-console
                console.info("request cached by cache adapter: " + index_1);
            }
            return responsePromise;
        }
        return adapter(config);
    };
}
//# sourceMappingURL=cacheAdapterEnhancer.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios-extensions/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/axios-extensions/esm/index.js ***!
  \****************************************************/
/*! exports provided: Cache, cacheAdapterEnhancer, throttleAdapterEnhancer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a; });
/* harmony import */ var _cacheAdapterEnhancer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cacheAdapterEnhancer */ "./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cacheAdapterEnhancer", function() { return _cacheAdapterEnhancer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _throttleAdapterEnhancer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./throttleAdapterEnhancer */ "./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttleAdapterEnhancer", function() { return _throttleAdapterEnhancer__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-09-28
 */




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return throttleAdapterEnhancer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buildSortedURL */ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js");
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-11
 */



function throttleAdapterEnhancer(adapter, options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    var _a = options.threshold, threshold = _a === void 0 ? 1000 : _a, _b = options.cache, cache = _b === void 0 ? new lru_cache__WEBPACK_IMPORTED_MODULE_1___default.a({ max: 10 }) : _b;
    var recordCacheWithRequest = function (index, config) {
        var responsePromise = (function () { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
            var response, reason_1;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, adapter(config)];
                    case 1:
                        response = _a.sent();
                        cache.set(index, {
                            timestamp: Date.now(),
                            value: Promise.resolve(response),
                        });
                        return [2 /*return*/, response];
                    case 2:
                        reason_1 = _a.sent();
                        cache.del(index);
                        throw reason_1;
                    case 3: return [2 /*return*/];
                }
            });
        }); })();
        cache.set(index, {
            timestamp: Date.now(),
            value: responsePromise,
        });
        return responsePromise;
    };
    return function (config) {
        var url = config.url, method = config.method, params = config.params, paramsSerializer = config.paramsSerializer;
        var index = Object(_utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__["default"])(url, params, paramsSerializer);
        var now = Date.now();
        var cachedRecord = cache.get(index) || { timestamp: now };
        if (method === 'get') {
            if (now - cachedRecord.timestamp <= threshold) {
                var responsePromise = cachedRecord.value;
                if (responsePromise) {
                    /* istanbul ignore next */
                    if (process.env.LOGGER_LEVEL === 'info') {
                        // eslint-disable-next-line no-console
                        console.info("request cached by throttle adapter: " + index);
                    }
                    return responsePromise;
                }
            }
            return recordCacheWithRequest(index, config);
        }
        return adapter(config);
    };
}
//# sourceMappingURL=throttleAdapterEnhancer.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js":
/*!*******************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/utils/buildSortedURL.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return buildSortedURL; });
/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios/lib/helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-12
 */

function buildSortedURL() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var builtURL = axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0___default.a.apply(void 0, args);
    var _a = builtURL.split('?'), urlPath = _a[0], queryString = _a[1];
    if (queryString) {
        var paramsPair = queryString.split('&');
        return urlPath + "?" + paramsPair.sort().join('&');
    }
    return builtURL;
}
//# sourceMappingURL=buildSortedURL.js.map

/***/ }),

/***/ "./node_modules/axios-extensions/esm/utils/isCacheLike.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/utils/isCacheLike.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isCacheLike; });
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2018-03-19
 */
function isCacheLike(cache) {
    return !!(cache.set && cache.get && cache.del &&
        typeof cache.get === 'function' && typeof cache.set === 'function' && typeof cache.del === 'function');
}
//# sourceMappingURL=isCacheLike.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(/*! ./../helpers/btoa */ "./node_modules/axios/lib/helpers/btoa.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ( true &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
var isAbsoluteURL = __webpack_require__(/*! ./../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ./../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/btoa.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/btoa.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/internals/a-function.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var UNSCOPABLES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('unscopables');
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  hide(ArrayPrototype, UNSCOPABLES, create(null));
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/internals/advance-string-index.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/advance-string-index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var codePointAt = __webpack_require__(/*! ../internals/string-at */ "./node_modules/core-js/internals/string-at.js");

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? codePointAt(S, index, true).length : 1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-instance.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-view-core.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-view-core.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var TO_STRING_TAG = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('toStringTag');
var TYPED_ARRAY_TAG = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js")('TYPED_ARRAY_TAG');

var DataView = global.DataView;
var DataViewPrototype = DataView && DataView.prototype;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var NATIVE_ARRAY_BUFFER = !!(global.ArrayBuffer && global.DataView);
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf;
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportProto = function (KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportStatic = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    hide(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

// WebKit bug - the same parent prototype for typed arrays and data view
if (NATIVE_ARRAY_BUFFER && setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
  setPrototypeOf(DataViewPrototype, ObjectPrototype);
}

module.exports = {
  NATIVE_ARRAY_BUFFER: NATIVE_ARRAY_BUFFER,
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportProto: exportProto,
  exportStatic: exportStatic,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var NATIVE_ARRAY_BUFFER = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER;
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toIndex = __webpack_require__(/*! ../internals/to-index */ "./node_modules/core-js/internals/to-index.js");
var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var arrayFill = __webpack_require__(/*! ../internals/array-fill */ "./node_modules/core-js/internals/array-fill.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpackIEEE754 = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new
    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, NativeArrayBuffer[key]);
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataView[PROTOTYPE].setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "./node_modules/core-js/internals/array-copy-within.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/array-copy-within.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-fill.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-fill.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-for-each.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-for-each.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativeForEach = [].forEach;
var internalForEach = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(0);

var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
module.exports = SLOPPY_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return internalForEach(this, callbackfn, arguments[1]);
} : nativeForEach;


/***/ }),

/***/ "./node_modules/core-js/internals/array-from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-from.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var index = 0;
  var iteratorMethod = getIteratorMethod(O);
  var length, result, step, iterator;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    result = new C();
    for (;!(step = iterator.next()).done; index++) {
      createProperty(result, index, mapping
        ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)
        : step.value
      );
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
// false -> Array#indexOf
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
// true  -> Array#includes
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-last-index-of.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/array-last-index-of.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var nativeLastIndexOf = [].lastIndexOf;

var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('lastIndexOf');

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
module.exports = (NEGATIVE_ZERO || SLOPPY_METHOD) ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;


/***/ }),

/***/ "./node_modules/core-js/internals/array-method-has-species-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');

module.exports = function (METHOD_NAME) {
  return !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-methods.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/array-methods.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
// 0 -> Array#forEach
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
// 1 -> Array#map
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// 2 -> Array#filter
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// 3 -> Array#some
// https://tc39.github.io/ecma262/#sec-array.prototype.some
// 4 -> Array#every
// https://tc39.github.io/ecma262/#sec-array.prototype.every
// 5 -> Array#find
// https://tc39.github.io/ecma262/#sec-array.prototype.find
// 6 -> Array#findIndex
// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
module.exports = function (TYPE, specificCreate) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = specificCreate || arraySpeciesCreate;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: target.push(value);       // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-reduce.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/array-reduce.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `Array.prototype.{ reduce, reduceRight }` methods implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
module.exports = function (that, callbackfn, argumentsLength, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IndexedObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (argumentsLength < 2) while (true) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/bind-context.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/bind-context.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var TO_STRING_TAG = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          hide(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    hide(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-well-known-symbol.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/wrapped-well-known-symbol */ "./node_modules/core-js/internals/wrapped-well-known-symbol.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var document = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").document;
// typeof document.createElement is 'object' in old IE
var exist = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return exist ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/enum-keys.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/enum-keys.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");

// all enumerable object keys, includes symbols
module.exports = function (it) {
  var result = objectKeys(it);
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  if (getOwnPropertySymbols) {
    var symbols = getOwnPropertySymbols(it);
    var propertyIsEnumerable = propertyIsEnumerableModule.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (propertyIsEnumerable.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      hide(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
    if (sham) hide(RegExp.prototype[SYMBOL], 'sham', true);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/function-to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js")('native-function-to-string', Function.toString);


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

module.exports = function (it) {
  var iteratorMethod = getIteratorMethod(it);
  if (typeof iteratorMethod != 'function') {
    throw TypeError(String(it) + ' is not iterable');
  } return anObject(iteratorMethod.call(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports = typeof window == 'object' && window && window.Math == Math ? window
  : typeof self == 'object' && self && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/hide.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/hide.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js") ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/host-report-errors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/host-report-errors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").document;

module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js") && !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js")('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var split = ''.split;

module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var WeakMap = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    hide(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-regexp.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-regexp.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var MATCH = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterate.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var BREAK = {};

var exports = module.exports = function (iterable, fn, that, ENTRIES, ITERATOR) {
  var boundFunction = bind(fn, that, ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, step;

  if (ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
        if (result === BREAK) return BREAK;
      } return;
    }
    iterator = iterFn.call(iterable);
  }

  while (!(step = iterator.next()).done) {
    if (callWithSafeIterationClosing(iterator, boundFunction, step.value, ENTRIES) === BREAK) return BREAK;
  }
};

exports.BREAK = BREAK;


/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/microtask.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/microtask.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var macrotask = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set;
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");
var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var IS_NODE = classof(process) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver && !/(iPhone|iPod|iPad).*AppleWebKit/i.test(userAgent)) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Chrome 38 Symbol has incorrect toString conversion
module.exports = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-url.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/native-url.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');

module.exports = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  var url = new URL('b?e=1', 'http://a');
  var searchParams = url.searchParams;
  url.pathname = 'c%20d';
  return (IS_PURE && !url.toJSON)
    || !searchParams.sort
    || url.href !== 'http://a/c%20d?e=1'
    || searchParams.get('e') !== '1'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !searchParams[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('http://тест').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('http://a#б').hash !== '#%D0%B1';
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");
var WeakMap = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(nativeFunctionToString.call(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/new-promise-capability.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/new-promise-capability.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-assign.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-assign.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var nativeAssign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !nativeAssign || __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (propertyIsEnumerable.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : nativeAssign;


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var IE_PROTO = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js")('IE_PROTO');
var PROTOTYPE = 'prototype';
var Empty = function () { /* empty */ };

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var length = enumBugKeys.length;
  var lt = '<';
  var script = 'script';
  var gt = '>';
  var js = 'java' + script + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = String(js);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : defineProperties(result, Properties);
};

__webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js")[IE_PROTO] = true;


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var key;
  while (length > i) definePropertyModule.f(O, key = keys[i++], Properties[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var nativeDefineProperty = Object.defineProperty;

exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IE_PROTO = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js")('IE_PROTO');
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");
var ObjectPrototype = Object.prototype;

module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var arrayIndexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js")(false);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = nativeGetOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = nativeGetOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var validateSetPrototypeOfArguments = __webpack_require__(/*! ../internals/validate-set-prototype-of-arguments */ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");

module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var correctSetter = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    correctSetter = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    validateSetPrototypeOfArguments(O, proto);
    if (correctSetter) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var TO_STRING_TAG = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = String(test) !== '[object z]' ? function toString() {
  return '[object ' + classof(this) + ']';
} : test.toString;


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var Reflect = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Reflect;

// all object keys, includes non-enumerable and symbols
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/parse-float.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/parse-float.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeParseFloat = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").parseFloat;
var internalStringTrim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");
var FORCED = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity;

module.exports = FORCED ? function parseFloat(str) {
  var string = internalStringTrim(String(str), 3);
  var result = nativeParseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : nativeParseFloat;


/***/ }),

/***/ "./node_modules/core-js/internals/parse-int.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/parse-int.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeParseInt = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").parseInt;
var internalStringTrim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");
var hex = /^[-+]?0[xX]/;
var FORCED = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22;

module.exports = FORCED ? function parseInt(str, radix) {
  var string = internalStringTrim(String(str), 3);
  return nativeParseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : nativeParseInt;


/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");


/***/ }),

/***/ "./node_modules/core-js/internals/perform.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/perform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/promise-resolve.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/promise-resolve.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var newPromiseCapability = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/internals/punycode-to-ascii.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/punycode-to-ascii.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[\u002E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
// eslint-disable-next-line  max-statements
var encode = function (input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw RangeError(OVERFLOW_ERROR);
      }
      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        for (var k = base; /* no condition */; k += base) {
          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) {
            break;
          }
          var qMinusT = q - t;
          var baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
        }

        output.push(stringFromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }

    ++delta;
    ++n;
  }
  return output.join('');
};

module.exports = function (input) {
  var encoded = [];
  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
  }
  return encoded.join('.');
};


/***/ }),

/***/ "./node_modules/core-js/internals/redefine-all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/redefine-all.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(nativeFunctionToString).split('toString');

__webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js")('inspectSource', function (it) {
  return nativeFunctionToString.call(it);
});

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else hide(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || nativeFunctionToString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec-abstract.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var regexpExec = __webpack_require__(/*! ./regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/same-value.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/same-value.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");

module.exports = function (key, value) {
  try {
    hide(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-species.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var C = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;
  if (DESCRIPTORS && C && !C[SPECIES]) defineProperty(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var TO_STRING_TAG = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js")('keys');
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.0.1',
  mode: __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/internals/sloppy-array-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/sloppy-array-method.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !method || !fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/species-constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/species-constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-at.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/string-at.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
// CONVERT_TO_STRING: true  -> String#at
// CONVERT_TO_STRING: false -> String#codePointAt
module.exports = function (that, pos, CONVERT_TO_STRING) {
  var S = String(requireObjectCoercible(that));
  var position = toInteger(pos);
  var size = S.length;
  var first, second;
  if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
  first = S.charCodeAt(position);
  return first < 0xD800 || first > 0xDBFF || position + 1 === size
    || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
      ? CONVERT_TO_STRING ? S.charAt(position) : first
      : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-repeat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/string-repeat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-trim.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/string-trim.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var whitespace = '[' + __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js") + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// 1 -> String#trimStart
// 2 -> String#trimEnd
// 3 -> String#trim
module.exports = function (string, TYPE) {
  string = String(requireObjectCoercible(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};


/***/ }),

/***/ "./node_modules/core-js/internals/task.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/task.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function (event) {
  run.call(event.data);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classof(process) == 'process') {
    defer = function (id) {
      process.nextTick(bind(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(bind(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(bind(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "./node_modules/core-js/internals/this-number-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/this-number-value.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-index.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/to-index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-offset.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-offset.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

module.exports = function (it, BYTES) {
  var offset = toInteger(it);
  if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/typed-array-constructor.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/typed-array-constructor.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js")) {
  var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
  var $export = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
  var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(/*! ../internals/typed-arrays-constructors-requires-wrappers */ "./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js");
  var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
  var ArrayBufferModule = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js");
  var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
  var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
  var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
  var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
  var toIndex = __webpack_require__(/*! ../internals/to-index */ "./node_modules/core-js/internals/to-index.js");
  var toOffset = __webpack_require__(/*! ../internals/to-offset */ "./node_modules/core-js/internals/to-offset.js");
  var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
  var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
  var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
  var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
  var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
  var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
  var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
  var typedArrayFrom = __webpack_require__(/*! ../internals/typed-array-from */ "./node_modules/core-js/internals/typed-array-from.js");
  var arrayForEach = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(0);
  var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
  var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
  var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
  var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
  var getInternalState = InternalStateModule.get;
  var setInternalState = InternalStateModule.set;
  var nativeDefineProperty = definePropertyModule.f;
  var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  var RangeError = global.RangeError;
  var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
  var DataView = ArrayBufferModule.DataView;
  var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
  var TypedArray = ArrayBufferViewCore.TypedArray;
  var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
  var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
  var isTypedArray = ArrayBufferViewCore.isTypedArray;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var WRONG_LENGTH = 'Wrong length';

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor(C))(length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key) {
    nativeDefineProperty(it, key, { get: function () {
      return getInternalState(this)[key];
    } });
  };

  var isArrayBuffer = function (it) {
    var klass;
    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
  };

  var isTypedArrayIndex = function (target, key) {
    return isTypedArray(target)
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };

  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    return isTypedArrayIndex(target, key = toPrimitive(key, true))
      ? createPropertyDescriptor(2, target[key])
      : nativeGetOwnPropertyDescriptor(target, key);
  };

  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    if (isTypedArrayIndex(target, key = toPrimitive(key, true))
      && isObject(descriptor)
      && has(descriptor, 'value')
      && !has(descriptor, 'get')
      && !has(descriptor, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !descriptor.configurable
      && (!has(descriptor, 'writable') || descriptor.writable)
      && (!has(descriptor, 'enumerable') || descriptor.enumerable)
    ) {
      target[key] = descriptor.value;
      return target;
    } return nativeDefineProperty(target, key, descriptor);
  };

  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  // eslint-disable-next-line max-statements
  module.exports = function (TYPE, BYTES, wrapper, CLAMPED) {
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (that, data, typedArrayOffset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
        if (isArrayBuffer(data)) return $length !== undefined
          ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
          : typedArrayOffset !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
            : new NativeTypedArrayConstructor(data);
        if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
        return typedArrayFrom.call(TypedArrayConstructor, data);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      arrayForEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) hide(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      hide(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) hide(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $export({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      hide(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      hide(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/internals/typed-array-from.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/typed-array-from.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var aTypedArrayConstructor = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").aTypedArrayConstructor;

module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    O = [];
    while (!(step = iterator.next()).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-new */
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari 11 bug
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + postfix).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/internals/user-agent.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/user-agent.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/internals/validate-set-prototype-of-arguments.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

module.exports = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) {
    throw TypeError("Can't set " + String(proto) + ' as a prototype');
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js")('wks');
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var Symbol = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Symbol;
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

module.exports = function (name) {
  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]
    || (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};


/***/ }),

/***/ "./node_modules/core-js/internals/whitespaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/whitespaces.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js/internals/wrapped-well-known-symbol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/wrapped-well-known-symbol.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.array-buffer.constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array-buffer.constructor.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js")[ARRAY_BUFFER];
var NativeArrayBuffer = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js")[ARRAY_BUFFER];

// `ArrayBuffer` constructor
// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: NativeArrayBuffer !== ArrayBuffer }, {
  ArrayBuffer: ArrayBuffer
});

__webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js")(ARRAY_BUFFER);


/***/ }),

/***/ "./node_modules/core-js/modules/es.array-buffer.slice.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array-buffer.slice.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferModule = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;

var INCORRECT_SLICE = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    } return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.concat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

var IS_CONCAT_SPREADABLE_SUPPORT = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.filter.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.filter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var internalFilter = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(2);

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('filter');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: !SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return internalFilter(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.for-each.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.for-each.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: [].forEach != forEach }, { forEach: forEach });


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.index-of.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.index-of.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var internalIndexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js")(false);
var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('indexOf');

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || SLOPPY_METHOD }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : internalIndexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.is-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Array.isArray` method
// https://tc39.github.io/ecma262/#sec-array.isarray
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', stat: true }, { isArray: __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.join.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.join.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeJoin = [].join;

var ES3_STRINGS = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js") != Object;
var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: ES3_STRINGS || SLOPPY_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.map.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var internalMap = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(1);

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('map');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: !SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return internalMap(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.reduce.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.reduce.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var internalReduce = __webpack_require__(/*! ../internals/array-reduce */ "./node_modules/core-js/internals/array-reduce.js");

var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('reduce');

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: SLOPPY_METHOD }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return internalReduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.slice.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.slice.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');
var nativeSlice = [].slice;
var max = Math.max;

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('slice');

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: !SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.splice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.splice.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('splice');

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: !SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.data-view.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.data-view.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_ARRAY_BUFFER = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER;

// `DataView` constructor
// https://tc39.github.io/ecma262/#sec-dataview-constructor
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: !NATIVE_ARRAY_BUFFER }, {
  DataView: __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js").DataView
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.now.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.now.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Date.now` method
// https://tc39.github.io/ecma262/#sec-date.now
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Date', stat: true }, {
  now: function now() {
    return new Date().getTime();
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-string.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-string.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime;

// `Date.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tostring
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js")(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.function.name.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.name.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.to-fixed.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.to-fixed.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var thisNumberValue = __webpack_require__(/*! ../internals/this-number-value */ "./node_modules/core-js/internals/this-number-value.js");
var repeat = __webpack_require__(/*! ../internals/string-repeat */ "./node_modules/core-js/internals/string-repeat.js");
var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};

var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
    }
  } return s;
};

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

// `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Number', proto: true, forced: nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
}) }, {
  toFixed: function toFixed(fractionDigits) {
    var x = thisNumberValue(this);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = '0';
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call('0', f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call('0', f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-property.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Object', stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
  defineProperty: __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var FAILS_ON_PRIMITIVES = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var nativeKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var FAILS_ON_PRIMITIVES = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");
var ObjectPrototype = Object.prototype;

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (toString !== ObjectPrototype.toString) {
  __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js")(ObjectPrototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-float.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-float.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseFloatImplementation = __webpack_require__(/*! ../internals/parse-float */ "./node_modules/core-js/internals/parse-float.js");

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: parseFloat != parseFloatImplementation }, {
  parseFloat: parseFloatImplementation
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-int.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-int.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseIntImplementation = __webpack_require__(/*! ../internals/parse-int */ "./node_modules/core-js/internals/parse-int.js");

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: parseInt != parseIntImplementation }, {
  parseInt: parseIntImplementation
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var PROMISE = 'Promise';
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var $export = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var task = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set;
var microtask = __webpack_require__(/*! ../internals/microtask */ "./node_modules/core-js/internals/microtask.js");
var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ "./node_modules/core-js/internals/promise-resolve.js");
var hostReportErrors = __webpack_require__(/*! ../internals/host-report-errors */ "./node_modules/core-js/internals/host-report-errors.js");
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");
var perform = __webpack_require__(/*! ../internals/perform */ "./node_modules/core-js/internals/perform.js");
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = global[PROMISE];
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = global.fetch;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper;

var FORCED = isForced(PROMISE, function () {
  // correct subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var empty = function () { /* empty */ };
  var FakePromise = (promise.constructor = {})[SPECIES] = function (exec) {
    exec(empty, empty);
  };
  // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  return !((IS_NODE || typeof PromiseRejectionEvent == 'function')
    && (!IS_PURE || promise['finally'])
    && promise.then(empty) instanceof FakePromise
    // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0
    && userAgent.indexOf('Chrome/66') === -1);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (handler = global['on' + name]) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task.call(global, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task.call(global, function () {
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, promise, wrapper, state),
            bind(internalReject, promise, wrapper, state)
          );
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, { done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js")(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  // wrap fetch result
  if (!IS_PURE && typeof $fetch == 'function') $export({ global: true, enumerable: true, forced: true }, {
    // eslint-disable-next-line no-unused-vars
    fetch: function fetch(input) {
      return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
    }
  });
}

$export({ global: true, wrap: true, forced: FORCED }, { Promise: PromiseConstructor });

__webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js")(PromiseConstructor, PROMISE, false, true);
__webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js")(PROMISE);

PromiseWrapper = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js")[PROMISE];

// statics
$export({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$export({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      iterate(iterable, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var MATCH = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('match');
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");
var getFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var FORCED = isForced('RegExp', DESCRIPTORS && (!CORRECT_NEW || fails(function () {
  re2[MATCH] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    return !thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined ? pattern
      : inheritIfRequired(CORRECT_NEW
        ? new NativeRegExp(patternIsRegExp && !flagsAreUndefined ? pattern.source : pattern, flags)
        : NativeRegExp((patternIsRegExp = pattern instanceof RegExpWrapper)
          ? pattern.source
          : pattern, patternIsRegExp && flagsAreUndefined ? getFlags.call(pattern) : flags)
      , thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys = getOwnPropertyNames(NativeRegExp);
  var i = 0;
  while (i < keys.length) proxy(keys[i++]);
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
__webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js")('RegExp');


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.exec.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.exec.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
  exec: regexpExec
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var flags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var TO_STRING = 'toString';
var nativeToString = /./[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js")(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? flags.call(R) : undefined);
  }, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var codePointAt = __webpack_require__(/*! ../internals/string-at */ "./node_modules/core-js/internals/string-at.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = codePointAt(string, index, true);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.match.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.match.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@match logic
__webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js")(
  'match',
  1,
  function (MATCH, nativeMatch, maybeCallNative) {
    return [
      // `String.prototype.match` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = regexp == undefined ? undefined : regexp[MATCH];
        return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
      function (regexp) {
        var res = maybeCallNative(nativeMatch, regexp, this);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);

        if (!rx.global) return regExpExec(rx, S);

        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regExpExec(rx, S)) !== null) {
          var matchStr = String(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }
    ];
  }
);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.replace.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.replace.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js")(
  'replace',
  2,
  function (REPLACE, nativeReplace, maybeCallNative) {
    return [
      // `String.prototype.replace` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
        return replacer !== undefined
          ? replacer.call(searchValue, O, replaceValue)
          : nativeReplace.call(String(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
      function (regexp, replaceValue) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);

        var functionalReplace = typeof replaceValue === 'function';
        if (!functionalReplace) replaceValue = String(replaceValue);

        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regExpExec(rx, S);
          if (result === null) break;

          results.push(result);
          if (!global) break;

          var matchStr = String(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];

          var matched = String(result[0]);
          var position = max(min(toInteger(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = [matched].concat(captures, position, S);
            if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
            var replacement = String(replaceValue.apply(undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + S.slice(nextSourcePosition);
      }
    ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
    function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== undefined) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return nativeReplace.call(replacement, symbols, function (match, ch) {
        var capture;
        switch (ch.charAt(0)) {
          case '$': return '$';
          case '&': return matched;
          case '`': return str.slice(0, position);
          case "'": return str.slice(tailPos);
          case '<':
            capture = namedCaptures[ch.slice(1, -1)];
            break;
          default: // \d\d?
            var n = +ch;
            if (n === 0) return match;
            if (n > m) {
              var f = floor(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === undefined ? '' : capture;
      });
    }
  }
);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.search.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.search.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var sameValue = __webpack_require__(/*! ../internals/same-value */ "./node_modules/core-js/internals/same-value.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@search logic
__webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js")(
  'search',
  1,
  function (SEARCH, nativeSearch, maybeCallNative) {
    return [
      // `String.prototype.search` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.search
      function search(regexp) {
        var O = requireObjectCoercible(this);
        var searcher = regexp == undefined ? undefined : regexp[SEARCH];
        return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
      },
      // `RegExp.prototype[@@search]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
      function (regexp) {
        var res = maybeCallNative(nativeSearch, regexp, this);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);

        var previousLastIndex = rx.lastIndex;
        if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
        var result = regExpExec(rx, S);
        if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
        return result === null ? -1 : result.index;
      }
    ];
  }
);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.split.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.split.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var callRegExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
__webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js")(
  'split',
  2,
  function (SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if (
      'abbc'.split(/(b)*/)[1] == 'c' ||
      'test'.split(/(?:)/, -1).length != 4 ||
      'ab'.split(/(?:ab)*/).length != 2 ||
      '.'.split(/(.?)(.?)/).length != 4 ||
      '.'.split(/()()/).length > 1 ||
      ''.split(/.?/).length
    ) {
      // based on es5-shim implementation, need to rework it
      internalSplit = function (separator, limit) {
        var string = String(requireObjectCoercible(this));
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === undefined) return [string];
        // If `separator` is not a regex, use native split
        if (!isRegExp(separator)) {
          return nativeSplit.call(string, separator, lim);
        }
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') +
                    (separator.multiline ? 'm' : '') +
                    (separator.unicode ? 'u' : '') +
                    (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;
        while (match = regexpExec.call(separatorCopy, string)) {
          lastIndex = separatorCopy.lastIndex;
          if (lastIndex > lastLastIndex) {
            output.push(string.slice(lastLastIndex, match.index));
            if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= lim) break;
          }
          if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !separatorCopy.test('')) output.push('');
        } else output.push(string.slice(lastLastIndex));
        return output.length > lim ? output.slice(0, lim) : output;
      };
    // Chakra, V8
    } else if ('0'.split(undefined, 0).length) {
      internalSplit = function (separator, limit) {
        return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
      };
    } else internalSplit = nativeSplit;

    return [
      // `String.prototype.split` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible(this);
        var splitter = separator == undefined ? undefined : separator[SPLIT];
        return splitter !== undefined
          ? splitter.call(separator, O, limit)
          : internalSplit.call(String(O), separator, limit);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (regexp, limit) {
        var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);
        var C = speciesConstructor(rx, RegExp);

        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (SUPPORTS_Y ? 'y' : 'g');

        // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the 'y' flag.
        var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q < S.length) {
          splitter.lastIndex = SUPPORTS_Y ? q : 0;
          var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
          var e;
          if (
            z === null ||
            (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
          ) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            A.push(S.slice(p, q));
            if (A.length === lim) return A;
            for (var i = 1; i <= z.length - 1; i++) {
              A.push(z[i]);
              if (A.length === lim) return A;
            }
            q = p = e;
          }
        }
        A.push(S.slice(p));
        return A;
      }
    ];
  },
  !SUPPORTS_Y
);


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.description.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.github.io/ecma262/#sec-symbol.prototype.description

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var NativeSymbol = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: true }, { Symbol: SymbolWrapper });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
__webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js")('iterator');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var $export = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/wrapped-well-known-symbol */ "./node_modules/core-js/internals/wrapped-well-known-symbol.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
var enumKeys = __webpack_require__(/*! ../internals/enum-keys */ "./node_modules/core-js/internals/enum-keys.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var HIDDEN = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js")('hidden');
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var SYMBOL = 'Symbol';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var $Symbol = global.Symbol;
var JSON = global.JSON;
var nativeJSONStringify = JSON && JSON.stringify;
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');
var ObjectPrototype = Object[PROTOTYPE];
var QObject = global.QObject;
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, key);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[key];
  nativeDefineProperty(it, key, D);
  if (ObjectPrototypeDescriptor && it !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, key, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = NATIVE_SYMBOL && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) nativeDefineProperty(it, HIDDEN, createPropertyDescriptor(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = nativeObjectCreate(D, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(it, key, D);
  } return nativeDefineProperty(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIndexedObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};

var $create = function create(it, P) {
  return P === undefined ? nativeObjectCreate(it) : $defineProperties(nativeObjectCreate(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = nativePropertyIsEnumerable.call(this, key = toPrimitive(key, true));
  if (this === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIndexedObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var D = nativeGetOwnPropertyDescriptor(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && !has(hiddenKeys, key)) result.push(key);
  } return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OP ? ObjectPrototypeSymbols : toIndexedObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectPrototype, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };
}

$export({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, { Symbol: $Symbol });

for (var wellKnownSymbols = objectKeys(WellKnownSymbolsStore), k = 0; wellKnownSymbols.length > k;) {
  defineWellKnownSymbol(wellKnownSymbols[k++]);
}

$export({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$export({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$export({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
JSON && $export({ target: 'JSON', stat: true, forced: !NATIVE_SYMBOL || fails(function () {
  var symbol = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  return nativeJSONStringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || nativeJSONStringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || nativeJSONStringify(Object(symbol)) != '{}';
}) }, {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return nativeJSONStringify.apply(JSON, args);
  }
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.copy-within.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.copy-within.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayCopyWithin = __webpack_require__(/*! ../internals/array-copy-within */ "./node_modules/core-js/internals/array-copy-within.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
ArrayBufferViewCore.exportProto('copyWithin', function copyWithin(target, start /* , end */) {
  return arrayCopyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.every.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.every.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayEvery = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(4);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
ArrayBufferViewCore.exportProto('every', function every(callbackfn /* , thisArg */) {
  return arrayEvery(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.fill.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.fill.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayFill = __webpack_require__(/*! ../internals/array-fill */ "./node_modules/core-js/internals/array-fill.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('fill', function fill(value /* , start, end */) {
  return arrayFill.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.filter.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.filter.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var arrayFilter = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(2);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

// `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
ArrayBufferViewCore.exportProto('filter', function filter(callbackfn /* , thisArg */) {
  var list = arrayFilter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.find-index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.find-index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayFindIndex = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(6);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
ArrayBufferViewCore.exportProto('findIndex', function findIndex(predicate /* , thisArg */) {
  return arrayFindIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.find.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.find.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayFind = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(5);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
ArrayBufferViewCore.exportProto('find', function find(predicate /* , thisArg */) {
  return arrayFind(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.for-each.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.for-each.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayForEach = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(0);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
ArrayBufferViewCore.exportProto('forEach', function forEach(callbackfn /* , thisArg */) {
  arrayForEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.includes.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayIncludes = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js")(true);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
ArrayBufferViewCore.exportProto('includes', function includes(searchElement /* , fromIndex */) {
  return arrayIncludes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.index-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.index-of.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayIndexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js")(false);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
ArrayBufferViewCore.exportProto('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return arrayIndexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.iterator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayIterators = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var Uint8Array = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Uint8Array;
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportProto = ArrayBufferViewCore.exportProto;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];

var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
exportProto('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
exportProto('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
exportProto('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
exportProto(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.join.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.join.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arrayJoin = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('join', function join(separator) {
  return arrayJoin.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.last-index-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.last-index-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayLastIndexOf = __webpack_require__(/*! ../internals/array-last-index-of */ "./node_modules/core-js/internals/array-last-index-of.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return arrayLastIndexOf.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.map.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

var internalTypedArrayMap = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(1, function (O, length) {
  return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
});

// `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
ArrayBufferViewCore.exportProto('map', function map(mapfn /* , thisArg */) {
  return internalTypedArrayMap(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.reduce-right.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.reduce-right.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arrayReduceRight = [].reduceRight;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return arrayReduceRight.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.reduce.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.reduce.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arrayReduce = [].reduce;

// `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('reduce', function reduce(callbackfn /* , initialValue */) {
  return arrayReduce.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.reverse.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.reverse.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
ArrayBufferViewCore.exportProto('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = Math.floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.set.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.set.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toOffset = __webpack_require__(/*! ../internals/to-offset */ "./node_modules/core-js/internals/to-offset.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

var FORCED = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
ArrayBufferViewCore.exportProto('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments[1], 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.slice.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.slice.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var arraySlice = [].slice;

var FORCED = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
ArrayBufferViewCore.exportProto('slice', function slice(start, end) {
  var list = arraySlice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.some.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.some.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arraySome = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(3);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
ArrayBufferViewCore.exportProto('some', function some(callbackfn /* , thisArg */) {
  return arraySome(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.sort.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.sort.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arraySort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
ArrayBufferViewCore.exportProto('sort', function sort(comparefn) {
  return arraySort.call(aTypedArray(this), comparefn);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.subarray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.subarray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
ArrayBufferViewCore.exportProto('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.to-locale-string.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.to-locale-string.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Int8Array = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Int8Array;
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arrayToLocaleString = [].toLocaleString;
var arraySlice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_BUG = !!Int8Array && fails(function () {
  arrayToLocaleString.call(new Int8Array(1));
});
var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
ArrayBufferViewCore.exportProto('toLocaleString', function toLocaleString() {
  return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.to-string.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.to-string.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Uint8Array = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype;
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var arrayToString = [].toString;
var arrayJoin = [].join;

if (__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

// `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
ArrayBufferViewCore.exportProto('toString', arrayToString, (Uint8ArrayPrototype || {}).toString != arrayToString);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint16-array.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint16-array.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Uint16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
__webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint32-array.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint32-array.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Uint32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
__webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint8-array.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint8-array.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
__webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.for-each.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    hide(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      hide(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) hide(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        hide(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var task = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js");
var FORCED = !global.setImmediate || !global.clearImmediate;

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, bind: true, enumerable: true, forced: FORCED }, {
  setImmediate: task.set,
  clearImmediate: task.clear
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/web.timers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");
var slice = [].slice;

var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, bind: true, forced: MSIE }, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.url-search-params.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/web.url-search-params.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var USE_NATIVE_URL = __webpack_require__(/*! ../internals/native-url */ "./node_modules/core-js/internals/native-url.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var hasOwn = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);

var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = it.replace(plus, ' ');
  var bytes = 4;
  while (bytes) {
    result = result.replace(percentSequence(bytes--), percentDecode);
  }
  return result;
};

var find = /[!'()~]|%20/g;

var replace = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replace[match];
};

var serialize = function (it) {
  return encodeURIComponent(it).replace(find, replacer);
};

var parseSearchParams = function (result, query) {
  if (query) {
    var attributes = query.split('&');
    var i = 0;
    var attribute, entry;
    while (i < attributes.length) {
      attribute = attributes[i++];
      if (attribute.length) {
        entry = attribute.split('=');
        result.push({
          key: deserialize(entry.shift()),
          value: deserialize(entry.join('='))
        });
      }
    }
  } return result;
};

var updateSearchParams = function (query) {
  this.entries.length = 0;
  parseSearchParams(this.entries, query);
};

var validateArgumentsLength = function (passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  } return step;
});

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var that = this;
  var entries = [];
  var iteratorMethod, iterator, step, entryIterator, first, second, key;

  setInternalState(that, {
    type: URL_SEARCH_PARAMS,
    entries: entries,
    updateURL: null,
    updateSearchParams: updateSearchParams
  });

  if (init !== undefined) {
    if (isObject(init)) {
      iteratorMethod = getIteratorMethod(init);
      if (typeof iteratorMethod === 'function') {
        iterator = iteratorMethod.call(init);
        while (!(step = iterator.next()).done) {
          entryIterator = getIterator(anObject(step.value));
          if (
            (first = entryIterator.next()).done ||
            (second = entryIterator.next()).done ||
            !entryIterator.next().done
          ) throw TypeError('Expected sequence with length 2');
          entries.push({ key: first.value + '', value: second.value + '' });
        }
      } else for (key in init) if (hasOwn(init, key)) entries.push({ key: key, value: init[key] + '' });
    } else {
      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
    }
  }
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.appent` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    state.entries.push({ key: name + '', value: value + '' });
    if (state.updateURL) state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = name + '';
    var i = 0;
    while (i < entries.length) {
      if (entries[i].key === key) entries.splice(i, 1);
      else i++;
    }
    if (state.updateURL) state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var i = 0;
    for (; i < entries.length; i++) if (entries[i].key === key) return entries[i].value;
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var result = [];
    var i = 0;
    for (; i < entries.length; i++) if (entries[i].key === key) result.push(entries[i].value);
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var i = 0;
    while (i < entries.length) if (entries[i++].key === key) return true;
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = name + '';
    var val = value + '';
    var i = 0;
    var entry;
    for (; i < entries.length; i++) {
      entry = entries[i];
      if (entry.key === key) {
        if (found) entries.splice(i--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) entries.push({ key: key, value: val });
    if (state.updateURL) state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    var entries = state.entries;
    // Array#sort is not stable in some engines
    var slice = entries.slice();
    var entry, i, j;
    entries.length = 0;
    for (i = 0; i < slice.length; i++) {
      entry = slice[i];
      for (j = 0; j < i; j++) if (entries[j].key > entry.key) {
        entries.splice(j, 0, entry);
        break;
      }
      if (j === i) entries.push(entry);
    }
    if (state.updateURL) state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
    var i = 0;
    var entry;
    while (i < entries.length) {
      entry = entries[i++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
  var entries = getInternalParamsState(this).entries;
  var result = [];
  var i = 0;
  var entry;
  while (i < entries.length) {
    entry = entries[i++];
    result.push(serialize(entry.key) + '=' + serialize(entry.value));
  } return result.join('&');
}, { enumerable: true });

__webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js")(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};


/***/ }),

/***/ "./node_modules/core-js/modules/web.url.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/web.url.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var USE_NATIVE_URL = __webpack_require__(/*! ../internals/native-url */ "./node_modules/core-js/internals/native-url.js");
var NativeURL = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").URL;
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js");
var arrayFrom = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
var codePointAt = __webpack_require__(/*! ../internals/string-at */ "./node_modules/core-js/internals/string-at.js");
var toASCII = __webpack_require__(/*! ../internals/punycode-to-ascii */ "./node_modules/core-js/internals/punycode-to-ascii.js");
var URLSearchParamsModule = __webpack_require__(/*! ../modules/web.url-search-params */ "./node_modules/core-js/modules/web.url-search-params.js");
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var pow = Math.pow;

var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';

var ALPHA = /[a-zA-Z]/;
var ALPHANUMERIC = /[a-zA-Z0-9+\-.]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[0-9A-Fa-f]+$/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT = /\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/;
// eslint-disable-next-line no-control-regex
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g;
// eslint-disable-next-line no-control-regex
var TAB_AND_NEW_LINE = /\u0009|\u000A|\u000D/g;
var EOF;

var parseHost = function (url, input) {
  var result, codePoints, i;
  if (input.charAt(0) == '[') {
    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
    result = parseIPv6(input.slice(1, -1));
    if (!result) return INVALID_HOST;
    url.host = result;
  // opaque host
  } else if (!isSpecial(url)) {
    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
    result = '';
    codePoints = arrayFrom(input);
    for (i = 0; i < codePoints.length; i++) result += percentEncode(codePoints[i], C0ControlPercentEncodeSet);
    url.host = result;
  } else {
    input = toASCII(input);
    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
    result = parseIPv4(input);
    if (result === null) return INVALID_HOST;
    url.host = result;
  }
};

var parseIPv4 = function (input) {
  var parts = input.split('.');
  var partsLength, numbers, i, part, R, n, ipv4;
  if (parts[parts.length - 1] == '') {
    if (parts.length) parts.pop();
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (i = 0; i < partsLength; i++) {
    part = parts[i];
    if (part == '') return input;
    R = 10;
    if (part.length > 1 && part.charAt(0) == '0') {
      R = HEX_START.test(part) ? 16 : 8;
      part = part.slice(R == 8 ? 1 : 2);
    }
    if (part === '') {
      n = 0;
    } else {
      if (!(R == 10 ? DEC : R == 8 ? OCT : HEX).test(part)) return input;
      n = parseInt(part, R);
    }
    numbers.push(n);
  }
  for (i = 0; i < partsLength; i++) {
    n = numbers[i];
    if (i == partsLength - 1) {
      if (n >= pow(256, 5 - partsLength)) return null;
    } else if (n > 255) return null;
  }
  ipv4 = numbers.pop();
  for (i = 0; i < numbers.length; i++) {
    ipv4 += numbers[i] * pow(256, 3 - i);
  }
  return ipv4;
};

// eslint-disable-next-line max-statements
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var char = function () {
    return input.charAt(pointer);
  };

  if (char() == ':') {
    if (input.charAt(1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (char()) {
    if (pieceIndex == 8) return;
    if (char() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && HEX.test(char())) {
      value = value * 16 + parseInt(char(), 16);
      pointer++;
      length++;
    }
    if (char() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (char()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (char() == '.' && numbersSeen < 4) pointer++;
          else return;
        }
        if (!DIGIT.test(char())) return;
        while (DIGIT.test(char())) {
          number = parseInt(char(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece == 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }
      if (numbersSeen != 4) return;
      break;
    } else if (char() == ':') {
      pointer++;
      if (!char()) return;
    } else if (char()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var i = 0;
  for (; i < 8; i++) {
    if (ipv6[i] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = i;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};

var serializeHost = function (host) {
  var result, i, compress, ignore0;
  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (i = 0; i < 4; i++) {
      result.unshift(host % 256);
      host = Math.floor(host / 256);
    } return result.join('.');
  // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (i = 0; i < 8; i++) {
      if (ignore0 && host[i] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === i) {
        result += i ? ':' : '::';
        ignore0 = true;
      } else {
        result += host[i].toString(16);
        if (i < 7) result += ':';
      }
    }
    return '[' + result + ']';
  } return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1, '?': 1, '{': 1, '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
});

var percentEncode = function (char, set) {
  var code = codePointAt(char, 0);
  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
};

var specialSchemes = {
  ftp: 21,
  file: null,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

var isSpecial = function (url) {
  return has(specialSchemes, url.scheme);
};

var includesCredentials = function (url) {
  return url.username != '' || url.password != '';
};

var cannotHaveUsernamePasswordPort = function (url) {
  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};

var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length == 2 && ALPHA.test(string.charAt(0))
    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
};

var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
    string.length == 2 ||
    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
  );
};

var shortenURLsPath = function (url) {
  var path = url.path;
  var pathSize = path.length;
  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
    path.pop();
  }
};

var isSingleDot = function (segment) {
  return segment === '.' || segment.toLowerCase() === '%2e';
};

var isDoubleDot = function (segment) {
  segment = segment.toLowerCase();
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

// eslint-disable-next-line max-statements
var parseURL = function (url, input, stateOverride, base) {
  var state = stateOverride || SCHEME_START;
  var pointer = 0;
  var buffer = '';
  var seenAt = false;
  var seenBracket = false;
  var seenPasswordToken = false;
  var codePoints, char, bufferCodePoints, failure;

  if (!stateOverride) {
    url.scheme = '';
    url.username = '';
    url.password = '';
    url.host = null;
    url.port = null;
    url.path = [];
    url.query = null;
    url.fragment = null;
    url.cannotBeABaseURL = false;
    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
  }

  input = input.replace(TAB_AND_NEW_LINE, '');

  codePoints = arrayFrom(input);

  while (pointer <= codePoints.length) {
    char = codePoints[pointer];
    switch (state) {
      case SCHEME_START:
        if (char && ALPHA.test(char)) {
          buffer += char.toLowerCase();
          state = SCHEME;
        } else if (!stateOverride) {
          state = NO_SCHEME;
          continue;
        } else return INVALID_SCHEME;
        break;

      case SCHEME:
        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
          buffer += char.toLowerCase();
        } else if (char == ':') {
          if (stateOverride) {
            if (
              (isSpecial(url) != has(specialSchemes, buffer)) ||
              (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
              (url.scheme == 'file' && !url.host)
            ) return;
          }
          url.scheme = buffer;
          if (stateOverride) {
            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
            return;
          }
          buffer = '';
          if (url.scheme == 'file') {
            state = FILE;
          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
            state = SPECIAL_RELATIVE_OR_AUTHORITY;
          } else if (isSpecial(url)) {
            state = SPECIAL_AUTHORITY_SLASHES;
          } else if (codePoints[pointer + 1] == '/') {
            state = PATH_OR_AUTHORITY;
            pointer++;
          } else {
            url.cannotBeABaseURL = true;
            url.path.push('');
            state = CANNOT_BE_A_BASE_URL_PATH;
          }
        } else if (!stateOverride) {
          buffer = '';
          state = NO_SCHEME;
          pointer = 0;
          continue;
        } else return INVALID_SCHEME;
        break;

      case NO_SCHEME:
        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
        if (base.cannotBeABaseURL && char == '#') {
          url.scheme = base.scheme;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          url.cannotBeABaseURL = true;
          state = FRAGMENT;
          break;
        }
        state = base.scheme == 'file' ? FILE : RELATIVE;
        continue;

      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if (char == '/' && codePoints[pointer + 1] == '/') {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          pointer++;
        } else {
          state = RELATIVE;
          continue;
        } break;

      case PATH_OR_AUTHORITY:
        if (char == '/') {
          state = AUTHORITY;
          break;
        } else {
          state = PATH;
          continue;
        }

      case RELATIVE:
        url.scheme = base.scheme;
        if (char == EOF) {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
          state = RELATIVE_SLASH;
        } else if (char == '?') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          state = FRAGMENT;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.path.pop();
          state = PATH;
          continue;
        } break;

      case RELATIVE_SLASH:
        if (isSpecial(url) && (char == '/' || char == '\\')) {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        } else if (char == '/') {
          state = AUTHORITY;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          state = PATH;
          continue;
        } break;

      case SPECIAL_AUTHORITY_SLASHES:
        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
        pointer++;
        break;

      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if (char != '/' && char != '\\') {
          state = AUTHORITY;
          continue;
        } break;

      case AUTHORITY:
        if (char == '@') {
          if (seenAt) buffer = '%40' + buffer;
          seenAt = true;
          bufferCodePoints = arrayFrom(buffer);
          for (var i = 0; i < bufferCodePoints.length; i++) {
            var codePoint = bufferCodePoints[i];
            if (codePoint == ':' && !seenPasswordToken) {
              seenPasswordToken = true;
              continue;
            }
            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
            if (seenPasswordToken) url.password += encodedCodePoints;
            else url.username += encodedCodePoints;
          }
          buffer = '';
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (seenAt && buffer == '') return INVALID_AUTHORITY;
          pointer -= arrayFrom(buffer).length + 1;
          buffer = '';
          state = HOST;
        } else buffer += char;
        break;

      case HOST:
      case HOSTNAME:
        if (stateOverride && url.scheme == 'file') {
          state = FILE_HOST;
          continue;
        } else if (char == ':' && !seenBracket) {
          if (buffer == '') return INVALID_HOST;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PORT;
          if (stateOverride == HOSTNAME) return;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (isSpecial(url) && buffer == '') return INVALID_HOST;
          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PATH_START;
          if (stateOverride) return;
          continue;
        } else {
          if (char == '[') seenBracket = true;
          else if (char == ']') seenBracket = false;
          buffer += char;
        } break;

      case PORT:
        if (DIGIT.test(char)) {
          buffer += char;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url)) ||
          stateOverride
        ) {
          if (buffer != '') {
            var port = parseInt(buffer, 10);
            if (port > 0xFFFF) return INVALID_PORT;
            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
            buffer = '';
          }
          if (stateOverride) return;
          state = PATH_START;
          continue;
        } else return INVALID_PORT;
        break;

      case FILE:
        url.scheme = 'file';
        if (char == '/' || char == '\\') state = FILE_SLASH;
        else if (base && base.scheme == 'file') {
          if (char == EOF) {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (char == '?') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
              url.host = base.host;
              url.path = base.path.slice();
              shortenURLsPath(url);
            }
            state = PATH;
            continue;
          }
        } else {
          state = PATH;
          continue;
        } break;

      case FILE_SLASH:
        if (char == '/' || char == '\\') {
          state = FILE_HOST;
          break;
        }
        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
          else url.host = base.host;
        }
        state = PATH;
        continue;

      case FILE_HOST:
        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
          if (!stateOverride && isWindowsDriveLetter(buffer)) {
            state = PATH;
          } else if (buffer == '') {
            url.host = '';
            if (stateOverride) return;
            state = PATH_START;
          } else {
            failure = parseHost(url, buffer);
            if (failure) return failure;
            if (url.host == 'localhost') url.host = '';
            if (stateOverride) return;
            buffer = '';
            state = PATH_START;
          } continue;
        } else buffer += char;
        break;

      case PATH_START:
        if (isSpecial(url)) {
          state = PATH;
          if (char != '/' && char != '\\') continue;
        } else if (!stateOverride && char == '?') {
          url.query = '';
          state = QUERY;
        } else if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          state = PATH;
          if (char != '/') continue;
        } break;

      case PATH:
        if (
          char == EOF || char == '/' ||
          (char == '\\' && isSpecial(url)) ||
          (!stateOverride && (char == '?' || char == '#'))
        ) {
          if (isDoubleDot(buffer)) {
            shortenURLsPath(url);
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else if (isSingleDot(buffer)) {
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else {
            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
              if (url.host) url.host = '';
              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
            }
            url.path.push(buffer);
          }
          buffer = '';
          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
            while (url.path.length > 1 && url.path[0] === '') {
              url.path.shift();
            }
          }
          if (char == '?') {
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.fragment = '';
            state = FRAGMENT;
          }
        } else {
          buffer += percentEncode(char, pathPercentEncodeSet);
        } break;

      case CANNOT_BE_A_BASE_URL_PATH:
        if (char == '?') {
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case QUERY:
        if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          if (char == "'" && isSpecial(url)) url.query += '%27';
          else if (char == '#') url.query += '%23';
          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case FRAGMENT:
        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
        break;
    }

    pointer++;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLConstructor, 'URL');
  var base = arguments.length > 1 ? arguments[1] : undefined;
  var urlString = String(url);
  var state = setInternalState(that, { type: 'URL' });
  var baseState, failure;
  if (base !== undefined) {
    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
    else {
      failure = parseURL(baseState = {}, String(base));
      if (failure) throw TypeError(failure);
    }
  }
  failure = parseURL(state, urlString, null, baseState);
  if (failure) throw TypeError(failure);
  var searchParams = state.searchParams = new URLSearchParams();
  var searchParamsState = getInternalSearchParamsState(searchParams);
  searchParamsState.updateSearchParams(state.query);
  searchParamsState.updateURL = function () {
    state.query = String(searchParams) || null;
  };
  if (!DESCRIPTORS) {
    that.href = serializeURL.call(that);
    that.origin = getOrigin.call(that);
    that.protocol = getProtocol.call(that);
    that.username = getUsername.call(that);
    that.password = getPassword.call(that);
    that.host = getHost.call(that);
    that.hostname = getHostname.call(that);
    that.port = getPort.call(that);
    that.pathname = getPathname.call(that);
    that.search = getSearch.call(that);
    that.searchParams = getSearchParams.call(that);
    that.hash = getHash.call(that);
  }
};

var URLPrototype = URLConstructor.prototype;

var serializeURL = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var username = url.username;
  var password = url.password;
  var host = url.host;
  var port = url.port;
  var path = url.path;
  var query = url.query;
  var fragment = url.fragment;
  var output = scheme + ':';
  if (host !== null) {
    output += '//';
    if (includesCredentials(url)) {
      output += username + (password ? ':' + password : '') + '@';
    }
    output += serializeHost(host);
    if (port !== null) output += ':' + port;
  } else if (scheme == 'file') output += '//';
  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
  if (query !== null) output += '?' + query;
  if (fragment !== null) output += '#' + fragment;
  return output;
};

var getOrigin = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var port = url.port;
  if (scheme == 'blob') try {
    return new URL(scheme.path[0]).origin;
  } catch (error) {
    return 'null';
  }
  if (scheme == 'file' || !isSpecial(url)) return 'null';
  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};

var getProtocol = function () {
  return getInternalURLState(this).scheme + ':';
};

var getUsername = function () {
  return getInternalURLState(this).username;
};

var getPassword = function () {
  return getInternalURLState(this).password;
};

var getHost = function () {
  var url = getInternalURLState(this);
  var host = url.host;
  var port = url.port;
  return host === null ? ''
    : port === null ? serializeHost(host)
    : serializeHost(host) + ':' + port;
};

var getHostname = function () {
  var host = getInternalURLState(this).host;
  return host === null ? '' : serializeHost(host);
};

var getPort = function () {
  var port = getInternalURLState(this).port;
  return port === null ? '' : String(port);
};

var getPathname = function () {
  var url = getInternalURLState(this);
  var path = url.path;
  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};

var getSearch = function () {
  var query = getInternalURLState(this).query;
  return query ? '?' + query : '';
};

var getSearchParams = function () {
  return getInternalURLState(this).searchParams;
};

var getHash = function () {
  var fragment = getInternalURLState(this).fragment;
  return fragment ? '#' + fragment : '';
};

var accessorDescriptor = function (getter, setter) {
  return { get: getter, set: setter, configurable: true, enumerable: true };
};

if (DESCRIPTORS) {
  defineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor(serializeURL, function (href) {
      var url = getInternalURLState(this);
      var urlString = String(href);
      var failure = parseURL(url, urlString);
      if (failure) throw TypeError(failure);
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor(getOrigin),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor(getProtocol, function (protocol) {
      var url = getInternalURLState(this);
      parseURL(url, String(protocol) + ':', SCHEME_START);
    }),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor(getUsername, function (username) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(username));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.username = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor(getPassword, function (password) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(password));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.password = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor(getHost, function (host) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(host), HOST);
    }),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor(getHostname, function (hostname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(hostname), HOSTNAME);
    }),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor(getPort, function (port) {
      var url = getInternalURLState(this);
      if (cannotHaveUsernamePasswordPort(url)) return;
      port = String(port);
      if (port == '') url.port = null;
      else parseURL(url, port, PORT);
    }),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor(getPathname, function (pathname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      url.path = [];
      parseURL(url, pathname + '', PATH_START);
    }),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor(getSearch, function (search) {
      var url = getInternalURLState(this);
      search = String(search);
      if (search == '') {
        url.query = null;
      } else {
        if ('?' == search.charAt(0)) search = search.slice(1);
        url.query = '';
        parseURL(url, search, QUERY);
      }
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor(getSearchParams),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor(getHash, function (hash) {
      var url = getInternalURLState(this);
      hash = String(hash);
      if (hash == '') {
        url.fragment = null;
        return;
      }
      if ('#' == hash.charAt(0)) hash = hash.slice(1);
      url.fragment = '';
      parseURL(url, hash, FRAGMENT);
    })
  });
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine(URLPrototype, 'toJSON', function toJSON() {
  return serializeURL.call(this);
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine(URLPrototype, 'toString', function toString() {
  return serializeURL.call(this);
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
    return nativeCreateObjectURL.apply(NativeURL, arguments);
  });
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
    return nativeRevokeObjectURL.apply(NativeURL, arguments);
  });
}

__webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js")(URLConstructor, 'URL');

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jsencrypt/bin/jsencrypt.js":
/*!*************************************************!*\
  !*** ./node_modules/jsencrypt/bin/jsencrypt.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
function int2char(n) {
    return BI_RM.charAt(n);
}
//#region BIT_OPERATIONS
// (public) this & a
function op_and(x, y) {
    return x & y;
}
// (public) this | a
function op_or(x, y) {
    return x | y;
}
// (public) this ^ a
function op_xor(x, y) {
    return x ^ y;
}
// (public) this & ~a
function op_andnot(x, y) {
    return x & ~y;
}
// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
    if (x == 0) {
        return -1;
    }
    var r = 0;
    if ((x & 0xffff) == 0) {
        x >>= 16;
        r += 16;
    }
    if ((x & 0xff) == 0) {
        x >>= 8;
        r += 8;
    }
    if ((x & 0xf) == 0) {
        x >>= 4;
        r += 4;
    }
    if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
    }
    if ((x & 1) == 0) {
        ++r;
    }
    return r;
}
// return number of 1 bits in x
function cbit(x) {
    var r = 0;
    while (x != 0) {
        x &= x - 1;
        ++r;
    }
    return r;
}
//#endregion BIT_OPERATIONS

var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";
function hex2b64(h) {
    var i;
    var c;
    var ret = "";
    for (i = 0; i + 3 <= h.length; i += 3) {
        c = parseInt(h.substring(i, i + 3), 16);
        ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
    }
    if (i + 1 == h.length) {
        c = parseInt(h.substring(i, i + 1), 16);
        ret += b64map.charAt(c << 2);
    }
    else if (i + 2 == h.length) {
        c = parseInt(h.substring(i, i + 2), 16);
        ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
    }
    while ((ret.length & 3) > 0) {
        ret += b64pad;
    }
    return ret;
}
// convert a base64 string to hex
function b64tohex(s) {
    var ret = "";
    var i;
    var k = 0; // b64 state, 0-3
    var slop = 0;
    for (i = 0; i < s.length; ++i) {
        if (s.charAt(i) == b64pad) {
            break;
        }
        var v = b64map.indexOf(s.charAt(i));
        if (v < 0) {
            continue;
        }
        if (k == 0) {
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 1;
        }
        else if (k == 1) {
            ret += int2char((slop << 2) | (v >> 4));
            slop = v & 0xf;
            k = 2;
        }
        else if (k == 2) {
            ret += int2char(slop);
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 3;
        }
        else {
            ret += int2char((slop << 2) | (v >> 4));
            ret += int2char(v & 0xf);
            k = 0;
        }
    }
    if (k == 1) {
        ret += int2char(slop << 2);
    }
    return ret;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// Hex JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder;
var Hex = {
    decode: function (a) {
        var i;
        if (decoder === undefined) {
            var hex = "0123456789ABCDEF";
            var ignore = " \f\n\r\t\u00A0\u2028\u2029";
            decoder = {};
            for (i = 0; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            hex = hex.toLowerCase();
            for (i = 10; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 2) {
                out[out.length] = bits;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 4;
            }
        }
        if (char_count) {
            throw new Error("Hex encoding incomplete: 4 bits missing");
        }
        return out;
    }
};

// Base64 JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder$1;
var Base64 = {
    decode: function (a) {
        var i;
        if (decoder$1 === undefined) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var ignore = "= \f\n\r\t\u00A0\u2028\u2029";
            decoder$1 = Object.create(null);
            for (i = 0; i < 64; ++i) {
                decoder$1[b64.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder$1[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder$1[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 4) {
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                out[out.length] = bits & 0xFF;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 6;
            }
        }
        switch (char_count) {
            case 1:
                throw new Error("Base64 encoding incomplete: at least 2 bits missing");
            case 2:
                out[out.length] = (bits >> 10);
                break;
            case 3:
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                break;
        }
        return out;
    },
    re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
    unarmor: function (a) {
        var m = Base64.re.exec(a);
        if (m) {
            if (m[1]) {
                a = m[1];
            }
            else if (m[2]) {
                a = m[2];
            }
            else {
                throw new Error("RegExp out of sync");
            }
        }
        return Base64.decode(a);
    }
};

// Big integer base-10 printing library
// Copyright (c) 2014 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var max = 10000000000000; // biggest integer that can still fit 2^53 when multiplied by 256
var Int10 = /** @class */ (function () {
    function Int10(value) {
        this.buf = [+value || 0];
    }
    Int10.prototype.mulAdd = function (m, c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] * m + c;
            if (t < max) {
                c = 0;
            }
            else {
                c = 0 | (t / max);
                t -= c * max;
            }
            b[i] = t;
        }
        if (c > 0) {
            b[i] = c;
        }
    };
    Int10.prototype.sub = function (c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] - c;
            if (t < 0) {
                t += max;
                c = 1;
            }
            else {
                c = 0;
            }
            b[i] = t;
        }
        while (b[b.length - 1] === 0) {
            b.pop();
        }
    };
    Int10.prototype.toString = function (base) {
        if ((base || 10) != 10) {
            throw new Error("only base 10 is supported");
        }
        var b = this.buf;
        var s = b[b.length - 1].toString();
        for (var i = b.length - 2; i >= 0; --i) {
            s += (max + b[i]).toString().substring(1);
        }
        return s;
    };
    Int10.prototype.valueOf = function () {
        var b = this.buf;
        var v = 0;
        for (var i = b.length - 1; i >= 0; --i) {
            v = v * max + b[i];
        }
        return v;
    };
    Int10.prototype.simplify = function () {
        var b = this.buf;
        return (b.length == 1) ? b[0] : this;
    };
    return Int10;
}());

// ASN.1 JavaScript decoder
var ellipsis = "\u2026";
var reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
var reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
function stringCut(str, len) {
    if (str.length > len) {
        str = str.substring(0, len) + ellipsis;
    }
    return str;
}
var Stream = /** @class */ (function () {
    function Stream(enc, pos) {
        this.hexDigits = "0123456789ABCDEF";
        if (enc instanceof Stream) {
            this.enc = enc.enc;
            this.pos = enc.pos;
        }
        else {
            // enc should be an array or a binary string
            this.enc = enc;
            this.pos = pos;
        }
    }
    Stream.prototype.get = function (pos) {
        if (pos === undefined) {
            pos = this.pos++;
        }
        if (pos >= this.enc.length) {
            throw new Error("Requesting byte offset " + pos + " on a stream of length " + this.enc.length);
        }
        return ("string" === typeof this.enc) ? this.enc.charCodeAt(pos) : this.enc[pos];
    };
    Stream.prototype.hexByte = function (b) {
        return this.hexDigits.charAt((b >> 4) & 0xF) + this.hexDigits.charAt(b & 0xF);
    };
    Stream.prototype.hexDump = function (start, end, raw) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
            if (raw !== true) {
                switch (i & 0xF) {
                    case 0x7:
                        s += "  ";
                        break;
                    case 0xF:
                        s += "\n";
                        break;
                    default:
                        s += " ";
                }
            }
        }
        return s;
    };
    Stream.prototype.isASCII = function (start, end) {
        for (var i = start; i < end; ++i) {
            var c = this.get(i);
            if (c < 32 || c > 176) {
                return false;
            }
        }
        return true;
    };
    Stream.prototype.parseStringISO = function (start, end) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += String.fromCharCode(this.get(i));
        }
        return s;
    };
    Stream.prototype.parseStringUTF = function (start, end) {
        var s = "";
        for (var i = start; i < end;) {
            var c = this.get(i++);
            if (c < 128) {
                s += String.fromCharCode(c);
            }
            else if ((c > 191) && (c < 224)) {
                s += String.fromCharCode(((c & 0x1F) << 6) | (this.get(i++) & 0x3F));
            }
            else {
                s += String.fromCharCode(((c & 0x0F) << 12) | ((this.get(i++) & 0x3F) << 6) | (this.get(i++) & 0x3F));
            }
        }
        return s;
    };
    Stream.prototype.parseStringBMP = function (start, end) {
        var str = "";
        var hi;
        var lo;
        for (var i = start; i < end;) {
            hi = this.get(i++);
            lo = this.get(i++);
            str += String.fromCharCode((hi << 8) | lo);
        }
        return str;
    };
    Stream.prototype.parseTime = function (start, end, shortYear) {
        var s = this.parseStringISO(start, end);
        var m = (shortYear ? reTimeS : reTimeL).exec(s);
        if (!m) {
            return "Unrecognized time: " + s;
        }
        if (shortYear) {
            // to avoid querying the timer, use the fixed range [1970, 2069]
            // it will conform with ITU X.400 [-10, +40] sliding window until 2030
            m[1] = +m[1];
            m[1] += (+m[1] < 70) ? 2000 : 1900;
        }
        s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];
        if (m[5]) {
            s += ":" + m[5];
            if (m[6]) {
                s += ":" + m[6];
                if (m[7]) {
                    s += "." + m[7];
                }
            }
        }
        if (m[8]) {
            s += " UTC";
            if (m[8] != "Z") {
                s += m[8];
                if (m[9]) {
                    s += ":" + m[9];
                }
            }
        }
        return s;
    };
    Stream.prototype.parseInteger = function (start, end) {
        var v = this.get(start);
        var neg = (v > 127);
        var pad = neg ? 255 : 0;
        var len;
        var s = "";
        // skip unuseful bits (not allowed in DER)
        while (v == pad && ++start < end) {
            v = this.get(start);
        }
        len = end - start;
        if (len === 0) {
            return neg ? -1 : 0;
        }
        // show bit length of huge integers
        if (len > 4) {
            s = v;
            len <<= 3;
            while (((+s ^ pad) & 0x80) == 0) {
                s = +s << 1;
                --len;
            }
            s = "(" + len + " bit)\n";
        }
        // decode the integer
        if (neg) {
            v = v - 256;
        }
        var n = new Int10(v);
        for (var i = start + 1; i < end; ++i) {
            n.mulAdd(256, this.get(i));
        }
        return s + n.toString();
    };
    Stream.prototype.parseBitString = function (start, end, maxLength) {
        var unusedBit = this.get(start);
        var lenBit = ((end - start - 1) << 3) - unusedBit;
        var intro = "(" + lenBit + " bit)\n";
        var s = "";
        for (var i = start + 1; i < end; ++i) {
            var b = this.get(i);
            var skip = (i == end - 1) ? unusedBit : 0;
            for (var j = 7; j >= skip; --j) {
                s += (b >> j) & 1 ? "1" : "0";
            }
            if (s.length > maxLength) {
                return intro + stringCut(s, maxLength);
            }
        }
        return intro + s;
    };
    Stream.prototype.parseOctetString = function (start, end, maxLength) {
        if (this.isASCII(start, end)) {
            return stringCut(this.parseStringISO(start, end), maxLength);
        }
        var len = end - start;
        var s = "(" + len + " byte)\n";
        maxLength /= 2; // we work in bytes
        if (len > maxLength) {
            end = start + maxLength;
        }
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
        }
        if (len > maxLength) {
            s += ellipsis;
        }
        return s;
    };
    Stream.prototype.parseOID = function (start, end, maxLength) {
        var s = "";
        var n = new Int10();
        var bits = 0;
        for (var i = start; i < end; ++i) {
            var v = this.get(i);
            n.mulAdd(128, v & 0x7F);
            bits += 7;
            if (!(v & 0x80)) { // finished
                if (s === "") {
                    n = n.simplify();
                    if (n instanceof Int10) {
                        n.sub(80);
                        s = "2." + n.toString();
                    }
                    else {
                        var m = n < 80 ? n < 40 ? 0 : 1 : 2;
                        s = m + "." + (n - m * 40);
                    }
                }
                else {
                    s += "." + n.toString();
                }
                if (s.length > maxLength) {
                    return stringCut(s, maxLength);
                }
                n = new Int10();
                bits = 0;
            }
        }
        if (bits > 0) {
            s += ".incomplete";
        }
        return s;
    };
    return Stream;
}());
var ASN1 = /** @class */ (function () {
    function ASN1(stream, header, length, tag, sub) {
        if (!(tag instanceof ASN1Tag)) {
            throw new Error("Invalid tag value.");
        }
        this.stream = stream;
        this.header = header;
        this.length = length;
        this.tag = tag;
        this.sub = sub;
    }
    ASN1.prototype.typeName = function () {
        switch (this.tag.tagClass) {
            case 0: // universal
                switch (this.tag.tagNumber) {
                    case 0x00:
                        return "EOC";
                    case 0x01:
                        return "BOOLEAN";
                    case 0x02:
                        return "INTEGER";
                    case 0x03:
                        return "BIT_STRING";
                    case 0x04:
                        return "OCTET_STRING";
                    case 0x05:
                        return "NULL";
                    case 0x06:
                        return "OBJECT_IDENTIFIER";
                    case 0x07:
                        return "ObjectDescriptor";
                    case 0x08:
                        return "EXTERNAL";
                    case 0x09:
                        return "REAL";
                    case 0x0A:
                        return "ENUMERATED";
                    case 0x0B:
                        return "EMBEDDED_PDV";
                    case 0x0C:
                        return "UTF8String";
                    case 0x10:
                        return "SEQUENCE";
                    case 0x11:
                        return "SET";
                    case 0x12:
                        return "NumericString";
                    case 0x13:
                        return "PrintableString"; // ASCII subset
                    case 0x14:
                        return "TeletexString"; // aka T61String
                    case 0x15:
                        return "VideotexString";
                    case 0x16:
                        return "IA5String"; // ASCII
                    case 0x17:
                        return "UTCTime";
                    case 0x18:
                        return "GeneralizedTime";
                    case 0x19:
                        return "GraphicString";
                    case 0x1A:
                        return "VisibleString"; // ASCII subset
                    case 0x1B:
                        return "GeneralString";
                    case 0x1C:
                        return "UniversalString";
                    case 0x1E:
                        return "BMPString";
                }
                return "Universal_" + this.tag.tagNumber.toString();
            case 1:
                return "Application_" + this.tag.tagNumber.toString();
            case 2:
                return "[" + this.tag.tagNumber.toString() + "]"; // Context
            case 3:
                return "Private_" + this.tag.tagNumber.toString();
        }
    };
    ASN1.prototype.content = function (maxLength) {
        if (this.tag === undefined) {
            return null;
        }
        if (maxLength === undefined) {
            maxLength = Infinity;
        }
        var content = this.posContent();
        var len = Math.abs(this.length);
        if (!this.tag.isUniversal()) {
            if (this.sub !== null) {
                return "(" + this.sub.length + " elem)";
            }
            return this.stream.parseOctetString(content, content + len, maxLength);
        }
        switch (this.tag.tagNumber) {
            case 0x01: // BOOLEAN
                return (this.stream.get(content) === 0) ? "false" : "true";
            case 0x02: // INTEGER
                return this.stream.parseInteger(content, content + len);
            case 0x03: // BIT_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseBitString(content, content + len, maxLength);
            case 0x04: // OCTET_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseOctetString(content, content + len, maxLength);
            // case 0x05: // NULL
            case 0x06: // OBJECT_IDENTIFIER
                return this.stream.parseOID(content, content + len, maxLength);
            // case 0x07: // ObjectDescriptor
            // case 0x08: // EXTERNAL
            // case 0x09: // REAL
            // case 0x0A: // ENUMERATED
            // case 0x0B: // EMBEDDED_PDV
            case 0x10: // SEQUENCE
            case 0x11: // SET
                if (this.sub !== null) {
                    return "(" + this.sub.length + " elem)";
                }
                else {
                    return "(no elem)";
                }
            case 0x0C: // UTF8String
                return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);
            case 0x12: // NumericString
            case 0x13: // PrintableString
            case 0x14: // TeletexString
            case 0x15: // VideotexString
            case 0x16: // IA5String
            // case 0x19: // GraphicString
            case 0x1A: // VisibleString
                // case 0x1B: // GeneralString
                // case 0x1C: // UniversalString
                return stringCut(this.stream.parseStringISO(content, content + len), maxLength);
            case 0x1E: // BMPString
                return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);
            case 0x17: // UTCTime
            case 0x18: // GeneralizedTime
                return this.stream.parseTime(content, content + len, (this.tag.tagNumber == 0x17));
        }
        return null;
    };
    ASN1.prototype.toString = function () {
        return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + ((this.sub === null) ? "null" : this.sub.length) + "]";
    };
    ASN1.prototype.toPrettyString = function (indent) {
        if (indent === undefined) {
            indent = "";
        }
        var s = indent + this.typeName() + " @" + this.stream.pos;
        if (this.length >= 0) {
            s += "+";
        }
        s += this.length;
        if (this.tag.tagConstructed) {
            s += " (constructed)";
        }
        else if ((this.tag.isUniversal() && ((this.tag.tagNumber == 0x03) || (this.tag.tagNumber == 0x04))) && (this.sub !== null)) {
            s += " (encapsulates)";
        }
        s += "\n";
        if (this.sub !== null) {
            indent += "  ";
            for (var i = 0, max = this.sub.length; i < max; ++i) {
                s += this.sub[i].toPrettyString(indent);
            }
        }
        return s;
    };
    ASN1.prototype.posStart = function () {
        return this.stream.pos;
    };
    ASN1.prototype.posContent = function () {
        return this.stream.pos + this.header;
    };
    ASN1.prototype.posEnd = function () {
        return this.stream.pos + this.header + Math.abs(this.length);
    };
    ASN1.prototype.toHexString = function () {
        return this.stream.hexDump(this.posStart(), this.posEnd(), true);
    };
    ASN1.decodeLength = function (stream) {
        var buf = stream.get();
        var len = buf & 0x7F;
        if (len == buf) {
            return len;
        }
        // no reason to use Int10, as it would be a huge buffer anyways
        if (len > 6) {
            throw new Error("Length over 48 bits not supported at position " + (stream.pos - 1));
        }
        if (len === 0) {
            return null;
        } // undefined
        buf = 0;
        for (var i = 0; i < len; ++i) {
            buf = (buf * 256) + stream.get();
        }
        return buf;
    };
    /**
     * Retrieve the hexadecimal value (as a string) of the current ASN.1 element
     * @returns {string}
     * @public
     */
    ASN1.prototype.getHexStringValue = function () {
        var hexString = this.toHexString();
        var offset = this.header * 2;
        var length = this.length * 2;
        return hexString.substr(offset, length);
    };
    ASN1.decode = function (str) {
        var stream;
        if (!(str instanceof Stream)) {
            stream = new Stream(str, 0);
        }
        else {
            stream = str;
        }
        var streamStart = new Stream(stream);
        var tag = new ASN1Tag(stream);
        var len = ASN1.decodeLength(stream);
        var start = stream.pos;
        var header = start - streamStart.pos;
        var sub = null;
        var getSub = function () {
            var ret = [];
            if (len !== null) {
                // definite length
                var end = start + len;
                while (stream.pos < end) {
                    ret[ret.length] = ASN1.decode(stream);
                }
                if (stream.pos != end) {
                    throw new Error("Content size is not correct for container starting at offset " + start);
                }
            }
            else {
                // undefined length
                try {
                    for (;;) {
                        var s = ASN1.decode(stream);
                        if (s.tag.isEOC()) {
                            break;
                        }
                        ret[ret.length] = s;
                    }
                    len = start - stream.pos; // undefined lengths are represented as negative values
                }
                catch (e) {
                    throw new Error("Exception while decoding undefined length content: " + e);
                }
            }
            return ret;
        };
        if (tag.tagConstructed) {
            // must have valid content
            sub = getSub();
        }
        else if (tag.isUniversal() && ((tag.tagNumber == 0x03) || (tag.tagNumber == 0x04))) {
            // sometimes BitString and OctetString are used to encapsulate ASN.1
            try {
                if (tag.tagNumber == 0x03) {
                    if (stream.get() != 0) {
                        throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
                    }
                }
                sub = getSub();
                for (var i = 0; i < sub.length; ++i) {
                    if (sub[i].tag.isEOC()) {
                        throw new Error("EOC is not supposed to be actual content.");
                    }
                }
            }
            catch (e) {
                // but silently ignore when they don't
                sub = null;
            }
        }
        if (sub === null) {
            if (len === null) {
                throw new Error("We can't skip over an invalid tag with undefined length at offset " + start);
            }
            stream.pos = start + Math.abs(len);
        }
        return new ASN1(streamStart, header, len, tag, sub);
    };
    return ASN1;
}());
var ASN1Tag = /** @class */ (function () {
    function ASN1Tag(stream) {
        var buf = stream.get();
        this.tagClass = buf >> 6;
        this.tagConstructed = ((buf & 0x20) !== 0);
        this.tagNumber = buf & 0x1F;
        if (this.tagNumber == 0x1F) { // long tag
            var n = new Int10();
            do {
                buf = stream.get();
                n.mulAdd(128, buf & 0x7F);
            } while (buf & 0x80);
            this.tagNumber = n.simplify();
        }
    }
    ASN1Tag.prototype.isUniversal = function () {
        return this.tagClass === 0x00;
    };
    ASN1Tag.prototype.isEOC = function () {
        return this.tagClass === 0x00 && this.tagNumber === 0x00;
    };
    return ASN1Tag;
}());

// Copyright (c) 2005  Tom Wu
// Bits per digit
var dbits;
// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary & 0xffffff) == 0xefcafe);
//#region
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
//#endregion
// (public) Constructor
var BigInteger = /** @class */ (function () {
    function BigInteger(a, b, c) {
        if (a != null) {
            if ("number" == typeof a) {
                this.fromNumber(a, b, c);
            }
            else if (b == null && "string" != typeof a) {
                this.fromString(a, 256);
            }
            else {
                this.fromString(a, b);
            }
        }
    }
    //#region PUBLIC
    // BigInteger.prototype.toString = bnToString;
    // (public) return string representation in given radix
    BigInteger.prototype.toString = function (b) {
        if (this.s < 0) {
            return "-" + this.negate().toString(b);
        }
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            return this.toRadix(b);
        }
        var km = (1 << k) - 1;
        var d;
        var m = false;
        var r = "";
        var i = this.t;
        var p = this.DB - (i * this.DB) % k;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
                m = true;
                r = int2char(d);
            }
            while (i >= 0) {
                if (p < k) {
                    d = (this[i] & ((1 << p) - 1)) << (k - p);
                    d |= this[--i] >> (p += this.DB - k);
                }
                else {
                    d = (this[i] >> (p -= k)) & km;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if (d > 0) {
                    m = true;
                }
                if (m) {
                    r += int2char(d);
                }
            }
        }
        return m ? r : "0";
    };
    // BigInteger.prototype.negate = bnNegate;
    // (public) -this
    BigInteger.prototype.negate = function () {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
    };
    // BigInteger.prototype.abs = bnAbs;
    // (public) |this|
    BigInteger.prototype.abs = function () {
        return (this.s < 0) ? this.negate() : this;
    };
    // BigInteger.prototype.compareTo = bnCompareTo;
    // (public) return + if this > a, - if this < a, 0 if equal
    BigInteger.prototype.compareTo = function (a) {
        var r = this.s - a.s;
        if (r != 0) {
            return r;
        }
        var i = this.t;
        r = i - a.t;
        if (r != 0) {
            return (this.s < 0) ? -r : r;
        }
        while (--i >= 0) {
            if ((r = this[i] - a[i]) != 0) {
                return r;
            }
        }
        return 0;
    };
    // BigInteger.prototype.bitLength = bnBitLength;
    // (public) return the number of bits in "this"
    BigInteger.prototype.bitLength = function () {
        if (this.t <= 0) {
            return 0;
        }
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
    };
    // BigInteger.prototype.mod = bnMod;
    // (public) this mod a
    BigInteger.prototype.mod = function (a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            a.subTo(r, r);
        }
        return r;
    };
    // BigInteger.prototype.modPowInt = bnModPowInt;
    // (public) this^e % m, 0 <= e < 2^32
    BigInteger.prototype.modPowInt = function (e, m) {
        var z;
        if (e < 256 || m.isEven()) {
            z = new Classic(m);
        }
        else {
            z = new Montgomery(m);
        }
        return this.exp(e, z);
    };
    // BigInteger.prototype.clone = bnClone;
    // (public)
    BigInteger.prototype.clone = function () {
        var r = nbi();
        this.copyTo(r);
        return r;
    };
    // BigInteger.prototype.intValue = bnIntValue;
    // (public) return value as integer
    BigInteger.prototype.intValue = function () {
        if (this.s < 0) {
            if (this.t == 1) {
                return this[0] - this.DV;
            }
            else if (this.t == 0) {
                return -1;
            }
        }
        else if (this.t == 1) {
            return this[0];
        }
        else if (this.t == 0) {
            return 0;
        }
        // assumes 16 < DB < 32
        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
    };
    // BigInteger.prototype.byteValue = bnByteValue;
    // (public) return value as byte
    BigInteger.prototype.byteValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
    };
    // BigInteger.prototype.shortValue = bnShortValue;
    // (public) return value as short (assumes DB>=16)
    BigInteger.prototype.shortValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
    };
    // BigInteger.prototype.signum = bnSigNum;
    // (public) 0 if this == 0, 1 if this > 0
    BigInteger.prototype.signum = function () {
        if (this.s < 0) {
            return -1;
        }
        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {
            return 0;
        }
        else {
            return 1;
        }
    };
    // BigInteger.prototype.toByteArray = bnToByteArray;
    // (public) convert to bigendian byte array
    BigInteger.prototype.toByteArray = function () {
        var i = this.t;
        var r = [];
        r[0] = this.s;
        var p = this.DB - (i * this.DB) % 8;
        var d;
        var k = 0;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {
                r[k++] = d | (this.s << (this.DB - p));
            }
            while (i >= 0) {
                if (p < 8) {
                    d = (this[i] & ((1 << p) - 1)) << (8 - p);
                    d |= this[--i] >> (p += this.DB - 8);
                }
                else {
                    d = (this[i] >> (p -= 8)) & 0xff;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if ((d & 0x80) != 0) {
                    d |= -256;
                }
                if (k == 0 && (this.s & 0x80) != (d & 0x80)) {
                    ++k;
                }
                if (k > 0 || d != this.s) {
                    r[k++] = d;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.equals = function (a) {
        return (this.compareTo(a) == 0);
    };
    // BigInteger.prototype.min = bnMin;
    BigInteger.prototype.min = function (a) {
        return (this.compareTo(a) < 0) ? this : a;
    };
    // BigInteger.prototype.max = bnMax;
    BigInteger.prototype.max = function (a) {
        return (this.compareTo(a) > 0) ? this : a;
    };
    // BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.and = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
    };
    // BigInteger.prototype.or = bnOr;
    BigInteger.prototype.or = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
    };
    // BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.xor = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
    };
    // BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.andNot = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
    };
    // BigInteger.prototype.not = bnNot;
    // (public) ~this
    BigInteger.prototype.not = function () {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) {
            r[i] = this.DM & ~this[i];
        }
        r.t = this.t;
        r.s = ~this.s;
        return r;
    };
    // BigInteger.prototype.shiftLeft = bnShiftLeft;
    // (public) this << n
    BigInteger.prototype.shiftLeft = function (n) {
        var r = nbi();
        if (n < 0) {
            this.rShiftTo(-n, r);
        }
        else {
            this.lShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.shiftRight = bnShiftRight;
    // (public) this >> n
    BigInteger.prototype.shiftRight = function (n) {
        var r = nbi();
        if (n < 0) {
            this.lShiftTo(-n, r);
        }
        else {
            this.rShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    // (public) returns index of lowest 1-bit (or -1 if none)
    BigInteger.prototype.getLowestSetBit = function () {
        for (var i = 0; i < this.t; ++i) {
            if (this[i] != 0) {
                return i * this.DB + lbit(this[i]);
            }
        }
        if (this.s < 0) {
            return this.t * this.DB;
        }
        return -1;
    };
    // BigInteger.prototype.bitCount = bnBitCount;
    // (public) return number of set bits
    BigInteger.prototype.bitCount = function () {
        var r = 0;
        var x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) {
            r += cbit(this[i] ^ x);
        }
        return r;
    };
    // BigInteger.prototype.testBit = bnTestBit;
    // (public) true iff nth bit is set
    BigInteger.prototype.testBit = function (n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) {
            return (this.s != 0);
        }
        return ((this[j] & (1 << (n % this.DB))) != 0);
    };
    // BigInteger.prototype.setBit = bnSetBit;
    // (public) this | (1<<n)
    BigInteger.prototype.setBit = function (n) {
        return this.changeBit(n, op_or);
    };
    // BigInteger.prototype.clearBit = bnClearBit;
    // (public) this & ~(1<<n)
    BigInteger.prototype.clearBit = function (n) {
        return this.changeBit(n, op_andnot);
    };
    // BigInteger.prototype.flipBit = bnFlipBit;
    // (public) this ^ (1<<n)
    BigInteger.prototype.flipBit = function (n) {
        return this.changeBit(n, op_xor);
    };
    // BigInteger.prototype.add = bnAdd;
    // (public) this + a
    BigInteger.prototype.add = function (a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
    };
    // BigInteger.prototype.subtract = bnSubtract;
    // (public) this - a
    BigInteger.prototype.subtract = function (a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
    };
    // BigInteger.prototype.multiply = bnMultiply;
    // (public) this * a
    BigInteger.prototype.multiply = function (a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
    };
    // BigInteger.prototype.divide = bnDivide;
    // (public) this / a
    BigInteger.prototype.divide = function (a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
    };
    // BigInteger.prototype.remainder = bnRemainder;
    // (public) this % a
    BigInteger.prototype.remainder = function (a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
    };
    // BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    // (public) [this/a,this%a]
    BigInteger.prototype.divideAndRemainder = function (a) {
        var q = nbi();
        var r = nbi();
        this.divRemTo(a, q, r);
        return [q, r];
    };
    // BigInteger.prototype.modPow = bnModPow;
    // (public) this^e % m (HAC 14.85)
    BigInteger.prototype.modPow = function (e, m) {
        var i = e.bitLength();
        var k;
        var r = nbv(1);
        var z;
        if (i <= 0) {
            return r;
        }
        else if (i < 18) {
            k = 1;
        }
        else if (i < 48) {
            k = 3;
        }
        else if (i < 144) {
            k = 4;
        }
        else if (i < 768) {
            k = 5;
        }
        else {
            k = 6;
        }
        if (i < 8) {
            z = new Classic(m);
        }
        else if (m.isEven()) {
            z = new Barrett(m);
        }
        else {
            z = new Montgomery(m);
        }
        // precomputation
        var g = [];
        var n = 3;
        var k1 = k - 1;
        var km = (1 << k) - 1;
        g[1] = z.convert(this);
        if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
                g[n] = nbi();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
            }
        }
        var j = e.t - 1;
        var w;
        var is1 = true;
        var r2 = nbi();
        var t;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
            if (i >= k1) {
                w = (e[j] >> (i - k1)) & km;
            }
            else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0) {
                    w |= e[j - 1] >> (this.DB + i - k1);
                }
            }
            n = k;
            while ((w & 1) == 0) {
                w >>= 1;
                --n;
            }
            if ((i -= n) < 0) {
                i += this.DB;
                --j;
            }
            if (is1) { // ret == 1, don't bother squaring or multiplying it
                g[w].copyTo(r);
                is1 = false;
            }
            else {
                while (n > 1) {
                    z.sqrTo(r, r2);
                    z.sqrTo(r2, r);
                    n -= 2;
                }
                if (n > 0) {
                    z.sqrTo(r, r2);
                }
                else {
                    t = r;
                    r = r2;
                    r2 = t;
                }
                z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2);
                t = r;
                r = r2;
                r2 = t;
                if (--i < 0) {
                    i = this.DB - 1;
                    --j;
                }
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.modInverse = bnModInverse;
    // (public) 1/this % m (HAC 14.61)
    BigInteger.prototype.modInverse = function (m) {
        var ac = m.isEven();
        if ((this.isEven() && ac) || m.signum() == 0) {
            return BigInteger.ZERO;
        }
        var u = m.clone();
        var v = this.clone();
        var a = nbv(1);
        var b = nbv(0);
        var c = nbv(0);
        var d = nbv(1);
        while (u.signum() != 0) {
            while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                    if (!a.isEven() || !b.isEven()) {
                        a.addTo(this, a);
                        b.subTo(m, b);
                    }
                    a.rShiftTo(1, a);
                }
                else if (!b.isEven()) {
                    b.subTo(m, b);
                }
                b.rShiftTo(1, b);
            }
            while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                    if (!c.isEven() || !d.isEven()) {
                        c.addTo(this, c);
                        d.subTo(m, d);
                    }
                    c.rShiftTo(1, c);
                }
                else if (!d.isEven()) {
                    d.subTo(m, d);
                }
                d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac) {
                    a.subTo(c, a);
                }
                b.subTo(d, b);
            }
            else {
                v.subTo(u, v);
                if (ac) {
                    c.subTo(a, c);
                }
                d.subTo(b, d);
            }
        }
        if (v.compareTo(BigInteger.ONE) != 0) {
            return BigInteger.ZERO;
        }
        if (d.compareTo(m) >= 0) {
            return d.subtract(m);
        }
        if (d.signum() < 0) {
            d.addTo(m, d);
        }
        else {
            return d;
        }
        if (d.signum() < 0) {
            return d.add(m);
        }
        else {
            return d;
        }
    };
    // BigInteger.prototype.pow = bnPow;
    // (public) this^e
    BigInteger.prototype.pow = function (e) {
        return this.exp(e, new NullExp());
    };
    // BigInteger.prototype.gcd = bnGCD;
    // (public) gcd(this,a) (HAC 14.54)
    BigInteger.prototype.gcd = function (a) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            return x;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
        }
        if (g > 0) {
            y.lShiftTo(g, y);
        }
        return y;
    };
    // BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    // (public) test primality with certainty >= 1-.5^t
    BigInteger.prototype.isProbablePrime = function (t) {
        var i;
        var x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i) {
                if (x[0] == lowprimes[i]) {
                    return true;
                }
            }
            return false;
        }
        if (x.isEven()) {
            return false;
        }
        i = 1;
        while (i < lowprimes.length) {
            var m = lowprimes[i];
            var j = i + 1;
            while (j < lowprimes.length && m < lplim) {
                m *= lowprimes[j++];
            }
            m = x.modInt(m);
            while (i < j) {
                if (m % lowprimes[i++] == 0) {
                    return false;
                }
            }
        }
        return x.millerRabin(t);
    };
    //#endregion PUBLIC
    //#region PROTECTED
    // BigInteger.prototype.copyTo = bnpCopyTo;
    // (protected) copy this to r
    BigInteger.prototype.copyTo = function (r) {
        for (var i = this.t - 1; i >= 0; --i) {
            r[i] = this[i];
        }
        r.t = this.t;
        r.s = this.s;
    };
    // BigInteger.prototype.fromInt = bnpFromInt;
    // (protected) set from integer value x, -DV <= x < DV
    BigInteger.prototype.fromInt = function (x) {
        this.t = 1;
        this.s = (x < 0) ? -1 : 0;
        if (x > 0) {
            this[0] = x;
        }
        else if (x < -1) {
            this[0] = x + this.DV;
        }
        else {
            this.t = 0;
        }
    };
    // BigInteger.prototype.fromString = bnpFromString;
    // (protected) set from string and radix
    BigInteger.prototype.fromString = function (s, b) {
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 256) {
            k = 8;
            /* byte array */
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            this.fromRadix(s, b);
            return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length;
        var mi = false;
        var sh = 0;
        while (--i >= 0) {
            var x = (k == 8) ? (+s[i]) & 0xff : intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-") {
                    mi = true;
                }
                continue;
            }
            mi = false;
            if (sh == 0) {
                this[this.t++] = x;
            }
            else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                this[this.t++] = (x >> (this.DB - sh));
            }
            else {
                this[this.t - 1] |= x << sh;
            }
            sh += k;
            if (sh >= this.DB) {
                sh -= this.DB;
            }
        }
        if (k == 8 && ((+s[0]) & 0x80) != 0) {
            this.s = -1;
            if (sh > 0) {
                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
            }
        }
        this.clamp();
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.clamp = bnpClamp;
    // (protected) clamp off excess high words
    BigInteger.prototype.clamp = function () {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) {
            --this.t;
        }
    };
    // BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    // (protected) r = this << n*DB
    BigInteger.prototype.dlShiftTo = function (n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) {
            r[i + n] = this[i];
        }
        for (i = n - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r.t = this.t + n;
        r.s = this.s;
    };
    // BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    // (protected) r = this >> n*DB
    BigInteger.prototype.drShiftTo = function (n, r) {
        for (var i = n; i < this.t; ++i) {
            r[i - n] = this[i];
        }
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
    };
    // BigInteger.prototype.lShiftTo = bnpLShiftTo;
    // (protected) r = this << n
    BigInteger.prototype.lShiftTo = function (n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB);
        var c = (this.s << bs) & this.DM;
        for (var i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = (this[i] >> cbs) | c;
            c = (this[i] & bm) << bs;
        }
        for (var i = ds - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
    };
    // BigInteger.prototype.rShiftTo = bnpRShiftTo;
    // (protected) r = this >> n
    BigInteger.prototype.rShiftTo = function (n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
            r.t = 0;
            return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) {
            r[this.t - ds - 1] |= (this.s & bm) << cbs;
        }
        r.t = this.t - ds;
        r.clamp();
    };
    // BigInteger.prototype.subTo = bnpSubTo;
    // (protected) r = this - a
    BigInteger.prototype.subTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c -= a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c -= a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c < -1) {
            r[i++] = this.DV + c;
        }
        else if (c > 0) {
            r[i++] = c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyTo = function (a, r) {
        var x = this.abs();
        var y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < y.t; ++i) {
            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        }
        r.s = 0;
        r.clamp();
        if (this.s != a.s) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.squareTo = bnpSquareTo;
    // (protected) r = this^2, r != this (HAC 14.16)
    BigInteger.prototype.squareTo = function (r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
            }
        }
        if (r.t > 0) {
            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        }
        r.s = 0;
        r.clamp();
    };
    // BigInteger.prototype.divRemTo = bnpDivRemTo;
    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    BigInteger.prototype.divRemTo = function (m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) {
            return;
        }
        var pt = this.abs();
        if (pt.t < pm.t) {
            if (q != null) {
                q.fromInt(0);
            }
            if (r != null) {
                this.copyTo(r);
            }
            return;
        }
        if (r == null) {
            r = nbi();
        }
        var y = nbi();
        var ts = this.s;
        var ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
        if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
        }
        else {
            pm.copyTo(y);
            pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) {
            return;
        }
        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt;
        var d2 = (1 << this.F1) / yt;
        var e = 1 << this.F2;
        var i = r.t;
        var j = i - ys;
        var t = (q == null) ? nbi() : q;
        y.dlShiftTo(j, t);
        if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t);
        t.subTo(y, y); // "negative" y so we can replace sub with am later
        while (y.t < ys) {
            y[y.t++] = 0;
        }
        while (--j >= 0) {
            // Estimate quotient digit
            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd) {
                    r.subTo(t, r);
                }
            }
        }
        if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) {
                BigInteger.ZERO.subTo(q, q);
            }
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) {
            r.rShiftTo(nsh, r);
        } // Denormalize remainder
        if (ts < 0) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.invDigit = bnpInvDigit;
    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    BigInteger.prototype.invDigit = function () {
        if (this.t < 1) {
            return 0;
        }
        var x = this[0];
        if ((x & 1) == 0) {
            return 0;
        }
        var y = x & 3; // y == 1/x mod 2^2
        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
        // last step - calculate inverse mod DV directly;
        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
        y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
        // we really want the negative inverse, and -DV < y < DV
        return (y > 0) ? this.DV - y : -y;
    };
    // BigInteger.prototype.isEven = bnpIsEven;
    // (protected) true iff this is even
    BigInteger.prototype.isEven = function () {
        return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
    };
    // BigInteger.prototype.exp = bnpExp;
    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    BigInteger.prototype.exp = function (e, z) {
        if (e > 0xffffffff || e < 1) {
            return BigInteger.ONE;
        }
        var r = nbi();
        var r2 = nbi();
        var g = z.convert(this);
        var i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & (1 << i)) > 0) {
                z.mulTo(r2, g, r);
            }
            else {
                var t = r;
                r = r2;
                r2 = t;
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.chunkSize = bnpChunkSize;
    // (protected) return x s.t. r^x < DV
    BigInteger.prototype.chunkSize = function (r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
    };
    // BigInteger.prototype.toRadix = bnpToRadix;
    // (protected) convert to radix string
    BigInteger.prototype.toRadix = function (b) {
        if (b == null) {
            b = 10;
        }
        if (this.signum() == 0 || b < 2 || b > 36) {
            return "0";
        }
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a);
        var y = nbi();
        var z = nbi();
        var r = "";
        this.divRemTo(d, y, z);
        while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
        }
        return z.intValue().toString(b) + r;
    };
    // BigInteger.prototype.fromRadix = bnpFromRadix;
    // (protected) convert from radix string
    BigInteger.prototype.fromRadix = function (s, b) {
        this.fromInt(0);
        if (b == null) {
            b = 10;
        }
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs);
        var mi = false;
        var j = 0;
        var w = 0;
        for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0) {
                    mi = true;
                }
                continue;
            }
            w = b * w + x;
            if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
            }
        }
        if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
        }
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.fromNumber = bnpFromNumber;
    // (protected) alternate constructor
    BigInteger.prototype.fromNumber = function (a, b, c) {
        if ("number" == typeof b) {
            // new BigInteger(int,int,RNG)
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    // force MSB set
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                } // force odd
                while (!this.isProbablePrime(b)) {
                    this.dAddOffset(2, 0);
                    if (this.bitLength() > a) {
                        this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                    }
                }
            }
        }
        else {
            // new BigInteger(int,RNG)
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    // BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    // (protected) r = this op a (bitwise)
    BigInteger.prototype.bitwiseTo = function (a, op, r) {
        var i;
        var f;
        var m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) {
            r[i] = op(this[i], a[i]);
        }
        if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) {
                r[i] = op(this[i], f);
            }
            r.t = this.t;
        }
        else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) {
                r[i] = op(f, a[i]);
            }
            r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
    };
    // BigInteger.prototype.changeBit = bnpChangeBit;
    // (protected) this op (1<<n)
    BigInteger.prototype.changeBit = function (n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
    };
    // BigInteger.prototype.addTo = bnpAddTo;
    // (protected) r = this + a
    BigInteger.prototype.addTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c += a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c > 0) {
            r[i++] = c;
        }
        else if (c < -1) {
            r[i++] = this.DV + c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.dMultiply = bnpDMultiply;
    // (protected) this *= n, this >= 0, 1 < n < DV
    BigInteger.prototype.dMultiply = function (n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
    };
    // BigInteger.prototype.dAddOffset = bnpDAddOffset;
    // (protected) this += n << w words, this >= 0
    BigInteger.prototype.dAddOffset = function (n, w) {
        if (n == 0) {
            return;
        }
        while (this.t <= w) {
            this[this.t++] = 0;
        }
        this[w] += n;
        while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) {
                this[this.t++] = 0;
            }
            ++this[w];
        }
    };
    // BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0; // assumes a,this >= 0
        r.t = i;
        while (i > 0) {
            r[--i] = 0;
        }
        for (var j = r.t - this.t; i < j; ++i) {
            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        }
        for (var j = Math.min(a.t, n); i < j; ++i) {
            this.am(0, a[i], r, i, 0, n - i);
        }
        r.clamp();
    };
    // BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0; // assumes a,this >= 0
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        }
        r.clamp();
        r.drShiftTo(1, r);
    };
    // BigInteger.prototype.modInt = bnpModInt;
    // (protected) this % n, n < 2^26
    BigInteger.prototype.modInt = function (n) {
        if (n <= 0) {
            return 0;
        }
        var d = this.DV % n;
        var r = (this.s < 0) ? n - 1 : 0;
        if (this.t > 0) {
            if (d == 0) {
                r = this[0] % n;
            }
            else {
                for (var i = this.t - 1; i >= 0; --i) {
                    r = (d * r + this[i]) % n;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.millerRabin = bnpMillerRabin;
    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    BigInteger.prototype.millerRabin = function (t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) {
            return false;
        }
        var r = n1.shiftRight(k);
        t = (t + 1) >> 1;
        if (t > lowprimes.length) {
            t = lowprimes.length;
        }
        var a = nbi();
        for (var i = 0; i < t; ++i) {
            // Pick bases at random, instead of starting at 2
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                    y = y.modPowInt(2, this);
                    if (y.compareTo(BigInteger.ONE) == 0) {
                        return false;
                    }
                }
                if (y.compareTo(n1) != 0) {
                    return false;
                }
            }
        }
        return true;
    };
    // BigInteger.prototype.square = bnSquare;
    // (public) this^2
    BigInteger.prototype.square = function () {
        var r = nbi();
        this.squareTo(r);
        return r;
    };
    //#region ASYNC
    // Public API method
    BigInteger.prototype.gcda = function (a, callback) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            callback(x);
            return;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        // Workhorse of the algorithm, gets called 200 - 800 times per 512 bit keygen.
        var gcda1 = function () {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
            if (!(x.signum() > 0)) {
                if (g > 0) {
                    y.lShiftTo(g, y);
                }
                setTimeout(function () { callback(y); }, 0); // escape
            }
            else {
                setTimeout(gcda1, 0);
            }
        };
        setTimeout(gcda1, 10);
    };
    // (protected) alternate constructor
    BigInteger.prototype.fromNumberAsync = function (a, b, c, callback) {
        if ("number" == typeof b) {
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                }
                var bnp_1 = this;
                var bnpfn1_1 = function () {
                    bnp_1.dAddOffset(2, 0);
                    if (bnp_1.bitLength() > a) {
                        bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);
                    }
                    if (bnp_1.isProbablePrime(b)) {
                        setTimeout(function () { callback(); }, 0); // escape
                    }
                    else {
                        setTimeout(bnpfn1_1, 0);
                    }
                };
                setTimeout(bnpfn1_1, 0);
            }
        }
        else {
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    return BigInteger;
}());
//#region REDUCERS
//#region NullExp
var NullExp = /** @class */ (function () {
    function NullExp() {
    }
    // NullExp.prototype.convert = nNop;
    NullExp.prototype.convert = function (x) {
        return x;
    };
    // NullExp.prototype.revert = nNop;
    NullExp.prototype.revert = function (x) {
        return x;
    };
    // NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
    };
    // NullExp.prototype.sqrTo = nSqrTo;
    NullExp.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
    };
    return NullExp;
}());
// Modular reduction using "classic" algorithm
var Classic = /** @class */ (function () {
    function Classic(m) {
        this.m = m;
    }
    // Classic.prototype.convert = cConvert;
    Classic.prototype.convert = function (x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) {
            return x.mod(this.m);
        }
        else {
            return x;
        }
    };
    // Classic.prototype.revert = cRevert;
    Classic.prototype.revert = function (x) {
        return x;
    };
    // Classic.prototype.reduce = cReduce;
    Classic.prototype.reduce = function (x) {
        x.divRemTo(this.m, null, x);
    };
    // Classic.prototype.mulTo = cMulTo;
    Classic.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Classic.prototype.sqrTo = cSqrTo;
    Classic.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Classic;
}());
//#endregion
//#region Montgomery
// Montgomery reduction
var Montgomery = /** @class */ (function () {
    function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 0x7fff;
        this.mph = this.mp >> 15;
        this.um = (1 << (m.DB - 15)) - 1;
        this.mt2 = 2 * m.t;
    }
    // Montgomery.prototype.convert = montConvert;
    // xR mod m
    Montgomery.prototype.convert = function (x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            this.m.subTo(r, r);
        }
        return r;
    };
    // Montgomery.prototype.revert = montRevert;
    // x/R mod m
    Montgomery.prototype.revert = function (x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
    };
    // Montgomery.prototype.reduce = montReduce;
    // x = x/R mod m (HAC 14.32)
    Montgomery.prototype.reduce = function (x) {
        while (x.t <= this.mt2) {
            // pad x so am has enough room later
            x[x.t++] = 0;
        }
        for (var i = 0; i < this.m.t; ++i) {
            // faster way of calculating u0 = x[i]*mp mod DV
            var j = x[i] & 0x7fff;
            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
            // use am to combine the multiply-shift-add into one call
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            // propagate carry
            while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
            }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Montgomery.prototype.mulTo = montMulTo;
    // r = "xy/R mod m"; x,y != r
    Montgomery.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Montgomery.prototype.sqrTo = montSqrTo;
    // r = "x^2/R mod m"; x != r
    Montgomery.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Montgomery;
}());
//#endregion Montgomery
//#region Barrett
// Barrett modular reduction
var Barrett = /** @class */ (function () {
    function Barrett(m) {
        this.m = m;
        // setup Barrett
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
    }
    // Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.convert = function (x) {
        if (x.s < 0 || x.t > 2 * this.m.t) {
            return x.mod(this.m);
        }
        else if (x.compareTo(this.m) < 0) {
            return x;
        }
        else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
        }
    };
    // Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.revert = function (x) {
        return x;
    };
    // Barrett.prototype.reduce = barrettReduce;
    // x = x mod m (HAC 14.42)
    Barrett.prototype.reduce = function (x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) {
            x.dAddOffset(1, this.m.t + 1);
        }
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Barrett.prototype.mulTo = barrettMulTo;
    // r = x*y mod m; x,y != r
    Barrett.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Barrett.prototype.sqrTo = barrettSqrTo;
    // r = x^2 mod m; x != r
    Barrett.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Barrett;
}());
//#endregion
//#endregion REDUCERS
// return new, unset BigInteger
function nbi() { return new BigInteger(null); }
function parseBigInt(str, r) {
    return new BigInteger(str, r);
}
// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
    while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 0x4000000);
        w[j++] = v & 0x3ffffff;
    }
    return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
    var xl = x & 0x7fff;
    var xh = x >> 15;
    while (--n >= 0) {
        var l = this[i] & 0x7fff;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 0x3fffffff;
    }
    return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
    var xl = x & 0x3fff;
    var xh = x >> 14;
    while (--n >= 0) {
        var l = this[i] & 0x3fff;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 0xfffffff;
    }
    return c;
}
if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    BigInteger.prototype.am = am2;
    dbits = 30;
}
else if (j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
// Digit conversions
var BI_RC = [];
var rr;
var vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
}
// return bigint initialized to value
function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
}
// returns bit length of the integer x
function nbits(x) {
    var r = 1;
    var t;
    if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
    }
    if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
    }
    if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
    }
    if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
    }
    if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
    }
    return r;
}
// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// prng4.js - uses Arcfour as a PRNG
var Arcfour = /** @class */ (function () {
    function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = [];
    }
    // Arcfour.prototype.init = ARC4init;
    // Initialize arcfour context from key, an array of ints, each from [0..255]
    Arcfour.prototype.init = function (key) {
        var i;
        var j;
        var t;
        for (i = 0; i < 256; ++i) {
            this.S[i] = i;
        }
        j = 0;
        for (i = 0; i < 256; ++i) {
            j = (j + this.S[i] + key[i % key.length]) & 255;
            t = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t;
        }
        this.i = 0;
        this.j = 0;
    };
    // Arcfour.prototype.next = ARC4next;
    Arcfour.prototype.next = function () {
        var t;
        this.i = (this.i + 1) & 255;
        this.j = (this.j + this.S[this.i]) & 255;
        t = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t;
        return this.S[(t + this.S[this.i]) & 255];
    };
    return Arcfour;
}());
// Plug in your RNG constructor here
function prng_newstate() {
    return new Arcfour();
}
// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;

// Random number generator - requires a PRNG backend, e.g. prng4.js
var rng_state;
var rng_pool = null;
var rng_pptr;
// Initialize the pool with junk if needed.
if (rng_pool == null) {
    rng_pool = [];
    rng_pptr = 0;
    var t = void 0;
    if (window.crypto && window.crypto.getRandomValues) {
        // Extract entropy (2048 bits) from RNG if available
        var z = new Uint32Array(256);
        window.crypto.getRandomValues(z);
        for (t = 0; t < z.length; ++t) {
            rng_pool[rng_pptr++] = z[t] & 255;
        }
    }
    // Use mouse events for entropy, if we do not have enough entropy by the time
    // we need it, entropy will be generated by Math.random.
    var onMouseMoveListener_1 = function (ev) {
        this.count = this.count || 0;
        if (this.count >= 256 || rng_pptr >= rng_psize) {
            if (window.removeEventListener) {
                window.removeEventListener("mousemove", onMouseMoveListener_1, false);
            }
            else if (window.detachEvent) {
                window.detachEvent("onmousemove", onMouseMoveListener_1);
            }
            return;
        }
        try {
            var mouseCoordinates = ev.x + ev.y;
            rng_pool[rng_pptr++] = mouseCoordinates & 255;
            this.count += 1;
        }
        catch (e) {
            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.
        }
    };
    if (window.addEventListener) {
        window.addEventListener("mousemove", onMouseMoveListener_1, false);
    }
    else if (window.attachEvent) {
        window.attachEvent("onmousemove", onMouseMoveListener_1);
    }
}
function rng_get_byte() {
    if (rng_state == null) {
        rng_state = prng_newstate();
        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random
        while (rng_pptr < rng_psize) {
            var random = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = random & 255;
        }
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
            rng_pool[rng_pptr] = 0;
        }
        rng_pptr = 0;
    }
    // TODO: allow reseeding after first request
    return rng_state.next();
}
var SecureRandom = /** @class */ (function () {
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = function (ba) {
        for (var i = 0; i < ba.length; ++i) {
            ba[i] = rng_get_byte();
        }
    };
    return SecureRandom;
}());

// Depends on jsbn.js and rng.js
// function linebrk(s,n) {
//   var ret = "";
//   var i = 0;
//   while(i + n < s.length) {
//     ret += s.substring(i,i+n) + "\n";
//     i += n;
//   }
//   return ret + s.substring(i,s.length);
// }
// function byte2Hex(b) {
//   if(b < 0x10)
//     return "0" + b.toString(16);
//   else
//     return b.toString(16);
// }
function pkcs1pad1(s, n) {
    if (n < s.length + 22) {
        console.error("Message too long for RSA");
        return null;
    }
    var len = n - s.length - 6;
    var filler = "";
    for (var f = 0; f < len; f += 2) {
        filler += "ff";
    }
    var m = "0001" + filler + "00" + s;
    return parseBigInt(m, 16);
}
// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s, n) {
    if (n < s.length + 11) { // TODO: fix for utf-8
        console.error("Message too long for RSA");
        return null;
    }
    var ba = [];
    var i = s.length - 1;
    while (i >= 0 && n > 0) {
        var c = s.charCodeAt(i--);
        if (c < 128) { // encode using utf-8
            ba[--n] = c;
        }
        else if ((c > 127) && (c < 2048)) {
            ba[--n] = (c & 63) | 128;
            ba[--n] = (c >> 6) | 192;
        }
        else {
            ba[--n] = (c & 63) | 128;
            ba[--n] = ((c >> 6) & 63) | 128;
            ba[--n] = (c >> 12) | 224;
        }
    }
    ba[--n] = 0;
    var rng = new SecureRandom();
    var x = [];
    while (n > 2) { // random non-zero pad
        x[0] = 0;
        while (x[0] == 0) {
            rng.nextBytes(x);
        }
        ba[--n] = x[0];
    }
    ba[--n] = 2;
    ba[--n] = 0;
    return new BigInteger(ba);
}
// "empty" RSA key constructor
var RSAKey = /** @class */ (function () {
    function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
    }
    //#region PROTECTED
    // protected
    // RSAKey.prototype.doPublic = RSADoPublic;
    // Perform raw public operation on "x": return x^e (mod n)
    RSAKey.prototype.doPublic = function (x) {
        return x.modPowInt(this.e, this.n);
    };
    // RSAKey.prototype.doPrivate = RSADoPrivate;
    // Perform raw private operation on "x": return x^d (mod n)
    RSAKey.prototype.doPrivate = function (x) {
        if (this.p == null || this.q == null) {
            return x.modPow(this.d, this.n);
        }
        // TODO: re-calculate any missing CRT params
        var xp = x.mod(this.p).modPow(this.dmp1, this.p);
        var xq = x.mod(this.q).modPow(this.dmq1, this.q);
        while (xp.compareTo(xq) < 0) {
            xp = xp.add(this.p);
        }
        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
    };
    //#endregion PROTECTED
    //#region PUBLIC
    // RSAKey.prototype.setPublic = RSASetPublic;
    // Set the public key fields N and e from hex strings
    RSAKey.prototype.setPublic = function (N, E) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
        }
        else {
            console.error("Invalid RSA public key");
        }
    };
    // RSAKey.prototype.encrypt = RSAEncrypt;
    // Return the PKCS#1 RSA encryption of "text" as an even-length hex string
    RSAKey.prototype.encrypt = function (text) {
        var m = pkcs1pad2(text, (this.n.bitLength() + 7) >> 3);
        if (m == null) {
            return null;
        }
        var c = this.doPublic(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    // RSAKey.prototype.setPrivate = RSASetPrivate;
    // Set the private key fields N, e, and d from hex strings
    RSAKey.prototype.setPrivate = function (N, E, D) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
    // Set the private key fields N, e, d and CRT params from hex strings
    RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
            this.p = parseBigInt(P, 16);
            this.q = parseBigInt(Q, 16);
            this.dmp1 = parseBigInt(DP, 16);
            this.dmq1 = parseBigInt(DQ, 16);
            this.coeff = parseBigInt(C, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.generate = RSAGenerate;
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generate = function (B, E) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        for (;;) {
            for (;;) {
                this.p = new BigInteger(B - qs, 1, rng);
                if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
                    break;
                }
            }
            for (;;) {
                this.q = new BigInteger(qs, 1, rng);
                if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
                    break;
                }
            }
            if (this.p.compareTo(this.q) <= 0) {
                var t = this.p;
                this.p = this.q;
                this.q = t;
            }
            var p1 = this.p.subtract(BigInteger.ONE);
            var q1 = this.q.subtract(BigInteger.ONE);
            var phi = p1.multiply(q1);
            if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                this.n = this.p.multiply(this.q);
                this.d = ee.modInverse(phi);
                this.dmp1 = this.d.mod(p1);
                this.dmq1 = this.d.mod(q1);
                this.coeff = this.q.modInverse(this.p);
                break;
            }
        }
    };
    // RSAKey.prototype.decrypt = RSADecrypt;
    // Return the PKCS#1 RSA decryption of "ctext".
    // "ctext" is an even-length hex string and the output is a plain string.
    RSAKey.prototype.decrypt = function (ctext) {
        var c = parseBigInt(ctext, 16);
        var m = this.doPrivate(c);
        if (m == null) {
            return null;
        }
        return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);
    };
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generateAsync = function (B, E, callback) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        var rsa = this;
        // These functions have non-descript names because they were originally for(;;) loops.
        // I don't know about cryptography to give them better names than loop1-4.
        var loop1 = function () {
            var loop4 = function () {
                if (rsa.p.compareTo(rsa.q) <= 0) {
                    var t = rsa.p;
                    rsa.p = rsa.q;
                    rsa.q = t;
                }
                var p1 = rsa.p.subtract(BigInteger.ONE);
                var q1 = rsa.q.subtract(BigInteger.ONE);
                var phi = p1.multiply(q1);
                if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                    rsa.n = rsa.p.multiply(rsa.q);
                    rsa.d = ee.modInverse(phi);
                    rsa.dmp1 = rsa.d.mod(p1);
                    rsa.dmq1 = rsa.d.mod(q1);
                    rsa.coeff = rsa.q.modInverse(rsa.p);
                    setTimeout(function () { callback(); }, 0); // escape
                }
                else {
                    setTimeout(loop1, 0);
                }
            };
            var loop3 = function () {
                rsa.q = nbi();
                rsa.q.fromNumberAsync(qs, 1, rng, function () {
                    rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
                            setTimeout(loop4, 0);
                        }
                        else {
                            setTimeout(loop3, 0);
                        }
                    });
                });
            };
            var loop2 = function () {
                rsa.p = nbi();
                rsa.p.fromNumberAsync(B - qs, 1, rng, function () {
                    rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
                            setTimeout(loop3, 0);
                        }
                        else {
                            setTimeout(loop2, 0);
                        }
                    });
                });
            };
            setTimeout(loop2, 0);
        };
        setTimeout(loop1, 0);
    };
    RSAKey.prototype.sign = function (text, digestMethod, digestName) {
        var header = getDigestHeader(digestName);
        var digest = header + digestMethod(text).toString();
        var m = pkcs1pad1(digest, this.n.bitLength() / 4);
        if (m == null) {
            return null;
        }
        var c = this.doPrivate(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    RSAKey.prototype.verify = function (text, signature, digestMethod) {
        var c = parseBigInt(signature, 16);
        var m = this.doPublic(c);
        if (m == null) {
            return null;
        }
        var unpadded = m.toString(16).replace(/^1f+00/, "");
        var digest = removeDigestHeader(unpadded);
        return digest == digestMethod(text).toString();
    };
    return RSAKey;
}());
// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d, n) {
    var b = d.toByteArray();
    var i = 0;
    while (i < b.length && b[i] == 0) {
        ++i;
    }
    if (b.length - i != n - 1 || b[i] != 2) {
        return null;
    }
    ++i;
    while (b[i] != 0) {
        if (++i >= b.length) {
            return null;
        }
    }
    var ret = "";
    while (++i < b.length) {
        var c = b[i] & 255;
        if (c < 128) { // utf-8 decode
            ret += String.fromCharCode(c);
        }
        else if ((c > 191) && (c < 224)) {
            ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
            ++i;
        }
        else {
            ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
            i += 2;
        }
    }
    return ret;
}
// https://tools.ietf.org/html/rfc3447#page-43
var DIGEST_HEADERS = {
    md2: "3020300c06082a864886f70d020205000410",
    md5: "3020300c06082a864886f70d020505000410",
    sha1: "3021300906052b0e03021a05000414",
    sha224: "302d300d06096086480165030402040500041c",
    sha256: "3031300d060960864801650304020105000420",
    sha384: "3041300d060960864801650304020205000430",
    sha512: "3051300d060960864801650304020305000440",
    ripemd160: "3021300906052b2403020105000414",
};
function getDigestHeader(name) {
    return DIGEST_HEADERS[name] || "";
}
function removeDigestHeader(str) {
    for (var name_1 in DIGEST_HEADERS) {
        if (DIGEST_HEADERS.hasOwnProperty(name_1)) {
            var header = DIGEST_HEADERS[name_1];
            var len = header.length;
            if (str.substr(0, len) == header) {
                return str.substr(len);
            }
        }
    }
    return str;
}
// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
// function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
// }
// public
// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
var YAHOO = {};
YAHOO.lang = {
    /**
     * Utility to set up the prototype, constructor and superclass properties to
     * support an inheritance strategy that can chain constructors and methods.
     * Static members will not be inherited.
     *
     * @method extend
     * @static
     * @param {Function} subc   the object to modify
     * @param {Function} superc the object to inherit
     * @param {Object} overrides  additional properties/methods to add to the
     *                              subclass prototype.  These will override the
     *                              matching items obtained from the superclass
     *                              if present.
     */
    extend: function(subc, superc, overrides) {
        if (! superc || ! subc) {
            throw new Error("YAHOO.lang.extend failed, please check that " +
                "all dependencies are included.");
        }

        var F = function() {};
        F.prototype = superc.prototype;
        subc.prototype = new F();
        subc.prototype.constructor = subc;
        subc.superclass = superc.prototype;

        if (superc.prototype.constructor == Object.prototype.constructor) {
            superc.prototype.constructor = superc;
        }

        if (overrides) {
            var i;
            for (i in overrides) {
                subc.prototype[i] = overrides[i];
            }

            /*
             * IE will not enumerate native functions in a derived object even if the
             * function was overridden.  This is a workaround for specific functions
             * we care about on the Object prototype.
             * @property _IEEnumFix
             * @param {Function} r  the object to receive the augmentation
             * @param {Function} s  the object that supplies the properties to augment
             * @static
             * @private
             */
            var _IEEnumFix = function() {},
                ADD = ["toString", "valueOf"];
            try {
                if (/MSIE/.test(navigator.userAgent)) {
                    _IEEnumFix = function(r, s) {
                        for (i = 0; i < ADD.length; i = i + 1) {
                            var fname = ADD[i], f = s[fname];
                            if (typeof f === 'function' && f != Object.prototype[fname]) {
                                r[fname] = f;
                            }
                        }
                    };
                }
            } catch (ex) {}            _IEEnumFix(subc.prototype, overrides);
        }
    }
};

/* asn1-1.0.13.js (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */

/**
 * @fileOverview
 * @name asn1-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version asn1 1.0.13 (2017-Jun-02)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * kjur's class library name space
 * <p>
 * This name space provides following name spaces:
 * <ul>
 * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>
 * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>
 * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature
 * class and utilities</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * @name KJUR
 * @namespace kjur's class library name space
 */
var KJUR = {};

/**
 * kjur's ASN.1 class library name space
 * <p>
 * This is ITU-T X.690 ASN.1 DER encoder class library and
 * class structure and methods is very similar to
 * org.bouncycastle.asn1 package of
 * well known BouncyCaslte Cryptography Library.
 * <h4>PROVIDING ASN.1 PRIMITIVES</h4>
 * Here are ASN.1 DER primitive classes.
 * <ul>
 * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>
 * <li>0x02 {@link KJUR.asn1.DERInteger}</li>
 * <li>0x03 {@link KJUR.asn1.DERBitString}</li>
 * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>
 * <li>0x05 {@link KJUR.asn1.DERNull}</li>
 * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>
 * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>
 * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>
 * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>
 * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>
 * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>
 * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>
 * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>
 * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>
 * <li>0x30 {@link KJUR.asn1.DERSequence}</li>
 * <li>0x31 {@link KJUR.asn1.DERSet}</li>
 * </ul>
 * <h4>OTHER ASN.1 CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ASN1Object}</li>
 * <li>{@link KJUR.asn1.DERAbstractString}</li>
 * <li>{@link KJUR.asn1.DERAbstractTime}</li>
 * <li>{@link KJUR.asn1.DERAbstractStructured}</li>
 * <li>{@link KJUR.asn1.DERTaggedObject}</li>
 * </ul>
 * <h4>SUB NAME SPACES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>
 * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>
 * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>
 * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>
 * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace.
 * This caused by a bug of jsdoc2.
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * ASN1 utilities class
 * @name KJUR.asn1.ASN1Util
 * @class ASN1 utilities class
 * @since asn1 1.0.2
 */
KJUR.asn1.ASN1Util = new function() {
    this.integerToByteHex = function(i) {
        var h = i.toString(16);
        if ((h.length % 2) == 1) h = '0' + h;
        return h;
    };
    this.bigIntToMinTwosComplementsHex = function(bigIntegerValue) {
        var h = bigIntegerValue.toString(16);
        if (h.substr(0, 1) != '-') {
            if (h.length % 2 == 1) {
                h = '0' + h;
            } else {
                if (! h.match(/^[0-7]/)) {
                    h = '00' + h;
                }
            }
        } else {
            var hPos = h.substr(1);
            var xorLen = hPos.length;
            if (xorLen % 2 == 1) {
                xorLen += 1;
            } else {
                if (! h.match(/^[0-7]/)) {
                    xorLen += 2;
                }
            }
            var hMask = '';
            for (var i = 0; i < xorLen; i++) {
                hMask += 'f';
            }
            var biMask = new BigInteger(hMask, 16);
            var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
            h = biNeg.toString(16).replace(/^-/, '');
        }
        return h;
    };
    /**
     * get PEM string from hexadecimal data and header string
     * @name getPEMStringFromHex
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {String} dataHex hexadecimal string of PEM body
     * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
     * @return {String} PEM formatted string of input data
     * @description
     * This method converts a hexadecimal string to a PEM string with
     * a specified header. Its line break will be CRLF("\r\n").
     * @example
     * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');
     * // value of pem will be:
     * -----BEGIN PRIVATE KEY-----
     * YWFh
     * -----END PRIVATE KEY-----
     */
    this.getPEMStringFromHex = function(dataHex, pemHeader) {
        return hextopem(dataHex, pemHeader);
    };

    /**
     * generate ASN1Object specifed by JSON parameters
     * @name newObject
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return {KJUR.asn1.ASN1Object} generated object
     * @since asn1 1.0.3
     * @description
     * generate any ASN1Object specified by JSON param
     * including ASN.1 primitive or structured.
     * Generally 'param' can be described as follows:
     * <blockquote>
     * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}
     * </blockquote>
     * 'TYPE-OF-ASN1OBJ' can be one of following symbols:
     * <ul>
     * <li>'bool' - DERBoolean</li>
     * <li>'int' - DERInteger</li>
     * <li>'bitstr' - DERBitString</li>
     * <li>'octstr' - DEROctetString</li>
     * <li>'null' - DERNull</li>
     * <li>'oid' - DERObjectIdentifier</li>
     * <li>'enum' - DEREnumerated</li>
     * <li>'utf8str' - DERUTF8String</li>
     * <li>'numstr' - DERNumericString</li>
     * <li>'prnstr' - DERPrintableString</li>
     * <li>'telstr' - DERTeletexString</li>
     * <li>'ia5str' - DERIA5String</li>
     * <li>'utctime' - DERUTCTime</li>
     * <li>'gentime' - DERGeneralizedTime</li>
     * <li>'seq' - DERSequence</li>
     * <li>'set' - DERSet</li>
     * <li>'tag' - DERTaggedObject</li>
     * </ul>
     * @example
     * newObject({'prnstr': 'aaa'});
     * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})
     * // ASN.1 Tagged Object
     * newObject({'tag': {'tag': 'a1',
     *                    'explicit': true,
     *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});
     * // more simple representation of ASN.1 Tagged Object
     * newObject({'tag': ['a1',
     *                    true,
     *                    {'seq': [
     *                      {'int': 3},
     *                      {'prnstr': 'aaa'}]}
     *                   ]});
     */
    this.newObject = function(param) {
        var _KJUR = KJUR,
            _KJUR_asn1 = _KJUR.asn1,
            _DERBoolean = _KJUR_asn1.DERBoolean,
            _DERInteger = _KJUR_asn1.DERInteger,
            _DERBitString = _KJUR_asn1.DERBitString,
            _DEROctetString = _KJUR_asn1.DEROctetString,
            _DERNull = _KJUR_asn1.DERNull,
            _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
            _DEREnumerated = _KJUR_asn1.DEREnumerated,
            _DERUTF8String = _KJUR_asn1.DERUTF8String,
            _DERNumericString = _KJUR_asn1.DERNumericString,
            _DERPrintableString = _KJUR_asn1.DERPrintableString,
            _DERTeletexString = _KJUR_asn1.DERTeletexString,
            _DERIA5String = _KJUR_asn1.DERIA5String,
            _DERUTCTime = _KJUR_asn1.DERUTCTime,
            _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
            _DERSequence = _KJUR_asn1.DERSequence,
            _DERSet = _KJUR_asn1.DERSet,
            _DERTaggedObject = _KJUR_asn1.DERTaggedObject,
            _newObject = _KJUR_asn1.ASN1Util.newObject;

        var keys = Object.keys(param);
        if (keys.length != 1)
            throw "key of param shall be only one.";
        var key = keys[0];

        if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + key + ":") == -1)
            throw "undefined key: " + key;

        if (key == "bool")    return new _DERBoolean(param[key]);
        if (key == "int")     return new _DERInteger(param[key]);
        if (key == "bitstr")  return new _DERBitString(param[key]);
        if (key == "octstr")  return new _DEROctetString(param[key]);
        if (key == "null")    return new _DERNull(param[key]);
        if (key == "oid")     return new _DERObjectIdentifier(param[key]);
        if (key == "enum")    return new _DEREnumerated(param[key]);
        if (key == "utf8str") return new _DERUTF8String(param[key]);
        if (key == "numstr")  return new _DERNumericString(param[key]);
        if (key == "prnstr")  return new _DERPrintableString(param[key]);
        if (key == "telstr")  return new _DERTeletexString(param[key]);
        if (key == "ia5str")  return new _DERIA5String(param[key]);
        if (key == "utctime") return new _DERUTCTime(param[key]);
        if (key == "gentime") return new _DERGeneralizedTime(param[key]);

        if (key == "seq") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSequence({'array': a});
        }

        if (key == "set") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSet({'array': a});
        }

        if (key == "tag") {
            var tagParam = param[key];
            if (Object.prototype.toString.call(tagParam) === '[object Array]' &&
                tagParam.length == 3) {
                var obj = _newObject(tagParam[2]);
                return new _DERTaggedObject({tag: tagParam[0],
                    explicit: tagParam[1],
                    obj: obj});
            } else {
                var newParam = {};
                if (tagParam.explicit !== undefined)
                    newParam.explicit = tagParam.explicit;
                if (tagParam.tag !== undefined)
                    newParam.tag = tagParam.tag;
                if (tagParam.obj === undefined)
                    throw "obj shall be specified for 'tag'.";
                newParam.obj = _newObject(tagParam.obj);
                return new _DERTaggedObject(newParam);
            }
        }
    };

    /**
     * get encoded hexadecimal string of ASN1Object specifed by JSON parameters
     * @name jsonToASN1HEX
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return hexadecimal string of ASN1Object
     * @since asn1 1.0.4
     * @description
     * As for ASN.1 object representation of JSON object,
     * please see {@link newObject}.
     * @example
     * jsonToASN1HEX({'prnstr': 'aaa'});
     */
    this.jsonToASN1HEX = function(param) {
        var asn1Obj = this.newObject(param);
        return asn1Obj.getEncodedHex();
    };
};

/**
 * get dot noted oid number string from hexadecimal value of OID
 * @name oidHexToInt
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} hex hexadecimal value of object identifier
 * @return {String} dot noted string of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from hexadecimal string representation of
 * ASN.1 value of object identifier to oid number string.
 * @example
 * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; "2.5.4.6"
 */
KJUR.asn1.ASN1Util.oidHexToInt = function(hex) {
    var s = "";
    var i01 = parseInt(hex.substr(0, 2), 16);
    var i0 = Math.floor(i01 / 40);
    var i1 = i01 % 40;
    var s = i0 + "." + i1;

    var binbuf = "";
    for (var i = 2; i < hex.length; i += 2) {
        var value = parseInt(hex.substr(i, 2), 16);
        var bin = ("00000000" + value.toString(2)).slice(- 8);
        binbuf = binbuf + bin.substr(1, 7);
        if (bin.substr(0, 1) == "0") {
            var bi = new BigInteger(binbuf, 2);
            s = s + "." + bi.toString(10);
            binbuf = "";
        }
    }
    return s;
};

/**
 * get hexadecimal value of object identifier from dot noted oid value
 * @name oidIntToHex
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} oidString dot noted string of object identifier
 * @return {String} hexadecimal value of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from object identifier value string.
 * to hexadecimal string representation of it.
 * @example
 * KJUR.asn1.ASN1Util.oidIntToHex("2.5.4.6") &rarr; "550406"
 */
KJUR.asn1.ASN1Util.oidIntToHex = function(oidString) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };

    var roidtox = function(roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };

    if (! oidString.match(/^[0-9.]+$/)) {
        throw "malformed oid string: " + oidString;
    }
    var h = '';
    var a = oidString.split('.');
    var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
    h += itox(i0);
    a.splice(0, 2);
    for (var i = 0; i < a.length; i++) {
        h += roidtox(a[i]);
    }
    return h;
};


// ********************************************************************
//  Abstract ASN.1 Classes
// ********************************************************************

// ********************************************************************

/**
 * base class for ASN.1 DER encoder object
 * @name KJUR.asn1.ASN1Object
 * @class base class for ASN.1 DER encoder object
 * @property {Boolean} isModified flag whether internal data was changed
 * @property {String} hTLV hexadecimal string of ASN.1 TLV
 * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)
 * @property {String} hL hexadecimal string of ASN.1 TLV length(L)
 * @property {String} hV hexadecimal string of ASN.1 TLV value(V)
 * @description
 */
KJUR.asn1.ASN1Object = function() {
    var hV = '';

    /**
     * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)
     * @name getLengthHexFromValue
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV length(L)
     */
    this.getLengthHexFromValue = function() {
        if (typeof this.hV == "undefined" || this.hV == null) {
            throw "this.hV is null or undefined.";
        }
        if (this.hV.length % 2 == 1) {
            throw "value hex must be even length: n=" + hV.length + ",v=" + this.hV;
        }
        var n = this.hV.length / 2;
        var hN = n.toString(16);
        if (hN.length % 2 == 1) {
            hN = "0" + hN;
        }
        if (n < 128) {
            return hN;
        } else {
            var hNlen = hN.length / 2;
            if (hNlen > 15) {
                throw "ASN.1 length too long to represent by 8x: n = " + n.toString(16);
            }
            var head = 128 + hNlen;
            return head.toString(16) + hN;
        }
    };

    /**
     * get hexadecimal string of ASN.1 TLV bytes
     * @name getEncodedHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV
     */
    this.getEncodedHex = function() {
        if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
            //alert("first time: " + this.hTLV);
        }
        return this.hTLV;
    };

    /**
     * get hexadecimal string of ASN.1 TLV value(V) bytes
     * @name getValueHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes
     */
    this.getValueHex = function() {
        this.getEncodedHex();
        return this.hV;
    };

    this.getFreshValueHex = function() {
        return '';
    };
};

// == BEGIN DERAbstractString ================================================
/**
 * base class for ASN.1 DER string classes
 * @name KJUR.asn1.DERAbstractString
 * @class base class for ASN.1 DER string classes
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @property {String} s internal string of value
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERAbstractString = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);

    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @return {String} string value of this string object
     */
    this.getString = function() {
        return this.s;
    };

    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newS value by a string to set
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(this.s);
    };

    /**
     * set value by a hexadecimal string
     * @name setStringHex
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newHexString value by a hexadecimal string to set
     */
    this.setStringHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string") {
            this.setString(params);
        } else if (typeof params['str'] != "undefined") {
            this.setString(params['str']);
        } else if (typeof params['hex'] != "undefined") {
            this.setStringHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
// == END   DERAbstractString ================================================

// == BEGIN DERAbstractTime ==================================================
/**
 * base class for ASN.1 DER Generalized/UTCTime class
 * @name KJUR.asn1.DERAbstractTime
 * @class base class for ASN.1 DER Generalized/UTCTime class
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractTime = function(params) {
    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);

    // --- PRIVATE METHODS --------------------
    this.localDateToUTC = function(d) {
        utc = d.getTime() + (d.getTimezoneOffset() * 60000);
        var utcDate = new Date(utc);
        return utcDate;
    };

    /*
     * format date string by Data object
     * @name formatDate
     * @memberOf KJUR.asn1.AbstractTime;
     * @param {Date} dateObject
     * @param {string} type 'utc' or 'gen'
     * @param {boolean} withMillis flag for with millisections or not
     * @description
     * 'withMillis' flag is supported from asn1 1.0.6.
     */
    this.formatDate = function(dateObject, type, withMillis) {
        var pad = this.zeroPadding;
        var d = this.localDateToUTC(dateObject);
        var year = String(d.getFullYear());
        if (type == 'utc') year = year.substr(2, 2);
        var month = pad(String(d.getMonth() + 1), 2);
        var day = pad(String(d.getDate()), 2);
        var hour = pad(String(d.getHours()), 2);
        var min = pad(String(d.getMinutes()), 2);
        var sec = pad(String(d.getSeconds()), 2);
        var s = year + month + day + hour + min + sec;
        if (withMillis === true) {
            var millis = d.getMilliseconds();
            if (millis != 0) {
                var sMillis = pad(String(millis), 3);
                sMillis = sMillis.replace(/[0]+$/, "");
                s = s + "." + sMillis;
            }
        }
        return s + "Z";
    };

    this.zeroPadding = function(s, len) {
        if (s.length >= len) return s;
        return new Array(len - s.length + 1).join('0') + s;
    };

    // --- PUBLIC METHODS --------------------
    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @return {String} string value of this time object
     */
    this.getString = function() {
        return this.s;
    };

    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {String} newS value by a string to set such like "130430235959Z"
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(newS);
    };

    /**
     * set value by a Date object
     * @name setByDateValue
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {Integer} year year of date (ex. 2013)
     * @param {Integer} month month of date between 1 and 12 (ex. 12)
     * @param {Integer} day day of month
     * @param {Integer} hour hours of date
     * @param {Integer} min minutes of date
     * @param {Integer} sec seconds of date
     */
    this.setByDateValue = function(year, month, day, hour, min, sec) {
        var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
        this.setByDate(dateObject);
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
// == END   DERAbstractTime ==================================================

// == BEGIN DERAbstractStructured ============================================
/**
 * base class for ASN.1 DER structured class
 * @name KJUR.asn1.DERAbstractStructured
 * @class base class for ASN.1 DER structured class
 * @property {Array} asn1Array internal array of ASN1Object
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractStructured = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);

    /**
     * set value by array of ASN1Object
     * @name setByASN1ObjectArray
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {array} asn1ObjectArray array of ASN1Object to set
     */
    this.setByASN1ObjectArray = function(asn1ObjectArray) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = asn1ObjectArray;
    };

    /**
     * append an ASN1Object to internal array
     * @name appendASN1Object
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {ASN1Object} asn1Object to add
     */
    this.appendASN1Object = function(asn1Object) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(asn1Object);
    };

    this.asn1Array = new Array();
    if (typeof params != "undefined") {
        if (typeof params['array'] != "undefined") {
            this.asn1Array = params['array'];
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);


// ********************************************************************
//  ASN.1 Object Classes
// ********************************************************************

// ********************************************************************
/**
 * class for ASN.1 DER Boolean
 * @name KJUR.asn1.DERBoolean
 * @class class for ASN.1 DER Boolean
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERBoolean = function() {
    KJUR.asn1.DERBoolean.superclass.constructor.call(this);
    this.hT = "01";
    this.hTLV = "0101ff";
};
YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Integer
 * @name KJUR.asn1.DERInteger
 * @class class for ASN.1 DER Integer
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERInteger = function(params) {
    KJUR.asn1.DERInteger.superclass.constructor.call(this);
    this.hT = "02";

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DERInteger
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     * @example
     * new KJUR.asn1.DERInteger(123);
     * new KJUR.asn1.DERInteger({'int': 123});
     * new KJUR.asn1.DERInteger({'hex': '1fad'});
     */
    this.setValueHex = function(newHexString) {
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['bigint'] != "undefined") {
            this.setByBigInteger(params['bigint']);
        } else if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        } else if (typeof params == "number") {
            this.setByInteger(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER encoded BitString primitive
 * @name KJUR.asn1.DERBitString
 * @class class for ASN.1 DER encoded BitString primitive
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>bin - specify binary string (ex. '10111')</li>
 * <li>array - specify array of boolean (ex. [true,false,true,true])</li>
 * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>
 * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject}
 * argument for "BitString encapsulates" structure.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: 'obj' parameter have been supported since
 * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>
 * @example
 * // default constructor
 * o = new KJUR.asn1.DERBitString();
 * // initialize with binary string
 * o = new KJUR.asn1.DERBitString({bin: "1011"});
 * // initialize with boolean array
 * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});
 * // initialize with hexadecimal string (04 is unused bits)
 * o = new KJUR.asn1.DEROctetString({hex: "04bac0"});
 * // initialize with ASN1Util.newObject argument for encapsulated
 * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // BIT STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DERBitString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = "00" + o.getEncodedHex();
    }
    KJUR.asn1.DERBitString.superclass.constructor.call(this);
    this.hT = "03";

    /**
     * set ASN.1 value(V) by a hexadecimal string including unused bits
     * @name setHexValueIncludingUnusedBits
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} newHexStringIncludingUnusedBits
     */
    this.setHexValueIncludingUnusedBits = function(newHexStringIncludingUnusedBits) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = newHexStringIncludingUnusedBits;
    };

    /**
     * set ASN.1 value(V) by unused bit and hexadecimal string of value
     * @name setUnusedBitsAndHexValue
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {Integer} unusedBits
     * @param {String} hValue
     */
    this.setUnusedBitsAndHexValue = function(unusedBits, hValue) {
        if (unusedBits < 0 || 7 < unusedBits) {
            throw "unused bits shall be from 0 to 7: u = " + unusedBits;
        }
        var hUnusedBits = "0" + unusedBits;
        this.hTLV = null;
        this.isModified = true;
        this.hV = hUnusedBits + hValue;
    };

    /**
     * set ASN.1 DER BitString by binary string<br/>
     * @name setByBinaryString
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} binaryString binary value string (i.e. '10111')
     * @description
     * Its unused bits will be calculated automatically by length of
     * 'binaryValue'. <br/>
     * NOTE: Trailing zeros '0' will be ignored.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray("01011");
     */
    this.setByBinaryString = function(binaryString) {
        binaryString = binaryString.replace(/0+$/, '');
        var unusedBits = 8 - binaryString.length % 8;
        if (unusedBits == 8) unusedBits = 0;
        for (var i = 0; i <= unusedBits; i++) {
            binaryString += '0';
        }
        var h = '';
        for (var i = 0; i < binaryString.length - 1; i += 8) {
            var b = binaryString.substr(i, 8);
            var x = parseInt(b, 2).toString(16);
            if (x.length == 1) x = '0' + x;
            h += x;
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = '0' + unusedBits + h;
    };

    /**
     * set ASN.1 TLV value(V) by an array of boolean<br/>
     * @name setByBooleanArray
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {array} booleanArray array of boolean (ex. [true, false, true])
     * @description
     * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray([false, true, false, true, true]);
     */
    this.setByBooleanArray = function(booleanArray) {
        var s = '';
        for (var i = 0; i < booleanArray.length; i++) {
            if (booleanArray[i] == true) {
                s += '1';
            } else {
                s += '0';
            }
        }
        this.setByBinaryString(s);
    };

    /**
     * generate an array of falses with specified length<br/>
     * @name newFalseArray
     * @memberOf KJUR.asn1.DERBitString
     * @function
     * @param {Integer} nLength length of array to generate
     * @return {array} array of boolean falses
     * @description
     * This static method may be useful to initialize boolean array.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.newFalseArray(3) &rarr; [false, false, false]
     */
    this.newFalseArray = function(nLength) {
        var a = new Array(nLength);
        for (var i = 0; i < nLength; i++) {
            a[i] = false;
        }
        return a;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string" && params.toLowerCase().match(/^[0-9a-f]+$/)) {
            this.setHexValueIncludingUnusedBits(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setHexValueIncludingUnusedBits(params['hex']);
        } else if (typeof params['bin'] != "undefined") {
            this.setByBinaryString(params['bin']);
        } else if (typeof params['array'] != "undefined") {
            this.setByBooleanArray(params['array']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER OctetString<br/>
 * @name KJUR.asn1.DEROctetString
 * @class class for ASN.1 DER OctetString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * This class provides ASN.1 OctetString simple type.<br/>
 * Supported "params" attributes are:
 * <ul>
 * <li>str - to set a string as a value</li>
 * <li>hex - to set a hexadecimal string as a value</li>
 * <li>obj - to set a encapsulated ASN.1 value by JSON object
 * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>
 * </ul>
 * NOTE: A parameter 'obj' have been supported
 * for "OCTET STRING, encapsulates" structure.
 * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).
 * @see KJUR.asn1.DERAbstractString - superclass
 * @example
 * // default constructor
 * o = new KJUR.asn1.DEROctetString();
 * // initialize with string
 * o = new KJUR.asn1.DEROctetString({str: "aaa"});
 * // initialize with hexadecimal string
 * o = new KJUR.asn1.DEROctetString({hex: "616161"});
 * // initialize with ASN1Util.newObject argument
 * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // OCTET STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DEROctetString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = o.getEncodedHex();
    }
    KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
    this.hT = "04";
};
YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER Null
 * @name KJUR.asn1.DERNull
 * @class class for ASN.1 DER Null
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERNull = function() {
    KJUR.asn1.DERNull.superclass.constructor.call(this);
    this.hT = "05";
    this.hTLV = "0500";
};
YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER ObjectIdentifier
 * @name KJUR.asn1.DERObjectIdentifier
 * @class class for ASN.1 DER ObjectIdentifier
 * @param {Array} params associative array of parameters (ex. {'oid': '2.5.4.5'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERObjectIdentifier = function(params) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };
    var roidtox = function(roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };

    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
    this.hT = "06";

    /**
     * set value by a hexadecimal string
     * @name setValueHex
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} newHexString hexadecimal value of OID bytes
     */
    this.setValueHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    /**
     * set value by a OID string<br/>
     * @name setValueOidString
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidString OID string (ex. 2.5.4.13)
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueOidString("2.5.4.13");
     */
    this.setValueOidString = function(oidString) {
        if (! oidString.match(/^[0-9.]+$/)) {
            throw "malformed oid string: " + oidString;
        }
        var h = '';
        var a = oidString.split('.');
        var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
        h += itox(i0);
        a.splice(0, 2);
        for (var i = 0; i < a.length; i++) {
            h += roidtox(a[i]);
        }
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = h;
    };

    /**
     * set value by a OID name
     * @name setValueName
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidName OID name (ex. 'serverAuth')
     * @since 1.0.1
     * @description
     * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.
     * Otherwise raise error.
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueName("serverAuth");
     */
    this.setValueName = function(oidName) {
        var oid = KJUR.asn1.x509.OID.name2oid(oidName);
        if (oid !== '') {
            this.setValueOidString(oid);
        } else {
            throw "DERObjectIdentifier oidName undefined: " + oidName;
        }
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (params !== undefined) {
        if (typeof params === "string") {
            if (params.match(/^[0-2].[0-9.]+$/)) {
                this.setValueOidString(params);
            } else {
                this.setValueName(params);
            }
        } else if (params.oid !== undefined) {
            this.setValueOidString(params.oid);
        } else if (params.hex !== undefined) {
            this.setValueHex(params.hex);
        } else if (params.name !== undefined) {
            this.setValueName(params.name);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Enumerated
 * @name KJUR.asn1.DEREnumerated
 * @class class for ASN.1 DER Enumerated
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * @example
 * new KJUR.asn1.DEREnumerated(123);
 * new KJUR.asn1.DEREnumerated({int: 123});
 * new KJUR.asn1.DEREnumerated({hex: '1fad'});
 */
KJUR.asn1.DEREnumerated = function(params) {
    KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
    this.hT = "0a";

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     */
    this.setValueHex = function(newHexString) {
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        } else if (typeof params == "number") {
            this.setByInteger(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER UTF8String
 * @name KJUR.asn1.DERUTF8String
 * @class class for ASN.1 DER UTF8String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERUTF8String = function(params) {
    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
    this.hT = "0c";
};
YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER NumericString
 * @name KJUR.asn1.DERNumericString
 * @class class for ASN.1 DER NumericString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERNumericString = function(params) {
    KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
    this.hT = "12";
};
YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER PrintableString
 * @name KJUR.asn1.DERPrintableString
 * @class class for ASN.1 DER PrintableString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERPrintableString = function(params) {
    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
    this.hT = "13";
};
YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER TeletexString
 * @name KJUR.asn1.DERTeletexString
 * @class class for ASN.1 DER TeletexString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERTeletexString = function(params) {
    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
    this.hT = "14";
};
YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER IA5String
 * @name KJUR.asn1.DERIA5String
 * @class class for ASN.1 DER IA5String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERIA5String = function(params) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
    this.hT = "16";
};
YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER UTCTime
 * @name KJUR.asn1.DERUTCTime
 * @class class for ASN.1 DER UTCTime
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * <h4>EXAMPLES</h4>
 * @example
 * d1 = new KJUR.asn1.DERUTCTime();
 * d1.setString('130430125959Z');
 *
 * d2 = new KJUR.asn1.DERUTCTime({'str': '130430125959Z'});
 * d3 = new KJUR.asn1.DERUTCTime({'date': new Date(Date.UTC(2015, 0, 31, 0, 0, 0, 0))});
 * d4 = new KJUR.asn1.DERUTCTime('130430125959Z');
 */
KJUR.asn1.DERUTCTime = function(params) {
    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
    this.hT = "17";

    /**
     * set value by a Date object<br/>
     * @name setByDate
     * @memberOf KJUR.asn1.DERUTCTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * o = new KJUR.asn1.DERUTCTime();
     * o.setByDate(new Date("2016/12/31"));
     */
    this.setByDate = function(dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'utc');
        this.hV = stohex(this.s);
    };

    this.getFreshValueHex = function() {
        if (typeof this.date == "undefined" && typeof this.s == "undefined") {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'utc');
            this.hV = stohex(this.s);
        }
        return this.hV;
    };

    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        } else if (typeof params == "string" && params.match(/^[0-9]{12}Z$/)) {
            this.setString(params);
        } else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        } else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER GeneralizedTime
 * @name KJUR.asn1.DERGeneralizedTime
 * @class class for ASN.1 DER GeneralizedTime
 * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})
 * @property {Boolean} withMillis flag to show milliseconds or not
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
 * </ul>
 * NOTE1: 'params' can be omitted.
 * NOTE2: 'withMillis' property is supported from asn1 1.0.6.
 */
KJUR.asn1.DERGeneralizedTime = function(params) {
    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
    this.hT = "18";
    this.withMillis = false;

    /**
     * set value by a Date object
     * @name setByDate
     * @memberOf KJUR.asn1.DERGeneralizedTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * When you specify UTC time, use 'Date.UTC' method like this:<br/>
     * o1 = new DERUTCTime();
     * o1.setByDate(date);
     *
     * date = new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)); #2015JAN31 23:59:59
     */
    this.setByDate = function(dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'gen', this.withMillis);
        this.hV = stohex(this.s);
    };

    this.getFreshValueHex = function() {
        if (this.date === undefined && this.s === undefined) {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'gen', this.withMillis);
            this.hV = stohex(this.s);
        }
        return this.hV;
    };

    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        } else if (typeof params == "string" && params.match(/^[0-9]{14}Z$/)) {
            this.setString(params);
        } else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        } else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
        if (params.millis === true) {
            this.withMillis = true;
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER Sequence
 * @name KJUR.asn1.DERSequence
 * @class class for ASN.1 DER Sequence
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERSequence = function(params) {
    KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
    this.hT = "30";
    this.getFreshValueHex = function() {
        var h = '';
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            h += asn1Obj.getEncodedHex();
        }
        this.hV = h;
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER Set
 * @name KJUR.asn1.DERSet
 * @class class for ASN.1 DER Set
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: sortflag is supported since 1.0.5.
 */
KJUR.asn1.DERSet = function(params) {
    KJUR.asn1.DERSet.superclass.constructor.call(this, params);
    this.hT = "31";
    this.sortFlag = true; // item shall be sorted only in ASN.1 DER
    this.getFreshValueHex = function() {
        var a = new Array();
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            a.push(asn1Obj.getEncodedHex());
        }
        if (this.sortFlag == true) a.sort();
        this.hV = a.join('');
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params.sortflag != "undefined" &&
            params.sortflag == false)
            this.sortFlag = false;
    }
};
YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER TaggedObject
 * @name KJUR.asn1.DERTaggedObject
 * @class class for ASN.1 DER TaggedObject
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.
 * For example, if you find '[1]' tag in a ASN.1 dump,
 * 'tagNoHex' will be 'a1'.
 * <br/>
 * As for optional argument 'params' for constructor, you can specify *ANY* of
 * following properties:
 * <ul>
 * <li>explicit - specify true if this is explicit tag otherwise false
 *     (default is 'true').</li>
 * <li>tag - specify tag (default is 'a0' which means [0])</li>
 * <li>obj - specify ASN1Object which is tagged</li>
 * </ul>
 * @example
 * d1 = new KJUR.asn1.DERUTF8String({'str':'a'});
 * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});
 * hex = d2.getEncodedHex();
 */
KJUR.asn1.DERTaggedObject = function(params) {
    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
    this.hT = "a0";
    this.hV = '';
    this.isExplicit = true;
    this.asn1Object = null;

    /**
     * set value by an ASN1Object
     * @name setString
     * @memberOf KJUR.asn1.DERTaggedObject#
     * @function
     * @param {Boolean} isExplicitFlag flag for explicit/implicit tag
     * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag
     * @param {ASN1Object} asn1Object ASN.1 to encapsulate
     */
    this.setASN1Object = function(isExplicitFlag, tagNoHex, asn1Object) {
        this.hT = tagNoHex;
        this.isExplicit = isExplicitFlag;
        this.asn1Object = asn1Object;
        if (this.isExplicit) {
            this.hV = this.asn1Object.getEncodedHex();
            this.hTLV = null;
            this.isModified = true;
        } else {
            this.hV = null;
            this.hTLV = asn1Object.getEncodedHex();
            this.hTLV = this.hTLV.replace(/^../, tagNoHex);
            this.isModified = false;
        }
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['tag'] != "undefined") {
            this.hT = params['tag'];
        }
        if (typeof params['explicit'] != "undefined") {
            this.isExplicit = params['explicit'];
        }
        if (typeof params['obj'] != "undefined") {
            this.asn1Object = params['obj'];
            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);

/**
 * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.
 * This object is just a decorator for parsing the key parameter
 * @param {string|Object} key - The key in string format, or an object containing
 * the parameters needed to build a RSAKey object.
 * @constructor
 */
var JSEncryptRSAKey = /** @class */ (function (_super) {
    __extends(JSEncryptRSAKey, _super);
    function JSEncryptRSAKey(key) {
        var _this = _super.call(this) || this;
        // Call the super constructor.
        //  RSAKey.call(this);
        // If a key key was provided.
        if (key) {
            // If this is a string...
            if (typeof key === "string") {
                _this.parseKey(key);
            }
            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||
                JSEncryptRSAKey.hasPublicKeyProperty(key)) {
                // Set the values for the key.
                _this.parsePropertiesFrom(key);
            }
        }
        return _this;
    }
    /**
     * Method to parse a pem encoded string containing both a public or private key.
     * The method will translate the pem encoded string in a der encoded string and
     * will parse private key and public key parameters. This method accepts public key
     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).
     *
     * @todo Check how many rsa formats use the same format of pkcs #1.
     *
     * The format is defined as:
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * it's possible to examine the structure of the keys obtained from openssl using
     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/
     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer
     * @private
     */
    JSEncryptRSAKey.prototype.parseKey = function (pem) {
        try {
            var modulus = 0;
            var public_exponent = 0;
            var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
            var asn1 = ASN1.decode(der);
            // Fixes a bug with OpenSSL 1.0+ private keys
            if (asn1.sub.length === 3) {
                asn1 = asn1.sub[2].sub[0];
            }
            if (asn1.sub.length === 9) {
                // Parse the private key.
                modulus = asn1.sub[1].getHexStringValue(); // bigint
                this.n = parseBigInt(modulus, 16);
                public_exponent = asn1.sub[2].getHexStringValue(); // int
                this.e = parseInt(public_exponent, 16);
                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint
                this.d = parseBigInt(private_exponent, 16);
                var prime1 = asn1.sub[4].getHexStringValue(); // bigint
                this.p = parseBigInt(prime1, 16);
                var prime2 = asn1.sub[5].getHexStringValue(); // bigint
                this.q = parseBigInt(prime2, 16);
                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint
                this.dmp1 = parseBigInt(exponent1, 16);
                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint
                this.dmq1 = parseBigInt(exponent2, 16);
                var coefficient = asn1.sub[8].getHexStringValue(); // bigint
                this.coeff = parseBigInt(coefficient, 16);
            }
            else if (asn1.sub.length === 2) {
                // Parse the public key.
                var bit_string = asn1.sub[1];
                var sequence = bit_string.sub[0];
                modulus = sequence.sub[0].getHexStringValue();
                this.n = parseBigInt(modulus, 16);
                public_exponent = sequence.sub[1].getHexStringValue();
                this.e = parseInt(public_exponent, 16);
            }
            else {
                return false;
            }
            return true;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa key.
     *
     * The translation follow the ASN.1 notation :
     * RSAPrivateKey ::= SEQUENCE {
     *   version           Version,
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER,  -- e
     *   privateExponent   INTEGER,  -- d
     *   prime1            INTEGER,  -- p
     *   prime2            INTEGER,  -- q
     *   exponent1         INTEGER,  -- d mod (p1)
     *   exponent2         INTEGER,  -- d mod (q-1)
     *   coefficient       INTEGER,  -- (inverse of q) mod p
     * }
     * @returns {string}  DER Encoded String representing the rsa private key
     * @private
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {
        var options = {
            array: [
                new KJUR.asn1.DERInteger({ int: 0 }),
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e }),
                new KJUR.asn1.DERInteger({ bigint: this.d }),
                new KJUR.asn1.DERInteger({ bigint: this.p }),
                new KJUR.asn1.DERInteger({ bigint: this.q }),
                new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),
                new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),
                new KJUR.asn1.DERInteger({ bigint: this.coeff })
            ]
        };
        var seq = new KJUR.asn1.DERSequence(options);
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {
        return hex2b64(this.getPrivateBaseKey());
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa public key.
     * The representation follow the ASN.1 notation :
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * @returns {string} DER Encoded String representing the rsa public key
     * @private
     */
    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {
        var first_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }),
                new KJUR.asn1.DERNull()
            ]
        });
        var second_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e })
            ]
        });
        var bit_string = new KJUR.asn1.DERBitString({
            hex: "00" + second_sequence.getEncodedHex()
        });
        var seq = new KJUR.asn1.DERSequence({
            array: [
                first_sequence,
                bit_string
            ]
        });
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {
        return hex2b64(this.getPublicBaseKey());
    };
    /**
     * wrap the string in block of width chars. The default value for rsa keys is 64
     * characters.
     * @param {string} str the pem encoded string without header and footer
     * @param {Number} [width=64] - the length the string has to be wrapped at
     * @returns {string}
     * @private
     */
    JSEncryptRSAKey.wordwrap = function (str, width) {
        width = width || 64;
        if (!str) {
            return str;
        }
        var regex = "(.{1," + width + "})( +|$\n?)|(.{1," + width + "})";
        return str.match(RegExp(regex, "g")).join("\n");
    };
    /**
     * Retrieve the pem encoded private key
     * @returns {string} the pem encoded private key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateKey = function () {
        var key = "-----BEGIN RSA PRIVATE KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + "\n";
        key += "-----END RSA PRIVATE KEY-----";
        return key;
    };
    /**
     * Retrieve the pem encoded public key
     * @returns {string} the pem encoded public key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicKey = function () {
        var key = "-----BEGIN PUBLIC KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + "\n";
        key += "-----END PUBLIC KEY-----";
        return key;
    };
    /**
     * Check if the object contains the necessary parameters to populate the rsa modulus
     * and public exponent parameters.
     * @param {Object} [obj={}] - An object that may contain the two public key
     * parameters
     * @returns {boolean} true if the object contains both the modulus and the public exponent
     * properties (n and e)
     * @todo check for types of n and e. N should be a parseable bigInt object, E should
     * be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e"));
    };
    /**
     * Check if the object contains ALL the parameters of an RSA key.
     * @param {Object} [obj={}] - An object that may contain nine rsa key
     * parameters
     * @returns {boolean} true if the object contains all the parameters needed
     * @todo check for types of the parameters all the parameters but the public exponent
     * should be parseable bigint objects, the public exponent should be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e") &&
            obj.hasOwnProperty("d") &&
            obj.hasOwnProperty("p") &&
            obj.hasOwnProperty("q") &&
            obj.hasOwnProperty("dmp1") &&
            obj.hasOwnProperty("dmq1") &&
            obj.hasOwnProperty("coeff"));
    };
    /**
     * Parse the properties of obj in the current rsa object. Obj should AT LEAST
     * include the modulus and public exponent (n, e) parameters.
     * @param {Object} obj - the object containing rsa parameters
     * @private
     */
    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {
        this.n = obj.n;
        this.e = obj.e;
        if (obj.hasOwnProperty("d")) {
            this.d = obj.d;
            this.p = obj.p;
            this.q = obj.q;
            this.dmp1 = obj.dmp1;
            this.dmq1 = obj.dmq1;
            this.coeff = obj.coeff;
        }
    };
    return JSEncryptRSAKey;
}(RSAKey));

/**
 *
 * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour
 * possible parameters are:
 * - default_key_size        {number}  default: 1024 the key size in bit
 * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent
 * - log                     {boolean} default: false whether log warn/error or not
 * @constructor
 */
var JSEncrypt = /** @class */ (function () {
    function JSEncrypt(options) {
        options = options || {};
        this.default_key_size = parseInt(options.default_key_size, 10) || 1024;
        this.default_public_exponent = options.default_public_exponent || "010001"; // 65537 default openssl public exponent for rsa key type
        this.log = options.log || false;
        // The private and public key.
        this.key = null;
    }
    /**
     * Method to set the rsa key parameter (one method is enough to set both the public
     * and the private key, since the private key contains the public key paramenters)
     * Log a warning if logs are enabled
     * @param {Object|string} key the pem encoded string or an object (with or without header/footer)
     * @public
     */
    JSEncrypt.prototype.setKey = function (key) {
        if (this.log && this.key) {
            console.warn("A key was already set, overriding existing.");
        }
        this.key = new JSEncryptRSAKey(key);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPrivateKey = function (privkey) {
        // Create the key.
        this.setKey(privkey);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPublicKey = function (pubkey) {
        // Sets the public key.
        this.setKey(pubkey);
    };
    /**
     * Proxy method for RSAKey object's decrypt, decrypt the string using the private
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str base64 encoded crypted string to decrypt
     * @return {string} the decrypted string
     * @public
     */
    JSEncrypt.prototype.decrypt = function (str) {
        // Return the decrypted string.
        try {
            return this.getKey().decrypt(b64tohex(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's encrypt, encrypt the string using the public
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str the string to encrypt
     * @return {string} the encrypted string encoded in base64
     * @public
     */
    JSEncrypt.prototype.encrypt = function (str) {
        // Return the encrypted string.
        try {
            return hex2b64(this.getKey().encrypt(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's sign.
     * @param {string} str the string to sign
     * @param {function} digestMethod hash method
     * @param {string} digestName the name of the hash algorithm
     * @return {string} the signature encoded in base64
     * @public
     */
    JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {
        // return the RSA signature of 'str' in 'hex' format.
        try {
            return hex2b64(this.getKey().sign(str, digestMethod, digestName));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's verify.
     * @param {string} str the string to verify
     * @param {string} signature the signature encoded in base64 to compare the string to
     * @param {function} digestMethod hash method
     * @return {boolean} whether the data and signature match
     * @public
     */
    JSEncrypt.prototype.verify = function (str, signature, digestMethod) {
        // Return the decrypted 'digest' of the signature.
        try {
            return this.getKey().verify(str, b64tohex(signature), digestMethod);
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object
     * will be created and returned
     * @param {callback} [cb] the callback to be called if we want the key to be generated
     * in an async fashion
     * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object
     * @public
     */
    JSEncrypt.prototype.getKey = function (cb) {
        // Only create new if it does not exist.
        if (!this.key) {
            // Get a new private key.
            this.key = new JSEncryptRSAKey();
            if (cb && {}.toString.call(cb) === "[object Function]") {
                this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
                return;
            }
            // Generate the key.
            this.key.generate(this.default_key_size, this.default_public_exponent);
        }
        return this.key;
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateKey();
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateBaseKeyB64();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicKey();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicBaseKeyB64();
    };
    JSEncrypt.version = "3.0.0-rc.1";
    return JSEncrypt;
}());

window.JSEncrypt = JSEncrypt;

exports.JSEncrypt = JSEncrypt;
exports.default = JSEncrypt;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = __webpack_require__(/*! pseudomap */ "./node_modules/pseudomap/map.js")
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")

// A linked list to keep track of recently-used-ness
var Yallist = __webpack_require__(/*! yallist */ "./node_modules/yallist/yallist.js")

// use symbols if possible, otherwise just _props
var hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1'
var makeSymbol
if (hasSymbol) {
  makeSymbol = function (key) {
    return Symbol(key)
  }
} else {
  makeSymbol = function (key) {
    return '_' + key
  }
}

var MAX = makeSymbol('max')
var LENGTH = makeSymbol('length')
var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
var ALLOW_STALE = makeSymbol('allowStale')
var MAX_AGE = makeSymbol('maxAge')
var DISPOSE = makeSymbol('dispose')
var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
var LRU_LIST = makeSymbol('lruList')
var CACHE = makeSymbol('cache')

function naiveLength () { return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  if (typeof options === 'number') {
    options = { max: options }
  }

  if (!options) {
    options = {}
  }

  var max = this[MAX] = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) {
    this[MAX] = Infinity
  }

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') {
    lc = naiveLength
  }
  this[LENGTH_CALCULATOR] = lc

  this[ALLOW_STALE] = options.stale || false
  this[MAX_AGE] = options.maxAge || 0
  this[DISPOSE] = options.dispose
  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', {
  set: function (mL) {
    if (!mL || !(typeof mL === 'number') || mL <= 0) {
      mL = Infinity
    }
    this[MAX] = mL
    trim(this)
  },
  get: function () {
    return this[MAX]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', {
  set: function (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  },
  get: function () {
    return this[ALLOW_STALE]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', {
  set: function (mA) {
    if (!mA || !(typeof mA === 'number') || mA < 0) {
      mA = 0
    }
    this[MAX_AGE] = mA
    trim(this)
  },
  get: function () {
    return this[MAX_AGE]
  },
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
  set: function (lC) {
    if (typeof lC !== 'function') {
      lC = naiveLength
    }
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(function (hit) {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      }, this)
    }
    trim(this)
  },
  get: function () { return this[LENGTH_CALCULATOR] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', {
  get: function () { return this[LENGTH] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', {
  get: function () { return this[LRU_LIST].length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].tail; walker !== null;) {
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  }
}

function forEachStep (self, fn, node, thisp) {
  var hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE]) {
      hit = undefined
    }
  }
  if (hit) {
    fn.call(thisp, hit.value, hit.key, self)
  }
}

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].head; walker !== null;) {
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  }
}

LRUCache.prototype.keys = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.key
  }, this)
}

LRUCache.prototype.values = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.value
  }, this)
}

LRUCache.prototype.reset = function () {
  if (this[DISPOSE] &&
      this[LRU_LIST] &&
      this[LRU_LIST].length) {
    this[LRU_LIST].forEach(function (hit) {
      this[DISPOSE](hit.key, hit.value)
    }, this)
  }

  this[CACHE] = new Map() // hash of items by key
  this[LRU_LIST] = new Yallist() // list of items in order of use recency
  this[LENGTH] = 0 // length of items in the list
}

LRUCache.prototype.dump = function () {
  return this[LRU_LIST].map(function (hit) {
    if (!isStale(this, hit)) {
      return {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }
    }
  }, this).toArray().filter(function (h) {
    return h
  })
}

LRUCache.prototype.dumpLru = function () {
  return this[LRU_LIST]
}

/* istanbul ignore next */
LRUCache.prototype.inspect = function (n, opts) {
  var str = 'LRUCache {'
  var extras = false

  var as = this[ALLOW_STALE]
  if (as) {
    str += '\n  allowStale: true'
    extras = true
  }

  var max = this[MAX]
  if (max && max !== Infinity) {
    if (extras) {
      str += ','
    }
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  }

  var maxAge = this[MAX_AGE]
  if (maxAge) {
    if (extras) {
      str += ','
    }
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  }

  var lc = this[LENGTH_CALCULATOR]
  if (lc && lc !== naiveLength) {
    if (extras) {
      str += ','
    }
    str += '\n  length: ' + util.inspect(this[LENGTH], opts)
    extras = true
  }

  var didFirst = false
  this[LRU_LIST].forEach(function (item) {
    if (didFirst) {
      str += ',\n  '
    } else {
      if (extras) {
        str += ',\n'
      }
      didFirst = true
      str += '\n  '
    }
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = { value: item.value }
    if (item.maxAge !== maxAge) {
      val.maxAge = item.maxAge
    }
    if (lc !== naiveLength) {
      val.length = item.length
    }
    if (isStale(this, item)) {
      val.stale = true
    }

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  })

  if (didFirst || extras) {
    str += '\n'
  }
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this[MAX_AGE]

  var now = maxAge ? Date.now() : 0
  var len = this[LENGTH_CALCULATOR](value, key)

  if (this[CACHE].has(key)) {
    if (len > this[MAX]) {
      del(this, this[CACHE].get(key))
      return false
    }

    var node = this[CACHE].get(key)
    var item = node.value

    // dispose of the old one before overwriting
    // split out into 2 ifs for better coverage tracking
    if (this[DISPOSE]) {
      if (!this[NO_DISPOSE_ON_SET]) {
        this[DISPOSE](key, item.value)
      }
    }

    item.now = now
    item.maxAge = maxAge
    item.value = value
    this[LENGTH] += len - item.length
    item.length = len
    this.get(key)
    trim(this)
    return true
  }

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this[MAX]) {
    if (this[DISPOSE]) {
      this[DISPOSE](key, value)
    }
    return false
  }

  this[LENGTH] += hit.length
  this[LRU_LIST].unshift(hit)
  this[CACHE].set(key, this[LRU_LIST].head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) {
  if (!this[CACHE].has(key)) return false
  var hit = this[CACHE].get(key).value
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var node = this[LRU_LIST].tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) {
  del(this, this[CACHE].get(key))
}

LRUCache.prototype.load = function (arr) {
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) {
        this.set(hit.k, hit.v, maxAge)
      }
    }
  }
}

LRUCache.prototype.prune = function () {
  var self = this
  this[CACHE].forEach(function (value, key) {
    get(self, key, false)
  })
}

function get (self, key, doUse) {
  var node = self[CACHE].get(key)
  if (node) {
    var hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE]) hit = undefined
    } else {
      if (doUse) {
        self[LRU_LIST].unshiftNode(node)
      }
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale (self, hit) {
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {
    return false
  }
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self[MAX_AGE] && (diff > self[MAX_AGE])
  }
  return stale
}

function trim (self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

function del (self, node) {
  if (node) {
    var hit = node.value
    if (self[DISPOSE]) {
      self[DISPOSE](hit.key, hit.value)
    }
    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) {
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/promise-window/dist/promise-window.js":
/*!************************************************************!*\
  !*** ./node_modules/promise-window/dist/promise-window.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * PromiseWindow
 * https://github.com/amercier/promise-window
 * @ignore
 */
(function() {
  'use strict';

  var root = window,
      prototype,
      html = root.document.documentElement;

  /**
   * Merge the contents of two or more objects together into the first object.
   *
   *     merge( target [, object1 ] [, objectN ] )
   *
   * @param {Object} target  An object that will receive the new properties if
   *                         additional objects are passed in.
   * @param {Object} object1 An object containing additional properties to merge in.
   * @param {Object} objectN An object containing additional properties to merge in.
   * @return {Object} Returns the first object.
   * @ignore
   */
  function extend() {
    var extended = arguments[0], key, i;
    for (i = 1; i < arguments.length; i++) {
      for (key in arguments[i]) {
        if (arguments[i].hasOwnProperty(key)) {
          extended[key] = arguments[i][key];
        }
      }
    }
    return extended;
  }

  /**
   * Generates a pseudo-unique String
   *
   * @param  {String} prefix Optional.
   * @return {String} Returns a pseudo-unique string prefixed with the given prefix, if any.
   * @ignore
   */
  function generateUniqueString(prefix) {
    return prefix + new Date().getTime() + "-" + Math.floor(10e12 * Math.random());
  }

  /**
   * Create a new PromiseWindow object
   *
   * During the lifecycle of this object, popup windows can be opened, closed,
   * and reopened again. However, it'
   *
   * Instanciating this prototype does not immediately opens a new popup window.
   * To open the window, use `open()` on the created object.
   *
   * @param {String}   uri                    Destination URI
   * @param {Object}   config                 Configuration object. See description below.
   * @param {Number}   config.width           Width of the popup window. Defaults to the current document width.
   * @param {Number}   config.height          Height of the popup window. Defaults to the current document height.
   * @param {Function} config.promiseProvider Promise provider. Should return a plain object containing 3 fields:
   *                                          - `promise` {Promise}  a new Promise object
   *                                          - `resolve` {Function} the method to resolve the given Promise
   *                                          - `reject`  {Function} the method to reject the given Promise
   * @param {Function} config.onPostMessage   Handler for receiving a postMessage from the opened window. Default
   *                                          implementation resolves the promise with the data passed in the post
   *                                          message, except if this data contains an `error` field. In this case,
   *                                          it rejects the Promise with the value of that field. In all cases, closes
   *                                          the popup window.
   * @param {Function} config.onPostMessage.event Event The postMessage event
   * @param {Number}   config.watcherDelay    There is no programmatic way of knowing when a popup window is closed
   *                                          (either manually or programatically). For this reason, every time
   *                                          PromiseWindow opens a popup, a new watcher is created. The watcher checks
   *                                          regularly if the window is still open. This value defines at which
   *                                          interval this check is done. Defaults to 100ms.
   * @param {String}   config.windowName      Name to be ginven to the popup window. See `window.open` references for
   *                                          details. If `null`, a random name is generated.
   * @param {Object}   config.window          Object containing window configuration settings. Scrollbars are enabled
   *                                          by default. All `window.open` ptions are accepted, but please note that
   *                                          many of them have no effect in most modern browsers. See
   *                                          https://developer.mozilla.org/en-US/docs/Web/API/Window/open for more
   *                                          details.
   * @param {Function} config.onClose         Function being called whenever the popup is being closed (either after a
   *                                          post message has been received, or window has been closed by user, or
   *                                          `.close()` method has been called. Default implementation closes the
   *                                          popup window by calling `this._window.close()`).
   * @param {RegExp} config.originRegexp      Regular expression that matches the origin part of an URI. Defaults to
   *                                          `new RegExp('^[^:/?]+://[^/]*')`. If doesn't match (ex: relative URIs),
   *                                          use `location.origin`.
   * @constructor
   */
  function PromiseWindow(uri, config) {
    this.uri = uri;
    this.config = extend({}, this.constructor.defaultConfig, config);
    this.config.windowName = this.config.windowName || generateUniqueString('promise-window-');
    this._onPostMessage = this._onPostMessage.bind(this);
  }

  /**
   * Create a Promise provider from a Promise/A+ constructor to be used with
   * `config.promiseProvider`.
   *
   *     new PromiseWindow(..., {
   *       ...,
   *       promiseProvider: PromiseWindow.getAPlusPromiseProvider(MyCustomPromise)
   *     });
   *
   * @param  {Function} CustomPromise Promise/A+ contructor
   * @return {Function} Returns a promise provider
   * @static
   */
  PromiseWindow.getAPlusPromiseProvider = function getAPlusPromiseProvider(CustomPromise) {
    return function promiseProvider() {
      var module = {};
      module.promise = new CustomPromise(function(resolve, reject) {
        module.resolve = resolve;
        module.reject = reject;
      });
      return module;
    };
  };

  /**
   * Convenience method for:
   *
   *     new PromiseWindow(uri, config).open()
   *
   * Use this method only if you never need to close the window programatically.
   * If you do, please consider using the classic way:
   *
   *     var w = new PromiseWindow(uri, config)
   *     w.open();
   *     // ...
   *     w.close();
   *
   * @return {Promise} Returns a Promise equivalent to the one returned by `open()`
   * @static
   */
  PromiseWindow.open = function open(uri, config) {
    return new PromiseWindow(uri, config).open();
  };

  /**
   * Default configuration
   * @type {Object}
   */
  PromiseWindow.defaultConfig = {
    width: html.clientWidth,
    height: html.clientHeight,
    window: {
      scrollbars: true
    },
    watcherDelay: 100,
    promiseProvider: null,
    onPostMessage: function onPostMessage(event) {
      if (event.data.error) {
        this._reject(event.data.error);
      } else {
        this._resolve(event.data);
      }
      this.close();
    },
    windowName: null,
    onClose: function() {
      this._window.close();
    },
    originRegexp: new RegExp('^[^:/?]+://[^/]*')
  };

  // Configure default Promise provider from current invironment
  if (root.Promise) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.Promise);
  }
  else if (root.RSVP) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.RSVP.Promise);
  }
  else if (root.Q) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.Q.Promise);
  }
  else if (root.jQuery) {
    PromiseWindow.defaultConfig.promiseProvider = function promiseProvider() {
      var deferred = root.jQuery.Deferred();
      return {
        promise: deferred.promise(),
        resolve: deferred.resolve,
        reject: deferred.reject
      };
    };
  }
  else {
    PromiseWindow.defaultConfig.promiseProvider = function() {
      throw new Error('Missing promiseProvider in PromiseWindow configuration');
    };
  }

  prototype = PromiseWindow.prototype;

  /**
   * Checks whether a value is a boolean
   * @param {*} value The value to check
   * @return {boolean} `true` if value is a boolean, `false` otherwise
   * @protected
   */
  prototype._isBoolean = function _isBoolean(value) {
    return value === true || value === false;
  };

  /**
   * Converts a config value into a value compatible with `window.open`.
   * If value is a boolean, convert it to 'yes' or 'no', otherwise simply
   * casts it into a string.
   * @param {*} value The value to convert
   * @return {string} The converted value
   * @protected
   */
  prototype._serializeFeatureValue = function _serializeFeatureValue(key, value) {
    if (this._isBoolean(value)) {
      return value ? 'yes' : 'no';
    }
    return '' + value;
  };

  /**
   * Get the left and top position in the screen for a rectangle, taking
   * dual-screen position into account
   * @param {Number} width Width of the rectangle
   * @param {Number} height Height of the rectangle
   * @return {Object} position A new object representing the position of the rectangle, centered
   * @return {Number} position.left The X coordinate of the centered rectangle
   * @return {Number} position.top The Y coordinate of the centered rectangle
   * @return {Number} position.width The width of the centered rectangle
   * @return {Number} position.height The height of the centered rectangle
   * @protected
   */
  prototype._getCenteredPosition = function _getCenteredPosition(width, height) {
    var dualScreenLeft = root.screenLeft !== undefined ? root.screenLeft : screen.left,
        dualScreenTop = root.screenTop !== undefined ? root.screenTop : screen.top,
        w = root.innerWidth || html.clientWidth || screen.width,
        h = root.innerHeight || html.clientHeight || screen.height;

    return {
      left: (w / 2) - (width / 2) + dualScreenLeft,
      top:  (h / 2) - (height / 2) + dualScreenTop,
      width: width,
      height: height
    };
  };

  /**
   * Generates window features based on the current configuration
   * @return {String} Returns window features compatible with `window.open`
   * @protected
   */
  prototype._getFeatures = function _getFeatures() {
    var config = this._getCenteredPosition(this.config.width, this.config.height);
    for (var key in this.config.window) {
      if (this.config.window.hasOwnProperty(key)) {
        config[key] = this.config.window[key];
      }
    }

    return Object.keys(config)
      .map(function(key) { return key + '=' + this._serializeFeatureValue(key, config[key]); }.bind(this))
      .join(',');
  };

  /**
   * Creates a new Promise, using `config.promiseProvider`, and save reject and
   * resolve methods for later.
   *
   * @return {Promise} Returns the new Promise object created by the configured
   *                   Promise Provider.
   * @protected
   */
  prototype._createPromise = function _createPromise() {
    var module = this.config.promiseProvider();
    this._resolve = module.resolve;
    this._reject = module.reject;
    return module.promise;
  };

  /**
   * Checks whether the window is alive or not
   * @return {Boolean} Returns `true` if the window is alive, `false` otherwise
   * @protected
   */
  prototype._isWindowAlive = function _isWindowAlive() {
    return this._window && !this._window.closed;
  };

  /**
   * Starts the popup window watcher.
   * @return {void}
   * @protected
   */
  prototype._startWatcher = function _startWatcher() {
    if (this._watcherRunning) {
      throw new Error('Watcher is already started');
    }
    this._watcher = root.setInterval(function () {
      if (this._watcherRunning && !this._isWindowAlive()) {
        this.close();
      }
    }.bind(this), this.config.watcherDelay);
    this._watcherRunning = true;
  };

  /**
   * Stops the popup window watcher.
   * @return {void}
   * @protected
   */
  prototype._stopWatcher = function _stopWatcher() {
    if (!this._watcherRunning) {
      throw new Error('Watcher is already stopped');
    }
    this._watcherRunning = false;
    root.clearInterval(this._watcher);
  };

  /**
   * Callback for post message events. If and only of the event has been
   * generated from the opened popup window, it propagates it to the configured
   * post message handler (`config.onPostMessage`).
   *
   * @param {Event} event The postMessage event
   * @return {void}
   * @protected
   */
  prototype._onPostMessage = function _onPostMessage(event) {
    var expectedOriginMatches = this.config.originRegexp.exec(this.uri);
    var expectedOrigin = expectedOriginMatches && expectedOriginMatches[0] || location.origin;
    if (this._window === event.source && event.origin === expectedOrigin) {
      this.config.onPostMessage.call(this, event);
    }
  };

  /**
   * Changes the URI
   * @param {String} uri The new URI
   * @throws {Error} If the window is open
   * @return {PromiseWindow} Returns this object to allow chaining
   */
  prototype.setURI = function setURI(uri) {
    if (this.isOpen()) {
      throw new Error('Cannot change the URI while the window is open');
    }
    this.uri = uri;
    return this;
  };

  /**
   * Opens a new popup window.
   *
   * @return {Promise} Returns a new `Promise` object. This promise will be:
   *                   - rejected with `"blocked"` message if the popup window
   *                     does not open for any reason (popup blocker, etc...)
   *                   - rejected with `"closed"` if closed either manually by
   *                     the user, or programatically
   *                   - rejected with the given error if the web page opened in
   *                     the popup sends a post message with a `error` data field.
   *                   - resolved with the given data if the web page opened in
   *                     the popup sends a post message without a `error` data
   *                     field.
   */
  prototype.open = function open() {
    if (this.isOpen()) {
      throw new Error('Window is already open');
    }

    this._windowOpen = true;
    var promise = this._createPromise();
    this._window = root.open(
      this.uri,
      this.config.windowName,
      this._getFeatures()
    );
    if (!this._window) {
      this._reject("blocked");
    }
    else {
      root.addEventListener("message", this._onPostMessage, true);
      this._startWatcher();
    }
    return promise;
  };

  /**
   * Closes the popup window.
   *
   * @return {void}
   */
  prototype.close = function close() {
    if (!this.isOpen()) {
      throw new Error('Window is already closed');
    }
    this._stopWatcher();
    root.removeEventListener("message", this._onPostMessage);
    if (this._isWindowAlive()) {
      this.config.onClose.call(this);
    }
    this._reject("closed");
    this._window = null;
    this._windowOpen = false;
  };

  /**
   * Checks whether the window is open or not
   * @return {Boolean} Returns `true` if the window is opened, `false` otherwise.
   */
  prototype.isOpen = function isOpen() {
    return this._windowOpen;
  };

  // Exports PromiseWindow to the global scope
  /* jshint ignore:start */
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return PromiseWindow }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
  /* jshint ignore:end */

})();


/***/ }),

/***/ "./node_modules/pseudomap/map.js":
/*!***************************************!*\
  !*** ./node_modules/pseudomap/map.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {if (process.env.npm_package_name === 'pseudomap' &&
    process.env.npm_lifecycle_script === 'test')
  process.env.TEST_PSEUDOMAP = 'true'

if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
  module.exports = Map
} else {
  module.exports = __webpack_require__(/*! ./pseudomap */ "./node_modules/pseudomap/pseudomap.js")
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pseudomap/pseudomap.js":
/*!*********************************************!*\
  !*** ./node_modules/pseudomap/pseudomap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty

module.exports = PseudoMap

function PseudoMap (set) {
  if (!(this instanceof PseudoMap)) // whyyyyyyy
    throw new TypeError("Constructor PseudoMap requires 'new'")

  this.clear()

  if (set) {
    if ((set instanceof PseudoMap) ||
        (typeof Map === 'function' && set instanceof Map))
      set.forEach(function (value, key) {
        this.set(key, value)
      }, this)
    else if (Array.isArray(set))
      set.forEach(function (kv) {
        this.set(kv[0], kv[1])
      }, this)
    else
      throw new TypeError('invalid argument')
  }
}

PseudoMap.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  Object.keys(this._data).forEach(function (k) {
    if (k !== 'size')
      fn.call(thisp, this._data[k].value, this._data[k].key)
  }, this)
}

PseudoMap.prototype.has = function (k) {
  return !!find(this._data, k)
}

PseudoMap.prototype.get = function (k) {
  var res = find(this._data, k)
  return res && res.value
}

PseudoMap.prototype.set = function (k, v) {
  set(this._data, k, v)
}

PseudoMap.prototype.delete = function (k) {
  var res = find(this._data, k)
  if (res) {
    delete this._data[res._index]
    this._data.size--
  }
}

PseudoMap.prototype.clear = function () {
  var data = Object.create(null)
  data.size = 0

  Object.defineProperty(this, '_data', {
    value: data,
    enumerable: false,
    configurable: true,
    writable: false
  })
}

Object.defineProperty(PseudoMap.prototype, 'size', {
  get: function () {
    return this._data.size
  },
  set: function (n) {},
  enumerable: true,
  configurable: true
})

PseudoMap.prototype.values =
PseudoMap.prototype.keys =
PseudoMap.prototype.entries = function () {
  throw new Error('iterators are not implemented in this version')
}

// Either identical, or both NaN
function same (a, b) {
  return a === b || a !== a && b !== b
}

function Entry (k, v, i) {
  this.key = k
  this.value = v
  this._index = i
}

function find (data, k) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k))
      return data[key]
  }
}

function set (data, k, v) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k)) {
      data[key].value = v
      return
    }
  }
  data.size++
  data[key] = new Entry(k, v, key)
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}


/***/ }),

/***/ "./src/authManager.js":
/*!****************************!*\
  !*** ./src/authManager.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = {
  getCurrentUser: function getCurrentUser() {
    return JSON.parse(localStorage.getItem('currentUser'));
  },
  setCurrentUser: function setCurrentUser(user) {
    return localStorage.setItem('currentUser', JSON.stringify(user));
  },
  getUserApiKey: function getUserApiKey() {
    return localStorage.getItem('userApiKey');
  },
  setUserApiKey: function setUserApiKey(apiKey) {
    return localStorage.setItem('userApiKey', apiKey);
  },
  hasUserApiKey: function hasUserApiKey() {
    return localStorage.getItem('userApiKey') !== null;
  },
  getAppProp: function getAppProp(appId, name) {
    return localStorage.getItem(appId + '_' + name);
  },
  setAppProp: function setAppProp(appId, name, storedProp) {
    return localStorage.setItem(appId + '_' + name, storedProp);
  },
  removeAppProp: function removeAppProp(appId, name) {
    return localStorage.removeItem(appId + '_' + name);
  },
  clearAuthData: function clearAuthData(appId) {
    localStorage.removeItem('userApiKey');
    localStorage.removeItem('currentUser');
    localStorage.removeItem(appId + '_clientId');
  }
};
exports["default"] = _default;

/***/ }),

/***/ "./src/discourse.js":
/*!**************************!*\
  !*** ./src/discourse.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");

__webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");

__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");

__webpack_require__(/*! core-js/modules/es.array.filter */ "./node_modules/core-js/modules/es.array.filter.js");

__webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");

__webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");

__webpack_require__(/*! core-js/modules/es.date.to-string */ "./node_modules/core-js/modules/es.date.to-string.js");

__webpack_require__(/*! core-js/modules/es.function.name */ "./node_modules/core-js/modules/es.function.name.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor */ "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js");

__webpack_require__(/*! core-js/modules/es.object.keys */ "./node_modules/core-js/modules/es.object.keys.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

__webpack_require__(/*! core-js/modules/es.regexp.constructor */ "./node_modules/core-js/modules/es.regexp.constructor.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.regexp.to-string */ "./node_modules/core-js/modules/es.regexp.to-string.js");

__webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");

__webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _discourseAuth = _interopRequireDefault(__webpack_require__(/*! ./discourseAuth */ "./src/discourseAuth.js"));

var _discourseClient = _interopRequireDefault(__webpack_require__(/*! ./discourseClient */ "./src/discourseClient.js"));

var _authManager = _interopRequireDefault(__webpack_require__(/*! ./authManager */ "./src/authManager.js"));

var _promiseWindow = _interopRequireDefault(__webpack_require__(/*! promise-window */ "./node_modules/promise-window/dist/promise-window.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Discourse =
/*#__PURE__*/
function () {
  function Discourse(options) {
    _classCallCheck(this, Discourse);

    this._requireOptions(options);

    this.options = this._formatOptions(options);
    this.auth = new _discourseAuth["default"](this.options);
    this.client = new _discourseClient["default"](this.options);
  }

  _createClass(Discourse, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return Promise.all([this.auth.init(), this.client.init()]);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_requireOptions",
    value: function _requireOptions(options) {
      options && _typeof(options) === 'object' || function (e) {
        throw e;
      }(new Error('Options must be an object'));
      typeof options.appName === 'string' && options.appName.length > 0 || function (e) {
        throw e;
      }(new Error('options.appName must be a non-empty string'));
      typeof options.apiBaseUrl === 'string' && options.apiBaseUrl.length > 0 || function (e) {
        throw e;
      }(new Error('Options.apiBaseUrl must be a non-empty string'));
      options.scopes instanceof Array && options.scopes.length > 0 || function (e) {
        throw e;
      }(new Error('Options.scopes must be a non-empty array'));
    }
  }, {
    key: "_formatOptions",
    value: function _formatOptions(options) {
      var formattedOptions = _objectSpread({}, options); // remove trailing slash


      formattedOptions.appId = this._slugify(options.appName);
      formattedOptions.apiBaseUrl = options.apiBaseUrl.replace(/\/$/, '');
      formattedOptions.scopes = options.scopes.join(',');
      return formattedOptions;
    }
  }, {
    key: "_slugify",
    value: function _slugify(text) {
      return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
    }
  }, {
    key: "getApiBaseUrl",
    value: function getApiBaseUrl() {
      return this.options.apiBaseUrl;
    }
  }, {
    key: "login",
    value: function () {
      var _login = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.isLoggedIn();

              case 2:
                if (!_context3.sent) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return");

              case 4:
                _context3.t0 = _promiseWindow["default"];
                _context3.next = 7;
                return this.auth._getLoginUrl();

              case 7:
                _context3.t1 = _context3.sent;
                _context3.t2 = {
                  width: 700,
                  height: 650,
                  originRegexp: new RegExp('^' + location.origin)
                };

                _context3.t3 =
                /*#__PURE__*/
                function () {
                  var _ref = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee2(data) {
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return _this.client._setUserApiKey(data.result.key);

                          case 2:
                            _context2.next = 4;
                            return _this._refreshCurrentUser();

                          case 4:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }();

                _context3.t4 = // Error
                function (error) {
                  switch (error) {
                    case 'closed':
                      dispatchEvent(new Event('discourseLoginCanceled'));
                      throw new Error('Authentication popup window closed by the user');

                    case 'blocked':
                      dispatchEvent(new Event('discourseLoginBlocked'));
                      throw new Error('Authentication popup window blocked by the browser');

                    default:
                      throw new Error('Authentication popup window returned an error: ', error);
                  }
                };

                _context3.t5 = function () {
                  return dispatchEvent(new Event('discourseLoggedIn'));
                };

                _context3.next = 14;
                return _context3.t0.open.call(_context3.t0, _context3.t1, _context3.t2).then(_context3.t3, _context3.t4).then(_context3.t5);

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function login() {
        return _login.apply(this, arguments);
      }

      return login;
    }()
  }, {
    key: "logout",
    value: function () {
      var _logout = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.client._doLogout(this.getCurrentUserName());

              case 2:
                _authManager["default"].clearAuthData(this.options.appId);

                dispatchEvent(new Event('discourseLoggedOut'));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
  }, {
    key: "getCurrentSessionUser",
    value: function () {
      var _getCurrentSessionUser = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.client._getCallResult('/session/current.json', 'current_user', true);

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getCurrentSessionUser() {
        return _getCurrentSessionUser.apply(this, arguments);
      }

      return getCurrentSessionUser;
    }()
  }, {
    key: "isLoggedIn",
    value: function () {
      var _isLoggedIn = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (_authManager["default"].hasUserApiKey()) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return", false);

              case 2:
                _context6.prev = 2;
                _context6.next = 5;
                return this._refreshCurrentUser();

              case 5:
                return _context6.abrupt("return", true);

              case 8:
                _context6.prev = 8;
                _context6.t0 = _context6["catch"](2);
                return _context6.abrupt("return", false);

              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[2, 8]]);
      }));

      function isLoggedIn() {
        return _isLoggedIn.apply(this, arguments);
      }

      return isLoggedIn;
    }()
  }, {
    key: "getCurrentUser",
    value: function getCurrentUser() {
      return _authManager["default"].getCurrentUser();
    }
  }, {
    key: "getCurrentUserName",
    value: function getCurrentUserName() {
      return this.getCurrentUser() && this.getCurrentUser()['username'];
    }
  }, {
    key: "getCurrentUserId",
    value: function getCurrentUserId() {
      return this.getCurrentUser() && this.getCurrentUser()['id'];
    }
  }, {
    key: "getCurrentUserDisplayName",
    value: function getCurrentUserDisplayName() {
      return this.getCurrentUser() && this.getCurrentUser()['name'];
    }
  }, {
    key: "isCurrentUserSilenced",
    value: function isCurrentUserSilenced() {
      return this.getCurrentUser() && !this.getCurrentUser()['can_create_topic'];
    }
  }, {
    key: "getCurrentUserAvatarUrl",
    value: function getCurrentUserAvatarUrl(size) {
      return this.getCurrentUser() && [this.options.apiBaseUrl, this.getCurrentUser()['avatar_template'].replace('{size}', size || 110)].join('/');
    }
  }, {
    key: "getCurrentUserNotificationsUrl",
    value: function getCurrentUserNotificationsUrl() {
      return this.getCurrentUser() && [this.options.apiBaseUrl, 'u', this.getCurrentUserName(), 'notifications'].join('/');
    }
  }, {
    key: "_refreshCurrentUser",
    value: function () {
      var _refreshCurrentUser2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.prev = 0;
                _context7.t0 = _authManager["default"];
                _context7.next = 4;
                return this.getCurrentSessionUser();

              case 4:
                _context7.t1 = _context7.sent;

                _context7.t0.setCurrentUser.call(_context7.t0, _context7.t1);

                _context7.next = 13;
                break;

              case 8:
                _context7.prev = 8;
                _context7.t2 = _context7["catch"](0);
                _context7.next = 12;
                return this.logout();

              case 12:
                throw new Error('Not logged in.');

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[0, 8]]);
      }));

      function _refreshCurrentUser() {
        return _refreshCurrentUser2.apply(this, arguments);
      }

      return _refreshCurrentUser;
    }()
  }, {
    key: "getLatestPosts",
    value: function () {
      var _getLatestPosts = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(descending) {
        var posts;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                _context8.next = 3;
                return this.client._getCallResult('/posts.json', 'latest_posts');

              case 3:
                posts = _context8.sent;
                _context8.next = 9;
                break;

              case 6:
                _context8.prev = 6;
                _context8.t0 = _context8["catch"](0);
                throw new Error(_context8.t0);

              case 9:
                if (descending) {
                  posts = posts.reverse();
                }

                return _context8.abrupt("return", posts.filter(function (post) {
                  return post.post_type === 1;
                }));

              case 11:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[0, 6]]);
      }));

      function getLatestPosts(_x2) {
        return _getLatestPosts.apply(this, arguments);
      }

      return getLatestPosts;
    }()
  }, {
    key: "getPostsInTopic",
    value: function () {
      var _getPostsInTopic = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(topicId, descending) {
        var nocache,
            posts,
            _args9 = arguments;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                nocache = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : false;
                _context9.next = 3;
                return this.client._getCallResult('/t/' + topicId + '/posts.json?include_raw=true', 'post_stream.posts', nocache);

              case 3:
                posts = _context9.sent;

                if (descending) {
                  posts = posts.reverse();
                }

                return _context9.abrupt("return", posts.filter(function (post) {
                  return post.post_type === 1;
                }));

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getPostsInTopic(_x3, _x4) {
        return _getPostsInTopic.apply(this, arguments);
      }

      return getPostsInTopic;
    }()
  }, {
    key: "getTopic",
    value: function () {
      var _getTopic = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(topicId, descending) {
        var nocache,
            topic,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                nocache = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : false;
                _context10.next = 3;
                return this.client._getCallResult('/t/' + topicId + '.json?include_raw=true', false, nocache);

              case 3:
                topic = _context10.sent;
                topic.post_stream.posts = topic.post_stream.posts.filter(function (post) {
                  return post.post_type === 1;
                });

                if (descending) {
                  topic.post_stream.posts = topic.post_stream.posts.reverse();
                }

                return _context10.abrupt("return", topic);

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getTopic(_x5, _x6) {
        return _getTopic.apply(this, arguments);
      }

      return getTopic;
    }()
  }, {
    key: "getPublicUserFields",
    value: function () {
      var _getPublicUserFields = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(username) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.client._getCallResult('/u/' + username + '.json?stats=false', 'user.user_fields');

              case 2:
                return _context11.abrupt("return", _context11.sent);

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getPublicUserFields(_x7) {
        return _getPublicUserFields.apply(this, arguments);
      }

      return getPublicUserFields;
    }()
  }, {
    key: "getPublicUserField",
    value: function () {
      var _getPublicUserField = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(username, field) {
        var userFields;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getPublicUserFields(username);

              case 2:
                userFields = _context12.sent;
                return _context12.abrupt("return", userFields && userFields[field]);

              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getPublicUserField(_x8, _x9) {
        return _getPublicUserField.apply(this, arguments);
      }

      return getPublicUserField;
    }()
  }, {
    key: "postMessage",
    value: function () {
      var _postMessage = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee13(topicId, message) {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this.client._checkUserApiKey();

                _context13.next = 3;
                return this.client._postCallResult('/posts.json', {
                  /* eslint-disable camelcase */
                  topic_id: topicId,
                  raw: message
                  /* eslint-enable camelcase */

                }).then(function (response) {
                  response.hidden && Promise.reject(response.hidden_reason_id);
                  return response;
                })["catch"](function (error) {
                  return Promise.reject(error.response.data.errors);
                });

              case 3:
                return _context13.abrupt("return", _context13.sent);

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function postMessage(_x10, _x11) {
        return _postMessage.apply(this, arguments);
      }

      return postMessage;
    }()
  }, {
    key: "likePost",
    value: function () {
      var _likePost = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee14(postId) {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                this.client._checkUserApiKey();

                _context14.next = 3;
                return this.client._postCallResult('/post_actions', {
                  /* eslint-disable camelcase */
                  id: postId,
                  post_action_type_id: 2
                  /* eslint-enable camelcase */

                }).then(function (response) {
                  return response;
                })["catch"](function (error) {
                  return Promise.reject(error.response.data.errors);
                });

              case 3:
                return _context14.abrupt("return", _context14.sent);

              case 4:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function likePost(_x12) {
        return _likePost.apply(this, arguments);
      }

      return likePost;
    }()
  }, {
    key: "undoLikePost",
    value: function () {
      var _undoLikePost = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee15(postId) {
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                this.client._checkUserApiKey();

                _context15.next = 3;
                return this.client.instance["delete"]('/post_actions/' + postId, {
                  data: {
                    /* eslint-disable camelcase */
                    post_action_type_id: '2'
                    /* eslint-enable camelcase */

                  }
                });

              case 3:
                return _context15.abrupt("return", _context15.sent.data);

              case 4:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function undoLikePost(_x13) {
        return _undoLikePost.apply(this, arguments);
      }

      return undoLikePost;
    }()
  }]);

  return Discourse;
}();

exports["default"] = Discourse;
window.Discourse = Discourse;

/***/ }),

/***/ "./src/discourseAuth.js":
/*!******************************!*\
  !*** ./src/discourseAuth.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");

__webpack_require__(/*! core-js/modules/es.array.map */ "./node_modules/core-js/modules/es.array.map.js");

__webpack_require__(/*! core-js/modules/es.date.to-string */ "./node_modules/core-js/modules/es.date.to-string.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.keys */ "./node_modules/core-js/modules/es.object.keys.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.regexp.to-string */ "./node_modules/core-js/modules/es.regexp.to-string.js");

__webpack_require__(/*! core-js/modules/es.string.search */ "./node_modules/core-js/modules/es.string.search.js");

__webpack_require__(/*! core-js/modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _keyManager = _interopRequireDefault(__webpack_require__(/*! ./keyManager */ "./src/keyManager.js"));

var _authManager = _interopRequireDefault(__webpack_require__(/*! ./authManager */ "./src/authManager.js"));

var _urlSearchParams = _interopRequireDefault(__webpack_require__(/*! @ungap/url-search-params */ "./node_modules/@ungap/url-search-params/esm/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// polyfill
// import MobileDetect from 'mobile-detect';
var DiscourseAuth =
/*#__PURE__*/
function () {
  function DiscourseAuth(options) {
    _classCallCheck(this, DiscourseAuth);

    this.km = new _keyManager["default"](options.appId);
    this.options = options;
  }

  _createClass(DiscourseAuth, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.km.getKeys();

              case 2:
                _authManager["default"].hasUserApiKey() || this._managePayload();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_getLoginUrl",
    value: function () {
      var _getLoginUrl2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var params;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = this.options.appName;
                _context2.next = 3;
                return this.km.getPublicKey();

              case 3:
                _context2.t1 = _context2.sent;
                _context2.t2 = this._generateStoredRandom('nonce');
                _context2.t3 = _authManager["default"].getAppProp(this.options.appId, 'clientId') || this._generateStoredRandom('clientId');
                _context2.t4 = location.href;
                _context2.t5 = this.options.scopes;
                params = {
                  application_name: _context2.t0,
                  public_key: _context2.t1,
                  nonce: _context2.t2,
                  client_id: _context2.t3,
                  auth_redirect: _context2.t4,
                  scopes: _context2.t5
                };
                return _context2.abrupt("return", this.options.apiBaseUrl + '/user-api-key/new?' + this._serializeParams(params));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getLoginUrl() {
        return _getLoginUrl2.apply(this, arguments);
      }

      return _getLoginUrl;
    }()
  }, {
    key: "_serializeParams",
    value: function _serializeParams(params) {
      return Object.keys(params).map(function (k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
      }).join('&');
    }
  }, {
    key: "_generateStoredRandom",
    value: function _generateStoredRandom(name) {
      var storedRandom = Math.random().toString(16).substr(2);

      _authManager["default"].setAppProp(this.options.appId, name, storedRandom);

      return storedRandom;
    }
  }, {
    key: "_managePayload",
    value: function _managePayload() {
      var _this = this;

      var url = new _urlSearchParams["default"](window.location.search || window.location.hash.split('?')[1]);

      if (url.has('payload') && opener) {
        this.km.decryptPayload(url.get('payload')).then(function (payloadObject) {
          payloadObject.nonce === _authManager["default"].getAppProp(_this.options.appId, 'nonce') || function (e) {
            throw e;
          }(new Error('The returned payload is invalid.'));
          payloadObject.api === 4 || function (e) {
            throw e;
          }(new Error('Wrong API version: ' + payloadObject.api + '. Discourse-js works with API version 3.'));

          _authManager["default"].setUserApiKey(payloadObject.key);

          _authManager["default"].removeAppProp(_this.options.appId, 'nonce');

          opener.postMessage({
            result: payloadObject
          }, location.origin);
        });
      } // var md = new MobileDetect(window.navigator.userAgent);

    }
  }]);

  return DiscourseAuth;
}();

exports["default"] = DiscourseAuth;

/***/ }),

/***/ "./src/discourseClient.js":
/*!********************************!*\
  !*** ./src/discourseClient.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.array.reduce */ "./node_modules/core-js/modules/es.array.reduce.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _authManager = _interopRequireDefault(__webpack_require__(/*! ./authManager */ "./src/authManager.js"));

var _axios = _interopRequireDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));

var _axiosExtensions = __webpack_require__(/*! axios-extensions */ "./node_modules/axios-extensions/esm/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DiscourseClient =
/*#__PURE__*/
function () {
  function DiscourseClient(options) {
    _classCallCheck(this, DiscourseClient);

    this.options = options;
    this.instance = _axios["default"].create({
      baseURL: options.apiBaseUrl,
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/json'
      },
      adapter: (0, _axiosExtensions.throttleAdapterEnhancer)((0, _axiosExtensions.cacheAdapterEnhancer)(_axios["default"].defaults.adapter), {
        threshold: 500 // 120 reqs/min

      })
    });
  }

  _createClass(DiscourseClient, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._setUserApiKey(_authManager["default"].getUserApiKey());

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_getCallResult",
    value: function () {
      var _getCallResult2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(endpoint, prop) {
        var nocache,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                nocache = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;
                _context2.prev = 1;
                _context2.next = 4;
                return this.instance.get(endpoint, {
                  forceUpdate: nocache
                });

              case 4:
                response = _context2.sent.data;
                _context2.next = 10;
                break;

              case 7:
                _context2.prev = 7;
                _context2.t0 = _context2["catch"](1);
                throw new Error(_context2.t0);

              case 10:
                if (prop) {
                  response = prop.split('.').reduce(function (returnedResponse, currentProp) {
                    return returnedResponse[currentProp];
                  }, response);
                }

                return _context2.abrupt("return", response);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 7]]);
      }));

      function _getCallResult(_x, _x2) {
        return _getCallResult2.apply(this, arguments);
      }

      return _getCallResult;
    }()
  }, {
    key: "_postCallResult",
    value: function () {
      var _postCallResult2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(endpoint, payload) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.instance.post(endpoint, payload);

              case 2:
                return _context3.abrupt("return", _context3.sent.data);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _postCallResult(_x3, _x4) {
        return _postCallResult2.apply(this, arguments);
      }

      return _postCallResult;
    }()
  }, {
    key: "_setUserApiKey",
    value: function () {
      var _setUserApiKey2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(userApiKey) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (userApiKey) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return");

              case 2:
                _context4.prev = 2;
                this.instance.defaults.headers.common['User-Api-Key'] = userApiKey;
                _context4.next = 6;
                return this._setCsrfToken();

              case 6:
                _context4.next = 12;
                break;

              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](2);

                _authManager["default"].clearAuthData(this.options.appId);

                delete this.instance.defaults.headers.common['User-Api-Key'];

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[2, 8]]);
      }));

      function _setUserApiKey(_x5) {
        return _setUserApiKey2.apply(this, arguments);
      }

      return _setUserApiKey;
    }()
  }, {
    key: "_setCsrfToken",
    value: function () {
      var _setCsrfToken2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._getCallResult('/session/csrf.json', 'csrf');

              case 2:
                this.instance.defaults.headers.common['X-CSRF-Token'] = _context5.sent;

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _setCsrfToken() {
        return _setCsrfToken2.apply(this, arguments);
      }

      return _setCsrfToken;
    }()
  }, {
    key: "_checkUserApiKey",
    value: function _checkUserApiKey() {
      this.instance.defaults.headers.common['User-Api-Key'] || function (e) {
        throw e;
      }(new Error('User API key not set'));
    }
  }, {
    key: "_doLogout",
    value: function () {
      var _doLogout2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(username) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this._checkUserApiKey();

                _context6.next = 3;
                return this.instance["delete"]('/session/' + username);

              case 3:
                _context6.next = 5;
                return this.instance.post('/user-api-key/revoke');

              case 5:
                delete this.instance.defaults.headers.common['User-Api-Key'];
                delete this.instance.defaults.headers.common['X-CSRF-Token'];

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _doLogout(_x6) {
        return _doLogout2.apply(this, arguments);
      }

      return _doLogout;
    }()
  }]);

  return DiscourseClient;
}();

exports["default"] = DiscourseClient;

/***/ }),

/***/ "./src/keyGenerator.js":
/*!*****************************!*\
  !*** ./src/keyGenerator.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _authManager = _interopRequireDefault(__webpack_require__(/*! ./authManager */ "./src/authManager.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var forge = __webpack_require__(/*! ./vendor/forge-pki */ "./src/vendor/forge-pki.js");

var _default = function () {
  var generate = function generate(appId) {
    return new Promise(function (resolve, reject) {
      forge.rsa.generateKeyPair({
        workerScript: '/prime-worker.min.js'
      }, function (error, generatedKeypair) {
        generatedKeypair ? function () {
          var keypair = {
            "public": forge.pki.publicKeyToPem(generatedKeypair.publicKey, 72).replace(/\r/g, ''),
            "private": forge.pki.privateKeyToPem(generatedKeypair.privateKey, 72).replace(/\r/g, '')
          };

          _authManager["default"].setAppProp(appId, 'publicKey', keypair["public"]);

          _authManager["default"].setAppProp(appId, 'privateKey', keypair["private"]);

          resolve(keypair);
        }() : reject(error);
      });
    });
  };

  return {
    generate: generate
  };
}();

exports["default"] = _default;

/***/ }),

/***/ "./src/keyManager.js":
/*!***************************!*\
  !*** ./src/keyManager.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _authManager = _interopRequireDefault(__webpack_require__(/*! ./authManager */ "./src/authManager.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var KeyManager =
/*#__PURE__*/
function () {
  function KeyManager(appId) {
    _classCallCheck(this, KeyManager);

    this.appId = appId;
  }

  _createClass(KeyManager, [{
    key: "generateNewKeypair",
    value: function () {
      var _generateNewKeypair = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve(/*! import() | keyGenerator */).then(__webpack_require__.t.bind(null, /*! ./keyGenerator */ "./src/keyGenerator.js", 7)).then(function (_ref) {
                  var keyGenerator = _ref["default"];
                  return keyGenerator.generate(_this.appId).then(function (keypair) {
                    return keypair;
                  });
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function generateNewKeypair() {
        return _generateNewKeypair.apply(this, arguments);
      }

      return generateNewKeypair;
    }()
  }, {
    key: "getKeys",
    value: function () {
      var _getKeys = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = this.readKeysFromStorage();

                if (_context2.t0) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 4;
                return this.generateNewKeypair();

              case 4:
                _context2.t0 = _context2.sent;

              case 5:
                return _context2.abrupt("return", _context2.t0);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getKeys() {
        return _getKeys.apply(this, arguments);
      }

      return getKeys;
    }()
  }, {
    key: "readKeysFromStorage",
    value: function readKeysFromStorage() {
      var publicKey = _authManager["default"].getAppProp(this.appId, 'publicKey');

      var privateKey = _authManager["default"].getAppProp(this.appId, 'privateKey');

      return publicKey && privateKey ? {
        "public": publicKey,
        "private": privateKey
      } : null;
    }
  }, {
    key: "getPublicKey",
    value: function () {
      var _getPublicKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getKeys();

              case 2:
                return _context3.abrupt("return", _context3.sent['public']);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPublicKey() {
        return _getPublicKey.apply(this, arguments);
      }

      return getPublicKey;
    }()
  }, {
    key: "getPrivateKey",
    value: function () {
      var _getPrivateKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getKeys();

              case 2:
                return _context4.abrupt("return", _context4.sent['private']);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPrivateKey() {
        return _getPrivateKey.apply(this, arguments);
      }

      return getPrivateKey;
    }()
  }, {
    key: "decryptPayload",
    value: function () {
      var _decryptPayload = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(payload) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.getPrivateKey().then(function (privateKey) {
                  return Promise.resolve(/*! import() | jsencrypt */).then(__webpack_require__.t.bind(null, /*! jsencrypt */ "./node_modules/jsencrypt/bin/jsencrypt.js", 7)).then(function (_ref2) {
                    var Jsencrypt = _ref2["default"];
                    var jsencrypt = new Jsencrypt();
                    jsencrypt.setPrivateKey(privateKey);
                    return JSON.parse(jsencrypt.decrypt(payload));
                  });
                }));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function decryptPayload(_x) {
        return _decryptPayload.apply(this, arguments);
      }

      return decryptPayload;
    }()
  }]);

  return KeyManager;
}();

exports["default"] = KeyManager;
;

/***/ }),

/***/ "./src/vendor/forge-pki.js":
/*!*********************************!*\
  !*** ./src/vendor/forge-pki.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, Buffer, module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");__webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");__webpack_require__(/*! core-js/modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");__webpack_require__(/*! core-js/modules/es.array.filter */ "./node_modules/core-js/modules/es.array.filter.js");__webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");__webpack_require__(/*! core-js/modules/es.array.index-of */ "./node_modules/core-js/modules/es.array.index-of.js");__webpack_require__(/*! core-js/modules/es.array.is-array */ "./node_modules/core-js/modules/es.array.is-array.js");__webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");__webpack_require__(/*! core-js/modules/es.array.reduce */ "./node_modules/core-js/modules/es.array.reduce.js");__webpack_require__(/*! core-js/modules/es.array.slice */ "./node_modules/core-js/modules/es.array.slice.js");__webpack_require__(/*! core-js/modules/es.array.splice */ "./node_modules/core-js/modules/es.array.splice.js");__webpack_require__(/*! core-js/modules/es.array-buffer.constructor */ "./node_modules/core-js/modules/es.array-buffer.constructor.js");__webpack_require__(/*! core-js/modules/es.array-buffer.slice */ "./node_modules/core-js/modules/es.array-buffer.slice.js");__webpack_require__(/*! core-js/modules/es.data-view */ "./node_modules/core-js/modules/es.data-view.js");__webpack_require__(/*! core-js/modules/es.date.now */ "./node_modules/core-js/modules/es.date.now.js");__webpack_require__(/*! core-js/modules/es.date.to-string */ "./node_modules/core-js/modules/es.date.to-string.js");__webpack_require__(/*! core-js/modules/es.function.name */ "./node_modules/core-js/modules/es.function.name.js");__webpack_require__(/*! core-js/modules/es.number.to-fixed */ "./node_modules/core-js/modules/es.number.to-fixed.js");__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");__webpack_require__(/*! core-js/modules/es.parse-float */ "./node_modules/core-js/modules/es.parse-float.js");__webpack_require__(/*! core-js/modules/es.parse-int */ "./node_modules/core-js/modules/es.parse-int.js");__webpack_require__(/*! core-js/modules/es.regexp.constructor */ "./node_modules/core-js/modules/es.regexp.constructor.js");__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");__webpack_require__(/*! core-js/modules/es.regexp.to-string */ "./node_modules/core-js/modules/es.regexp.to-string.js");__webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");__webpack_require__(/*! core-js/modules/es.string.match */ "./node_modules/core-js/modules/es.string.match.js");__webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");__webpack_require__(/*! core-js/modules/es.string.search */ "./node_modules/core-js/modules/es.string.search.js");__webpack_require__(/*! core-js/modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");__webpack_require__(/*! core-js/modules/es.typed-array.uint8-array */ "./node_modules/core-js/modules/es.typed-array.uint8-array.js");__webpack_require__(/*! core-js/modules/es.typed-array.uint16-array */ "./node_modules/core-js/modules/es.typed-array.uint16-array.js");__webpack_require__(/*! core-js/modules/es.typed-array.uint32-array */ "./node_modules/core-js/modules/es.typed-array.uint32-array.js");__webpack_require__(/*! core-js/modules/es.typed-array.copy-within */ "./node_modules/core-js/modules/es.typed-array.copy-within.js");__webpack_require__(/*! core-js/modules/es.typed-array.every */ "./node_modules/core-js/modules/es.typed-array.every.js");__webpack_require__(/*! core-js/modules/es.typed-array.fill */ "./node_modules/core-js/modules/es.typed-array.fill.js");__webpack_require__(/*! core-js/modules/es.typed-array.filter */ "./node_modules/core-js/modules/es.typed-array.filter.js");__webpack_require__(/*! core-js/modules/es.typed-array.find */ "./node_modules/core-js/modules/es.typed-array.find.js");__webpack_require__(/*! core-js/modules/es.typed-array.find-index */ "./node_modules/core-js/modules/es.typed-array.find-index.js");__webpack_require__(/*! core-js/modules/es.typed-array.for-each */ "./node_modules/core-js/modules/es.typed-array.for-each.js");__webpack_require__(/*! core-js/modules/es.typed-array.includes */ "./node_modules/core-js/modules/es.typed-array.includes.js");__webpack_require__(/*! core-js/modules/es.typed-array.index-of */ "./node_modules/core-js/modules/es.typed-array.index-of.js");__webpack_require__(/*! core-js/modules/es.typed-array.iterator */ "./node_modules/core-js/modules/es.typed-array.iterator.js");__webpack_require__(/*! core-js/modules/es.typed-array.join */ "./node_modules/core-js/modules/es.typed-array.join.js");__webpack_require__(/*! core-js/modules/es.typed-array.last-index-of */ "./node_modules/core-js/modules/es.typed-array.last-index-of.js");__webpack_require__(/*! core-js/modules/es.typed-array.map */ "./node_modules/core-js/modules/es.typed-array.map.js");__webpack_require__(/*! core-js/modules/es.typed-array.reduce */ "./node_modules/core-js/modules/es.typed-array.reduce.js");__webpack_require__(/*! core-js/modules/es.typed-array.reduce-right */ "./node_modules/core-js/modules/es.typed-array.reduce-right.js");__webpack_require__(/*! core-js/modules/es.typed-array.reverse */ "./node_modules/core-js/modules/es.typed-array.reverse.js");__webpack_require__(/*! core-js/modules/es.typed-array.set */ "./node_modules/core-js/modules/es.typed-array.set.js");__webpack_require__(/*! core-js/modules/es.typed-array.slice */ "./node_modules/core-js/modules/es.typed-array.slice.js");__webpack_require__(/*! core-js/modules/es.typed-array.some */ "./node_modules/core-js/modules/es.typed-array.some.js");__webpack_require__(/*! core-js/modules/es.typed-array.sort */ "./node_modules/core-js/modules/es.typed-array.sort.js");__webpack_require__(/*! core-js/modules/es.typed-array.subarray */ "./node_modules/core-js/modules/es.typed-array.subarray.js");__webpack_require__(/*! core-js/modules/es.typed-array.to-locale-string */ "./node_modules/core-js/modules/es.typed-array.to-locale-string.js");__webpack_require__(/*! core-js/modules/es.typed-array.to-string */ "./node_modules/core-js/modules/es.typed-array.to-string.js");__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");__webpack_require__(/*! core-js/modules/web.immediate */ "./node_modules/core-js/modules/web.immediate.js");__webpack_require__(/*! core-js/modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");__webpack_require__(/*! core-js/modules/web.url */ "./node_modules/core-js/modules/web.url.js");function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}(function webpackUniversalModuleDefinition(root,factory){if(( false?undefined:_typeof(exports))==='object'&&( false?undefined:_typeof(module))==='object')module.exports=factory();else if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(typeof self!=='undefined'?self:void 0,function(){return(/******/function(modules){// webpackBootstrap
/******/ // The module cache
/******/var installedModules={};/******/ /******/ // The require function
/******/function __webpack_require__(moduleId){/******/ /******/ // Check if module is in cache
/******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/ // Create a new module (and put it into the cache)
/******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******/ /******/ // Execute the module function
/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******/ /******/ // Flag the module as loaded
/******/module.l=true;/******/ /******/ // Return the exports of the module
/******/return module.exports;/******/}/******/ /******/ /******/ // expose the modules object (__webpack_modules__)
/******/__webpack_require__.m=modules;/******/ /******/ // expose the module cache
/******/__webpack_require__.c=installedModules;/******/ /******/ // define getter function for harmony exports
/******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{/******/configurable:false,/******/enumerable:true,/******/get:getter/******/});/******/}/******/};/******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
/******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******/ /******/ // Object.prototype.hasOwnProperty.call
/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******/ /******/ // __webpack_public_path__
/******/__webpack_require__.p="";/******/ /******/ // Load entry module and return exports
/******/return __webpack_require__(__webpack_require__.s=20);/******/}(/************************************************************************/ /******/[/* 0 */ /***/function(module,exports){/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */module.exports={// default options
options:{usePureJavaScript:false}};/***/},/* 1 */ /***/function(module,exports,__webpack_require__){/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);var baseN=__webpack_require__(22);/* Utilities API */var util=module.exports=forge.util=forge.util||{};// define setImmediate and nextTick
(function(){// use native nextTick (unless we're in webpack)
// webpack (or better node-libs-browser polyfill) sets process.browser.
// this way we can detect webpack properly
if(typeof process!=='undefined'&&process.nextTick&&!process.browser){util.nextTick=process.nextTick;if(typeof setImmediate==='function'){util.setImmediate=setImmediate;}else{// polyfill setImmediate with nextTick, older versions of node
// (those w/o setImmediate) won't totally starve IO
util.setImmediate=util.nextTick;}return;}// polyfill nextTick with native setImmediate
if(typeof setImmediate==='function'){util.setImmediate=function(){return setImmediate.apply(undefined,arguments);};util.nextTick=function(callback){return setImmediate(callback);};return;}/* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */ // polyfill with setTimeout
util.setImmediate=function(callback){setTimeout(callback,0);};// upgrade polyfill to use postMessage
if(typeof window!=='undefined'&&typeof window.postMessage==='function'){var handler=function handler(event){if(event.source===window&&event.data===msg){event.stopPropagation();var copy=callbacks.slice();callbacks.length=0;copy.forEach(function(callback){callback();});}};var msg='forge.setImmediate';var callbacks=[];util.setImmediate=function(callback){callbacks.push(callback);// only send message when one hasn't been sent in
// the current turn of the event loop
if(callbacks.length===1){window.postMessage(msg,'*');}};window.addEventListener('message',handler,true);}// upgrade polyfill to use MutationObserver
if(typeof MutationObserver!=='undefined'){// polyfill with MutationObserver
var now=Date.now();var attr=true;var div=document.createElement('div');var callbacks=[];new MutationObserver(function(){var copy=callbacks.slice();callbacks.length=0;copy.forEach(function(callback){callback();});}).observe(div,{attributes:true});var oldSetImmediate=util.setImmediate;util.setImmediate=function(callback){if(Date.now()-now>15){now=Date.now();oldSetImmediate(callback);}else{callbacks.push(callback);// only trigger observer when it hasn't been triggered in
// the current turn of the event loop
if(callbacks.length===1){div.setAttribute('a',attr=!attr);}}};}util.nextTick=util.setImmediate;})();// check if running under Node.js
util.isNodejs=typeof process!=='undefined'&&process.versions&&process.versions.node;// define isArray
util.isArray=Array.isArray||function(x){return Object.prototype.toString.call(x)==='[object Array]';};// define isArrayBuffer
util.isArrayBuffer=function(x){return typeof ArrayBuffer!=='undefined'&&x instanceof ArrayBuffer;};// define isArrayBufferView
util.isArrayBufferView=function(x){return x&&util.isArrayBuffer(x.buffer)&&x.byteLength!==undefined;};/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */function _checkBitsParam(n){if(!(n===8||n===16||n===24||n===32)){throw new Error('Only 8, 16, 24, or 32 bits supported: '+n);}}// TODO: set ByteBuffer to best available backing
util.ByteBuffer=ByteStringBuffer;/** Buffer w/BinaryString backing */ /**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */function ByteStringBuffer(b){// TODO: update to match DataBuffer API
// the data in this buffer
this.data='';// the pointer for reading from this buffer
this.read=0;if(typeof b==='string'){this.data=b;}else if(util.isArrayBuffer(b)||util.isArrayBufferView(b)){if(typeof Buffer!=='undefined'&&b instanceof Buffer){this.data=b.toString('binary');}else{// convert native buffer to forge buffer
// FIXME: support native buffers internally instead
var arr=new Uint8Array(b);try{this.data=String.fromCharCode.apply(null,arr);}catch(e){for(var i=0;i<arr.length;++i){this.putByte(arr[i]);}}}}else if(b instanceof ByteStringBuffer||_typeof(b)==='object'&&typeof b.data==='string'&&typeof b.read==='number'){// copy existing buffer
this.data=b.data;this.read=b.read;}// used for v8 optimization
this._constructedStringLength=0;}util.ByteStringBuffer=ByteStringBuffer;/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */var _MAX_CONSTRUCTED_STRING_LENGTH=4096;util.ByteStringBuffer.prototype._optimizeConstructedString=function(x){this._constructedStringLength+=x;if(this._constructedStringLength>_MAX_CONSTRUCTED_STRING_LENGTH){// this substr() should cause the constructed string to join
this.data.substr(0,1);this._constructedStringLength=0;}};/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */util.ByteStringBuffer.prototype.length=function(){return this.data.length-this.read;};/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */util.ByteStringBuffer.prototype.isEmpty=function(){return this.length()<=0;};/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putByte=function(b){return this.putBytes(String.fromCharCode(b));};/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.fillWithByte=function(b,n){b=String.fromCharCode(b);var d=this.data;while(n>0){if(n&1){d+=b;}n>>>=1;if(n>0){b+=b;}}this.data=d;this._optimizeConstructedString(n);return this;};/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a UTF-8 encoded string) to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putBytes=function(bytes){this.data+=bytes;this._optimizeConstructedString(bytes.length);return this;};/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putString=function(str){return this.putBytes(util.encodeUtf8(str));};/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt16=function(i){return this.putBytes(String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt24=function(i){return this.putBytes(String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt32=function(i){return this.putBytes(String.fromCharCode(i>>24&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt16Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF));};/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt24Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i>>16&0xFF));};/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt32Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>24&0xFF));};/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt=function(i,n){_checkBitsParam(n);var bytes='';do{n-=8;bytes+=String.fromCharCode(i>>n&0xFF);}while(n>0);return this.putBytes(bytes);};/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putSignedInt=function(i,n){// putInt checks n
if(i<0){i+=2<<n-1;}return this.putInt(i,n);};/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putBuffer=function(buffer){return this.putBytes(buffer.getBytes());};/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */util.ByteStringBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++);};/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.ByteStringBuffer.prototype.getInt16=function(){var rval=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.ByteStringBuffer.prototype.getInt24=function(){var rval=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.ByteStringBuffer.prototype.getInt32=function(){var rval=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);this.read+=4;return rval;};/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.ByteStringBuffer.prototype.getInt16Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.ByteStringBuffer.prototype.getInt24Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.ByteStringBuffer.prototype.getInt32Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;this.read+=4;return rval;};/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.ByteStringBuffer.prototype.getInt=function(n){_checkBitsParam(n);var rval=0;do{// TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
rval=(rval<<8)+this.data.charCodeAt(this.read++);n-=8;}while(n>0);return rval;};/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.ByteStringBuffer.prototype.getSignedInt=function(n){// getInt checks n
var x=this.getInt(n);var max=2<<n-2;if(x>=max){x-=max<<1;}return x;};/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */util.ByteStringBuffer.prototype.getBytes=function(count){var rval;if(count){// read count bytes
count=Math.min(this.length(),count);rval=this.data.slice(this.read,this.read+count);this.read+=count;}else if(count===0){rval='';}else{// read all bytes, optimize to only copy when needed
rval=this.read===0?this.data:this.data.slice(this.read);this.clear();}return rval;};/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */util.ByteStringBuffer.prototype.bytes=function(count){return typeof count==='undefined'?this.data.slice(this.read):this.data.slice(this.read,this.read+count);};/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */util.ByteStringBuffer.prototype.at=function(i){return this.data.charCodeAt(this.read+i);};/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.setAt=function(i,b){this.data=this.data.substr(0,this.read+i)+String.fromCharCode(b)+this.data.substr(this.read+i+1);return this;};/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */util.ByteStringBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1);};/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */util.ByteStringBuffer.prototype.copy=function(){var c=util.createBuffer(this.data);c.read=this.read;return c;};/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.compact=function(){if(this.read>0){this.data=this.data.slice(this.read);this.read=0;}return this;};/**
 * Clears this buffer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.clear=function(){this.data='';this.read=0;return this;};/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.truncate=function(count){var len=Math.max(0,this.length()-count);this.data=this.data.substr(this.read,len);this.read=0;return this;};/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */util.ByteStringBuffer.prototype.toHex=function(){var rval='';for(var i=this.read;i<this.data.length;++i){var b=this.data.charCodeAt(i);if(b<16){rval+='0';}rval+=b.toString(16);}return rval;};/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */util.ByteStringBuffer.prototype.toString=function(){return util.decodeUtf8(this.bytes());};/** End Buffer w/BinaryString backing */ /** Buffer w/UInt8Array backing */ /**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */function DataBuffer(b,options){// default options
options=options||{};// pointers for read from/write to buffer
this.read=options.readOffset||0;this.growSize=options.growSize||1024;var isArrayBuffer=util.isArrayBuffer(b);var isArrayBufferView=util.isArrayBufferView(b);if(isArrayBuffer||isArrayBufferView){// use ArrayBuffer directly
if(isArrayBuffer){this.data=new DataView(b);}else{// TODO: adjust read/write offset based on the type of view
// or specify that this must be done in the options ... that the
// offsets are byte-based
this.data=new DataView(b.buffer,b.byteOffset,b.byteLength);}this.write='writeOffset'in options?options.writeOffset:this.data.byteLength;return;}// initialize to empty array buffer and add any given bytes using putBytes
this.data=new DataView(new ArrayBuffer(0));this.write=0;if(b!==null&&b!==undefined){this.putBytes(b);}if('writeOffset'in options){this.write=options.writeOffset;}}util.DataBuffer=DataBuffer;/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */util.DataBuffer.prototype.length=function(){return this.write-this.read;};/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */util.DataBuffer.prototype.isEmpty=function(){return this.length()<=0;};/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */util.DataBuffer.prototype.accommodate=function(amount,growSize){if(this.length()>=amount){return this;}growSize=Math.max(growSize||this.growSize,amount);// grow buffer
var src=new Uint8Array(this.data.buffer,this.data.byteOffset,this.data.byteLength);var dst=new Uint8Array(this.length()+growSize);dst.set(src);this.data=new DataView(dst.buffer);return this;};/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putByte=function(b){this.accommodate(1);this.data.setUint8(this.write++,b);return this;};/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.fillWithByte=function(b,n){this.accommodate(n);for(var i=0;i<n;++i){this.data.setUint8(b);}return this;};/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putBytes=function(bytes,encoding){if(util.isArrayBufferView(bytes)){var src=new Uint8Array(bytes.buffer,bytes.byteOffset,bytes.byteLength);var len=src.byteLength-src.byteOffset;this.accommodate(len);var dst=new Uint8Array(this.data.buffer,this.write);dst.set(src);this.write+=len;return this;}if(util.isArrayBuffer(bytes)){var src=new Uint8Array(bytes);this.accommodate(src.byteLength);var dst=new Uint8Array(this.data.buffer);dst.set(src,this.write);this.write+=src.byteLength;return this;}// bytes is a util.DataBuffer or equivalent
if(bytes instanceof util.DataBuffer||_typeof(bytes)==='object'&&typeof bytes.read==='number'&&typeof bytes.write==='number'&&util.isArrayBufferView(bytes.data)){var src=new Uint8Array(bytes.data.byteLength,bytes.read,bytes.length());this.accommodate(src.byteLength);var dst=new Uint8Array(bytes.data.byteLength,this.write);dst.set(src);this.write+=src.byteLength;return this;}if(bytes instanceof util.ByteStringBuffer){// copy binary string and process as the same as a string parameter below
bytes=bytes.data;encoding='binary';}// string conversion
encoding=encoding||'binary';if(typeof bytes==='string'){var view;// decode from string
if(encoding==='hex'){this.accommodate(Math.ceil(bytes.length/2));view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.hex.decode(bytes,view,this.write);return this;}if(encoding==='base64'){this.accommodate(Math.ceil(bytes.length/4)*3);view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.base64.decode(bytes,view,this.write);return this;}// encode text as UTF-8 bytes
if(encoding==='utf8'){// encode as UTF-8 then decode string as raw binary
bytes=util.encodeUtf8(bytes);encoding='binary';}// decode string as raw binary
if(encoding==='binary'||encoding==='raw'){// one byte per character
this.accommodate(bytes.length);view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.raw.decode(view);return this;}// encode text as UTF-16 bytes
if(encoding==='utf16'){// two bytes per character
this.accommodate(bytes.length*2);view=new Uint16Array(this.data.buffer,this.write);this.write+=util.text.utf16.encode(view);return this;}throw new Error('Invalid encoding: '+encoding);}throw Error('Invalid parameter: '+bytes);};/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putBuffer=function(buffer){this.putBytes(buffer);buffer.clear();return this;};/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putString=function(str){return this.putBytes(str,'utf16');};/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt16=function(i){this.accommodate(2);this.data.setInt16(this.write,i);this.write+=2;return this;};/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt24=function(i){this.accommodate(3);this.data.setInt16(this.write,i>>8&0xFFFF);this.data.setInt8(this.write,i>>16&0xFF);this.write+=3;return this;};/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt32=function(i){this.accommodate(4);this.data.setInt32(this.write,i);this.write+=4;return this;};/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt16Le=function(i){this.accommodate(2);this.data.setInt16(this.write,i,true);this.write+=2;return this;};/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt24Le=function(i){this.accommodate(3);this.data.setInt8(this.write,i>>16&0xFF);this.data.setInt16(this.write,i>>8&0xFFFF,true);this.write+=3;return this;};/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt32Le=function(i){this.accommodate(4);this.data.setInt32(this.write,i,true);this.write+=4;return this;};/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt=function(i,n){_checkBitsParam(n);this.accommodate(n/8);do{n-=8;this.data.setInt8(this.write++,i>>n&0xFF);}while(n>0);return this;};/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putSignedInt=function(i,n){_checkBitsParam(n);this.accommodate(n/8);if(i<0){i+=2<<n-1;}return this.putInt(i,n);};/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */util.DataBuffer.prototype.getByte=function(){return this.data.getInt8(this.read++);};/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.DataBuffer.prototype.getInt16=function(){var rval=this.data.getInt16(this.read);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.DataBuffer.prototype.getInt24=function(){var rval=this.data.getInt16(this.read)<<8^this.data.getInt8(this.read+2);this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.DataBuffer.prototype.getInt32=function(){var rval=this.data.getInt32(this.read);this.read+=4;return rval;};/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.DataBuffer.prototype.getInt16Le=function(){var rval=this.data.getInt16(this.read,true);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.DataBuffer.prototype.getInt24Le=function(){var rval=this.data.getInt8(this.read)^this.data.getInt16(this.read+1,true)<<8;this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.DataBuffer.prototype.getInt32Le=function(){var rval=this.data.getInt32(this.read,true);this.read+=4;return rval;};/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.DataBuffer.prototype.getInt=function(n){_checkBitsParam(n);var rval=0;do{// TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
rval=(rval<<8)+this.data.getInt8(this.read++);n-=8;}while(n>0);return rval;};/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.DataBuffer.prototype.getSignedInt=function(n){// getInt checks n
var x=this.getInt(n);var max=2<<n-2;if(x>=max){x-=max<<1;}return x;};/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */util.DataBuffer.prototype.getBytes=function(count){// TODO: deprecate this method, it is poorly named and
// this.toString('binary') replaces it
// add a toTypedArray()/toArrayBuffer() function
var rval;if(count){// read count bytes
count=Math.min(this.length(),count);rval=this.data.slice(this.read,this.read+count);this.read+=count;}else if(count===0){rval='';}else{// read all bytes, optimize to only copy when needed
rval=this.read===0?this.data:this.data.slice(this.read);this.clear();}return rval;};/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */util.DataBuffer.prototype.bytes=function(count){// TODO: deprecate this method, it is poorly named, add "getString()"
return typeof count==='undefined'?this.data.slice(this.read):this.data.slice(this.read,this.read+count);};/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */util.DataBuffer.prototype.at=function(i){return this.data.getUint8(this.read+i);};/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.setAt=function(i,b){this.data.setUint8(i,b);return this;};/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */util.DataBuffer.prototype.last=function(){return this.data.getUint8(this.write-1);};/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */util.DataBuffer.prototype.copy=function(){return new util.DataBuffer(this);};/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.compact=function(){if(this.read>0){var src=new Uint8Array(this.data.buffer,this.read);var dst=new Uint8Array(src.byteLength);dst.set(src);this.data=new DataView(dst);this.write-=this.read;this.read=0;}return this;};/**
 * Clears this buffer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.clear=function(){this.data=new DataView(new ArrayBuffer(0));this.read=this.write=0;return this;};/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.truncate=function(count){this.write=Math.max(0,this.length()-count);this.read=Math.min(this.read,this.write);return this;};/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */util.DataBuffer.prototype.toHex=function(){var rval='';for(var i=this.read;i<this.data.byteLength;++i){var b=this.data.getUint8(i);if(b<16){rval+='0';}rval+=b.toString(16);}return rval;};/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */util.DataBuffer.prototype.toString=function(encoding){var view=new Uint8Array(this.data,this.read,this.length());encoding=encoding||'utf8';// encode to string
if(encoding==='binary'||encoding==='raw'){return util.binary.raw.encode(view);}if(encoding==='hex'){return util.binary.hex.encode(view);}if(encoding==='base64'){return util.binary.base64.encode(view);}// decode to text
if(encoding==='utf8'){return util.text.utf8.decode(view);}if(encoding==='utf16'){return util.text.utf16.decode(view);}throw new Error('Invalid encoding: '+encoding);};/** End Buffer w/UInt8Array backing */ /**
 * Creates a buffer that stores bytes. A value may be given to put into the
 * buffer that is either a string of bytes or a UTF-16 string that will
 * be encoded using UTF-8 (to do the latter, specify 'utf8' as the encoding).
 *
 * @param [input] the bytes to wrap (as a string) or a UTF-16 string to encode
 *          as UTF-8.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */util.createBuffer=function(input,encoding){// TODO: deprecate, use new ByteBuffer() instead
encoding=encoding||'raw';if(input!==undefined&&encoding==='utf8'){input=util.encodeUtf8(input);}return new util.ByteBuffer(input);};/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */util.fillString=function(c,n){var s='';while(n>0){if(n&1){s+=c;}n>>>=1;if(n>0){c+=c;}}return s;};/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */util.xorBytes=function(s1,s2,n){var s3='';var b='';var t='';var i=0;var c=0;for(;n>0;--n,++i){b=s1.charCodeAt(i)^s2.charCodeAt(i);if(c>=10){s3+=t;t='';c=0;}t+=String.fromCharCode(b);++c;}s3+=t;return s3;};/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */util.hexToBytes=function(hex){// TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
var rval='';var i=0;if(hex.length&1==1){// odd number of characters, convert first character alone
i=1;rval+=String.fromCharCode(parseInt(hex[0],16));}// convert 2 characters (1 byte) at a time
for(;i<hex.length;i+=2){rval+=String.fromCharCode(parseInt(hex.substr(i,2),16));}return rval;};/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */util.bytesToHex=function(bytes){// TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
return util.createBuffer(bytes).toHex();};/**
 * Converts an 32-bit integer to 4-big-endian byte string.
 *
 * @param i the integer.
 *
 * @return the byte string.
 */util.int32ToBytes=function(i){return String.fromCharCode(i>>24&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF);};// base64 characters, reverse mapping
var _base64='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';var _base64Idx=[/*43 -43 = 0*/ /*'+',  1,  2,  3,'/' */62,-1,-1,-1,63,/*'0','1','2','3','4','5','6','7','8','9' */52,53,54,55,56,57,58,59,60,61,/*15, 16, 17,'=', 19, 20, 21 */-1,-1,-1,64,-1,-1,-1,/*65 - 43 = 22*/ /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */0,1,2,3,4,5,6,7,8,9,10,11,12,/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */13,14,15,16,17,18,19,20,21,22,23,24,25,/*91 - 43 = 48 */ /*48, 49, 50, 51, 52, 53 */-1,-1,-1,-1,-1,-1,/*97 - 43 = 54*/ /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */26,27,28,29,30,31,32,33,34,35,36,37,38,/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */39,40,41,42,43,44,45,46,47,48,49,50,51];// base58 characters (Bitcoin alphabet)
var _base58='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';/**
 * Base64 encodes a 'binary' encoded string of bytes.
 *
 * @param input the binary encoded string of bytes to base64-encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output.
 */util.encode64=function(input,maxline){// TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
var line='';var output='';var chr1,chr2,chr3;var i=0;while(i<input.length){chr1=input.charCodeAt(i++);chr2=input.charCodeAt(i++);chr3=input.charCodeAt(i++);// encode 4 character group
line+=_base64.charAt(chr1>>2);line+=_base64.charAt((chr1&3)<<4|chr2>>4);if(isNaN(chr2)){line+='==';}else{line+=_base64.charAt((chr2&15)<<2|chr3>>6);line+=isNaN(chr3)?'=':_base64.charAt(chr3&63);}if(maxline&&line.length>maxline){output+=line.substr(0,maxline)+'\r\n';line=line.substr(maxline);}}output+=line;return output;};/**
 * Base64 decodes a string into a 'binary' encoded string of bytes.
 *
 * @param input the base64-encoded input.
 *
 * @return the binary encoded string.
 */util.decode64=function(input){// TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."
// remove all non-base64 characters
input=input.replace(/[^A-Za-z0-9\+\/\=]/g,'');var output='';var enc1,enc2,enc3,enc4;var i=0;while(i<input.length){enc1=_base64Idx[input.charCodeAt(i++)-43];enc2=_base64Idx[input.charCodeAt(i++)-43];enc3=_base64Idx[input.charCodeAt(i++)-43];enc4=_base64Idx[input.charCodeAt(i++)-43];output+=String.fromCharCode(enc1<<2|enc2>>4);if(enc3!==64){// decoded at least 2 bytes
output+=String.fromCharCode((enc2&15)<<4|enc3>>2);if(enc4!==64){// decoded 3 bytes
output+=String.fromCharCode((enc3&3)<<6|enc4);}}}return output;};/**
 * UTF-8 encodes the given UTF-16 encoded string (a standard JavaScript
 * string). Non-ASCII characters will be encoded as multiple bytes according
 * to UTF-8.
 *
 * @param str the string to encode.
 *
 * @return the UTF-8 encoded string.
 */util.encodeUtf8=function(str){return unescape(encodeURIComponent(str));};/**
 * Decodes a UTF-8 encoded string into a UTF-16 string.
 *
 * @param str the string to decode.
 *
 * @return the UTF-16 encoded string (standard JavaScript string).
 */util.decodeUtf8=function(str){return decodeURIComponent(escape(str));};// binary encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.binary={raw:{},hex:{},base64:{},base58:{},baseN:{encode:baseN.encode,decode:baseN.decode}};/**
 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param bytes the Uint8Array to encode.
 *
 * @return the binary-encoded string.
 */util.binary.raw.encode=function(bytes){return String.fromCharCode.apply(null,bytes);};/**
 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param str the binary-encoded string to decode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.raw.decode=function(str,output,offset){var out=output;if(!out){out=new Uint8Array(str.length);}offset=offset||0;var j=offset;for(var i=0;i<str.length;++i){out[j++]=str.charCodeAt(i);}return output?j-offset:out;};/**
 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
 * ByteBuffer as a string of hexadecimal characters.
 *
 * @param bytes the bytes to convert.
 *
 * @return the string of hexadecimal characters.
 */util.binary.hex.encode=util.bytesToHex;/**
 * Decodes a hex-encoded string to a Uint8Array.
 *
 * @param hex the hexadecimal string to convert.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.hex.decode=function(hex,output,offset){var out=output;if(!out){out=new Uint8Array(Math.ceil(hex.length/2));}offset=offset||0;var i=0,j=offset;if(hex.length&1){// odd number of characters, convert first character alone
i=1;out[j++]=parseInt(hex[0],16);}// convert 2 characters (1 byte) at a time
for(;i<hex.length;i+=2){out[j++]=parseInt(hex.substr(i,2),16);}return output?j-offset:out;};/**
 * Base64-encodes a Uint8Array.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output string.
 */util.binary.base64.encode=function(input,maxline){var line='';var output='';var chr1,chr2,chr3;var i=0;while(i<input.byteLength){chr1=input[i++];chr2=input[i++];chr3=input[i++];// encode 4 character group
line+=_base64.charAt(chr1>>2);line+=_base64.charAt((chr1&3)<<4|chr2>>4);if(isNaN(chr2)){line+='==';}else{line+=_base64.charAt((chr2&15)<<2|chr3>>6);line+=isNaN(chr3)?'=':_base64.charAt(chr3&63);}if(maxline&&line.length>maxline){output+=line.substr(0,maxline)+'\r\n';line=line.substr(maxline);}}output+=line;return output;};/**
 * Decodes a base64-encoded string to a Uint8Array.
 *
 * @param input the base64-encoded input string.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.base64.decode=function(input,output,offset){var out=output;if(!out){out=new Uint8Array(Math.ceil(input.length/4)*3);}// remove all non-base64 characters
input=input.replace(/[^A-Za-z0-9\+\/\=]/g,'');offset=offset||0;var enc1,enc2,enc3,enc4;var i=0,j=offset;while(i<input.length){enc1=_base64Idx[input.charCodeAt(i++)-43];enc2=_base64Idx[input.charCodeAt(i++)-43];enc3=_base64Idx[input.charCodeAt(i++)-43];enc4=_base64Idx[input.charCodeAt(i++)-43];out[j++]=enc1<<2|enc2>>4;if(enc3!==64){// decoded at least 2 bytes
out[j++]=(enc2&15)<<4|enc3>>2;if(enc4!==64){// decoded 3 bytes
out[j++]=(enc3&3)<<6|enc4;}}}// make sure result is the exact decoded length
return output?j-offset:out.subarray(0,j);};// add support for base58 encoding/decoding with Bitcoin alphabet
util.binary.base58.encode=function(input,maxline){return util.binary.baseN.encode(input,_base58,maxline);};util.binary.base58.decode=function(input,maxline){return util.binary.baseN.decode(input,_base58,maxline);};// text encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.text={utf8:{},utf16:{}};/**
 * Encodes the given string as UTF-8 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.text.utf8.encode=function(str,output,offset){str=util.encodeUtf8(str);var out=output;if(!out){out=new Uint8Array(str.length);}offset=offset||0;var j=offset;for(var i=0;i<str.length;++i){out[j++]=str.charCodeAt(i);}return output?j-offset:out;};/**
 * Decodes the UTF-8 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */util.text.utf8.decode=function(bytes){return util.decodeUtf8(String.fromCharCode.apply(null,bytes));};/**
 * Encodes the given string as UTF-16 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.text.utf16.encode=function(str,output,offset){var out=output;if(!out){out=new Uint8Array(str.length*2);}var view=new Uint16Array(out.buffer);offset=offset||0;var j=offset;var k=offset;for(var i=0;i<str.length;++i){view[k++]=str.charCodeAt(i);j+=2;}return output?j-offset:out;};/**
 * Decodes the UTF-16 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */util.text.utf16.decode=function(bytes){return String.fromCharCode.apply(null,new Uint16Array(bytes.buffer));};/**
 * Deflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true to return only raw deflate data, false to include zlib
 *          header and trailer.
 *
 * @return the deflated data as a string.
 */util.deflate=function(api,bytes,raw){bytes=util.decode64(api.deflate(util.encode64(bytes)).rval);// strip zlib header and trailer if necessary
if(raw){// zlib header is 2 bytes (CMF,FLG) where FLG indicates that
// there is a 4-byte DICT (alder-32) block before the data if
// its 5th bit is set
var start=2;var flg=bytes.charCodeAt(1);if(flg&0x20){start=6;}// zlib trailer is 4 bytes of adler-32
bytes=bytes.substring(start,bytes.length-4);}return bytes;};/**
 * Inflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true if the incoming data has no zlib header or trailer and is
 *          raw DEFLATE data.
 *
 * @return the inflated data as a string, null on error.
 */util.inflate=function(api,bytes,raw){// TODO: add zlib header and trailer if necessary/possible
var rval=api.inflate(util.encode64(bytes)).rval;return rval===null?null:util.decode64(rval);};/**
 * Sets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param obj the storage object, null to remove.
 */var _setStorageObject=function _setStorageObject(api,id,obj){if(!api){throw new Error('WebStorage not available.');}var rval;if(obj===null){rval=api.removeItem(id);}else{// json-encode and base64-encode object
obj=util.encode64(JSON.stringify(obj));rval=api.setItem(id,obj);}// handle potential flash error
if(typeof rval!=='undefined'&&rval.rval!==true){var error=new Error(rval.error.message);error.id=rval.error.id;error.name=rval.error.name;throw error;}};/**
 * Gets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 *
 * @return the storage object entry or null if none exists.
 */var _getStorageObject=function _getStorageObject(api,id){if(!api){throw new Error('WebStorage not available.');}// get the existing entry
var rval=api.getItem(id);/* Note: We check api.init because we can't do (api == localStorage)
    on IE because of "Class doesn't support Automation" exception. Only
    the flash api has an init method so this works too, but we need a
    better solution in the future. */ // flash returns item wrapped in an object, handle special case
if(api.init){if(rval.rval===null){if(rval.error){var error=new Error(rval.error.message);error.id=rval.error.id;error.name=rval.error.name;throw error;}// no error, but also no item
rval=null;}else{rval=rval.rval;}}// handle decoding
if(rval!==null){// base64-decode and json-decode data
rval=JSON.parse(util.decode64(rval));}return rval;};/**
 * Stores an item in local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 */var _setItem=function _setItem(api,id,key,data){// get storage object
var obj=_getStorageObject(api,id);if(obj===null){// create a new storage object
obj={};}// update key
obj[key]=data;// set storage object
_setStorageObject(api,id,obj);};/**
 * Gets an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 *
 * @return the item.
 */var _getItem=function _getItem(api,id,key){// get storage object
var rval=_getStorageObject(api,id);if(rval!==null){// return data at key
rval=key in rval?rval[key]:null;}return rval;};/**
 * Removes an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 */var _removeItem=function _removeItem(api,id,key){// get storage object
var obj=_getStorageObject(api,id);if(obj!==null&&key in obj){// remove key
delete obj[key];// see if entry has no keys remaining
var empty=true;for(var prop in obj){empty=false;break;}if(empty){// remove entry entirely if no keys are left
obj=null;}// set storage object
_setStorageObject(api,id,obj);}};/**
 * Clears the local disk storage identified by the given ID.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 */var _clearItems=function _clearItems(api,id){_setStorageObject(api,id,null);};/**
 * Calls a storage function.
 *
 * @param func the function to call.
 * @param args the arguments for the function.
 * @param location the location argument.
 *
 * @return the return value from the function.
 */var _callStorageFunction=function _callStorageFunction(func,args,location){var rval=null;// default storage types
if(typeof location==='undefined'){location=['web','flash'];}// apply storage types in order of preference
var type;var done=false;var exception=null;for(var idx in location){type=location[idx];try{if(type==='flash'||type==='both'){if(args[0]===null){throw new Error('Flash local storage not available.');}rval=func.apply(this,args);done=type==='flash';}if(type==='web'||type==='both'){args[0]=localStorage;rval=func.apply(this,args);done=true;}}catch(ex){exception=ex;}if(done){break;}}if(!done){throw exception;}return rval;};/**
 * Stores an item on local disk.
 *
 * The available types of local storage include 'flash', 'web', and 'both'.
 *
 * The type 'flash' refers to flash local storage (SharedObject). In order
 * to use flash local storage, the 'api' parameter must be valid. The type
 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
 * refers to storing using both 'flash' and 'web', not just one or the
 * other.
 *
 * The location array should list the storage types to use in order of
 * preference:
 *
 * ['flash']: flash only storage
 * ['web']: web only storage
 * ['both']: try to store in both
 * ['flash','web']: store in flash first, but if not available, 'web'
 * ['web','flash']: store in web first, but if not available, 'flash'
 *
 * The location array defaults to: ['web', 'flash']
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 * @param location an array with the preferred types of storage to use.
 */util.setItem=function(api,id,key,data,location){_callStorageFunction(_setItem,arguments,location);};/**
 * Gets an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 *
 * @return the item.
 */util.getItem=function(api,id,key,location){return _callStorageFunction(_getItem,arguments,location);};/**
 * Removes an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 */util.removeItem=function(api,id,key,location){_callStorageFunction(_removeItem,arguments,location);};/**
 * Clears the local disk storage identified by the given ID.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface if flash is available.
 * @param id the storage ID to use.
 * @param location an array with the preferred types of storage to use.
 */util.clearItems=function(api,id,location){_callStorageFunction(_clearItems,arguments,location);};/**
 * Parses the scheme, host, and port from an http(s) url.
 *
 * @param str the url string.
 *
 * @return the parsed url object or null if the url is invalid.
 */util.parseUrl=function(str){// FIXME: this regex looks a bit broken
var regex=/^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;regex.lastIndex=0;var m=regex.exec(str);var url=m===null?null:{full:str,scheme:m[1],host:m[2],port:m[3],path:m[4]};if(url){url.fullHost=url.host;if(url.port){if(url.port!==80&&url.scheme==='http'){url.fullHost+=':'+url.port;}else if(url.port!==443&&url.scheme==='https'){url.fullHost+=':'+url.port;}}else if(url.scheme==='http'){url.port=80;}else if(url.scheme==='https'){url.port=443;}url.full=url.scheme+'://'+url.fullHost;}return url;};/* Storage for query variables */var _queryVariables=null;/**
 * Returns the window location query variables. Query is parsed on the first
 * call and the same object is returned on subsequent calls. The mapping
 * is from keys to an array of values. Parameters without values will have
 * an object key set but no value added to the value array. Values are
 * unescaped.
 *
 * ...?k1=v1&k2=v2:
 * {
 *   "k1": ["v1"],
 *   "k2": ["v2"]
 * }
 *
 * ...?k1=v1&k1=v2:
 * {
 *   "k1": ["v1", "v2"]
 * }
 *
 * ...?k1=v1&k2:
 * {
 *   "k1": ["v1"],
 *   "k2": []
 * }
 *
 * ...?k1=v1&k1:
 * {
 *   "k1": ["v1"]
 * }
 *
 * ...?k1&k1:
 * {
 *   "k1": []
 * }
 *
 * @param query the query string to parse (optional, default to cached
 *          results from parsing window location search query).
 *
 * @return object mapping keys to variables.
 */util.getQueryVariables=function(query){var parse=function parse(q){var rval={};var kvpairs=q.split('&');for(var i=0;i<kvpairs.length;i++){var pos=kvpairs[i].indexOf('=');var key;var val;if(pos>0){key=kvpairs[i].substring(0,pos);val=kvpairs[i].substring(pos+1);}else{key=kvpairs[i];val=null;}if(!(key in rval)){rval[key]=[];}// disallow overriding object prototype keys
if(!(key in Object.prototype)&&val!==null){rval[key].push(unescape(val));}}return rval;};var rval;if(typeof query==='undefined'){// set cached variables if needed
if(_queryVariables===null){if(typeof window!=='undefined'&&window.location&&window.location.search){// parse window search query
_queryVariables=parse(window.location.search.substring(1));}else{// no query variables available
_queryVariables={};}}rval=_queryVariables;}else{// parse given query
rval=parse(query);}return rval;};/**
 * Parses a fragment into a path and query. This method will take a URI
 * fragment and break it up as if it were the main URI. For example:
 *    /bar/baz?a=1&b=2
 * results in:
 *    {
 *       path: ["bar", "baz"],
 *       query: {"k1": ["v1"], "k2": ["v2"]}
 *    }
 *
 * @return object with a path array and query object.
 */util.parseFragment=function(fragment){// default to whole fragment
var fp=fragment;var fq='';// split into path and query if possible at the first '?'
var pos=fragment.indexOf('?');if(pos>0){fp=fragment.substring(0,pos);fq=fragment.substring(pos+1);}// split path based on '/' and ignore first element if empty
var path=fp.split('/');if(path.length>0&&path[0]===''){path.shift();}// convert query into object
var query=fq===''?{}:util.getQueryVariables(fq);return{pathString:fp,queryString:fq,path:path,query:query};};/**
 * Makes a request out of a URI-like request string. This is intended to
 * be used where a fragment id (after a URI '#') is parsed as a URI with
 * path and query parts. The string should have a path beginning and
 * delimited by '/' and optional query parameters following a '?'. The
 * query should be a standard URL set of key value pairs delimited by
 * '&'. For backwards compatibility the initial '/' on the path is not
 * required. The request object has the following API, (fully described
 * in the method code):
 *    {
 *       path: <the path string part>.
 *       query: <the query string part>,
 *       getPath(i): get part or all of the split path array,
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */util.makeRequest=function(reqString){var frag=util.parseFragment(reqString);var req={// full path string
path:frag.pathString,// full query string
query:frag.queryString,/**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */getPath:function getPath(i){return typeof i==='undefined'?frag.path:frag.path[i];},/**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */getQuery:function getQuery(k,i){var rval;if(typeof k==='undefined'){rval=frag.query;}else{rval=frag.query[k];if(rval&&typeof i!=='undefined'){rval=rval[i];}}return rval;},getQueryLast:function getQueryLast(k,_default){var rval;var vals=req.getQuery(k);if(vals){rval=vals[vals.length-1];}else{rval=_default;}return rval;}};return req;};/**
 * Makes a URI out of a path, an object with query parameters, and a
 * fragment. Uses jQuery.param() internally for query string creation.
 * If the path is an array, it will be joined with '/'.
 *
 * @param path string path or array of strings.
 * @param query object with query parameters. (optional)
 * @param fragment fragment string. (optional)
 *
 * @return string object with request parameters.
 */util.makeLink=function(path,query,fragment){// join path parts if needed
path=jQuery.isArray(path)?path.join('/'):path;var qstr=jQuery.param(query||{});fragment=fragment||'';return path+(qstr.length>0?'?'+qstr:'')+(fragment.length>0?'#'+fragment:'');};/**
 * Follows a path of keys deep into an object hierarchy and set a value.
 * If a key does not exist or it's value is not an object, create an
 * object in it's place. This can be destructive to a object tree if
 * leaf nodes are given as non-final path keys.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param value the value to set.
 */util.setPath=function(object,keys,value){// need to start at an object
if(_typeof(object)==='object'&&object!==null){var i=0;var len=keys.length;while(i<len){var next=keys[i++];if(i==len){// last
object[next]=value;}else{// more
var hasNext=next in object;if(!hasNext||hasNext&&_typeof(object[next])!=='object'||hasNext&&object[next]===null){object[next]={};}object=object[next];}}}};/**
 * Follows a path of keys deep into an object hierarchy and return a value.
 * If a key does not exist, create an object in it's place.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param _default value to return if path not found.
 *
 * @return the value at the path if found, else default if given, else
 *         undefined.
 */util.getPath=function(object,keys,_default){var i=0;var len=keys.length;var hasNext=true;while(hasNext&&i<len&&_typeof(object)==='object'&&object!==null){var next=keys[i++];hasNext=next in object;if(hasNext){object=object[next];}}return hasNext?object:_default;};/**
 * Follow a path of keys deep into an object hierarchy and delete the
 * last one. If a key does not exist, do nothing.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 */util.deletePath=function(object,keys){// need to start at an object
if(_typeof(object)==='object'&&object!==null){var i=0;var len=keys.length;while(i<len){var next=keys[i++];if(i==len){// last
delete object[next];}else{// more
if(!(next in object)||_typeof(object[next])!=='object'||object[next]===null){break;}object=object[next];}}}};/**
 * Check if an object is empty.
 *
 * Taken from:
 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
 *
 * @param object the object to check.
 */util.isEmpty=function(obj){for(var prop in obj){if(obj.hasOwnProperty(prop)){return false;}}return true;};/**
 * Format with simple printf-style interpolation.
 *
 * %%: literal '%'
 * %s,%o: convert next argument into a string.
 *
 * @param format the string to format.
 * @param ... arguments to interpolate into the format string.
 */util.format=function(format){var re=/%./g;// current match
var match;// current part
var part;// current arg index
var argi=0;// collected parts to recombine later
var parts=[];// last index found
var last=0;// loop while matches remain
while(match=re.exec(format)){part=format.substring(last,re.lastIndex-2);// don't add empty strings (ie, parts between %s%s)
if(part.length>0){parts.push(part);}last=re.lastIndex;// switch on % code
var code=match[0][1];switch(code){case's':case'o':// check if enough arguments were given
if(argi<arguments.length){parts.push(arguments[argi++ +1]);}else{parts.push('<?>');}break;// FIXME: do proper formating for numbers, etc
//case 'f':
//case 'd':
case'%':parts.push('%');break;default:parts.push('<%'+code+'?>');}}// add trailing part of format string
parts.push(format.substring(last));return parts.join('');};/**
 * Formats a number.
 *
 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
 */util.formatNumber=function(number,decimals,dec_point,thousands_sep){// http://kevin.vanzonneveld.net
// +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +     bugfix by: Michael White (http://crestidg.com)
// +     bugfix by: Benjamin Lupton
// +     bugfix by: Allan Jensen (http://www.winternet.no)
// +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
// *     example 1: number_format(1234.5678, 2, '.', '');
// *     returns 1: 1234.57
var n=number,c=isNaN(decimals=Math.abs(decimals))?2:decimals;var d=dec_point===undefined?',':dec_point;var t=thousands_sep===undefined?'.':thousands_sep,s=n<0?'-':'';var i=parseInt(n=Math.abs(+n||0).toFixed(c),10)+'';var j=i.length>3?i.length%3:0;return s+(j?i.substr(0,j)+t:'')+i.substr(j).replace(/(\d{3})(?=\d)/g,'$1'+t)+(c?d+Math.abs(n-i).toFixed(c).slice(2):'');};/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */util.formatSize=function(size){if(size>=1073741824){size=util.formatNumber(size/1073741824,2,'.','')+' GiB';}else if(size>=1048576){size=util.formatNumber(size/1048576,2,'.','')+' MiB';}else if(size>=1024){size=util.formatNumber(size/1024,0)+' KiB';}else{size=util.formatNumber(size,0)+' bytes';}return size;};/**
 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */util.bytesFromIP=function(ip){if(ip.indexOf('.')!==-1){return util.bytesFromIPv4(ip);}if(ip.indexOf(':')!==-1){return util.bytesFromIPv6(ip);}return null;};/**
 * Converts an IPv4 string representation into bytes (in network order).
 *
 * @param ip the IPv4 address to convert.
 *
 * @return the 4-byte address or null if the address can't be parsed.
 */util.bytesFromIPv4=function(ip){ip=ip.split('.');if(ip.length!==4){return null;}var b=util.createBuffer();for(var i=0;i<ip.length;++i){var num=parseInt(ip[i],10);if(isNaN(num)){return null;}b.putByte(num);}return b.getBytes();};/**
 * Converts an IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv6 address to convert.
 *
 * @return the 16-byte address or null if the address can't be parsed.
 */util.bytesFromIPv6=function(ip){var blanks=0;ip=ip.split(':').filter(function(e){if(e.length===0)++blanks;return true;});var zeros=(8-ip.length+blanks)*2;var b=util.createBuffer();for(var i=0;i<8;++i){if(!ip[i]||ip[i].length===0){b.fillWithByte(0,zeros);zeros=0;continue;}var bytes=util.hexToBytes(ip[i]);if(bytes.length<2){b.putByte(0);}b.putBytes(bytes);}return b.getBytes();};/**
 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
 * an IPv6 string representation. The bytes must be in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */util.bytesToIP=function(bytes){if(bytes.length===4){return util.bytesToIPv4(bytes);}if(bytes.length===16){return util.bytesToIPv6(bytes);}return null;};/**
 * Converts 4-bytes into an IPv4 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 string representation or null for an invalid # of bytes.
 */util.bytesToIPv4=function(bytes){if(bytes.length!==4){return null;}var ip=[];for(var i=0;i<bytes.length;++i){ip.push(bytes.charCodeAt(i));}return ip.join('.');};/**
 * Converts 16-bytes into an IPv16 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv16 string representation or null for an invalid # of bytes.
 */util.bytesToIPv6=function(bytes){if(bytes.length!==16){return null;}var ip=[];var zeroGroups=[];var zeroMaxGroup=0;for(var i=0;i<bytes.length;i+=2){var hex=util.bytesToHex(bytes[i]+bytes[i+1]);// canonicalize zero representation
while(hex[0]==='0'&&hex!=='0'){hex=hex.substr(1);}if(hex==='0'){var last=zeroGroups[zeroGroups.length-1];var idx=ip.length;if(!last||idx!==last.end+1){zeroGroups.push({start:idx,end:idx});}else{last.end=idx;if(last.end-last.start>zeroGroups[zeroMaxGroup].end-zeroGroups[zeroMaxGroup].start){zeroMaxGroup=zeroGroups.length-1;}}}ip.push(hex);}if(zeroGroups.length>0){var group=zeroGroups[zeroMaxGroup];// only shorten group of length > 0
if(group.end-group.start>0){ip.splice(group.start,group.end-group.start+1,'');if(group.start===0){ip.unshift('');}if(group.end===7){ip.push('');}}}return ip.join(':');};/**
 * Estimates the number of processes that can be run concurrently. If
 * creating Web Workers, keep in mind that the main JavaScript process needs
 * its own core.
 *
 * @param options the options to use:
 *          update true to force an update (not use the cached value).
 * @param callback(err, max) called once the operation completes.
 */util.estimateCores=function(options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};if('cores'in util&&!options.update){return callback(null,util.cores);}if(typeof navigator!=='undefined'&&'hardwareConcurrency'in navigator&&navigator.hardwareConcurrency>0){util.cores=navigator.hardwareConcurrency;return callback(null,util.cores);}if(typeof Worker==='undefined'){// workers not available
util.cores=1;return callback(null,util.cores);}if(typeof Blob==='undefined'){// can't estimate, default to 2
util.cores=2;return callback(null,util.cores);}// create worker concurrency estimation code as blob
var blobUrl=URL.createObjectURL(new Blob(['(',function(){self.addEventListener('message',function(e){// run worker for 4 ms
var st=Date.now();var et=st+4;while(Date.now()<et){;}self.postMessage({st:st,et:et});});}.toString(),')()'],{type:'application/javascript'}));// take 5 samples using 16 workers
sample([],5,16);function sample(max,samples,numWorkers){if(samples===0){// get overlap average
var avg=Math.floor(max.reduce(function(avg,x){return avg+x;},0)/max.length);util.cores=Math.max(1,avg);URL.revokeObjectURL(blobUrl);return callback(null,util.cores);}map(numWorkers,function(err,results){max.push(reduce(numWorkers,results));sample(max,samples-1,numWorkers);});}function map(numWorkers,callback){var workers=[];var results=[];for(var i=0;i<numWorkers;++i){var worker=new Worker(blobUrl);worker.addEventListener('message',function(e){results.push(e.data);if(results.length===numWorkers){for(var i=0;i<numWorkers;++i){workers[i].terminate();}callback(null,results);}});workers.push(worker);}for(var i=0;i<numWorkers;++i){workers[i].postMessage(i);}}function reduce(numWorkers,results){// find overlapping time windows
var overlaps=[];for(var n=0;n<numWorkers;++n){var r1=results[n];var overlap=overlaps[n]=[];for(var i=0;i<numWorkers;++i){if(n===i){continue;}var r2=results[i];if(r1.st>r2.st&&r1.st<r2.et||r2.st>r1.st&&r2.st<r1.et){overlap.push(i);}}}// get maximum overlaps ... don't include overlapping worker itself
// as the main JS process was also being scheduled during the work and
// would have to be subtracted from the estimate anyway
return overlaps.reduce(function(max,overlap){return Math.max(max,overlap.length);},0);}};/***/},/* 2 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of Abstract Syntax Notation Number One.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 *
 * An API for storing data using the Abstract Syntax Notation Number One
 * format using DER (Distinguished Encoding Rules) encoding. This encoding is
 * commonly used to store data for PKI, i.e. X.509 Certificates, and this
 * implementation exists for that purpose.
 *
 * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract
 * syntax of information without restricting the way the information is encoded
 * for transmission. It provides a standard that allows for open systems
 * communication. ASN.1 defines the syntax of information data and a number of
 * simple data types as well as a notation for describing them and specifying
 * values for them.
 *
 * The RSA algorithm creates public and private keys that are often stored in
 * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This
 * class provides the most basic functionality required to store and load DSA
 * keys that are encoded according to ASN.1.
 *
 * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)
 * and DER (Distinguished Encoding Rules). DER is just a subset of BER that
 * has stricter requirements for how data must be encoded.
 *
 * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)
 * and a byte array for the value of this ASN1 structure which may be data or a
 * list of ASN.1 structures.
 *
 * Each ASN.1 structure using BER is (Tag-Length-Value):
 *
 * | byte 0 | bytes X | bytes Y |
 * |--------|---------|----------
 * |  tag   | length  |  value  |
 *
 * ASN.1 allows for tags to be of "High-tag-number form" which allows a tag to
 * be two or more octets, but that is not supported by this class. A tag is
 * only 1 byte. Bits 1-5 give the tag number (ie the data type within a
 * particular 'class'), 6 indicates whether or not the ASN.1 value is
 * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If
 * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,
 * then the class is APPLICATION. If only bit 8 is set, then the class is
 * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.
 * The tag numbers for the data types for the class UNIVERSAL are listed below:
 *
 * UNIVERSAL 0 Reserved for use by the encoding rules
 * UNIVERSAL 1 Boolean type
 * UNIVERSAL 2 Integer type
 * UNIVERSAL 3 Bitstring type
 * UNIVERSAL 4 Octetstring type
 * UNIVERSAL 5 Null type
 * UNIVERSAL 6 Object identifier type
 * UNIVERSAL 7 Object descriptor type
 * UNIVERSAL 8 External type and Instance-of type
 * UNIVERSAL 9 Real type
 * UNIVERSAL 10 Enumerated type
 * UNIVERSAL 11 Embedded-pdv type
 * UNIVERSAL 12 UTF8String type
 * UNIVERSAL 13 Relative object identifier type
 * UNIVERSAL 14-15 Reserved for future editions
 * UNIVERSAL 16 Sequence and Sequence-of types
 * UNIVERSAL 17 Set and Set-of types
 * UNIVERSAL 18-22, 25-30 Character string types
 * UNIVERSAL 23-24 Time types
 *
 * The length of an ASN.1 structure is specified after the tag identifier.
 * There is a definite form and an indefinite form. The indefinite form may
 * be used if the encoding is constructed and not all immediately available.
 * The indefinite form is encoded using a length byte with only the 8th bit
 * set. The end of the constructed object is marked using end-of-contents
 * octets (two zero bytes).
 *
 * The definite form looks like this:
 *
 * The length may take up 1 or more bytes, it depends on the length of the
 * value of the ASN.1 structure. DER encoding requires that if the ASN.1
 * structure has a value that has a length greater than 127, more than 1 byte
 * will be used to store its length, otherwise just one byte will be used.
 * This is strict.
 *
 * In the case that the length of the ASN.1 value is less than 127, 1 octet
 * (byte) is used to store the "short form" length. The 8th bit has a value of
 * 0 indicating the length is "short form" and not "long form" and bits 7-1
 * give the length of the data. (The 8th bit is the left-most, most significant
 * bit: also known as big endian or network format).
 *
 * In the case that the length of the ASN.1 value is greater than 127, 2 to
 * 127 octets (bytes) are used to store the "long form" length. The first
 * byte's 8th bit is set to 1 to indicate the length is "long form." Bits 7-1
 * give the number of additional octets. All following octets are in base 256
 * with the most significant digit first (typical big-endian binary unsigned
 * integer storage). So, for instance, if the length of a value was 257, the
 * first byte would be set to:
 *
 * 10000010 = 130 = 0x82.
 *
 * This indicates there are 2 octets (base 256) for the length. The second and
 * third bytes (the octets just mentioned) would store the length in base 256:
 *
 * octet 2: 00000001 = 1 * 256^1 = 256
 * octet 3: 00000001 = 1 * 256^0 = 1
 * total = 257
 *
 * The algorithm for converting a js integer value of 257 to base-256 is:
 *
 * var value = 257;
 * var bytes = [];
 * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first
 * bytes[1] = value & 0xFF;        // least significant byte last
 *
 * On the ASN.1 UNIVERSAL Object Identifier (OID) type:
 *
 * An OID can be written like: "value1.value2.value3...valueN"
 *
 * The DER encoding rules:
 *
 * The first byte has the value 40 * value1 + value2.
 * The following bytes, if any, encode the remaining values. Each value is
 * encoded in base 128, most significant digit first (big endian), with as
 * few digits as possible, and the most significant bit of each byte set
 * to 1 except the last in each value's encoding. For example: Given the
 * OID "1.2.840.113549", its DER encoding is (remember each byte except the
 * last one in each encoding is OR'd with 0x80):
 *
 * byte 1: 40 * 1 + 2 = 42 = 0x2A.
 * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648
 * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D
 *
 * The final value is: 0x2A864886F70D.
 * The full OID (including ASN.1 tag and length of 6 bytes) is:
 * 0x06062A864886F70D
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(3);/* ASN.1 API */var asn1=module.exports=forge.asn1=forge.asn1||{};/**
 * ASN.1 classes.
 */asn1.Class={UNIVERSAL:0x00,APPLICATION:0x40,CONTEXT_SPECIFIC:0x80,PRIVATE:0xC0};/**
 * ASN.1 types. Not all types are supported by this implementation, only
 * those necessary to implement a simple PKI are implemented.
 */asn1.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30};/**
 * Creates a new asn1 object.
 *
 * @param tagClass the tag class for the object.
 * @param type the data type (tag number) for the object.
 * @param constructed true if the asn1 object is in constructed form.
 * @param value the value for the object, if it is not constructed.
 * @param [options] the options to use:
 *          [bitStringContents] the plain BIT STRING content including padding
 *            byte.
 *
 * @return the asn1 object.
 */asn1.create=function(tagClass,type,constructed,value,options){/* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */ // remove undefined values
if(forge.util.isArray(value)){var tmp=[];for(var i=0;i<value.length;++i){if(value[i]!==undefined){tmp.push(value[i]);}}value=tmp;}var obj={tagClass:tagClass,type:type,constructed:constructed,composed:constructed||forge.util.isArray(value),value:value};if(options&&'bitStringContents'in options){// TODO: copy byte buffer if it's a buffer not a string
obj.bitStringContents=options.bitStringContents;// TODO: add readonly flag to avoid this overhead
// save copy to detect changes
obj.original=asn1.copy(obj);}return obj;};/**
 * Copies an asn1 object.
 *
 * @param obj the asn1 object.
 * @param [options] copy options:
 *          [excludeBitStringContents] true to not copy bitStringContents
 *
 * @return the a copy of the asn1 object.
 */asn1.copy=function(obj,options){var copy;if(forge.util.isArray(obj)){copy=[];for(var i=0;i<obj.length;++i){copy.push(asn1.copy(obj[i],options));}return copy;}if(typeof obj==='string'){// TODO: copy byte buffer if it's a buffer not a string
return obj;}copy={tagClass:obj.tagClass,type:obj.type,constructed:obj.constructed,composed:obj.composed,value:asn1.copy(obj.value,options)};if(options&&!options.excludeBitStringContents){// TODO: copy byte buffer if it's a buffer not a string
copy.bitStringContents=obj.bitStringContents;}return copy;};/**
 * Compares asn1 objects for equality.
 *
 * Note this function does not run in constant time.
 *
 * @param obj1 the first asn1 object.
 * @param obj2 the second asn1 object.
 * @param [options] compare options:
 *          [includeBitStringContents] true to compare bitStringContents
 *
 * @return true if the asn1 objects are equal.
 */asn1.equals=function(obj1,obj2,options){if(forge.util.isArray(obj1)){if(!forge.util.isArray(obj2)){return false;}if(obj1.length!==obj2.length){return false;}for(var i=0;i<obj1.length;++i){if(!asn1.equals(obj1[i],obj2[i])){return false;}}return true;}if(_typeof(obj1)!==_typeof(obj2)){return false;}if(typeof obj1==='string'){return obj1===obj2;}var equal=obj1.tagClass===obj2.tagClass&&obj1.type===obj2.type&&obj1.constructed===obj2.constructed&&obj1.composed===obj2.composed&&asn1.equals(obj1.value,obj2.value);if(options&&options.includeBitStringContents){equal=equal&&obj1.bitStringContents===obj2.bitStringContents;}return equal;};/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param b the BER-encoded ASN.1 byte buffer, starting with the first
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */asn1.getBerValueLength=function(b){// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
var b2=b.getByte();if(b2===0x80){return undefined;}// see if the length is "short form" or "long form" (bit 8 set)
var length;var longForm=b2&0x80;if(!longForm){// length is just the first byte
length=b2;}else{// the number of bytes the length is specified in bits 7 through 1
// and each length byte is in big-endian base-256
length=b.getInt((b2&0x7F)<<3);}return length;};/**
 * Check if the byte buffer has enough bytes. Throws an Error if not.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 * @param n the number of bytes the buffer must have.
 */function _checkBufferLength(bytes,remaining,n){if(n>remaining){var error=new Error('Too few bytes to parse DER.');error.available=bytes.length();error.remaining=remaining;error.requested=n;throw error;}}/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */var _getValueLength=function _getValueLength(bytes,remaining){// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
// fromDer already checked that this byte exists
var b2=bytes.getByte();remaining--;if(b2===0x80){return undefined;}// see if the length is "short form" or "long form" (bit 8 set)
var length;var longForm=b2&0x80;if(!longForm){// length is just the first byte
length=b2;}else{// the number of bytes the length is specified in bits 7 through 1
// and each length byte is in big-endian base-256
var longFormBytes=b2&0x7F;_checkBufferLength(bytes,remaining,longFormBytes);length=bytes.getInt(longFormBytes<<3);}// FIXME: this will only happen for 32 bit getInt with high bit set
if(length<0){throw new Error('Negative length: '+length);}return length;};/**
 * Parses an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param [strict] true to be strict when checking value lengths, false to
 *          allow truncated values (default: true).
 * @param [options] object with options or boolean strict flag
 *          [strict] true to be strict when checking value lengths, false to
 *            allow truncated values (default: true).
 *          [decodeBitStrings] true to attempt to decode the content of
 *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
 *            without schema support to understand the data context this can
 *            erroneously decode values that happen to be valid ASN.1. This
 *            flag will be deprecated or removed as soon as schema support is
 *            available. (default: true)
 *
 * @return the parsed asn1 object.
 */asn1.fromDer=function(bytes,options){if(options===undefined){options={strict:true,decodeBitStrings:true};}if(typeof options==='boolean'){options={strict:options,decodeBitStrings:true};}if(!('strict'in options)){options.strict=true;}if(!('decodeBitStrings'in options)){options.decodeBitStrings=true;}// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}return _fromDer(bytes,bytes.length(),0,options);};/**
 * Internal function to parse an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the number of bytes remaining for this chunk.
 * @param depth the current parsing depth.
 * @param options object with same options as fromDer().
 *
 * @return the parsed asn1 object.
 */function _fromDer(bytes,remaining,depth,options){// temporary storage for consumption calculations
var start;// minimum length for ASN.1 DER structure is 2
_checkBufferLength(bytes,remaining,2);// get the first byte
var b1=bytes.getByte();// consumed one byte
remaining--;// get the tag class
var tagClass=b1&0xC0;// get the type (bits 1-5)
var type=b1&0x1F;// get the variable value length and adjust remaining bytes
start=bytes.length();var length=_getValueLength(bytes,remaining);remaining-=start-bytes.length();// ensure there are enough bytes to get the value
if(length!==undefined&&length>remaining){if(options.strict){var error=new Error('Too few bytes to read ASN.1 value.');error.available=bytes.length();error.remaining=remaining;error.requested=length;throw error;}// Note: be lenient with truncated values and use remaining state bytes
length=remaining;}// value storage
var value;// possible BIT STRING contents storage
var bitStringContents;// constructed flag is bit 6 (32 = 0x20) of the first byte
var constructed=(b1&0x20)===0x20;if(constructed){// parse child asn1 objects from the value
value=[];if(length===undefined){// asn1 object of indefinite length, read until end tag
for(;;){_checkBufferLength(bytes,remaining,2);if(bytes.bytes(2)===String.fromCharCode(0,0)){bytes.getBytes(2);remaining-=2;break;}start=bytes.length();value.push(_fromDer(bytes,remaining,depth+1,options));remaining-=start-bytes.length();}}else{// parsing asn1 object of definite length
while(length>0){start=bytes.length();value.push(_fromDer(bytes,length,depth+1,options));remaining-=start-bytes.length();length-=start-bytes.length();}}}// if a BIT STRING, save the contents including padding
if(value===undefined&&tagClass===asn1.Class.UNIVERSAL&&type===asn1.Type.BITSTRING){bitStringContents=bytes.bytes(length);}// determine if a non-constructed value should be decoded as a composed
// value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)
// can be used this way.
if(value===undefined&&options.decodeBitStrings&&tagClass===asn1.Class.UNIVERSAL&&// FIXME: OCTET STRINGs not yet supported here
// .. other parts of forge expect to decode OCTET STRINGs manually
type===asn1.Type.BITSTRING/*|| type === asn1.Type.OCTETSTRING*/&&length>1){// save read position
var savedRead=bytes.read;var savedRemaining=remaining;var unused=0;if(type===asn1.Type.BITSTRING){/* The first octet gives the number of bits by which the length of the
        bit string is less than the next multiple of eight (this is called
        the "number of unused bits").

        The second and following octets give the value of the bit string
        converted to an octet string. */_checkBufferLength(bytes,remaining,1);unused=bytes.getByte();remaining--;}// if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs
if(unused===0){try{// attempt to parse child asn1 object from the value
// (stored in array to signal composed value)
start=bytes.length();var subOptions={// enforce strict mode to avoid parsing ASN.1 from plain data
verbose:options.verbose,strict:true,decodeBitStrings:true};var composed=_fromDer(bytes,remaining,depth+1,subOptions);var used=start-bytes.length();remaining-=used;if(type==asn1.Type.BITSTRING){used++;}// if the data all decoded and the class indicates UNIVERSAL or
// CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object
var tc=composed.tagClass;if(used===length&&(tc===asn1.Class.UNIVERSAL||tc===asn1.Class.CONTEXT_SPECIFIC)){value=[composed];}}catch(ex){}}if(value===undefined){// restore read position
bytes.read=savedRead;remaining=savedRemaining;}}if(value===undefined){// asn1 not constructed or composed, get raw value
// TODO: do DER to OID conversion and vice-versa in .toDer?
if(length===undefined){if(options.strict){throw new Error('Non-constructed ASN.1 object of indefinite length.');}// be lenient and use remaining state bytes
length=remaining;}if(type===asn1.Type.BMPSTRING){value='';for(;length>0;length-=2){_checkBufferLength(bytes,remaining,2);value+=String.fromCharCode(bytes.getInt16());remaining-=2;}}else{value=bytes.getBytes(length);}}// add BIT STRING contents if available
var asn1Options=bitStringContents===undefined?null:{bitStringContents:bitStringContents};// create and return asn1 object
return asn1.create(tagClass,type,constructed,value,asn1Options);}/**
 * Converts the given asn1 object to a buffer of bytes in DER format.
 *
 * @param asn1 the asn1 object to convert to bytes.
 *
 * @return the buffer of bytes.
 */asn1.toDer=function(obj){var bytes=forge.util.createBuffer();// build the first byte
var b1=obj.tagClass|obj.type;// for storing the ASN.1 value
var value=forge.util.createBuffer();// use BIT STRING contents if available and data not changed
var useBitStringContents=false;if('bitStringContents'in obj){useBitStringContents=true;if(obj.original){useBitStringContents=asn1.equals(obj,obj.original);}}if(useBitStringContents){value.putBytes(obj.bitStringContents);}else if(obj.composed){// if composed, use each child asn1 object's DER bytes as value
// turn on 6th bit (0x20 = 32) to indicate asn1 is constructed
// from other asn1 objects
if(obj.constructed){b1|=0x20;}else{// type is a bit string, add unused bits of 0x00
value.putByte(0x00);}// add all of the child DER bytes together
for(var i=0;i<obj.value.length;++i){if(obj.value[i]!==undefined){value.putBuffer(asn1.toDer(obj.value[i]));}}}else{// use asn1.value directly
if(obj.type===asn1.Type.BMPSTRING){for(var i=0;i<obj.value.length;++i){value.putInt16(obj.value.charCodeAt(i));}}else{// ensure integer is minimally-encoded
// TODO: should all leading bytes be stripped vs just one?
// .. ex '00 00 01' => '01'?
if(obj.type===asn1.Type.INTEGER&&obj.value.length>1&&(// leading 0x00 for positive integer
obj.value.charCodeAt(0)===0&&(obj.value.charCodeAt(1)&0x80)===0||// leading 0xFF for negative integer
obj.value.charCodeAt(0)===0xFF&&(obj.value.charCodeAt(1)&0x80)===0x80)){value.putBytes(obj.value.substr(1));}else{value.putBytes(obj.value);}}}// add tag byte
bytes.putByte(b1);// use "short form" encoding
if(value.length()<=127){// one byte describes the length
// bit 8 = 0 and bits 7-1 = length
bytes.putByte(value.length()&0x7F);}else{// use "long form" encoding
// 2 to 127 bytes describe the length
// first byte: bit 8 = 1 and bits 7-1 = # of additional bytes
// other bytes: length in base 256, big-endian
var len=value.length();var lenBytes='';do{lenBytes+=String.fromCharCode(len&0xFF);len=len>>>8;}while(len>0);// set first byte to # bytes used to store the length and turn on
// bit 8 to indicate long-form length is used
bytes.putByte(lenBytes.length|0x80);// concatenate length bytes in reverse since they were generated
// little endian and we need big endian
for(var i=lenBytes.length-1;i>=0;--i){bytes.putByte(lenBytes.charCodeAt(i));}}// concatenate value bytes
bytes.putBuffer(value);return bytes;};/**
 * Converts an OID dot-separated string to a byte buffer. The byte buffer
 * contains only the DER-encoded value, not any tag or length bytes.
 *
 * @param oid the OID dot-separated string.
 *
 * @return the byte buffer.
 */asn1.oidToDer=function(oid){// split OID into individual values
var values=oid.split('.');var bytes=forge.util.createBuffer();// first byte is 40 * value1 + value2
bytes.putByte(40*parseInt(values[0],10)+parseInt(values[1],10));// other bytes are each value in base 128 with 8th bit set except for
// the last byte for each value
var last,valueBytes,value,b;for(var i=2;i<values.length;++i){// produce value bytes in reverse because we don't know how many
// bytes it will take to store the value
last=true;valueBytes=[];value=parseInt(values[i],10);do{b=value&0x7F;value=value>>>7;// if value is not last, then turn on 8th bit
if(!last){b|=0x80;}valueBytes.push(b);last=false;}while(value>0);// add value bytes in reverse (needs to be in big endian)
for(var n=valueBytes.length-1;n>=0;--n){bytes.putByte(valueBytes[n]);}}return bytes;};/**
 * Converts a DER-encoded byte buffer to an OID dot-separated string. The
 * byte buffer should contain only the DER-encoded value, not any tag or
 * length bytes.
 *
 * @param bytes the byte buffer.
 *
 * @return the OID dot-separated string.
 */asn1.derToOid=function(bytes){var oid;// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}// first byte is 40 * value1 + value2
var b=bytes.getByte();oid=Math.floor(b/40)+'.'+b%40;// other bytes are each value in base 128 with 8th bit set except for
// the last byte for each value
var value=0;while(bytes.length()>0){b=bytes.getByte();value=value<<7;// not the last byte for the value
if(b&0x80){value+=b&0x7F;}else{// last byte
oid+='.'+(value+b);value=0;}}return oid;};/**
 * Converts a UTCTime value to a date.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Parsing that structure hasn't been implemented yet.
 *
 * @param utc the UTCTime value to convert.
 *
 * @return the date.
 */asn1.utcTimeToDate=function(utc){/* The following formats can be used:

    YYMMDDhhmmZ
    YYMMDDhhmm+hh'mm'
    YYMMDDhhmm-hh'mm'
    YYMMDDhhmmssZ
    YYMMDDhhmmss+hh'mm'
    YYMMDDhhmmss-hh'mm'

    Where:

    YY is the least significant two digits of the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */var date=new Date();// if YY >= 50 use 19xx, if YY < 50 use 20xx
var year=parseInt(utc.substr(0,2),10);year=year>=50?1900+year:2000+year;var MM=parseInt(utc.substr(2,2),10)-1;// use 0-11 for month
var DD=parseInt(utc.substr(4,2),10);var hh=parseInt(utc.substr(6,2),10);var mm=parseInt(utc.substr(8,2),10);var ss=0;// not just YYMMDDhhmmZ
if(utc.length>11){// get character after minutes
var c=utc.charAt(10);var end=10;// see if seconds are present
if(c!=='+'&&c!=='-'){// get seconds
ss=parseInt(utc.substr(10,2),10);end+=2;}}// update date
date.setUTCFullYear(year,MM,DD);date.setUTCHours(hh,mm,ss,0);if(end){// get +/- after end of time
c=utc.charAt(end);if(c==='+'||c==='-'){// get hours+minutes offset
var hhoffset=parseInt(utc.substr(end+1,2),10);var mmoffset=parseInt(utc.substr(end+4,2),10);// calculate offset in milliseconds
var offset=hhoffset*60+mmoffset;offset*=60000;// apply offset
if(c==='+'){date.setTime(+date-offset);}else{date.setTime(+date+offset);}}}return date;};/**
 * Converts a GeneralizedTime value to a date.
 *
 * @param gentime the GeneralizedTime value to convert.
 *
 * @return the date.
 */asn1.generalizedTimeToDate=function(gentime){/* The following formats can be used:

    YYYYMMDDHHMMSS
    YYYYMMDDHHMMSS.fff
    YYYYMMDDHHMMSSZ
    YYYYMMDDHHMMSS.fffZ
    YYYYMMDDHHMMSS+hh'mm'
    YYYYMMDDHHMMSS.fff+hh'mm'
    YYYYMMDDHHMMSS-hh'mm'
    YYYYMMDDHHMMSS.fff-hh'mm'

    Where:

    YYYY is the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    .fff is the second fraction, accurate to three decimal places
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */var date=new Date();var YYYY=parseInt(gentime.substr(0,4),10);var MM=parseInt(gentime.substr(4,2),10)-1;// use 0-11 for month
var DD=parseInt(gentime.substr(6,2),10);var hh=parseInt(gentime.substr(8,2),10);var mm=parseInt(gentime.substr(10,2),10);var ss=parseInt(gentime.substr(12,2),10);var fff=0;var offset=0;var isUTC=false;if(gentime.charAt(gentime.length-1)==='Z'){isUTC=true;}var end=gentime.length-5,c=gentime.charAt(end);if(c==='+'||c==='-'){// get hours+minutes offset
var hhoffset=parseInt(gentime.substr(end+1,2),10);var mmoffset=parseInt(gentime.substr(end+4,2),10);// calculate offset in milliseconds
offset=hhoffset*60+mmoffset;offset*=60000;// apply offset
if(c==='+'){offset*=-1;}isUTC=true;}// check for second fraction
if(gentime.charAt(14)==='.'){fff=parseFloat(gentime.substr(14),10)*1000;}if(isUTC){date.setUTCFullYear(YYYY,MM,DD);date.setUTCHours(hh,mm,ss,fff);// apply offset
date.setTime(+date+offset);}else{date.setFullYear(YYYY,MM,DD);date.setHours(hh,mm,ss,fff);}return date;};/**
 * Converts a date to a UTCTime value.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Converting to a GeneralizedTime hasn't been
 * implemented yet.
 *
 * @param date the date to convert.
 *
 * @return the UTCTime value.
 */asn1.dateToUtcTime=function(date){// TODO: validate; currently assumes proper format
if(typeof date==='string'){return date;}var rval='';// create format YYMMDDhhmmssZ
var format=[];format.push((''+date.getUTCFullYear()).substr(2));format.push(''+(date.getUTCMonth()+1));format.push(''+date.getUTCDate());format.push(''+date.getUTCHours());format.push(''+date.getUTCMinutes());format.push(''+date.getUTCSeconds());// ensure 2 digits are used for each format entry
for(var i=0;i<format.length;++i){if(format[i].length<2){rval+='0';}rval+=format[i];}rval+='Z';return rval;};/**
 * Converts a date to a GeneralizedTime value.
 *
 * @param date the date to convert.
 *
 * @return the GeneralizedTime value as a string.
 */asn1.dateToGeneralizedTime=function(date){// TODO: validate; currently assumes proper format
if(typeof date==='string'){return date;}var rval='';// create format YYYYMMDDHHMMSSZ
var format=[];format.push(''+date.getUTCFullYear());format.push(''+(date.getUTCMonth()+1));format.push(''+date.getUTCDate());format.push(''+date.getUTCHours());format.push(''+date.getUTCMinutes());format.push(''+date.getUTCSeconds());// ensure 2 digits are used for each format entry
for(var i=0;i<format.length;++i){if(format[i].length<2){rval+='0';}rval+=format[i];}rval+='Z';return rval;};/**
 * Converts a javascript integer to a DER-encoded byte buffer to be used
 * as the value for an INTEGER type.
 *
 * @param x the integer.
 *
 * @return the byte buffer.
 */asn1.integerToDer=function(x){var rval=forge.util.createBuffer();if(x>=-0x80&&x<0x80){return rval.putSignedInt(x,8);}if(x>=-0x8000&&x<0x8000){return rval.putSignedInt(x,16);}if(x>=-0x800000&&x<0x800000){return rval.putSignedInt(x,24);}if(x>=-0x80000000&&x<0x80000000){return rval.putSignedInt(x,32);}var error=new Error('Integer too large; max is 32-bits.');error.integer=x;throw error;};/**
 * Converts a DER-encoded byte buffer to a javascript integer. This is
 * typically used to decode the value of an INTEGER type.
 *
 * @param bytes the byte buffer.
 *
 * @return the integer.
 */asn1.derToInteger=function(bytes){// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}var n=bytes.length()*8;if(n>32){throw new Error('Integer too large; max is 32-bits.');}return bytes.getSignedInt(n);};/**
 * Validates that the given ASN.1 object is at least a super set of the
 * given ASN.1 structure. Only tag classes and types are checked. An
 * optional map may also be provided to capture ASN.1 values while the
 * structure is checked.
 *
 * To capture an ASN.1 value, set an object in the validator's 'capture'
 * parameter to the key to use in the capture map. To capture the full
 * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including
 * the leading unused bits counter byte, specify 'captureBitStringContents'.
 * To capture BIT STRING bytes, without the leading unused bits counter byte,
 * specify 'captureBitStringValue'.
 *
 * Objects in the validator may set a field 'optional' to true to indicate
 * that it isn't necessary to pass validation.
 *
 * @param obj the ASN.1 object to validate.
 * @param v the ASN.1 structure validator.
 * @param capture an optional map to capture values in.
 * @param errors an optional array for storing validation errors.
 *
 * @return true on success, false on failure.
 */asn1.validate=function(obj,v,capture,errors){var rval=false;// ensure tag class and type are the same if specified
if((obj.tagClass===v.tagClass||typeof v.tagClass==='undefined')&&(obj.type===v.type||typeof v.type==='undefined')){// ensure constructed flag is the same if specified
if(obj.constructed===v.constructed||typeof v.constructed==='undefined'){rval=true;// handle sub values
if(v.value&&forge.util.isArray(v.value)){var j=0;for(var i=0;rval&&i<v.value.length;++i){rval=v.value[i].optional||false;if(obj.value[j]){rval=asn1.validate(obj.value[j],v.value[i],capture,errors);if(rval){++j;}else if(v.value[i].optional){rval=true;}}if(!rval&&errors){errors.push('['+v.name+'] '+'Tag class "'+v.tagClass+'", type "'+v.type+'" expected value length "'+v.value.length+'", got "'+obj.value.length+'"');}}}if(rval&&capture){if(v.capture){capture[v.capture]=obj.value;}if(v.captureAsn1){capture[v.captureAsn1]=obj;}if(v.captureBitStringContents&&'bitStringContents'in obj){capture[v.captureBitStringContents]=obj.bitStringContents;}if(v.captureBitStringValue&&'bitStringContents'in obj){var value;if(obj.bitStringContents.length<2){capture[v.captureBitStringValue]='';}else{// FIXME: support unused bits with data shifting
var unused=obj.bitStringContents.charCodeAt(0);if(unused!==0){throw new Error('captureBitStringValue only supported for zero unused bits');}capture[v.captureBitStringValue]=obj.bitStringContents.slice(1);}}}}else if(errors){errors.push('['+v.name+'] '+'Expected constructed "'+v.constructed+'", got "'+obj.constructed+'"');}}else if(errors){if(obj.tagClass!==v.tagClass){errors.push('['+v.name+'] '+'Expected tag class "'+v.tagClass+'", got "'+obj.tagClass+'"');}if(obj.type!==v.type){errors.push('['+v.name+'] '+'Expected type "'+v.type+'", got "'+obj.type+'"');}}return rval;};// regex for testing for non-latin characters
var _nonLatinRegex=/[^\\u0000-\\u00ff]/;/**
 * Pretty prints an ASN.1 object to a string.
 *
 * @param obj the object to write out.
 * @param level the level in the tree.
 * @param indentation the indentation to use.
 *
 * @return the string.
 */asn1.prettyPrint=function(obj,level,indentation){var rval='';// set default level and indentation
level=level||0;indentation=indentation||2;// start new line for deep levels
if(level>0){rval+='\n';}// create indent
var indent='';for(var i=0;i<level*indentation;++i){indent+=' ';}// print class:type
rval+=indent+'Tag: ';switch(obj.tagClass){case asn1.Class.UNIVERSAL:rval+='Universal:';break;case asn1.Class.APPLICATION:rval+='Application:';break;case asn1.Class.CONTEXT_SPECIFIC:rval+='Context-Specific:';break;case asn1.Class.PRIVATE:rval+='Private:';break;}if(obj.tagClass===asn1.Class.UNIVERSAL){rval+=obj.type;// known types
switch(obj.type){case asn1.Type.NONE:rval+=' (None)';break;case asn1.Type.BOOLEAN:rval+=' (Boolean)';break;case asn1.Type.INTEGER:rval+=' (Integer)';break;case asn1.Type.BITSTRING:rval+=' (Bit string)';break;case asn1.Type.OCTETSTRING:rval+=' (Octet string)';break;case asn1.Type.NULL:rval+=' (Null)';break;case asn1.Type.OID:rval+=' (Object Identifier)';break;case asn1.Type.ODESC:rval+=' (Object Descriptor)';break;case asn1.Type.EXTERNAL:rval+=' (External or Instance of)';break;case asn1.Type.REAL:rval+=' (Real)';break;case asn1.Type.ENUMERATED:rval+=' (Enumerated)';break;case asn1.Type.EMBEDDED:rval+=' (Embedded PDV)';break;case asn1.Type.UTF8:rval+=' (UTF8)';break;case asn1.Type.ROID:rval+=' (Relative Object Identifier)';break;case asn1.Type.SEQUENCE:rval+=' (Sequence)';break;case asn1.Type.SET:rval+=' (Set)';break;case asn1.Type.PRINTABLESTRING:rval+=' (Printable String)';break;case asn1.Type.IA5String:rval+=' (IA5String (ASCII))';break;case asn1.Type.UTCTIME:rval+=' (UTC time)';break;case asn1.Type.GENERALIZEDTIME:rval+=' (Generalized time)';break;case asn1.Type.BMPSTRING:rval+=' (BMP String)';break;}}else{rval+=obj.type;}rval+='\n';rval+=indent+'Constructed: '+obj.constructed+'\n';if(obj.composed){var subvalues=0;var sub='';for(var i=0;i<obj.value.length;++i){if(obj.value[i]!==undefined){subvalues+=1;sub+=asn1.prettyPrint(obj.value[i],level+1,indentation);if(i+1<obj.value.length){sub+=',';}}}rval+=indent+'Sub values: '+subvalues+sub;}else{rval+=indent+'Value: ';if(obj.type===asn1.Type.OID){var oid=asn1.derToOid(obj.value);rval+=oid;if(forge.pki&&forge.pki.oids){if(oid in forge.pki.oids){rval+=' ('+forge.pki.oids[oid]+') ';}}}if(obj.type===asn1.Type.INTEGER){try{rval+=asn1.derToInteger(obj.value);}catch(ex){rval+='0x'+forge.util.bytesToHex(obj.value);}}else if(obj.type===asn1.Type.BITSTRING){// TODO: shift bits as needed to display without padding
if(obj.value.length>1){// remove unused bits field
rval+='0x'+forge.util.bytesToHex(obj.value.slice(1));}else{rval+='(none)';}// show unused bit count
if(obj.value.length>0){var unused=obj.value.charCodeAt(0);if(unused==1){rval+=' (1 unused bit shown)';}else if(unused>1){rval+=' ('+unused+' unused bits shown)';}}}else if(obj.type===asn1.Type.OCTETSTRING){if(!_nonLatinRegex.test(obj.value)){rval+='('+obj.value+') ';}rval+='0x'+forge.util.bytesToHex(obj.value);}else if(obj.type===asn1.Type.UTF8){rval+=forge.util.decodeUtf8(obj.value);}else if(obj.type===asn1.Type.PRINTABLESTRING||obj.type===asn1.Type.IA5String){rval+=obj.value;}else if(_nonLatinRegex.test(obj.value)){rval+='0x'+forge.util.bytesToHex(obj.value);}else if(obj.value.length===0){rval+='[null]';}else{rval+=obj.value;}}return rval;};/***/},/* 3 */ /***/function(module,exports,__webpack_require__){/**
 * Object IDs for ASN.1.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);forge.pki=forge.pki||{};var oids=module.exports=forge.pki.oids=forge.oids=forge.oids||{};// set id to name mapping and name to id mapping
function _IN(id,name){oids[id]=name;oids[name]=id;}// set id to name mapping only
function _I_(id,name){oids[id]=name;}// algorithm OIDs
_IN('1.2.840.113549.1.1.1','rsaEncryption');// Note: md2 & md4 not implemented
//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');
//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');
_IN('1.2.840.113549.1.1.4','md5WithRSAEncryption');_IN('1.2.840.113549.1.1.5','sha1WithRSAEncryption');_IN('1.2.840.113549.1.1.7','RSAES-OAEP');_IN('1.2.840.113549.1.1.8','mgf1');_IN('1.2.840.113549.1.1.9','pSpecified');_IN('1.2.840.113549.1.1.10','RSASSA-PSS');_IN('1.2.840.113549.1.1.11','sha256WithRSAEncryption');_IN('1.2.840.113549.1.1.12','sha384WithRSAEncryption');_IN('1.2.840.113549.1.1.13','sha512WithRSAEncryption');_IN('1.2.840.10040.4.3','dsa-with-sha1');_IN('1.3.14.3.2.7','desCBC');_IN('1.3.14.3.2.26','sha1');_IN('2.16.840.1.101.3.4.2.1','sha256');_IN('2.16.840.1.101.3.4.2.2','sha384');_IN('2.16.840.1.101.3.4.2.3','sha512');_IN('1.2.840.113549.2.5','md5');// pkcs#7 content types
_IN('1.2.840.113549.1.7.1','data');_IN('1.2.840.113549.1.7.2','signedData');_IN('1.2.840.113549.1.7.3','envelopedData');_IN('1.2.840.113549.1.7.4','signedAndEnvelopedData');_IN('1.2.840.113549.1.7.5','digestedData');_IN('1.2.840.113549.1.7.6','encryptedData');// pkcs#9 oids
_IN('1.2.840.113549.1.9.1','emailAddress');_IN('1.2.840.113549.1.9.2','unstructuredName');_IN('1.2.840.113549.1.9.3','contentType');_IN('1.2.840.113549.1.9.4','messageDigest');_IN('1.2.840.113549.1.9.5','signingTime');_IN('1.2.840.113549.1.9.6','counterSignature');_IN('1.2.840.113549.1.9.7','challengePassword');_IN('1.2.840.113549.1.9.8','unstructuredAddress');_IN('1.2.840.113549.1.9.14','extensionRequest');_IN('1.2.840.113549.1.9.20','friendlyName');_IN('1.2.840.113549.1.9.21','localKeyId');_IN('1.2.840.113549.1.9.22.1','x509Certificate');// pkcs#12 safe bags
_IN('1.2.840.113549.1.12.10.1.1','keyBag');_IN('1.2.840.113549.1.12.10.1.2','pkcs8ShroudedKeyBag');_IN('1.2.840.113549.1.12.10.1.3','certBag');_IN('1.2.840.113549.1.12.10.1.4','crlBag');_IN('1.2.840.113549.1.12.10.1.5','secretBag');_IN('1.2.840.113549.1.12.10.1.6','safeContentsBag');// password-based-encryption for pkcs#12
_IN('1.2.840.113549.1.5.13','pkcs5PBES2');_IN('1.2.840.113549.1.5.12','pkcs5PBKDF2');_IN('1.2.840.113549.1.12.1.1','pbeWithSHAAnd128BitRC4');_IN('1.2.840.113549.1.12.1.2','pbeWithSHAAnd40BitRC4');_IN('1.2.840.113549.1.12.1.3','pbeWithSHAAnd3-KeyTripleDES-CBC');_IN('1.2.840.113549.1.12.1.4','pbeWithSHAAnd2-KeyTripleDES-CBC');_IN('1.2.840.113549.1.12.1.5','pbeWithSHAAnd128BitRC2-CBC');_IN('1.2.840.113549.1.12.1.6','pbewithSHAAnd40BitRC2-CBC');// hmac OIDs
_IN('1.2.840.113549.2.7','hmacWithSHA1');_IN('1.2.840.113549.2.8','hmacWithSHA224');_IN('1.2.840.113549.2.9','hmacWithSHA256');_IN('1.2.840.113549.2.10','hmacWithSHA384');_IN('1.2.840.113549.2.11','hmacWithSHA512');// symmetric key algorithm oids
_IN('1.2.840.113549.3.7','des-EDE3-CBC');_IN('2.16.840.1.101.3.4.1.2','aes128-CBC');_IN('2.16.840.1.101.3.4.1.22','aes192-CBC');_IN('2.16.840.1.101.3.4.1.42','aes256-CBC');// certificate issuer/subject OIDs
_IN('2.5.4.3','commonName');_IN('2.5.4.5','serialName');_IN('2.5.4.6','countryName');_IN('2.5.4.7','localityName');_IN('2.5.4.8','stateOrProvinceName');_IN('2.5.4.10','organizationName');_IN('2.5.4.11','organizationalUnitName');_IN('2.5.4.13','description');// X.509 extension OIDs
_IN('2.16.840.1.113730.1.1','nsCertType');_I_('2.5.29.1','authorityKeyIdentifier');// deprecated, use .35
_I_('2.5.29.2','keyAttributes');// obsolete use .37 or .15
_I_('2.5.29.3','certificatePolicies');// deprecated, use .32
_I_('2.5.29.4','keyUsageRestriction');// obsolete use .37 or .15
_I_('2.5.29.5','policyMapping');// deprecated use .33
_I_('2.5.29.6','subtreesConstraint');// obsolete use .30
_I_('2.5.29.7','subjectAltName');// deprecated use .17
_I_('2.5.29.8','issuerAltName');// deprecated use .18
_I_('2.5.29.9','subjectDirectoryAttributes');_I_('2.5.29.10','basicConstraints');// deprecated use .19
_I_('2.5.29.11','nameConstraints');// deprecated use .30
_I_('2.5.29.12','policyConstraints');// deprecated use .36
_I_('2.5.29.13','basicConstraints');// deprecated use .19
_IN('2.5.29.14','subjectKeyIdentifier');_IN('2.5.29.15','keyUsage');_I_('2.5.29.16','privateKeyUsagePeriod');_IN('2.5.29.17','subjectAltName');_IN('2.5.29.18','issuerAltName');_IN('2.5.29.19','basicConstraints');_I_('2.5.29.20','cRLNumber');_I_('2.5.29.21','cRLReason');_I_('2.5.29.22','expirationDate');_I_('2.5.29.23','instructionCode');_I_('2.5.29.24','invalidityDate');_I_('2.5.29.25','cRLDistributionPoints');// deprecated use .31
_I_('2.5.29.26','issuingDistributionPoint');// deprecated use .28
_I_('2.5.29.27','deltaCRLIndicator');_I_('2.5.29.28','issuingDistributionPoint');_I_('2.5.29.29','certificateIssuer');_I_('2.5.29.30','nameConstraints');_IN('2.5.29.31','cRLDistributionPoints');_IN('2.5.29.32','certificatePolicies');_I_('2.5.29.33','policyMappings');_I_('2.5.29.34','policyConstraints');// deprecated use .36
_IN('2.5.29.35','authorityKeyIdentifier');_I_('2.5.29.36','policyConstraints');_IN('2.5.29.37','extKeyUsage');_I_('2.5.29.46','freshestCRL');_I_('2.5.29.54','inhibitAnyPolicy');// extKeyUsage purposes
_IN('1.3.6.1.4.1.11129.2.4.2','timestampList');_IN('1.3.6.1.5.5.7.1.1','authorityInfoAccess');_IN('1.3.6.1.5.5.7.3.1','serverAuth');_IN('1.3.6.1.5.5.7.3.2','clientAuth');_IN('1.3.6.1.5.5.7.3.3','codeSigning');_IN('1.3.6.1.5.5.7.3.4','emailProtection');_IN('1.3.6.1.5.5.7.3.8','timeStamping');/***/},/* 4 */ /***/function(module,exports,__webpack_require__){/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);module.exports=forge.md=forge.md||{};forge.md.algorithms=forge.md.algorithms||{};/***/},/* 5 */ /***/function(module,exports,__webpack_require__){/**
 * An API for getting cryptographically-secure random bytes. The bytes are
 * generated using the Fortuna algorithm devised by Bruce Schneier and
 * Niels Ferguson.
 *
 * Getting strong random bytes is not yet easy to do in javascript. The only
 * truish random entropy that can be collected is from the mouse, keyboard, or
 * from timing with respect to page loads, etc. This generator makes a poor
 * attempt at providing random bytes when those sources haven't yet provided
 * enough entropy to initially seed or to reseed the PRNG.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2009-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(23);__webpack_require__(24);__webpack_require__(1);(function(){// forge.random already defined
if(forge.random&&forge.random.getBytes){module.exports=forge.random;return;}(function(jQuery){// the default prng plugin, uses AES-128
var prng_aes={};var _prng_aes_output=new Array(4);var _prng_aes_buffer=forge.util.createBuffer();prng_aes.formatKey=function(key){// convert the key into 32-bit integers
var tmp=forge.util.createBuffer(key);key=new Array(4);key[0]=tmp.getInt32();key[1]=tmp.getInt32();key[2]=tmp.getInt32();key[3]=tmp.getInt32();// return the expanded key
return forge.aes._expandKey(key,false);};prng_aes.formatSeed=function(seed){// convert seed into 32-bit integers
var tmp=forge.util.createBuffer(seed);seed=new Array(4);seed[0]=tmp.getInt32();seed[1]=tmp.getInt32();seed[2]=tmp.getInt32();seed[3]=tmp.getInt32();return seed;};prng_aes.cipher=function(key,seed){forge.aes._updateBlock(key,seed,_prng_aes_output,false);_prng_aes_buffer.putInt32(_prng_aes_output[0]);_prng_aes_buffer.putInt32(_prng_aes_output[1]);_prng_aes_buffer.putInt32(_prng_aes_output[2]);_prng_aes_buffer.putInt32(_prng_aes_output[3]);return _prng_aes_buffer.getBytes();};prng_aes.increment=function(seed){// FIXME: do we care about carry or signed issues?
++seed[3];return seed;};prng_aes.md=forge.md.sha256;/**
 * Creates a new PRNG.
 */function spawnPrng(){var ctx=forge.prng.create(prng_aes);/**
   * Gets random bytes. If a native secure crypto API is unavailable, this
   * method tries to make the bytes more unpredictable by drawing from data that
   * can be collected from the user of the browser, eg: mouse movement.
   *
   * If a callback is given, this method will be called asynchronously.
   *
   * @param count the number of random bytes to get.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return the random bytes in a string.
   */ctx.getBytes=function(count,callback){return ctx.generate(count,callback);};/**
   * Gets random bytes asynchronously. If a native secure crypto API is
   * unavailable, this method tries to make the bytes more unpredictable by
   * drawing from data that can be collected from the user of the browser,
   * eg: mouse movement.
   *
   * @param count the number of random bytes to get.
   *
   * @return the random bytes in a string.
   */ctx.getBytesSync=function(count){return ctx.generate(count);};return ctx;}// create default prng context
var _ctx=spawnPrng();// add other sources of entropy only if window.crypto.getRandomValues is not
// available -- otherwise this source will be automatically used by the prng
var getRandomValues=null;if(typeof window!=='undefined'){var _crypto=window.crypto||window.msCrypto;if(_crypto&&_crypto.getRandomValues){getRandomValues=function getRandomValues(arr){return _crypto.getRandomValues(arr);};}}if(forge.options.usePureJavaScript||!forge.util.isNodejs&&!getRandomValues){// if this is a web worker, do not use weak entropy, instead register to
// receive strong entropy asynchronously from the main thread
if(typeof window==='undefined'||window.document===undefined){}// FIXME:
// get load time entropy
_ctx.collectInt(+new Date(),32);// add some entropy from navigator object
if(typeof navigator!=='undefined'){var _navBytes='';for(var key in navigator){try{if(typeof navigator[key]=='string'){_navBytes+=navigator[key];}}catch(e){/* Some navigator keys might not be accessible, e.g. the geolocation
          attribute throws an exception if touched in Mozilla chrome://
          context.

          Silently ignore this and just don't use this as a source of
          entropy. */}}_ctx.collect(_navBytes);_navBytes=null;}// add mouse and keyboard collectors if jquery is available
if(jQuery){// set up mouse entropy capture
jQuery().mousemove(function(e){// add mouse coords
_ctx.collectInt(e.clientX,16);_ctx.collectInt(e.clientY,16);});// set up keyboard entropy capture
jQuery().keypress(function(e){_ctx.collectInt(e.charCode,8);});}}/* Random API */if(!forge.random){forge.random=_ctx;}else{// extend forge.random with _ctx
for(var key in _ctx){forge.random[key]=_ctx[key];}}// expose spawn PRNG
forge.random.createInstance=spawnPrng;module.exports=forge.random;})(typeof jQuery!=='undefined'?jQuery:null);})();/***/},/* 6 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of basic RSA algorithms.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The only algorithm currently supported for PKI is RSA.
 *
 * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo
 * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier
 * and a subjectPublicKey of type bit string.
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of RSA, there aren't any.
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm AlgorithmIdentifier,
 *   subjectPublicKey BIT STRING
 * }
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * For an RSA public key, the subjectPublicKey is:
 *
 * RSAPublicKey ::= SEQUENCE {
 *   modulus            INTEGER,    -- n
 *   publicExponent     INTEGER     -- e
 * }
 *
 * PrivateKeyInfo ::= SEQUENCE {
 *   version                   Version,
 *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
 *   privateKey                PrivateKey,
 *   attributes           [0]  IMPLICIT Attributes OPTIONAL
 * }
 *
 * Version ::= INTEGER
 * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
 * PrivateKey ::= OCTET STRING
 * Attributes ::= SET OF Attribute
 *
 * An RSA private key as the following structure:
 *
 * RSAPrivateKey ::= SEQUENCE {
 *   version Version,
 *   modulus INTEGER, -- n
 *   publicExponent INTEGER, -- e
 *   privateExponent INTEGER, -- d
 *   prime1 INTEGER, -- p
 *   prime2 INTEGER, -- q
 *   exponent1 INTEGER, -- d mod (p-1)
 *   exponent2 INTEGER, -- d mod (q-1)
 *   coefficient INTEGER -- (inverse of q) mod p
 * }
 *
 * Version ::= INTEGER
 *
 * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(16);__webpack_require__(3);__webpack_require__(26);__webpack_require__(27);__webpack_require__(5);__webpack_require__(1);if(typeof BigInteger==='undefined'){var BigInteger=forge.jsbn.BigInteger;}// shortcut for asn.1 API
var asn1=forge.asn1;/*
 * RSA encryption and decryption, see RFC 2313.
 */forge.pki=forge.pki||{};module.exports=forge.pki.rsa=forge.rsa=forge.rsa||{};var pki=forge.pki;// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA=[6,4,2,4,2,4,6,2];// validator for a PrivateKeyInfo structure
var privateKeyValidator={// PrivateKeyInfo
name:'PrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// Version (INTEGER)
name:'PrivateKeyInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyVersion'},{// privateKeyAlgorithm
name:'PrivateKeyInfo.privateKeyAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'privateKeyOid'}]},{// PrivateKey
name:'PrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'privateKey'}]};// validator for an RSA private key
var rsaPrivateKeyValidator={// RSAPrivateKey
name:'RSAPrivateKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// Version (INTEGER)
name:'RSAPrivateKey.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyVersion'},{// modulus (n)
name:'RSAPrivateKey.modulus',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyModulus'},{// publicExponent (e)
name:'RSAPrivateKey.publicExponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPublicExponent'},{// privateExponent (d)
name:'RSAPrivateKey.privateExponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrivateExponent'},{// prime1 (p)
name:'RSAPrivateKey.prime1',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrime1'},{// prime2 (q)
name:'RSAPrivateKey.prime2',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrime2'},{// exponent1 (d mod (p-1))
name:'RSAPrivateKey.exponent1',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyExponent1'},{// exponent2 (d mod (q-1))
name:'RSAPrivateKey.exponent2',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyExponent2'},{// coefficient ((inverse of q) mod p)
name:'RSAPrivateKey.coefficient',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyCoefficient'}]};// validator for an RSA public key
var rsaPublicKeyValidator={// RSAPublicKey
name:'RSAPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// modulus (n)
name:'RSAPublicKey.modulus',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'publicKeyModulus'},{// publicExponent (e)
name:'RSAPublicKey.exponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'publicKeyExponent'}]};// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator=forge.pki.rsa.publicKeyValidator={name:'SubjectPublicKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'subjectPublicKeyInfo',value:[{name:'SubjectPublicKeyInfo.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'publicKeyOid'}]},{// subjectPublicKey
name:'SubjectPublicKeyInfo.subjectPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,value:[{// RSAPublicKey
name:'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,captureAsn1:'rsaPublicKey'}]}]};/**
 * Wrap digest in DigestInfo object.
 *
 * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 * Digest ::= OCTET STRING
 *
 * @param md the message digest object with the hash to sign.
 *
 * @return the encoded message (ready for RSA encrytion)
 */var emsaPkcs1v15encode=function emsaPkcs1v15encode(md){// get the oid for the algorithm
var oid;if(md.algorithm in pki.oids){oid=pki.oids[md.algorithm];}else{var error=new Error('Unknown message digest algorithm.');error.algorithm=md.algorithm;throw error;}var oidBytes=asn1.oidToDer(oid).getBytes();// create the digest info
var digestInfo=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var digestAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,oidBytes));digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,''));var digest=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,md.digest().getBytes());digestInfo.value.push(digestAlgorithm);digestInfo.value.push(digest);// encode digest info
return asn1.toDer(digestInfo).getBytes();};/**
 * Performs x^c mod n (RSA encryption or decryption operation).
 *
 * @param x the number to raise and mod.
 * @param key the key to use.
 * @param pub true if the key is public, false if private.
 *
 * @return the result of x^c mod n.
 */var _modPow=function _modPow(x,key,pub){if(pub){return x.modPow(key.e,key.n);}if(!key.p||!key.q){// allow calculation without CRT params (slow)
return x.modPow(key.d,key.n);}// pre-compute dP, dQ, and qInv if necessary
if(!key.dP){key.dP=key.d.mod(key.p.subtract(BigInteger.ONE));}if(!key.dQ){key.dQ=key.d.mod(key.q.subtract(BigInteger.ONE));}if(!key.qInv){key.qInv=key.q.modInverse(key.p);}/* Chinese remainder theorem (CRT) states:

    Suppose n1, n2, ..., nk are positive integers which are pairwise
    coprime (n1 and n2 have no common factors other than 1). For any
    integers x1, x2, ..., xk there exists an integer x solving the
    system of simultaneous congruences (where ~= means modularly
    congruent so a ~= b mod n means a mod n = b mod n):

    x ~= x1 mod n1
    x ~= x2 mod n2
    ...
    x ~= xk mod nk

    This system of congruences has a single simultaneous solution x
    between 0 and n - 1. Furthermore, each xk solution and x itself
    is congruent modulo the product n = n1*n2*...*nk.
    So x1 mod n = x2 mod n = xk mod n = x mod n.

    The single simultaneous solution x can be solved with the following
    equation:

    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.

    Where x is less than n, xi = x mod ni.

    For RSA we are only concerned with k = 2. The modulus n = pq, where
    p and q are coprime. The RSA decryption algorithm is:

    y = x^d mod n

    Given the above:

    x1 = x^d mod p
    r1 = n/p = q
    s1 = q^-1 mod p
    x2 = x^d mod q
    r2 = n/q = p
    s2 = p^-1 mod q

    So y = (x1r1s1 + x2r2s2) mod n
         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n

    According to Fermat's Little Theorem, if the modulus P is prime,
    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.
    Since A is not divisible by P it follows that if:
    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:

    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort
    to calculate). In order to calculate x^d mod p more quickly the
    exponent d mod (p - 1) is stored in the RSA private key (the same
    is done for x^d mod q). These values are referred to as dP and dQ
    respectively. Therefore we now have:

    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n

    Since we'll be reducing x^dP by modulo p (same for q) we can also
    reduce x by p (and q respectively) before hand. Therefore, let

    xp = ((x mod p)^dP mod p), and
    xq = ((x mod q)^dQ mod q), yielding:

    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n

    This can be further reduced to a simple algorithm that only
    requires 1 inverse (the q inverse is used) to be used and stored.
    The algorithm is called Garner's algorithm. If qInv is the
    inverse of q, we simply calculate:

    y = (qInv*(xp - xq) mod p) * q + xq

    However, there are two further complications. First, we need to
    ensure that xp > xq to prevent signed BigIntegers from being used
    so we add p until this is true (since we will be mod'ing with
    p anyway). Then, there is a known timing attack on algorithms
    using the CRT. To mitigate this risk, "cryptographic blinding"
    should be used. This requires simply generating a random number r
    between 0 and n-1 and its inverse and multiplying x by r^e before
    calculating y and then multiplying y by r^-1 afterwards. Note that
    r must be coprime with n (gcd(r, n) === 1) in order to have an
    inverse.
  */ // cryptographic blinding
var r;do{r=new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength()/8)),16);}while(r.compareTo(key.n)>=0||!r.gcd(key.n).equals(BigInteger.ONE));x=x.multiply(r.modPow(key.e,key.n)).mod(key.n);// calculate xp and xq
var xp=x.mod(key.p).modPow(key.dP,key.p);var xq=x.mod(key.q).modPow(key.dQ,key.q);// xp must be larger than xq to avoid signed bit usage
while(xp.compareTo(xq)<0){xp=xp.add(key.p);}// do last step
var y=xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);// remove effect of random for cryptographic blinding
y=y.multiply(r.modInverse(key.n)).mod(key.n);return y;};/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or
 * 'encrypt' on a public key object instead.
 *
 * Performs RSA encryption.
 *
 * The parameter bt controls whether to put padding bytes before the
 * message passed in. Set bt to either true or false to disable padding
 * completely (in order to handle e.g. EMSA-PSS encoding seperately before),
 * signaling whether the encryption operation is a public key operation
 * (i.e. encrypting data) or not, i.e. private key operation (data signing).
 *
 * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01
 * (for signing) or 0x02 (for encryption). The key operation mode (private
 * or public) is derived from this flag in that case).
 *
 * @param m the message to encrypt as a byte string.
 * @param key the RSA key to use.
 * @param bt for PKCS#1 v1.5 padding, the block type to use
 *   (0x01 for private key, 0x02 for public),
 *   to disable padding: true = public key, false = private key.
 *
 * @return the encrypted bytes as a string.
 */pki.rsa.encrypt=function(m,key,bt){var pub=bt;var eb;// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);if(bt!==false&&bt!==true){// legacy, default to PKCS#1 v1.5 padding
pub=bt===0x02;eb=_encodePkcs1_v1_5(m,key,bt);}else{eb=forge.util.createBuffer();eb.putBytes(m);}// load encryption block as big integer 'x'
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var x=new BigInteger(eb.toHex(),16);// do RSA encryption
var y=_modPow(x,key,pub);// convert y into the encrypted data byte string, if y is shorter in
// bytes than k, then prepend zero bytes to fill up ed
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var yhex=y.toString(16);var ed=forge.util.createBuffer();var zeros=k-Math.ceil(yhex.length/2);while(zeros>0){ed.putByte(0x00);--zeros;}ed.putBytes(forge.util.hexToBytes(yhex));return ed.getBytes();};/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or
 * 'verify' on a public key object instead.
 *
 * Performs RSA decryption.
 *
 * The parameter ml controls whether to apply PKCS#1 v1.5 padding
 * or not.  Set ml = false to disable padding removal completely
 * (in order to handle e.g. EMSA-PSS later on) and simply pass back
 * the RSA encryption block.
 *
 * @param ed the encrypted data to decrypt in as a byte string.
 * @param key the RSA key to use.
 * @param pub true for a public key operation, false for private.
 * @param ml the message length, if known, false to disable padding.
 *
 * @return the decrypted message as a byte string.
 */pki.rsa.decrypt=function(ed,key,pub,ml){// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);// error if the length of the encrypted data ED is not k
if(ed.length!==k){var error=new Error('Encrypted message length is invalid.');error.length=ed.length;error.expected=k;throw error;}// convert encrypted data into a big integer
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var y=new BigInteger(forge.util.createBuffer(ed).toHex(),16);// y must be less than the modulus or it wasn't the result of
// a previous mod operation (encryption) using that modulus
if(y.compareTo(key.n)>=0){throw new Error('Encrypted message is invalid.');}// do RSA decryption
var x=_modPow(y,key,pub);// create the encryption block, if x is shorter in bytes than k, then
// prepend zero bytes to fill up eb
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var xhex=x.toString(16);var eb=forge.util.createBuffer();var zeros=k-Math.ceil(xhex.length/2);while(zeros>0){eb.putByte(0x00);--zeros;}eb.putBytes(forge.util.hexToBytes(xhex));if(ml!==false){// legacy, default to PKCS#1 v1.5 padding
return _decodePkcs1_v1_5(eb.getBytes(),key,pub);}// return message
return eb.getBytes();};/**
 * Creates an RSA key-pair generation state object. It is used to allow
 * key-generation to be performed in steps. It also allows for a UI to
 * display progress updates.
 *
 * @param bits the size for the private key in bits, defaults to 2048.
 * @param e the public exponent to use, defaults to 65537 (0x10001).
 * @param [options] the options to use.
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 *
 * @return the state object to use to generate the key-pair.
 */pki.rsa.createKeyPairGenerationState=function(bits,e,options){// TODO: migrate step-based prime generation code to forge.prime
// set default bits
if(typeof bits==='string'){bits=parseInt(bits,10);}bits=bits||2048;// create prng with api that matches BigInteger secure random
options=options||{};var prng=options.prng||forge.random;var rng={// x is an array to fill with bytes
nextBytes:function nextBytes(x){var b=prng.getBytesSync(x.length);for(var i=0;i<x.length;++i){x[i]=b.charCodeAt(i);}}};var algorithm=options.algorithm||'PRIMEINC';// create PRIMEINC algorithm state
var rval;if(algorithm==='PRIMEINC'){rval={algorithm:algorithm,state:0,bits:bits,rng:rng,eInt:e||65537,e:new BigInteger(null),p:null,q:null,qBits:bits>>1,pBits:bits-(bits>>1),pqState:0,num:null,keys:null};rval.e.fromInt(rval.eInt);}else{throw new Error('Invalid key generation algorithm: '+algorithm);}return rval;};/**
 * Attempts to runs the key-generation algorithm for at most n seconds
 * (approximately) using the given state. When key-generation has completed,
 * the keys will be stored in state.keys.
 *
 * To use this function to update a UI while generating a key or to prevent
 * causing browser lockups/warnings, set "n" to a value other than 0. A
 * simple pattern for generating a key and showing a progress indicator is:
 *
 * var state = pki.rsa.createKeyPairGenerationState(2048);
 * var step = function() {
 *   // step key-generation, run algorithm for 100 ms, repeat
 *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {
 *     setTimeout(step, 1);
 *   } else {
 *     // key-generation complete
 *     // TODO: turn off progress indicator here
 *     // TODO: use the generated key-pair in "state.keys"
 *   }
 * };
 * // TODO: turn on progress indicator here
 * setTimeout(step, 0);
 *
 * @param state the state to use.
 * @param n the maximum number of milliseconds to run the algorithm for, 0
 *          to run the algorithm to completion.
 *
 * @return true if the key-generation completed, false if not.
 */pki.rsa.stepKeyPairGenerationState=function(state,n){// set default algorithm if not set
if(!('algorithm'in state)){state.algorithm='PRIMEINC';}// TODO: migrate step-based prime generation code to forge.prime
// TODO: abstract as PRIMEINC algorithm
// do key generation (based on Tom Wu's rsa.js, see jsbn.js license)
// with some minor optimizations and designed to run in steps
// local state vars
var THIRTY=new BigInteger(null);THIRTY.fromInt(30);var deltaIdx=0;var op_or=function op_or(x,y){return x|y;};// keep stepping until time limit is reached or done
var t1=+new Date();var t2;var total=0;while(state.keys===null&&(n<=0||total<n)){// generate p or q
if(state.state===0){/* Note: All primes are of the form:

        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i

        When we generate a random number, we always align it at 30k + 1. Each
        time the number is determined not to be prime we add to get to the
        next 'i', eg: if the number was at 30k + 1 we add 6. */var bits=state.p===null?state.pBits:state.qBits;var bits1=bits-1;// get a random number
if(state.pqState===0){state.num=new BigInteger(bits,state.rng);// force MSB set
if(!state.num.testBit(bits1)){state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1),op_or,state.num);}// align number on 30k+1 boundary
state.num.dAddOffset(31-state.num.mod(THIRTY).byteValue(),0);deltaIdx=0;++state.pqState;}else if(state.pqState===1){// try to make the number a prime
if(state.num.bitLength()>bits){// overflow, try again
state.pqState=0;// do primality test
}else if(state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))){++state.pqState;}else{// get next potential prime
state.num.dAddOffset(GCD_30_DELTA[deltaIdx++%8],0);}}else if(state.pqState===2){// ensure number is coprime with e
state.pqState=state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)===0?3:0;}else if(state.pqState===3){// store p or q
state.pqState=0;if(state.p===null){state.p=state.num;}else{state.q=state.num;}// advance state if both p and q are ready
if(state.p!==null&&state.q!==null){++state.state;}state.num=null;}}else if(state.state===1){// ensure p is larger than q (swap them if not)
if(state.p.compareTo(state.q)<0){state.num=state.p;state.p=state.q;state.q=state.num;}++state.state;}else if(state.state===2){// compute phi: (p - 1)(q - 1) (Euler's totient function)
state.p1=state.p.subtract(BigInteger.ONE);state.q1=state.q.subtract(BigInteger.ONE);state.phi=state.p1.multiply(state.q1);++state.state;}else if(state.state===3){// ensure e and phi are coprime
if(state.phi.gcd(state.e).compareTo(BigInteger.ONE)===0){// phi and e are coprime, advance
++state.state;}else{// phi and e aren't coprime, so generate a new p and q
state.p=null;state.q=null;state.state=0;}}else if(state.state===4){// create n, ensure n is has the right number of bits
state.n=state.p.multiply(state.q);// ensure n is right number of bits
if(state.n.bitLength()===state.bits){// success, advance
++state.state;}else{// failed, get new q
state.q=null;state.state=0;}}else if(state.state===5){// set keys
var d=state.e.modInverse(state.phi);state.keys={privateKey:pki.rsa.setPrivateKey(state.n,state.e,d,state.p,state.q,d.mod(state.p1),d.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)};}// update timing
t2=+new Date();total+=t2-t1;t1=t2;}return state.keys!==null;};/**
 * Generates an RSA public-private key pair in a single call.
 *
 * To generate a key-pair in steps (to allow for progress updates and to
 * prevent blocking or warnings in slow browsers) then use the key-pair
 * generation state functions.
 *
 * To generate a key-pair asynchronously (either through web-workers, if
 * available, or by breaking up the work on the main thread), pass a
 * callback function.
 *
 * @param [bits] the size for the private key in bits, defaults to 2048.
 * @param [e] the public exponent to use, defaults to 65537.
 * @param [options] options for key-pair generation, if given then 'bits'
 *          and 'e' must *not* be given:
 *          bits the size for the private key in bits, (default: 2048).
 *          e the public exponent to use, (default: 65537 (0x10001)).
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 * @param [callback(err, keypair)] called once the operation completes.
 *
 * @return an object with privateKey and publicKey properties.
 */pki.rsa.generateKeyPair=function(bits,e,options,callback){// (bits), (options), (callback)
if(arguments.length===1){if(_typeof(bits)==='object'){options=bits;bits=undefined;}else if(typeof bits==='function'){callback=bits;bits=undefined;}}else if(arguments.length===2){// (bits, e), (bits, options), (bits, callback), (options, callback)
if(typeof bits==='number'){if(typeof e==='function'){callback=e;e=undefined;}else if(typeof e!=='number'){options=e;e=undefined;}}else{options=bits;callback=e;bits=undefined;e=undefined;}}else if(arguments.length===3){// (bits, e, options), (bits, e, callback), (bits, options, callback)
if(typeof e==='number'){if(typeof options==='function'){callback=options;options=undefined;}}else{callback=options;options=e;e=undefined;}}options=options||{};if(bits===undefined){bits=options.bits||2048;}if(e===undefined){e=options.e||0x10001;}// if native code is permitted and a callback is given, use native
// key generation code if available and if parameters are acceptable
if(!forge.options.usePureJavaScript&&callback&&bits>=256&&bits<=16384&&(e===0x10001||e===3)){if(_detectSubtleCrypto('generateKey')&&_detectSubtleCrypto('exportKey')){// use standard native generateKey
return window.crypto.subtle.generateKey({name:'RSASSA-PKCS1-v1_5',modulusLength:bits,publicExponent:_intToUint8Array(e),hash:{name:'SHA-256'}},true/* key can be exported*/,['sign','verify']).then(function(pair){return window.crypto.subtle.exportKey('pkcs8',pair.privateKey);// avoiding catch(function(err) {...}) to support IE <= 8
}).then(undefined,function(err){callback(err);}).then(function(pkcs8){if(pkcs8){var privateKey=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));callback(null,{privateKey:privateKey,publicKey:pki.setRsaPublicKey(privateKey.n,privateKey.e)});}});}if(_detectSubtleMsCrypto('generateKey')&&_detectSubtleMsCrypto('exportKey')){var genOp=window.msCrypto.subtle.generateKey({name:'RSASSA-PKCS1-v1_5',modulusLength:bits,publicExponent:_intToUint8Array(e),hash:{name:'SHA-256'}},true/* key can be exported*/,['sign','verify']);genOp.oncomplete=function(e){var pair=e.target.result;var exportOp=window.msCrypto.subtle.exportKey('pkcs8',pair.privateKey);exportOp.oncomplete=function(e){var pkcs8=e.target.result;var privateKey=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));callback(null,{privateKey:privateKey,publicKey:pki.setRsaPublicKey(privateKey.n,privateKey.e)});};exportOp.onerror=function(err){callback(err);};};genOp.onerror=function(err){callback(err);};return;}}// use JavaScript implementation
var state=pki.rsa.createKeyPairGenerationState(bits,e,options);if(!callback){pki.rsa.stepKeyPairGenerationState(state,0);return state.keys;}_generateKeyPair(state,options,callback);};/**
 * Sets an RSA public key from BigIntegers modulus and exponent.
 *
 * @param n the modulus.
 * @param e the exponent.
 *
 * @return the public key.
 */pki.setRsaPublicKey=pki.rsa.setPublicKey=function(n,e){var key={n:n,e:e};/**
   * Encrypts the given data with this public key. Newer applications
   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
   * legacy applications.
   *
   * @param data the byte string to encrypt.
   * @param scheme the encryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA encryption,
   *          an object with an 'encode' property set to a function
   *          with the signature 'function(data, key)' that returns
   *          a binary-encoded string representing the encoded data.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the encrypted byte string.
   */key.encrypt=function(data,scheme,schemeOptions){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSAES-PKCS1-V1_5';}if(scheme==='RSAES-PKCS1-V1_5'){scheme={encode:function encode(m,key,pub){return _encodePkcs1_v1_5(m,key,0x02).getBytes();}};}else if(scheme==='RSA-OAEP'||scheme==='RSAES-OAEP'){scheme={encode:function encode(m,key){return forge.pkcs1.encode_rsa_oaep(key,m,schemeOptions);}};}else if(['RAW','NONE','NULL',null].indexOf(scheme)!==-1){scheme={encode:function encode(e){return e;}};}else if(typeof scheme==='string'){throw new Error('Unsupported encryption scheme: "'+scheme+'".');}// do scheme-based encoding then rsa encryption
var e=scheme.encode(data,key,true);return pki.rsa.encrypt(e,key,true);};/**
   * Verifies the given signature against the given digest.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
   * signature is an OCTET STRING that holds a DigestInfo.
   *
   * DigestInfo ::= SEQUENCE {
   *   digestAlgorithm DigestAlgorithmIdentifier,
   *   digest Digest
   * }
   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
   * Digest ::= OCTET STRING
   *
   * To perform PSS signature verification, provide an instance
   * of Forge PSS object as the scheme parameter.
   *
   * @param digest the message digest hash to compare against the signature,
   *          as a binary-encoded string.
   * @param signature the signature to verify, as a binary-encoded string.
   * @param scheme signature verification scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be expected, but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return true if the signature was verified, false if not.
   */key.verify=function(digest,signature,scheme){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSASSA-PKCS1-V1_5';}if(scheme==='RSASSA-PKCS1-V1_5'){scheme={verify:function verify(digest,d){// remove padding
d=_decodePkcs1_v1_5(d,key,true);// d is ASN.1 BER-encoded DigestInfo
var obj=asn1.fromDer(d);// compare the given digest to the decrypted one
return digest===obj.value[1].value;}};}else if(scheme==='NONE'||scheme==='NULL'||scheme===null){scheme={verify:function verify(digest,d){// remove padding
d=_decodePkcs1_v1_5(d,key,true);return digest===d;}};}// do rsa decryption w/o any decoding, then verify -- which does decoding
var d=pki.rsa.decrypt(signature,key,true,false);return scheme.verify(digest,d,key.n.bitLength());};return key;};/**
 * Sets an RSA private key from BigIntegers modulus, exponent, primes,
 * prime exponents, and modular multiplicative inverse.
 *
 * @param n the modulus.
 * @param e the public exponent.
 * @param d the private exponent ((inverse of e) mod n).
 * @param p the first prime.
 * @param q the second prime.
 * @param dP exponent1 (d mod (p-1)).
 * @param dQ exponent2 (d mod (q-1)).
 * @param qInv ((inverse of q) mod p)
 *
 * @return the private key.
 */pki.setRsaPrivateKey=pki.rsa.setPrivateKey=function(n,e,d,p,q,dP,dQ,qInv){var key={n:n,e:e,d:d,p:p,q:q,dP:dP,dQ:dQ,qInv:qInv};/**
   * Decrypts the given data with this private key. The decryption scheme
   * must match the one used to encrypt the data.
   *
   * @param data the byte string to decrypt.
   * @param scheme the decryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA decryption.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the decrypted byte string.
   */key.decrypt=function(data,scheme,schemeOptions){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSAES-PKCS1-V1_5';}// do rsa decryption w/o any decoding
var d=pki.rsa.decrypt(data,key,false,false);if(scheme==='RSAES-PKCS1-V1_5'){scheme={decode:_decodePkcs1_v1_5};}else if(scheme==='RSA-OAEP'||scheme==='RSAES-OAEP'){scheme={decode:function decode(d,key){return forge.pkcs1.decode_rsa_oaep(key,d,schemeOptions);}};}else if(['RAW','NONE','NULL',null].indexOf(scheme)!==-1){scheme={decode:function decode(d){return d;}};}else{throw new Error('Unsupported encryption scheme: "'+scheme+'".');}// decode according to scheme
return scheme.decode(d,key,false);};/**
   * Signs the given digest, producing a signature.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
   * an instance of Forge PSS object as the scheme parameter.
   *
   * @param md the message digest object with the hash to sign.
   * @param scheme the signature scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be used but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return the signature as a byte string.
   */key.sign=function(md,scheme){/* Note: The internal implementation of RSA operations is being
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy
      code like the use of an encoding block identifier 'bt' will eventually
      be removed. */ // private key operation
var bt=false;if(typeof scheme==='string'){scheme=scheme.toUpperCase();}if(scheme===undefined||scheme==='RSASSA-PKCS1-V1_5'){scheme={encode:emsaPkcs1v15encode};bt=0x01;}else if(scheme==='NONE'||scheme==='NULL'||scheme===null){scheme={encode:function encode(){return md;}};bt=0x01;}// encode and then encrypt
var d=scheme.encode(md,key.n.bitLength());return pki.rsa.encrypt(d,key,bt);};return key;};/**
 * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.
 *
 * @param rsaKey the ASN.1 RSAPrivateKey.
 *
 * @return the ASN.1 PrivateKeyInfo.
 */pki.wrapRsaPrivateKey=function(rsaKey){// PrivateKeyInfo
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (0)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(0).getBytes()),// privateKeyAlgorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// PrivateKey
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(rsaKey).getBytes())]);};/**
 * Converts a private key from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a PrivateKeyInfo containing an
 *          RSAPrivateKey or an RSAPrivateKey.
 *
 * @return the private key.
 */pki.privateKeyFromAsn1=function(obj){// get PrivateKeyInfo
var capture={};var errors=[];if(asn1.validate(obj,privateKeyValidator,capture,errors)){obj=asn1.fromDer(forge.util.createBuffer(capture.privateKey));}// get RSAPrivateKey
capture={};errors=[];if(!asn1.validate(obj,rsaPrivateKeyValidator,capture,errors)){var error=new Error('Cannot read private key. '+'ASN.1 object does not contain an RSAPrivateKey.');error.errors=errors;throw error;}// Note: Version is currently ignored.
// capture.privateKeyVersion
// FIXME: inefficient, get a BigInteger that uses byte strings
var n,e,d,p,q,dP,dQ,qInv;n=forge.util.createBuffer(capture.privateKeyModulus).toHex();e=forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();d=forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();p=forge.util.createBuffer(capture.privateKeyPrime1).toHex();q=forge.util.createBuffer(capture.privateKeyPrime2).toHex();dP=forge.util.createBuffer(capture.privateKeyExponent1).toHex();dQ=forge.util.createBuffer(capture.privateKeyExponent2).toHex();qInv=forge.util.createBuffer(capture.privateKeyCoefficient).toHex();// set private key
return pki.setRsaPrivateKey(new BigInteger(n,16),new BigInteger(e,16),new BigInteger(d,16),new BigInteger(p,16),new BigInteger(q,16),new BigInteger(dP,16),new BigInteger(dQ,16),new BigInteger(qInv,16));};/**
 * Converts a private key to an ASN.1 RSAPrivateKey.
 *
 * @param key the private key.
 *
 * @return the ASN.1 representation of an RSAPrivateKey.
 */pki.privateKeyToAsn1=pki.privateKeyToRSAPrivateKey=function(key){// RSAPrivateKey
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (0 = only 2 primes, 1 multiple primes)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(0).getBytes()),// modulus (n)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.n)),// publicExponent (e)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.e)),// privateExponent (d)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.d)),// privateKeyPrime1 (p)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.p)),// privateKeyPrime2 (q)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.q)),// privateKeyExponent1 (dP)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.dP)),// privateKeyExponent2 (dQ)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.dQ)),// coefficient (qInv)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.qInv))]);};/**
 * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @return the public key.
 */pki.publicKeyFromAsn1=function(obj){// get SubjectPublicKeyInfo
var capture={};var errors=[];if(asn1.validate(obj,publicKeyValidator,capture,errors)){// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){var error=new Error('Cannot read public key. Unknown OID.');error.oid=oid;throw error;}obj=capture.rsaPublicKey;}// get RSA params
errors=[];if(!asn1.validate(obj,rsaPublicKeyValidator,capture,errors)){var error=new Error('Cannot read public key. '+'ASN.1 object does not contain an RSAPublicKey.');error.errors=errors;throw error;}// FIXME: inefficient, get a BigInteger that uses byte strings
var n=forge.util.createBuffer(capture.publicKeyModulus).toHex();var e=forge.util.createBuffer(capture.publicKeyExponent).toHex();// set public key
return pki.setRsaPublicKey(new BigInteger(n,16),new BigInteger(e,16));};/**
 * Converts a public key to an ASN.1 SubjectPublicKeyInfo.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a SubjectPublicKeyInfo.
 */pki.publicKeyToAsn1=pki.publicKeyToSubjectPublicKeyInfo=function(key){// SubjectPublicKeyInfo
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AlgorithmIdentifier
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),// parameters (null)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// subjectPublicKey
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,[pki.publicKeyToRSAPublicKey(key)])]);};/**
 * Converts a public key to an ASN.1 RSAPublicKey.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a RSAPublicKey.
 */pki.publicKeyToRSAPublicKey=function(key){// RSAPublicKey
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// modulus (n)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.n)),// publicExponent (e)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.e))]);};/**
 * Encodes a message using PKCS#1 v1.5 padding.
 *
 * @param m the message to encode.
 * @param key the RSA key to use.
 * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02
 *          (for encryption).
 *
 * @return the padded byte buffer.
 */function _encodePkcs1_v1_5(m,key,bt){var eb=forge.util.createBuffer();// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);/* use PKCS#1 v1.5 padding */if(m.length>k-11){var error=new Error('Message is too long for PKCS#1 v1.5 padding.');error.length=m.length;error.max=k-11;throw error;}/* A block type BT, a padding string PS, and the data D shall be
    formatted into an octet string EB, the encryption block:

    EB = 00 || BT || PS || 00 || D

    The block type BT shall be a single octet indicating the structure of
    the encryption block. For this version of the document it shall have
    value 00, 01, or 02. For a private-key operation, the block type
    shall be 00 or 01. For a public-key operation, it shall be 02.

    The padding string PS shall consist of k-3-||D|| octets. For block
    type 00, the octets shall have value 00; for block type 01, they
    shall have value FF; and for block type 02, they shall be
    pseudorandomly generated and nonzero. This makes the length of the
    encryption block EB equal to k. */ // build the encryption block
eb.putByte(0x00);eb.putByte(bt);// create the padding
var padNum=k-3-m.length;var padByte;// private key op
if(bt===0x00||bt===0x01){padByte=bt===0x00?0x00:0xFF;for(var i=0;i<padNum;++i){eb.putByte(padByte);}}else{// public key op
// pad with random non-zero values
while(padNum>0){var numZeros=0;var padBytes=forge.random.getBytes(padNum);for(var i=0;i<padNum;++i){padByte=padBytes.charCodeAt(i);if(padByte===0){++numZeros;}else{eb.putByte(padByte);}}padNum=numZeros;}}// zero followed by message
eb.putByte(0x00);eb.putBytes(m);return eb;}/**
 * Decodes a message using PKCS#1 v1.5 padding.
 *
 * @param em the message to decode.
 * @param key the RSA key to use.
 * @param pub true if the key is a public key, false if it is private.
 * @param ml the message length, if specified.
 *
 * @return the decoded bytes.
 */function _decodePkcs1_v1_5(em,key,pub,ml){// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);/* It is an error if any of the following conditions occurs:

    1. The encryption block EB cannot be parsed unambiguously.
    2. The padding string PS consists of fewer than eight octets
      or is inconsisent with the block type BT.
    3. The decryption process is a public-key operation and the block
      type BT is not 00 or 01, or the decryption process is a
      private-key operation and the block type is not 02.
   */ // parse the encryption block
var eb=forge.util.createBuffer(em);var first=eb.getByte();var bt=eb.getByte();if(first!==0x00||pub&&bt!==0x00&&bt!==0x01||!pub&&bt!=0x02||pub&&bt===0x00&&typeof ml==='undefined'){throw new Error('Encryption block is invalid.');}var padNum=0;if(bt===0x00){// check all padding bytes for 0x00
padNum=k-3-ml;for(var i=0;i<padNum;++i){if(eb.getByte()!==0x00){throw new Error('Encryption block is invalid.');}}}else if(bt===0x01){// find the first byte that isn't 0xFF, should be after all padding
padNum=0;while(eb.length()>1){if(eb.getByte()!==0xFF){--eb.read;break;}++padNum;}}else if(bt===0x02){// look for 0x00 byte
padNum=0;while(eb.length()>1){if(eb.getByte()===0x00){--eb.read;break;}++padNum;}}// zero must be 0x00 and padNum must be (k - 3 - message length)
var zero=eb.getByte();if(zero!==0x00||padNum!==k-3-eb.length()){throw new Error('Encryption block is invalid.');}return eb.getBytes();}/**
 * Runs the key-generation algorithm asynchronously, either in the background
 * via Web Workers, or using the main thread and setImmediate.
 *
 * @param state the key-pair generation state.
 * @param [options] options for key-pair generation:
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2, -1 to use estimated cores minus one).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 * @param callback(err, keypair) called once the operation completes.
 */function _generateKeyPair(state,options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};var opts={algorithm:{name:options.algorithm||'PRIMEINC',options:{workers:options.workers||2,workLoad:options.workLoad||100,workerScript:options.workerScript}}};if('prng'in options){opts.prng=options.prng;}generate();function generate(){// find p and then q (done in series to simplify)
getPrime(state.pBits,function(err,num){if(err){return callback(err);}state.p=num;if(state.q!==null){return finish(err,state.q);}getPrime(state.qBits,finish);});}function getPrime(bits,callback){forge.prime.generateProbablePrime(bits,opts,callback);}function finish(err,num){if(err){return callback(err);}// set q
state.q=num;// ensure p is larger than q (swap them if not)
if(state.p.compareTo(state.q)<0){var tmp=state.p;state.p=state.q;state.q=tmp;}// ensure p is coprime with e
if(state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)!==0){state.p=null;generate();return;}// ensure q is coprime with e
if(state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)!==0){state.q=null;getPrime(state.qBits,finish);return;}// compute phi: (p - 1)(q - 1) (Euler's totient function)
state.p1=state.p.subtract(BigInteger.ONE);state.q1=state.q.subtract(BigInteger.ONE);state.phi=state.p1.multiply(state.q1);// ensure e and phi are coprime
if(state.phi.gcd(state.e).compareTo(BigInteger.ONE)!==0){// phi and e aren't coprime, so generate a new p and q
state.p=state.q=null;generate();return;}// create n, ensure n is has the right number of bits
state.n=state.p.multiply(state.q);if(state.n.bitLength()!==state.bits){// failed, get new q
state.q=null;getPrime(state.qBits,finish);return;}// set keys
var d=state.e.modInverse(state.phi);state.keys={privateKey:pki.rsa.setPrivateKey(state.n,state.e,d,state.p,state.q,d.mod(state.p1),d.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)};callback(null,state.keys);}}/**
 * Converts a positive BigInteger into 2's-complement big-endian bytes.
 *
 * @param b the big integer to convert.
 *
 * @return the bytes.
 */function _bnToBytes(b){// prepend 0x00 if first byte >= 0x80
var hex=b.toString(16);if(hex[0]>='8'){hex='00'+hex;}var bytes=forge.util.hexToBytes(hex);// ensure integer is minimally-encoded
if(bytes.length>1&&(// leading 0x00 for positive integer
bytes.charCodeAt(0)===0&&(bytes.charCodeAt(1)&0x80)===0||// leading 0xFF for negative integer
bytes.charCodeAt(0)===0xFF&&(bytes.charCodeAt(1)&0x80)===0x80)){return bytes.substr(1);}return bytes;}/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */function _getMillerRabinTests(bits){if(bits<=100)return 27;if(bits<=150)return 18;if(bits<=200)return 15;if(bits<=250)return 12;if(bits<=300)return 9;if(bits<=350)return 8;if(bits<=400)return 7;if(bits<=500)return 6;if(bits<=600)return 5;if(bits<=800)return 4;if(bits<=1250)return 3;return 2;}/**
 * Performs feature detection on the SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */function _detectSubtleCrypto(fn){return typeof window!=='undefined'&&_typeof(window.crypto)==='object'&&_typeof(window.crypto.subtle)==='object'&&typeof window.crypto.subtle[fn]==='function';}/**
 * Performs feature detection on the deprecated Microsoft Internet Explorer
 * outdated SubtleCrypto interface. This function should only be used after
 * checking for the modern, standard SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */function _detectSubtleMsCrypto(fn){return typeof window!=='undefined'&&_typeof(window.msCrypto)==='object'&&_typeof(window.msCrypto.subtle)==='object'&&typeof window.msCrypto.subtle[fn]==='function';}function _intToUint8Array(x){var bytes=forge.util.hexToBytes(x.toString(16));var buffer=new Uint8Array(bytes.length);for(var i=0;i<bytes.length;++i){buffer[i]=bytes.charCodeAt(i);}return buffer;}function _privateKeyFromJwk(jwk){if(jwk.kty!=='RSA'){throw new Error('Unsupported key algorithm "'+jwk.kty+'"; algorithm must be "RSA".');}return pki.setRsaPrivateKey(_base64ToBigInt(jwk.n),_base64ToBigInt(jwk.e),_base64ToBigInt(jwk.d),_base64ToBigInt(jwk.p),_base64ToBigInt(jwk.q),_base64ToBigInt(jwk.dp),_base64ToBigInt(jwk.dq),_base64ToBigInt(jwk.qi));}function _publicKeyFromJwk(jwk){if(jwk.kty!=='RSA'){throw new Error('Key algorithm must be "RSA".');}return pki.setRsaPublicKey(_base64ToBigInt(jwk.n),_base64ToBigInt(jwk.e));}function _base64ToBigInt(b64){return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)),16);}/***/},/* 7 */ /***/function(module,exports,__webpack_require__){/**
 * Advanced Encryption Standard (AES) implementation.
 *
 * This implementation is based on the public domain library 'jscrypto' which
 * was written by:
 *
 * Emily Stark (estark@stanford.edu)
 * Mike Hamburg (mhamburg@stanford.edu)
 * Dan Boneh (dabo@cs.stanford.edu)
 *
 * Parts of this code are based on the OpenSSL implementation of AES:
 * http://www.openssl.org
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(10);__webpack_require__(11);__webpack_require__(1);/* AES API */module.exports=forge.aes=forge.aes||{};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.startEncrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:false,mode:mode});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.createEncryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:false,mode:mode});};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.startDecrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:true,mode:mode});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.createDecryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:true,mode:mode});};/**
 * Creates a new AES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the AES algorithm object.
 */forge.aes.Algorithm=function(name,mode){if(!init){initialize();}var self=this;self.name=name;self.mode=new mode({blockSize:16,cipher:{encrypt:function encrypt(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,false);},decrypt:function decrypt(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,true);}}});self._init=false;};/**
 * Initializes this AES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */forge.aes.Algorithm.prototype.initialize=function(options){if(this._init){return;}var key=options.key;var tmp;/* Note: The key may be a string of bytes, an array of bytes, a byte
    buffer, or an array of 32-bit integers. If the key is in bytes, then
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit
    integers, it must be 4, 6, or 8 integers long. */if(typeof key==='string'&&(key.length===16||key.length===24||key.length===32)){// convert key string into byte buffer
key=forge.util.createBuffer(key);}else if(forge.util.isArray(key)&&(key.length===16||key.length===24||key.length===32)){// convert key integer array into byte buffer
tmp=key;key=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){key.putByte(tmp[i]);}}// convert key byte buffer into 32-bit integer array
if(!forge.util.isArray(key)){tmp=key;key=[];// key lengths of 16, 24, 32 bytes allowed
var len=tmp.length();if(len===16||len===24||len===32){len=len>>>2;for(var i=0;i<len;++i){key.push(tmp.getInt32());}}}// key must be an array of 32-bit integers by now
if(!forge.util.isArray(key)||!(key.length===4||key.length===6||key.length===8)){throw new Error('Invalid key parameter.');}// encryption operation is always used for these modes
var mode=this.mode.name;var encryptOp=['CFB','OFB','CTR','GCM'].indexOf(mode)!==-1;// do key expansion
this._w=_expandKey(key,options.decrypt&&!encryptOp);this._init=true;};/**
 * Expands a key. Typically only used for testing.
 *
 * @param key the symmetric key to expand, as an array of 32-bit words.
 * @param decrypt true to expand for decryption, false for encryption.
 *
 * @return the expanded key.
 */forge.aes._expandKey=function(key,decrypt){if(!init){initialize();}return _expandKey(key,decrypt);};/**
 * Updates a single block. Typically only used for testing.
 *
 * @param w the expanded key to use.
 * @param input an array of block-size 32-bit words.
 * @param output an array of block-size 32-bit words.
 * @param decrypt true to decrypt, false to encrypt.
 */forge.aes._updateBlock=_updateBlock;/** Register AES algorithms **/registerAlgorithm('AES-ECB',forge.cipher.modes.ecb);registerAlgorithm('AES-CBC',forge.cipher.modes.cbc);registerAlgorithm('AES-CFB',forge.cipher.modes.cfb);registerAlgorithm('AES-OFB',forge.cipher.modes.ofb);registerAlgorithm('AES-CTR',forge.cipher.modes.ctr);registerAlgorithm('AES-GCM',forge.cipher.modes.gcm);function registerAlgorithm(name,mode){var factory=function factory(){return new forge.aes.Algorithm(name,mode);};forge.cipher.registerAlgorithm(name,factory);}/** AES implementation **/var init=false;// not yet initialized
var Nb=4;// number of words comprising the state (AES = 4)
var sbox;// non-linear substitution table used in key expansion
var isbox;// inversion of sbox
var rcon;// round constant word array
var mix;// mix-columns table
var imix;// inverse mix-columns table
/**
 * Performs initialization, ie: precomputes tables to optimize for speed.
 *
 * One way to understand how AES works is to imagine that 'addition' and
 * 'multiplication' are interfaces that require certain mathematical
 * properties to hold true (ie: they are associative) but they might have
 * different implementations and produce different kinds of results ...
 * provided that their mathematical properties remain true. AES defines
 * its own methods of addition and multiplication but keeps some important
 * properties the same, ie: associativity and distributivity. The
 * explanation below tries to shed some light on how AES defines addition
 * and multiplication of bytes and 32-bit words in order to perform its
 * encryption and decryption algorithms.
 *
 * The basics:
 *
 * The AES algorithm views bytes as binary representations of polynomials
 * that have either 1 or 0 as the coefficients. It defines the addition
 * or subtraction of two bytes as the XOR operation. It also defines the
 * multiplication of two bytes as a finite field referred to as GF(2^8)
 * (Note: 'GF' means "Galois Field" which is a field that contains a finite
 * number of elements so GF(2^8) has 256 elements).
 *
 * This means that any two bytes can be represented as binary polynomials;
 * when they multiplied together and modularly reduced by an irreducible
 * polynomial of the 8th degree, the results are the field GF(2^8). The
 * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
 * This multiplication is associative with 0x01 as the identity:
 *
 * (b * 0x01 = GF(b, 0x01) = b).
 *
 * The operation GF(b, 0x02) can be performed at the byte level by left
 * shifting b once and then XOR'ing it (to perform the modular reduction)
 * with 0x11b if b is >= 128. Repeated application of the multiplication
 * of 0x02 can be used to implement the multiplication of any two bytes.
 *
 * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
 * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
 * factors can each be multiplied by 0x57 and then added together. To do
 * the multiplication, values for 0x57 multiplied by each of these 3 factors
 * can be precomputed and stored in a table. To add them, the values from
 * the table are XOR'd together.
 *
 * AES also defines addition and multiplication of words, that is 4-byte
 * numbers represented as polynomials of 3 degrees where the coefficients
 * are the values of the bytes.
 *
 * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
 *
 * Addition is performed by XOR'ing like powers of x. Multiplication
 * is performed in two steps, the first is an algebriac expansion as
 * you would do normally (where addition is XOR). But the result is
 * a polynomial larger than 3 degrees and thus it cannot fit in a word. So
 * next the result is modularly reduced by an AES-specific polynomial of
 * degree 4 which will always produce a polynomial of less than 4 degrees
 * such that it will fit in a word. In AES, this polynomial is x^4 + 1.
 *
 * The modular product of two polynomials 'a' and 'b' is thus:
 *
 * d(x) = d3x^3 + d2x^2 + d1x + d0
 * with
 * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
 * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
 * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
 * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
 *
 * As a matrix:
 *
 * [d0] = [a0 a3 a2 a1][b0]
 * [d1]   [a1 a0 a3 a2][b1]
 * [d2]   [a2 a1 a0 a3][b2]
 * [d3]   [a3 a2 a1 a0][b3]
 *
 * Special polynomials defined by AES (0x02 == {02}):
 * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
 * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
 *
 * These polynomials are used in the MixColumns() and InverseMixColumns()
 * operations, respectively, to cause each element in the state to affect
 * the output (referred to as diffusing).
 *
 * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
 * polynomial x3.
 *
 * The ShiftRows() method modifies the last 3 rows in the state (where
 * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
 * The 1st byte in the second row is moved to the end of the row. The 1st
 * and 2nd bytes in the third row are moved to the end of the row. The 1st,
 * 2nd, and 3rd bytes are moved in the fourth row.
 *
 * More details on how AES arithmetic works:
 *
 * In the polynomial representation of binary numbers, XOR performs addition
 * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
 * corresponds with the multiplication of polynomials modulo an irreducible
 * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply
 * polynomial 'a' with polynomial 'b' and then do a modular reduction by
 * an AES-specific irreducible polynomial of degree 8.
 *
 * A polynomial is irreducible if its only divisors are one and itself. For
 * the AES algorithm, this irreducible polynomial is:
 *
 * m(x) = x^8 + x^4 + x^3 + x + 1,
 *
 * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:
 * 100011011 = 283 = 0x11b.
 *
 * For example, GF(0x57, 0x83) = 0xc1 because
 *
 * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1
 * 0x85 = 131 = 10000101 = x^7 + x + 1
 *
 * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)
 * =  x^13 + x^11 + x^9 + x^8 + x^7 +
 *    x^7 + x^5 + x^3 + x^2 + x +
 *    x^6 + x^4 + x^2 + x + 1
 * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y
 *    y modulo (x^8 + x^4 + x^3 + x + 1)
 * =  x^7 + x^6 + 1.
 *
 * The modular reduction by m(x) guarantees the result will be a binary
 * polynomial of less than degree 8, so that it can fit in a byte.
 *
 * The operation to multiply a binary polynomial b with x (the polynomial
 * x in binary representation is 00000010) is:
 *
 * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1
 *
 * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the
 * most significant bit is 0 in b) then the result is already reduced. If
 * it is 1, then we can reduce it by subtracting m(x) via an XOR.
 *
 * It follows that multiplication by x (00000010 or 0x02) can be implemented
 * by performing a left shift followed by a conditional bitwise XOR with
 * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by
 * higher powers of x can be implemented by repeated application of xtime().
 *
 * By adding intermediate results, multiplication by any constant can be
 * implemented. For instance:
 *
 * GF(0x57, 0x13) = 0xfe because:
 *
 * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)
 *
 * Note: We XOR with 0x11b instead of 0x1b because in javascript our
 * datatype for b can be larger than 1 byte, so a left shift will not
 * automatically eliminate bits that overflow a byte ... by XOR'ing the
 * overflow bit with 1 (the extra one from 0x11b) we zero it out.
 *
 * GF(0x57, 0x02) = xtime(0x57) = 0xae
 * GF(0x57, 0x04) = xtime(0xae) = 0x47
 * GF(0x57, 0x08) = xtime(0x47) = 0x8e
 * GF(0x57, 0x10) = xtime(0x8e) = 0x07
 *
 * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))
 *
 * And by the distributive property (since XOR is addition and GF() is
 * multiplication):
 *
 * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)
 * = 0x57 ^ 0xae ^ 0x07
 * = 0xfe.
 */function initialize(){init=true;/* Populate the Rcon table. These are the values given by
    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)
    in the field of GF(2^8), where i starts at 1.

    rcon[0] = [0x00, 0x00, 0x00, 0x00]
    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1
    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2
    ...
    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B
    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36

    We only store the first byte because it is the only one used.
  */rcon=[0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36];// compute xtime table which maps i onto GF(i, 0x02)
var xtime=new Array(256);for(var i=0;i<128;++i){xtime[i]=i<<1;xtime[i+128]=i+128<<1^0x11B;}// compute all other tables
sbox=new Array(256);isbox=new Array(256);mix=new Array(4);imix=new Array(4);for(var i=0;i<4;++i){mix[i]=new Array(256);imix[i]=new Array(256);}var e=0,ei=0,e2,e4,e8,sx,sx2,me,ime;for(var i=0;i<256;++i){/* We need to generate the SubBytes() sbox and isbox tables so that
      we can perform byte substitutions. This requires us to traverse
      all of the elements in GF, find their multiplicative inverses,
      and apply to each the following affine transformation:

      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^
            b(i + 7) mod 8 ^ ci
      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the
      ith bit of a byte c with the value {63} or {01100011}.

      It is possible to traverse every possible value in a Galois field
      using what is referred to as a 'generator'. There are many
      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully
      traverse GF we iterate 255 times, multiplying by our generator
      each time.

      On each iteration we can determine the multiplicative inverse for
      the current element.

      Suppose there is an element in GF 'e'. For a given generator 'g',
      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns
      out that if use the inverse of a generator as another generator
      it will produce all of the corresponding multiplicative inverses
      at the same time. For this reason, we choose 5 as our inverse
      generator because it only requires 2 multiplies and 1 add and its
      inverse, 82, requires relatively few operations as well.

      In order to apply the affine transformation, the multiplicative
      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a
      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and
      'x'. Then 's' is left shifted and the high bit of 's' is made the
      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd
      with 's' and stored in 'x'. On each subsequent iteration the same
      operation is performed. When 4 iterations are complete, 'x' is
      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.
      For example:

      s = 01000001
      x = 01000001

      iteration 1: s = 10000010, x ^= s
      iteration 2: s = 00000101, x ^= s
      iteration 3: s = 00001010, x ^= s
      iteration 4: s = 00010100, x ^= s
      x ^= 0x63

      This can be done with a loop where s = (s << 1) | (s >> 7). However,
      it can also be done by using a single 16-bit (in this case 32-bit)
      number 'sx'. Since XOR is an associative operation, we can set 'sx'
      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.
      The most significant bits will flow into the high 8 bit positions
      and be correctly XOR'd with one another. All that remains will be
      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits
      afterwards.

      At the same time we're populating sbox and isbox we can precompute
      the multiplication we'll need to do to do MixColumns() later.
    */ // apply affine transformation
sx=ei^ei<<1^ei<<2^ei<<3^ei<<4;sx=sx>>8^sx&255^0x63;// update tables
sbox[e]=sx;isbox[sx]=e;/* Mixing columns is done using matrix multiplication. The columns
      that are to be mixed are each a single word in the current state.
      The state has Nb columns (4 columns). Therefore each column is a
      4 byte word. So to mix the columns in a single column 'c' where
      its rows are r0, r1, r2, and r3, we use the following matrix
      multiplication:

      [2 3 1 1]*[r0,c]=[r'0,c]
      [1 2 3 1] [r1,c] [r'1,c]
      [1 1 2 3] [r2,c] [r'2,c]
      [3 1 1 2] [r3,c] [r'3,c]

      r0, r1, r2, and r3 are each 1 byte of one of the words in the
      state (a column). To do matrix multiplication for each mixed
      column c' we multiply the corresponding row from the left matrix
      with the corresponding column from the right matrix. In total, we
      get 4 equations:

      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c
      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c
      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c
      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c

      As usual, the multiplication is as previously defined and the
      addition is XOR. In order to optimize mixing columns we can store
      the multiplication results in tables. If you think of the whole
      column as a word (it might help to visualize by mentally rotating
      the equations above by counterclockwise 90 degrees) then you can
      see that it would be useful to map the multiplications performed on
      each byte (r0, r1, r2, r3) onto a word as well. For instance, we
      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the
      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two
      respectively in the middle). This means that a table can be
      constructed that uses r0 as an index to the word. We can do the
      same with r1, r2, and r3, creating a total of 4 tables.

      To construct a full c', we can just look up each byte of c in
      their respective tables and XOR the results together.

      Also, to build each table we only have to calculate the word
      for 2,1,1,3 for every byte ... which we can do on each iteration
      of this loop since we will iterate over every byte. After we have
      calculated 2,1,1,3 we can get the results for the other tables
      by cycling the byte at the end to the beginning. For instance
      we can take the result of table 2,1,1,3 and produce table 3,2,1,1
      by moving the right most byte to the left most position just like
      how you can imagine the 3 moved out of 2,1,1,3 and to the front
      to produce 3,2,1,1.

      There is another optimization in that the same multiples of
      the current element we need in order to advance our generator
      to the next iteration can be reused in performing the 2,1,1,3
      calculation. We also calculate the inverse mix column tables,
      with e,9,d,b being the inverse of 2,1,1,3.

      When we're done, and we need to actually mix columns, the first
      byte of each state word should be put through mix[0] (2,1,1,3),
      the second through mix[1] (3,2,1,1) and so forth. Then they should
      be XOR'd together to produce the fully mixed column.
    */ // calculate mix and imix table values
sx2=xtime[sx];e2=xtime[e];e4=xtime[e2];e8=xtime[e4];me=sx2<<24^// 2
sx<<16^// 1
sx<<8^(// 1
sx^sx2);// 3
ime=(e2^e4^e8)<<24^// E (14)
(e^e8)<<16^// 9
(e^e4^e8)<<8^(// D (13)
e^e2^e8);// B (11)
// produce each of the mix tables by rotating the 2,1,1,3 value
for(var n=0;n<4;++n){mix[n][e]=me;imix[n][sx]=ime;// cycle the right most byte to the left most position
// ie: 2,1,1,3 becomes 3,2,1,1
me=me<<24|me>>>8;ime=ime<<24|ime>>>8;}// get next element and inverse
if(e===0){// 1 is the inverse of 1
e=ei=1;}else{// e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)
// ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)
e=e2^xtime[xtime[xtime[e2^e8]]];ei^=xtime[xtime[ei]];}}}/**
 * Generates a key schedule using the AES key expansion algorithm.
 *
 * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
 * routine to generate a key schedule. The Key Expansion generates a total
 * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
 * and each of the Nr rounds requires Nb words of key data. The resulting
 * key schedule consists of a linear array of 4-byte words, denoted [wi ],
 * with i in the range 0 ≤ i < Nb(Nr + 1).
 *
 * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
 * AES-128 (Nb=4, Nk=4, Nr=10)
 * AES-192 (Nb=4, Nk=6, Nr=12)
 * AES-256 (Nb=4, Nk=8, Nr=14)
 * Note: Nr=Nk+6.
 *
 * Nb is the number of columns (32-bit words) comprising the State (or
 * number of bytes in a block). For AES, Nb=4.
 *
 * @param key the key to schedule (as an array of 32-bit words).
 * @param decrypt true to modify the key schedule to decrypt, false not to.
 *
 * @return the generated key schedule.
 */function _expandKey(key,decrypt){// copy the key's words to initialize the key schedule
var w=key.slice(0);/* RotWord() will rotate a word, moving the first byte to the last
    byte's position (shifting the other bytes left).

    We will be getting the value of Rcon at i / Nk. 'i' will iterate
    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in
    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from
    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will
    increase by 1. We use a counter iNk to keep track of this.
   */ // go through the rounds expanding the key
var temp,iNk=1;var Nk=w.length;var Nr1=Nk+6+1;var end=Nb*Nr1;for(var i=Nk;i<end;++i){temp=w[i-1];if(i%Nk===0){// temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]
temp=sbox[temp>>>16&255]<<24^sbox[temp>>>8&255]<<16^sbox[temp&255]<<8^sbox[temp>>>24]^rcon[iNk]<<24;iNk++;}else if(Nk>6&&i%Nk===4){// temp = SubWord(temp)
temp=sbox[temp>>>24]<<24^sbox[temp>>>16&255]<<16^sbox[temp>>>8&255]<<8^sbox[temp&255];}w[i]=w[i-Nk]^temp;}/* When we are updating a cipher block we always use the code path for
     encryption whether we are decrypting or not (to shorten code and
     simplify the generation of look up tables). However, because there
     are differences in the decryption algorithm, other than just swapping
     in different look up tables, we must transform our key schedule to
     account for these changes:

     1. The decryption algorithm gets its key rounds in reverse order.
     2. The decryption algorithm adds the round key before mixing columns
       instead of afterwards.

     We don't need to modify our key schedule to handle the first case,
     we can just traverse the key schedule in reverse order when decrypting.

     The second case requires a little work.

     The tables we built for performing rounds will take an input and then
     perform SubBytes() and MixColumns() or, for the decrypt version,
     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires
     us to AddRoundKey() before InvMixColumns(). This means we'll need to
     apply some transformations to the round key to inverse-mix its columns
     so they'll be correct for moving AddRoundKey() to after the state has
     had its columns inverse-mixed.

     To inverse-mix the columns of the state when we're decrypting we use a
     lookup table that will apply InvSubBytes() and InvMixColumns() at the
     same time. However, the round key's bytes are not inverse-substituted
     in the decryption algorithm. To get around this problem, we can first
     substitute the bytes in the round key so that when we apply the
     transformation via the InvSubBytes()+InvMixColumns() table, it will
     undo our substitution leaving us with the original value that we
     want -- and then inverse-mix that value.

     This change will correctly alter our key schedule so that we can XOR
     each round key with our already transformed decryption state. This
     allows us to use the same code path as the encryption algorithm.

     We make one more change to the decryption key. Since the decryption
     algorithm runs in reverse from the encryption algorithm, we reverse
     the order of the round keys to avoid having to iterate over the key
     schedule backwards when running the encryption algorithm later in
     decryption mode. In addition to reversing the order of the round keys,
     we also swap each round key's 2nd and 4th rows. See the comments
     section where rounds are performed for more details about why this is
     done. These changes are done inline with the other substitution
     described above.
  */if(decrypt){var tmp;var m0=imix[0];var m1=imix[1];var m2=imix[2];var m3=imix[3];var wnew=w.slice(0);end=w.length;for(var i=0,wi=end-Nb;i<end;i+=Nb,wi-=Nb){// do not sub the first or last round key (round keys are Nb
// words) as no column mixing is performed before they are added,
// but do change the key order
if(i===0||i===end-Nb){wnew[i]=w[wi];wnew[i+1]=w[wi+3];wnew[i+2]=w[wi+2];wnew[i+3]=w[wi+1];}else{// substitute each round key byte because the inverse-mix
// table will inverse-substitute it (effectively cancel the
// substitution because round key bytes aren't sub'd in
// decryption mode) and swap indexes 3 and 1
for(var n=0;n<Nb;++n){tmp=w[wi+n];wnew[i+(3&-n)]=m0[sbox[tmp>>>24]]^m1[sbox[tmp>>>16&255]]^m2[sbox[tmp>>>8&255]]^m3[sbox[tmp&255]];}}}w=wnew;}return w;}/**
 * Updates a single block (16 bytes) using AES. The update will either
 * encrypt or decrypt the block.
 *
 * @param w the key schedule.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */function _updateBlock(w,input,output,decrypt){/*
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr–1
      SubBytes(state)
      ShiftRows(state)
      MixColumns(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
  end

  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    for round = Nr-1 step -1 downto 1
      InvShiftRows(state)
      InvSubBytes(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
      InvMixColumns(state)
    end for
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
    out = state
  end
  */ // Encrypt: AddRoundKey(state, w[0, Nb-1])
// Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
var Nr=w.length/4-1;var m0,m1,m2,m3,sub;if(decrypt){m0=imix[0];m1=imix[1];m2=imix[2];m3=imix[3];sub=isbox;}else{m0=mix[0];m1=mix[1];m2=mix[2];m3=mix[3];sub=sbox;}var a,b,c,d,a2,b2,c2;a=input[0]^w[0];b=input[decrypt?3:1]^w[1];c=input[2]^w[2];d=input[decrypt?1:3]^w[3];var i=3;/* In order to share code we follow the encryption algorithm when both
    encrypting and decrypting. To account for the changes required in the
    decryption algorithm, we use different lookup tables when decrypting
    and use a modified key schedule to account for the difference in the
    order of transformations applied when performing rounds. We also get
    key rounds in reverse order (relative to encryption). */for(var round=1;round<Nr;++round){/* As described above, we'll be using table lookups to perform the
      column mixing. Each column is stored as a word in the state (the
      array 'input' has one column as a word at each index). In order to
      mix a column, we perform these transformations on each row in c,
      which is 1 byte in each word. The new column for c0 is c'0:

               m0      m1      m2      m3
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0

      So using mix tables where c0 is a word with r0 being its upper
      8 bits and r3 being its lower 8 bits:

      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]
      ...
      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]

      Therefore to mix the columns in each word in the state we
      do the following (& 255 omitted for brevity):
      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]

      However, before mixing, the algorithm requires us to perform
      ShiftRows(). The ShiftRows() transformation cyclically shifts the
      last 3 rows of the state over different offsets. The first row
      (r = 0) is not shifted.

      s'_r,c = s_r,(c + shift(r, Nb) mod Nb
      for 0 < r < 4 and 0 <= c < Nb and
      shift(1, 4) = 1
      shift(2, 4) = 2
      shift(3, 4) = 3.

      This causes the first byte in r = 1 to be moved to the end of
      the row, the first 2 bytes in r = 2 to be moved to the end of
      the row, the first 3 bytes in r = 3 to be moved to the end of
      the row:

      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]

      We can make these substitutions inline with our column mixing to
      generate an updated set of equations to produce each word in the
      state (note the columns have changed positions):

      c0 c1 c2 c3 => c0 c1 c2 c3
      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)
      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)
      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)

      Therefore:

      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3
      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3

      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0
      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0

      ... and so forth for c'2 and c'3. The important distinction is
      that the columns are cycling, with c0 being used with the m0
      map when calculating c0, but c1 being used with the m0 map when
      calculating c1 ... and so forth.

      When performing the inverse we transform the mirror image and
      skip the bottom row, instead of the top one, and move upwards:

      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption
      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)
      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption
      c3 c2 c1 c0    c3 c2 c1 c0

      If you compare the resulting matrices for ShiftRows()+MixColumns()
      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are
      different (in encrypt mode vs. decrypt mode). So in order to use
      the same code to handle both encryption and decryption, we will
      need to do some mapping.

      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be
      a row number in the state, then the resulting matrix in encryption
      mode for applying the above transformations would be:

      r1: a b c d
      r2: b c d a
      r3: c d a b
      r4: d a b c

      If we did the same in decryption mode we would get:

      r1: a d c b
      r2: b a d c
      r3: c b a d
      r4: d c b a

      If instead we swap d and b (set b=c3 and d=c1), then we get:

      r1: a b c d
      r2: d a b c
      r3: c d a b
      r4: b c d a

      Now the 1st and 3rd rows are the same as the encryption matrix. All
      we need to do then to make the mapping exactly the same is to swap
      the 2nd and 4th rows when in decryption mode. To do this without
      having to do it on each iteration, we swapped the 2nd and 4th rows
      in the decryption key schedule. We also have to do the swap above
      when we first pull in the input and when we set the final output. */a2=m0[a>>>24]^m1[b>>>16&255]^m2[c>>>8&255]^m3[d&255]^w[++i];b2=m0[b>>>24]^m1[c>>>16&255]^m2[d>>>8&255]^m3[a&255]^w[++i];c2=m0[c>>>24]^m1[d>>>16&255]^m2[a>>>8&255]^m3[b&255]^w[++i];d=m0[d>>>24]^m1[a>>>16&255]^m2[b>>>8&255]^m3[c&255]^w[++i];a=a2;b=b2;c=c2;}/*
    Encrypt:
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])

    Decrypt:
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
   */ // Note: rows are shifted inline
output[0]=sub[a>>>24]<<24^sub[b>>>16&255]<<16^sub[c>>>8&255]<<8^sub[d&255]^w[++i];output[decrypt?3:1]=sub[b>>>24]<<24^sub[c>>>16&255]<<16^sub[d>>>8&255]<<8^sub[a&255]^w[++i];output[2]=sub[c>>>24]<<24^sub[d>>>16&255]<<16^sub[a>>>8&255]<<8^sub[b&255]^w[++i];output[decrypt?1:3]=sub[d>>>24]<<24^sub[a>>>16&255]<<16^sub[b>>>8&255]<<8^sub[c&255]^w[++i];}/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('AES-<mode>', key);
 * forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates a deprecated AES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key and iv may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param options the options to use.
 *          key the symmetric key to use.
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */function _createCipher(options){options=options||{};var mode=(options.mode||'CBC').toUpperCase();var algorithm='AES-'+mode;var cipher;if(options.decrypt){cipher=forge.cipher.createDecipher(algorithm,options.key);}else{cipher=forge.cipher.createCipher(algorithm,options.key);}// backwards compatible start API
var start=cipher.start;cipher.start=function(iv,options){// backwards compatibility: support second arg as output buffer
var output=null;if(options instanceof forge.util.ByteBuffer){output=options;options={};}options=options||{};options.output=output;options.iv=iv;start.call(cipher,options);};return cipher;}/***/},/* 8 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
 *
 * See: RFC 1421.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 *
 * A Forge PEM object has the following fields:
 *
 * type: identifies the type of message (eg: "RSA PRIVATE KEY").
 *
 * procType: identifies the type of processing performed on the message,
 *   it has two subfields: version and type, eg: 4,ENCRYPTED.
 *
 * contentDomain: identifies the type of content in the message, typically
 *   only uses the value: "RFC822".
 *
 * dekInfo: identifies the message encryption algorithm and mode and includes
 *   any parameters for the algorithm, it has two subfields: algorithm and
 *   parameters, eg: DES-CBC,F8143EDE5960C597.
 *
 * headers: contains all other PEM encapsulated headers -- where order is
 *   significant (for pairing data like recipient ID + key info).
 *
 * body: the binary-encoded body.
 */var forge=__webpack_require__(0);__webpack_require__(1);// shortcut for pem API
var pem=module.exports=forge.pem=forge.pem||{};/**
 * Encodes (serializes) the given PEM object.
 *
 * @param msg the PEM message object to encode.
 * @param options the options to use:
 *          maxline the maximum characters per line for the body, (default: 64).
 *
 * @return the PEM-formatted string.
 */pem.encode=function(msg,options){options=options||{};var rval='-----BEGIN '+msg.type+'-----\r\n';// encode special headers
var header;if(msg.procType){header={name:'Proc-Type',values:[String(msg.procType.version),msg.procType.type]};rval+=foldHeader(header);}if(msg.contentDomain){header={name:'Content-Domain',values:[msg.contentDomain]};rval+=foldHeader(header);}if(msg.dekInfo){header={name:'DEK-Info',values:[msg.dekInfo.algorithm]};if(msg.dekInfo.parameters){header.values.push(msg.dekInfo.parameters);}rval+=foldHeader(header);}if(msg.headers){// encode all other headers
for(var i=0;i<msg.headers.length;++i){rval+=foldHeader(msg.headers[i]);}}// terminate header
if(msg.procType){rval+='\r\n';}// add body
rval+=forge.util.encode64(msg.body,options.maxline||64)+'\r\n';rval+='-----END '+msg.type+'-----\r\n';return rval;};/**
 * Decodes (deserializes) all PEM messages found in the given string.
 *
 * @param str the PEM-formatted string to decode.
 *
 * @return the PEM message objects in an array.
 */pem.decode=function(str){var rval=[];// split string into PEM messages (be lenient w/EOF on BEGIN line)
var rMessage=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;var rHeader=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;var rCRLF=/\r?\n/;var match;while(true){match=rMessage.exec(str);if(!match){break;}var msg={type:match[1],procType:null,contentDomain:null,dekInfo:null,headers:[],body:forge.util.decode64(match[3])};rval.push(msg);// no headers
if(!match[2]){continue;}// parse headers
var lines=match[2].split(rCRLF);var li=0;while(match&&li<lines.length){// get line, trim any rhs whitespace
var line=lines[li].replace(/\s+$/,'');// RFC2822 unfold any following folded lines
for(var nl=li+1;nl<lines.length;++nl){var next=lines[nl];if(!/\s/.test(next[0])){break;}line+=next;li=nl;}// parse header
match=line.match(rHeader);if(match){var header={name:match[1],values:[]};var values=match[2].split(',');for(var vi=0;vi<values.length;++vi){header.values.push(ltrim(values[vi]));}// Proc-Type must be the first header
if(!msg.procType){if(header.name!=='Proc-Type'){throw new Error('Invalid PEM formatted message. The first '+'encapsulated header must be "Proc-Type".');}else if(header.values.length!==2){throw new Error('Invalid PEM formatted message. The "Proc-Type" '+'header must have two subfields.');}msg.procType={version:values[0],type:values[1]};}else if(!msg.contentDomain&&header.name==='Content-Domain'){// special-case Content-Domain
msg.contentDomain=values[0]||'';}else if(!msg.dekInfo&&header.name==='DEK-Info'){// special-case DEK-Info
if(header.values.length===0){throw new Error('Invalid PEM formatted message. The "DEK-Info" '+'header must have at least one subfield.');}msg.dekInfo={algorithm:values[0],parameters:values[1]||null};}else{msg.headers.push(header);}}++li;}if(msg.procType==='ENCRYPTED'&&!msg.dekInfo){throw new Error('Invalid PEM formatted message. The "DEK-Info" '+'header must be present if "Proc-Type" is "ENCRYPTED".');}}if(rval.length===0){throw new Error('Invalid PEM formatted message.');}return rval;};function foldHeader(header){var rval=header.name+': ';// ensure values with CRLF are folded
var values=[];var insertSpace=function insertSpace(match,$1){return' '+$1;};for(var i=0;i<header.values.length;++i){values.push(header.values[i].replace(/^(\S+\r\n)/,insertSpace));}rval+=values.join(',')+'\r\n';// do folding
var length=0;var candidate=-1;for(var i=0;i<rval.length;++i,++length){if(length>65&&candidate!==-1){var insert=rval[candidate];if(insert===','){++candidate;rval=rval.substr(0,candidate)+'\r\n '+rval.substr(candidate);}else{rval=rval.substr(0,candidate)+'\r\n'+insert+rval.substr(candidate+1);}length=i-candidate-1;candidate=-1;++i;}else if(rval[i]===' '||rval[i]==='\t'||rval[i]===','){candidate=i;}}return rval;}function ltrim(str){return str.replace(/^\s+/,'');}/***/},/* 9 */ /***/function(module,exports,__webpack_require__){/**
 * Password-based encryption functions.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * An EncryptedPrivateKeyInfo:
 *
 * EncryptedPrivateKeyInfo ::= SEQUENCE {
 *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
 *   encryptedData        EncryptedData }
 *
 * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedData ::= OCTET STRING
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(2);__webpack_require__(12);__webpack_require__(4);__webpack_require__(3);__webpack_require__(13);__webpack_require__(8);__webpack_require__(5);__webpack_require__(25);__webpack_require__(6);__webpack_require__(1);if(typeof BigInteger==='undefined'){var BigInteger=forge.jsbn.BigInteger;}// shortcut for asn.1 API
var asn1=forge.asn1;/* Password-based encryption implementation. */var pki=forge.pki=forge.pki||{};module.exports=pki.pbe=forge.pbe=forge.pbe||{};var oids=pki.oids;// validator for an EncryptedPrivateKeyInfo structure
// Note: Currently only works w/algorithm params
var encryptedPrivateKeyValidator={name:'EncryptedPrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedPrivateKeyInfo.encryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encryptionOid'},{name:'AlgorithmIdentifier.parameters',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'encryptionParams'}]},{// encryptedData
name:'EncryptedPrivateKeyInfo.encryptedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encryptedData'}]};// validator for a PBES2Algorithms structure
// Note: Currently only works w/PBKDF2 + AES encryption schemes
var PBES2AlgorithmsValidator={name:'PBES2Algorithms',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.keyDerivationFunc',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.keyDerivationFunc.oid',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'kdfOid'},{name:'PBES2Algorithms.params',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.params.salt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'kdfSalt'},{name:'PBES2Algorithms.params.iterationCount',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'kdfIterationCount'},{name:'PBES2Algorithms.params.keyLength',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,optional:true,capture:'keyLength'},{// prf
name:'PBES2Algorithms.params.prf',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,value:[{name:'PBES2Algorithms.params.prf.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'prfOid'}]}]}]},{name:'PBES2Algorithms.encryptionScheme',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.encryptionScheme.oid',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encOid'},{name:'PBES2Algorithms.encryptionScheme.iv',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encIv'}]}]};var pkcs12PbeParamsValidator={name:'pkcs-12PbeParams',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'pkcs-12PbeParams.salt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'salt'},{name:'pkcs-12PbeParams.iterations',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'iterations'}]};/**
 * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.
 *
 * PBES2Algorithms ALGORITHM-IDENTIFIER ::=
 *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}
 *
 * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}
 *
 * PBES2-params ::= SEQUENCE {
 *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
 *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
 * }
 *
 * PBES2-KDFs ALGORITHM-IDENTIFIER ::=
 *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }
 *
 * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }
 *
 * PBKDF2-params ::= SEQUENCE {
 *   salt CHOICE {
 *     specified OCTET STRING,
 *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
 *   },
 *   iterationCount INTEGER (1..MAX),
 *   keyLength INTEGER (1..MAX) OPTIONAL,
 *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
 * }
 *
 * @param obj the ASN.1 PrivateKeyInfo object.
 * @param password the password to encrypt with.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          prfAlgorithm the PRF message digest algorithm to use
 *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptPrivateKeyInfo=function(obj,password,options){// set default options
options=options||{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||'aes128';options.prfAlgorithm=options.prfAlgorithm||'sha1';// generate PBE params
var salt=forge.random.getBytesSync(options.saltSize);var count=options.count;var countBytes=asn1.integerToDer(count);var dkLen;var encryptionAlgorithm;var encryptedData;if(options.algorithm.indexOf('aes')===0||options.algorithm==='des'){// do PBES2
var ivLen,encOid,cipherFn;switch(options.algorithm){case'aes128':dkLen=16;ivLen=16;encOid=oids['aes128-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'aes192':dkLen=24;ivLen=16;encOid=oids['aes192-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'aes256':dkLen=32;ivLen=16;encOid=oids['aes256-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'des':dkLen=8;ivLen=8;encOid=oids['desCBC'];cipherFn=forge.des.createEncryptionCipher;break;default:var error=new Error('Cannot encrypt private key. Unknown encryption algorithm.');error.algorithm=options.algorithm;throw error;}// get PRF message digest
var prfAlgorithm='hmacWith'+options.prfAlgorithm.toUpperCase();var md=prfAlgorithmToMessageDigest(prfAlgorithm);// encrypt private key using pbe SHA-1 and AES/DES
var dk=forge.pkcs5.pbkdf2(password,salt,count,dkLen,md);var iv=forge.random.getBytesSync(ivLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(asn1.toDer(obj));cipher.finish();encryptedData=cipher.output.getBytes();// get PBKDF2-params
var params=createPbkdf2Params(salt,countBytes,dkLen,prfAlgorithm);encryptionAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// keyDerivationFunc
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),// PBKDF2-params
params]),// encryptionScheme
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(encOid).getBytes()),// iv
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,iv)])])]);}else if(options.algorithm==='3des'){// Do PKCS12 PBE
dkLen=24;var saltBytes=new forge.util.ByteBuffer(salt);var dk=pki.pbe.generatePkcs12Key(password,saltBytes,1,count,dkLen);var iv=pki.pbe.generatePkcs12Key(password,saltBytes,2,count,dkLen);var cipher=forge.des.createEncryptionCipher(dk);cipher.start(iv);cipher.update(asn1.toDer(obj));cipher.finish();encryptedData=cipher.output.getBytes();encryptionAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),// pkcs-12PbeParams
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// salt
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,salt),// iteration count
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,countBytes.getBytes())])]);}else{var error=new Error('Cannot encrypt private key. Unknown encryption algorithm.');error.algorithm=options.algorithm;throw error;}// EncryptedPrivateKeyInfo
var rval=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// encryptionAlgorithm
encryptionAlgorithm,// encryptedData
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,encryptedData)]);return rval;};/**
 * Decrypts a ASN.1 PrivateKeyInfo object.
 *
 * @param obj the ASN.1 EncryptedPrivateKeyInfo object.
 * @param password the password to decrypt with.
 *
 * @return the ASN.1 PrivateKeyInfo on success, null on failure.
 */pki.decryptPrivateKeyInfo=function(obj,password){var rval=null;// get PBE params
var capture={};var errors=[];if(!asn1.validate(obj,encryptedPrivateKeyValidator,capture,errors)){var error=new Error('Cannot read encrypted private key. '+'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}// get cipher
var oid=asn1.derToOid(capture.encryptionOid);var cipher=pki.pbe.getCipher(oid,capture.encryptionParams,password);// get encrypted data
var encrypted=forge.util.createBuffer(capture.encryptedData);cipher.update(encrypted);if(cipher.finish()){rval=asn1.fromDer(cipher.output);}return rval;};/**
 * Converts a EncryptedPrivateKeyInfo to PEM format.
 *
 * @param epki the EncryptedPrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted encrypted private key.
 */pki.encryptedPrivateKeyToPem=function(epki,maxline){// convert to DER, then PEM-encode
var msg={type:'ENCRYPTED PRIVATE KEY',body:asn1.toDer(epki).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
 * is not performed.
 *
 * @param pem the EncryptedPrivateKeyInfo in PEM-format.
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptedPrivateKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='ENCRYPTED PRIVATE KEY'){var error=new Error('Could not convert encrypted private key from PEM; '+'PEM header type is "ENCRYPTED PRIVATE KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert encrypted private key from PEM; '+'PEM is encrypted.');}// convert DER to ASN.1 object
return asn1.fromDer(msg.body);};/**
 * Encrypts an RSA private key. By default, the key will be wrapped in
 * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.
 * This is the standard, preferred way to encrypt a private key.
 *
 * To produce a non-standard PEM-encrypted private key that uses encapsulated
 * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL
 * private key encryption), set the 'legacy' option to true. Note: Using this
 * option will cause the iteration count to be forced to 1.
 *
 * Note: The 'des' algorithm is supported, but it is not considered to be
 * secure because it only uses a single 56-bit key. If possible, it is highly
 * recommended that a different algorithm be used.
 *
 * @param rsaKey the RSA key to encrypt.
 * @param password the password to use.
 * @param options:
 *          algorithm: the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des', 'des').
 *          count: the iteration count to use.
 *          saltSize: the salt size to use.
 *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated
 *            headers (DEK-Info) private key.
 *
 * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptRsaPrivateKey=function(rsaKey,password,options){// standard PKCS#8
options=options||{};if(!options.legacy){// encrypt PrivateKeyInfo
var rval=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));rval=pki.encryptPrivateKeyInfo(rval,password,options);return pki.encryptedPrivateKeyToPem(rval);}// legacy non-PKCS#8
var algorithm;var iv;var dkLen;var cipherFn;switch(options.algorithm){case'aes128':algorithm='AES-128-CBC';dkLen=16;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'aes192':algorithm='AES-192-CBC';dkLen=24;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'aes256':algorithm='AES-256-CBC';dkLen=32;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'3des':algorithm='DES-EDE3-CBC';dkLen=24;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;case'des':algorithm='DES-CBC';dkLen=8;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;default:var error=new Error('Could not encrypt RSA private key; unsupported '+'encryption algorithm "'+options.algorithm+'".');error.algorithm=options.algorithm;throw error;}// encrypt private key using OpenSSL legacy key derivation
var dk=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));cipher.finish();var msg={type:'RSA PRIVATE KEY',procType:{version:'4',type:'ENCRYPTED'},dekInfo:{algorithm:algorithm,parameters:forge.util.bytesToHex(iv).toUpperCase()},body:cipher.output.getBytes()};return forge.pem.encode(msg);};/**
 * Decrypts an RSA private key.
 *
 * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.
 * @param password the password to use.
 *
 * @return the RSA key on success, null on failure.
 */pki.decryptRsaPrivateKey=function(pem,password){var rval=null;var msg=forge.pem.decode(pem)[0];if(msg.type!=='ENCRYPTED PRIVATE KEY'&&msg.type!=='PRIVATE KEY'&&msg.type!=='RSA PRIVATE KEY'){var error=new Error('Could not convert private key from PEM; PEM header type '+'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');error.headerType=error;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){var dkLen;var cipherFn;switch(msg.dekInfo.algorithm){case'DES-CBC':dkLen=8;cipherFn=forge.des.createDecryptionCipher;break;case'DES-EDE3-CBC':dkLen=24;cipherFn=forge.des.createDecryptionCipher;break;case'AES-128-CBC':dkLen=16;cipherFn=forge.aes.createDecryptionCipher;break;case'AES-192-CBC':dkLen=24;cipherFn=forge.aes.createDecryptionCipher;break;case'AES-256-CBC':dkLen=32;cipherFn=forge.aes.createDecryptionCipher;break;case'RC2-40-CBC':dkLen=5;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,40);};break;case'RC2-64-CBC':dkLen=8;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,64);};break;case'RC2-128-CBC':dkLen=16;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,128);};break;default:var error=new Error('Could not decrypt private key; unsupported '+'encryption algorithm "'+msg.dekInfo.algorithm+'".');error.algorithm=msg.dekInfo.algorithm;throw error;}// use OpenSSL legacy key derivation
var iv=forge.util.hexToBytes(msg.dekInfo.parameters);var dk=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(forge.util.createBuffer(msg.body));if(cipher.finish()){rval=cipher.output.getBytes();}else{return rval;}}else{rval=msg.body;}if(msg.type==='ENCRYPTED PRIVATE KEY'){rval=pki.decryptPrivateKeyInfo(asn1.fromDer(rval),password);}else{// decryption already performed above
rval=asn1.fromDer(rval);}if(rval!==null){rval=pki.privateKeyFromAsn1(rval);}return rval;};/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */pki.pbe.generatePkcs12Key=function(password,salt,id,iter,n,md){var j,l;if(typeof md==='undefined'||md===null){if(!('sha1'in forge.md)){throw new Error('"sha1" hash algorithm unavailable.');}md=forge.md.sha1.create();}var u=md.digestLength;var v=md.blockLength;var result=new forge.util.ByteBuffer();/* Convert password to Unicode byte buffer + trailing 0-byte. */var passBuf=new forge.util.ByteBuffer();if(password!==null&&password!==undefined){for(l=0;l<password.length;l++){passBuf.putInt16(password.charCodeAt(l));}passBuf.putInt16(0);}/* Length of salt and password in BYTES. */var p=passBuf.length();var s=salt.length();/* 1. Construct a string, D (the "diversifier"), by concatenating
        v copies of ID. */var D=new forge.util.ByteBuffer();D.fillWithByte(id,v);/* 2. Concatenate copies of the salt together to create a string S of length
        v * ceil(s / v) bytes (the final copy of the salt may be trunacted
        to create S).
        Note that if the salt is the empty string, then so is S. */var Slen=v*Math.ceil(s/v);var S=new forge.util.ByteBuffer();for(l=0;l<Slen;l++){S.putByte(salt.at(l%s));}/* 3. Concatenate copies of the password together to create a string P of
        length v * ceil(p / v) bytes (the final copy of the password may be
        truncated to create P).
        Note that if the password is the empty string, then so is P. */var Plen=v*Math.ceil(p/v);var P=new forge.util.ByteBuffer();for(l=0;l<Plen;l++){P.putByte(passBuf.at(l%p));}/* 4. Set I=S||P to be the concatenation of S and P. */var I=S;I.putBuffer(P);/* 5. Set c=ceil(n / u). */var c=Math.ceil(n/u);/* 6. For i=1, 2, ..., c, do the following: */for(var i=1;i<=c;i++){/* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */var buf=new forge.util.ByteBuffer();buf.putBytes(D.bytes());buf.putBytes(I.bytes());for(var round=0;round<iter;round++){md.start();md.update(buf.getBytes());buf=md.digest();}/* b) Concatenate copies of Ai to create a string B of length v bytes (the
          final copy of Ai may be truncated to create B). */var B=new forge.util.ByteBuffer();for(l=0;l<v;l++){B.putByte(buf.at(l%u));}/* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,
          where k=ceil(s / v) + ceil(p / v), modify I by setting
          Ij=(Ij+B+1) mod 2v for each j.  */var k=Math.ceil(s/v)+Math.ceil(p/v);var Inew=new forge.util.ByteBuffer();for(j=0;j<k;j++){var chunk=new forge.util.ByteBuffer(I.getBytes(v));var x=0x1ff;for(l=B.length()-1;l>=0;l--){x=x>>8;x+=B.at(l)+chunk.at(l);chunk.setAt(l,x&0xff);}Inew.putBuffer(chunk);}I=Inew;/* Add Ai to A. */result.putBuffer(buf);}result.truncate(result.length()-n);return result;};/**
 * Get new Forge cipher object instance.
 *
 * @param oid the OID (in string notation).
 * @param params the ASN.1 params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */pki.pbe.getCipher=function(oid,params,password){switch(oid){case pki.oids['pkcs5PBES2']:return pki.pbe.getCipherForPBES2(oid,params,password);case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:case pki.oids['pbewithSHAAnd40BitRC2-CBC']:return pki.pbe.getCipherForPKCS12PBE(oid,params,password);default:var error=new Error('Cannot read encrypted PBE data block. Unsupported OID.');error.oid=oid;error.supportedOids=['pkcs5PBES2','pbeWithSHAAnd3-KeyTripleDES-CBC','pbewithSHAAnd40BitRC2-CBC'];throw error;}};/**
 * Get new Forge cipher object instance according to PBES2 params block.
 *
 * The returned cipher instance is already started using the IV
 * from PBES2 parameter block.
 *
 * @param oid the PKCS#5 PBKDF2 OID (in string notation).
 * @param params the ASN.1 PBES2-params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */pki.pbe.getCipherForPBES2=function(oid,params,password){// get PBE params
var capture={};var errors=[];if(!asn1.validate(params,PBES2AlgorithmsValidator,capture,errors)){var error=new Error('Cannot read password-based-encryption algorithm '+'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}// check oids
oid=asn1.derToOid(capture.kdfOid);if(oid!==pki.oids['pkcs5PBKDF2']){var error=new Error('Cannot read encrypted private key. '+'Unsupported key derivation function OID.');error.oid=oid;error.supportedOids=['pkcs5PBKDF2'];throw error;}oid=asn1.derToOid(capture.encOid);if(oid!==pki.oids['aes128-CBC']&&oid!==pki.oids['aes192-CBC']&&oid!==pki.oids['aes256-CBC']&&oid!==pki.oids['des-EDE3-CBC']&&oid!==pki.oids['desCBC']){var error=new Error('Cannot read encrypted private key. '+'Unsupported encryption scheme OID.');error.oid=oid;error.supportedOids=['aes128-CBC','aes192-CBC','aes256-CBC','des-EDE3-CBC','desCBC'];throw error;}// set PBE params
var salt=capture.kdfSalt;var count=forge.util.createBuffer(capture.kdfIterationCount);count=count.getInt(count.length()<<3);var dkLen;var cipherFn;switch(pki.oids[oid]){case'aes128-CBC':dkLen=16;cipherFn=forge.aes.createDecryptionCipher;break;case'aes192-CBC':dkLen=24;cipherFn=forge.aes.createDecryptionCipher;break;case'aes256-CBC':dkLen=32;cipherFn=forge.aes.createDecryptionCipher;break;case'des-EDE3-CBC':dkLen=24;cipherFn=forge.des.createDecryptionCipher;break;case'desCBC':dkLen=8;cipherFn=forge.des.createDecryptionCipher;break;}// get PRF message digest
var md=prfOidToMessageDigest(capture.prfOid);// decrypt private key using pbe with chosen PRF and AES/DES
var dk=forge.pkcs5.pbkdf2(password,salt,count,dkLen,md);var iv=capture.encIv;var cipher=cipherFn(dk);cipher.start(iv);return cipher;};/**
 * Get new Forge cipher object instance for PKCS#12 PBE.
 *
 * The returned cipher instance is already started using the key & IV
 * derived from the provided password and PKCS#12 PBE salt.
 *
 * @param oid The PKCS#12 PBE OID (in string notation).
 * @param params The ASN.1 PKCS#12 PBE-params object.
 * @param password The password to decrypt with.
 *
 * @return the new cipher object instance.
 */pki.pbe.getCipherForPKCS12PBE=function(oid,params,password){// get PBE params
var capture={};var errors=[];if(!asn1.validate(params,pkcs12PbeParamsValidator,capture,errors)){var error=new Error('Cannot read password-based-encryption algorithm '+'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}var salt=forge.util.createBuffer(capture.salt);var count=forge.util.createBuffer(capture.iterations);count=count.getInt(count.length()<<3);var dkLen,dIvLen,cipherFn;switch(oid){case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:dkLen=24;dIvLen=8;cipherFn=forge.des.startDecrypting;break;case pki.oids['pbewithSHAAnd40BitRC2-CBC']:dkLen=5;dIvLen=8;cipherFn=function cipherFn(key,iv){var cipher=forge.rc2.createDecryptionCipher(key,40);cipher.start(iv,null);return cipher;};break;default:var error=new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');error.oid=oid;throw error;}// get PRF message digest
var md=prfOidToMessageDigest(capture.prfOid);var key=pki.pbe.generatePkcs12Key(password,salt,1,count,dkLen,md);md.start();var iv=pki.pbe.generatePkcs12Key(password,salt,2,count,dIvLen,md);return cipherFn(key,iv);};/**
 * OpenSSL's legacy key derivation function.
 *
 * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
 *
 * @param password the password to derive the key from.
 * @param salt the salt to use, null for none.
 * @param dkLen the number of bytes needed for the derived key.
 * @param [options] the options to use:
 *          [md] an optional message digest object to use.
 */pki.pbe.opensslDeriveBytes=function(password,salt,dkLen,md){if(typeof md==='undefined'||md===null){if(!('md5'in forge.md)){throw new Error('"md5" hash algorithm unavailable.');}md=forge.md.md5.create();}if(salt===null){salt='';}var digests=[hash(md,password+salt)];for(var length=16,i=1;length<dkLen;++i,length+=16){digests.push(hash(md,digests[i-1]+password+salt));}return digests.join('').substr(0,dkLen);};function hash(md,bytes){return md.start().update(bytes).digest().getBytes();}function prfOidToMessageDigest(prfOid){// get PRF algorithm, default to SHA-1
var prfAlgorithm;if(!prfOid){prfAlgorithm='hmacWithSHA1';}else{prfAlgorithm=pki.oids[asn1.derToOid(prfOid)];if(!prfAlgorithm){var error=new Error('Unsupported PRF OID.');error.oid=prfOid;error.supported=['hmacWithSHA1','hmacWithSHA224','hmacWithSHA256','hmacWithSHA384','hmacWithSHA512'];throw error;}}return prfAlgorithmToMessageDigest(prfAlgorithm);}function prfAlgorithmToMessageDigest(prfAlgorithm){var factory=forge.md;switch(prfAlgorithm){case'hmacWithSHA224':factory=forge.md.sha512;case'hmacWithSHA1':case'hmacWithSHA256':case'hmacWithSHA384':case'hmacWithSHA512':prfAlgorithm=prfAlgorithm.substr(8).toLowerCase();break;default:var error=new Error('Unsupported PRF algorithm.');error.algorithm=prfAlgorithm;error.supported=['hmacWithSHA1','hmacWithSHA224','hmacWithSHA256','hmacWithSHA384','hmacWithSHA512'];throw error;}if(!factory||!(prfAlgorithm in factory)){throw new Error('Unknown hash algorithm: '+prfAlgorithm);}return factory[prfAlgorithm].create();}function createPbkdf2Params(salt,countBytes,dkLen,prfAlgorithm){var params=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// salt
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,salt),// iteration count
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,countBytes.getBytes())]);// when PRF algorithm is not SHA-1 default, add key length and PRF algorithm
if(prfAlgorithm!=='hmacWithSHA1'){params.value.push(// key length
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,forge.util.hexToBytes(dkLen.toString(16))),// AlgorithmIdentifier
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),// parameters (null)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]));}return params;}/***/},/* 10 */ /***/function(module,exports,__webpack_require__){/**
 * Cipher base API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);module.exports=forge.cipher=forge.cipher||{};// registered algorithms
forge.cipher.algorithms=forge.cipher.algorithms||{};/**
 * Creates a cipher object that can be used to encrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */forge.cipher.createCipher=function(algorithm,key){var api=algorithm;if(typeof api==='string'){api=forge.cipher.getAlgorithm(api);if(api){api=api();}}if(!api){throw new Error('Unsupported algorithm: '+algorithm);}// assume block cipher
return new forge.cipher.BlockCipher({algorithm:api,key:key,decrypt:false});};/**
 * Creates a decipher object that can be used to decrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */forge.cipher.createDecipher=function(algorithm,key){var api=algorithm;if(typeof api==='string'){api=forge.cipher.getAlgorithm(api);if(api){api=api();}}if(!api){throw new Error('Unsupported algorithm: '+algorithm);}// assume block cipher
return new forge.cipher.BlockCipher({algorithm:api,key:key,decrypt:true});};/**
 * Registers an algorithm by name. If the name was already registered, the
 * algorithm API object will be overwritten.
 *
 * @param name the name of the algorithm.
 * @param algorithm the algorithm API object.
 */forge.cipher.registerAlgorithm=function(name,algorithm){name=name.toUpperCase();forge.cipher.algorithms[name]=algorithm;};/**
 * Gets a registered algorithm by name.
 *
 * @param name the name of the algorithm.
 *
 * @return the algorithm, if found, null if not.
 */forge.cipher.getAlgorithm=function(name){name=name.toUpperCase();if(name in forge.cipher.algorithms){return forge.cipher.algorithms[name];}return null;};var BlockCipher=forge.cipher.BlockCipher=function(options){this.algorithm=options.algorithm;this.mode=this.algorithm.mode;this.blockSize=this.mode.blockSize;this._finish=false;this._input=null;this.output=null;this._op=options.decrypt?this.mode.decrypt:this.mode.encrypt;this._decrypt=options.decrypt;this.algorithm.initialize(options);};/**
 * Starts or restarts the encryption or decryption process, whichever
 * was previously configured.
 *
 * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
 * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in
 * bytes, then it must be Nb (16) bytes in length. If the IV is given in as
 * 32-bit integers, then it must be 4 integers long.
 *
 * Note: an IV is not required or used in ECB mode.
 *
 * For GCM-mode, the IV must be given as a binary-encoded string of bytes or
 * a byte buffer. The number of bytes should be 12 (96 bits) as recommended
 * by NIST SP-800-38D but another length may be given.
 *
 * @param options the options to use:
 *          iv the initialization vector to use as a binary-encoded string of
 *            bytes, null to reuse the last ciphered block from a previous
 *            update() (this "residue" method is for legacy support only).
 *          additionalData additional authentication data as a binary-encoded
 *            string of bytes, for 'GCM' mode, (default: none).
 *          tagLength desired length of authentication tag, in bits, for
 *            'GCM' mode (0-128, default: 128).
 *          tag the authentication tag to check if decrypting, as a
 *             binary-encoded string of bytes.
 *          output the output the buffer to write to, null to create one.
 */BlockCipher.prototype.start=function(options){options=options||{};var opts={};for(var key in options){opts[key]=options[key];}opts.decrypt=this._decrypt;this._finish=false;this._input=forge.util.createBuffer();this.output=options.output||forge.util.createBuffer();this.mode.start(opts);};/**
 * Updates the next block according to the cipher mode.
 *
 * @param input the buffer to read from.
 */BlockCipher.prototype.update=function(input){if(input){// input given, so empty it into the input buffer
this._input.putBuffer(input);}// do cipher operation until it needs more input and not finished
while(!this._op.call(this.mode,this._input,this.output,this._finish)&&!this._finish){}// free consumed memory from input buffer
this._input.compact();};/**
 * Finishes encrypting or decrypting.
 *
 * @param pad a padding function to use in CBC mode, null for default,
 *          signature(blockSize, buffer, decrypt).
 *
 * @return true if successful, false on error.
 */BlockCipher.prototype.finish=function(pad){// backwards-compatibility w/deprecated padding API
// Note: will overwrite padding functions even after another start() call
if(pad&&(this.mode.name==='ECB'||this.mode.name==='CBC')){this.mode.pad=function(input){return pad(this.blockSize,input,false);};this.mode.unpad=function(output){return pad(this.blockSize,output,true);};}// build options for padding and afterFinish functions
var options={};options.decrypt=this._decrypt;// get # of bytes that won't fill a block
options.overflow=this._input.length()%this.blockSize;if(!this._decrypt&&this.mode.pad){if(!this.mode.pad(this._input,options)){return false;}}// do final update
this._finish=true;this.update();if(this._decrypt&&this.mode.unpad){if(!this.mode.unpad(this.output,options)){return false;}}if(this.mode.afterFinish){if(!this.mode.afterFinish(this.output,options)){return false;}}return true;};/***/},/* 11 */ /***/function(module,exports,__webpack_require__){/**
 * Supported cipher modes.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);forge.cipher=forge.cipher||{};// supported cipher modes
var modes=module.exports=forge.cipher.modes=forge.cipher.modes||{};/** Electronic codebook (ECB) (Don't use this; it's not secure) **/modes.ecb=function(options){options=options||{};this.name='ECB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);};modes.ecb.prototype.start=function(options){};modes.ecb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// write output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}};modes.ecb.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// decrypt block
this.cipher.decrypt(this._inBlock,this._outBlock);// write output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}};modes.ecb.prototype.pad=function(input,options){// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=input.length()===this.blockSize?this.blockSize:this.blockSize-input.length();input.fillWithByte(padding,padding);return true;};modes.ecb.prototype.unpad=function(output,options){// check for error: input data not a multiple of blockSize
if(options.overflow>0){return false;}// ensure padding byte count is valid
var len=output.length();var count=output.at(len-1);if(count>this.blockSize<<2){return false;}// trim off padding bytes
output.truncate(count);return true;};/** Cipher-block Chaining (CBC) **/modes.cbc=function(options){options=options||{};this.name='CBC';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);};modes.cbc.prototype.start=function(options){// Note: legacy support for using IV residue (has security flaws)
// if IV is null, reuse block from previous processing
if(options.iv===null){// must have a previous block
if(!this._prev){throw new Error('Invalid IV parameter.');}this._iv=this._prev.slice(0);}else if(!('iv'in options)){throw new Error('Invalid IV parameter.');}else{// save IV as "previous" block
this._iv=transformIV(options.iv);this._prev=this._iv.slice(0);}};modes.cbc.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
// CBC XOR's IV (or previous block) with plaintext
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._prev[i]^input.getInt32();}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// write output, save previous block
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}this._prev=this._outBlock;};modes.cbc.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// decrypt block
this.cipher.decrypt(this._inBlock,this._outBlock);// write output, save previous ciphered block
// CBC XOR's IV (or previous block) with ciphertext
for(var i=0;i<this._ints;++i){output.putInt32(this._prev[i]^this._outBlock[i]);}this._prev=this._inBlock.slice(0);};modes.cbc.prototype.pad=function(input,options){// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=input.length()===this.blockSize?this.blockSize:this.blockSize-input.length();input.fillWithByte(padding,padding);return true;};modes.cbc.prototype.unpad=function(output,options){// check for error: input data not a multiple of blockSize
if(options.overflow>0){return false;}// ensure padding byte count is valid
var len=output.length();var count=output.at(len-1);if(count>this.blockSize<<2){return false;}// trim off padding bytes
output.truncate(count);return true;};/** Cipher feedback (CFB) **/modes.cfb=function(options){options=options||{};this.name='CFB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.cfb.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.cfb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output, write input as output
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32()^this._outBlock[i];output.putInt32(this._inBlock[i]);}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output, write input as partial output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialBlock[i]=input.getInt32()^this._outBlock[i];this._partialOutput.putInt32(this._partialBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._partialBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};modes.cfb.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block (CFB always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output, write input as output
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();output.putInt32(this._inBlock[i]^this._outBlock[i]);}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output, write input as partial output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialBlock[i]=input.getInt32();this._partialOutput.putInt32(this._partialBlock[i]^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._partialBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};/** Output feedback (OFB) **/modes.ofb=function(options){options=options||{};this.name='OFB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.ofb.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.ofb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(input.length()===0){return true;}// encrypt block (OFB always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output and update next input
for(var i=0;i<this._ints;++i){output.putInt32(input.getInt32()^this._outBlock[i]);this._inBlock[i]=this._outBlock[i];}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._outBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};modes.ofb.prototype.decrypt=modes.ofb.prototype.encrypt;/** Counter (CTR) **/modes.ctr=function(options){options=options||{};this.name='CTR';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.ctr.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.ctr.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block (CTR always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output
for(var i=0;i<this._ints;++i){output.putInt32(input.getInt32()^this._outBlock[i]);}}else{// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;}// block complete, increment counter (input block)
inc32(this._inBlock);};modes.ctr.prototype.decrypt=modes.ctr.prototype.encrypt;/** Galois/Counter Mode (GCM) **/modes.gcm=function(options){options=options||{};this.name='GCM';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;// R is actually this value concatenated with 120 more zero bits, but
// we only XOR against R so the other zeros have no effect -- we just
// apply this value to the first integer in a block
this._R=0xE1000000;};modes.gcm.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// ensure IV is a byte buffer
var iv=forge.util.createBuffer(options.iv);// no ciphered data processed yet
this._cipherLength=0;// default additional data is none
var additionalData;if('additionalData'in options){additionalData=forge.util.createBuffer(options.additionalData);}else{additionalData=forge.util.createBuffer();}// default tag length is 128 bits
if('tagLength'in options){this._tagLength=options.tagLength;}else{this._tagLength=128;}// if tag is given, ensure tag matches tag length
this._tag=null;if(options.decrypt){// save tag to check later
this._tag=forge.util.createBuffer(options.tag).getBytes();if(this._tag.length!==this._tagLength/8){throw new Error('Authentication tag does not match tag length.');}}// create tmp storage for hash calculation
this._hashBlock=new Array(this._ints);// no tag generated yet
this.tag=null;// generate hash subkey
// (apply block cipher to "zero" block)
this._hashSubkey=new Array(this._ints);this.cipher.encrypt([0,0,0,0],this._hashSubkey);// generate table M
// use 4-bit tables (32 component decomposition of a 16 byte value)
// 8-bit tables take more space and are known to have security
// vulnerabilities (in native implementations)
this.componentBits=4;this._m=this.generateHashTable(this._hashSubkey,this.componentBits);// Note: support IV length different from 96 bits? (only supporting
// 96 bits is recommended by NIST SP-800-38D)
// generate J_0
var ivLength=iv.length();if(ivLength===12){// 96-bit IV
this._j0=[iv.getInt32(),iv.getInt32(),iv.getInt32(),1];}else{// IV is NOT 96-bits
this._j0=[0,0,0,0];while(iv.length()>0){this._j0=this.ghash(this._hashSubkey,this._j0,[iv.getInt32(),iv.getInt32(),iv.getInt32(),iv.getInt32()]);}this._j0=this.ghash(this._hashSubkey,this._j0,[0,0].concat(from64To32(ivLength*8)));}// generate ICB (initial counter block)
this._inBlock=this._j0.slice(0);inc32(this._inBlock);this._partialBytes=0;// consume authentication data
additionalData=forge.util.createBuffer(additionalData);// save additional data length as a BE 64-bit number
this._aDataLength=from64To32(additionalData.length()*8);// pad additional data to 128 bit (16 byte) block size
var overflow=additionalData.length()%this.blockSize;if(overflow){additionalData.fillWithByte(0,this.blockSize-overflow);}this._s=[0,0,0,0];while(additionalData.length()>0){this._s=this.ghash(this._hashSubkey,this._s,[additionalData.getInt32(),additionalData.getInt32(),additionalData.getInt32(),additionalData.getInt32()]);}};modes.gcm.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]^=input.getInt32());}this._cipherLength+=this.blockSize;}else{// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes===0||finish){// handle overflow prior to hashing
if(finish){// get block overflow
var overflow=inputLength%this.blockSize;this._cipherLength+=overflow;// truncate for hash function
this._partialOutput.truncate(this.blockSize-overflow);}else{this._cipherLength+=this.blockSize;}// get output block for hashing
for(var i=0;i<this._ints;++i){this._outBlock[i]=this._partialOutput.getInt32();}this._partialOutput.read-=this.blockSize;}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){// block still incomplete, restore input buffer, get partial output,
// and return early
input.read-=this.blockSize;output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;}// update hash block S
this._s=this.ghash(this._hashSubkey,this._s,this._outBlock);// increment counter (input block)
inc32(this._inBlock);};modes.gcm.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
var inputLength=input.length();if(inputLength<this.blockSize&&!(finish&&inputLength>0)){return true;}// encrypt block (GCM always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// increment counter (input block)
inc32(this._inBlock);// update hash block S
this._hashBlock[0]=input.getInt32();this._hashBlock[1]=input.getInt32();this._hashBlock[2]=input.getInt32();this._hashBlock[3]=input.getInt32();this._s=this.ghash(this._hashSubkey,this._s,this._hashBlock);// XOR hash input with output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]^this._hashBlock[i]);}// increment cipher data length
if(inputLength<this.blockSize){this._cipherLength+=inputLength%this.blockSize;}else{this._cipherLength+=this.blockSize;}};modes.gcm.prototype.afterFinish=function(output,options){var rval=true;// handle overflow
if(options.decrypt&&options.overflow){output.truncate(this.blockSize-options.overflow);}// handle authentication tag
this.tag=forge.util.createBuffer();// concatenate additional data length with cipher length
var lengths=this._aDataLength.concat(from64To32(this._cipherLength*8));// include lengths in hash
this._s=this.ghash(this._hashSubkey,this._s,lengths);// do GCTR(J_0, S)
var tag=[];this.cipher.encrypt(this._j0,tag);for(var i=0;i<this._ints;++i){this.tag.putInt32(this._s[i]^tag[i]);}// trim tag to length
this.tag.truncate(this.tag.length()%(this._tagLength/8));// check authentication tag
if(options.decrypt&&this.tag.bytes()!==this._tag){rval=false;}return rval;};/**
 * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois
 * field multiplication. The field, GF(2^128), is defined by the polynomial:
 *
 * x^128 + x^7 + x^2 + x + 1
 *
 * Which is represented in little-endian binary form as: 11100001 (0xe1). When
 * the value of a coefficient is 1, a bit is set. The value R, is the
 * concatenation of this value and 120 zero bits, yielding a 128-bit value
 * which matches the block size.
 *
 * This function will multiply two elements (vectors of bytes), X and Y, in
 * the field GF(2^128). The result is initialized to zero. For each bit of
 * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)
 * by the current value of Y. For each bit, the value of Y will be raised by
 * a power of x (multiplied by the polynomial x). This can be achieved by
 * shifting Y once to the right. If the current value of Y, prior to being
 * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.
 * Otherwise, we must divide by R after shifting to find the remainder.
 *
 * @param x the first block to multiply by the second.
 * @param y the second block to multiply by the first.
 *
 * @return the block result of the multiplication.
 */modes.gcm.prototype.multiply=function(x,y){var z_i=[0,0,0,0];var v_i=y.slice(0);// calculate Z_128 (block has 128 bits)
for(var i=0;i<128;++i){// if x_i is 0, Z_{i+1} = Z_i (unchanged)
// else Z_{i+1} = Z_i ^ V_i
// get x_i by finding 32-bit int position, then left shift 1 by remainder
var x_i=x[i/32|0]&1<<31-i%32;if(x_i){z_i[0]^=v_i[0];z_i[1]^=v_i[1];z_i[2]^=v_i[2];z_i[3]^=v_i[3];}// if LSB(V_i) is 1, V_i = V_i >> 1
// else V_i = (V_i >> 1) ^ R
this.pow(v_i,v_i);}return z_i;};modes.gcm.prototype.pow=function(x,out){// if LSB(x) is 1, x = x >>> 1
// else x = (x >>> 1) ^ R
var lsb=x[3]&1;// always do x >>> 1:
// starting with the rightmost integer, shift each integer to the right
// one bit, pulling in the bit from the integer to the left as its top
// most bit (do this for the last 3 integers)
for(var i=3;i>0;--i){out[i]=x[i]>>>1|(x[i-1]&1)<<31;}// shift the first integer normally
out[0]=x[0]>>>1;// if lsb was not set, then polynomial had a degree of 127 and doesn't
// need to divided; otherwise, XOR with R to find the remainder; we only
// need to XOR the first integer since R technically ends w/120 zero bits
if(lsb){out[0]^=this._R;}};modes.gcm.prototype.tableMultiply=function(x){// assumes 4-bit tables are used
var z=[0,0,0,0];for(var i=0;i<32;++i){var idx=i/8|0;var x_i=x[idx]>>>(7-i%8)*4&0xF;var ah=this._m[i][x_i];z[0]^=ah[0];z[1]^=ah[1];z[2]^=ah[2];z[3]^=ah[3];}return z;};/**
 * A continuing version of the GHASH algorithm that operates on a single
 * block. The hash block, last hash value (Ym) and the new block to hash
 * are given.
 *
 * @param h the hash block.
 * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.
 * @param x the block to hash.
 *
 * @return the hashed value (Ym).
 */modes.gcm.prototype.ghash=function(h,y,x){y[0]^=x[0];y[1]^=x[1];y[2]^=x[2];y[3]^=x[3];return this.tableMultiply(y);//return this.multiply(y, h);
};/**
 * Precomputes a table for multiplying against the hash subkey. This
 * mechanism provides a substantial speed increase over multiplication
 * performed without a table. The table-based multiplication this table is
 * for solves X * H by multiplying each component of X by H and then
 * composing the results together using XOR.
 *
 * This function can be used to generate tables with different bit sizes
 * for the components, however, this implementation assumes there are
 * 32 components of X (which is a 16 byte vector), therefore each component
 * takes 4-bits (so the table is constructed with bits=4).
 *
 * @param h the hash subkey.
 * @param bits the bit size for a component.
 */modes.gcm.prototype.generateHashTable=function(h,bits){// TODO: There are further optimizations that would use only the
// first table M_0 (or some variant) along with a remainder table;
// this can be explored in the future
var multiplier=8/bits;var perInt=4*multiplier;var size=16*multiplier;var m=new Array(size);for(var i=0;i<size;++i){var tmp=[0,0,0,0];var idx=i/perInt|0;var shft=(perInt-1-i%perInt)*bits;tmp[idx]=1<<bits-1<<shft;m[i]=this.generateSubHashTable(this.multiply(tmp,h),bits);}return m;};/**
 * Generates a table for multiplying against the hash subkey for one
 * particular component (out of all possible component values).
 *
 * @param mid the pre-multiplied value for the middle key of the table.
 * @param bits the bit size for a component.
 */modes.gcm.prototype.generateSubHashTable=function(mid,bits){// compute the table quickly by minimizing the number of
// POW operations -- they only need to be performed for powers of 2,
// all other entries can be composed from those powers using XOR
var size=1<<bits;var half=size>>>1;var m=new Array(size);m[half]=mid.slice(0);var i=half>>>1;while(i>0){// raise m0[2 * i] and store in m0[i]
this.pow(m[2*i],m[i]=[]);i>>=1;}i=2;while(i<half){for(var j=1;j<i;++j){var m_i=m[i];var m_j=m[j];m[i+j]=[m_i[0]^m_j[0],m_i[1]^m_j[1],m_i[2]^m_j[2],m_i[3]^m_j[3]];}i*=2;}m[0]=[0,0,0,0];/* Note: We could avoid storing these by doing composition during multiply
  calculate top half using composition by speed is preferred. */for(i=half+1;i<size;++i){var c=m[i^half];m[i]=[mid[0]^c[0],mid[1]^c[1],mid[2]^c[2],mid[3]^c[3]];}return m;};/** Utility functions */function transformIV(iv){if(typeof iv==='string'){// convert iv string into byte buffer
iv=forge.util.createBuffer(iv);}if(forge.util.isArray(iv)&&iv.length>4){// convert iv byte array into byte buffer
var tmp=iv;iv=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){iv.putByte(tmp[i]);}}if(!forge.util.isArray(iv)){// convert iv byte buffer into 32-bit integer array
iv=[iv.getInt32(),iv.getInt32(),iv.getInt32(),iv.getInt32()];}return iv;}function inc32(block){// increment last 32 bits of block only
block[block.length-1]=block[block.length-1]+1&0xFFFFFFFF;}function from64To32(num){// convert 64-bit number to two BE Int32s
return[num/0x100000000|0,num&0xFFFFFFFF];}/***/},/* 12 */ /***/function(module,exports,__webpack_require__){/**
 * DES (Data Encryption Standard) implementation.
 *
 * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.
 * It is based on the BSD-licensed implementation by Paul Tero:
 *
 * Paul Tero, July 2001
 * http://www.tero.co.uk/des/
 *
 * Optimised for performance with large blocks by Michael Hayworth, November 2001
 * http://www.netdealing.com
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2012-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(10);__webpack_require__(11);__webpack_require__(1);/* DES API */module.exports=forge.des=forge.des||{};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */forge.des.startEncrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:false,mode:mode||(iv===null?'ECB':'CBC')});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.des.createEncryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:false,mode:mode});};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */forge.des.startDecrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:true,mode:mode||(iv===null?'ECB':'CBC')});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.des.createDecryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:true,mode:mode});};/**
 * Creates a new DES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the DES algorithm object.
 */forge.des.Algorithm=function(name,mode){var self=this;self.name=name;self.mode=new mode({blockSize:8,cipher:{encrypt:function encrypt(inBlock,outBlock){return _updateBlock(self._keys,inBlock,outBlock,false);},decrypt:function decrypt(inBlock,outBlock){return _updateBlock(self._keys,inBlock,outBlock,true);}}});self._init=false;};/**
 * Initializes this DES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */forge.des.Algorithm.prototype.initialize=function(options){if(this._init){return;}var key=forge.util.createBuffer(options.key);if(this.name.indexOf('3DES')===0){if(key.length()!==24){throw new Error('Invalid Triple-DES key size: '+key.length()*8);}}// do key expansion to 16 or 48 subkeys (single or triple DES)
this._keys=_createKeys(key);this._init=true;};/** Register DES algorithms **/registerAlgorithm('DES-ECB',forge.cipher.modes.ecb);registerAlgorithm('DES-CBC',forge.cipher.modes.cbc);registerAlgorithm('DES-CFB',forge.cipher.modes.cfb);registerAlgorithm('DES-OFB',forge.cipher.modes.ofb);registerAlgorithm('DES-CTR',forge.cipher.modes.ctr);registerAlgorithm('3DES-ECB',forge.cipher.modes.ecb);registerAlgorithm('3DES-CBC',forge.cipher.modes.cbc);registerAlgorithm('3DES-CFB',forge.cipher.modes.cfb);registerAlgorithm('3DES-OFB',forge.cipher.modes.ofb);registerAlgorithm('3DES-CTR',forge.cipher.modes.ctr);function registerAlgorithm(name,mode){var factory=function factory(){return new forge.des.Algorithm(name,mode);};forge.cipher.registerAlgorithm(name,factory);}/** DES implementation **/var spfunction1=[0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004];var spfunction2=[-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000];var spfunction3=[0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200];var spfunction4=[0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080];var spfunction5=[0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100];var spfunction6=[0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010];var spfunction7=[0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002];var spfunction8=[0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000];/**
 * Create necessary sub keys.
 *
 * @param key the 64-bit or 192-bit key.
 *
 * @return the expanded keys.
 */function _createKeys(key){var pc2bytes0=[0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204],pc2bytes1=[0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101],pc2bytes2=[0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808],pc2bytes3=[0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000],pc2bytes4=[0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010],pc2bytes5=[0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420],pc2bytes6=[0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002],pc2bytes7=[0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800],pc2bytes8=[0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002],pc2bytes9=[0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408],pc2bytes10=[0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020],pc2bytes11=[0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200],pc2bytes12=[0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010],pc2bytes13=[0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105];// how many iterations (1 for des, 3 for triple des)
// changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys
var iterations=key.length()>8?3:1;// stores the return keys
var keys=[];// now define the left shifts which need to be done
var shifts=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0];var n=0,tmp;for(var j=0;j<iterations;j++){var left=key.getInt32();var right=key.getInt32();tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;tmp=(right>>>-16^left)&0x0000ffff;left^=tmp;right^=tmp<<-16;tmp=(left>>>2^right)&0x33333333;right^=tmp;left^=tmp<<2;tmp=(right>>>-16^left)&0x0000ffff;left^=tmp;right^=tmp<<-16;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;// right needs to be shifted and OR'd with last four bits of left
tmp=left<<8|right>>>20&0x000000f0;// left needs to be put upside down
left=right<<24|right<<8&0xff0000|right>>>8&0xff00|right>>>24&0xf0;right=tmp;// now go through and perform these shifts on the left and right keys
for(var i=0;i<shifts.length;++i){//shift the keys either one or two bits to the left
if(shifts[i]){left=left<<2|left>>>26;right=right<<2|right>>>26;}else{left=left<<1|left>>>27;right=right<<1|right>>>27;}left&=-0xf;right&=-0xf;// now apply PC-2, in such a way that E is easier when encrypting or
// decrypting this conversion will look like PC-2 except only the last 6
// bits of each byte are used rather than 48 consecutive bits and the
// order of lines will be according to how the S selection functions will
// be applied: S2, S4, S6, S8, S1, S3, S5, S7
var lefttmp=pc2bytes0[left>>>28]|pc2bytes1[left>>>24&0xf]|pc2bytes2[left>>>20&0xf]|pc2bytes3[left>>>16&0xf]|pc2bytes4[left>>>12&0xf]|pc2bytes5[left>>>8&0xf]|pc2bytes6[left>>>4&0xf];var righttmp=pc2bytes7[right>>>28]|pc2bytes8[right>>>24&0xf]|pc2bytes9[right>>>20&0xf]|pc2bytes10[right>>>16&0xf]|pc2bytes11[right>>>12&0xf]|pc2bytes12[right>>>8&0xf]|pc2bytes13[right>>>4&0xf];tmp=(righttmp>>>16^lefttmp)&0x0000ffff;keys[n++]=lefttmp^tmp;keys[n++]=righttmp^tmp<<16;}}return keys;}/**
 * Updates a single block (1 byte) using DES. The update will either
 * encrypt or decrypt the block.
 *
 * @param keys the expanded keys.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */function _updateBlock(keys,input,output,decrypt){// set up loops for single or triple DES
var iterations=keys.length===32?3:9;var looping;if(iterations===3){looping=decrypt?[30,-2,-2]:[0,32,2];}else{looping=decrypt?[94,62,-2,32,64,2,30,-2,-2]:[0,32,2,62,30,-2,64,96,2];}var tmp;var left=input[0];var right=input[1];// first each 64 bit chunk of the message must be permuted according to IP
tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;tmp=(left>>>16^right)&0x0000ffff;right^=tmp;left^=tmp<<16;tmp=(right>>>2^left)&0x33333333;left^=tmp;right^=tmp<<2;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;// rotate left 1 bit
left=left<<1|left>>>31;right=right<<1|right>>>31;for(var j=0;j<iterations;j+=3){var endloop=looping[j+1];var loopinc=looping[j+2];// now go through and perform the encryption or decryption
for(var i=looping[j];i!=endloop;i+=loopinc){var right1=right^keys[i];var right2=(right>>>4|right<<28)^keys[i+1];// passing these bytes through the S selection functions
tmp=left;left=right;right=tmp^(spfunction2[right1>>>24&0x3f]|spfunction4[right1>>>16&0x3f]|spfunction6[right1>>>8&0x3f]|spfunction8[right1&0x3f]|spfunction1[right2>>>24&0x3f]|spfunction3[right2>>>16&0x3f]|spfunction5[right2>>>8&0x3f]|spfunction7[right2&0x3f]);}// unreverse left and right
tmp=left;left=right;right=tmp;}// rotate right 1 bit
left=left>>>1|left<<31;right=right>>>1|right<<31;// now perform IP-1, which is IP in the opposite direction
tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(right>>>2^left)&0x33333333;left^=tmp;right^=tmp<<2;tmp=(left>>>16^right)&0x0000ffff;right^=tmp;left^=tmp<<16;tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;output[0]=left;output[1]=right;}/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('DES-<mode>', key);
 * forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates a deprecated DES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param options the options to use.
 *          key the symmetric key to use (64 or 192 bits).
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */function _createCipher(options){options=options||{};var mode=(options.mode||'CBC').toUpperCase();var algorithm='DES-'+mode;var cipher;if(options.decrypt){cipher=forge.cipher.createDecipher(algorithm,options.key);}else{cipher=forge.cipher.createCipher(algorithm,options.key);}// backwards compatible start API
var start=cipher.start;cipher.start=function(iv,options){// backwards compatibility: support second arg as output buffer
var output=null;if(options instanceof forge.util.ByteBuffer){output=options;options={};}options=options||{};options.output=output;options.iv=iv;start.call(cipher,options);};return cipher;}/***/},/* 13 */ /***/function(module,exports,__webpack_require__){/**
 * Password-Based Key-Derivation Function #2 implementation.
 *
 * See RFC 2898 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(14);__webpack_require__(4);__webpack_require__(1);var pkcs5=forge.pkcs5=forge.pkcs5||{};var crypto;if(forge.util.isNodejs&&!forge.options.usePureJavaScript){crypto=__webpack_require__(15);}/**
 * Derives a key from a password.
 *
 * @param p the password as a binary-encoded string of bytes.
 * @param s the salt as a binary-encoded string of bytes.
 * @param c the iteration count, a positive integer.
 * @param dkLen the intended length, in bytes, of the derived key,
 *          (max: 2^32 - 1) * hash length of the PRF.
 * @param [md] the message digest (or algorithm identifier as a string) to use
 *          in the PRF, defaults to SHA-1.
 * @param [callback(err, key)] presence triggers asynchronous version, called
 *          once the operation completes.
 *
 * @return the derived key, as a binary-encoded string of bytes, for the
 *           synchronous version (if no callback is specified).
 */module.exports=forge.pbkdf2=pkcs5.pbkdf2=function(p,s,c,dkLen,md,callback){if(typeof md==='function'){callback=md;md=null;}// use native implementation if possible and not disabled, note that
// some node versions only support SHA-1, others allow digest to be changed
if(forge.util.isNodejs&&!forge.options.usePureJavaScript&&crypto.pbkdf2&&(md===null||_typeof(md)!=='object')&&(crypto.pbkdf2Sync.length>4||!md||md==='sha1')){if(typeof md!=='string'){// default prf to SHA-1
md='sha1';}p=new Buffer(p,'binary');s=new Buffer(s,'binary');if(!callback){if(crypto.pbkdf2Sync.length===4){return crypto.pbkdf2Sync(p,s,c,dkLen).toString('binary');}return crypto.pbkdf2Sync(p,s,c,dkLen,md).toString('binary');}if(crypto.pbkdf2Sync.length===4){return crypto.pbkdf2(p,s,c,dkLen,function(err,key){if(err){return callback(err);}callback(null,key.toString('binary'));});}return crypto.pbkdf2(p,s,c,dkLen,md,function(err,key){if(err){return callback(err);}callback(null,key.toString('binary'));});}if(typeof md==='undefined'||md===null){// default prf to SHA-1
md='sha1';}if(typeof md==='string'){if(!(md in forge.md.algorithms)){throw new Error('Unknown hash algorithm: '+md);}md=forge.md[md].create();}var hLen=md.digestLength;/* 1. If dkLen > (2^32 - 1) * hLen, output "derived key too long" and
    stop. */if(dkLen>0xFFFFFFFF*hLen){var err=new Error('Derived key is too long.');if(callback){return callback(err);}throw err;}/* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:

    len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */var len=Math.ceil(dkLen/hLen);var r=dkLen-(len-1)*hLen;/* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:

    T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),

    where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:

    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c

    where

    u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).

    Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */var prf=forge.hmac.create();prf.start(md,p);var dk='';var xor,u_c,u_c1;// sync version
if(!callback){for(var i=1;i<=len;++i){// PRF(P, S || INT(i)) (first iteration)
prf.start(null,null);prf.update(s);prf.update(forge.util.int32ToBytes(i));xor=u_c1=prf.digest().getBytes();// PRF(P, u_{c-1}) (other iterations)
for(var j=2;j<=c;++j){prf.start(null,null);prf.update(u_c1);u_c=prf.digest().getBytes();// F(p, s, c, i)
xor=forge.util.xorBytes(xor,u_c,hLen);u_c1=u_c;}/* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:

        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */dk+=i<len?xor:xor.substr(0,r);}/* 5. Output the derived key DK. */return dk;}// async version
var i=1,j;function outer(){if(i>len){// done
return callback(null,dk);}// PRF(P, S || INT(i)) (first iteration)
prf.start(null,null);prf.update(s);prf.update(forge.util.int32ToBytes(i));xor=u_c1=prf.digest().getBytes();// PRF(P, u_{c-1}) (other iterations)
j=2;inner();}function inner(){if(j<=c){prf.start(null,null);prf.update(u_c1);u_c=prf.digest().getBytes();// F(p, s, c, i)
xor=forge.util.xorBytes(xor,u_c,hLen);u_c1=u_c;++j;return forge.util.setImmediate(inner);}/* 4. Concatenate the blocks and extract the first dkLen octets to
      produce a derived key DK:

      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */dk+=i<len?xor:xor.substr(0,r);++i;outer();}outer();};/***/},/* 14 */ /***/function(module,exports,__webpack_require__){/**
 * Hash-based Message Authentication Code implementation. Requires a message
 * digest object that can be obtained, for example, from forge.md.sha1 or
 * forge.md.md5.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);/* HMAC API */var hmac=module.exports=forge.hmac=forge.hmac||{};/**
 * Creates an HMAC object that uses the given message digest object.
 *
 * @return an HMAC object.
 */hmac.create=function(){// the hmac key to use
var _key=null;// the message digest to use
var _md=null;// the inner padding
var _ipadding=null;// the outer padding
var _opadding=null;// hmac context
var ctx={};/**
   * Starts or restarts the HMAC with the given key and message digest.
   *
   * @param md the message digest to use, null to reuse the previous one,
   *           a string to use builtin 'sha1', 'md5', 'sha256'.
   * @param key the key to use as a string, array of bytes, byte buffer,
   *           or null to reuse the previous key.
   */ctx.start=function(md,key){if(md!==null){if(typeof md==='string'){// create builtin message digest
md=md.toLowerCase();if(md in forge.md.algorithms){_md=forge.md.algorithms[md].create();}else{throw new Error('Unknown hash algorithm "'+md+'"');}}else{// store message digest
_md=md;}}if(key===null){// reuse previous key
key=_key;}else{if(typeof key==='string'){// convert string into byte buffer
key=forge.util.createBuffer(key);}else if(forge.util.isArray(key)){// convert byte array into byte buffer
var tmp=key;key=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){key.putByte(tmp[i]);}}// if key is longer than blocksize, hash it
var keylen=key.length();if(keylen>_md.blockLength){_md.start();_md.update(key.bytes());key=_md.digest();}// mix key into inner and outer padding
// ipadding = [0x36 * blocksize] ^ key
// opadding = [0x5C * blocksize] ^ key
_ipadding=forge.util.createBuffer();_opadding=forge.util.createBuffer();keylen=key.length();for(var i=0;i<keylen;++i){var tmp=key.at(i);_ipadding.putByte(0x36^tmp);_opadding.putByte(0x5C^tmp);}// if key is shorter than blocksize, add additional padding
if(keylen<_md.blockLength){var tmp=_md.blockLength-keylen;for(var i=0;i<tmp;++i){_ipadding.putByte(0x36);_opadding.putByte(0x5C);}}_key=key;_ipadding=_ipadding.bytes();_opadding=_opadding.bytes();}// digest is done like so: hash(opadding | hash(ipadding | message))
// prepare to do inner hash
// hash(ipadding | message)
_md.start();_md.update(_ipadding);};/**
   * Updates the HMAC with the given message bytes.
   *
   * @param bytes the bytes to update with.
   */ctx.update=function(bytes){_md.update(bytes);};/**
   * Produces the Message Authentication Code (MAC).
   *
   * @return a byte buffer containing the digest value.
   */ctx.getMac=function(){// digest is done like so: hash(opadding | hash(ipadding | message))
// here we do the outer hashing
var inner=_md.digest().bytes();_md.start();_md.update(_opadding);_md.update(inner);return _md.digest();};// alias for getMac
ctx.digest=ctx.getMac;return ctx;};/***/},/* 15 */ /***/function(module,exports){/* (ignored) */ /***/},/* 16 */ /***/function(module,exports,__webpack_require__){// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.
// Basic JavaScript BN library - subset useful for RSA encryption.
/*
Licensing (LICENSE)
-------------------

This software is covered under the following copyright:
*/ /*
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */ /*
Address all questions regarding this license to:

  Tom Wu
  tjw@cs.Stanford.EDU
*/var forge=__webpack_require__(0);module.exports=forge.jsbn=forge.jsbn||{};// Bits per digit
var dbits;// JavaScript engine analysis
var canary=0xdeadbeefcafe;var j_lm=(canary&0xffffff)==0xefcafe;// (public) Constructor
function BigInteger(a,b,c){this.data=[];if(a!=null)if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b);}forge.jsbn.BigInteger=BigInteger;// return new, unset BigInteger
function nbi(){return new BigInteger(null);}// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this.data[i++]+w.data[j]+c;c=Math.floor(v/0x4000000);w.data[j++]=v&0x3ffffff;}return c;}// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n){var xl=x&0x7fff,xh=x>>15;while(--n>=0){var l=this.data[i]&0x7fff;var h=this.data[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);w.data[j++]=l&0x3fffffff;}return c;}// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n){var xl=x&0x3fff,xh=x>>14;while(--n>=0){var l=this.data[i]&0x3fff;var h=this.data[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&0x3fff)<<14)+w.data[j]+c;c=(l>>28)+(m>>14)+xh*h;w.data[j++]=l&0xfffffff;}return c;}// node.js (no browser)
if(typeof navigator==='undefined'){BigInteger.prototype.am=am3;dbits=28;}else if(j_lm&&navigator.appName=="Microsoft Internet Explorer"){BigInteger.prototype.am=am2;dbits=30;}else if(j_lm&&navigator.appName!="Netscape"){BigInteger.prototype.am=am1;dbits=26;}else{// Mozilla/Netscape seems to prefer am3
BigInteger.prototype.am=am3;dbits=28;}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=(1<<dbits)-1;BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;// Digit conversions
var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array();var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv){BI_RC[rr++]=vv;}rr="a".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}rr="A".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}function int2char(n){return BI_RM.charAt(n);}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];return c==null?-1:c;}// (protected) copy this to r
function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i){r.data[i]=this.data[i];}r.t=this.t;r.s=this.s;}// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this.data[0]=x;else if(x<-1)this.data[0]=x+this.DV;else this.t=0;}// return bigint initialized to value
function nbv(i){var r=nbi();r.fromInt(i);return r;}// (protected) set from string and radix
function bnpFromString(s,b){var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;// byte array
else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{this.fromRadix(s,b);return;}this.t=0;this.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&0xff:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue;}mi=false;if(sh==0)this.data[this.t++]=x;else if(sh+k>this.DB){this.data[this.t-1]|=(x&(1<<this.DB-sh)-1)<<sh;this.data[this.t++]=x>>this.DB-sh;}else this.data[this.t-1]|=x<<sh;sh+=k;if(sh>=this.DB)sh-=this.DB;}if(k==8&&(s[0]&0x80)!=0){this.s=-1;if(sh>0)this.data[this.t-1]|=(1<<this.DB-sh)-1<<sh;}this.clamp();if(mi)BigInteger.ZERO.subTo(this,this);}// (protected) clamp off excess high words
function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this.data[this.t-1]==c){--this.t;}}// (public) return string representation in given radix
function bnToString(b){if(this.s<0)return"-"+this.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return this.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=this.t;var p=this.DB-i*this.DB%k;if(i-->0){if(p<this.DB&&(d=this.data[i]>>p)>0){m=true;r=int2char(d);}while(i>=0){if(p<k){d=(this.data[i]&(1<<p)-1)<<k-p;d|=this.data[--i]>>(p+=this.DB-k);}else{d=this.data[i]>>(p-=k)&km;if(p<=0){p+=this.DB;--i;}}if(d>0)m=true;if(m)r+=int2char(d);}}return m?r:"0";}// (public) -this
function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,r);return r;}// (public) |this|
function bnAbs(){return this.s<0?this.negate():this;}// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0){if((r=this.data[i]-a.data[i])!=0)return r;}return 0;}// returns bit length of the integer x
function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16;}if((t=x>>8)!=0){x=t;r+=8;}if((t=x>>4)!=0){x=t;r+=4;}if((t=x>>2)!=0){x=t;r+=2;}if((t=x>>1)!=0){x=t;r+=1;}return r;}// (public) return the number of bits in "this"
function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this.data[this.t-1]^this.s&this.DM);}// (protected) r = this << n*DB
function bnpDLShiftTo(n,r){var i;for(i=this.t-1;i>=0;--i){r.data[i+n]=this.data[i];}for(i=n-1;i>=0;--i){r.data[i]=0;}r.t=this.t+n;r.s=this.s;}// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i){r.data[i-n]=this.data[i];}r.t=Math.max(this.t-n,0);r.s=this.s;}// (protected) r = this << n
function bnpLShiftTo(n,r){var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/this.DB),c=this.s<<bs&this.DM,i;for(i=this.t-1;i>=0;--i){r.data[i+ds+1]=this.data[i]>>cbs|c;c=(this.data[i]&bm)<<bs;}for(i=ds-1;i>=0;--i){r.data[i]=0;}r.data[ds]=c;r.t=this.t+ds+1;r.s=this.s;r.clamp();}// (protected) r = this >> n
function bnpRShiftTo(n,r){r.s=this.s;var ds=Math.floor(n/this.DB);if(ds>=this.t){r.t=0;return;}var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<bs)-1;r.data[0]=this.data[ds]>>bs;for(var i=ds+1;i<this.t;++i){r.data[i-ds-1]|=(this.data[i]&bm)<<cbs;r.data[i-ds]=this.data[i]>>bs;}if(bs>0)r.data[this.t-ds-1]|=(this.s&bm)<<cbs;r.t=this.t-ds;r.clamp();}// (protected) r = this - a
function bnpSubTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this.data[i]-a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}if(a.t<this.t){c-=a.s;while(i<this.t){c+=this.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=this.s;}else{c+=this.s;while(i<a.t){c-=a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c-=a.s;}r.s=c<0?-1:0;if(c<-1)r.data[i++]=this.DV+c;else if(c>0)r.data[i++]=c;r.t=i;r.clamp();}// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0){r.data[i]=0;}for(i=0;i<y.t;++i){r.data[i+x.t]=x.am(0,y.data[i],r,i,0,x.t);}r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r);}// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0){r.data[i]=0;}for(i=0;i<x.t-1;++i){var c=x.am(i,x.data[i],r,2*i,0,1);if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1))>=x.DV){r.data[i+x.t]-=x.DV;r.data[i+x.t+1]=1;}}if(r.t>0)r.data[r.t-1]+=x.am(i,x.data[i],r,2*i,0,1);r.s=0;r.clamp();}// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r){var pm=m.abs();if(pm.t<=0)return;var pt=this.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)this.copyTo(r);return;}if(r==null)r=nbi();var y=nbi(),ts=this.s,ms=m.s;var nsh=this.DB-nbits(pm.data[pm.t-1]);// normalize modulus
if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r);}else{pm.copyTo(y);pt.copyTo(r);}var ys=y.t;var y0=y.data[ys-1];if(y0==0)return;var yt=y0*(1<<this.F1)+(ys>1?y.data[ys-2]>>this.F2:0);var d1=this.FV/yt,d2=(1<<this.F1)/yt,e=1<<this.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r.data[r.t++]=1;r.subTo(t,r);}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);// "negative" y so we can replace sub with am later
while(y.t<ys){y.data[y.t++]=0;}while(--j>=0){// Estimate quotient digit
var qd=r.data[--i]==y0?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);if((r.data[i]+=y.am(0,qd,r,j,0,ys))<qd){// Try it out
y.dlShiftTo(j,t);r.subTo(t,r);while(r.data[i]<--qd){r.subTo(t,r);}}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q);}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);// Denormalize remainder
if(ts<0)BigInteger.ZERO.subTo(r,r);}// (public) this mod a
function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r;}// Modular reduction using "classic" algorithm
function Classic(m){this.m=m;}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x;}function cRevert(x){return x;}function cReduce(x){x.divRemTo(this.m,null,x);}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}function cSqrTo(x,r){x.squareTo(r);this.reduce(r);}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit(){if(this.t<1)return 0;var x=this.data[0];if((x&1)==0)return 0;var y=x&3;// y == 1/x mod 2^2
y=y*(2-(x&0xf)*y)&0xf;// y == 1/x mod 2^4
y=y*(2-(x&0xff)*y)&0xff;// y == 1/x mod 2^8
y=y*(2-((x&0xffff)*y&0xffff))&0xffff;// y == 1/x mod 2^16
// last step - calculate inverse mod DV directly;
// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
y=y*(2-x*y%this.DV)%this.DV;// y == 1/x mod 2^dbits
// we really want the negative inverse, and -DV < y < DV
return y>0?this.DV-y:-y;}// Montgomery reduction
function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&0x7fff;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t;}// xR mod m
function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r;}// x/R mod m
function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r;}// x = x/R mod m (HAC 14.32)
function montReduce(x){while(x.t<=this.mt2){// pad x so am has enough room later
x.data[x.t++]=0;}for(var i=0;i<this.m.t;++i){// faster way of calculating u0 = x.data[i]*mp mod DV
var j=x.data[i]&0x7fff;var u0=j*this.mpl+((j*this.mph+(x.data[i]>>15)*this.mpl&this.um)<<15)&x.DM;// use am to combine the multiply-shift-add into one call
j=i+this.m.t;x.data[j]+=this.m.am(0,u0,x,i,0,this.m.t);// propagate carry
while(x.data[j]>=x.DV){x.data[j]-=x.DV;x.data[++j]++;}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x);}// r = "x^2/R mod m"; x != r
function montSqrTo(x,r){x.squareTo(r);this.reduce(r);}// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;// (protected) true iff this is even
function bnpIsEven(){return(this.t>0?this.data[0]&1:this.s)==0;}// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z){if(e>0xffffffff||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t;}}return z.revert(r);}// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z);}// protected
BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;// public
BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;// "constants"
BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);// jsbn2 lib
//Copyright (c) 2005-2009  Tom Wu
//All Rights Reserved.
//See "LICENSE" for details (See jsbn.js for LICENSE).
//Extended JavaScript BN functions, required for RSA private ops.
//Version 1.1: new BigInteger("0", 10) returns "proper" zero
//(public)
function bnClone(){var r=nbi();this.copyTo(r);return r;}//(public) return value as integer
function bnIntValue(){if(this.s<0){if(this.t==1)return this.data[0]-this.DV;else if(this.t==0)return-1;}else if(this.t==1)return this.data[0];else if(this.t==0)return 0;// assumes 16 < DB < 32
return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0];}//(public) return value as byte
function bnByteValue(){return this.t==0?this.s:this.data[0]<<24>>24;}//(public) return value as short (assumes DB>=16)
function bnShortValue(){return this.t==0?this.s:this.data[0]<<16>>16;}//(protected) return x s.t. r^x < DV
function bnpChunkSize(r){return Math.floor(Math.LN2*this.DB/Math.log(r));}//(public) 0 if this == 0, 1 if this > 0
function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this.data[0]<=0)return 0;else return 1;}//(protected) convert to radix string
function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z);}return z.intValue().toString(b)+r;}//(protected) convert from radix string
function bnpFromRadix(s,b){this.fromInt(0);if(b==null)b=10;var cs=this.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&this.signum()==0)mi=true;continue;}w=b*w+x;if(++j>=cs){this.dMultiply(d);this.dAddOffset(w,0);j=0;w=0;}}if(j>0){this.dMultiply(Math.pow(b,j));this.dAddOffset(w,0);}if(mi)BigInteger.ZERO.subTo(this,this);}//(protected) alternate constructor
function bnpFromNumber(a,b,c){if("number"==typeof b){// new BigInteger(int,int,RNG)
if(a<2)this.fromInt(1);else{this.fromNumber(a,c);if(!this.testBit(a-1))// force MSB set
this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);if(this.isEven())this.dAddOffset(1,0);// force odd
while(!this.isProbablePrime(b)){this.dAddOffset(2,0);if(this.bitLength()>a)this.subTo(BigInteger.ONE.shiftLeft(a-1),this);}}}else{// new BigInteger(int,RNG)
var x=new Array(),t=a&7;x.length=(a>>3)+1;b.nextBytes(x);if(t>0)x[0]&=(1<<t)-1;else x[0]=0;this.fromString(x,256);}}//(public) convert to bigendian byte array
function bnToByteArray(){var i=this.t,r=new Array();r[0]=this.s;var p=this.DB-i*this.DB%8,d,k=0;if(i-->0){if(p<this.DB&&(d=this.data[i]>>p)!=(this.s&this.DM)>>p)r[k++]=d|this.s<<this.DB-p;while(i>=0){if(p<8){d=(this.data[i]&(1<<p)-1)<<8-p;d|=this.data[--i]>>(p+=this.DB-8);}else{d=this.data[i]>>(p-=8)&0xff;if(p<=0){p+=this.DB;--i;}}if((d&0x80)!=0)d|=-256;if(k==0&&(this.s&0x80)!=(d&0x80))++k;if(k>0||d!=this.s)r[k++]=d;}}return r;}function bnEquals(a){return this.compareTo(a)==0;}function bnMin(a){return this.compareTo(a)<0?this:a;}function bnMax(a){return this.compareTo(a)>0?this:a;}//(protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r){var i,f,m=Math.min(a.t,this.t);for(i=0;i<m;++i){r.data[i]=op(this.data[i],a.data[i]);}if(a.t<this.t){f=a.s&this.DM;for(i=m;i<this.t;++i){r.data[i]=op(this.data[i],f);}r.t=this.t;}else{f=this.s&this.DM;for(i=m;i<a.t;++i){r.data[i]=op(f,a.data[i]);}r.t=a.t;}r.s=op(this.s,a.s);r.clamp();}//(public) this & a
function op_and(x,y){return x&y;}function bnAnd(a){var r=nbi();this.bitwiseTo(a,op_and,r);return r;}//(public) this | a
function op_or(x,y){return x|y;}function bnOr(a){var r=nbi();this.bitwiseTo(a,op_or,r);return r;}//(public) this ^ a
function op_xor(x,y){return x^y;}function bnXor(a){var r=nbi();this.bitwiseTo(a,op_xor,r);return r;}//(public) this & ~a
function op_andnot(x,y){return x&~y;}function bnAndNot(a){var r=nbi();this.bitwiseTo(a,op_andnot,r);return r;}//(public) ~this
function bnNot(){var r=nbi();for(var i=0;i<this.t;++i){r.data[i]=this.DM&~this.data[i];}r.t=this.t;r.s=~this.s;return r;}//(public) this << n
function bnShiftLeft(n){var r=nbi();if(n<0)this.rShiftTo(-n,r);else this.lShiftTo(n,r);return r;}//(public) this >> n
function bnShiftRight(n){var r=nbi();if(n<0)this.lShiftTo(-n,r);else this.rShiftTo(n,r);return r;}//return index of lowest 1-bit in x, x < 2^31
function lbit(x){if(x==0)return-1;var r=0;if((x&0xffff)==0){x>>=16;r+=16;}if((x&0xff)==0){x>>=8;r+=8;}if((x&0xf)==0){x>>=4;r+=4;}if((x&3)==0){x>>=2;r+=2;}if((x&1)==0)++r;return r;}//(public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit(){for(var i=0;i<this.t;++i){if(this.data[i]!=0)return i*this.DB+lbit(this.data[i]);}if(this.s<0)return this.t*this.DB;return-1;}//return number of 1 bits in x
function cbit(x){var r=0;while(x!=0){x&=x-1;++r;}return r;}//(public) return number of set bits
function bnBitCount(){var r=0,x=this.s&this.DM;for(var i=0;i<this.t;++i){r+=cbit(this.data[i]^x);}return r;}//(public) true iff nth bit is set
function bnTestBit(n){var j=Math.floor(n/this.DB);if(j>=this.t)return this.s!=0;return(this.data[j]&1<<n%this.DB)!=0;}//(protected) this op (1<<n)
function bnpChangeBit(n,op){var r=BigInteger.ONE.shiftLeft(n);this.bitwiseTo(r,op,r);return r;}//(public) this | (1<<n)
function bnSetBit(n){return this.changeBit(n,op_or);}//(public) this & ~(1<<n)
function bnClearBit(n){return this.changeBit(n,op_andnot);}//(public) this ^ (1<<n)
function bnFlipBit(n){return this.changeBit(n,op_xor);}//(protected) r = this + a
function bnpAddTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this.data[i]+a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}if(a.t<this.t){c+=a.s;while(i<this.t){c+=this.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=this.s;}else{c+=this.s;while(i<a.t){c+=a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=a.s;}r.s=c<0?-1:0;if(c>0)r.data[i++]=c;else if(c<-1)r.data[i++]=this.DV+c;r.t=i;r.clamp();}//(public) this + a
function bnAdd(a){var r=nbi();this.addTo(a,r);return r;}//(public) this - a
function bnSubtract(a){var r=nbi();this.subTo(a,r);return r;}//(public) this * a
function bnMultiply(a){var r=nbi();this.multiplyTo(a,r);return r;}//(public) this / a
function bnDivide(a){var r=nbi();this.divRemTo(a,r,null);return r;}//(public) this % a
function bnRemainder(a){var r=nbi();this.divRemTo(a,null,r);return r;}//(public) [this/a,this%a]
function bnDivideAndRemainder(a){var q=nbi(),r=nbi();this.divRemTo(a,q,r);return new Array(q,r);}//(protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n){this.data[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp();}//(protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w){this.data[this.t++]=0;}this.data[w]+=n;while(this.data[w]>=this.DV){this.data[w]-=this.DV;if(++w>=this.t)this.data[this.t++]=0;++this.data[w];}}//A "null" reducer
function NullExp(){}function nNop(x){return x;}function nMulTo(x,y,r){x.multiplyTo(y,r);}function nSqrTo(x,r){x.squareTo(r);}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;//(public) this^e
function bnPow(e){return this.exp(e,new NullExp());}//(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r){var i=Math.min(this.t+a.t,n);r.s=0;// assumes a,this >= 0
r.t=i;while(i>0){r.data[--i]=0;}var j;for(j=r.t-this.t;i<j;++i){r.data[i+this.t]=this.am(0,a.data[i],r,i,0,this.t);}for(j=Math.min(a.t,n);i<j;++i){this.am(0,a.data[i],r,i,0,n-i);}r.clamp();}//(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r){--n;var i=r.t=this.t+a.t-n;r.s=0;// assumes a,this >= 0
while(--i>=0){r.data[i]=0;}for(i=Math.max(n-this.t,0);i<a.t;++i){r.data[this.t+i-n]=this.am(n-i,a.data[i],r,0,0,this.t+i-n);}r.clamp();r.drShiftTo(1,r);}//Barrett modular reduction
function Barrett(m){// setup Barrett
this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*m.t,this.r2);this.mu=this.r2.divide(m);this.m=m;}function barrettConvert(x){if(x.s<0||x.t>2*this.m.t)return x.mod(this.m);else if(x.compareTo(this.m)<0)return x;else{var r=nbi();x.copyTo(r);this.reduce(r);return r;}}function barrettRevert(x){return x;}//x = x mod m (HAC 14.42)
function barrettReduce(x){x.drShiftTo(this.m.t-1,this.r2);if(x.t>this.m.t+1){x.t=this.m.t+1;x.clamp();}this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(x.compareTo(this.r2)<0){x.dAddOffset(1,this.m.t+1);}x.subTo(this.r2,x);while(x.compareTo(this.m)>=0){x.subTo(this.m,x);}}//r = x^2 mod m; x != r
function barrettSqrTo(x,r){x.squareTo(r);this.reduce(r);}//r = x*y mod m; x,y != r
function barrettMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;//(public) this^e % m (HAC 14.85)
function bnModPow(e,m){var i=e.bitLength(),k,r=nbv(1),z;if(i<=0)return r;else if(i<18)k=1;else if(i<48)k=3;else if(i<144)k=4;else if(i<768)k=5;else k=6;if(i<8)z=new Classic(m);else if(m.isEven())z=new Barrett(m);else z=new Montgomery(m);// precomputation
var g=new Array(),n=3,k1=k-1,km=(1<<k)-1;g[1]=z.convert(this);if(k>1){var g2=nbi();z.sqrTo(g[1],g2);while(n<=km){g[n]=nbi();z.mulTo(g2,g[n-2],g[n]);n+=2;}}var j=e.t-1,w,is1=true,r2=nbi(),t;i=nbits(e.data[j])-1;while(j>=0){if(i>=k1)w=e.data[j]>>i-k1&km;else{w=(e.data[j]&(1<<i+1)-1)<<k1-i;if(j>0)w|=e.data[j-1]>>this.DB+i-k1;}n=k;while((w&1)==0){w>>=1;--n;}if((i-=n)<0){i+=this.DB;--j;}if(is1){// ret == 1, don't bother squaring or multiplying it
g[w].copyTo(r);is1=false;}else{while(n>1){z.sqrTo(r,r2);z.sqrTo(r2,r);n-=2;}if(n>0)z.sqrTo(r,r2);else{t=r;r=r2;r2=t;}z.mulTo(r2,g[w],r);}while(j>=0&&(e.data[j]&1<<i)==0){z.sqrTo(r,r2);t=r;r=r2;r2=t;if(--i<0){i=this.DB-1;--j;}}}return z.revert(r);}//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a){var x=this.s<0?this.negate():this.clone();var y=a.s<0?a.negate():a.clone();if(x.compareTo(y)<0){var t=x;x=y;y=t;}var i=x.getLowestSetBit(),g=y.getLowestSetBit();if(g<0)return x;if(i<g)g=i;if(g>0){x.rShiftTo(g,x);y.rShiftTo(g,y);}while(x.signum()>0){if((i=x.getLowestSetBit())>0)x.rShiftTo(i,x);if((i=y.getLowestSetBit())>0)y.rShiftTo(i,y);if(x.compareTo(y)>=0){x.subTo(y,x);x.rShiftTo(1,x);}else{y.subTo(x,y);y.rShiftTo(1,y);}}if(g>0)y.lShiftTo(g,y);return y;}//(protected) this % n, n < 2^26
function bnpModInt(n){if(n<=0)return 0;var d=this.DV%n,r=this.s<0?n-1:0;if(this.t>0)if(d==0)r=this.data[0]%n;else for(var i=this.t-1;i>=0;--i){r=(d*r+this.data[i])%n;}return r;}//(public) 1/this % m (HAC 14.61)
function bnModInverse(m){var ac=m.isEven();if(this.isEven()&&ac||m.signum()==0)return BigInteger.ZERO;var u=m.clone(),v=this.clone();var a=nbv(1),b=nbv(0),c=nbv(0),d=nbv(1);while(u.signum()!=0){while(u.isEven()){u.rShiftTo(1,u);if(ac){if(!a.isEven()||!b.isEven()){a.addTo(this,a);b.subTo(m,b);}a.rShiftTo(1,a);}else if(!b.isEven())b.subTo(m,b);b.rShiftTo(1,b);}while(v.isEven()){v.rShiftTo(1,v);if(ac){if(!c.isEven()||!d.isEven()){c.addTo(this,c);d.subTo(m,d);}c.rShiftTo(1,c);}else if(!d.isEven())d.subTo(m,d);d.rShiftTo(1,d);}if(u.compareTo(v)>=0){u.subTo(v,u);if(ac)a.subTo(c,a);b.subTo(d,b);}else{v.subTo(u,v);if(ac)c.subTo(a,c);d.subTo(b,d);}}if(v.compareTo(BigInteger.ONE)!=0)return BigInteger.ZERO;if(d.compareTo(m)>=0)return d.subtract(m);if(d.signum()<0)d.addTo(m,d);else return d;if(d.signum()<0)return d.add(m);else return d;}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];var lplim=(1<<26)/lowprimes[lowprimes.length-1];//(public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t){var i,x=this.abs();if(x.t==1&&x.data[0]<=lowprimes[lowprimes.length-1]){for(i=0;i<lowprimes.length;++i){if(x.data[0]==lowprimes[i])return true;}return false;}if(x.isEven())return false;i=1;while(i<lowprimes.length){var m=lowprimes[i],j=i+1;while(j<lowprimes.length&&m<lplim){m*=lowprimes[j++];}m=x.modInt(m);while(i<j){if(m%lowprimes[i++]==0)return false;}}return x.millerRabin(t);}//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t){var n1=this.subtract(BigInteger.ONE);var k=n1.getLowestSetBit();if(k<=0)return false;var r=n1.shiftRight(k);var prng=bnGetPrng();var a;for(var i=0;i<t;++i){// select witness 'a' at random from between 1 and n1
do{a=new BigInteger(this.bitLength(),prng);}while(a.compareTo(BigInteger.ONE)<=0||a.compareTo(n1)>=0);var y=a.modPow(r,this);if(y.compareTo(BigInteger.ONE)!=0&&y.compareTo(n1)!=0){var j=1;while(j++<k&&y.compareTo(n1)!=0){y=y.modPowInt(2,this);if(y.compareTo(BigInteger.ONE)==0)return false;}if(y.compareTo(n1)!=0)return false;}}return true;}// get pseudo random number generator
function bnGetPrng(){// create prng with api that matches BigInteger secure random
return{// x is an array to fill with bytes
nextBytes:function nextBytes(x){for(var i=0;i<x.length;++i){x[i]=Math.floor(Math.random()*0x0100);}}};}//protected
BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.fromNumber=bnpFromNumber;BigInteger.prototype.bitwiseTo=bnpBitwiseTo;BigInteger.prototype.changeBit=bnpChangeBit;BigInteger.prototype.addTo=bnpAddTo;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger.prototype.modInt=bnpModInt;BigInteger.prototype.millerRabin=bnpMillerRabin;//public
BigInteger.prototype.clone=bnClone;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.byteValue=bnByteValue;BigInteger.prototype.shortValue=bnShortValue;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.toByteArray=bnToByteArray;BigInteger.prototype.equals=bnEquals;BigInteger.prototype.min=bnMin;BigInteger.prototype.max=bnMax;BigInteger.prototype.and=bnAnd;BigInteger.prototype.or=bnOr;BigInteger.prototype.xor=bnXor;BigInteger.prototype.andNot=bnAndNot;BigInteger.prototype.not=bnNot;BigInteger.prototype.shiftLeft=bnShiftLeft;BigInteger.prototype.shiftRight=bnShiftRight;BigInteger.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger.prototype.bitCount=bnBitCount;BigInteger.prototype.testBit=bnTestBit;BigInteger.prototype.setBit=bnSetBit;BigInteger.prototype.clearBit=bnClearBit;BigInteger.prototype.flipBit=bnFlipBit;BigInteger.prototype.add=bnAdd;BigInteger.prototype.subtract=bnSubtract;BigInteger.prototype.multiply=bnMultiply;BigInteger.prototype.divide=bnDivide;BigInteger.prototype.remainder=bnRemainder;BigInteger.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger.prototype.modPow=bnModPow;BigInteger.prototype.modInverse=bnModInverse;BigInteger.prototype.pow=bnPow;BigInteger.prototype.gcd=bnGCD;BigInteger.prototype.isProbablePrime=bnIsProbablePrime;//BigInteger interfaces not implemented in jsbn:
//BigInteger(int signum, byte[] magnitude)
//double doubleValue()
//float floatValue()
//int hashCode()
//long longValue()
//static BigInteger valueOf(long val)
/***/},/* 17 */ /***/function(module,exports,__webpack_require__){/**
 * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);var sha1=module.exports=forge.sha1=forge.sha1||{};forge.md.sha1=forge.md.algorithms.sha1=sha1;/**
 * Creates a SHA-1 message digest object.
 *
 * @return a message digest object.
 */sha1.create=function(){// do initialization as necessary
if(!_initialized){_init();}// SHA-1 state contains five 32-bit integers
var _state=null;// input buffer
var _input=forge.util.createBuffer();// used for word storage
var _w=new Array(80);// message digest object
var md={algorithm:'sha1',blockLength:64,digestLength:20,// 56-bit length of message so far (does not including padding)
messageLength:0,// true message length
fullMessageLength:null,// size of message length in bytes
messageLengthSize:8};/**
   * Starts the digest.
   *
   * @return this digest object.
   */md.start=function(){// up to 56-bit message length for convenience
md.messageLength=0;// full message length (set md.messageLength64 for backwards-compatibility)
md.fullMessageLength=md.messageLength64=[];var int32s=md.messageLengthSize/4;for(var i=0;i<int32s;++i){md.fullMessageLength.push(0);}_input=forge.util.createBuffer();_state={h0:0x67452301,h1:0xEFCDAB89,h2:0x98BADCFE,h3:0x10325476,h4:0xC3D2E1F0};return md;};// start digest automatically for first time
md.start();/**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */md.update=function(msg,encoding){if(encoding==='utf8'){msg=forge.util.encodeUtf8(msg);}// update message length
var len=msg.length;md.messageLength+=len;len=[len/0x100000000>>>0,len>>>0];for(var i=md.fullMessageLength.length-1;i>=0;--i){md.fullMessageLength[i]+=len[1];len[1]=len[0]+(md.fullMessageLength[i]/0x100000000>>>0);md.fullMessageLength[i]=md.fullMessageLength[i]>>>0;len[0]=len[1]/0x100000000>>>0;}// add bytes to input buffer
_input.putBytes(msg);// process bytes
_update(_state,_w,_input);// compact input buffer every 2K or if empty
if(_input.read>2048||_input.length()===0){_input.compact();}return md;};/**
    * Produces the digest.
    *
    * @return a byte buffer containing the digest value.
    */md.digest=function(){/* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */var finalBlock=forge.util.createBuffer();finalBlock.putBytes(_input.bytes());// compute remaining size to be digested (include message length size)
var remaining=md.fullMessageLength[md.fullMessageLength.length-1]+md.messageLengthSize;// add padding for overflow blockSize - overflow
// _padding starts with 1 byte with first bit is set (byte value 128), then
// there may be up to (blockSize - 1) other pad bytes
var overflow=remaining&md.blockLength-1;finalBlock.putBytes(_padding.substr(0,md.blockLength-overflow));// serialize message length in bits in big-endian order; since length
// is stored in bytes we multiply by 8 and add carry from next int
var next,carry;var bits=md.fullMessageLength[0]*8;for(var i=0;i<md.fullMessageLength.length-1;++i){next=md.fullMessageLength[i+1]*8;carry=next/0x100000000>>>0;bits+=carry;finalBlock.putInt32(bits>>>0);bits=next>>>0;}finalBlock.putInt32(bits);var s2={h0:_state.h0,h1:_state.h1,h2:_state.h2,h3:_state.h3,h4:_state.h4};_update(s2,_w,finalBlock);var rval=forge.util.createBuffer();rval.putInt32(s2.h0);rval.putInt32(s2.h1);rval.putInt32(s2.h2);rval.putInt32(s2.h3);rval.putInt32(s2.h4);return rval;};return md;};// sha-1 padding bytes not initialized yet
var _padding=null;var _initialized=false;/**
 * Initializes the constant tables.
 */function _init(){// create padding
_padding=String.fromCharCode(128);_padding+=forge.util.fillString(String.fromCharCode(0x00),64);// now initialized
_initialized=true;}/**
 * Updates a SHA-1 state with the given byte buffer.
 *
 * @param s the SHA-1 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */function _update(s,w,bytes){// consume 512 bit (64 byte) chunks
var t,a,b,c,d,e,f,i;var len=bytes.length();while(len>=64){// the w array will be populated with sixteen 32-bit big-endian words
// and then extended into 80 32-bit words according to SHA-1 algorithm
// and for 32-79 using Max Locktyukhin's optimization
// initialize hash value for this chunk
a=s.h0;b=s.h1;c=s.h2;d=s.h3;e=s.h4;// round 1
for(i=0;i<16;++i){t=bytes.getInt32();w[i]=t;f=d^b&(c^d);t=(a<<5|a>>>27)+f+e+0x5A827999+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}for(;i<20;++i){t=w[i-3]^w[i-8]^w[i-14]^w[i-16];t=t<<1|t>>>31;w[i]=t;f=d^b&(c^d);t=(a<<5|a>>>27)+f+e+0x5A827999+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 2
for(;i<32;++i){t=w[i-3]^w[i-8]^w[i-14]^w[i-16];t=t<<1|t>>>31;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0x6ED9EBA1+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}for(;i<40;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0x6ED9EBA1+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 3
for(;i<60;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b&c|d&(b^c);t=(a<<5|a>>>27)+f+e+0x8F1BBCDC+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 4
for(;i<80;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0xCA62C1D6+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// update hash state
s.h0=s.h0+a|0;s.h1=s.h1+b|0;s.h2=s.h2+c|0;s.h3=s.h3+d|0;s.h4=s.h4+e|0;len-=64;}}/***/},/* 18 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of X.509 and related components (such as
 * Certification Signing Requests) of a Public Key Infrastructure.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The ASN.1 representation of an X.509v3 certificate is as follows
 * (see RFC 2459):
 *
 * Certificate ::= SEQUENCE {
 *   tbsCertificate       TBSCertificate,
 *   signatureAlgorithm   AlgorithmIdentifier,
 *   signatureValue       BIT STRING
 * }
 *
 * TBSCertificate ::= SEQUENCE {
 *   version         [0]  EXPLICIT Version DEFAULT v1,
 *   serialNumber         CertificateSerialNumber,
 *   signature            AlgorithmIdentifier,
 *   issuer               Name,
 *   validity             Validity,
 *   subject              Name,
 *   subjectPublicKeyInfo SubjectPublicKeyInfo,
 *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   extensions      [3]  EXPLICIT Extensions OPTIONAL
 *                        -- If present, version shall be v3
 * }
 *
 * Version ::= INTEGER  { v1(0), v2(1), v3(2) }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * Name ::= CHOICE {
 *   // only one possible choice for now
 *   RDNSequence
 * }
 *
 * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 *
 * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
 *
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type     AttributeType,
 *   value    AttributeValue
 * }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY DEFINED BY AttributeType
 *
 * Validity ::= SEQUENCE {
 *   notBefore      Time,
 *   notAfter       Time
 * }
 *
 * Time ::= CHOICE {
 *   utcTime        UTCTime,
 *   generalTime    GeneralizedTime
 * }
 *
 * UniqueIdentifier ::= BIT STRING
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm            AlgorithmIdentifier,
 *   subjectPublicKey     BIT STRING
 * }
 *
 * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
 *
 * Extension ::= SEQUENCE {
 *   extnID      OBJECT IDENTIFIER,
 *   critical    BOOLEAN DEFAULT FALSE,
 *   extnValue   OCTET STRING
 * }
 *
 * The only key algorithm currently supported for PKI is RSA.
 *
 * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
 *
 * PKCS#10 v1.7 describes certificate signing requests:
 *
 * CertificationRequestInfo:
 *
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes{{ CRIAttributes }}
 * }
 *
 * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
 *
 * CRIAttributes  ATTRIBUTE  ::= {
 *   ... -- add any locally defined attributes here -- }
 *
 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
 *   type   ATTRIBUTE.&id({IOSet}),
 *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
 * }
 *
 * CertificationRequest ::= SEQUENCE {
 *   certificationRequestInfo CertificationRequestInfo,
 *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
 *   signature          BIT STRING
 * }
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(2);__webpack_require__(12);__webpack_require__(4);__webpack_require__(30);__webpack_require__(3);__webpack_require__(8);__webpack_require__(19);__webpack_require__(6);__webpack_require__(1);// shortcut for asn.1 API
var asn1=forge.asn1;/* Public Key Infrastructure (PKI) implementation. */var pki=module.exports=forge.pki=forge.pki||{};var oids=pki.oids;// short name OID mappings
var _shortNames={};_shortNames['CN']=oids['commonName'];_shortNames['commonName']='CN';_shortNames['C']=oids['countryName'];_shortNames['countryName']='C';_shortNames['L']=oids['localityName'];_shortNames['localityName']='L';_shortNames['ST']=oids['stateOrProvinceName'];_shortNames['stateOrProvinceName']='ST';_shortNames['O']=oids['organizationName'];_shortNames['organizationName']='O';_shortNames['OU']=oids['organizationalUnitName'];_shortNames['organizationalUnitName']='OU';_shortNames['E']=oids['emailAddress'];_shortNames['emailAddress']='E';// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator=forge.pki.rsa.publicKeyValidator;// validator for an X.509v3 certificate
var x509CertificateValidator={name:'Certificate',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Certificate.TBSCertificate',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'tbsCertificate',value:[{name:'Certificate.TBSCertificate.version',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.version.integer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certVersion'}]},{name:'Certificate.TBSCertificate.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certSerialNumber'},{name:'Certificate.TBSCertificate.signature',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Certificate.TBSCertificate.signature.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certinfoSignatureOid'},{name:'Certificate.TBSCertificate.signature.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'certinfoSignatureParams'}]},{name:'Certificate.TBSCertificate.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certIssuer'},{name:'Certificate.TBSCertificate.validity',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,// Note: UTC and generalized times may both appear so the capture
// names are based on their detected order, the names used below
// are only for the common case, which validity time really means
// "notBefore" and which means "notAfter" will be determined by order
value:[{// notBefore (Time) (UTC time case)
name:'Certificate.TBSCertificate.validity.notBefore (utc)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.UTCTIME,constructed:false,optional:true,capture:'certValidity1UTCTime'},{// notBefore (Time) (generalized time case)
name:'Certificate.TBSCertificate.validity.notBefore (generalized)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.GENERALIZEDTIME,constructed:false,optional:true,capture:'certValidity2GeneralizedTime'},{// notAfter (Time) (only UTC time is supported)
name:'Certificate.TBSCertificate.validity.notAfter (utc)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.UTCTIME,constructed:false,optional:true,capture:'certValidity3UTCTime'},{// notAfter (Time) (only UTC time is supported)
name:'Certificate.TBSCertificate.validity.notAfter (generalized)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.GENERALIZEDTIME,constructed:false,optional:true,capture:'certValidity4GeneralizedTime'}]},{// Name (subject) (RDNSequence)
name:'Certificate.TBSCertificate.subject',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certSubject'},// SubjectPublicKeyInfo
publicKeyValidator,{// issuerUniqueID (optional)
name:'Certificate.TBSCertificate.issuerUniqueID',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.issuerUniqueID.id',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,// TODO: support arbitrary bit length ids
captureBitStringValue:'certIssuerUniqueId'}]},{// subjectUniqueID (optional)
name:'Certificate.TBSCertificate.subjectUniqueID',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:2,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.subjectUniqueID.id',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,// TODO: support arbitrary bit length ids
captureBitStringValue:'certSubjectUniqueId'}]},{// Extensions (optional)
name:'Certificate.TBSCertificate.extensions',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:3,constructed:true,captureAsn1:'certExtensions',optional:true}]},{// AlgorithmIdentifier (signature algorithm)
name:'Certificate.signatureAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// algorithm
name:'Certificate.signatureAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certSignatureOid'},{name:'Certificate.TBSCertificate.signature.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'certSignatureParams'}]},{// SignatureValue
name:'Certificate.signatureValue',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,captureBitStringValue:'certSignature'}]};var rsassaPssParameterValidator={name:'rsapss',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'rsapss.hashAlgorithm',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,value:[{name:'rsapss.hashAlgorithm.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.SEQUENCE,constructed:true,optional:true,value:[{name:'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'hashOid'/* parameter block omitted, for SHA1 NULL anyhow. */}]}]},{name:'rsapss.maskGenAlgorithm',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.SEQUENCE,constructed:true,optional:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'maskGenOid'},{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'maskGenHashOid'/* parameter block omitted, for SHA1 NULL anyhow. */}]}]}]},{name:'rsapss.saltLength',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:2,optional:true,value:[{name:'rsapss.saltLength.saltLength',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.INTEGER,constructed:false,capture:'saltLength'}]},{name:'rsapss.trailerField',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:3,optional:true,value:[{name:'rsapss.trailer.trailer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.INTEGER,constructed:false,capture:'trailer'}]}]};// validator for a CertificationRequestInfo structure
var certificationRequestInfoValidator={name:'CertificationRequestInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certificationRequestInfo',value:[{name:'CertificationRequestInfo.integer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certificationRequestInfoVersion'},{// Name (subject) (RDNSequence)
name:'CertificationRequestInfo.subject',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certificationRequestInfoSubject'},// SubjectPublicKeyInfo
publicKeyValidator,{name:'CertificationRequestInfo.attributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,capture:'certificationRequestInfoAttributes',value:[{name:'CertificationRequestInfo.attributes',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'CertificationRequestInfo.attributes.type',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false},{name:'CertificationRequestInfo.attributes.value',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true}]}]}]};// validator for a CertificationRequest structure
var certificationRequestValidator={name:'CertificationRequest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'csr',value:[certificationRequestInfoValidator,{// AlgorithmIdentifier (signature algorithm)
name:'CertificationRequest.signatureAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// algorithm
name:'CertificationRequest.signatureAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'csrSignatureOid'},{name:'CertificationRequest.signatureAlgorithm.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'csrSignatureParams'}]},{// signature
name:'CertificationRequest.signature',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,captureBitStringValue:'csrSignature'}]};/**
 * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
 * sets into an array with objects that have type and value properties.
 *
 * @param rdn the RDNSequence to convert.
 * @param md a message digest to append type and value to if provided.
 */pki.RDNAttributesAsArray=function(rdn,md){var rval=[];// each value in 'rdn' in is a SET of RelativeDistinguishedName
var set,attr,obj;for(var si=0;si<rdn.value.length;++si){// get the RelativeDistinguishedName set
set=rdn.value[si];// each value in the SET is an AttributeTypeAndValue sequence
// containing first a type (an OID) and second a value (defined by
// the OID)
for(var i=0;i<set.value.length;++i){obj={};attr=set.value[i];obj.type=asn1.derToOid(attr.value[0].value);obj.value=attr.value[1].value;obj.valueTagClass=attr.value[1].type;// if the OID is known, get its name and short name
if(obj.type in oids){obj.name=oids[obj.type];if(obj.name in _shortNames){obj.shortName=_shortNames[obj.name];}}if(md){md.update(obj.type);md.update(obj.value);}rval.push(obj);}}return rval;};/**
 * Converts ASN.1 CRIAttributes into an array with objects that have type and
 * value properties.
 *
 * @param attributes the CRIAttributes to convert.
 */pki.CRIAttributesAsArray=function(attributes){var rval=[];// each value in 'attributes' in is a SEQUENCE with an OID and a SET
for(var si=0;si<attributes.length;++si){// get the attribute sequence
var seq=attributes[si];// each value in the SEQUENCE containing first a type (an OID) and
// second a set of values (defined by the OID)
var type=asn1.derToOid(seq.value[0].value);var values=seq.value[1].value;for(var vi=0;vi<values.length;++vi){var obj={};obj.type=type;obj.value=values[vi].value;obj.valueTagClass=values[vi].type;// if the OID is known, get its name and short name
if(obj.type in oids){obj.name=oids[obj.type];if(obj.name in _shortNames){obj.shortName=_shortNames[obj.name];}}// parse extensions
if(obj.type===oids.extensionRequest){obj.extensions=[];for(var ei=0;ei<obj.value.length;++ei){obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));}}rval.push(obj);}}return rval;};/**
 * Gets an issuer or subject attribute from its name, type, or short name.
 *
 * @param obj the issuer or subject object.
 * @param options a short name string or an object with:
 *          shortName the short name for the attribute.
 *          name the name for the attribute.
 *          type the type for the attribute.
 *
 * @return the attribute.
 */function _getAttribute(obj,options){if(typeof options==='string'){options={shortName:options};}var rval=null;var attr;for(var i=0;rval===null&&i<obj.attributes.length;++i){attr=obj.attributes[i];if(options.type&&options.type===attr.type){rval=attr;}else if(options.name&&options.name===attr.name){rval=attr;}else if(options.shortName&&options.shortName===attr.shortName){rval=attr;}}return rval;}/**
 * Converts signature parameters from ASN.1 structure.
 *
 * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
 * no parameters.
 *
 * RSASSA-PSS-params  ::=  SEQUENCE  {
 *   hashAlgorithm      [0] HashAlgorithm DEFAULT
 *                             sha1Identifier,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
 *                             mgf1SHA1Identifier,
 *   saltLength         [2] INTEGER DEFAULT 20,
 *   trailerField       [3] INTEGER DEFAULT 1
 * }
 *
 * HashAlgorithm  ::=  AlgorithmIdentifier
 *
 * MaskGenAlgorithm  ::=  AlgorithmIdentifier
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * @param oid The OID specifying the signature algorithm
 * @param obj The ASN.1 structure holding the parameters
 * @param fillDefaults Whether to use return default values where omitted
 * @return signature parameter object
 */var _readSignatureParameters=function _readSignatureParameters(oid,obj,fillDefaults){var params={};if(oid!==oids['RSASSA-PSS']){return params;}if(fillDefaults){params={hash:{algorithmOid:oids['sha1']},mgf:{algorithmOid:oids['mgf1'],hash:{algorithmOid:oids['sha1']}},saltLength:20};}var capture={};var errors=[];if(!asn1.validate(obj,rsassaPssParameterValidator,capture,errors)){var error=new Error('Cannot read RSASSA-PSS parameter block.');error.errors=errors;throw error;}if(capture.hashOid!==undefined){params.hash=params.hash||{};params.hash.algorithmOid=asn1.derToOid(capture.hashOid);}if(capture.maskGenOid!==undefined){params.mgf=params.mgf||{};params.mgf.algorithmOid=asn1.derToOid(capture.maskGenOid);params.mgf.hash=params.mgf.hash||{};params.mgf.hash.algorithmOid=asn1.derToOid(capture.maskGenHashOid);}if(capture.saltLength!==undefined){params.saltLength=capture.saltLength.charCodeAt(0);}return params;};/**
 * Converts an X.509 certificate from PEM format.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. This will scan the TBSCertificate part of the ASN.1
 * object while it is converted so it doesn't need to be converted back
 * to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certificate.
 */pki.certificateFromPem=function(pem,computeHash,strict){var msg=forge.pem.decode(pem)[0];if(msg.type!=='CERTIFICATE'&&msg.type!=='X509 CERTIFICATE'&&msg.type!=='TRUSTED CERTIFICATE'){var error=new Error('Could not convert certificate from PEM; PEM header type '+'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert certificate from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body,strict);return pki.certificateFromAsn1(obj,computeHash);};/**
 * Converts an X.509 certificate to PEM format.
 *
 * @param cert the certificate.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certificate.
 */pki.certificateToPem=function(cert,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'CERTIFICATE',body:asn1.toDer(pki.certificateToAsn1(cert)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts an RSA public key from PEM format.
 *
 * @param pem the PEM-formatted public key.
 *
 * @return the public key.
 */pki.publicKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='PUBLIC KEY'&&msg.type!=='RSA PUBLIC KEY'){var error=new Error('Could not convert public key from PEM; PEM header '+'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert public key from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body);return pki.publicKeyFromAsn1(obj);};/**
 * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */pki.publicKeyToPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'PUBLIC KEY',body:asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts an RSA public key to PEM format (using an RSAPublicKey).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */pki.publicKeyToRSAPublicKeyPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'RSA PUBLIC KEY',body:asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Gets a fingerprint for the given public key.
 *
 * @param options the options to use.
 *          [md] the message digest object to use (defaults to forge.md.sha1).
 *          [type] the type of fingerprint, such as 'RSAPublicKey',
 *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
 *          [encoding] an alternative output encoding, such as 'hex'
 *            (defaults to none, outputs a byte buffer).
 *          [delimiter] the delimiter to use between bytes for 'hex' encoded
 *            output, eg: ':' (defaults to none).
 *
 * @return the fingerprint as a byte buffer or other encoding based on options.
 */pki.getPublicKeyFingerprint=function(key,options){options=options||{};var md=options.md||forge.md.sha1.create();var type=options.type||'RSAPublicKey';var bytes;switch(type){case'RSAPublicKey':bytes=asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();break;case'SubjectPublicKeyInfo':bytes=asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();break;default:throw new Error('Unknown fingerprint type "'+options.type+'".');}// hash public key bytes
md.start();md.update(bytes);var digest=md.digest();if(options.encoding==='hex'){var hex=digest.toHex();if(options.delimiter){return hex.match(/.{2}/g).join(options.delimiter);}return hex;}else if(options.encoding==='binary'){return digest.getBytes();}else if(options.encoding){throw new Error('Unknown encoding "'+options.encoding+'".');}return digest;};/**
 * Converts a PKCS#10 certification request (CSR) from PEM format.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. This will scan the CertificationRequestInfo part of
 * the ASN.1 object while it is converted so it doesn't need to be converted
 * back to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certification request (CSR).
 */pki.certificationRequestFromPem=function(pem,computeHash,strict){var msg=forge.pem.decode(pem)[0];if(msg.type!=='CERTIFICATE REQUEST'){var error=new Error('Could not convert certification request from PEM; '+'PEM header type is not "CERTIFICATE REQUEST".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert certification request from PEM; '+'PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body,strict);return pki.certificationRequestFromAsn1(obj,computeHash);};/**
 * Converts a PKCS#10 certification request (CSR) to PEM format.
 *
 * @param csr the certification request.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certification request.
 */pki.certificationRequestToPem=function(csr,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'CERTIFICATE REQUEST',body:asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Creates an empty X.509v3 RSA certificate.
 *
 * @return the certificate.
 */pki.createCertificate=function(){var cert={};cert.version=0x02;cert.serialNumber='00';cert.signatureOid=null;cert.signature=null;cert.siginfo={};cert.siginfo.algorithmOid=null;cert.validity={};cert.validity.notBefore=new Date();cert.validity.notAfter=new Date();cert.issuer={};cert.issuer.getField=function(sn){return _getAttribute(cert.issuer,sn);};cert.issuer.addField=function(attr){_fillMissingFields([attr]);cert.issuer.attributes.push(attr);};cert.issuer.attributes=[];cert.issuer.hash=null;cert.subject={};cert.subject.getField=function(sn){return _getAttribute(cert.subject,sn);};cert.subject.addField=function(attr){_fillMissingFields([attr]);cert.subject.attributes.push(attr);};cert.subject.attributes=[];cert.subject.hash=null;cert.extensions=[];cert.publicKey=null;cert.md=null;/**
   * Sets the subject of this certificate.
   *
   * @param attrs the array of subject attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */cert.setSubject=function(attrs,uniqueId){// set new attributes, clear hash
_fillMissingFields(attrs);cert.subject.attributes=attrs;delete cert.subject.uniqueId;if(uniqueId){// TODO: support arbitrary bit length ids
cert.subject.uniqueId=uniqueId;}cert.subject.hash=null;};/**
   * Sets the issuer of this certificate.
   *
   * @param attrs the array of issuer attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */cert.setIssuer=function(attrs,uniqueId){// set new attributes, clear hash
_fillMissingFields(attrs);cert.issuer.attributes=attrs;delete cert.issuer.uniqueId;if(uniqueId){// TODO: support arbitrary bit length ids
cert.issuer.uniqueId=uniqueId;}cert.issuer.hash=null;};/**
   * Sets the extensions of this certificate.
   *
   * @param exts the array of extensions to use.
   */cert.setExtensions=function(exts){for(var i=0;i<exts.length;++i){_fillMissingExtensionFields(exts[i],{cert:cert});}// set new extensions
cert.extensions=exts;};/**
   * Gets an extension by its name or id.
   *
   * @param options the name to use or an object with:
   *          name the name to use.
   *          id the id to use.
   *
   * @return the extension or null if not found.
   */cert.getExtension=function(options){if(typeof options==='string'){options={name:options};}var rval=null;var ext;for(var i=0;rval===null&&i<cert.extensions.length;++i){ext=cert.extensions[i];if(options.id&&ext.id===options.id){rval=ext;}else if(options.name&&ext.name===options.name){rval=ext;}}return rval;};/**
   * Signs this certificate using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */cert.sign=function(key,md){// TODO: get signature OID from private key
cert.md=md||forge.md.sha1.create();var algorithmOid=oids[cert.md.algorithm+'WithRSAEncryption'];if(!algorithmOid){var error=new Error('Could not compute certificate digest. '+'Unknown message digest algorithm OID.');error.algorithm=cert.md.algorithm;throw error;}cert.signatureOid=cert.siginfo.algorithmOid=algorithmOid;// get TBSCertificate, convert to DER
cert.tbsCertificate=pki.getTBSCertificate(cert);var bytes=asn1.toDer(cert.tbsCertificate);// digest and sign
cert.md.update(bytes.getBytes());cert.signature=key.sign(cert.md);};/**
   * Attempts verify the signature on the passed certificate using this
   * certificate's public key.
   *
   * @param child the certificate to verify.
   *
   * @return true if verified, false if not.
   */cert.verify=function(child){var rval=false;if(!cert.issued(child)){var issuer=child.issuer;var subject=cert.subject;var error=new Error('The parent certificate did not issue the given child '+'certificate; the child certificate\'s issuer does not match the '+'parent\'s subject.');error.expectedIssuer=issuer.attributes;error.actualIssuer=subject.attributes;throw error;}var md=child.md;if(md===null){// check signature OID for supported signature types
if(child.signatureOid in oids){var oid=oids[child.signatureOid];switch(oid){case'sha1WithRSAEncryption':md=forge.md.sha1.create();break;case'md5WithRSAEncryption':md=forge.md.md5.create();break;case'sha256WithRSAEncryption':md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':md=forge.md.sha512.create();break;case'RSASSA-PSS':md=forge.md.sha256.create();break;}}if(md===null){var error=new Error('Could not compute certificate digest. '+'Unknown signature OID.');error.signatureOid=child.signatureOid;throw error;}// produce DER formatted TBSCertificate and digest it
var tbsCertificate=child.tbsCertificate||pki.getTBSCertificate(child);var bytes=asn1.toDer(tbsCertificate);md.update(bytes.getBytes());}if(md!==null){var scheme;switch(child.signatureOid){case oids.sha1WithRSAEncryption:scheme=undefined;/* use PKCS#1 v1.5 padding scheme */break;case oids['RSASSA-PSS']:var hash,mgf;/* initialize mgf */hash=oids[child.signatureParameters.mgf.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported MGF hash function.');error.oid=child.signatureParameters.mgf.hash.algorithmOid;error.name=hash;throw error;}mgf=oids[child.signatureParameters.mgf.algorithmOid];if(mgf===undefined||forge.mgf[mgf]===undefined){var error=new Error('Unsupported MGF function.');error.oid=child.signatureParameters.mgf.algorithmOid;error.name=mgf;throw error;}mgf=forge.mgf[mgf].create(forge.md[hash].create());/* initialize hash function */hash=oids[child.signatureParameters.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){throw{message:'Unsupported RSASSA-PSS hash function.',oid:child.signatureParameters.hash.algorithmOid,name:hash};}scheme=forge.pss.create(forge.md[hash].create(),mgf,child.signatureParameters.saltLength);break;}// verify signature on cert using public key
rval=cert.publicKey.verify(md.digest().getBytes(),child.signature,scheme);}return rval;};/**
   * Returns true if this certificate's issuer matches the passed
   * certificate's subject. Note that no signature check is performed.
   *
   * @param parent the certificate to check.
   *
   * @return true if this certificate's issuer matches the passed certificate's
   *         subject.
   */cert.isIssuer=function(parent){var rval=false;var i=cert.issuer;var s=parent.subject;// compare hashes if present
if(i.hash&&s.hash){rval=i.hash===s.hash;}else if(i.attributes.length===s.attributes.length){// all attributes are the same so issuer matches subject
rval=true;var iattr,sattr;for(var n=0;rval&&n<i.attributes.length;++n){iattr=i.attributes[n];sattr=s.attributes[n];if(iattr.type!==sattr.type||iattr.value!==sattr.value){// attribute mismatch
rval=false;}}}return rval;};/**
   * Returns true if this certificate's subject matches the issuer of the
   * given certificate). Note that not signature check is performed.
   *
   * @param child the certificate to check.
   *
   * @return true if this certificate's subject matches the passed
   *         certificate's issuer.
   */cert.issued=function(child){return child.isIssuer(cert);};/**
   * Generates the subjectKeyIdentifier for this certificate as byte buffer.
   *
   * @return the subjectKeyIdentifier for this certificate as byte buffer.
   */cert.generateSubjectKeyIdentifier=function(){/* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:

      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
        value of the BIT STRING subjectPublicKey (excluding the tag,
        length, and number of unused bits).

      (2) The keyIdentifier is composed of a four bit type field with
        the value 0100 followed by the least significant 60 bits of the
        SHA-1 hash of the value of the BIT STRING subjectPublicKey
        (excluding the tag, length, and number of unused bit string bits).
    */ // skipping the tag, length, and number of unused bits is the same
// as just using the RSAPublicKey (for RSA keys, which are the
// only ones supported)
return pki.getPublicKeyFingerprint(cert.publicKey,{type:'RSAPublicKey'});};/**
   * Verifies the subjectKeyIdentifier extension value for this certificate
   * against its public key. If no extension is found, false will be
   * returned.
   *
   * @return true if verified, false if not.
   */cert.verifySubjectKeyIdentifier=function(){var oid=oids['subjectKeyIdentifier'];for(var i=0;i<cert.extensions.length;++i){var ext=cert.extensions[i];if(ext.id===oid){var ski=cert.generateSubjectKeyIdentifier().getBytes();return forge.util.hexToBytes(ext.subjectKeyIdentifier)===ski;}}return false;};return cert;};/**
 * Converts an X.509v3 RSA certificate from an ASN.1 object.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
 * object needs to be scanned before the cert object is created.
 *
 * @param obj the asn1 representation of an X.509v3 RSA certificate.
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certificate.
 */pki.certificateFromAsn1=function(obj,computeHash){// validate certificate and capture data
var capture={};var errors=[];if(!asn1.validate(obj,x509CertificateValidator,capture,errors)){var error=new Error('Cannot read X.509 certificate. '+'ASN.1 object is not an X509v3 Certificate.');error.errors=errors;throw error;}// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){throw new Error('Cannot read public key. OID is not RSA.');}// create certificate
var cert=pki.createCertificate();cert.version=capture.certVersion?capture.certVersion.charCodeAt(0):0;var serial=forge.util.createBuffer(capture.certSerialNumber);cert.serialNumber=serial.toHex();cert.signatureOid=forge.asn1.derToOid(capture.certSignatureOid);cert.signatureParameters=_readSignatureParameters(cert.signatureOid,capture.certSignatureParams,true);cert.siginfo.algorithmOid=forge.asn1.derToOid(capture.certinfoSignatureOid);cert.siginfo.parameters=_readSignatureParameters(cert.siginfo.algorithmOid,capture.certinfoSignatureParams,false);cert.signature=capture.certSignature;var validity=[];if(capture.certValidity1UTCTime!==undefined){validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));}if(capture.certValidity2GeneralizedTime!==undefined){validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));}if(capture.certValidity3UTCTime!==undefined){validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));}if(capture.certValidity4GeneralizedTime!==undefined){validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));}if(validity.length>2){throw new Error('Cannot read notBefore/notAfter validity times; more '+'than two times were provided in the certificate.');}if(validity.length<2){throw new Error('Cannot read notBefore/notAfter validity times; they '+'were not provided as either UTCTime or GeneralizedTime.');}cert.validity.notBefore=validity[0];cert.validity.notAfter=validity[1];// keep TBSCertificate to preserve signature when exporting
cert.tbsCertificate=capture.tbsCertificate;if(computeHash){// check signature OID for supported signature types
cert.md=null;if(cert.signatureOid in oids){var oid=oids[cert.signatureOid];switch(oid){case'sha1WithRSAEncryption':cert.md=forge.md.sha1.create();break;case'md5WithRSAEncryption':cert.md=forge.md.md5.create();break;case'sha256WithRSAEncryption':cert.md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':cert.md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':cert.md=forge.md.sha512.create();break;case'RSASSA-PSS':cert.md=forge.md.sha256.create();break;}}if(cert.md===null){var error=new Error('Could not compute certificate digest. '+'Unknown signature OID.');error.signatureOid=cert.signatureOid;throw error;}// produce DER formatted TBSCertificate and digest it
var bytes=asn1.toDer(cert.tbsCertificate);cert.md.update(bytes.getBytes());}// handle issuer, build issuer message digest
var imd=forge.md.sha1.create();cert.issuer.getField=function(sn){return _getAttribute(cert.issuer,sn);};cert.issuer.addField=function(attr){_fillMissingFields([attr]);cert.issuer.attributes.push(attr);};cert.issuer.attributes=pki.RDNAttributesAsArray(capture.certIssuer,imd);if(capture.certIssuerUniqueId){cert.issuer.uniqueId=capture.certIssuerUniqueId;}cert.issuer.hash=imd.digest().toHex();// handle subject, build subject message digest
var smd=forge.md.sha1.create();cert.subject.getField=function(sn){return _getAttribute(cert.subject,sn);};cert.subject.addField=function(attr){_fillMissingFields([attr]);cert.subject.attributes.push(attr);};cert.subject.attributes=pki.RDNAttributesAsArray(capture.certSubject,smd);if(capture.certSubjectUniqueId){cert.subject.uniqueId=capture.certSubjectUniqueId;}cert.subject.hash=smd.digest().toHex();// handle extensions
if(capture.certExtensions){cert.extensions=pki.certificateExtensionsFromAsn1(capture.certExtensions);}else{cert.extensions=[];}// convert RSA public key from ASN.1
cert.publicKey=pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);return cert;};/**
 * Converts an ASN.1 extensions object (with extension sequences as its
 * values) into an array of extension objects with types and values.
 *
 * Supported extensions:
 *
 * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 * KeyUsage ::= BIT STRING {
 *   digitalSignature        (0),
 *   nonRepudiation          (1),
 *   keyEncipherment         (2),
 *   dataEncipherment        (3),
 *   keyAgreement            (4),
 *   keyCertSign             (5),
 *   cRLSign                 (6),
 *   encipherOnly            (7),
 *   decipherOnly            (8)
 * }
 *
 * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
 * BasicConstraints ::= SEQUENCE {
 *   cA                      BOOLEAN DEFAULT FALSE,
 *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
 * }
 *
 * subjectAltName EXTENSION ::= {
 *   SYNTAX GeneralNames
 *   IDENTIFIED BY id-ce-subjectAltName
 * }
 *
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 *
 * GeneralName ::= CHOICE {
 *   otherName      [0] INSTANCE OF OTHER-NAME,
 *   rfc822Name     [1] IA5String,
 *   dNSName        [2] IA5String,
 *   x400Address    [3] ORAddress,
 *   directoryName  [4] Name,
 *   ediPartyName   [5] EDIPartyName,
 *   uniformResourceIdentifier [6] IA5String,
 *   IPAddress      [7] OCTET STRING,
 *   registeredID   [8] OBJECT IDENTIFIER
 * }
 *
 * OTHER-NAME ::= TYPE-IDENTIFIER
 *
 * EDIPartyName ::= SEQUENCE {
 *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
 *   partyName    [1] DirectoryString {ub-name}
 * }
 *
 * @param exts the extensions ASN.1 with extension sequences to parse.
 *
 * @return the array.
 */pki.certificateExtensionsFromAsn1=function(exts){var rval=[];for(var i=0;i<exts.value.length;++i){// get extension sequence
var extseq=exts.value[i];for(var ei=0;ei<extseq.value.length;++ei){rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));}}return rval;};/**
 * Parses a single certificate extension from ASN.1.
 *
 * @param ext the extension in ASN.1 format.
 *
 * @return the parsed extension as an object.
 */pki.certificateExtensionFromAsn1=function(ext){// an extension has:
// [0] extnID      OBJECT IDENTIFIER
// [1] critical    BOOLEAN DEFAULT FALSE
// [2] extnValue   OCTET STRING
var e={};e.id=asn1.derToOid(ext.value[0].value);e.critical=false;if(ext.value[1].type===asn1.Type.BOOLEAN){e.critical=ext.value[1].value.charCodeAt(0)!==0x00;e.value=ext.value[2].value;}else{e.value=ext.value[1].value;}// if the oid is known, get its name
if(e.id in oids){e.name=oids[e.id];// handle key usage
if(e.name==='keyUsage'){// get value as BIT STRING
var ev=asn1.fromDer(e.value);var b2=0x00;var b3=0x00;if(ev.value.length>1){// skip first byte, just indicates unused bits which
// will be padded with 0s anyway
// get bytes with flag bits
b2=ev.value.charCodeAt(1);b3=ev.value.length>2?ev.value.charCodeAt(2):0;}// set flags
e.digitalSignature=(b2&0x80)===0x80;e.nonRepudiation=(b2&0x40)===0x40;e.keyEncipherment=(b2&0x20)===0x20;e.dataEncipherment=(b2&0x10)===0x10;e.keyAgreement=(b2&0x08)===0x08;e.keyCertSign=(b2&0x04)===0x04;e.cRLSign=(b2&0x02)===0x02;e.encipherOnly=(b2&0x01)===0x01;e.decipherOnly=(b3&0x80)===0x80;}else if(e.name==='basicConstraints'){// handle basic constraints
// get value as SEQUENCE
var ev=asn1.fromDer(e.value);// get cA BOOLEAN flag (defaults to false)
if(ev.value.length>0&&ev.value[0].type===asn1.Type.BOOLEAN){e.cA=ev.value[0].value.charCodeAt(0)!==0x00;}else{e.cA=false;}// get path length constraint
var value=null;if(ev.value.length>0&&ev.value[0].type===asn1.Type.INTEGER){value=ev.value[0].value;}else if(ev.value.length>1){value=ev.value[1].value;}if(value!==null){e.pathLenConstraint=asn1.derToInteger(value);}}else if(e.name==='extKeyUsage'){// handle extKeyUsage
// value is a SEQUENCE of OIDs
var ev=asn1.fromDer(e.value);for(var vi=0;vi<ev.value.length;++vi){var oid=asn1.derToOid(ev.value[vi].value);if(oid in oids){e[oids[oid]]=true;}else{e[oid]=true;}}}else if(e.name==='nsCertType'){// handle nsCertType
// get value as BIT STRING
var ev=asn1.fromDer(e.value);var b2=0x00;if(ev.value.length>1){// skip first byte, just indicates unused bits which
// will be padded with 0s anyway
// get bytes with flag bits
b2=ev.value.charCodeAt(1);}// set flags
e.client=(b2&0x80)===0x80;e.server=(b2&0x40)===0x40;e.email=(b2&0x20)===0x20;e.objsign=(b2&0x10)===0x10;e.reserved=(b2&0x08)===0x08;e.sslCA=(b2&0x04)===0x04;e.emailCA=(b2&0x02)===0x02;e.objCA=(b2&0x01)===0x01;}else if(e.name==='subjectAltName'||e.name==='issuerAltName'){// handle subjectAltName/issuerAltName
e.altNames=[];// ev is a SYNTAX SEQUENCE
var gn;var ev=asn1.fromDer(e.value);for(var n=0;n<ev.value.length;++n){// get GeneralName
gn=ev.value[n];var altName={type:gn.type,value:gn.value};e.altNames.push(altName);// Note: Support for types 1,2,6,7,8
switch(gn.type){// rfc822Name
case 1:// dNSName
case 2:// uniformResourceIdentifier (URI)
case 6:break;// IPAddress
case 7:// convert to IPv4/IPv6 string representation
altName.ip=forge.util.bytesToIP(gn.value);break;// registeredID
case 8:altName.oid=asn1.derToOid(gn.value);break;default:// unsupported
}}}else if(e.name==='subjectKeyIdentifier'){// value is an OCTETSTRING w/the hash of the key-type specific
// public key structure (eg: RSAPublicKey)
var ev=asn1.fromDer(e.value);e.subjectKeyIdentifier=forge.util.bytesToHex(ev.value);}}return e;};/**
 * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the CertificationRequestInfo part of the
 * ASN.1 object needs to be scanned before the csr object is created.
 *
 * @param obj the asn1 representation of a PKCS#10 certification request (CSR).
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certification request (CSR).
 */pki.certificationRequestFromAsn1=function(obj,computeHash){// validate certification request and capture data
var capture={};var errors=[];if(!asn1.validate(obj,certificationRequestValidator,capture,errors)){var error=new Error('Cannot read PKCS#10 certificate request. '+'ASN.1 object is not a PKCS#10 CertificationRequest.');error.errors=errors;throw error;}// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){throw new Error('Cannot read public key. OID is not RSA.');}// create certification request
var csr=pki.createCertificationRequest();csr.version=capture.csrVersion?capture.csrVersion.charCodeAt(0):0;csr.signatureOid=forge.asn1.derToOid(capture.csrSignatureOid);csr.signatureParameters=_readSignatureParameters(csr.signatureOid,capture.csrSignatureParams,true);csr.siginfo.algorithmOid=forge.asn1.derToOid(capture.csrSignatureOid);csr.siginfo.parameters=_readSignatureParameters(csr.siginfo.algorithmOid,capture.csrSignatureParams,false);csr.signature=capture.csrSignature;// keep CertificationRequestInfo to preserve signature when exporting
csr.certificationRequestInfo=capture.certificationRequestInfo;if(computeHash){// check signature OID for supported signature types
csr.md=null;if(csr.signatureOid in oids){var oid=oids[csr.signatureOid];switch(oid){case'sha1WithRSAEncryption':csr.md=forge.md.sha1.create();break;case'md5WithRSAEncryption':csr.md=forge.md.md5.create();break;case'sha256WithRSAEncryption':csr.md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':csr.md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':csr.md=forge.md.sha512.create();break;case'RSASSA-PSS':csr.md=forge.md.sha256.create();break;}}if(csr.md===null){var error=new Error('Could not compute certification request digest. '+'Unknown signature OID.');error.signatureOid=csr.signatureOid;throw error;}// produce DER formatted CertificationRequestInfo and digest it
var bytes=asn1.toDer(csr.certificationRequestInfo);csr.md.update(bytes.getBytes());}// handle subject, build subject message digest
var smd=forge.md.sha1.create();csr.subject.getField=function(sn){return _getAttribute(csr.subject,sn);};csr.subject.addField=function(attr){_fillMissingFields([attr]);csr.subject.attributes.push(attr);};csr.subject.attributes=pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject,smd);csr.subject.hash=smd.digest().toHex();// convert RSA public key from ASN.1
csr.publicKey=pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);// convert attributes from ASN.1
csr.getAttribute=function(sn){return _getAttribute(csr,sn);};csr.addAttribute=function(attr){_fillMissingFields([attr]);csr.attributes.push(attr);};csr.attributes=pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes||[]);return csr;};/**
 * Creates an empty certification request (a CSR or certificate signing
 * request). Once created, its public key and attributes can be set and then
 * it can be signed.
 *
 * @return the empty certification request.
 */pki.createCertificationRequest=function(){var csr={};csr.version=0x00;csr.signatureOid=null;csr.signature=null;csr.siginfo={};csr.siginfo.algorithmOid=null;csr.subject={};csr.subject.getField=function(sn){return _getAttribute(csr.subject,sn);};csr.subject.addField=function(attr){_fillMissingFields([attr]);csr.subject.attributes.push(attr);};csr.subject.attributes=[];csr.subject.hash=null;csr.publicKey=null;csr.attributes=[];csr.getAttribute=function(sn){return _getAttribute(csr,sn);};csr.addAttribute=function(attr){_fillMissingFields([attr]);csr.attributes.push(attr);};csr.md=null;/**
   * Sets the subject of this certification request.
   *
   * @param attrs the array of subject attributes to use.
   */csr.setSubject=function(attrs){// set new attributes
_fillMissingFields(attrs);csr.subject.attributes=attrs;csr.subject.hash=null;};/**
   * Sets the attributes of this certification request.
   *
   * @param attrs the array of attributes to use.
   */csr.setAttributes=function(attrs){// set new attributes
_fillMissingFields(attrs);csr.attributes=attrs;};/**
   * Signs this certification request using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */csr.sign=function(key,md){// TODO: get signature OID from private key
csr.md=md||forge.md.sha1.create();var algorithmOid=oids[csr.md.algorithm+'WithRSAEncryption'];if(!algorithmOid){var error=new Error('Could not compute certification request digest. '+'Unknown message digest algorithm OID.');error.algorithm=csr.md.algorithm;throw error;}csr.signatureOid=csr.siginfo.algorithmOid=algorithmOid;// get CertificationRequestInfo, convert to DER
csr.certificationRequestInfo=pki.getCertificationRequestInfo(csr);var bytes=asn1.toDer(csr.certificationRequestInfo);// digest and sign
csr.md.update(bytes.getBytes());csr.signature=key.sign(csr.md);};/**
   * Attempts verify the signature on the passed certification request using
   * its public key.
   *
   * A CSR that has been exported to a file in PEM format can be verified using
   * OpenSSL using this command:
   *
   * openssl req -in <the-csr-pem-file> -verify -noout -text
   *
   * @return true if verified, false if not.
   */csr.verify=function(){var rval=false;var md=csr.md;if(md===null){// check signature OID for supported signature types
if(csr.signatureOid in oids){// TODO: create DRY `OID to md` function
var oid=oids[csr.signatureOid];switch(oid){case'sha1WithRSAEncryption':md=forge.md.sha1.create();break;case'md5WithRSAEncryption':md=forge.md.md5.create();break;case'sha256WithRSAEncryption':md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':md=forge.md.sha512.create();break;case'RSASSA-PSS':md=forge.md.sha256.create();break;}}if(md===null){var error=new Error('Could not compute certification request digest. '+'Unknown signature OID.');error.signatureOid=csr.signatureOid;throw error;}// produce DER formatted CertificationRequestInfo and digest it
var cri=csr.certificationRequestInfo||pki.getCertificationRequestInfo(csr);var bytes=asn1.toDer(cri);md.update(bytes.getBytes());}if(md!==null){var scheme;switch(csr.signatureOid){case oids.sha1WithRSAEncryption:/* use PKCS#1 v1.5 padding scheme */break;case oids['RSASSA-PSS']:var hash,mgf;/* initialize mgf */hash=oids[csr.signatureParameters.mgf.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported MGF hash function.');error.oid=csr.signatureParameters.mgf.hash.algorithmOid;error.name=hash;throw error;}mgf=oids[csr.signatureParameters.mgf.algorithmOid];if(mgf===undefined||forge.mgf[mgf]===undefined){var error=new Error('Unsupported MGF function.');error.oid=csr.signatureParameters.mgf.algorithmOid;error.name=mgf;throw error;}mgf=forge.mgf[mgf].create(forge.md[hash].create());/* initialize hash function */hash=oids[csr.signatureParameters.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported RSASSA-PSS hash function.');error.oid=csr.signatureParameters.hash.algorithmOid;error.name=hash;throw error;}scheme=forge.pss.create(forge.md[hash].create(),mgf,csr.signatureParameters.saltLength);break;}// verify signature on csr using its public key
rval=csr.publicKey.verify(md.digest().getBytes(),csr.signature,scheme);}return rval;};return csr;};/**
 * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
 *
 * @param obj the subject or issuer (distinguished name).
 *
 * @return the ASN.1 RDNSequence.
 */function _dnToAsn1(obj){// create an empty RDNSequence
var rval=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// iterate over attributes
var attr,set;var attrs=obj.attributes;for(var i=0;i<attrs.length;++i){attr=attrs[i];var value=attr.value;// reuse tag class for attribute value if available
var valueTagClass=asn1.Type.PRINTABLESTRING;if('valueTagClass'in attr){valueTagClass=attr.valueTagClass;if(valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(value);}// FIXME: handle more encodings
}// create a RelativeDistinguishedName set
// each value in the set is an AttributeTypeAndValue first
// containing the type (an OID) and second the value
set=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AttributeType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(attr.type).getBytes()),// AttributeValue
asn1.create(asn1.Class.UNIVERSAL,valueTagClass,false,value)])]);rval.value.push(set);}return rval;}/**
 * Gets all printable attributes (typically of an issuer or subject) in a
 * simplified JSON format for display.
 *
 * @param attrs the attributes.
 *
 * @return the JSON for display.
 */function _getAttributesAsJson(attrs){var rval={};for(var i=0;i<attrs.length;++i){var attr=attrs[i];if(attr.shortName&&(attr.valueTagClass===asn1.Type.UTF8||attr.valueTagClass===asn1.Type.PRINTABLESTRING||attr.valueTagClass===asn1.Type.IA5STRING)){var value=attr.value;if(attr.valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(attr.value);}if(!(attr.shortName in rval)){rval[attr.shortName]=value;}else if(forge.util.isArray(rval[attr.shortName])){rval[attr.shortName].push(value);}else{rval[attr.shortName]=[rval[attr.shortName],value];}}}return rval;}/**
 * Fills in missing fields in attributes.
 *
 * @param attrs the attributes to fill missing fields in.
 */function _fillMissingFields(attrs){var attr;for(var i=0;i<attrs.length;++i){attr=attrs[i];// populate missing name
if(typeof attr.name==='undefined'){if(attr.type&&attr.type in pki.oids){attr.name=pki.oids[attr.type];}else if(attr.shortName&&attr.shortName in _shortNames){attr.name=pki.oids[_shortNames[attr.shortName]];}}// populate missing type (OID)
if(typeof attr.type==='undefined'){if(attr.name&&attr.name in pki.oids){attr.type=pki.oids[attr.name];}else{var error=new Error('Attribute type not specified.');error.attribute=attr;throw error;}}// populate missing shortname
if(typeof attr.shortName==='undefined'){if(attr.name&&attr.name in _shortNames){attr.shortName=_shortNames[attr.name];}}// convert extensions to value
if(attr.type===oids.extensionRequest){attr.valueConstructed=true;attr.valueTagClass=asn1.Type.SEQUENCE;if(!attr.value&&attr.extensions){attr.value=[];for(var ei=0;ei<attr.extensions.length;++ei){attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));}}}if(typeof attr.value==='undefined'){var error=new Error('Attribute value not specified.');error.attribute=attr;throw error;}}}/**
 * Fills in missing fields in certificate extensions.
 *
 * @param e the extension.
 * @param [options] the options to use.
 *          [cert] the certificate the extensions are for.
 *
 * @return the extension.
 */function _fillMissingExtensionFields(e,options){options=options||{};// populate missing name
if(typeof e.name==='undefined'){if(e.id&&e.id in pki.oids){e.name=pki.oids[e.id];}}// populate missing id
if(typeof e.id==='undefined'){if(e.name&&e.name in pki.oids){e.id=pki.oids[e.name];}else{var error=new Error('Extension ID not specified.');error.extension=e;throw error;}}if(typeof e.value!=='undefined'){return e;}// handle missing value:
// value is a BIT STRING
if(e.name==='keyUsage'){// build flags
var unused=0;var b2=0x00;var b3=0x00;if(e.digitalSignature){b2|=0x80;unused=7;}if(e.nonRepudiation){b2|=0x40;unused=6;}if(e.keyEncipherment){b2|=0x20;unused=5;}if(e.dataEncipherment){b2|=0x10;unused=4;}if(e.keyAgreement){b2|=0x08;unused=3;}if(e.keyCertSign){b2|=0x04;unused=2;}if(e.cRLSign){b2|=0x02;unused=1;}if(e.encipherOnly){b2|=0x01;unused=0;}if(e.decipherOnly){b3|=0x80;unused=7;}// create bit string
var value=String.fromCharCode(unused);if(b3!==0){value+=String.fromCharCode(b2)+String.fromCharCode(b3);}else if(b2!==0){value+=String.fromCharCode(b2);}e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,value);}else if(e.name==='basicConstraints'){// basicConstraints is a SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// cA BOOLEAN flag defaults to false
if(e.cA){e.value.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BOOLEAN,false,String.fromCharCode(0xFF)));}if('pathLenConstraint'in e){e.value.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(e.pathLenConstraint).getBytes()));}}else if(e.name==='extKeyUsage'){// extKeyUsage is a SEQUENCE of OIDs
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;for(var key in e){if(e[key]!==true){continue;}// key is name in OID map
if(key in oids){seq.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids[key]).getBytes()));}else if(key.indexOf('.')!==-1){// assume key is an OID
seq.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(key).getBytes()));}}}else if(e.name==='nsCertType'){// nsCertType is a BIT STRING
// build flags
var unused=0;var b2=0x00;if(e.client){b2|=0x80;unused=7;}if(e.server){b2|=0x40;unused=6;}if(e.email){b2|=0x20;unused=5;}if(e.objsign){b2|=0x10;unused=4;}if(e.reserved){b2|=0x08;unused=3;}if(e.sslCA){b2|=0x04;unused=2;}if(e.emailCA){b2|=0x02;unused=1;}if(e.objCA){b2|=0x01;unused=0;}// create bit string
var value=String.fromCharCode(unused);if(b2!==0){value+=String.fromCharCode(b2);}e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,value);}else if(e.name==='subjectAltName'||e.name==='issuerAltName'){// SYNTAX SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var altName;for(var n=0;n<e.altNames.length;++n){altName=e.altNames[n];var value=altName.value;// handle IP
if(altName.type===7&&altName.ip){value=forge.util.bytesFromIP(altName.ip);if(value===null){var error=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');error.extension=e;throw error;}}else if(altName.type===8){// handle OID
if(altName.oid){value=asn1.oidToDer(asn1.oidToDer(altName.oid));}else{// deprecated ... convert value to OID
value=asn1.oidToDer(value);}}e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,altName.type,false,value));}}else if(e.name==='subjectKeyIdentifier'&&options.cert){var ski=options.cert.generateSubjectKeyIdentifier();e.subjectKeyIdentifier=ski.toHex();// OCTETSTRING w/digest
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,ski.getBytes());}else if(e.name==='authorityKeyIdentifier'&&options.cert){// SYNTAX SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;if(e.keyIdentifier){var keyIdentifier=e.keyIdentifier===true?options.cert.generateSubjectKeyIdentifier().getBytes():e.keyIdentifier;seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,false,keyIdentifier));}if(e.authorityCertIssuer){var authorityCertIssuer=[asn1.create(asn1.Class.CONTEXT_SPECIFIC,4,true,[_dnToAsn1(e.authorityCertIssuer===true?options.cert.issuer:e.authorityCertIssuer)])];seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,authorityCertIssuer));}if(e.serialNumber){var serialNumber=forge.util.hexToBytes(e.serialNumber===true?options.cert.serialNumber:e.serialNumber);seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,false,serialNumber));}}else if(e.name==='cRLDistributionPoints'){e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;// Create sub SEQUENCE of DistributionPointName
var subSeq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// Create fullName CHOICE
var fullNameGeneralNames=asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[]);var altName;for(var n=0;n<e.altNames.length;++n){altName=e.altNames[n];var value=altName.value;// handle IP
if(altName.type===7&&altName.ip){value=forge.util.bytesFromIP(altName.ip);if(value===null){var error=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');error.extension=e;throw error;}}else if(altName.type===8){// handle OID
if(altName.oid){value=asn1.oidToDer(asn1.oidToDer(altName.oid));}else{// deprecated ... convert value to OID
value=asn1.oidToDer(value);}}fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,altName.type,false,value));}// Add to the parent SEQUENCE
subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[fullNameGeneralNames]));seq.push(subSeq);}// ensure value has been defined by now
if(typeof e.value==='undefined'){var error=new Error('Extension value not specified.');error.extension=e;throw error;}return e;}/**
 * Convert signature parameters object to ASN.1
 *
 * @param {String} oid Signature algorithm OID
 * @param params The signature parametrs object
 * @return ASN.1 object representing signature parameters
 */function _signatureParametersToAsn1(oid,params){switch(oid){case oids['RSASSA-PSS']:var parts=[];if(params.hash.algorithmOid!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.hash.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')])]));}if(params.mgf.algorithmOid!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.mgf.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')])])]));}if(params.saltLength!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(params.saltLength).getBytes())]));}return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,parts);default:return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'');}}/**
 * Converts a certification request's attributes to an ASN.1 set of
 * CRIAttributes.
 *
 * @param csr certification request.
 *
 * @return the ASN.1 set of CRIAttributes.
 */function _CRIAttributesToAsn1(csr){// create an empty context-specific container
var rval=asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[]);// no attributes, return empty container
if(csr.attributes.length===0){return rval;}// each attribute has a sequence with a type and a set of values
var attrs=csr.attributes;for(var i=0;i<attrs.length;++i){var attr=attrs[i];var value=attr.value;// reuse tag class for attribute value if available
var valueTagClass=asn1.Type.UTF8;if('valueTagClass'in attr){valueTagClass=attr.valueTagClass;}if(valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(value);}var valueConstructed=false;if('valueConstructed'in attr){valueConstructed=attr.valueConstructed;}// FIXME: handle more encodings
// create a RelativeDistinguishedName set
// each value in the set is an AttributeTypeAndValue first
// containing the type (an OID) and second the value
var seq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AttributeType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(attr.type).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[// AttributeValue
asn1.create(asn1.Class.UNIVERSAL,valueTagClass,valueConstructed,value)])]);rval.value.push(seq);}return rval;}var jan_1_1950=new Date('1950-01-01T00:00:00Z');var jan_1_2050=new Date('2050-01-01T00:00:00Z');/**
 * Converts a Date object to ASN.1
 * Handles the different format before and after 1st January 2050
 *
 * @param date date object.
 *
 * @return the ASN.1 object representing the date.
 */function _dateToAsn1(date){if(date>=jan_1_1950&&date<jan_1_2050){return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.UTCTIME,false,asn1.dateToUtcTime(date));}else{return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.GENERALIZEDTIME,false,asn1.dateToGeneralizedTime(date));}}/**
 * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
 *
 * @param cert the certificate.
 *
 * @return the asn1 TBSCertificate.
 */pki.getTBSCertificate=function(cert){// TBSCertificate
var notBefore=_dateToAsn1(cert.validity.notBefore);var notAfter=_dateToAsn1(cert.validity.notAfter);var tbs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// integer
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(cert.version).getBytes())]),// serialNumber
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,forge.util.hexToBytes(cert.serialNumber)),// signature
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),// parameters
_signatureParametersToAsn1(cert.siginfo.algorithmOid,cert.siginfo.parameters)]),// issuer
_dnToAsn1(cert.issuer),// validity
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[notBefore,notAfter]),// subject
_dnToAsn1(cert.subject),// SubjectPublicKeyInfo
pki.publicKeyToAsn1(cert.publicKey)]);if(cert.issuer.uniqueId){// issuerUniqueID (optional)
tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,// TODO: support arbitrary bit length ids
String.fromCharCode(0x00)+cert.issuer.uniqueId)]));}if(cert.subject.uniqueId){// subjectUniqueID (optional)
tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,// TODO: support arbitrary bit length ids
String.fromCharCode(0x00)+cert.subject.uniqueId)]));}if(cert.extensions.length>0){// extensions (optional)
tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));}return tbs;};/**
 * Gets the ASN.1 CertificationRequestInfo part of a
 * PKCS#10 CertificationRequest.
 *
 * @param csr the certification request.
 *
 * @return the asn1 CertificationRequestInfo.
 */pki.getCertificationRequestInfo=function(csr){// CertificationRequestInfo
var cri=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(csr.version).getBytes()),// subject
_dnToAsn1(csr.subject),// SubjectPublicKeyInfo
pki.publicKeyToAsn1(csr.publicKey),// attributes
_CRIAttributesToAsn1(csr)]);return cri;};/**
 * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
 *
 * @param dn the DistinguishedName.
 *
 * @return the asn1 representation of a DistinguishedName.
 */pki.distinguishedNameToAsn1=function(dn){return _dnToAsn1(dn);};/**
 * Converts an X.509v3 RSA certificate to an ASN.1 object.
 *
 * @param cert the certificate.
 *
 * @return the asn1 representation of an X.509v3 RSA certificate.
 */pki.certificateToAsn1=function(cert){// prefer cached TBSCertificate over generating one
var tbsCertificate=cert.tbsCertificate||pki.getTBSCertificate(cert);// Certificate
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// TBSCertificate
tbsCertificate,// AlgorithmIdentifier (signature algorithm)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(cert.signatureOid).getBytes()),// parameters
_signatureParametersToAsn1(cert.signatureOid,cert.signatureParameters)]),// SignatureValue
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,String.fromCharCode(0x00)+cert.signature)]);};/**
 * Converts X.509v3 certificate extensions to ASN.1.
 *
 * @param exts the extensions to convert.
 *
 * @return the extensions in ASN.1 format.
 */pki.certificateExtensionsToAsn1=function(exts){// create top-level extension container
var rval=asn1.create(asn1.Class.CONTEXT_SPECIFIC,3,true,[]);// create extension sequence (stores a sequence for each extension)
var seq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);rval.value.push(seq);for(var i=0;i<exts.length;++i){seq.value.push(pki.certificateExtensionToAsn1(exts[i]));}return rval;};/**
 * Converts a single certificate extension to ASN.1.
 *
 * @param ext the extension to convert.
 *
 * @return the extension in ASN.1 format.
 */pki.certificateExtensionToAsn1=function(ext){// create a sequence for each extension
var extseq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// extnID (OID)
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(ext.id).getBytes()));// critical defaults to false
if(ext.critical){// critical BOOLEAN DEFAULT FALSE
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BOOLEAN,false,String.fromCharCode(0xFF)));}var value=ext.value;if(typeof ext.value!=='string'){// value is asn.1
value=asn1.toDer(value).getBytes();}// extnValue (OCTET STRING)
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,value));return extseq;};/**
 * Converts a PKCS#10 certification request to an ASN.1 object.
 *
 * @param csr the certification request.
 *
 * @return the asn1 representation of a certification request.
 */pki.certificationRequestToAsn1=function(csr){// prefer cached CertificationRequestInfo over generating one
var cri=csr.certificationRequestInfo||pki.getCertificationRequestInfo(csr);// Certificate
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// CertificationRequestInfo
cri,// AlgorithmIdentifier (signature algorithm)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(csr.signatureOid).getBytes()),// parameters
_signatureParametersToAsn1(csr.signatureOid,csr.signatureParameters)]),// signature
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,String.fromCharCode(0x00)+csr.signature)]);};/**
 * Creates a CA store.
 *
 * @param certs an optional array of certificate objects or PEM-formatted
 *          certificate strings to add to the CA store.
 *
 * @return the CA store.
 */pki.createCaStore=function(certs){// create CA store
var caStore={// stored certificates
certs:{}};/**
   * Gets the certificate that issued the passed certificate or its
   * 'parent'.
   *
   * @param cert the certificate to get the parent for.
   *
   * @return the parent certificate or null if none was found.
   */caStore.getIssuer=function(cert){var rval=getBySubject(cert.issuer);// see if there are multiple matches
/*if(forge.util.isArray(rval)) {
      // TODO: resolve multiple matches by checking
      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.
      // FIXME: or alternatively do authority key mapping
      // if possible (X.509v1 certs can't work?)
      throw new Error('Resolving multiple issuer matches not implemented yet.');
    }*/return rval;};/**
   * Adds a trusted certificate to the store.
   *
   * @param cert the certificate to add as a trusted certificate (either a
   *          pki.certificate object or a PEM-formatted certificate).
   */caStore.addCertificate=function(cert){// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}ensureSubjectHasHash(cert.subject);if(!caStore.hasCertificate(cert)){// avoid duplicate certificates in store
if(cert.subject.hash in caStore.certs){// subject hash already exists, append to array
var tmp=caStore.certs[cert.subject.hash];if(!forge.util.isArray(tmp)){tmp=[tmp];}tmp.push(cert);caStore.certs[cert.subject.hash]=tmp;}else{caStore.certs[cert.subject.hash]=cert;}}};/**
   * Checks to see if the given certificate is in the store.
   *
   * @param cert the certificate to check (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return true if the certificate is in the store, false if not.
   */caStore.hasCertificate=function(cert){// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}var match=getBySubject(cert.subject);if(!match){return false;}if(!forge.util.isArray(match)){match=[match];}// compare DER-encoding of certificates
var der1=asn1.toDer(pki.certificateToAsn1(cert)).getBytes();for(var i=0;i<match.length;++i){var der2=asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();if(der1===der2){return true;}}return false;};/**
   * Lists all of the certificates kept in the store.
   *
   * @return an array of all of the pki.certificate objects in the store.
   */caStore.listAllCertificates=function(){var certList=[];for(var hash in caStore.certs){if(caStore.certs.hasOwnProperty(hash)){var value=caStore.certs[hash];if(!forge.util.isArray(value)){certList.push(value);}else{for(var i=0;i<value.length;++i){certList.push(value[i]);}}}}return certList;};/**
   * Removes a certificate from the store.
   *
   * @param cert the certificate to remove (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return the certificate that was removed or null if the certificate
   *           wasn't in store.
   */caStore.removeCertificate=function(cert){var result;// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}ensureSubjectHasHash(cert.subject);if(!caStore.hasCertificate(cert)){return null;}var match=getBySubject(cert.subject);if(!forge.util.isArray(match)){result=caStore.certs[cert.subject.hash];delete caStore.certs[cert.subject.hash];return result;}// compare DER-encoding of certificates
var der1=asn1.toDer(pki.certificateToAsn1(cert)).getBytes();for(var i=0;i<match.length;++i){var der2=asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();if(der1===der2){result=match[i];match.splice(i,1);}}if(match.length===0){delete caStore.certs[cert.subject.hash];}return result;};function getBySubject(subject){ensureSubjectHasHash(subject);return caStore.certs[subject.hash]||null;}function ensureSubjectHasHash(subject){// produce subject hash if it doesn't exist
if(!subject.hash){var md=forge.md.sha1.create();subject.attributes=pki.RDNAttributesAsArray(_dnToAsn1(subject),md);subject.hash=md.digest().toHex();}}// auto-add passed in certs
if(certs){// parse PEM-formatted certificates as necessary
for(var i=0;i<certs.length;++i){var cert=certs[i];caStore.addCertificate(cert);}}return caStore;};/**
 * Certificate verification errors, based on TLS.
 */pki.certificateError={bad_certificate:'forge.pki.BadCertificate',unsupported_certificate:'forge.pki.UnsupportedCertificate',certificate_revoked:'forge.pki.CertificateRevoked',certificate_expired:'forge.pki.CertificateExpired',certificate_unknown:'forge.pki.CertificateUnknown',unknown_ca:'forge.pki.UnknownCertificateAuthority'};/**
 * Verifies a certificate chain against the given Certificate Authority store
 * with an optional custom verify callback.
 *
 * @param caStore a certificate store to verify against.
 * @param chain the certificate chain to verify, with the root or highest
 *          authority at the end (an array of certificates).
 * @param verify called for every certificate in the chain.
 *
 * The verify callback has the following signature:
 *
 * verified - Set to true if certificate was verified, otherwise the
 *   pki.certificateError for why the certificate failed.
 * depth - The current index in the chain, where 0 is the end point's cert.
 * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
 *   end point.
 *
 * The function returns true on success and on failure either the appropriate
 * pki.certificateError or an object with 'error' set to the appropriate
 * pki.certificateError and 'message' set to a custom error message.
 *
 * @return true if successful, error thrown if not.
 */pki.verifyCertificateChain=function(caStore,chain,verify){/* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate
    Section 6: Certification Path Validation
    See inline parentheticals related to this particular implementation.

    The primary goal of path validation is to verify the binding between
    a subject distinguished name or a subject alternative name and subject
    public key, as represented in the end entity certificate, based on the
    public key of the trust anchor. This requires obtaining a sequence of
    certificates that support that binding. That sequence should be provided
    in the passed 'chain'. The trust anchor should be in the given CA
    store. The 'end entity' certificate is the certificate provided by the
    end point (typically a server) and is the first in the chain.

    To meet this goal, the path validation process verifies, among other
    things, that a prospective certification path (a sequence of n
    certificates or a 'chain') satisfies the following conditions:

    (a) for all x in {1, ..., n-1}, the subject of certificate x is
          the issuer of certificate x+1;

    (b) certificate 1 is issued by the trust anchor;

    (c) certificate n is the certificate to be validated; and

    (d) for all x in {1, ..., n}, the certificate was valid at the
          time in question.

    Note that here 'n' is index 0 in the chain and 1 is the last certificate
    in the chain and it must be signed by a certificate in the connection's
    CA store.

    The path validation process also determines the set of certificate
    policies that are valid for this path, based on the certificate policies
    extension, policy mapping extension, policy constraints extension, and
    inhibit any-policy extension.

    Note: Policy mapping extension not supported (Not Required).

    Note: If the certificate has an unsupported critical extension, then it
    must be rejected.

    Note: A certificate is self-issued if the DNs that appear in the subject
    and issuer fields are identical and are not empty.

    The path validation algorithm assumes the following seven inputs are
    provided to the path processing logic. What this specific implementation
    will use is provided parenthetically:

    (a) a prospective certification path of length n (the 'chain')
    (b) the current date/time: ('now').
    (c) user-initial-policy-set: A set of certificate policy identifiers
          naming the policies that are acceptable to the certificate user.
          The user-initial-policy-set contains the special value any-policy
          if the user is not concerned about certificate policy
          (Not implemented. Any policy is accepted).
    (d) trust anchor information, describing a CA that serves as a trust
          anchor for the certification path. The trust anchor information
          includes:

      (1)  the trusted issuer name,
      (2)  the trusted public key algorithm,
      (3)  the trusted public key, and
      (4)  optionally, the trusted public key parameters associated
             with the public key.

      (Trust anchors are provided via certificates in the CA store).

      The trust anchor information may be provided to the path processing
      procedure in the form of a self-signed certificate. The trusted anchor
      information is trusted because it was delivered to the path processing
      procedure by some trustworthy out-of-band procedure. If the trusted
      public key algorithm requires parameters, then the parameters are
      provided along with the trusted public key (No parameters used in this
      implementation).

    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is
          allowed in the certification path.
          (Not implemented, no policy checking)

    (f) initial-explicit-policy, which indicates if the path must be valid
          for at least one of the certificate policies in the user-initial-
          policy-set.
          (Not implemented, no policy checking)

    (g) initial-any-policy-inhibit, which indicates whether the
          anyPolicy OID should be processed if it is included in a
          certificate.
          (Not implemented, so any policy is valid provided that it is
          not marked as critical) */ /* Basic Path Processing:

    For each certificate in the 'chain', the following is checked:

    1. The certificate validity period includes the current time.
    2. The certificate was signed by its parent (where the parent is either
       the next in the chain or from the CA store). Allow processing to
       continue to the next step if no parent is found but the certificate is
       in the CA store.
    3. TODO: The certificate has not been revoked.
    4. The certificate issuer name matches the parent's subject name.
    5. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is within one of the permitted subtrees of X.500 distinguished names
       and that each of the alternative names in the subjectAltName extension
       (critical or non-critical) is within one of the permitted subtrees for
       that name type.
    6. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is not within one of the excluded subtrees for X.500 distinguished
       names and none of the subjectAltName extension names are excluded for
       that name type.
    7. The other steps in the algorithm for basic path processing involve
       handling the policy extension which is not presently supported in this
       implementation. Instead, if a critical policy extension is found, the
       certificate is rejected as not supported.
    8. If the certificate is not the first or if its the only certificate in
       the chain (having no parent from the CA store or is self-signed) and it
       has a critical key usage extension, verify that the keyCertSign bit is
       set. If the key usage extension exists, verify that the basic
       constraints extension exists. If the basic constraints extension exists,
       verify that the cA flag is set. If pathLenConstraint is set, ensure that
       the number of certificates that precede in the chain (come earlier
       in the chain as implemented below), excluding the very first in the
       chain (typically the end-entity one), isn't greater than the
       pathLenConstraint. This constraint limits the number of intermediate
       CAs that may appear below a CA before only end-entity certificates
       may be issued. */ // copy cert chain references to another array to protect against changes
// in verify callback
chain=chain.slice(0);var certs=chain.slice(0);// get current date
var now=new Date();// verify each cert in the chain using its parent, where the parent
// is either the next in the chain or from the CA store
var first=true;var error=null;var depth=0;do{var cert=chain.shift();var parent=null;var selfSigned=false;// 1. check valid time
if(now<cert.validity.notBefore||now>cert.validity.notAfter){error={message:'Certificate is not valid yet or has expired.',error:pki.certificateError.certificate_expired,notBefore:cert.validity.notBefore,notAfter:cert.validity.notAfter,now:now};}// 2. verify with parent from chain or CA store
if(error===null){parent=chain[0]||caStore.getIssuer(cert);if(parent===null){// check for self-signed cert
if(cert.isIssuer(cert)){selfSigned=true;parent=cert;}}if(parent){// FIXME: current CA store implementation might have multiple
// certificates where the issuer can't be determined from the
// certificate (happens rarely with, eg: old certificates) so normalize
// by always putting parents into an array
// TODO: there's may be an extreme degenerate case currently uncovered
// where an old intermediate certificate seems to have a matching parent
// but none of the parents actually verify ... but the intermediate
// is in the CA and it should pass this check; needs investigation
var parents=parent;if(!forge.util.isArray(parents)){parents=[parents];}// try to verify with each possible parent (typically only one)
var verified=false;while(!verified&&parents.length>0){parent=parents.shift();try{verified=parent.verify(cert);}catch(ex){// failure to verify, don't care why, try next one
}}if(!verified){error={message:'Certificate signature is invalid.',error:pki.certificateError.bad_certificate};}}if(error===null&&(!parent||selfSigned)&&!caStore.hasCertificate(cert)){// no parent issuer and certificate itself is not trusted
error={message:'Certificate is not trusted.',error:pki.certificateError.unknown_ca};}}// TODO: 3. check revoked
// 4. check for matching issuer/subject
if(error===null&&parent&&!cert.isIssuer(parent)){// parent is not issuer
error={message:'Certificate issuer is invalid.',error:pki.certificateError.bad_certificate};}// 5. TODO: check names with permitted names tree
// 6. TODO: check names against excluded names tree
// 7. check for unsupported critical extensions
if(error===null){// supported extensions
var se={keyUsage:true,basicConstraints:true};for(var i=0;error===null&&i<cert.extensions.length;++i){var ext=cert.extensions[i];if(ext.critical&&!(ext.name in se)){error={message:'Certificate has an unsupported critical extension.',error:pki.certificateError.unsupported_certificate};}}}// 8. check for CA if cert is not first or is the only certificate
// remaining in chain with no parent or is self-signed
if(error===null&&(!first||chain.length===0&&(!parent||selfSigned))){// first check keyUsage extension and then basic constraints
var bcExt=cert.getExtension('basicConstraints');var keyUsageExt=cert.getExtension('keyUsage');if(keyUsageExt!==null){// keyCertSign must be true and there must be a basic
// constraints extension
if(!keyUsageExt.keyCertSign||bcExt===null){// bad certificate
error={message:'Certificate keyUsage or basicConstraints conflict '+'or indicate that the certificate is not a CA. '+'If the certificate is the only one in the chain or '+'isn\'t the first then the certificate must be a '+'valid CA.',error:pki.certificateError.bad_certificate};}}// basic constraints cA flag must be set
if(error===null&&bcExt!==null&&!bcExt.cA){// bad certificate
error={message:'Certificate basicConstraints indicates the certificate '+'is not a CA.',error:pki.certificateError.bad_certificate};}// if error is not null and keyUsage is available, then we know it
// has keyCertSign and there is a basic constraints extension too,
// which means we can check pathLenConstraint (if it exists)
if(error===null&&keyUsageExt!==null&&'pathLenConstraint'in bcExt){// pathLen is the maximum # of intermediate CA certs that can be
// found between the current certificate and the end-entity (depth 0)
// certificate; this number does not include the end-entity (depth 0,
// last in the chain) even if it happens to be a CA certificate itself
var pathLen=depth-1;if(pathLen>bcExt.pathLenConstraint){// pathLenConstraint violated, bad certificate
error={message:'Certificate basicConstraints pathLenConstraint violated.',error:pki.certificateError.bad_certificate};}}}// call application callback
var vfd=error===null?true:error.error;var ret=verify?verify(vfd,depth,certs):vfd;if(ret===true){// clear any set error
error=null;}else{// if passed basic tests, set default message and alert
if(vfd===true){error={message:'The application rejected the certificate.',error:pki.certificateError.bad_certificate};}// check for custom error info
if(ret||ret===0){// set custom message and error
if(_typeof(ret)==='object'&&!forge.util.isArray(ret)){if(ret.message){error.message=ret.message;}if(ret.error){error.error=ret.error;}}else if(typeof ret==='string'){// set custom error
error.error=ret;}}// throw error
throw error;}// no longer first cert in chain
first=false;++depth;}while(chain.length>0);return true;};/***/},/* 19 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of PKCS#1 PSS signature padding.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 */var forge=__webpack_require__(0);__webpack_require__(5);__webpack_require__(1);// shortcut for PSS API
var pss=module.exports=forge.pss=forge.pss||{};/**
 * Creates a PSS signature scheme object.
 *
 * There are several ways to provide a salt for encoding:
 *
 * 1. Specify the saltLength only and the built-in PRNG will generate it.
 * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
 *   will be used.
 * 3. Specify the salt itself as a forge.util.ByteBuffer.
 *
 * @param options the options to use:
 *          md the message digest object to use, a forge md instance.
 *          mgf the mask generation function to use, a forge mgf instance.
 *          [saltLength] the length of the salt in octets.
 *          [prng] the pseudo-random number generator to use to produce a salt.
 *          [salt] the salt to use when encoding.
 *
 * @return a signature scheme object.
 */pss.create=function(options){// backwards compatibility w/legacy args: hash, mgf, sLen
if(arguments.length===3){options={md:arguments[0],mgf:arguments[1],saltLength:arguments[2]};}var hash=options.md;var mgf=options.mgf;var hLen=hash.digestLength;var salt_=options.salt||null;if(typeof salt_==='string'){// assume binary-encoded string
salt_=forge.util.createBuffer(salt_);}var sLen;if('saltLength'in options){sLen=options.saltLength;}else if(salt_!==null){sLen=salt_.length();}else{throw new Error('Salt length not specified or specific salt not given.');}if(salt_!==null&&salt_.length()!==sLen){throw new Error('Given salt length does not match length of given salt.');}var prng=options.prng||forge.random;var pssobj={};/**
   * Encodes a PSS signature.
   *
   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
   *
   * @param md the message digest object with the hash to sign.
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return the encoded message as a binary-encoded string of length
   *           ceil((modBits - 1) / 8).
   */pssobj.encode=function(md,modBits){var i;var emBits=modBits-1;var emLen=Math.ceil(emBits/8);/* 2. Let mHash = Hash(M), an octet string of length hLen. */var mHash=md.digest().getBytes();/* 3. If emLen < hLen + sLen + 2, output "encoding error" and stop. */if(emLen<hLen+sLen+2){throw new Error('Message is too long to encrypt.');}/* 4. Generate a random octet string salt of length sLen; if sLen = 0,
     *    then salt is the empty string. */var salt;if(salt_===null){salt=prng.getBytesSync(sLen);}else{salt=salt_.bytes();}/* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */var m_=new forge.util.ByteBuffer();m_.fillWithByte(0,8);m_.putBytes(mHash);m_.putBytes(salt);/* 6. Let H = Hash(M'), an octet string of length hLen. */hash.start();hash.update(m_.getBytes());var h=hash.digest().getBytes();/* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
     *    zero octets.  The length of PS may be 0. */var ps=new forge.util.ByteBuffer();ps.fillWithByte(0,emLen-sLen-hLen-2);/* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length
     *    emLen - hLen - 1. */ps.putByte(0x01);ps.putBytes(salt);var db=ps.getBytes();/* 9. Let dbMask = MGF(H, emLen - hLen - 1). */var maskLen=emLen-hLen-1;var dbMask=mgf.generate(h,maskLen);/* 10. Let maskedDB = DB \xor dbMask. */var maskedDB='';for(i=0;i<maskLen;i++){maskedDB+=String.fromCharCode(db.charCodeAt(i)^dbMask.charCodeAt(i));}/* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
     *     maskedDB to zero. */var mask=0xFF00>>8*emLen-emBits&0xFF;maskedDB=String.fromCharCode(maskedDB.charCodeAt(0)&~mask)+maskedDB.substr(1);/* 12. Let EM = maskedDB || H || 0xbc.
     * 13. Output EM. */return maskedDB+h+String.fromCharCode(0xbc);};/**
   * Verifies a PSS signature.
   *
   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
   *
   * @param mHash the message digest hash, as a binary-encoded string, to
   *         compare against the signature.
   * @param em the encoded message, as a binary-encoded string
   *          (RSA decryption result).
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return true if the signature was verified, false if not.
   */pssobj.verify=function(mHash,em,modBits){var i;var emBits=modBits-1;var emLen=Math.ceil(emBits/8);/* c. Convert the message representative m to an encoded message EM
     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits
     *    is the length in bits of the RSA modulus n */em=em.substr(-emLen);/* 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop. */if(emLen<hLen+sLen+2){throw new Error('Inconsistent parameters to PSS signature verification.');}/* 4. If the rightmost octet of EM does not have hexadecimal value
     *    0xbc, output "inconsistent" and stop. */if(em.charCodeAt(emLen-1)!==0xbc){throw new Error('Encoded message does not end in 0xBC.');}/* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
     *    let H be the next hLen octets. */var maskLen=emLen-hLen-1;var maskedDB=em.substr(0,maskLen);var h=em.substr(maskLen,hLen);/* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
     *    maskedDB are not all equal to zero, output "inconsistent" and stop. */var mask=0xFF00>>8*emLen-emBits&0xFF;if((maskedDB.charCodeAt(0)&mask)!==0){throw new Error('Bits beyond keysize not zero as expected.');}/* 7. Let dbMask = MGF(H, emLen - hLen - 1). */var dbMask=mgf.generate(h,maskLen);/* 8. Let DB = maskedDB \xor dbMask. */var db='';for(i=0;i<maskLen;i++){db+=String.fromCharCode(maskedDB.charCodeAt(i)^dbMask.charCodeAt(i));}/* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
     * in DB to zero. */db=String.fromCharCode(db.charCodeAt(0)&~mask)+db.substr(1);/* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
     * position is "position 1") does not have hexadecimal value 0x01,
     * output "inconsistent" and stop. */var checkLen=emLen-hLen-sLen-2;for(i=0;i<checkLen;i++){if(db.charCodeAt(i)!==0x00){throw new Error('Leftmost octets not zero as expected');}}if(db.charCodeAt(checkLen)!==0x01){throw new Error('Inconsistent PSS signature, 0x01 marker not found');}/* 11. Let salt be the last sLen octets of DB. */var salt=db.substr(-sLen);/* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */var m_=new forge.util.ByteBuffer();m_.fillWithByte(0,8);m_.putBytes(mHash);m_.putBytes(salt);/* 13. Let H' = Hash(M'), an octet string of length hLen. */hash.start();hash.update(m_.getBytes());var h_=hash.digest().getBytes();/* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */return h===h_;};return pssobj;};/***/},/* 20 */ /***/function(module,exports,__webpack_require__){__webpack_require__(21);module.exports=__webpack_require__(0);/***/},/* 21 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of a basic Public Key Infrastructure, including
 * support for RSA public and private keys.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(3);__webpack_require__(9);__webpack_require__(8);__webpack_require__(13);__webpack_require__(28);__webpack_require__(19);__webpack_require__(6);__webpack_require__(1);__webpack_require__(18);// shortcut for asn.1 API
var asn1=forge.asn1;/* Public Key Infrastructure (PKI) implementation. */var pki=module.exports=forge.pki=forge.pki||{};/**
 * NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.
 *
 * Converts PEM-formatted data to DER.
 *
 * @param pem the PEM-formatted data.
 *
 * @return the DER-formatted data.
 */pki.pemToDer=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert PEM to DER; PEM is encrypted.');}return forge.util.createBuffer(msg.body);};/**
 * Converts an RSA private key from PEM format.
 *
 * @param pem the PEM-formatted private key.
 *
 * @return the private key.
 */pki.privateKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='PRIVATE KEY'&&msg.type!=='RSA PRIVATE KEY'){var error=new Error('Could not convert private key from PEM; PEM '+'header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert private key from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body);return pki.privateKeyFromAsn1(obj);};/**
 * Converts an RSA private key to PEM format.
 *
 * @param key the private key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */pki.privateKeyToPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'RSA PRIVATE KEY',body:asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts a PrivateKeyInfo to PEM format.
 *
 * @param pki the PrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */pki.privateKeyInfoToPem=function(pki,maxline){// convert to DER, then PEM-encode
var msg={type:'PRIVATE KEY',body:asn1.toDer(pki).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/***/},/* 22 */ /***/function(module,exports){/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */var api={};module.exports=api;// baseN alphabet indexes
var _reverseAlphabets={};/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */api.encode=function(input,alphabet,maxline){if(typeof alphabet!=='string'){throw new TypeError('"alphabet" must be a string.');}if(maxline!==undefined&&typeof maxline!=='number'){throw new TypeError('"maxline" must be a number.');}var output='';if(!(input instanceof Uint8Array)){// assume forge byte buffer
output=_encodeWithByteBuffer(input,alphabet);}else{var i=0;var base=alphabet.length;var first=alphabet.charAt(0);var digits=[0];for(i=0;i<input.length;++i){for(var j=0,carry=input[i];j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%base;carry=carry/base|0;}while(carry>0){digits.push(carry%base);carry=carry/base|0;}}// deal with leading zeros
for(i=0;input[i]===0&&i<input.length-1;++i){output+=first;}// convert digits to a string
for(i=digits.length-1;i>=0;--i){output+=alphabet[digits[i]];}}if(maxline){var regex=new RegExp('.{1,'+maxline+'}','g');output=output.match(regex).join('\r\n');}return output;};/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */api.decode=function(input,alphabet){if(typeof input!=='string'){throw new TypeError('"input" must be a string.');}if(typeof alphabet!=='string'){throw new TypeError('"alphabet" must be a string.');}var table=_reverseAlphabets[alphabet];if(!table){// compute reverse alphabet
table=_reverseAlphabets[alphabet]=[];for(var i=0;i<alphabet.length;++i){table[alphabet.charCodeAt(i)]=i;}}// remove whitespace characters
input=input.replace(/\s/g,'');var base=alphabet.length;var first=alphabet.charAt(0);var bytes=[0];for(var i=0;i<input.length;i++){var value=table[input.charCodeAt(i)];if(value===undefined){return;}for(var j=0,carry=value;j<bytes.length;++j){carry+=bytes[j]*base;bytes[j]=carry&0xff;carry>>=8;}while(carry>0){bytes.push(carry&0xff);carry>>=8;}}// deal with leading zeros
for(var k=0;input[k]===first&&k<input.length-1;++k){bytes.push(0);}if(typeof Buffer!=='undefined'){return Buffer.from(bytes.reverse());}return new Uint8Array(bytes.reverse());};function _encodeWithByteBuffer(input,alphabet){var i=0;var base=alphabet.length;var first=alphabet.charAt(0);var digits=[0];for(i=0;i<input.length();++i){for(var j=0,carry=input.at(i);j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%base;carry=carry/base|0;}while(carry>0){digits.push(carry%base);carry=carry/base|0;}}var output='';// deal with leading zeros
for(i=0;input.at(i)===0&&i<input.length()-1;++i){output+=first;}// convert digits to a string
for(i=digits.length-1;i>=0;--i){output+=alphabet[digits[i]];}return output;}/***/},/* 23 */ /***/function(module,exports,__webpack_require__){/**
 * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
 *
 * See FIPS 180-2 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);var sha256=module.exports=forge.sha256=forge.sha256||{};forge.md.sha256=forge.md.algorithms.sha256=sha256;/**
 * Creates a SHA-256 message digest object.
 *
 * @return a message digest object.
 */sha256.create=function(){// do initialization as necessary
if(!_initialized){_init();}// SHA-256 state contains eight 32-bit integers
var _state=null;// input buffer
var _input=forge.util.createBuffer();// used for word storage
var _w=new Array(64);// message digest object
var md={algorithm:'sha256',blockLength:64,digestLength:32,// 56-bit length of message so far (does not including padding)
messageLength:0,// true message length
fullMessageLength:null,// size of message length in bytes
messageLengthSize:8};/**
   * Starts the digest.
   *
   * @return this digest object.
   */md.start=function(){// up to 56-bit message length for convenience
md.messageLength=0;// full message length (set md.messageLength64 for backwards-compatibility)
md.fullMessageLength=md.messageLength64=[];var int32s=md.messageLengthSize/4;for(var i=0;i<int32s;++i){md.fullMessageLength.push(0);}_input=forge.util.createBuffer();_state={h0:0x6A09E667,h1:0xBB67AE85,h2:0x3C6EF372,h3:0xA54FF53A,h4:0x510E527F,h5:0x9B05688C,h6:0x1F83D9AB,h7:0x5BE0CD19};return md;};// start digest automatically for first time
md.start();/**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */md.update=function(msg,encoding){if(encoding==='utf8'){msg=forge.util.encodeUtf8(msg);}// update message length
var len=msg.length;md.messageLength+=len;len=[len/0x100000000>>>0,len>>>0];for(var i=md.fullMessageLength.length-1;i>=0;--i){md.fullMessageLength[i]+=len[1];len[1]=len[0]+(md.fullMessageLength[i]/0x100000000>>>0);md.fullMessageLength[i]=md.fullMessageLength[i]>>>0;len[0]=len[1]/0x100000000>>>0;}// add bytes to input buffer
_input.putBytes(msg);// process bytes
_update(_state,_w,_input);// compact input buffer every 2K or if empty
if(_input.read>2048||_input.length()===0){_input.compact();}return md;};/**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */md.digest=function(){/* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */var finalBlock=forge.util.createBuffer();finalBlock.putBytes(_input.bytes());// compute remaining size to be digested (include message length size)
var remaining=md.fullMessageLength[md.fullMessageLength.length-1]+md.messageLengthSize;// add padding for overflow blockSize - overflow
// _padding starts with 1 byte with first bit is set (byte value 128), then
// there may be up to (blockSize - 1) other pad bytes
var overflow=remaining&md.blockLength-1;finalBlock.putBytes(_padding.substr(0,md.blockLength-overflow));// serialize message length in bits in big-endian order; since length
// is stored in bytes we multiply by 8 and add carry from next int
var next,carry;var bits=md.fullMessageLength[0]*8;for(var i=0;i<md.fullMessageLength.length-1;++i){next=md.fullMessageLength[i+1]*8;carry=next/0x100000000>>>0;bits+=carry;finalBlock.putInt32(bits>>>0);bits=next>>>0;}finalBlock.putInt32(bits);var s2={h0:_state.h0,h1:_state.h1,h2:_state.h2,h3:_state.h3,h4:_state.h4,h5:_state.h5,h6:_state.h6,h7:_state.h7};_update(s2,_w,finalBlock);var rval=forge.util.createBuffer();rval.putInt32(s2.h0);rval.putInt32(s2.h1);rval.putInt32(s2.h2);rval.putInt32(s2.h3);rval.putInt32(s2.h4);rval.putInt32(s2.h5);rval.putInt32(s2.h6);rval.putInt32(s2.h7);return rval;};return md;};// sha-256 padding bytes not initialized yet
var _padding=null;var _initialized=false;// table of constants
var _k=null;/**
 * Initializes the constant tables.
 */function _init(){// create padding
_padding=String.fromCharCode(128);_padding+=forge.util.fillString(String.fromCharCode(0x00),64);// create K table for SHA-256
_k=[0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2];// now initialized
_initialized=true;}/**
 * Updates a SHA-256 state with the given byte buffer.
 *
 * @param s the SHA-256 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */function _update(s,w,bytes){// consume 512 bit (64 byte) chunks
var t1,t2,s0,s1,ch,maj,i,a,b,c,d,e,f,g,h;var len=bytes.length();while(len>=64){// the w array will be populated with sixteen 32-bit big-endian words
// and then extended into 64 32-bit words according to SHA-256
for(i=0;i<16;++i){w[i]=bytes.getInt32();}for(;i<64;++i){// XOR word 2 words ago rot right 17, rot right 19, shft right 10
t1=w[i-2];t1=(t1>>>17|t1<<15)^(t1>>>19|t1<<13)^t1>>>10;// XOR word 15 words ago rot right 7, rot right 18, shft right 3
t2=w[i-15];t2=(t2>>>7|t2<<25)^(t2>>>18|t2<<14)^t2>>>3;// sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32
w[i]=t1+w[i-7]+t2+w[i-16]|0;}// initialize hash value for this chunk
a=s.h0;b=s.h1;c=s.h2;d=s.h3;e=s.h4;f=s.h5;g=s.h6;h=s.h7;// round function
for(i=0;i<64;++i){// Sum1(e)
s1=(e>>>6|e<<26)^(e>>>11|e<<21)^(e>>>25|e<<7);// Ch(e, f, g) (optimized the same way as SHA-1)
ch=g^e&(f^g);// Sum0(a)
s0=(a>>>2|a<<30)^(a>>>13|a<<19)^(a>>>22|a<<10);// Maj(a, b, c) (optimized the same way as SHA-1)
maj=a&b|c&(a^b);// main algorithm
t1=h+s1+ch+_k[i]+w[i];t2=s0+maj;h=g;g=f;f=e;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
// can't truncate with `| 0`
e=d+t1>>>0;d=c;c=b;b=a;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
// can't truncate with `| 0`
a=t1+t2>>>0;}// update hash state
s.h0=s.h0+a|0;s.h1=s.h1+b|0;s.h2=s.h2+c|0;s.h3=s.h3+d|0;s.h4=s.h4+e|0;s.h5=s.h5+f|0;s.h6=s.h6+g|0;s.h7=s.h7+h|0;len-=64;}}/***/},/* 24 */ /***/function(module,exports,__webpack_require__){/**
 * A javascript implementation of a cryptographically-secure
 * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
 * here though the use of SHA-256 is not enforced; when generating an
 * a PRNG context, the hashing algorithm and block cipher used for
 * the generator are specified via a plugin.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);var _crypto=null;if(forge.util.isNodejs&&!forge.options.usePureJavaScript&&!process.versions['node-webkit']){_crypto=__webpack_require__(15);}/* PRNG API */var prng=module.exports=forge.prng=forge.prng||{};/**
 * Creates a new PRNG context.
 *
 * A PRNG plugin must be passed in that will provide:
 *
 * 1. A function that initializes the key and seed of a PRNG context. It
 *   will be given a 16 byte key and a 16 byte seed. Any key expansion
 *   or transformation of the seed from a byte string into an array of
 *   integers (or similar) should be performed.
 * 2. The cryptographic function used by the generator. It takes a key and
 *   a seed.
 * 3. A seed increment function. It takes the seed and returns seed + 1.
 * 4. An api to create a message digest.
 *
 * For an example, see random.js.
 *
 * @param plugin the PRNG plugin to use.
 */prng.create=function(plugin){var ctx={plugin:plugin,key:null,seed:null,time:null,// number of reseeds so far
reseeds:0,// amount of data generated so far
generated:0,// no initial key bytes
keyBytes:''};// create 32 entropy pools (each is a message digest)
var md=plugin.md;var pools=new Array(32);for(var i=0;i<32;++i){pools[i]=md.create();}ctx.pools=pools;// entropy pools are written to cyclically, starting at index 0
ctx.pool=0;/**
   * Generates random bytes. The bytes may be generated synchronously or
   * asynchronously. Web workers must use the asynchronous interface or
   * else the behavior is undefined.
   *
   * @param count the number of random bytes to generate.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */ctx.generate=function(count,callback){// do synchronously
if(!callback){return ctx.generateSync(count);}// simple generator using counter-based CBC
var cipher=ctx.plugin.cipher;var increment=ctx.plugin.increment;var formatKey=ctx.plugin.formatKey;var formatSeed=ctx.plugin.formatSeed;var b=forge.util.createBuffer();// paranoid deviation from Fortuna:
// reset key for every request to protect previously
// generated random bytes should the key be discovered;
// there is no 100ms based reseeding because of this
// forced reseed for every `generate` call
ctx.key=null;generate();function generate(err){if(err){return callback(err);}// sufficient bytes generated
if(b.length()>=count){return callback(null,b.getBytes(count));}// if amount of data generated is greater than 1 MiB, trigger reseed
if(ctx.generated>0xfffff){ctx.key=null;}if(ctx.key===null){// prevent stack overflow
return forge.util.nextTick(function(){_reseed(generate);});}// generate the random bytes
var bytes=cipher(ctx.key,ctx.seed);ctx.generated+=bytes.length;b.putBytes(bytes);// generate bytes for a new key and seed
ctx.key=formatKey(cipher(ctx.key,increment(ctx.seed)));ctx.seed=formatSeed(cipher(ctx.key,ctx.seed));forge.util.setImmediate(generate);}};/**
   * Generates random bytes synchronously.
   *
   * @param count the number of random bytes to generate.
   *
   * @return count random bytes as a string.
   */ctx.generateSync=function(count){// simple generator using counter-based CBC
var cipher=ctx.plugin.cipher;var increment=ctx.plugin.increment;var formatKey=ctx.plugin.formatKey;var formatSeed=ctx.plugin.formatSeed;// paranoid deviation from Fortuna:
// reset key for every request to protect previously
// generated random bytes should the key be discovered;
// there is no 100ms based reseeding because of this
// forced reseed for every `generateSync` call
ctx.key=null;var b=forge.util.createBuffer();while(b.length()<count){// if amount of data generated is greater than 1 MiB, trigger reseed
if(ctx.generated>0xfffff){ctx.key=null;}if(ctx.key===null){_reseedSync();}// generate the random bytes
var bytes=cipher(ctx.key,ctx.seed);ctx.generated+=bytes.length;b.putBytes(bytes);// generate bytes for a new key and seed
ctx.key=formatKey(cipher(ctx.key,increment(ctx.seed)));ctx.seed=formatSeed(cipher(ctx.key,ctx.seed));}return b.getBytes(count);};/**
   * Private function that asynchronously reseeds a generator.
   *
   * @param callback(err) called once the operation completes.
   */function _reseed(callback){if(ctx.pools[0].messageLength>=32){_seed();return callback();}// not enough seed data...
var needed=32-ctx.pools[0].messageLength<<5;ctx.seedFile(needed,function(err,bytes){if(err){return callback(err);}ctx.collect(bytes);_seed();callback();});}/**
   * Private function that synchronously reseeds a generator.
   */function _reseedSync(){if(ctx.pools[0].messageLength>=32){return _seed();}// not enough seed data...
var needed=32-ctx.pools[0].messageLength<<5;ctx.collect(ctx.seedFileSync(needed));_seed();}/**
   * Private function that seeds a generator once enough bytes are available.
   */function _seed(){// update reseed count
ctx.reseeds=ctx.reseeds===0xffffffff?0:ctx.reseeds+1;// goal is to update `key` via:
// key = hash(key + s)
//   where 's' is all collected entropy from selected pools, then...
// create a plugin-based message digest
var md=ctx.plugin.md.create();// consume current key bytes
md.update(ctx.keyBytes);// digest the entropy of pools whose index k meet the
// condition 'n mod 2^k == 0' where n is the number of reseeds
var _2powK=1;for(var k=0;k<32;++k){if(ctx.reseeds%_2powK===0){md.update(ctx.pools[k].digest().getBytes());ctx.pools[k].start();}_2powK=_2powK<<1;}// get digest for key bytes
ctx.keyBytes=md.digest().getBytes();// paranoid deviation from Fortuna:
// update `seed` via `seed = hash(key)`
// instead of initializing to zero once and only
// ever incrementing it
md.start();md.update(ctx.keyBytes);var seedBytes=md.digest().getBytes();// update state
ctx.key=ctx.plugin.formatKey(ctx.keyBytes);ctx.seed=ctx.plugin.formatSeed(seedBytes);ctx.generated=0;}/**
   * The built-in default seedFile. This seedFile is used when entropy
   * is needed immediately.
   *
   * @param needed the number of bytes that are needed.
   *
   * @return the random bytes.
   */function defaultSeedFile(needed){// use window.crypto.getRandomValues strong source of entropy if available
var getRandomValues=null;if(typeof window!=='undefined'){var _crypto=window.crypto||window.msCrypto;if(_crypto&&_crypto.getRandomValues){getRandomValues=function getRandomValues(arr){return _crypto.getRandomValues(arr);};}}var b=forge.util.createBuffer();if(getRandomValues){while(b.length()<needed){// max byte length is 65536 before QuotaExceededError is thrown
// http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues
var count=Math.max(1,Math.min(needed-b.length(),65536)/4);var entropy=new Uint32Array(Math.floor(count));try{getRandomValues(entropy);for(var i=0;i<entropy.length;++i){b.putInt32(entropy[i]);}}catch(e){/* only ignore QuotaExceededError */if(!(typeof QuotaExceededError!=='undefined'&&e instanceof QuotaExceededError)){throw e;}}}}// be sad and add some weak random data
if(b.length()<needed){/* Draws from Park-Miller "minimal standard" 31 bit PRNG,
      implemented with David G. Carta's optimization: with 32 bit math
      and without division (Public Domain). */var hi,lo,next;var seed=Math.floor(Math.random()*0x010000);while(b.length()<needed){lo=16807*(seed&0xFFFF);hi=16807*(seed>>16);lo+=(hi&0x7FFF)<<16;lo+=hi>>15;lo=(lo&0x7FFFFFFF)+(lo>>31);seed=lo&0xFFFFFFFF;// consume lower 3 bytes of seed
for(var i=0;i<3;++i){// throw in more pseudo random
next=seed>>>(i<<3);next^=Math.floor(Math.random()*0x0100);b.putByte(String.fromCharCode(next&0xFF));}}}return b.getBytes(needed);}// initialize seed file APIs
if(_crypto){// use nodejs async API
ctx.seedFile=function(needed,callback){_crypto.randomBytes(needed,function(err,bytes){if(err){return callback(err);}callback(null,bytes.toString());});};// use nodejs sync API
ctx.seedFileSync=function(needed){return _crypto.randomBytes(needed).toString();};}else{ctx.seedFile=function(needed,callback){try{callback(null,defaultSeedFile(needed));}catch(e){callback(e);}};ctx.seedFileSync=defaultSeedFile;}/**
   * Adds entropy to a prng ctx's accumulator.
   *
   * @param bytes the bytes of entropy as a string.
   */ctx.collect=function(bytes){// iterate over pools distributing entropy cyclically
var count=bytes.length;for(var i=0;i<count;++i){ctx.pools[ctx.pool].update(bytes.substr(i,1));ctx.pool=ctx.pool===31?0:ctx.pool+1;}};/**
   * Collects an integer of n bits.
   *
   * @param i the integer entropy.
   * @param n the number of bits in the integer.
   */ctx.collectInt=function(i,n){var bytes='';for(var x=0;x<n;x+=8){bytes+=String.fromCharCode(i>>x&0xFF);}ctx.collect(bytes);};/**
   * Registers a Web Worker to receive immediate entropy from the main thread.
   * This method is required until Web Workers can access the native crypto
   * API. This method should be called twice for each created worker, once in
   * the main thread, and once in the worker itself.
   *
   * @param worker the worker to register.
   */ctx.registerWorker=function(worker){// worker receives random bytes
if(worker===self){ctx.seedFile=function(needed,callback){function listener(e){var data=e.data;if(data.forge&&data.forge.prng){self.removeEventListener('message',listener);callback(data.forge.prng.err,data.forge.prng.bytes);}}self.addEventListener('message',listener);self.postMessage({forge:{prng:{needed:needed}}});};}else{// main thread sends random bytes upon request
var listener=function listener(e){var data=e.data;if(data.forge&&data.forge.prng){ctx.seedFile(data.forge.prng.needed,function(err,bytes){worker.postMessage({forge:{prng:{err:err,bytes:bytes}}});});}};// TODO: do we need to remove the event listener when the worker dies?
worker.addEventListener('message',listener);}};return ctx;};/***/},/* 25 */ /***/function(module,exports,__webpack_require__){/**
 * RC2 implementation.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * Information on the RC2 cipher is available from RFC #2268,
 * http://www.ietf.org/rfc/rfc2268.txt
 */var forge=__webpack_require__(0);__webpack_require__(1);var piTable=[0xd9,0x78,0xf9,0xc4,0x19,0xdd,0xb5,0xed,0x28,0xe9,0xfd,0x79,0x4a,0xa0,0xd8,0x9d,0xc6,0x7e,0x37,0x83,0x2b,0x76,0x53,0x8e,0x62,0x4c,0x64,0x88,0x44,0x8b,0xfb,0xa2,0x17,0x9a,0x59,0xf5,0x87,0xb3,0x4f,0x13,0x61,0x45,0x6d,0x8d,0x09,0x81,0x7d,0x32,0xbd,0x8f,0x40,0xeb,0x86,0xb7,0x7b,0x0b,0xf0,0x95,0x21,0x22,0x5c,0x6b,0x4e,0x82,0x54,0xd6,0x65,0x93,0xce,0x60,0xb2,0x1c,0x73,0x56,0xc0,0x14,0xa7,0x8c,0xf1,0xdc,0x12,0x75,0xca,0x1f,0x3b,0xbe,0xe4,0xd1,0x42,0x3d,0xd4,0x30,0xa3,0x3c,0xb6,0x26,0x6f,0xbf,0x0e,0xda,0x46,0x69,0x07,0x57,0x27,0xf2,0x1d,0x9b,0xbc,0x94,0x43,0x03,0xf8,0x11,0xc7,0xf6,0x90,0xef,0x3e,0xe7,0x06,0xc3,0xd5,0x2f,0xc8,0x66,0x1e,0xd7,0x08,0xe8,0xea,0xde,0x80,0x52,0xee,0xf7,0x84,0xaa,0x72,0xac,0x35,0x4d,0x6a,0x2a,0x96,0x1a,0xd2,0x71,0x5a,0x15,0x49,0x74,0x4b,0x9f,0xd0,0x5e,0x04,0x18,0xa4,0xec,0xc2,0xe0,0x41,0x6e,0x0f,0x51,0xcb,0xcc,0x24,0x91,0xaf,0x50,0xa1,0xf4,0x70,0x39,0x99,0x7c,0x3a,0x85,0x23,0xb8,0xb4,0x7a,0xfc,0x02,0x36,0x5b,0x25,0x55,0x97,0x31,0x2d,0x5d,0xfa,0x98,0xe3,0x8a,0x92,0xae,0x05,0xdf,0x29,0x10,0x67,0x6c,0xba,0xc9,0xd3,0x00,0xe6,0xcf,0xe1,0x9e,0xa8,0x2c,0x63,0x16,0x01,0x3f,0x58,0xe2,0x89,0xa9,0x0d,0x38,0x34,0x1b,0xab,0x33,0xff,0xb0,0xbb,0x48,0x0c,0x5f,0xb9,0xb1,0xcd,0x2e,0xc5,0xf3,0xdb,0x47,0xe5,0xa5,0x9c,0x77,0x0a,0xa6,0x20,0x68,0xfe,0x7f,0xc1,0xad];var s=[1,2,3,5];/**
 * Rotate a word left by given number of bits.
 *
 * Bits that are shifted out on the left are put back in on the right
 * hand side.
 *
 * @param word The word to shift left.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */var rol=function rol(word,bits){return word<<bits&0xffff|(word&0xffff)>>16-bits;};/**
 * Rotate a word right by given number of bits.
 *
 * Bits that are shifted out on the right are put back in on the left
 * hand side.
 *
 * @param word The word to shift right.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */var ror=function ror(word,bits){return(word&0xffff)>>bits|word<<16-bits&0xffff;};/* RC2 API */module.exports=forge.rc2=forge.rc2||{};/**
 * Perform RC2 key expansion as per RFC #2268, section 2.
 *
 * @param key variable-length user key (between 1 and 128 bytes)
 * @param effKeyBits number of effective key bits (default: 128)
 * @return the expanded RC2 key (ByteBuffer of 128 bytes)
 */forge.rc2.expandKey=function(key,effKeyBits){if(typeof key==='string'){key=forge.util.createBuffer(key);}effKeyBits=effKeyBits||128;/* introduce variables that match the names used in RFC #2268 */var L=key;var T=key.length();var T1=effKeyBits;var T8=Math.ceil(T1/8);var TM=0xff>>(T1&0x07);var i;for(i=T;i<128;i++){L.putByte(piTable[L.at(i-1)+L.at(i-T)&0xff]);}L.setAt(128-T8,piTable[L.at(128-T8)&TM]);for(i=127-T8;i>=0;i--){L.setAt(i,piTable[L.at(i+1)^L.at(i+T8)]);}return L;};/**
 * Creates a RC2 cipher object.
 *
 * @param key the symmetric key to use (as base for key generation).
 * @param bits the number of effective key bits.
 * @param encrypt false for decryption, true for encryption.
 *
 * @return the cipher.
 */var createCipher=function createCipher(key,bits,encrypt){var _finish=false,_input=null,_output=null,_iv=null;var mixRound,mashRound;var i,j,K=[];/* Expand key and fill into K[] Array */key=forge.rc2.expandKey(key,bits);for(i=0;i<64;i++){K.push(key.getInt16Le());}if(encrypt){/**
     * Perform one mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */mixRound=function mixRound(R){for(i=0;i<4;i++){R[i]+=K[j]+(R[(i+3)%4]&R[(i+2)%4])+(~R[(i+3)%4]&R[(i+1)%4]);R[i]=rol(R[i],s[i]);j++;}};/**
     * Perform one mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */mashRound=function mashRound(R){for(i=0;i<4;i++){R[i]+=K[R[(i+3)%4]&63];}};}else{/**
     * Perform one r-mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */mixRound=function mixRound(R){for(i=3;i>=0;i--){R[i]=ror(R[i],s[i]);R[i]-=K[j]+(R[(i+3)%4]&R[(i+2)%4])+(~R[(i+3)%4]&R[(i+1)%4]);j--;}};/**
     * Perform one r-mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */mashRound=function mashRound(R){for(i=3;i>=0;i--){R[i]-=K[R[(i+3)%4]&63];}};}/**
   * Run the specified cipher execution plan.
   *
   * This function takes four words from the input buffer, applies the IV on
   * it (if requested) and runs the provided execution plan.
   *
   * The plan must be put together in form of a array of arrays.  Where the
   * outer one is simply a list of steps to perform and the inner one needs
   * to have two elements: the first one telling how many rounds to perform,
   * the second one telling what to do (i.e. the function to call).
   *
   * @param {Array} plan The plan to execute.
   */var runPlan=function runPlan(plan){var R=[];/* Get data from input buffer and fill the four words into R */for(i=0;i<4;i++){var val=_input.getInt16Le();if(_iv!==null){if(encrypt){/* We're encrypting, apply the IV first. */val^=_iv.getInt16Le();}else{/* We're decryption, keep cipher text for next block. */_iv.putInt16Le(val);}}R.push(val&0xffff);}/* Reset global "j" variable as per spec. */j=encrypt?0:63;/* Run execution plan. */for(var ptr=0;ptr<plan.length;ptr++){for(var ctr=0;ctr<plan[ptr][0];ctr++){plan[ptr][1](R);}}/* Write back result to output buffer. */for(i=0;i<4;i++){if(_iv!==null){if(encrypt){/* We're encrypting in CBC-mode, feed back encrypted bytes into
             IV buffer to carry it forward to next block. */_iv.putInt16Le(R[i]);}else{R[i]^=_iv.getInt16Le();}}_output.putInt16Le(R[i]);}};/* Create cipher object */var cipher=null;cipher={/**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */start:function start(iv,output){if(iv){/* CBC mode */if(typeof iv==='string'){iv=forge.util.createBuffer(iv);}}_finish=false;_input=forge.util.createBuffer();_output=output||new forge.util.createBuffer();_iv=iv;cipher.output=_output;},/**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */update:function update(input){if(!_finish){// not finishing, so fill the input buffer with more input
_input.putBuffer(input);}while(_input.length()>=8){runPlan([[5,mixRound],[1,mashRound],[6,mixRound],[1,mashRound],[5,mixRound]]);}},/**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */finish:function finish(pad){var rval=true;if(encrypt){if(pad){rval=pad(8,_input,!encrypt);}else{// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=_input.length()===8?8:8-_input.length();_input.fillWithByte(padding,padding);}}if(rval){// do final update
_finish=true;cipher.update();}if(!encrypt){// check for error: input data not a multiple of block size
rval=_input.length()===0;if(rval){if(pad){rval=pad(8,_output,!encrypt);}else{// ensure padding byte count is valid
var len=_output.length();var count=_output.at(len-1);if(count>len){rval=false;}else{// trim off padding bytes
_output.truncate(count);}}}}return rval;}};return cipher;};/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */forge.rc2.startEncrypting=function(key,iv,output){var cipher=forge.rc2.createEncryptionCipher(key,128);cipher.start(iv,output);return cipher;};/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start encrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */forge.rc2.createEncryptionCipher=function(key,bits){return createCipher(key,bits,true);};/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */forge.rc2.startDecrypting=function(key,iv,output){var cipher=forge.rc2.createDecryptionCipher(key,128);cipher.start(iv,output);return cipher;};/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start decrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */forge.rc2.createDecryptionCipher=function(key,bits){return createCipher(key,bits,false);};/***/},/* 26 */ /***/function(module,exports,__webpack_require__){/**
 * Partial implementation of PKCS#1 v2.2: RSA-OEAP
 *
 * Modified but based on the following MIT and BSD licensed code:
 *
 * https://github.com/kjur/jsjws/blob/master/rsa.js:
 *
 * The 'jsjws'(JSON Web Signature JavaScript Library) License
 *
 * Copyright (c) 2012 Kenji Urushima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:
 *
 * RSAES-OAEP.js
 * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $
 * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)
 * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.
 * Contact: ellis@nukinetics.com
 * Distributed under the BSD License.
 *
 * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125
 *
 * @author Evan Jones (http://evanjones.ca/)
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(5);__webpack_require__(17);// shortcut for PKCS#1 API
var pkcs1=module.exports=forge.pkcs1=forge.pkcs1||{};/**
 * Encode the given RSAES-OAEP message (M) using key, with optional label (L)
 * and seed.
 *
 * This method does not perform RSA encryption, it only encodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param message the message to encode.
 * @param options the options to use:
 *          label an optional label to use.
 *          seed the seed to use.
 *          md the message digest object to use, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the encoded message bytes.
 */pkcs1.encode_rsa_oaep=function(key,message,options){// parse arguments
var label;var seed;var md;var mgf1Md;// legacy args (label, seed, md)
if(typeof options==='string'){label=options;seed=arguments[3]||undefined;md=arguments[4]||undefined;}else if(options){label=options.label||undefined;seed=options.seed||undefined;md=options.md||undefined;if(options.mgf1&&options.mgf1.md){mgf1Md=options.mgf1.md;}}// default OAEP to SHA-1 message digest
if(!md){md=forge.md.sha1.create();}else{md.start();}// default MGF-1 to same as OAEP
if(!mgf1Md){mgf1Md=md;}// compute length in bytes and check output
var keyLength=Math.ceil(key.n.bitLength()/8);var maxLength=keyLength-2*md.digestLength-2;if(message.length>maxLength){var error=new Error('RSAES-OAEP input message length is too long.');error.length=message.length;error.maxLength=maxLength;throw error;}if(!label){label='';}md.update(label,'raw');var lHash=md.digest();var PS='';var PS_length=maxLength-message.length;for(var i=0;i<PS_length;i++){PS+='\x00';}var DB=lHash.getBytes()+PS+'\x01'+message;if(!seed){seed=forge.random.getBytes(md.digestLength);}else if(seed.length!==md.digestLength){var error=new Error('Invalid RSAES-OAEP seed. The seed length must '+'match the digest length.');error.seedLength=seed.length;error.digestLength=md.digestLength;throw error;}var dbMask=rsa_mgf1(seed,keyLength-md.digestLength-1,mgf1Md);var maskedDB=forge.util.xorBytes(DB,dbMask,DB.length);var seedMask=rsa_mgf1(maskedDB,md.digestLength,mgf1Md);var maskedSeed=forge.util.xorBytes(seed,seedMask,seed.length);// return encoded message
return'\x00'+maskedSeed+maskedDB;};/**
 * Decode the given RSAES-OAEP encoded message (EM) using key, with optional
 * label (L).
 *
 * This method does not perform RSA decryption, it only decodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param em the encoded message to decode.
 * @param options the options to use:
 *          label an optional label to use.
 *          md the message digest object to use for OAEP, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the decoded message bytes.
 */pkcs1.decode_rsa_oaep=function(key,em,options){// parse args
var label;var md;var mgf1Md;// legacy args
if(typeof options==='string'){label=options;md=arguments[3]||undefined;}else if(options){label=options.label||undefined;md=options.md||undefined;if(options.mgf1&&options.mgf1.md){mgf1Md=options.mgf1.md;}}// compute length in bytes
var keyLength=Math.ceil(key.n.bitLength()/8);if(em.length!==keyLength){var error=new Error('RSAES-OAEP encoded message length is invalid.');error.length=em.length;error.expectedLength=keyLength;throw error;}// default OAEP to SHA-1 message digest
if(md===undefined){md=forge.md.sha1.create();}else{md.start();}// default MGF-1 to same as OAEP
if(!mgf1Md){mgf1Md=md;}if(keyLength<2*md.digestLength+2){throw new Error('RSAES-OAEP key is too short for the hash function.');}if(!label){label='';}md.update(label,'raw');var lHash=md.digest().getBytes();// split the message into its parts
var y=em.charAt(0);var maskedSeed=em.substring(1,md.digestLength+1);var maskedDB=em.substring(1+md.digestLength);var seedMask=rsa_mgf1(maskedDB,md.digestLength,mgf1Md);var seed=forge.util.xorBytes(maskedSeed,seedMask,maskedSeed.length);var dbMask=rsa_mgf1(seed,keyLength-md.digestLength-1,mgf1Md);var db=forge.util.xorBytes(maskedDB,dbMask,maskedDB.length);var lHashPrime=db.substring(0,md.digestLength);// constant time check that all values match what is expected
var error=y!=='\x00';// constant time check lHash vs lHashPrime
for(var i=0;i<md.digestLength;++i){error|=lHash.charAt(i)!==lHashPrime.charAt(i);}// "constant time" find the 0x1 byte separating the padding (zeros) from the
// message
// TODO: It must be possible to do this in a better/smarter way?
var in_ps=1;var index=md.digestLength;for(var j=md.digestLength;j<db.length;j++){var code=db.charCodeAt(j);var is_0=code&0x1^0x1;// non-zero if not 0 or 1 in the ps section
var error_mask=in_ps?0xfffe:0x0000;error|=code&error_mask;// latch in_ps to zero after we find 0x1
in_ps=in_ps&is_0;index+=in_ps;}if(error||db.charCodeAt(index)!==0x1){throw new Error('Invalid RSAES-OAEP padding.');}return db.substring(index+1);};function rsa_mgf1(seed,maskLength,hash){// default to SHA-1 message digest
if(!hash){hash=forge.md.sha1.create();}var t='';var count=Math.ceil(maskLength/hash.digestLength);for(var i=0;i<count;++i){var c=String.fromCharCode(i>>24&0xFF,i>>16&0xFF,i>>8&0xFF,i&0xFF);hash.start();hash.update(seed+c);t+=hash.digest().getBytes();}return t.substring(0,maskLength);}/***/},/* 27 */ /***/function(module,exports,__webpack_require__){/**
 * Prime number generation API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(16);__webpack_require__(5);(function(){// forge.prime already defined
if(forge.prime){module.exports=forge.prime;return;}/* PRIME API */var prime=module.exports=forge.prime=forge.prime||{};var BigInteger=forge.jsbn.BigInteger;// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA=[6,4,2,4,2,4,6,2];var THIRTY=new BigInteger(null);THIRTY.fromInt(30);var op_or=function op_or(x,y){return x|y;};/**
 * Generates a random probable prime with the given number of bits.
 *
 * Alternative algorithms can be specified by name as a string or as an
 * object with custom options like so:
 *
 * {
 *   name: 'PRIMEINC',
 *   options: {
 *     maxBlockTime: <the maximum amount of time to block the main
 *       thread before allowing I/O other JS to run>,
 *     millerRabinTests: <the number of miller-rabin tests to run>,
 *     workerScript: <the worker script URL>,
 *     workers: <the number of web workers (if supported) to use,
 *       -1 to use estimated cores minus one>.
 *     workLoad: the size of the work load, ie: number of possible prime
 *       numbers for each web worker to check per work assignment,
 *       (default: 100).
 *   }
 * }
 *
 * @param bits the number of bits for the prime number.
 * @param options the options to use.
 *          [algorithm] the algorithm to use (default: 'PRIMEINC').
 *          [prng] a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *
 * @return callback(err, num) called once the operation completes.
 */prime.generateProbablePrime=function(bits,options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};// default to PRIMEINC algorithm
var algorithm=options.algorithm||'PRIMEINC';if(typeof algorithm==='string'){algorithm={name:algorithm};}algorithm.options=algorithm.options||{};// create prng with api that matches BigInteger secure random
var prng=options.prng||forge.random;var rng={// x is an array to fill with bytes
nextBytes:function nextBytes(x){var b=prng.getBytesSync(x.length);for(var i=0;i<x.length;++i){x[i]=b.charCodeAt(i);}}};if(algorithm.name==='PRIMEINC'){return primeincFindPrime(bits,rng,algorithm.options,callback);}throw new Error('Invalid prime generation algorithm: '+algorithm.name);};function primeincFindPrime(bits,rng,options,callback){if('workers'in options){return primeincFindPrimeWithWorkers(bits,rng,options,callback);}return primeincFindPrimeWithoutWorkers(bits,rng,options,callback);}function primeincFindPrimeWithoutWorkers(bits,rng,options,callback){// initialize random number
var num=generateRandom(bits,rng);/* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The
  number we are given is always aligned at 30k + 1. Each time the number is
  determined not to be prime we add to get to the next 'i', eg: if the number
  was at 30k + 1 we add 6. */var deltaIdx=0;// get required number of MR tests
var mrTests=getMillerRabinTests(num.bitLength());if('millerRabinTests'in options){mrTests=options.millerRabinTests;}// find prime nearest to 'num' for maxBlockTime ms
// 10 ms gives 5ms of leeway for other calculations before dropping
// below 60fps (1000/60 == 16.67), but in reality, the number will
// likely be higher due to an 'atomic' big int modPow
var maxBlockTime=10;if('maxBlockTime'in options){maxBlockTime=options.maxBlockTime;}_primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback);}function _primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback){var start=+new Date();do{// overflow, regenerate random number
if(num.bitLength()>bits){num=generateRandom(bits,rng);}// do primality test
if(num.isProbablePrime(mrTests)){return callback(null,num);}// get next potential prime
num.dAddOffset(GCD_30_DELTA[deltaIdx++%8],0);}while(maxBlockTime<0||+new Date()-start<maxBlockTime);// keep trying later
forge.util.setImmediate(function(){_primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback);});}// NOTE: This algorithm is indeterminate in nature because workers
// run in parallel looking at different segments of numbers. Even if this
// algorithm is run twice with the same input from a predictable RNG, it
// may produce different outputs.
function primeincFindPrimeWithWorkers(bits,rng,options,callback){// web workers unavailable
if(typeof Worker==='undefined'){return primeincFindPrimeWithoutWorkers(bits,rng,options,callback);}// initialize random number
var num=generateRandom(bits,rng);// use web workers to generate keys
var numWorkers=options.workers;var workLoad=options.workLoad||100;var range=workLoad*30/8;var workerScript=options.workerScript||'forge/prime.worker.js';if(numWorkers===-1){return forge.util.estimateCores(function(err,cores){if(err){// default to 2
cores=2;}numWorkers=cores-1;generate();});}generate();function generate(){// require at least 1 worker
numWorkers=Math.max(1,numWorkers);// TODO: consider optimizing by starting workers outside getPrime() ...
// note that in order to clean up they will have to be made internally
// asynchronous which may actually be slower
// start workers immediately
var workers=[];for(var i=0;i<numWorkers;++i){// FIXME: fix path or use blob URLs
workers[i]=new Worker(workerScript);}var running=numWorkers;// listen for requests from workers and assign ranges to find prime
for(var i=0;i<numWorkers;++i){workers[i].addEventListener('message',workerMessage);}/* Note: The distribution of random numbers is unknown. Therefore, each
    web worker is continuously allocated a range of numbers to check for a
    random number until one is found.

    Every 30 numbers will be checked just 8 times, because prime numbers
    have the form:

    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)

    Therefore, if we want a web worker to run N checks before asking for
    a new range of numbers, each range must contain N*30/8 numbers.

    For 100 checks (workLoad), this is a range of 375. */var found=false;function workerMessage(e){// ignore message, prime already found
if(found){return;}--running;var data=e.data;if(data.found){// terminate all workers
for(var i=0;i<workers.length;++i){workers[i].terminate();}found=true;return callback(null,new BigInteger(data.prime,16));}// overflow, regenerate random number
if(num.bitLength()>bits){num=generateRandom(bits,rng);}// assign new range to check
var hex=num.toString(16);// start prime search
e.target.postMessage({hex:hex,workLoad:workLoad});num.dAddOffset(range,0);}}}/**
 * Generates a random number using the given number of bits and RNG.
 *
 * @param bits the number of bits for the number.
 * @param rng the random number generator to use.
 *
 * @return the random number.
 */function generateRandom(bits,rng){var num=new BigInteger(bits,rng);// force MSB set
var bits1=bits-1;if(!num.testBit(bits1)){num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1),op_or,num);}// align number on 30k+1 boundary
num.dAddOffset(31-num.mod(THIRTY).byteValue(),0);return num;}/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */function getMillerRabinTests(bits){if(bits<=100)return 27;if(bits<=150)return 18;if(bits<=200)return 15;if(bits<=250)return 12;if(bits<=300)return 9;if(bits<=350)return 8;if(bits<=400)return 7;if(bits<=500)return 6;if(bits<=600)return 5;if(bits<=800)return 4;if(bits<=1250)return 3;return 2;}})();/***/},/* 28 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of PKCS#12.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#12 is as follows
 * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)
 *
 * PFX ::= SEQUENCE {
 *   version  INTEGER {v3(3)}(v3,...),
 *   authSafe ContentInfo,
 *   macData  MacData OPTIONAL
 * }
 *
 * MacData ::= SEQUENCE {
 *   mac DigestInfo,
 *   macSalt OCTET STRING,
 *   iterations INTEGER DEFAULT 1
 * }
 * Note: The iterations default is for historical reasons and its use is
 * deprecated. A higher value, like 1024, is recommended.
 *
 * DigestInfo is defined in PKCS#7 as follows:
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of SHA1 there is none.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * Digest ::= OCTET STRING
 *
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType ContentType,
 *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * AuthenticatedSafe ::= SEQUENCE OF ContentInfo
 * -- Data if unencrypted
 * -- EncryptedData if password-encrypted
 * -- EnvelopedData if public key-encrypted
 *
 *
 * SafeContents ::= SEQUENCE OF SafeBag
 *
 * SafeBag ::= SEQUENCE {
 *   bagId     BAG-TYPE.&id ({PKCS12BagSet})
 *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),
 *   bagAttributes SET OF PKCS12Attribute OPTIONAL
 * }
 *
 * PKCS12Attribute ::= SEQUENCE {
 *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),
 *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})
 * } -- This type is compatible with the X.500 type ’Attribute’
 *
 * PKCS12AttrSet ATTRIBUTE ::= {
 *   friendlyName | -- from PKCS #9
 *   localKeyId, -- from PKCS #9
 *   ... -- Other attributes are allowed
 * }
 *
 * CertBag ::= SEQUENCE {
 *   certId    BAG-TYPE.&id   ({CertTypes}),
 *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})
 * }
 *
 * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}
 *   -- DER-encoded X.509 certificate stored in OCTET STRING
 *
 * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}
 * -- Base64-encoded SDSI certificate stored in IA5String
 *
 * CertTypes BAG-TYPE ::= {
 *   x509Certificate |
 *   sdsiCertificate,
 *   ... -- For future extensions
 * }
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(14);__webpack_require__(3);__webpack_require__(29);__webpack_require__(9);__webpack_require__(5);__webpack_require__(6);__webpack_require__(17);__webpack_require__(1);__webpack_require__(18);// shortcut for asn.1 & PKI API
var asn1=forge.asn1;var pki=forge.pki;// shortcut for PKCS#12 API
var p12=module.exports=forge.pkcs12=forge.pkcs12||{};var contentInfoValidator={name:'ContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// a ContentInfo
constructed:true,value:[{name:'ContentInfo.contentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'ContentInfo.content',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,captureAsn1:'content'}]};var pfxValidator={name:'PFX',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PFX.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},contentInfoValidator,{name:'PFX.macData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,captureAsn1:'mac',value:[{name:'PFX.macData.mac',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// DigestInfo
constructed:true,value:[{name:'PFX.macData.mac.digestAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// DigestAlgorithmIdentifier
constructed:true,value:[{name:'PFX.macData.mac.digestAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'macAlgorithm'},{name:'PFX.macData.mac.digestAlgorithm.parameters',tagClass:asn1.Class.UNIVERSAL,captureAsn1:'macAlgorithmParameters'}]},{name:'PFX.macData.mac.digest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'macDigest'}]},{name:'PFX.macData.macSalt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'macSalt'},{name:'PFX.macData.iterations',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,optional:true,capture:'macIterations'}]}]};var safeBagValidator={name:'SafeBag',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SafeBag.bagId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'bagId'},{name:'SafeBag.bagValue',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,captureAsn1:'bagValue'},{name:'SafeBag.bagAttributes',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,optional:true,capture:'bagAttributes'}]};var attributeValidator={name:'Attribute',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Attribute.attrId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'oid'},{name:'Attribute.attrValues',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,capture:'values'}]};var certBagValidator={name:'CertBag',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'CertBag.certId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certId'},{name:'CertBag.certValue',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,/* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */value:[{name:'CertBag.certValue[0]',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.OCTETSTRING,constructed:false,capture:'cert'}]}]};/**
 * Search SafeContents structure for bags with matching attributes.
 *
 * The search can optionally be narrowed by a certain bag type.
 *
 * @param safeContents the SafeContents structure to search in.
 * @param attrName the name of the attribute to compare against.
 * @param attrValue the attribute value to search for.
 * @param [bagType] bag type to narrow search by.
 *
 * @return an array of matching bags.
 */function _getBagsByAttribute(safeContents,attrName,attrValue,bagType){var result=[];for(var i=0;i<safeContents.length;i++){for(var j=0;j<safeContents[i].safeBags.length;j++){var bag=safeContents[i].safeBags[j];if(bagType!==undefined&&bag.type!==bagType){continue;}// only filter by bag type, no attribute specified
if(attrName===null){result.push(bag);continue;}if(bag.attributes[attrName]!==undefined&&bag.attributes[attrName].indexOf(attrValue)>=0){result.push(bag);}}}return result;}/**
 * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.
 *
 * @param obj The PKCS#12 PFX in ASN.1 notation.
 * @param strict true to use strict DER decoding, false not to (default: true).
 * @param {String} password Password to decrypt with (optional).
 *
 * @return PKCS#12 PFX object.
 */p12.pkcs12FromAsn1=function(obj,strict,password){// handle args
if(typeof strict==='string'){password=strict;strict=true;}else if(strict===undefined){strict=true;}// validate PFX and capture data
var capture={};var errors=[];if(!asn1.validate(obj,pfxValidator,capture,errors)){var error=new Error('Cannot read PKCS#12 PFX. '+'ASN.1 object is not an PKCS#12 PFX.');error.errors=error;throw error;}var pfx={version:capture.version.charCodeAt(0),safeContents:[],/**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */getBags:function getBags(filter){var rval={};var localKeyId;if('localKeyId'in filter){localKeyId=filter.localKeyId;}else if('localKeyIdHex'in filter){localKeyId=forge.util.hexToBytes(filter.localKeyIdHex);}// filter on bagType only
if(localKeyId===undefined&&!('friendlyName'in filter)&&'bagType'in filter){rval[filter.bagType]=_getBagsByAttribute(pfx.safeContents,null,null,filter.bagType);}if(localKeyId!==undefined){rval.localKeyId=_getBagsByAttribute(pfx.safeContents,'localKeyId',localKeyId,filter.bagType);}if('friendlyName'in filter){rval.friendlyName=_getBagsByAttribute(pfx.safeContents,'friendlyName',filter.friendlyName,filter.bagType);}return rval;},/**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */getBagsByFriendlyName:function getBagsByFriendlyName(friendlyName,bagType){return _getBagsByAttribute(pfx.safeContents,'friendlyName',friendlyName,bagType);},/**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */getBagsByLocalKeyId:function getBagsByLocalKeyId(localKeyId,bagType){return _getBagsByAttribute(pfx.safeContents,'localKeyId',localKeyId,bagType);}};if(capture.version.charCodeAt(0)!==3){var error=new Error('PKCS#12 PFX of version other than 3 not supported.');error.version=capture.version.charCodeAt(0);throw error;}if(asn1.derToOid(capture.contentType)!==pki.oids.data){var error=new Error('Only PKCS#12 PFX in password integrity mode supported.');error.oid=asn1.derToOid(capture.contentType);throw error;}var data=capture.content.value[0];if(data.tagClass!==asn1.Class.UNIVERSAL||data.type!==asn1.Type.OCTETSTRING){throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');}data=_decodePkcs7Data(data);// check for MAC
if(capture.mac){var md=null;var macKeyBytes=0;var macAlgorithm=asn1.derToOid(capture.macAlgorithm);switch(macAlgorithm){case pki.oids.sha1:md=forge.md.sha1.create();macKeyBytes=20;break;case pki.oids.sha256:md=forge.md.sha256.create();macKeyBytes=32;break;case pki.oids.sha384:md=forge.md.sha384.create();macKeyBytes=48;break;case pki.oids.sha512:md=forge.md.sha512.create();macKeyBytes=64;break;case pki.oids.md5:md=forge.md.md5.create();macKeyBytes=16;break;}if(md===null){throw new Error('PKCS#12 uses unsupported MAC algorithm: '+macAlgorithm);}// verify MAC (iterations default to 1)
var macSalt=new forge.util.ByteBuffer(capture.macSalt);var macIterations='macIterations'in capture?parseInt(forge.util.bytesToHex(capture.macIterations),16):1;var macKey=p12.generateKey(password,macSalt,3,macIterations,macKeyBytes,md);var mac=forge.hmac.create();mac.start(md,macKey);mac.update(data.value);var macValue=mac.getMac();if(macValue.getBytes()!==capture.macDigest){throw new Error('PKCS#12 MAC could not be verified. Invalid password?');}}_decodeAuthenticatedSafe(pfx,data.value,strict,password);return pfx;};/**
 * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines "Data" as an OCTET STRING,
 * but it is sometimes an OCTET STRING that is composed/constructed of chunks,
 * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This
 * function transforms this corner-case into the usual simple,
 * non-composed/constructed OCTET STRING.
 *
 * This function may be moved to ASN.1 at some point to better deal with
 * more BER-encoding issues, should they arise.
 *
 * @param data the ASN.1 Data object to transform.
 */function _decodePkcs7Data(data){// handle special case of "chunked" data content: an octet string composed
// of other octet strings
if(data.composed||data.constructed){var value=forge.util.createBuffer();for(var i=0;i<data.value.length;++i){value.putBytes(data.value[i].value);}data.composed=data.constructed=false;data.value=value.getBytes();}return data;}/**
 * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.
 *
 * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.
 *
 * @param pfx The PKCS#12 PFX object to fill.
 * @param {String} authSafe BER-encoded AuthenticatedSafe.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 */function _decodeAuthenticatedSafe(pfx,authSafe,strict,password){authSafe=asn1.fromDer(authSafe,strict);/* actually it's BER encoded */if(authSafe.tagClass!==asn1.Class.UNIVERSAL||authSafe.type!==asn1.Type.SEQUENCE||authSafe.constructed!==true){throw new Error('PKCS#12 AuthenticatedSafe expected to be a '+'SEQUENCE OF ContentInfo');}for(var i=0;i<authSafe.value.length;i++){var contentInfo=authSafe.value[i];// validate contentInfo and capture data
var capture={};var errors=[];if(!asn1.validate(contentInfo,contentInfoValidator,capture,errors)){var error=new Error('Cannot read ContentInfo.');error.errors=errors;throw error;}var obj={encrypted:false};var safeContents=null;var data=capture.content.value[0];switch(asn1.derToOid(capture.contentType)){case pki.oids.data:if(data.tagClass!==asn1.Class.UNIVERSAL||data.type!==asn1.Type.OCTETSTRING){throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');}safeContents=_decodePkcs7Data(data).value;break;case pki.oids.encryptedData:safeContents=_decryptSafeContents(data,password);obj.encrypted=true;break;default:var error=new Error('Unsupported PKCS#12 contentType.');error.contentType=asn1.derToOid(capture.contentType);throw error;}obj.safeBags=_decodeSafeContents(safeContents,strict,password);pfx.safeContents.push(obj);}}/**
 * Decrypt PKCS#7 EncryptedData structure.
 *
 * @param data ASN.1 encoded EncryptedContentInfo object.
 * @param password The user-provided password.
 *
 * @return The decrypted SafeContents (ASN.1 object).
 */function _decryptSafeContents(data,password){var capture={};var errors=[];if(!asn1.validate(data,forge.pkcs7.asn1.encryptedDataValidator,capture,errors)){var error=new Error('Cannot read EncryptedContentInfo.');error.errors=errors;throw error;}var oid=asn1.derToOid(capture.contentType);if(oid!==pki.oids.data){var error=new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');error.oid=oid;throw error;}// get cipher
oid=asn1.derToOid(capture.encAlgorithm);var cipher=pki.pbe.getCipher(oid,capture.encParameter,password);// get encrypted data
var encryptedContentAsn1=_decodePkcs7Data(capture.encryptedContentAsn1);var encrypted=forge.util.createBuffer(encryptedContentAsn1.value);cipher.update(encrypted);if(!cipher.finish()){throw new Error('Failed to decrypt PKCS#12 SafeContents.');}return cipher.output.getBytes();}/**
 * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.
 *
 * The safeContents is a BER-encoded SEQUENCE OF SafeBag.
 *
 * @param {String} safeContents BER-encoded safeContents.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 *
 * @return {Array} Array of Bag objects.
 */function _decodeSafeContents(safeContents,strict,password){// if strict and no safe contents, return empty safes
if(!strict&&safeContents.length===0){return[];}// actually it's BER-encoded
safeContents=asn1.fromDer(safeContents,strict);if(safeContents.tagClass!==asn1.Class.UNIVERSAL||safeContents.type!==asn1.Type.SEQUENCE||safeContents.constructed!==true){throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');}var res=[];for(var i=0;i<safeContents.value.length;i++){var safeBag=safeContents.value[i];// validate SafeBag and capture data
var capture={};var errors=[];if(!asn1.validate(safeBag,safeBagValidator,capture,errors)){var error=new Error('Cannot read SafeBag.');error.errors=errors;throw error;}/* Create bag object and push to result array. */var bag={type:asn1.derToOid(capture.bagId),attributes:_decodeBagAttributes(capture.bagAttributes)};res.push(bag);var validator,decoder;var bagAsn1=capture.bagValue.value[0];switch(bag.type){case pki.oids.pkcs8ShroudedKeyBag:/* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.
           Afterwards we can handle it like a keyBag,
           which is a PrivateKeyInfo. */bagAsn1=pki.decryptPrivateKeyInfo(bagAsn1,password);if(bagAsn1===null){throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');}/* fall through */case pki.oids.keyBag:/* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our
           PKI module, hence we don't have to do validation/capturing here,
           just pass what we already got. */try{bag.key=pki.privateKeyFromAsn1(bagAsn1);}catch(e){// ignore unknown key type, pass asn1 value
bag.key=null;bag.asn1=bagAsn1;}continue;/* Nothing more to do. */case pki.oids.certBag:/* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.
           Therefore put the SafeBag content through another validator to
           capture the fields.  Afterwards check & store the results. */validator=certBagValidator;decoder=function decoder(){if(asn1.derToOid(capture.certId)!==pki.oids.x509Certificate){var error=new Error('Unsupported certificate type, only X.509 supported.');error.oid=asn1.derToOid(capture.certId);throw error;}// true=produce cert hash
var certAsn1=asn1.fromDer(capture.cert,strict);try{bag.cert=pki.certificateFromAsn1(certAsn1,true);}catch(e){// ignore unknown cert type, pass asn1 value
bag.cert=null;bag.asn1=certAsn1;}};break;default:var error=new Error('Unsupported PKCS#12 SafeBag type.');error.oid=bag.type;throw error;}/* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */if(validator!==undefined&&!asn1.validate(bagAsn1,validator,capture,errors)){var error=new Error('Cannot read PKCS#12 '+validator.name);error.errors=errors;throw error;}/* Call decoder function from above to store the results. */decoder();}return res;}/**
 * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.
 *
 * @param attributes SET OF PKCS12Attribute (ASN.1 object).
 *
 * @return the decoded attributes.
 */function _decodeBagAttributes(attributes){var decodedAttrs={};if(attributes!==undefined){for(var i=0;i<attributes.length;++i){var capture={};var errors=[];if(!asn1.validate(attributes[i],attributeValidator,capture,errors)){var error=new Error('Cannot read PKCS#12 BagAttribute.');error.errors=errors;throw error;}var oid=asn1.derToOid(capture.oid);if(pki.oids[oid]===undefined){// unsupported attribute type, ignore.
continue;}decodedAttrs[pki.oids[oid]]=[];for(var j=0;j<capture.values.length;++j){decodedAttrs[pki.oids[oid]].push(capture.values[j].value);}}}return decodedAttrs;}/**
 * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a
 * password is provided then the private key will be encrypted.
 *
 * An entire certificate chain may also be included. To do this, pass
 * an array for the "cert" parameter where the first certificate is
 * the one that is paired with the private key and each subsequent one
 * verifies the previous one. The certificates may be in PEM format or
 * have been already parsed by Forge.
 *
 * @todo implement password-based-encryption for the whole package
 *
 * @param key the private key.
 * @param cert the certificate (may be an array of certificates in order
 *          to specify a certificate chain).
 * @param password the password to use, null for none.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          useMac true to include a MAC, false not to, defaults to true.
 *          localKeyId the local key ID to use, in hex.
 *          friendlyName the friendly name to use.
 *          generateLocalKeyId true to generate a random local key ID,
 *            false not to, defaults to true.
 *
 * @return the PKCS#12 PFX ASN.1 object.
 */p12.toPkcs12Asn1=function(key,cert,password,options){// set default options
options=options||{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||options.encAlgorithm||'aes128';if(!('useMac'in options)){options.useMac=true;}if(!('localKeyId'in options)){options.localKeyId=null;}if(!('generateLocalKeyId'in options)){options.generateLocalKeyId=true;}var localKeyId=options.localKeyId;var bagAttrs;if(localKeyId!==null){localKeyId=forge.util.hexToBytes(localKeyId);}else if(options.generateLocalKeyId){// use SHA-1 of paired cert, if available
if(cert){var pairedCert=forge.util.isArray(cert)?cert[0]:cert;if(typeof pairedCert==='string'){pairedCert=pki.certificateFromPem(pairedCert);}var sha1=forge.md.sha1.create();sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());localKeyId=sha1.digest().getBytes();}else{// FIXME: consider using SHA-1 of public key (which can be generated
// from private key components), see: cert.generateSubjectKeyIdentifier
// generate random bytes
localKeyId=forge.random.getBytes(20);}}var attrs=[];if(localKeyId!==null){attrs.push(// localKeyID
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// attrId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.localKeyId).getBytes()),// attrValues
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,localKeyId)])]));}if('friendlyName'in options){attrs.push(// friendlyName
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// attrId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.friendlyName).getBytes()),// attrValues
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BMPSTRING,false,options.friendlyName)])]));}if(attrs.length>0){bagAttrs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,attrs);}// collect contents for AuthenticatedSafe
var contents=[];// create safe bag(s) for certificate chain
var chain=[];if(cert!==null){if(forge.util.isArray(cert)){chain=cert;}else{chain=[cert];}}var certSafeBags=[];for(var i=0;i<chain.length;++i){// convert cert from PEM as necessary
cert=chain[i];if(typeof cert==='string'){cert=pki.certificateFromPem(cert);}// SafeBag
var certBagAttrs=i===0?bagAttrs:undefined;var certAsn1=pki.certificateToAsn1(cert);var certSafeBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.certBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// CertBag
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// certId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.x509Certificate).getBytes()),// certValue (x509Certificate)
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(certAsn1).getBytes())])])]),// bagAttributes (OPTIONAL)
certBagAttrs]);certSafeBags.push(certSafeBag);}if(certSafeBags.length>0){// SafeContents
var certSafeContents=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,certSafeBags);// ContentInfo
var certCI=// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(certSafeContents).getBytes())])]);contents.push(certCI);}// create safe contents for private key
var keyBag=null;if(key!==null){// SafeBag
var pkAsn1=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));if(password===null){// no encryption
keyBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.keyBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// PrivateKeyInfo
pkAsn1]),// bagAttributes (OPTIONAL)
bagAttrs]);}else{// encrypted PrivateKeyInfo
keyBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// EncryptedPrivateKeyInfo
pki.encryptPrivateKeyInfo(pkAsn1,password,options)]),// bagAttributes (OPTIONAL)
bagAttrs]);}// SafeContents
var keySafeContents=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[keyBag]);// ContentInfo
var keyCI=// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(keySafeContents).getBytes())])]);contents.push(keyCI);}// create AuthenticatedSafe by stringing together the contents
var safe=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,contents);var macData;if(options.useMac){// MacData
var sha1=forge.md.sha1.create();var macSalt=new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));var count=options.count;// 160-bit key
var key=p12.generateKey(password,macSalt,3,count,20);var mac=forge.hmac.create();mac.start(sha1,key);mac.update(asn1.toDer(safe).getBytes());var macValue=mac.getMac();macData=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// mac DigestInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// digestAlgorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm = SHA-1
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.sha1).getBytes()),// parameters = Null
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// digest
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,macValue.getBytes())]),// macSalt OCTET STRING
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,macSalt.getBytes()),// iterations INTEGER (XXX: Only support count < 65536)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(count).getBytes())]);}// PFX
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (3)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(3).getBytes()),// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(safe).getBytes())])]),macData]);};/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */p12.generateKey=forge.pbe.generatePkcs12Key;/***/},/* 29 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
 *
 * @author Dave Longley
 * @author Stefan Siegl
 *
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#7 is as follows
 * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
 *
 * A PKCS#7 message consists of a ContentInfo on root level, which may
 * contain any number of further ContentInfo nested into it.
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType                ContentType,
 *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * EnvelopedData ::= SEQUENCE {
 *   version                    Version,
 *   recipientInfos             RecipientInfos,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * EncryptedData ::= SEQUENCE {
 *   version                    Version,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
 *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
 *
 * SignedData ::= SEQUENCE {
 *   version           INTEGER,
 *   digestAlgorithms  DigestAlgorithmIdentifiers,
 *   contentInfo       ContentInfo,
 *   certificates      [0] IMPLICIT Certificates OPTIONAL,
 *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos       SignerInfos
 * }
 *
 * SignerInfos ::= SET OF SignerInfo
 *
 * SignerInfo ::= SEQUENCE {
 *   version                    Version,
 *   issuerAndSerialNumber      IssuerAndSerialNumber,
 *   digestAlgorithm            DigestAlgorithmIdentifier,
 *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
 *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
 *   encryptedDigest            EncryptedDigest,
 *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
 * }
 *
 * EncryptedDigest ::= OCTET STRING
 *
 * Attributes ::= SET OF Attribute
 *
 * Attribute ::= SEQUENCE {
 *   attrType    OBJECT IDENTIFIER,
 *   attrValues  SET OF AttributeValue
 * }
 *
 * AttributeValue ::= ANY
 *
 * Version ::= INTEGER
 *
 * RecipientInfos ::= SET OF RecipientInfo
 *
 * EncryptedContentInfo ::= SEQUENCE {
 *   contentType                 ContentType,
 *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
 *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
 * }
 *
 * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of AES and DES3, there is only one,
 * the IV.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * EncryptedContent ::= OCTET STRING
 *
 * RecipientInfo ::= SEQUENCE {
 *   version                     Version,
 *   issuerAndSerialNumber       IssuerAndSerialNumber,
 *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
 *   encryptedKey                EncryptedKey
 * }
 *
 * IssuerAndSerialNumber ::= SEQUENCE {
 *   issuer                      Name,
 *   serialNumber                CertificateSerialNumber
 * }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedKey ::= OCTET STRING
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(1);// shortcut for ASN.1 API
var asn1=forge.asn1;// shortcut for PKCS#7 API
var p7v=module.exports=forge.pkcs7asn1=forge.pkcs7asn1||{};forge.pkcs7=forge.pkcs7||{};forge.pkcs7.asn1=p7v;var contentInfoValidator={name:'ContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'ContentInfo.ContentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'ContentInfo.content',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,captureAsn1:'content'}]};p7v.contentInfoValidator=contentInfoValidator;var encryptedContentInfoValidator={name:'EncryptedContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedContentInfo.contentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'EncryptedContentInfo.contentEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encAlgorithm'},{name:'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,captureAsn1:'encParameter'}]},{name:'EncryptedContentInfo.encryptedContent',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,/* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */capture:'encryptedContent',captureAsn1:'encryptedContentAsn1'}]};p7v.envelopedDataValidator={name:'EnvelopedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EnvelopedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'EnvelopedData.RecipientInfos',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,captureAsn1:'recipientInfos'}].concat(encryptedContentInfoValidator)};p7v.encryptedDataValidator={name:'EncryptedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'}].concat(encryptedContentInfoValidator)};var signerValidator={name:'SignerInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false},{name:'SignerInfo.issuerAndSerialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.issuerAndSerialNumber.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'issuer'},{name:'SignerInfo.issuerAndSerialNumber.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'serial'}]},{name:'SignerInfo.digestAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.digestAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'digestAlgorithm'},{name:'SignerInfo.digestAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,constructed:false,captureAsn1:'digestParameter',optional:true}]},{name:'SignerInfo.authenticatedAttributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,capture:'authenticatedAttributes'},{name:'SignerInfo.digestEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,capture:'signatureAlgorithm'},{name:'SignerInfo.encryptedDigest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'signature'},{name:'SignerInfo.unauthenticatedAttributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,optional:true,capture:'unauthenticatedAttributes'}]};p7v.signedDataValidator={name:'SignedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'SignedData.DigestAlgorithms',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,captureAsn1:'digestAlgorithms'},contentInfoValidator,{name:'SignedData.Certificates',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,optional:true,captureAsn1:'certificates'},{name:'SignedData.CertificateRevocationLists',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,optional:true,captureAsn1:'crls'},{name:'SignedData.SignerInfos',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,capture:'signerInfos',optional:true,value:[signerValidator]}]};p7v.recipientInfoValidator={name:'RecipientInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'RecipientInfo.issuerAndSerial',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.issuerAndSerial.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'issuer'},{name:'RecipientInfo.issuerAndSerial.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'serial'}]},{name:'RecipientInfo.keyEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.keyEncryptionAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encAlgorithm'},{name:'RecipientInfo.keyEncryptionAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,constructed:false,captureAsn1:'encParameter'}]},{name:'RecipientInfo.encryptedKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encKey'}]};/***/},/* 30 */ /***/function(module,exports,__webpack_require__){/**
 * Node.js module for Forge mask generation functions.
 *
 * @author Stefan Siegl
 *
 * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
 */var forge=__webpack_require__(0);__webpack_require__(31);module.exports=forge.mgf=forge.mgf||{};forge.mgf.mgf1=forge.mgf1;/***/},/* 31 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of mask generation function MGF1.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);forge.mgf=forge.mgf||{};var mgf1=module.exports=forge.mgf.mgf1=forge.mgf1=forge.mgf1||{};/**
 * Creates a MGF1 mask generation function object.
 *
 * @param md the message digest API to use (eg: forge.md.sha1.create()).
 *
 * @return a mask generation function object.
 */mgf1.create=function(md){var mgf={/**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */generate:function generate(seed,maskLen){/* 2. Let T be the empty octet string. */var t=new forge.util.ByteBuffer();/* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */var len=Math.ceil(maskLen/md.digestLength);for(var i=0;i<len;i++){/* a. Convert counter to an octet string C of length 4 octets */var c=new forge.util.ByteBuffer();c.putInt32(i);/* b. Concatenate the hash of the seed mgfSeed and C to the octet
         * string T: */md.start();md.update(seed+c.getBytes());t.putBuffer(md.digest());}/* Output the leading maskLen octets of T as the octet string mask. */t.truncate(t.length()-maskLen);return t.getBytes();}};return mgf;};/***/}]));});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHVuZ2FwL3VybC1zZWFyY2gtcGFyYW1zL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zLWV4dGVuc2lvbnMvZXNtL2NhY2hlQWRhcHRlckVuaGFuY2VyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MtZXh0ZW5zaW9ucy9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy1leHRlbnNpb25zL2VzbS90aHJvdHRsZUFkYXB0ZXJFbmhhbmNlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zLWV4dGVuc2lvbnMvZXNtL3V0aWxzL2J1aWxkU29ydGVkVVJMLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MtZXh0ZW5zaW9ucy9lc20vdXRpbHMvaXNDYWNoZUxpa2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZpbGwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZyb20uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2JpbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaG9zdC1yZXBvcnQtZXJyb3JzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXVybC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGVyZm9ybS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb21pc2UtcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3B1bnljb2RlLXRvLWFzY2lpLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1leGVjLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2FtZS12YWx1ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Nsb3BweS1hcnJheS1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLWF0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXJlcGVhdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy10cmltLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdGFzay5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9mZnNldC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHlwZWQtYXJyYXktZnJvbS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3R5cGVkLWFycmF5cy1jb25zdHJ1Y3RvcnMtcmVxdWlyZXMtd3JhcHBlcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2VyLWFnZW50LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdmFsaWRhdGUtc2V0LXByb3RvdHlwZS1vZi1hcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd3JhcHBlZC13ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXktYnVmZmVyLnNsaWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5kYXRhLXZpZXcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tZml4ZWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtaW50LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc2VhcmNoLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi51cmwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvYmluL2pzZW5jcnlwdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb21pc2Utd2luZG93L2Rpc3QvcHJvbWlzZS13aW5kb3cuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9wc2V1ZG9tYXAvbWFwLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHNldWRvbWFwL3BzZXVkb21hcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Lyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Lyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL2F1dGhNYW5hZ2VyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9zcmMvZGlzY291cnNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9zcmMvZGlzY291cnNlQXV0aC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL2Rpc2NvdXJzZUNsaWVudC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL2tleUdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL2tleU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL3NyYy92ZW5kb3IvZm9yZ2UtcGtpLmpzIl0sIm5hbWVzIjpbImdldEN1cnJlbnRVc2VyIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEN1cnJlbnRVc2VyIiwidXNlciIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJnZXRVc2VyQXBpS2V5Iiwic2V0VXNlckFwaUtleSIsImFwaUtleSIsImhhc1VzZXJBcGlLZXkiLCJnZXRBcHBQcm9wIiwiYXBwSWQiLCJuYW1lIiwic2V0QXBwUHJvcCIsInN0b3JlZFByb3AiLCJyZW1vdmVBcHBQcm9wIiwicmVtb3ZlSXRlbSIsImNsZWFyQXV0aERhdGEiLCJEaXNjb3Vyc2UiLCJvcHRpb25zIiwiX3JlcXVpcmVPcHRpb25zIiwiX2Zvcm1hdE9wdGlvbnMiLCJhdXRoIiwiRGlzY291cnNlQXV0aCIsImNsaWVudCIsIkRpc2NvdXJzZUNsaWVudCIsIlByb21pc2UiLCJhbGwiLCJpbml0IiwiRXJyb3IiLCJhcHBOYW1lIiwibGVuZ3RoIiwiYXBpQmFzZVVybCIsInNjb3BlcyIsIkFycmF5IiwiZm9ybWF0dGVkT3B0aW9ucyIsIl9zbHVnaWZ5IiwicmVwbGFjZSIsImpvaW4iLCJ0ZXh0IiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImlzTG9nZ2VkSW4iLCJQcm9taXNlV2luZG93IiwiX2dldExvZ2luVXJsIiwid2lkdGgiLCJoZWlnaHQiLCJvcmlnaW5SZWdleHAiLCJSZWdFeHAiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImRhdGEiLCJfc2V0VXNlckFwaUtleSIsInJlc3VsdCIsImtleSIsIl9yZWZyZXNoQ3VycmVudFVzZXIiLCJlcnJvciIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsIm9wZW4iLCJ0aGVuIiwiX2RvTG9nb3V0IiwiZ2V0Q3VycmVudFVzZXJOYW1lIiwiYXV0aE1hbmFnZXIiLCJfZ2V0Q2FsbFJlc3VsdCIsInNpemUiLCJnZXRDdXJyZW50U2Vzc2lvblVzZXIiLCJsb2dvdXQiLCJkZXNjZW5kaW5nIiwicG9zdHMiLCJyZXZlcnNlIiwiZmlsdGVyIiwicG9zdCIsInBvc3RfdHlwZSIsInRvcGljSWQiLCJub2NhY2hlIiwidG9waWMiLCJwb3N0X3N0cmVhbSIsInVzZXJuYW1lIiwiZmllbGQiLCJnZXRQdWJsaWNVc2VyRmllbGRzIiwidXNlckZpZWxkcyIsIm1lc3NhZ2UiLCJfY2hlY2tVc2VyQXBpS2V5IiwiX3Bvc3RDYWxsUmVzdWx0IiwidG9waWNfaWQiLCJyYXciLCJyZXNwb25zZSIsImhpZGRlbiIsInJlamVjdCIsImhpZGRlbl9yZWFzb25faWQiLCJlcnJvcnMiLCJwb3N0SWQiLCJpZCIsInBvc3RfYWN0aW9uX3R5cGVfaWQiLCJpbnN0YW5jZSIsIndpbmRvdyIsImttIiwiS2V5TWFuYWdlciIsImdldEtleXMiLCJfbWFuYWdlUGF5bG9hZCIsImdldFB1YmxpY0tleSIsIl9nZW5lcmF0ZVN0b3JlZFJhbmRvbSIsImhyZWYiLCJwYXJhbXMiLCJhcHBsaWNhdGlvbl9uYW1lIiwicHVibGljX2tleSIsIm5vbmNlIiwiY2xpZW50X2lkIiwiYXV0aF9yZWRpcmVjdCIsIl9zZXJpYWxpemVQYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiayIsImVuY29kZVVSSUNvbXBvbmVudCIsInN0b3JlZFJhbmRvbSIsIk1hdGgiLCJyYW5kb20iLCJzdWJzdHIiLCJ1cmwiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJoYXNoIiwic3BsaXQiLCJoYXMiLCJvcGVuZXIiLCJkZWNyeXB0UGF5bG9hZCIsImdldCIsInBheWxvYWRPYmplY3QiLCJhcGkiLCJwb3N0TWVzc2FnZSIsImF4aW9zIiwiY3JlYXRlIiwiYmFzZVVSTCIsImhlYWRlcnMiLCJhZGFwdGVyIiwiZGVmYXVsdHMiLCJ0aHJlc2hvbGQiLCJlbmRwb2ludCIsInByb3AiLCJmb3JjZVVwZGF0ZSIsInJlZHVjZSIsInJldHVybmVkUmVzcG9uc2UiLCJjdXJyZW50UHJvcCIsInBheWxvYWQiLCJ1c2VyQXBpS2V5IiwiY29tbW9uIiwiX3NldENzcmZUb2tlbiIsImZvcmdlIiwicmVxdWlyZSIsImdlbmVyYXRlIiwicmVzb2x2ZSIsInJzYSIsImdlbmVyYXRlS2V5UGFpciIsIndvcmtlclNjcmlwdCIsImdlbmVyYXRlZEtleXBhaXIiLCJrZXlwYWlyIiwicGtpIiwicHVibGljS2V5VG9QZW0iLCJwdWJsaWNLZXkiLCJwcml2YXRlS2V5VG9QZW0iLCJwcml2YXRlS2V5Iiwia2V5R2VuZXJhdG9yIiwicmVhZEtleXNGcm9tU3RvcmFnZSIsImdlbmVyYXRlTmV3S2V5cGFpciIsImdldFByaXZhdGVLZXkiLCJKc2VuY3J5cHQiLCJqc2VuY3J5cHQiLCJzZXRQcml2YXRlS2V5IiwiZGVjcnlwdCIsIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwic2VsZiIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwiZ2V0dGVyIiwibyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIm4iLCJfX2VzTW9kdWxlIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJ1c2VQdXJlSmF2YVNjcmlwdCIsImJhc2VOIiwidXRpbCIsInByb2Nlc3MiLCJuZXh0VGljayIsImJyb3dzZXIiLCJzZXRJbW1lZGlhdGUiLCJhcHBseSIsInVuZGVmaW5lZCIsImFyZ3VtZW50cyIsImNhbGxiYWNrIiwic2V0VGltZW91dCIsImhhbmRsZXIiLCJldmVudCIsInNvdXJjZSIsIm1zZyIsInN0b3BQcm9wYWdhdGlvbiIsImNvcHkiLCJjYWxsYmFja3MiLCJzbGljZSIsImZvckVhY2giLCJwdXNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJub3ciLCJEYXRlIiwiYXR0ciIsImRpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwib2xkU2V0SW1tZWRpYXRlIiwic2V0QXR0cmlidXRlIiwiaXNOb2RlanMiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJpc0FycmF5IiwieCIsImlzQXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImlzQXJyYXlCdWZmZXJWaWV3IiwiYnVmZmVyIiwiYnl0ZUxlbmd0aCIsIl9jaGVja0JpdHNQYXJhbSIsIkJ5dGVCdWZmZXIiLCJCeXRlU3RyaW5nQnVmZmVyIiwiYiIsInJlYWQiLCJCdWZmZXIiLCJhcnIiLCJVaW50OEFycmF5IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZSIsInB1dEJ5dGUiLCJfY29uc3RydWN0ZWRTdHJpbmdMZW5ndGgiLCJfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEgiLCJfb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyIsImlzRW1wdHkiLCJwdXRCeXRlcyIsImZpbGxXaXRoQnl0ZSIsImJ5dGVzIiwicHV0U3RyaW5nIiwic3RyIiwiZW5jb2RlVXRmOCIsInB1dEludDE2IiwicHV0SW50MjQiLCJwdXRJbnQzMiIsInB1dEludDE2TGUiLCJwdXRJbnQyNExlIiwicHV0SW50MzJMZSIsInB1dEludCIsInB1dFNpZ25lZEludCIsInB1dEJ1ZmZlciIsImdldEJ5dGVzIiwiZ2V0Qnl0ZSIsImNoYXJDb2RlQXQiLCJnZXRJbnQxNiIsInJ2YWwiLCJnZXRJbnQyNCIsImdldEludDMyIiwiZ2V0SW50MTZMZSIsImdldEludDI0TGUiLCJnZXRJbnQzMkxlIiwiZ2V0SW50IiwiZ2V0U2lnbmVkSW50IiwibWF4IiwiY291bnQiLCJtaW4iLCJjbGVhciIsImF0Iiwic2V0QXQiLCJsYXN0IiwiY3JlYXRlQnVmZmVyIiwiY29tcGFjdCIsInRydW5jYXRlIiwibGVuIiwidG9IZXgiLCJkZWNvZGVVdGY4IiwiRGF0YUJ1ZmZlciIsInJlYWRPZmZzZXQiLCJncm93U2l6ZSIsIkRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsIndyaXRlIiwid3JpdGVPZmZzZXQiLCJhY2NvbW1vZGF0ZSIsImFtb3VudCIsInNyYyIsImRzdCIsInNldCIsInNldFVpbnQ4IiwiZW5jb2RpbmciLCJ2aWV3IiwiY2VpbCIsImJpbmFyeSIsImhleCIsImRlY29kZSIsImJhc2U2NCIsIlVpbnQxNkFycmF5IiwidXRmMTYiLCJlbmNvZGUiLCJzZXRJbnQxNiIsInNldEludDgiLCJzZXRJbnQzMiIsImdldEludDgiLCJnZXRVaW50OCIsInV0ZjgiLCJpbnB1dCIsImZpbGxTdHJpbmciLCJ4b3JCeXRlcyIsInMxIiwiczIiLCJzMyIsInQiLCJoZXhUb0J5dGVzIiwicGFyc2VJbnQiLCJieXRlc1RvSGV4IiwiaW50MzJUb0J5dGVzIiwiX2Jhc2U2NCIsIl9iYXNlNjRJZHgiLCJfYmFzZTU4IiwiZW5jb2RlNjQiLCJtYXhsaW5lIiwibGluZSIsIm91dHB1dCIsImNocjEiLCJjaHIyIiwiY2hyMyIsImNoYXJBdCIsImlzTmFOIiwiZGVjb2RlNjQiLCJlbmMxIiwiZW5jMiIsImVuYzMiLCJlbmM0IiwidW5lc2NhcGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJiYXNlNTgiLCJvZmZzZXQiLCJvdXQiLCJqIiwic3ViYXJyYXkiLCJkZWZsYXRlIiwic3RhcnQiLCJmbGciLCJzdWJzdHJpbmciLCJpbmZsYXRlIiwiX3NldFN0b3JhZ2VPYmplY3QiLCJvYmoiLCJfZ2V0U3RvcmFnZU9iamVjdCIsIl9zZXRJdGVtIiwiX2dldEl0ZW0iLCJfcmVtb3ZlSXRlbSIsImVtcHR5IiwiX2NsZWFySXRlbXMiLCJfY2FsbFN0b3JhZ2VGdW5jdGlvbiIsImZ1bmMiLCJhcmdzIiwidHlwZSIsImRvbmUiLCJleGNlcHRpb24iLCJpZHgiLCJleCIsImNsZWFySXRlbXMiLCJwYXJzZVVybCIsInJlZ2V4IiwibGFzdEluZGV4IiwiZXhlYyIsImZ1bGwiLCJzY2hlbWUiLCJob3N0IiwicG9ydCIsInBhdGgiLCJmdWxsSG9zdCIsIl9xdWVyeVZhcmlhYmxlcyIsImdldFF1ZXJ5VmFyaWFibGVzIiwicXVlcnkiLCJxIiwia3ZwYWlycyIsInBvcyIsImluZGV4T2YiLCJ2YWwiLCJwYXJzZUZyYWdtZW50IiwiZnJhZ21lbnQiLCJmcCIsImZxIiwic2hpZnQiLCJwYXRoU3RyaW5nIiwicXVlcnlTdHJpbmciLCJtYWtlUmVxdWVzdCIsInJlcVN0cmluZyIsImZyYWciLCJyZXEiLCJnZXRQYXRoIiwiZ2V0UXVlcnkiLCJnZXRRdWVyeUxhc3QiLCJfZGVmYXVsdCIsInZhbHMiLCJtYWtlTGluayIsImpRdWVyeSIsInFzdHIiLCJwYXJhbSIsInNldFBhdGgiLCJ2YWx1ZSIsIm5leHQiLCJoYXNOZXh0IiwiZGVsZXRlUGF0aCIsImZvcm1hdCIsInJlIiwibWF0Y2giLCJwYXJ0IiwiYXJnaSIsInBhcnRzIiwiY29kZSIsImZvcm1hdE51bWJlciIsIm51bWJlciIsImRlY2ltYWxzIiwiZGVjX3BvaW50IiwidGhvdXNhbmRzX3NlcCIsImFicyIsInRvRml4ZWQiLCJmb3JtYXRTaXplIiwiYnl0ZXNGcm9tSVAiLCJpcCIsImJ5dGVzRnJvbUlQdjQiLCJieXRlc0Zyb21JUHY2IiwibnVtIiwiYmxhbmtzIiwiemVyb3MiLCJieXRlc1RvSVAiLCJieXRlc1RvSVB2NCIsImJ5dGVzVG9JUHY2IiwiemVyb0dyb3VwcyIsInplcm9NYXhHcm91cCIsImVuZCIsImdyb3VwIiwic3BsaWNlIiwidW5zaGlmdCIsImVzdGltYXRlQ29yZXMiLCJ1cGRhdGUiLCJjb3JlcyIsIm5hdmlnYXRvciIsImhhcmR3YXJlQ29uY3VycmVuY3kiLCJXb3JrZXIiLCJCbG9iIiwiYmxvYlVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInN0IiwiZXQiLCJzYW1wbGUiLCJzYW1wbGVzIiwibnVtV29ya2VycyIsImF2ZyIsImZsb29yIiwicmV2b2tlT2JqZWN0VVJMIiwiZXJyIiwicmVzdWx0cyIsIndvcmtlcnMiLCJ3b3JrZXIiLCJ0ZXJtaW5hdGUiLCJvdmVybGFwcyIsInIxIiwib3ZlcmxhcCIsInIyIiwiYXNuMSIsIkNsYXNzIiwiVU5JVkVSU0FMIiwiQVBQTElDQVRJT04iLCJDT05URVhUX1NQRUNJRklDIiwiUFJJVkFURSIsIlR5cGUiLCJOT05FIiwiQk9PTEVBTiIsIklOVEVHRVIiLCJCSVRTVFJJTkciLCJPQ1RFVFNUUklORyIsIk5VTEwiLCJPSUQiLCJPREVTQyIsIkVYVEVSTkFMIiwiUkVBTCIsIkVOVU1FUkFURUQiLCJFTUJFRERFRCIsIlVURjgiLCJST0lEIiwiU0VRVUVOQ0UiLCJTRVQiLCJQUklOVEFCTEVTVFJJTkciLCJJQTVTVFJJTkciLCJVVENUSU1FIiwiR0VORVJBTElaRURUSU1FIiwiQk1QU1RSSU5HIiwidGFnQ2xhc3MiLCJjb25zdHJ1Y3RlZCIsInRtcCIsImNvbXBvc2VkIiwiYml0U3RyaW5nQ29udGVudHMiLCJvcmlnaW5hbCIsImV4Y2x1ZGVCaXRTdHJpbmdDb250ZW50cyIsImVxdWFscyIsIm9iajEiLCJvYmoyIiwiZXF1YWwiLCJpbmNsdWRlQml0U3RyaW5nQ29udGVudHMiLCJnZXRCZXJWYWx1ZUxlbmd0aCIsImIyIiwibG9uZ0Zvcm0iLCJfY2hlY2tCdWZmZXJMZW5ndGgiLCJyZW1haW5pbmciLCJhdmFpbGFibGUiLCJyZXF1ZXN0ZWQiLCJfZ2V0VmFsdWVMZW5ndGgiLCJsb25nRm9ybUJ5dGVzIiwiZnJvbURlciIsInN0cmljdCIsImRlY29kZUJpdFN0cmluZ3MiLCJfZnJvbURlciIsImRlcHRoIiwiYjEiLCJzYXZlZFJlYWQiLCJzYXZlZFJlbWFpbmluZyIsInVudXNlZCIsInN1Yk9wdGlvbnMiLCJ2ZXJib3NlIiwidXNlZCIsInRjIiwiYXNuMU9wdGlvbnMiLCJ0b0RlciIsInVzZUJpdFN0cmluZ0NvbnRlbnRzIiwibGVuQnl0ZXMiLCJvaWRUb0RlciIsIm9pZCIsInZhbHVlcyIsInZhbHVlQnl0ZXMiLCJkZXJUb09pZCIsInV0Y1RpbWVUb0RhdGUiLCJ1dGMiLCJkYXRlIiwieWVhciIsIk1NIiwiREQiLCJoaCIsIm1tIiwic3MiLCJzZXRVVENGdWxsWWVhciIsInNldFVUQ0hvdXJzIiwiaGhvZmZzZXQiLCJtbW9mZnNldCIsInNldFRpbWUiLCJnZW5lcmFsaXplZFRpbWVUb0RhdGUiLCJnZW50aW1lIiwiWVlZWSIsImZmZiIsImlzVVRDIiwicGFyc2VGbG9hdCIsInNldEZ1bGxZZWFyIiwic2V0SG91cnMiLCJkYXRlVG9VdGNUaW1lIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lIiwiaW50ZWdlclRvRGVyIiwiaW50ZWdlciIsImRlclRvSW50ZWdlciIsInZhbGlkYXRlIiwidiIsImNhcHR1cmUiLCJvcHRpb25hbCIsImNhcHR1cmVBc24xIiwiY2FwdHVyZUJpdFN0cmluZ0NvbnRlbnRzIiwiY2FwdHVyZUJpdFN0cmluZ1ZhbHVlIiwiX25vbkxhdGluUmVnZXgiLCJwcmV0dHlQcmludCIsImxldmVsIiwiaW5kZW50YXRpb24iLCJpbmRlbnQiLCJJQTVTdHJpbmciLCJzdWJ2YWx1ZXMiLCJzdWIiLCJvaWRzIiwidGVzdCIsIl9JTiIsIl9JXyIsIm1kIiwiYWxnb3JpdGhtcyIsInBybmdfYWVzIiwiX3BybmdfYWVzX291dHB1dCIsIl9wcm5nX2Flc19idWZmZXIiLCJmb3JtYXRLZXkiLCJhZXMiLCJfZXhwYW5kS2V5IiwiZm9ybWF0U2VlZCIsInNlZWQiLCJjaXBoZXIiLCJfdXBkYXRlQmxvY2siLCJpbmNyZW1lbnQiLCJzaGEyNTYiLCJzcGF3blBybmciLCJjdHgiLCJwcm5nIiwiZ2V0Qnl0ZXNTeW5jIiwiX2N0eCIsImdldFJhbmRvbVZhbHVlcyIsIl9jcnlwdG8iLCJjcnlwdG8iLCJtc0NyeXB0byIsImNvbGxlY3RJbnQiLCJfbmF2Qnl0ZXMiLCJjb2xsZWN0IiwibW91c2Vtb3ZlIiwiY2xpZW50WCIsImNsaWVudFkiLCJrZXlwcmVzcyIsImNoYXJDb2RlIiwiY3JlYXRlSW5zdGFuY2UiLCJCaWdJbnRlZ2VyIiwianNibiIsIkdDRF8zMF9ERUxUQSIsInByaXZhdGVLZXlWYWxpZGF0b3IiLCJyc2FQcml2YXRlS2V5VmFsaWRhdG9yIiwicnNhUHVibGljS2V5VmFsaWRhdG9yIiwicHVibGljS2V5VmFsaWRhdG9yIiwiZW1zYVBrY3MxdjE1ZW5jb2RlIiwiYWxnb3JpdGhtIiwib2lkQnl0ZXMiLCJkaWdlc3RJbmZvIiwiZGlnZXN0QWxnb3JpdGhtIiwiZGlnZXN0IiwiX21vZFBvdyIsInB1YiIsIm1vZFBvdyIsImRQIiwibW9kIiwic3VidHJhY3QiLCJPTkUiLCJkUSIsInFJbnYiLCJtb2RJbnZlcnNlIiwiciIsImJpdExlbmd0aCIsImNvbXBhcmVUbyIsImdjZCIsIm11bHRpcGx5IiwieHAiLCJ4cSIsImFkZCIsInkiLCJlbmNyeXB0IiwiYnQiLCJlYiIsIl9lbmNvZGVQa2NzMV92MV81IiwieWhleCIsImVkIiwibWwiLCJleHBlY3RlZCIsInhoZXgiLCJfZGVjb2RlUGtjczFfdjFfNSIsImNyZWF0ZUtleVBhaXJHZW5lcmF0aW9uU3RhdGUiLCJiaXRzIiwicm5nIiwibmV4dEJ5dGVzIiwic3RhdGUiLCJlSW50IiwicUJpdHMiLCJwQml0cyIsInBxU3RhdGUiLCJmcm9tSW50Iiwic3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUiLCJUSElSVFkiLCJkZWx0YUlkeCIsIm9wX29yIiwidDEiLCJ0MiIsInRvdGFsIiwiYml0czEiLCJ0ZXN0Qml0IiwiYml0d2lzZVRvIiwic2hpZnRMZWZ0IiwiZEFkZE9mZnNldCIsImJ5dGVWYWx1ZSIsImlzUHJvYmFibGVQcmltZSIsIl9nZXRNaWxsZXJSYWJpblRlc3RzIiwicDEiLCJxMSIsInBoaSIsInNldFB1YmxpY0tleSIsIl9kZXRlY3RTdWJ0bGVDcnlwdG8iLCJzdWJ0bGUiLCJnZW5lcmF0ZUtleSIsIm1vZHVsdXNMZW5ndGgiLCJwdWJsaWNFeHBvbmVudCIsIl9pbnRUb1VpbnQ4QXJyYXkiLCJwYWlyIiwiZXhwb3J0S2V5IiwicGtjczgiLCJwcml2YXRlS2V5RnJvbUFzbjEiLCJzZXRSc2FQdWJsaWNLZXkiLCJfZGV0ZWN0U3VidGxlTXNDcnlwdG8iLCJnZW5PcCIsIm9uY29tcGxldGUiLCJ0YXJnZXQiLCJleHBvcnRPcCIsIm9uZXJyb3IiLCJfZ2VuZXJhdGVLZXlQYWlyIiwic2NoZW1lT3B0aW9ucyIsInRvVXBwZXJDYXNlIiwicGtjczEiLCJlbmNvZGVfcnNhX29hZXAiLCJ2ZXJpZnkiLCJzaWduYXR1cmUiLCJzZXRSc2FQcml2YXRlS2V5IiwiZGVjb2RlX3JzYV9vYWVwIiwic2lnbiIsIndyYXBSc2FQcml2YXRlS2V5IiwicnNhS2V5IiwicnNhRW5jcnlwdGlvbiIsInByaXZhdGVLZXlNb2R1bHVzIiwicHJpdmF0ZUtleVB1YmxpY0V4cG9uZW50IiwicHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudCIsInByaXZhdGVLZXlQcmltZTEiLCJwcml2YXRlS2V5UHJpbWUyIiwicHJpdmF0ZUtleUV4cG9uZW50MSIsInByaXZhdGVLZXlFeHBvbmVudDIiLCJwcml2YXRlS2V5Q29lZmZpY2llbnQiLCJwcml2YXRlS2V5VG9Bc24xIiwicHJpdmF0ZUtleVRvUlNBUHJpdmF0ZUtleSIsIl9iblRvQnl0ZXMiLCJwdWJsaWNLZXlGcm9tQXNuMSIsInB1YmxpY0tleU9pZCIsInJzYVB1YmxpY0tleSIsInB1YmxpY0tleU1vZHVsdXMiLCJwdWJsaWNLZXlFeHBvbmVudCIsInB1YmxpY0tleVRvQXNuMSIsInB1YmxpY0tleVRvU3ViamVjdFB1YmxpY0tleUluZm8iLCJwdWJsaWNLZXlUb1JTQVB1YmxpY0tleSIsInBhZE51bSIsInBhZEJ5dGUiLCJudW1aZXJvcyIsInBhZEJ5dGVzIiwiZW0iLCJmaXJzdCIsInplcm8iLCJvcHRzIiwid29ya0xvYWQiLCJnZXRQcmltZSIsImZpbmlzaCIsInByaW1lIiwiZ2VuZXJhdGVQcm9iYWJsZVByaW1lIiwiZm4iLCJfcHJpdmF0ZUtleUZyb21Kd2siLCJqd2siLCJrdHkiLCJfYmFzZTY0VG9CaWdJbnQiLCJkcCIsImRxIiwicWkiLCJfcHVibGljS2V5RnJvbUp3ayIsImI2NCIsInN0YXJ0RW5jcnlwdGluZyIsIml2IiwibW9kZSIsIl9jcmVhdGVDaXBoZXIiLCJjcmVhdGVFbmNyeXB0aW9uQ2lwaGVyIiwic3RhcnREZWNyeXB0aW5nIiwiY3JlYXRlRGVjcnlwdGlvbkNpcGhlciIsIkFsZ29yaXRobSIsImluaXRpYWxpemUiLCJibG9ja1NpemUiLCJpbkJsb2NrIiwib3V0QmxvY2siLCJfdyIsIl9pbml0IiwiZW5jcnlwdE9wIiwicmVnaXN0ZXJBbGdvcml0aG0iLCJtb2RlcyIsImVjYiIsImNiYyIsImNmYiIsIm9mYiIsImN0ciIsImdjbSIsIk5iIiwic2JveCIsImlzYm94IiwicmNvbiIsIm1peCIsImltaXgiLCJ4dGltZSIsImVpIiwiZTIiLCJlNCIsImU4Iiwic3giLCJzeDIiLCJtZSIsImltZSIsInciLCJ0ZW1wIiwiaU5rIiwiTmsiLCJOcjEiLCJtMCIsIm0xIiwibTIiLCJtMyIsInduZXciLCJ3aSIsIk5yIiwiYSIsImEyIiwiYzIiLCJyb3VuZCIsImNyZWF0ZURlY2lwaGVyIiwiY3JlYXRlQ2lwaGVyIiwicGVtIiwiaGVhZGVyIiwicHJvY1R5cGUiLCJ2ZXJzaW9uIiwiZm9sZEhlYWRlciIsImNvbnRlbnREb21haW4iLCJkZWtJbmZvIiwicGFyYW1ldGVycyIsImJvZHkiLCJyTWVzc2FnZSIsInJIZWFkZXIiLCJyQ1JMRiIsImxpbmVzIiwibGkiLCJubCIsInZpIiwibHRyaW0iLCJpbnNlcnRTcGFjZSIsIiQxIiwiY2FuZGlkYXRlIiwiaW5zZXJ0IiwicGJlIiwiZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciIsIlBCRVMyQWxnb3JpdGhtc1ZhbGlkYXRvciIsInBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciIsImVuY3J5cHRQcml2YXRlS2V5SW5mbyIsInBhc3N3b3JkIiwic2FsdFNpemUiLCJwcmZBbGdvcml0aG0iLCJzYWx0IiwiY291bnRCeXRlcyIsImRrTGVuIiwiZW5jcnlwdGlvbkFsZ29yaXRobSIsImVuY3J5cHRlZERhdGEiLCJpdkxlbiIsImVuY09pZCIsImNpcGhlckZuIiwiZGVzIiwicHJmQWxnb3JpdGhtVG9NZXNzYWdlRGlnZXN0IiwiZGsiLCJwa2NzNSIsInBia2RmMiIsImNyZWF0ZVBia2RmMlBhcmFtcyIsInNhbHRCeXRlcyIsImdlbmVyYXRlUGtjczEyS2V5IiwiZGVjcnlwdFByaXZhdGVLZXlJbmZvIiwiZW5jcnlwdGlvbk9pZCIsImdldENpcGhlciIsImVuY3J5cHRpb25QYXJhbXMiLCJlbmNyeXB0ZWQiLCJlbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0iLCJlcGtpIiwiZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0iLCJoZWFkZXJUeXBlIiwiZW5jcnlwdFJzYVByaXZhdGVLZXkiLCJsZWdhY3kiLCJvcGVuc3NsRGVyaXZlQnl0ZXMiLCJkZWNyeXB0UnNhUHJpdmF0ZUtleSIsInJjMiIsIml0ZXIiLCJzaGExIiwidSIsImRpZ2VzdExlbmd0aCIsImJsb2NrTGVuZ3RoIiwicGFzc0J1ZiIsIkQiLCJTbGVuIiwiUyIsIlBsZW4iLCJQIiwiSSIsImJ1ZiIsIkIiLCJJbmV3IiwiY2h1bmsiLCJnZXRDaXBoZXJGb3JQQkVTMiIsImdldENpcGhlckZvclBLQ1MxMlBCRSIsInN1cHBvcnRlZE9pZHMiLCJrZGZPaWQiLCJrZGZTYWx0Iiwia2RmSXRlcmF0aW9uQ291bnQiLCJwcmZPaWRUb01lc3NhZ2VEaWdlc3QiLCJwcmZPaWQiLCJlbmNJdiIsIml0ZXJhdGlvbnMiLCJkSXZMZW4iLCJtZDUiLCJkaWdlc3RzIiwic3VwcG9ydGVkIiwic2hhNTEyIiwiZ2V0QWxnb3JpdGhtIiwiQmxvY2tDaXBoZXIiLCJfZmluaXNoIiwiX2lucHV0IiwiX29wIiwiX2RlY3J5cHQiLCJwYWQiLCJ1bnBhZCIsIm92ZXJmbG93IiwiYWZ0ZXJGaW5pc2giLCJfaW50cyIsIl9pbkJsb2NrIiwiX291dEJsb2NrIiwicGFkZGluZyIsIl9wcmV2IiwiX2l2IiwidHJhbnNmb3JtSVYiLCJfcGFydGlhbEJsb2NrIiwiX3BhcnRpYWxPdXRwdXQiLCJfcGFydGlhbEJ5dGVzIiwiaW5wdXRMZW5ndGgiLCJwYXJ0aWFsQnl0ZXMiLCJpbmMzMiIsIl9SIiwiX2NpcGhlckxlbmd0aCIsImFkZGl0aW9uYWxEYXRhIiwiX3RhZ0xlbmd0aCIsInRhZ0xlbmd0aCIsIl90YWciLCJ0YWciLCJfaGFzaEJsb2NrIiwiX2hhc2hTdWJrZXkiLCJjb21wb25lbnRCaXRzIiwiX20iLCJnZW5lcmF0ZUhhc2hUYWJsZSIsIml2TGVuZ3RoIiwiX2owIiwiZ2hhc2giLCJjb25jYXQiLCJmcm9tNjRUbzMyIiwiX2FEYXRhTGVuZ3RoIiwiX3MiLCJsZW5ndGhzIiwiel9pIiwidl9pIiwieF9pIiwicG93IiwibHNiIiwidGFibGVNdWx0aXBseSIsInoiLCJhaCIsImgiLCJtdWx0aXBsaWVyIiwicGVySW50Iiwic2hmdCIsImdlbmVyYXRlU3ViSGFzaFRhYmxlIiwibWlkIiwiaGFsZiIsIm1faSIsIm1faiIsImJsb2NrIiwiX2tleXMiLCJfY3JlYXRlS2V5cyIsInNwZnVuY3Rpb24xIiwic3BmdW5jdGlvbjIiLCJzcGZ1bmN0aW9uMyIsInNwZnVuY3Rpb240Iiwic3BmdW5jdGlvbjUiLCJzcGZ1bmN0aW9uNiIsInNwZnVuY3Rpb243Iiwic3BmdW5jdGlvbjgiLCJwYzJieXRlczAiLCJwYzJieXRlczEiLCJwYzJieXRlczIiLCJwYzJieXRlczMiLCJwYzJieXRlczQiLCJwYzJieXRlczUiLCJwYzJieXRlczYiLCJwYzJieXRlczciLCJwYzJieXRlczgiLCJwYzJieXRlczkiLCJwYzJieXRlczEwIiwicGMyYnl0ZXMxMSIsInBjMmJ5dGVzMTIiLCJwYzJieXRlczEzIiwic2hpZnRzIiwibGVmdCIsInJpZ2h0IiwibGVmdHRtcCIsInJpZ2h0dG1wIiwibG9vcGluZyIsImVuZGxvb3AiLCJsb29waW5jIiwicmlnaHQxIiwicmlnaHQyIiwicGJrZGYyU3luYyIsImhMZW4iLCJwcmYiLCJobWFjIiwieG9yIiwidV9jIiwidV9jMSIsIm91dGVyIiwiaW5uZXIiLCJfa2V5IiwiX21kIiwiX2lwYWRkaW5nIiwiX29wYWRkaW5nIiwia2V5bGVuIiwiZ2V0TWFjIiwiZGJpdHMiLCJjYW5hcnkiLCJqX2xtIiwiZnJvbU51bWJlciIsImZyb21TdHJpbmciLCJuYmkiLCJhbTEiLCJhbTIiLCJ4bCIsInhoIiwiYW0zIiwiYW0iLCJEQiIsIkRNIiwiRFYiLCJCSV9GUCIsIkZWIiwiRjEiLCJGMiIsIkJJX1JNIiwiQklfUkMiLCJyciIsInZ2IiwiaW50MmNoYXIiLCJpbnRBdCIsImJucENvcHlUbyIsImJucEZyb21JbnQiLCJuYnYiLCJibnBGcm9tU3RyaW5nIiwiZnJvbVJhZGl4IiwibWkiLCJzaCIsImNsYW1wIiwiWkVSTyIsInN1YlRvIiwiYm5wQ2xhbXAiLCJiblRvU3RyaW5nIiwibmVnYXRlIiwidG9SYWRpeCIsImJuTmVnYXRlIiwiYm5BYnMiLCJibkNvbXBhcmVUbyIsIm5iaXRzIiwiYm5CaXRMZW5ndGgiLCJibnBETFNoaWZ0VG8iLCJibnBEUlNoaWZ0VG8iLCJibnBMU2hpZnRUbyIsImJzIiwiY2JzIiwiYm0iLCJkcyIsImJucFJTaGlmdFRvIiwiYm5wU3ViVG8iLCJibnBNdWx0aXBseVRvIiwiYm5wU3F1YXJlVG8iLCJibnBEaXZSZW1UbyIsInBtIiwicHQiLCJjb3B5VG8iLCJ0cyIsIm1zIiwibnNoIiwibFNoaWZ0VG8iLCJ5cyIsInkwIiwieXQiLCJkMSIsImQyIiwiZGxTaGlmdFRvIiwicWQiLCJkclNoaWZ0VG8iLCJyU2hpZnRUbyIsImJuTW9kIiwiZGl2UmVtVG8iLCJDbGFzc2ljIiwiY0NvbnZlcnQiLCJjUmV2ZXJ0IiwiY1JlZHVjZSIsImNNdWxUbyIsIm11bHRpcGx5VG8iLCJjU3FyVG8iLCJzcXVhcmVUbyIsImNvbnZlcnQiLCJyZXZlcnQiLCJtdWxUbyIsInNxclRvIiwiYm5wSW52RGlnaXQiLCJNb250Z29tZXJ5IiwibXAiLCJpbnZEaWdpdCIsIm1wbCIsIm1waCIsInVtIiwibXQyIiwibW9udENvbnZlcnQiLCJtb250UmV2ZXJ0IiwibW9udFJlZHVjZSIsInUwIiwibW9udFNxclRvIiwibW9udE11bFRvIiwiYm5wSXNFdmVuIiwiYm5wRXhwIiwiZyIsImJuTW9kUG93SW50IiwiaXNFdmVuIiwiZXhwIiwibW9kUG93SW50IiwiYm5DbG9uZSIsImJuSW50VmFsdWUiLCJibkJ5dGVWYWx1ZSIsImJuU2hvcnRWYWx1ZSIsImJucENodW5rU2l6ZSIsIkxOMiIsImxvZyIsImJuU2lnTnVtIiwiYm5wVG9SYWRpeCIsInNpZ251bSIsImNzIiwiY2h1bmtTaXplIiwiaW50VmFsdWUiLCJibnBGcm9tUmFkaXgiLCJkTXVsdGlwbHkiLCJibnBGcm9tTnVtYmVyIiwiYm5Ub0J5dGVBcnJheSIsImJuRXF1YWxzIiwiYm5NaW4iLCJibk1heCIsImJucEJpdHdpc2VUbyIsIm9wIiwiZiIsIm9wX2FuZCIsImJuQW5kIiwiYm5PciIsIm9wX3hvciIsImJuWG9yIiwib3BfYW5kbm90IiwiYm5BbmROb3QiLCJibk5vdCIsImJuU2hpZnRMZWZ0IiwiYm5TaGlmdFJpZ2h0IiwibGJpdCIsImJuR2V0TG93ZXN0U2V0Qml0IiwiY2JpdCIsImJuQml0Q291bnQiLCJiblRlc3RCaXQiLCJibnBDaGFuZ2VCaXQiLCJiblNldEJpdCIsImNoYW5nZUJpdCIsImJuQ2xlYXJCaXQiLCJibkZsaXBCaXQiLCJibnBBZGRUbyIsImJuQWRkIiwiYWRkVG8iLCJiblN1YnRyYWN0IiwiYm5NdWx0aXBseSIsImJuRGl2aWRlIiwiYm5SZW1haW5kZXIiLCJibkRpdmlkZUFuZFJlbWFpbmRlciIsImJucERNdWx0aXBseSIsImJucERBZGRPZmZzZXQiLCJOdWxsRXhwIiwibk5vcCIsIm5NdWxUbyIsIm5TcXJUbyIsImJuUG93IiwiYm5wTXVsdGlwbHlMb3dlclRvIiwiYm5wTXVsdGlwbHlVcHBlclRvIiwiQmFycmV0dCIsInEzIiwibXUiLCJkaXZpZGUiLCJiYXJyZXR0Q29udmVydCIsImJhcnJldHRSZXZlcnQiLCJiYXJyZXR0UmVkdWNlIiwibXVsdGlwbHlVcHBlclRvIiwibXVsdGlwbHlMb3dlclRvIiwiYmFycmV0dFNxclRvIiwiYmFycmV0dE11bFRvIiwiYm5Nb2RQb3ciLCJrMSIsImcyIiwiaXMxIiwiYm5HQ0QiLCJjbG9uZSIsImdldExvd2VzdFNldEJpdCIsImJucE1vZEludCIsImJuTW9kSW52ZXJzZSIsImFjIiwibG93cHJpbWVzIiwibHBsaW0iLCJibklzUHJvYmFibGVQcmltZSIsIm1vZEludCIsIm1pbGxlclJhYmluIiwiYm5wTWlsbGVyUmFiaW4iLCJuMSIsInNoaWZ0UmlnaHQiLCJibkdldFBybmciLCJzaG9ydFZhbHVlIiwidG9CeXRlQXJyYXkiLCJhbmQiLCJvciIsImFuZE5vdCIsIm5vdCIsImJpdENvdW50Iiwic2V0Qml0IiwiY2xlYXJCaXQiLCJmbGlwQml0IiwicmVtYWluZGVyIiwiZGl2aWRlQW5kUmVtYWluZGVyIiwiX2luaXRpYWxpemVkIiwiX3N0YXRlIiwibWVzc2FnZUxlbmd0aCIsImZ1bGxNZXNzYWdlTGVuZ3RoIiwibWVzc2FnZUxlbmd0aFNpemUiLCJtZXNzYWdlTGVuZ3RoNjQiLCJpbnQzMnMiLCJoMCIsImgxIiwiaDIiLCJoMyIsImg0IiwiX3VwZGF0ZSIsImZpbmFsQmxvY2siLCJfcGFkZGluZyIsImNhcnJ5IiwiX3Nob3J0TmFtZXMiLCJ4NTA5Q2VydGlmaWNhdGVWYWxpZGF0b3IiLCJyc2Fzc2FQc3NQYXJhbWV0ZXJWYWxpZGF0b3IiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9WYWxpZGF0b3IiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdFZhbGlkYXRvciIsIlJETkF0dHJpYnV0ZXNBc0FycmF5IiwicmRuIiwic2kiLCJ2YWx1ZVRhZ0NsYXNzIiwic2hvcnROYW1lIiwiQ1JJQXR0cmlidXRlc0FzQXJyYXkiLCJzZXEiLCJleHRlbnNpb25SZXF1ZXN0IiwiZXh0ZW5zaW9ucyIsImNlcnRpZmljYXRlRXh0ZW5zaW9uRnJvbUFzbjEiLCJfZ2V0QXR0cmlidXRlIiwiX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzIiwiZmlsbERlZmF1bHRzIiwiYWxnb3JpdGhtT2lkIiwibWdmIiwic2FsdExlbmd0aCIsImhhc2hPaWQiLCJtYXNrR2VuT2lkIiwibWFza0dlbkhhc2hPaWQiLCJjZXJ0aWZpY2F0ZUZyb21QZW0iLCJjb21wdXRlSGFzaCIsImNlcnRpZmljYXRlRnJvbUFzbjEiLCJjZXJ0aWZpY2F0ZVRvUGVtIiwiY2VydCIsImNlcnRpZmljYXRlVG9Bc24xIiwicHVibGljS2V5RnJvbVBlbSIsInB1YmxpY0tleVRvUlNBUHVibGljS2V5UGVtIiwiZ2V0UHVibGljS2V5RmluZ2VycHJpbnQiLCJkZWxpbWl0ZXIiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21QZW0iLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21Bc24xIiwiY2VydGlmaWNhdGlvblJlcXVlc3RUb1BlbSIsImNzciIsImNlcnRpZmljYXRpb25SZXF1ZXN0VG9Bc24xIiwiY3JlYXRlQ2VydGlmaWNhdGUiLCJzZXJpYWxOdW1iZXIiLCJzaWduYXR1cmVPaWQiLCJzaWdpbmZvIiwidmFsaWRpdHkiLCJub3RCZWZvcmUiLCJub3RBZnRlciIsImlzc3VlciIsImdldEZpZWxkIiwic24iLCJhZGRGaWVsZCIsIl9maWxsTWlzc2luZ0ZpZWxkcyIsInN1YmplY3QiLCJzZXRTdWJqZWN0IiwiYXR0cnMiLCJ1bmlxdWVJZCIsInNldElzc3VlciIsInNldEV4dGVuc2lvbnMiLCJleHRzIiwiX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzIiwiZ2V0RXh0ZW5zaW9uIiwiZXh0IiwidGJzQ2VydGlmaWNhdGUiLCJnZXRUQlNDZXJ0aWZpY2F0ZSIsImNoaWxkIiwiaXNzdWVkIiwiZXhwZWN0ZWRJc3N1ZXIiLCJhY3R1YWxJc3N1ZXIiLCJzaGEzODQiLCJzaGExV2l0aFJTQUVuY3J5cHRpb24iLCJzaWduYXR1cmVQYXJhbWV0ZXJzIiwicHNzIiwiaXNJc3N1ZXIiLCJwYXJlbnQiLCJpYXR0ciIsInNhdHRyIiwiZ2VuZXJhdGVTdWJqZWN0S2V5SWRlbnRpZmllciIsInZlcmlmeVN1YmplY3RLZXlJZGVudGlmaWVyIiwic2tpIiwic3ViamVjdEtleUlkZW50aWZpZXIiLCJjZXJ0VmVyc2lvbiIsInNlcmlhbCIsImNlcnRTZXJpYWxOdW1iZXIiLCJjZXJ0U2lnbmF0dXJlT2lkIiwiY2VydFNpZ25hdHVyZVBhcmFtcyIsImNlcnRpbmZvU2lnbmF0dXJlT2lkIiwiY2VydGluZm9TaWduYXR1cmVQYXJhbXMiLCJjZXJ0U2lnbmF0dXJlIiwiY2VydFZhbGlkaXR5MVVUQ1RpbWUiLCJjZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lIiwiY2VydFZhbGlkaXR5M1VUQ1RpbWUiLCJjZXJ0VmFsaWRpdHk0R2VuZXJhbGl6ZWRUaW1lIiwiaW1kIiwiY2VydElzc3VlciIsImNlcnRJc3N1ZXJVbmlxdWVJZCIsInNtZCIsImNlcnRTdWJqZWN0IiwiY2VydFN1YmplY3RVbmlxdWVJZCIsImNlcnRFeHRlbnNpb25zIiwiY2VydGlmaWNhdGVFeHRlbnNpb25zRnJvbUFzbjEiLCJzdWJqZWN0UHVibGljS2V5SW5mbyIsImV4dHNlcSIsImNyaXRpY2FsIiwiZXYiLCJiMyIsImRpZ2l0YWxTaWduYXR1cmUiLCJub25SZXB1ZGlhdGlvbiIsImtleUVuY2lwaGVybWVudCIsImRhdGFFbmNpcGhlcm1lbnQiLCJrZXlBZ3JlZW1lbnQiLCJrZXlDZXJ0U2lnbiIsImNSTFNpZ24iLCJlbmNpcGhlck9ubHkiLCJkZWNpcGhlck9ubHkiLCJjQSIsInBhdGhMZW5Db25zdHJhaW50Iiwic2VydmVyIiwiZW1haWwiLCJvYmpzaWduIiwicmVzZXJ2ZWQiLCJzc2xDQSIsImVtYWlsQ0EiLCJvYmpDQSIsImFsdE5hbWVzIiwiZ24iLCJhbHROYW1lIiwiY3JlYXRlQ2VydGlmaWNhdGlvblJlcXVlc3QiLCJjc3JWZXJzaW9uIiwiY3NyU2lnbmF0dXJlT2lkIiwiY3NyU2lnbmF0dXJlUGFyYW1zIiwiY3NyU2lnbmF0dXJlIiwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIiwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvU3ViamVjdCIsImdldEF0dHJpYnV0ZSIsImFkZEF0dHJpYnV0ZSIsImNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb0F0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGVzIiwiZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIiwiY3JpIiwiX2RuVG9Bc24xIiwiX2dldEF0dHJpYnV0ZXNBc0pzb24iLCJhdHRyaWJ1dGUiLCJ2YWx1ZUNvbnN0cnVjdGVkIiwiY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEiLCJleHRlbnNpb24iLCJrZXlJZGVudGlmaWVyIiwiYXV0aG9yaXR5Q2VydElzc3VlciIsInN1YlNlcSIsImZ1bGxOYW1lR2VuZXJhbE5hbWVzIiwiX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEiLCJfQ1JJQXR0cmlidXRlc1RvQXNuMSIsImphbl8xXzE5NTAiLCJqYW5fMV8yMDUwIiwiX2RhdGVUb0FzbjEiLCJ0YnMiLCJjZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEiLCJkaXN0aW5ndWlzaGVkTmFtZVRvQXNuMSIsImRuIiwiY3JlYXRlQ2FTdG9yZSIsImNlcnRzIiwiY2FTdG9yZSIsImdldElzc3VlciIsImdldEJ5U3ViamVjdCIsImFkZENlcnRpZmljYXRlIiwiZW5zdXJlU3ViamVjdEhhc0hhc2giLCJoYXNDZXJ0aWZpY2F0ZSIsImRlcjEiLCJkZXIyIiwibGlzdEFsbENlcnRpZmljYXRlcyIsImNlcnRMaXN0IiwicmVtb3ZlQ2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZUVycm9yIiwiYmFkX2NlcnRpZmljYXRlIiwidW5zdXBwb3J0ZWRfY2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZV9yZXZva2VkIiwiY2VydGlmaWNhdGVfZXhwaXJlZCIsImNlcnRpZmljYXRlX3Vua25vd24iLCJ1bmtub3duX2NhIiwidmVyaWZ5Q2VydGlmaWNhdGVDaGFpbiIsImNoYWluIiwic2VsZlNpZ25lZCIsInBhcmVudHMiLCJ2ZXJpZmllZCIsInNlIiwia2V5VXNhZ2UiLCJiYXNpY0NvbnN0cmFpbnRzIiwiYmNFeHQiLCJrZXlVc2FnZUV4dCIsInBhdGhMZW4iLCJ2ZmQiLCJyZXQiLCJzYWx0XyIsInNMZW4iLCJwc3NvYmoiLCJtb2RCaXRzIiwiZW1CaXRzIiwiZW1MZW4iLCJtSGFzaCIsIm1fIiwicHMiLCJkYiIsIm1hc2tMZW4iLCJkYk1hc2siLCJtYXNrZWREQiIsIm1hc2siLCJjaGVja0xlbiIsImhfIiwicGVtVG9EZXIiLCJwcml2YXRlS2V5RnJvbVBlbSIsInByaXZhdGVLZXlJbmZvVG9QZW0iLCJfcmV2ZXJzZUFscGhhYmV0cyIsImFscGhhYmV0IiwiVHlwZUVycm9yIiwiX2VuY29kZVdpdGhCeXRlQnVmZmVyIiwiYmFzZSIsImRpZ2l0cyIsInRhYmxlIiwiZnJvbSIsImg1IiwiaDYiLCJoNyIsIl9rIiwiczAiLCJjaCIsIm1haiIsInBsdWdpbiIsInRpbWUiLCJyZXNlZWRzIiwiZ2VuZXJhdGVkIiwia2V5Qnl0ZXMiLCJwb29scyIsInBvb2wiLCJnZW5lcmF0ZVN5bmMiLCJfcmVzZWVkIiwiX3Jlc2VlZFN5bmMiLCJfc2VlZCIsIm5lZWRlZCIsInNlZWRGaWxlIiwic2VlZEZpbGVTeW5jIiwiXzJwb3dLIiwic2VlZEJ5dGVzIiwiZGVmYXVsdFNlZWRGaWxlIiwiZW50cm9weSIsIlVpbnQzMkFycmF5IiwiUXVvdGFFeGNlZWRlZEVycm9yIiwiaGkiLCJsbyIsInJhbmRvbUJ5dGVzIiwicmVnaXN0ZXJXb3JrZXIiLCJsaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwaVRhYmxlIiwicm9sIiwid29yZCIsInJvciIsImV4cGFuZEtleSIsImVmZktleUJpdHMiLCJMIiwiVCIsIlQxIiwiVDgiLCJUTSIsIl9vdXRwdXQiLCJtaXhSb3VuZCIsIm1hc2hSb3VuZCIsIksiLCJSIiwicnVuUGxhbiIsInBsYW4iLCJwdHIiLCJsYWJlbCIsIm1nZjFNZCIsIm1nZjEiLCJrZXlMZW5ndGgiLCJtYXhMZW5ndGgiLCJsSGFzaCIsIlBTIiwiUFNfbGVuZ3RoIiwic2VlZExlbmd0aCIsInJzYV9tZ2YxIiwic2VlZE1hc2siLCJtYXNrZWRTZWVkIiwiZXhwZWN0ZWRMZW5ndGgiLCJsSGFzaFByaW1lIiwiaW5fcHMiLCJpbmRleCIsImlzXzAiLCJlcnJvcl9tYXNrIiwibWFza0xlbmd0aCIsInByaW1laW5jRmluZFByaW1lIiwicHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyIsInByaW1laW5jRmluZFByaW1lV2l0aG91dFdvcmtlcnMiLCJnZW5lcmF0ZVJhbmRvbSIsIm1yVGVzdHMiLCJnZXRNaWxsZXJSYWJpblRlc3RzIiwibWlsbGVyUmFiaW5UZXN0cyIsIm1heEJsb2NrVGltZSIsIl9wcmltZWluYyIsInJhbmdlIiwicnVubmluZyIsIndvcmtlck1lc3NhZ2UiLCJmb3VuZCIsInAxMiIsInBrY3MxMiIsImNvbnRlbnRJbmZvVmFsaWRhdG9yIiwicGZ4VmFsaWRhdG9yIiwic2FmZUJhZ1ZhbGlkYXRvciIsImF0dHJpYnV0ZVZhbGlkYXRvciIsImNlcnRCYWdWYWxpZGF0b3IiLCJfZ2V0QmFnc0J5QXR0cmlidXRlIiwic2FmZUNvbnRlbnRzIiwiYXR0ck5hbWUiLCJhdHRyVmFsdWUiLCJiYWdUeXBlIiwic2FmZUJhZ3MiLCJiYWciLCJwa2NzMTJGcm9tQXNuMSIsInBmeCIsImdldEJhZ3MiLCJsb2NhbEtleUlkIiwibG9jYWxLZXlJZEhleCIsImZyaWVuZGx5TmFtZSIsImdldEJhZ3NCeUZyaWVuZGx5TmFtZSIsImdldEJhZ3NCeUxvY2FsS2V5SWQiLCJjb250ZW50VHlwZSIsImNvbnRlbnQiLCJfZGVjb2RlUGtjczdEYXRhIiwibWFjIiwibWFjS2V5Qnl0ZXMiLCJtYWNBbGdvcml0aG0iLCJtYWNTYWx0IiwibWFjSXRlcmF0aW9ucyIsIm1hY0tleSIsIm1hY1ZhbHVlIiwibWFjRGlnZXN0IiwiX2RlY29kZUF1dGhlbnRpY2F0ZWRTYWZlIiwiYXV0aFNhZmUiLCJjb250ZW50SW5mbyIsIl9kZWNyeXB0U2FmZUNvbnRlbnRzIiwiX2RlY29kZVNhZmVDb250ZW50cyIsInBrY3M3IiwiZW5jcnlwdGVkRGF0YVZhbGlkYXRvciIsImVuY0FsZ29yaXRobSIsImVuY1BhcmFtZXRlciIsImVuY3J5cHRlZENvbnRlbnRBc24xIiwicmVzIiwic2FmZUJhZyIsImJhZ0lkIiwiX2RlY29kZUJhZ0F0dHJpYnV0ZXMiLCJiYWdBdHRyaWJ1dGVzIiwidmFsaWRhdG9yIiwiZGVjb2RlciIsImJhZ0FzbjEiLCJiYWdWYWx1ZSIsInBrY3M4U2hyb3VkZWRLZXlCYWciLCJrZXlCYWciLCJjZXJ0QmFnIiwiY2VydElkIiwieDUwOUNlcnRpZmljYXRlIiwiY2VydEFzbjEiLCJkZWNvZGVkQXR0cnMiLCJ0b1BrY3MxMkFzbjEiLCJ1c2VNYWMiLCJnZW5lcmF0ZUxvY2FsS2V5SWQiLCJiYWdBdHRycyIsInBhaXJlZENlcnQiLCJjb250ZW50cyIsImNlcnRTYWZlQmFncyIsImNlcnRCYWdBdHRycyIsImNlcnRTYWZlQmFnIiwiY2VydFNhZmVDb250ZW50cyIsImNlcnRDSSIsInBrQXNuMSIsImtleVNhZmVDb250ZW50cyIsImtleUNJIiwic2FmZSIsIm1hY0RhdGEiLCJwN3YiLCJwa2NzN2FzbjEiLCJlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvciIsImVudmVsb3BlZERhdGFWYWxpZGF0b3IiLCJzaWduZXJWYWxpZGF0b3IiLCJzaWduZWREYXRhVmFsaWRhdG9yIiwicmVjaXBpZW50SW5mb1ZhbGlkYXRvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQVEsb0JBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGtEQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyxtQkFBbUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFtQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG1CQUFPLENBQUMsNkZBQWdDOztBQUV4QyxtQkFBTyxDQUFDLHVFQUFxQixHQUFHLDREQUE0RDtBQUM1RjtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3orQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BCQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsU0FDa0M7QUFDbkMsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw0R0FBNEcsSUFBSTtBQUNoSCxnSEFBZ0gsSUFBSTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhLEVBQUUsS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZLEVBQUUsS0FBSztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVksRUFBRSxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QyxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25kQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsMEVBQW9COztBQUUvQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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eUQsRUFBekQsQ0FBNEQsRUFBNUQsQ0FBK0QsRUFBL0QsQ0FBa0UsRUFBbEUsQ0FBcUUsRUFBckUsQ0FBd0UsR0FBeEUsQ0FBNEUsR0FBNUUsQ0FBZ0YsR0FBaEYsQ0FBb0YsR0FBcEYsQ0FBd0YsR0FBeEYsQ0FBNEYsR0FBNUYsQ0FBZ0csR0FBaEcsQ0FBb0csR0FBcEcsQ0FBd0csR0FBeEcsQ0FBNEcsR0FBNUcsQ0FBZ0gsR0FBaEgsQ0FBb0gsR0FBcEgsQ0FBd0gsR0FBeEgsQ0FBNEgsR0FBNUgsQ0FBZ0ksR0FBaEksQ0FBb0ksR0FBcEksQ0FBd0ksR0FBeEksQ0FBNEksR0FBNUksQ0FBZ0osR0FBaEosQ0FBb0osR0FBcEosQ0FBd0osR0FBeEosQ0FBNEosR0FBNUosQ0FBZ0ssR0FBaEssQ0FBb0ssR0FBcEssQ0FBd0ssR0FBeEssQ0FBNEssR0FBNUssQ0FBZ0wsR0FBaEwsQ0FBb0wsR0FBcEwsQ0FBd0wsR0FBeEwsQ0FBNEwsR0FBNUwsQ0FBZ00sR0FBaE0sQ0FBb00sR0FBcE0sQ0FBd00sR0FBeE0sQ0FBNE0sR0FBNU0sQ0FBZ04sR0FBaE4sQ0FBb04sR0FBcE4sQ0FBd04sR0FBeE4sQ0FBNE4sR0FBNU4sQ0FBZ08sR0FBaE8sQ0FBb08sR0FBcE8sQ0FBd08sR0FBeE8sQ0FBNE8sR0FBNU8sQ0FBZ1AsR0FBaFAsQ0FBb1AsR0FBcFAsQ0FBd1AsR0FBeFAsQ0FBNFAsR0FBNVAsQ0FBZ1EsR0FBaFEsQ0FBb1EsR0FBcFEsQ0FBd1EsR0FBeFEsQ0FBNFEsR0FBNVEsQ0FBZ1IsR0FBaFIsQ0FBb1IsR0FBcFIsQ0FBd1IsR0FBeFIsQ0FBNFIsR0FBNVIsQ0FBZ1MsR0FBaFMsQ0FBb1MsR0FBcFMsQ0FBd1MsR0FBeFMsQ0FBNFMsR0FBNVMsQ0FBZ1QsR0FBaFQsQ0FBb1QsR0FBcFQsQ0FBd1QsR0FBeFQsQ0FBNFQsR0FBNVQsQ0FBZ1UsR0FBaFUsQ0FBb1UsR0FBcFUsQ0FBd1UsR0FBeFUsQ0FBNFUsR0FBNVUsQ0FBZ1YsR0FBaFYsQ0FBb1YsR0FBcFYsQ0FBd1YsR0FBeFYsQ0FBNFYsR0FBNVYsQ0FBZ1csR0FBaFcsQ0FBb1csR0FBcFcsQ0FBaEIsQ0FDQSxHQUFJQyxNQUFLLENBQUcsQ0FBQyxHQUFHLEVBQUosRUFBUUQsU0FBUyxDQUFDQSxTQUFTLENBQUNsckMsTUFBVixDQUFpQixDQUFsQixDQUE3QixDQUVBO0FBQ0EsUUFBU29yQyxrQkFBVCxDQUEyQmo0QixDQUEzQixDQUE4QixDQUM5QixHQUFJNUosRUFBSixDQUFPMkQsQ0FBQyxDQUFHLEtBQUs0TSxHQUFMLEVBQVgsQ0FDQSxHQUFHNU0sQ0FBQyxDQUFDaUcsQ0FBRixFQUFPLENBQVAsRUFBWWpHLENBQUMsQ0FBQzlMLElBQUYsQ0FBTyxDQUFQLEdBQWE4cEMsU0FBUyxDQUFDQSxTQUFTLENBQUNsckMsTUFBVixDQUFpQixDQUFsQixDQUFyQyxDQUEyRCxDQUMxRCxJQUFJdUosQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHMmhDLFNBQVMsQ0FBQ2xyQyxNQUF6QixDQUFpQyxFQUFFdUosQ0FBbkMsRUFDRSxHQUFHMkQsQ0FBQyxDQUFDOUwsSUFBRixDQUFPLENBQVAsR0FBYThwQyxTQUFTLENBQUMzaEMsQ0FBRCxDQUF6QixDQUE4QixNQUFPLEtBQVAsQ0FEaEMsQ0FFQSxNQUFPLE1BQVAsQ0FDQSxDQUNELEdBQUcyRCxDQUFDLENBQUM0NEIsTUFBRixFQUFILENBQWUsTUFBTyxNQUFQLENBQ2Z2OEIsQ0FBQyxDQUFHLENBQUosQ0FDQSxNQUFNQSxDQUFDLENBQUcyaEMsU0FBUyxDQUFDbHJDLE1BQXBCLENBQTRCLENBQzNCLEdBQUkwSixFQUFDLENBQUd3aEMsU0FBUyxDQUFDM2hDLENBQUQsQ0FBakIsQ0FBc0J3TCxDQUFDLENBQUd4TCxDQUFDLENBQUMsQ0FBNUIsQ0FDQSxNQUFNd0wsQ0FBQyxDQUFHbTJCLFNBQVMsQ0FBQ2xyQyxNQUFkLEVBQXdCMEosQ0FBQyxDQUFHeWhDLEtBQWxDLEVBQXlDemhDLENBQUMsRUFBSXdoQyxTQUFTLENBQUNuMkIsQ0FBQyxFQUFGLENBQWQsQ0FBekMsQ0FDQXJMLENBQUMsQ0FBR3dELENBQUMsQ0FBQ20rQixNQUFGLENBQVMzaEMsQ0FBVCxDQUFKLENBQ0EsTUFBTUgsQ0FBQyxDQUFHd0wsQ0FBVixFQUFhLEdBQUdyTCxDQUFDLENBQUN3aEMsU0FBUyxDQUFDM2hDLENBQUMsRUFBRixDQUFYLEVBQW9CLENBQXZCLENBQTBCLE1BQU8sTUFBUCxDQUF2QyxDQUNBLENBQ0QsTUFBTzJELEVBQUMsQ0FBQ28rQixXQUFGLENBQWNuNEIsQ0FBZCxDQUFQLENBQ0MsQ0FFRDtBQUNBLFFBQVNvNEIsZUFBVCxDQUF3QnA0QixDQUF4QixDQUEyQixDQUMzQixHQUFJcTRCLEdBQUUsQ0FBRyxLQUFLL2pCLFFBQUwsQ0FBY2xCLFVBQVUsQ0FBQ21CLEdBQXpCLENBQVQsQ0FDQSxHQUFJdmlCLEVBQUMsQ0FBR3FtQyxFQUFFLENBQUNWLGVBQUgsRUFBUixDQUNBLEdBQUczbEMsQ0FBQyxFQUFJLENBQVIsQ0FBVyxNQUFPLE1BQVAsQ0FDWCxHQUFJMmlCLEVBQUMsQ0FBRzBqQixFQUFFLENBQUNDLFVBQUgsQ0FBY3RtQyxDQUFkLENBQVIsQ0FDQSxHQUFJb2dCLEtBQUksQ0FBR21tQixTQUFTLEVBQXBCLENBQ0EsR0FBSWxaLEVBQUosQ0FDQSxJQUFJLEdBQUlqcEIsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHNEosQ0FBbkIsQ0FBc0IsRUFBRTVKLENBQXhCLENBQTJCLENBQzFCO0FBQ0EsRUFBRyxDQUNEaXBCLENBQUMsQ0FBRyxHQUFJak0sV0FBSixDQUFlLEtBQUt3QixTQUFMLEVBQWYsQ0FBaUN4QyxJQUFqQyxDQUFKLENBQ0QsQ0FGRCxNQUdNaU4sQ0FBQyxDQUFDeEssU0FBRixDQUFZekIsVUFBVSxDQUFDbUIsR0FBdkIsR0FBK0IsQ0FBL0IsRUFBb0M4SyxDQUFDLENBQUN4SyxTQUFGLENBQVl3akIsRUFBWixHQUFtQixDQUg3RCxFQUlBLEdBQUlsakIsRUFBQyxDQUFHa0ssQ0FBQyxDQUFDbEwsTUFBRixDQUFTUSxDQUFULENBQVcsSUFBWCxDQUFSLENBQ0EsR0FBR1EsQ0FBQyxDQUFDTixTQUFGLENBQVl6QixVQUFVLENBQUNtQixHQUF2QixHQUErQixDQUEvQixFQUFvQ1ksQ0FBQyxDQUFDTixTQUFGLENBQVl3akIsRUFBWixHQUFtQixDQUExRCxDQUE2RCxDQUMzRCxHQUFJejJCLEVBQUMsQ0FBRyxDQUFSLENBQ0EsTUFBTUEsQ0FBQyxHQUFLNVAsQ0FBTixFQUFXbWpCLENBQUMsQ0FBQ04sU0FBRixDQUFZd2pCLEVBQVosR0FBbUIsQ0FBcEMsQ0FBdUMsQ0FDckNsakIsQ0FBQyxDQUFHQSxDQUFDLENBQUMwZCxTQUFGLENBQVksQ0FBWixDQUFjLElBQWQsQ0FBSixDQUNBLEdBQUcxZCxDQUFDLENBQUNOLFNBQUYsQ0FBWXpCLFVBQVUsQ0FBQ21CLEdBQXZCLEdBQStCLENBQWxDLENBQXFDLE1BQU8sTUFBUCxDQUN0QyxDQUNELEdBQUdZLENBQUMsQ0FBQ04sU0FBRixDQUFZd2pCLEVBQVosR0FBbUIsQ0FBdEIsQ0FBeUIsTUFBTyxNQUFQLENBQzFCLENBQ0QsQ0FDRCxNQUFPLEtBQVAsQ0FDQyxDQUVEO0FBQ0EsUUFBU0UsVUFBVCxFQUFxQixDQUNuQjtBQUNBLE1BQU8sQ0FDTDtBQUNBdGlCLFNBQVMsQ0FBRSxtQkFBU2xjLENBQVQsQ0FBWSxDQUNyQixJQUFJLEdBQUkzRCxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcyRCxDQUFDLENBQUNsTixNQUFyQixDQUE2QixFQUFFdUosQ0FBL0IsQ0FBa0MsQ0FDaEMyRCxDQUFDLENBQUMzRCxDQUFELENBQUQsQ0FBT2pFLElBQUksQ0FBQzJXLEtBQUwsQ0FBVzNXLElBQUksQ0FBQ0MsTUFBTCxHQUFnQixNQUEzQixDQUFQLENBQ0QsQ0FDRixDQU5JLENBQVAsQ0FRRCxDQUVEO0FBQ0FnaEIsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQm84QixTQUFyQixDQUFpQ1AsWUFBakMsQ0FDQTlmLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUJvM0IsT0FBckIsQ0FBK0I2RSxVQUEvQixDQUNBbGdCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUIyMkIsU0FBckIsQ0FBaUMyRixZQUFqQyxDQUNBdmdCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUJpMUIsVUFBckIsQ0FBa0N1SCxhQUFsQyxDQUNBemdCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUI0ZixTQUFyQixDQUFpQ2lkLFlBQWpDLENBQ0E5Z0IsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQmkrQixTQUFyQixDQUFpQ0YsWUFBakMsQ0FDQWhpQixVQUFVLENBQUMvYixTQUFYLENBQXFCcytCLEtBQXJCLENBQTZCRixRQUE3QixDQUNBcmlCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUJ1OEIsU0FBckIsQ0FBaUNxQyxZQUFqQyxDQUNBN2lCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUI4ZixVQUFyQixDQUFrQytlLGFBQWxDLENBQ0E5aUIsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQjYvQixlQUFyQixDQUF1Q1Ysa0JBQXZDLENBQ0FwakIsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQjQvQixlQUFyQixDQUF1Q1Isa0JBQXZDLENBQ0FyakIsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQjZnQyxNQUFyQixDQUE4Qk4sU0FBOUIsQ0FDQXhrQixVQUFVLENBQUMvYixTQUFYLENBQXFCOGdDLFdBQXJCLENBQW1DQyxjQUFuQyxDQUVBO0FBQ0FobEIsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQnFnQyxLQUFyQixDQUE2QjVFLE9BQTdCLENBQ0ExZixVQUFVLENBQUMvYixTQUFYLENBQXFCcThCLFFBQXJCLENBQWdDWCxVQUFoQyxDQUNBM2YsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQitmLFNBQXJCLENBQWlDNGIsV0FBakMsQ0FDQTVmLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUJtaEMsVUFBckIsQ0FBa0N2RixZQUFsQyxDQUNBN2YsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQms4QixNQUFyQixDQUE4QkYsUUFBOUIsQ0FDQWpnQixVQUFVLENBQUMvYixTQUFYLENBQXFCb2hDLFdBQXJCLENBQW1DM0UsYUFBbkMsQ0FDQTFnQixVQUFVLENBQUMvYixTQUFYLENBQXFCdVUsTUFBckIsQ0FBOEJtb0IsUUFBOUIsQ0FDQTNnQixVQUFVLENBQUMvYixTQUFYLENBQXFCNkYsR0FBckIsQ0FBMkI4MkIsS0FBM0IsQ0FDQTVnQixVQUFVLENBQUMvYixTQUFYLENBQXFCMkYsR0FBckIsQ0FBMkJpM0IsS0FBM0IsQ0FDQTdnQixVQUFVLENBQUMvYixTQUFYLENBQXFCcWhDLEdBQXJCLENBQTJCcEUsS0FBM0IsQ0FDQWxoQixVQUFVLENBQUMvYixTQUFYLENBQXFCc2hDLEVBQXJCLENBQTBCcEUsSUFBMUIsQ0FDQW5oQixVQUFVLENBQUMvYixTQUFYLENBQXFCbTBCLEdBQXJCLENBQTJCaUosS0FBM0IsQ0FDQXJoQixVQUFVLENBQUMvYixTQUFYLENBQXFCdWhDLE1BQXJCLENBQThCakUsUUFBOUIsQ0FDQXZoQixVQUFVLENBQUMvYixTQUFYLENBQXFCd2hDLEdBQXJCLENBQTJCakUsS0FBM0IsQ0FDQXhoQixVQUFVLENBQUMvYixTQUFYLENBQXFCNmYsU0FBckIsQ0FBaUMyZCxXQUFqQyxDQUNBemhCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUJpaEMsVUFBckIsQ0FBa0N4RCxZQUFsQyxDQUNBMWhCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUJzZ0MsZUFBckIsQ0FBdUMzQyxpQkFBdkMsQ0FDQTVoQixVQUFVLENBQUMvYixTQUFYLENBQXFCeWhDLFFBQXJCLENBQWdDNUQsVUFBaEMsQ0FDQTloQixVQUFVLENBQUMvYixTQUFYLENBQXFCMmYsT0FBckIsQ0FBK0JtZSxTQUEvQixDQUNBL2hCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUIwaEMsTUFBckIsQ0FBOEIxRCxRQUE5QixDQUNBamlCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUIyaEMsUUFBckIsQ0FBZ0N6RCxVQUFoQyxDQUNBbmlCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUI0aEMsT0FBckIsQ0FBK0J6RCxTQUEvQixDQUNBcGlCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUI2ZCxHQUFyQixDQUEyQndnQixLQUEzQixDQUNBdGlCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUJpZCxRQUFyQixDQUFnQ3NoQixVQUFoQyxDQUNBeGlCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUIwZCxRQUFyQixDQUFnQzhnQixVQUFoQyxDQUNBemlCLFVBQVUsQ0FBQy9iLFNBQVgsQ0FBcUJ3L0IsTUFBckIsQ0FBOEJmLFFBQTlCLENBQ0ExaUIsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQjZoQyxTQUFyQixDQUFpQ25ELFdBQWpDLENBQ0EzaUIsVUFBVSxDQUFDL2IsU0FBWCxDQUFxQjhoQyxrQkFBckIsQ0FBMENuRCxvQkFBMUMsQ0FDQTVpQixVQUFVLENBQUMvYixTQUFYLENBQXFCOGMsTUFBckIsQ0FBOEJrakIsUUFBOUIsQ0FDQWprQixVQUFVLENBQUMvYixTQUFYLENBQXFCcWQsVUFBckIsQ0FBa0NtakIsWUFBbEMsQ0FDQXprQixVQUFVLENBQUMvYixTQUFYLENBQXFCOHdCLEdBQXJCLENBQTJCb08sS0FBM0IsQ0FDQW5qQixVQUFVLENBQUMvYixTQUFYLENBQXFCeWQsR0FBckIsQ0FBMkIyaUIsS0FBM0IsQ0FDQXJrQixVQUFVLENBQUMvYixTQUFYLENBQXFCZ2dCLGVBQXJCLENBQXVDNGdCLGlCQUF2QyxDQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0EsS0FBTyxDQXBqWUcsQ0FxallWLFFBcmpZVSxDQXNqWVYsS0FBTyxTQUFTcGlDLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7OztHQU9BLEdBQUkvQixNQUFLLENBQUcrQixtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUVBLEdBQUlxdEIsS0FBSSxDQUFHMXRCLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQnpCLEtBQUssQ0FBQ292QixJQUFOLENBQWFwdkIsS0FBSyxDQUFDb3ZCLElBQU4sRUFBYyxFQUF2RCxDQUNBcHZCLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU21TLElBQVQsQ0FBZ0JwdkIsS0FBSyxDQUFDaWQsRUFBTixDQUFTQyxVQUFULENBQW9Ca1MsSUFBcEIsQ0FBMkJBLElBQTNDLENBRUE7Ozs7R0FLQUEsSUFBSSxDQUFDcHdCLE1BQUwsQ0FBYyxVQUFXLENBQ3ZCO0FBQ0EsR0FBRyxDQUFDaW1DLFlBQUosQ0FBa0IsQ0FDaEJwYyxLQUFLLEdBQ04sQ0FFRDtBQUNBLEdBQUlxYyxPQUFNLENBQUcsSUFBYixDQUVBO0FBQ0EsR0FBSTdULE9BQU0sQ0FBR3J4QixLQUFLLENBQUN3RCxJQUFOLENBQVc0RixZQUFYLEVBQWIsQ0FFQTtBQUNBLEdBQUl3ZixHQUFFLENBQUcsR0FBSS92QixNQUFKLENBQVUsRUFBVixDQUFULENBRUE7QUFDQSxHQUFJb2tCLEdBQUUsQ0FBRyxDQUNQd0MsU0FBUyxDQUFFLE1BREosQ0FFUDhQLFdBQVcsQ0FBRSxFQUZOLENBR1BELFlBQVksQ0FBRSxFQUhQLENBSVA7QUFDQTZWLGFBQWEsQ0FBRSxDQUxSLENBTVA7QUFDQUMsaUJBQWlCLENBQUUsSUFQWixDQVFQO0FBQ0FDLGlCQUFpQixDQUFFLENBVFosQ0FBVCxDQVlBOzs7O0tBS0Fwb0IsRUFBRSxDQUFDclAsS0FBSCxDQUFXLFVBQVcsQ0FDcEI7QUFDQXFQLEVBQUUsQ0FBQ2tvQixhQUFILENBQW1CLENBQW5CLENBRUE7QUFDQWxvQixFQUFFLENBQUNtb0IsaUJBQUgsQ0FBdUJub0IsRUFBRSxDQUFDcW9CLGVBQUgsQ0FBcUIsRUFBNUMsQ0FDQSxHQUFJQyxPQUFNLENBQUd0b0IsRUFBRSxDQUFDb29CLGlCQUFILENBQXVCLENBQXBDLENBQ0EsSUFBSSxHQUFJcGpDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3NqQyxNQUFuQixDQUEyQixFQUFFdGpDLENBQTdCLENBQWdDLENBQzlCZ2IsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCemdDLElBQXJCLENBQTBCLENBQTFCLEVBQ0QsQ0FDRDBzQixNQUFNLENBQUdyeEIsS0FBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBWCxFQUFULENBQ0E4N0IsTUFBTSxDQUFHLENBQ1BNLEVBQUUsQ0FBRSxVQURHLENBRVBDLEVBQUUsQ0FBRSxVQUZHLENBR1BDLEVBQUUsQ0FBRSxVQUhHLENBSVBDLEVBQUUsQ0FBRSxVQUpHLENBS1BDLEVBQUUsQ0FBRSxVQUxHLENBQVQsQ0FPQSxNQUFPM29CLEdBQVAsQ0FDRCxDQW5CRCxDQW9CQTtBQUNBQSxFQUFFLENBQUNyUCxLQUFILEdBRUE7Ozs7Ozs7OztLQVVBcVAsRUFBRSxDQUFDckosTUFBSCxDQUFZLFNBQVN2UCxHQUFULENBQWNrRyxRQUFkLENBQXdCLENBQ2xDLEdBQUdBLFFBQVEsR0FBSyxNQUFoQixDQUF3QixDQUN0QmxHLEdBQUcsQ0FBR3JFLEtBQUssQ0FBQ3dELElBQU4sQ0FBVytELFVBQVgsQ0FBc0JsRCxHQUF0QixDQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlrRixJQUFHLENBQUdsRixHQUFHLENBQUMzTCxNQUFkLENBQ0F1a0IsRUFBRSxDQUFDa29CLGFBQUgsRUFBb0I1N0IsR0FBcEIsQ0FDQUEsR0FBRyxDQUFHLENBQUVBLEdBQUcsQ0FBRyxXQUFQLEdBQXdCLENBQXpCLENBQTRCQSxHQUFHLEdBQUssQ0FBcEMsQ0FBTixDQUNBLElBQUksR0FBSXRILEVBQUMsQ0FBR2diLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQjFzQyxNQUFyQixDQUE4QixDQUExQyxDQUE2Q3VKLENBQUMsRUFBSSxDQUFsRCxDQUFxRCxFQUFFQSxDQUF2RCxDQUEwRCxDQUN4RGdiLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQm5qQyxDQUFyQixHQUEyQnNILEdBQUcsQ0FBQyxDQUFELENBQTlCLENBQ0FBLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBU0EsR0FBRyxDQUFDLENBQUQsQ0FBSCxFQUFXMFQsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCbmpDLENBQXJCLEVBQTBCLFdBQTNCLEdBQTRDLENBQXRELENBQVQsQ0FDQWdiLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQm5qQyxDQUFyQixFQUEwQmdiLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQm5qQyxDQUFyQixJQUE0QixDQUF0RCxDQUNBc0gsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFXQSxHQUFHLENBQUMsQ0FBRCxDQUFILENBQVMsV0FBVixHQUEyQixDQUFyQyxDQUNELENBRUQ7QUFDQThuQixNQUFNLENBQUNucUIsUUFBUCxDQUFnQjdDLEdBQWhCLEVBRUE7QUFDQXdoQyxPQUFPLENBQUNYLE1BQUQsQ0FBU3RjLEVBQVQsQ0FBYXlJLE1BQWIsQ0FBUCxDQUVBO0FBQ0EsR0FBR0EsTUFBTSxDQUFDL3FCLElBQVAsQ0FBYyxJQUFkLEVBQXNCK3FCLE1BQU0sQ0FBQzM0QixNQUFQLEtBQW9CLENBQTdDLENBQWdELENBQzlDMjRCLE1BQU0sQ0FBQ2hvQixPQUFQLEdBQ0QsQ0FFRCxNQUFPNFQsR0FBUCxDQUNELENBNUJELENBOEJDOzs7O01BS0FBLEVBQUUsQ0FBQzRDLE1BQUgsQ0FBWSxVQUFXLENBQ3RCOzs7MkNBRHNCLENBTXRCOzs7Ozs7Ozs7Ozs7O3FFQWVBLEdBQUlpbUIsV0FBVSxDQUFHOWxDLEtBQUssQ0FBQ3dELElBQU4sQ0FBVzRGLFlBQVgsRUFBakIsQ0FDQTA4QixVQUFVLENBQUM1K0IsUUFBWCxDQUFvQm1xQixNQUFNLENBQUNqcUIsS0FBUCxFQUFwQixFQUVBO0FBQ0EsR0FBSThRLFVBQVMsQ0FDWCtFLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQm5vQixFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUIxc0MsTUFBckIsQ0FBOEIsQ0FBbkQsRUFDQXVrQixFQUFFLENBQUNvb0IsaUJBRkwsQ0FJQTtBQUNBO0FBQ0E7QUFDQSxHQUFJM1QsU0FBUSxDQUFHeFosU0FBUyxDQUFJK0UsRUFBRSxDQUFDc1MsV0FBSCxDQUFpQixDQUE3QyxDQUNBdVcsVUFBVSxDQUFDNStCLFFBQVgsQ0FBb0I2K0IsUUFBUSxDQUFDN25DLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBbUIrZSxFQUFFLENBQUNzUyxXQUFILENBQWlCbUMsUUFBcEMsQ0FBcEIsRUFFQTtBQUNBO0FBQ0EsR0FBSWpnQixLQUFKLENBQVV1MEIsS0FBVixDQUNBLEdBQUlwa0IsS0FBSSxDQUFHM0UsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCLENBQXJCLEVBQTBCLENBQXJDLENBQ0EsSUFBSSxHQUFJbmpDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR2diLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQjFzQyxNQUFyQixDQUE4QixDQUFqRCxDQUFvRCxFQUFFdUosQ0FBdEQsQ0FBeUQsQ0FDdkR3UCxJQUFJLENBQUd3TCxFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJuakMsQ0FBQyxDQUFHLENBQXpCLEVBQThCLENBQXJDLENBQ0ErakMsS0FBSyxDQUFJdjBCLElBQUksQ0FBRyxXQUFSLEdBQXlCLENBQWpDLENBQ0FtUSxJQUFJLEVBQUlva0IsS0FBUixDQUNBRixVQUFVLENBQUNwK0IsUUFBWCxDQUFvQmthLElBQUksR0FBSyxDQUE3QixFQUNBQSxJQUFJLENBQUduUSxJQUFJLEdBQUssQ0FBaEIsQ0FDRCxDQUNEcTBCLFVBQVUsQ0FBQ3ArQixRQUFYLENBQW9Ca2EsSUFBcEIsRUFFQSxHQUFJalcsR0FBRSxDQUFHLENBQ1A2NUIsRUFBRSxDQUFFTixNQUFNLENBQUNNLEVBREosQ0FFUEMsRUFBRSxDQUFFUCxNQUFNLENBQUNPLEVBRkosQ0FHUEMsRUFBRSxDQUFFUixNQUFNLENBQUNRLEVBSEosQ0FJUEMsRUFBRSxDQUFFVCxNQUFNLENBQUNTLEVBSkosQ0FLUEMsRUFBRSxDQUFFVixNQUFNLENBQUNVLEVBTEosQ0FBVCxDQU9BQyxPQUFPLENBQUNsNkIsRUFBRCxDQUFLaWQsRUFBTCxDQUFTa2QsVUFBVCxDQUFQLENBQ0EsR0FBSXo5QixLQUFJLENBQUdySSxLQUFLLENBQUN3RCxJQUFOLENBQVc0RixZQUFYLEVBQVgsQ0FDQWYsSUFBSSxDQUFDWCxRQUFMLENBQWNpRSxFQUFFLENBQUM2NUIsRUFBakIsRUFDQW45QixJQUFJLENBQUNYLFFBQUwsQ0FBY2lFLEVBQUUsQ0FBQzg1QixFQUFqQixFQUNBcDlCLElBQUksQ0FBQ1gsUUFBTCxDQUFjaUUsRUFBRSxDQUFDKzVCLEVBQWpCLEVBQ0FyOUIsSUFBSSxDQUFDWCxRQUFMLENBQWNpRSxFQUFFLENBQUNnNkIsRUFBakIsRUFDQXQ5QixJQUFJLENBQUNYLFFBQUwsQ0FBY2lFLEVBQUUsQ0FBQ2k2QixFQUFqQixFQUNBLE1BQU92OUIsS0FBUCxDQUNELENBL0RBLENBaUVELE1BQU80VSxHQUFQLENBQ0QsQ0F2S0QsQ0F5S0E7QUFDQSxHQUFJOG9CLFNBQVEsQ0FBRyxJQUFmLENBQ0EsR0FBSWQsYUFBWSxDQUFHLEtBQW5CLENBRUE7O0dBR0EsUUFBU3BjLE1BQVQsRUFBaUIsQ0FDZjtBQUNBa2QsUUFBUSxDQUFHci9CLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQixHQUFwQixDQUFYLENBQ0FvL0IsUUFBUSxFQUFJL2xDLEtBQUssQ0FBQ3dELElBQU4sQ0FBV2dJLFVBQVgsQ0FBc0I5RSxNQUFNLENBQUNDLFlBQVAsQ0FBb0IsSUFBcEIsQ0FBdEIsQ0FBaUQsRUFBakQsQ0FBWixDQUVBO0FBQ0FzK0IsWUFBWSxDQUFHLElBQWYsQ0FDRCxDQUVEOzs7Ozs7R0FPQSxRQUFTWSxRQUFULENBQWlCeGlDLENBQWpCLENBQW9CaW5CLENBQXBCLENBQXVCbGpCLEtBQXZCLENBQThCLENBQzVCO0FBQ0EsR0FBSXlFLEVBQUosQ0FBT3FmLENBQVAsQ0FBVTdrQixDQUFWLENBQWFoRSxDQUFiLENBQWdCQyxDQUFoQixDQUFtQnNFLENBQW5CLENBQXNCcTVCLENBQXRCLENBQXlCaCtCLENBQXpCLENBQ0EsR0FBSXNILElBQUcsQ0FBR25DLEtBQUssQ0FBQzFPLE1BQU4sRUFBVixDQUNBLE1BQU02USxHQUFHLEVBQUksRUFBYixDQUFpQixDQUNmO0FBQ0E7QUFDQTtBQUVBO0FBQ0EyaEIsQ0FBQyxDQUFHN25CLENBQUMsQ0FBQ21pQyxFQUFOLENBQ0FuL0IsQ0FBQyxDQUFHaEQsQ0FBQyxDQUFDb2lDLEVBQU4sQ0FDQXBqQyxDQUFDLENBQUdnQixDQUFDLENBQUNxaUMsRUFBTixDQUNBcGpDLENBQUMsQ0FBR2UsQ0FBQyxDQUFDc2lDLEVBQU4sQ0FDQS8rQixDQUFDLENBQUd2RCxDQUFDLENBQUN1aUMsRUFBTixDQUVBO0FBQ0EsSUFBSTNqQyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUcsRUFBZixDQUFtQixFQUFFQSxDQUFyQixDQUF3QixDQUN0QjRKLENBQUMsQ0FBR3pFLEtBQUssQ0FBQ21CLFFBQU4sRUFBSixDQUNBK2hCLENBQUMsQ0FBQ3JvQixDQUFELENBQUQsQ0FBTzRKLENBQVAsQ0FDQW8wQixDQUFDLENBQUczOUIsQ0FBQyxDQUFJK0QsQ0FBQyxFQUFJaEUsQ0FBQyxDQUFHQyxDQUFSLENBQVYsQ0FDQXVKLENBQUMsQ0FBRyxDQUFFcWYsQ0FBQyxFQUFJLENBQU4sQ0FBWUEsQ0FBQyxHQUFLLEVBQW5CLEVBQTBCK1UsQ0FBMUIsQ0FBOEJyNUIsQ0FBOUIsQ0FBa0MsVUFBbEMsQ0FBK0NpRixDQUFuRCxDQUNBakYsQ0FBQyxDQUFHdEUsQ0FBSixDQUNBQSxDQUFDLENBQUdELENBQUosQ0FDQTtBQUNBQSxDQUFDLENBQUcsQ0FBRWdFLENBQUMsRUFBSSxFQUFOLENBQWFBLENBQUMsR0FBSyxDQUFwQixJQUE0QixDQUFoQyxDQUNBQSxDQUFDLENBQUc2a0IsQ0FBSixDQUNBQSxDQUFDLENBQUdyZixDQUFKLENBQ0QsQ0FDRCxLQUFNNUosQ0FBQyxDQUFHLEVBQVYsQ0FBYyxFQUFFQSxDQUFoQixDQUFtQixDQUNqQjRKLENBQUMsQ0FBSXllLENBQUMsQ0FBQ3JvQixDQUFDLENBQUcsQ0FBTCxDQUFELENBQVdxb0IsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxDQUFMLENBQVosQ0FBc0Jxb0IsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxFQUFMLENBQXZCLENBQWtDcW9CLENBQUMsQ0FBQ3JvQixDQUFDLENBQUcsRUFBTCxDQUF4QyxDQUNBNEosQ0FBQyxDQUFJQSxDQUFDLEVBQUksQ0FBTixDQUFZQSxDQUFDLEdBQUssRUFBdEIsQ0FDQXllLENBQUMsQ0FBQ3JvQixDQUFELENBQUQsQ0FBTzRKLENBQVAsQ0FDQW8wQixDQUFDLENBQUczOUIsQ0FBQyxDQUFJK0QsQ0FBQyxFQUFJaEUsQ0FBQyxDQUFHQyxDQUFSLENBQVYsQ0FDQXVKLENBQUMsQ0FBRyxDQUFFcWYsQ0FBQyxFQUFJLENBQU4sQ0FBWUEsQ0FBQyxHQUFLLEVBQW5CLEVBQTBCK1UsQ0FBMUIsQ0FBOEJyNUIsQ0FBOUIsQ0FBa0MsVUFBbEMsQ0FBK0NpRixDQUFuRCxDQUNBakYsQ0FBQyxDQUFHdEUsQ0FBSixDQUNBQSxDQUFDLENBQUdELENBQUosQ0FDQTtBQUNBQSxDQUFDLENBQUcsQ0FBRWdFLENBQUMsRUFBSSxFQUFOLENBQWFBLENBQUMsR0FBSyxDQUFwQixJQUE0QixDQUFoQyxDQUNBQSxDQUFDLENBQUc2a0IsQ0FBSixDQUNBQSxDQUFDLENBQUdyZixDQUFKLENBQ0QsQ0FDRDtBQUNBLEtBQU01SixDQUFDLENBQUcsRUFBVixDQUFjLEVBQUVBLENBQWhCLENBQW1CLENBQ2pCNEosQ0FBQyxDQUFJeWUsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxDQUFMLENBQUQsQ0FBV3FvQixDQUFDLENBQUNyb0IsQ0FBQyxDQUFHLENBQUwsQ0FBWixDQUFzQnFvQixDQUFDLENBQUNyb0IsQ0FBQyxDQUFHLEVBQUwsQ0FBdkIsQ0FBa0Nxb0IsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxFQUFMLENBQXhDLENBQ0E0SixDQUFDLENBQUlBLENBQUMsRUFBSSxDQUFOLENBQVlBLENBQUMsR0FBSyxFQUF0QixDQUNBeWUsQ0FBQyxDQUFDcm9CLENBQUQsQ0FBRCxDQUFPNEosQ0FBUCxDQUNBbzBCLENBQUMsQ0FBRzU1QixDQUFDLENBQUdoRSxDQUFKLENBQVFDLENBQVosQ0FDQXVKLENBQUMsQ0FBRyxDQUFFcWYsQ0FBQyxFQUFJLENBQU4sQ0FBWUEsQ0FBQyxHQUFLLEVBQW5CLEVBQTBCK1UsQ0FBMUIsQ0FBOEJyNUIsQ0FBOUIsQ0FBa0MsVUFBbEMsQ0FBK0NpRixDQUFuRCxDQUNBakYsQ0FBQyxDQUFHdEUsQ0FBSixDQUNBQSxDQUFDLENBQUdELENBQUosQ0FDQTtBQUNBQSxDQUFDLENBQUcsQ0FBRWdFLENBQUMsRUFBSSxFQUFOLENBQWFBLENBQUMsR0FBSyxDQUFwQixJQUE0QixDQUFoQyxDQUNBQSxDQUFDLENBQUc2a0IsQ0FBSixDQUNBQSxDQUFDLENBQUdyZixDQUFKLENBQ0QsQ0FDRCxLQUFNNUosQ0FBQyxDQUFHLEVBQVYsQ0FBYyxFQUFFQSxDQUFoQixDQUFtQixDQUNqQjRKLENBQUMsQ0FBSXllLENBQUMsQ0FBQ3JvQixDQUFDLENBQUcsQ0FBTCxDQUFELENBQVdxb0IsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxFQUFMLENBQVosQ0FBdUJxb0IsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxFQUFMLENBQXhCLENBQW1DcW9CLENBQUMsQ0FBQ3JvQixDQUFDLENBQUcsRUFBTCxDQUF6QyxDQUNBNEosQ0FBQyxDQUFJQSxDQUFDLEVBQUksQ0FBTixDQUFZQSxDQUFDLEdBQUssRUFBdEIsQ0FDQXllLENBQUMsQ0FBQ3JvQixDQUFELENBQUQsQ0FBTzRKLENBQVAsQ0FDQW8wQixDQUFDLENBQUc1NUIsQ0FBQyxDQUFHaEUsQ0FBSixDQUFRQyxDQUFaLENBQ0F1SixDQUFDLENBQUcsQ0FBRXFmLENBQUMsRUFBSSxDQUFOLENBQVlBLENBQUMsR0FBSyxFQUFuQixFQUEwQitVLENBQTFCLENBQThCcjVCLENBQTlCLENBQWtDLFVBQWxDLENBQStDaUYsQ0FBbkQsQ0FDQWpGLENBQUMsQ0FBR3RFLENBQUosQ0FDQUEsQ0FBQyxDQUFHRCxDQUFKLENBQ0E7QUFDQUEsQ0FBQyxDQUFHLENBQUVnRSxDQUFDLEVBQUksRUFBTixDQUFhQSxDQUFDLEdBQUssQ0FBcEIsSUFBNEIsQ0FBaEMsQ0FDQUEsQ0FBQyxDQUFHNmtCLENBQUosQ0FDQUEsQ0FBQyxDQUFHcmYsQ0FBSixDQUNELENBQ0Q7QUFDQSxLQUFNNUosQ0FBQyxDQUFHLEVBQVYsQ0FBYyxFQUFFQSxDQUFoQixDQUFtQixDQUNqQjRKLENBQUMsQ0FBSXllLENBQUMsQ0FBQ3JvQixDQUFDLENBQUcsQ0FBTCxDQUFELENBQVdxb0IsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxFQUFMLENBQVosQ0FBdUJxb0IsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxFQUFMLENBQXhCLENBQW1DcW9CLENBQUMsQ0FBQ3JvQixDQUFDLENBQUcsRUFBTCxDQUF6QyxDQUNBNEosQ0FBQyxDQUFJQSxDQUFDLEVBQUksQ0FBTixDQUFZQSxDQUFDLEdBQUssRUFBdEIsQ0FDQXllLENBQUMsQ0FBQ3JvQixDQUFELENBQUQsQ0FBTzRKLENBQVAsQ0FDQW8wQixDQUFDLENBQUk1NUIsQ0FBQyxDQUFHaEUsQ0FBTCxDQUFXQyxDQUFDLEVBQUkrRCxDQUFDLENBQUdoRSxDQUFSLENBQWhCLENBQ0F3SixDQUFDLENBQUcsQ0FBRXFmLENBQUMsRUFBSSxDQUFOLENBQVlBLENBQUMsR0FBSyxFQUFuQixFQUEwQitVLENBQTFCLENBQThCcjVCLENBQTlCLENBQWtDLFVBQWxDLENBQStDaUYsQ0FBbkQsQ0FDQWpGLENBQUMsQ0FBR3RFLENBQUosQ0FDQUEsQ0FBQyxDQUFHRCxDQUFKLENBQ0E7QUFDQUEsQ0FBQyxDQUFHLENBQUVnRSxDQUFDLEVBQUksRUFBTixDQUFhQSxDQUFDLEdBQUssQ0FBcEIsSUFBNEIsQ0FBaEMsQ0FDQUEsQ0FBQyxDQUFHNmtCLENBQUosQ0FDQUEsQ0FBQyxDQUFHcmYsQ0FBSixDQUNELENBQ0Q7QUFDQSxLQUFNNUosQ0FBQyxDQUFHLEVBQVYsQ0FBYyxFQUFFQSxDQUFoQixDQUFtQixDQUNqQjRKLENBQUMsQ0FBSXllLENBQUMsQ0FBQ3JvQixDQUFDLENBQUcsQ0FBTCxDQUFELENBQVdxb0IsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxFQUFMLENBQVosQ0FBdUJxb0IsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxFQUFMLENBQXhCLENBQW1DcW9CLENBQUMsQ0FBQ3JvQixDQUFDLENBQUcsRUFBTCxDQUF6QyxDQUNBNEosQ0FBQyxDQUFJQSxDQUFDLEVBQUksQ0FBTixDQUFZQSxDQUFDLEdBQUssRUFBdEIsQ0FDQXllLENBQUMsQ0FBQ3JvQixDQUFELENBQUQsQ0FBTzRKLENBQVAsQ0FDQW8wQixDQUFDLENBQUc1NUIsQ0FBQyxDQUFHaEUsQ0FBSixDQUFRQyxDQUFaLENBQ0F1SixDQUFDLENBQUcsQ0FBRXFmLENBQUMsRUFBSSxDQUFOLENBQVlBLENBQUMsR0FBSyxFQUFuQixFQUEwQitVLENBQTFCLENBQThCcjVCLENBQTlCLENBQWtDLFVBQWxDLENBQStDaUYsQ0FBbkQsQ0FDQWpGLENBQUMsQ0FBR3RFLENBQUosQ0FDQUEsQ0FBQyxDQUFHRCxDQUFKLENBQ0E7QUFDQUEsQ0FBQyxDQUFHLENBQUVnRSxDQUFDLEVBQUksRUFBTixDQUFhQSxDQUFDLEdBQUssQ0FBcEIsSUFBNEIsQ0FBaEMsQ0FDQUEsQ0FBQyxDQUFHNmtCLENBQUosQ0FDQUEsQ0FBQyxDQUFHcmYsQ0FBSixDQUNELENBRUQ7QUFDQXhJLENBQUMsQ0FBQ21pQyxFQUFGLENBQVFuaUMsQ0FBQyxDQUFDbWlDLEVBQUYsQ0FBT3RhLENBQVIsQ0FBYSxDQUFwQixDQUNBN25CLENBQUMsQ0FBQ29pQyxFQUFGLENBQVFwaUMsQ0FBQyxDQUFDb2lDLEVBQUYsQ0FBT3AvQixDQUFSLENBQWEsQ0FBcEIsQ0FDQWhELENBQUMsQ0FBQ3FpQyxFQUFGLENBQVFyaUMsQ0FBQyxDQUFDcWlDLEVBQUYsQ0FBT3JqQyxDQUFSLENBQWEsQ0FBcEIsQ0FDQWdCLENBQUMsQ0FBQ3NpQyxFQUFGLENBQVF0aUMsQ0FBQyxDQUFDc2lDLEVBQUYsQ0FBT3JqQyxDQUFSLENBQWEsQ0FBcEIsQ0FDQWUsQ0FBQyxDQUFDdWlDLEVBQUYsQ0FBUXZpQyxDQUFDLENBQUN1aUMsRUFBRixDQUFPaC9CLENBQVIsQ0FBYSxDQUFwQixDQUVBMkMsR0FBRyxFQUFJLEVBQVAsQ0FDRCxDQUNGLENBR0QsS0FBTyxDQXozWUcsQ0EwM1lWLFFBMTNZVSxDQTIzWVYsS0FBTyxTQUFTN0gsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkdBLEdBQUkvQixNQUFLLENBQUcrQixtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQTtBQUNBLEdBQUl1VCxLQUFJLENBQUd0VixLQUFLLENBQUNzVixJQUFqQixDQUVBLHFEQUNBLEdBQUk3VSxJQUFHLENBQUdpQixNQUFNLENBQUNELE9BQVAsQ0FBaUJ6QixLQUFLLENBQUNTLEdBQU4sQ0FBWVQsS0FBSyxDQUFDUyxHQUFOLEVBQWEsRUFBcEQsQ0FDQSxHQUFJb2MsS0FBSSxDQUFHcGMsR0FBRyxDQUFDb2MsSUFBZixDQUVBO0FBQ0EsR0FBSW9wQixZQUFXLENBQUcsRUFBbEIsQ0FDQUEsV0FBVyxDQUFDLElBQUQsQ0FBWCxDQUFvQnBwQixJQUFJLENBQUMsWUFBRCxDQUF4QixDQUNBb3BCLFdBQVcsQ0FBQyxZQUFELENBQVgsQ0FBNEIsSUFBNUIsQ0FDQUEsV0FBVyxDQUFDLEdBQUQsQ0FBWCxDQUFtQnBwQixJQUFJLENBQUMsYUFBRCxDQUF2QixDQUNBb3BCLFdBQVcsQ0FBQyxhQUFELENBQVgsQ0FBNkIsR0FBN0IsQ0FDQUEsV0FBVyxDQUFDLEdBQUQsQ0FBWCxDQUFtQnBwQixJQUFJLENBQUMsY0FBRCxDQUF2QixDQUNBb3BCLFdBQVcsQ0FBQyxjQUFELENBQVgsQ0FBOEIsR0FBOUIsQ0FDQUEsV0FBVyxDQUFDLElBQUQsQ0FBWCxDQUFvQnBwQixJQUFJLENBQUMscUJBQUQsQ0FBeEIsQ0FDQW9wQixXQUFXLENBQUMscUJBQUQsQ0FBWCxDQUFxQyxJQUFyQyxDQUNBQSxXQUFXLENBQUMsR0FBRCxDQUFYLENBQW1CcHBCLElBQUksQ0FBQyxrQkFBRCxDQUF2QixDQUNBb3BCLFdBQVcsQ0FBQyxrQkFBRCxDQUFYLENBQWtDLEdBQWxDLENBQ0FBLFdBQVcsQ0FBQyxJQUFELENBQVgsQ0FBb0JwcEIsSUFBSSxDQUFDLHdCQUFELENBQXhCLENBQ0FvcEIsV0FBVyxDQUFDLHdCQUFELENBQVgsQ0FBd0MsSUFBeEMsQ0FDQUEsV0FBVyxDQUFDLEdBQUQsQ0FBWCxDQUFtQnBwQixJQUFJLENBQUMsY0FBRCxDQUF2QixDQUNBb3BCLFdBQVcsQ0FBQyxjQUFELENBQVgsQ0FBOEIsR0FBOUIsQ0FFQTtBQUNBO0FBQ0EsR0FBSTFtQixtQkFBa0IsQ0FBR3ZmLEtBQUssQ0FBQ1MsR0FBTixDQUFVTCxHQUFWLENBQWNtZixrQkFBdkMsQ0FFQTtBQUNBLEdBQUkybUIseUJBQXdCLENBQUcsQ0FDN0IzdUMsSUFBSSxDQUFFLGFBRHVCLENBRTdCMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRlEsQ0FHN0I3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIYSxDQUk3QlEsV0FBVyxDQUFFLElBSmdCLENBSzdCM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSw0QkFEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhWLENBSU5RLFdBQVcsQ0FBRSxJQUpQLENBS04rRSxXQUFXLENBQUUsZ0JBTFAsQ0FNTjFLLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsb0NBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGZixDQUdOL0csSUFBSSxDQUFFLENBSEEsQ0FJTndJLFdBQVcsQ0FBRSxJQUpQLENBS044RSxRQUFRLENBQUUsSUFMSixDQU1OekssS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSw0Q0FEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUhWLENBSU5vQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGFBTEgsQ0FBRCxDQU5ELENBQUQsQ0FhSixDQUNEemtCLElBQUksQ0FBRSx5Q0FETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIZixDQUlEb0IsV0FBVyxDQUFFLEtBSlosQ0FLRDZFLE9BQU8sQ0FBRSxrQkFMUixDQWJJLENBbUJKLENBQ0R6a0IsSUFBSSxDQUFFLHNDQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhmLENBSURRLFdBQVcsQ0FBRSxJQUpaLENBS0QzRixLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLGdEQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsc0JBTEgsQ0FBRCxDQU1KLENBQ0R6a0IsSUFBSSxDQUFFLGlEQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRHlHLFFBQVEsQ0FBRSxJQUhULENBSURDLFdBQVcsQ0FBRSx5QkFKWixDQU5JLENBTE4sQ0FuQkksQ0FvQ0osQ0FDRDNrQixJQUFJLENBQUUsbUNBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGYsQ0FJRFEsV0FBVyxDQUFFLElBSlosQ0FLRCtFLFdBQVcsQ0FBRSxZQUxaLENBcENJLENBMENKLENBQ0Qza0IsSUFBSSxDQUFFLHFDQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhmLENBSURRLFdBQVcsQ0FBRSxJQUpaLENBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTNGLEtBQUssQ0FBRSxDQUFDLENBQ047QUFDQWphLElBQUksQ0FBRSxxREFGQSxDQUdOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSGYsQ0FJTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVbUIsT0FKVixDQUtOSSxXQUFXLENBQUUsS0FMUCxDQU1OOEUsUUFBUSxDQUFFLElBTkosQ0FPTkQsT0FBTyxDQUFFLHNCQVBILENBQUQsQ0FRSixDQUNEO0FBQ0F6a0IsSUFBSSxDQUFFLDZEQUZMLENBR0QyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIcEIsQ0FJRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVb0IsZUFKZixDQUtERyxXQUFXLENBQUUsS0FMWixDQU1EOEUsUUFBUSxDQUFFLElBTlQsQ0FPREQsT0FBTyxDQUFFLDhCQVBSLENBUkksQ0FnQkosQ0FDRDtBQUNBemtCLElBQUksQ0FBRSxvREFGTCxDQUdEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVW1CLE9BSmYsQ0FLREksV0FBVyxDQUFFLEtBTFosQ0FNRDhFLFFBQVEsQ0FBRSxJQU5ULENBT0RELE9BQU8sQ0FBRSxzQkFQUixDQWhCSSxDQXdCSixDQUNEO0FBQ0F6a0IsSUFBSSxDQUFFLDREQUZMLENBR0QyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIcEIsQ0FJRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVb0IsZUFKZixDQUtERyxXQUFXLENBQUUsS0FMWixDQU1EOEUsUUFBUSxDQUFFLElBTlQsQ0FPREQsT0FBTyxDQUFFLDhCQVBSLENBeEJJLENBVE4sQ0ExQ0ksQ0FvRkosQ0FDRDtBQUNBemtCLElBQUksQ0FBRSxvQ0FGTCxDQUdEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFKZixDQUtEUSxXQUFXLENBQUUsSUFMWixDQU1EK0UsV0FBVyxDQUFFLGFBTlosQ0FwRkksQ0E0Rkw7QUFDQXFELGtCQTdGSyxDQThGUCxDQUNFO0FBQ0Fob0IsSUFBSSxDQUFFLDJDQUZSLENBR0UyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBSHZCLENBSUUvRyxJQUFJLENBQUUsQ0FKUixDQUtFd0ksV0FBVyxDQUFFLElBTGYsQ0FNRThFLFFBQVEsQ0FBRSxJQU5aLENBT0V6SyxLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLDhDQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVJLFNBSFYsQ0FJTm1CLFdBQVcsQ0FBRSxLQUpQLENBS047QUFDQWlGLHFCQUFxQixDQUFFLG9CQU5qQixDQUFELENBUFQsQ0E5Rk8sQ0E2R0osQ0FDRDtBQUNBN2tCLElBQUksQ0FBRSw0Q0FGTCxDQUdEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUhwQixDQUlEL0csSUFBSSxDQUFFLENBSkwsQ0FLRHdJLFdBQVcsQ0FBRSxJQUxaLENBTUQ4RSxRQUFRLENBQUUsSUFOVCxDQU9EekssS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSwrQ0FEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUhWLENBSU5tQixXQUFXLENBQUUsS0FKUCxDQUtOO0FBQ0FpRixxQkFBcUIsQ0FBRSxxQkFOakIsQ0FBRCxDQVBOLENBN0dJLENBNEhKLENBQ0Q7QUFDQTdrQixJQUFJLENBQUUsdUNBRkwsQ0FHRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFIcEIsQ0FJRC9HLElBQUksQ0FBRSxDQUpMLENBS0R3SSxXQUFXLENBQUUsSUFMWixDQU1EK0UsV0FBVyxDQUFFLGdCQU5aLENBT0RELFFBQVEsQ0FBRSxJQVBULENBNUhJLENBTkQsQ0FBRCxDQTJJSixDQUNEO0FBQ0Exa0IsSUFBSSxDQUFFLGdDQUZMLENBR0QyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIcEIsQ0FJRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUpmLENBS0RRLFdBQVcsQ0FBRSxJQUxaLENBTUQzRixLQUFLLENBQUUsQ0FBQyxDQUNOO0FBQ0FqYSxJQUFJLENBQUUsMENBRkEsQ0FHTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhmLENBSU43RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FKVixDQUtOZ0IsV0FBVyxDQUFFLEtBTFAsQ0FNTjZFLE9BQU8sQ0FBRSxrQkFOSCxDQUFELENBT0osQ0FDRHprQixJQUFJLENBQUUsaURBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEeUcsUUFBUSxDQUFFLElBSFQsQ0FJREMsV0FBVyxDQUFFLHFCQUpaLENBUEksQ0FOTixDQTNJSSxDQThKSixDQUNEO0FBQ0Eza0IsSUFBSSxDQUFFLDRCQUZMLENBR0QyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIcEIsQ0FJRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUpmLENBS0RtQixXQUFXLENBQUUsS0FMWixDQU1EaUYscUJBQXFCLENBQUUsZUFOdEIsQ0E5SkksQ0FMc0IsQ0FBL0IsQ0E2S0EsR0FBSStwQiw0QkFBMkIsQ0FBRyxDQUNoQzV1QyxJQUFJLENBQUUsUUFEMEIsQ0FFaEMyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGVyxDQUdoQzdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhnQixDQUloQ1EsV0FBVyxDQUFFLElBSm1CLENBS2hDM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSxzQkFEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUZmLENBR04vRyxJQUFJLENBQUUsQ0FIQSxDQUlOd0ksV0FBVyxDQUFFLElBSlAsQ0FLTjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsMENBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNDLEtBQUwsQ0FBV29CLFFBSFgsQ0FJTlEsV0FBVyxDQUFFLElBSlAsQ0FLTjhFLFFBQVEsQ0FBRSxJQUxKLENBTU56SyxLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLG9EQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsU0FDVCxvREFOTSxDQUFELENBTkQsQ0FBRCxDQUxELENBQUQsQ0FvQkosQ0FDRHprQixJQUFJLENBQUUseUJBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRC9HLElBQUksQ0FBRSxDQUhMLENBSUR3SSxXQUFXLENBQUUsSUFKWixDQUtEM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSw2Q0FEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ0MsS0FBTCxDQUFXb0IsUUFIWCxDQUlOUSxXQUFXLENBQUUsSUFKUCxDQUtOOEUsUUFBUSxDQUFFLElBTEosQ0FNTnpLLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsdURBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxZQUxILENBQUQsQ0FNSixDQUNEemtCLElBQUksQ0FBRSxvREFETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIZixDQUlEUSxXQUFXLENBQUUsSUFKWixDQUtEM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSw4REFEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGdCQUNULG9EQU5NLENBQUQsQ0FMTixDQU5JLENBTkQsQ0FBRCxDQUxOLENBcEJJLENBb0RKLENBQ0R6a0IsSUFBSSxDQUFFLG1CQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRnBCLENBR0QvRyxJQUFJLENBQUUsQ0FITCxDQUlEc04sUUFBUSxDQUFFLElBSlQsQ0FLRHpLLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsOEJBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNDLEtBQUwsQ0FBV1EsT0FIWCxDQUlOb0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxZQUxILENBQUQsQ0FMTixDQXBESSxDQWdFSixDQUNEemtCLElBQUksQ0FBRSxxQkFETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUZwQixDQUdEL0csSUFBSSxDQUFFLENBSEwsQ0FJRHNOLFFBQVEsQ0FBRSxJQUpULENBS0R6SyxLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLHdCQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDQyxLQUFMLENBQVdRLE9BSFgsQ0FJTm9CLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsU0FMSCxDQUFELENBTE4sQ0FoRUksQ0FMeUIsQ0FBbEMsQ0FvRkE7QUFDQSxHQUFJb3FCLGtDQUFpQyxDQUFHLENBQ3RDN3VDLElBQUksQ0FBRSwwQkFEZ0MsQ0FFdEMyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGaUIsQ0FHdEM3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIc0IsQ0FJdENRLFdBQVcsQ0FBRSxJQUp5QixDQUt0QytFLFdBQVcsQ0FBRSwwQkFMeUIsQ0FNdEMxSyxLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLGtDQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSFYsQ0FJTm9CLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsaUNBTEgsQ0FBRCxDQU1KLENBQ0Q7QUFDQXprQixJQUFJLENBQUUsa0NBRkwsQ0FHRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSmYsQ0FLRFEsV0FBVyxDQUFFLElBTFosQ0FNRCtFLFdBQVcsQ0FBRSxpQ0FOWixDQU5JLENBY1A7QUFDQXFELGtCQWZPLENBZ0JQLENBQ0Vob0IsSUFBSSxDQUFFLHFDQURSLENBRUUyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRnZCLENBR0UvRyxJQUFJLENBQUUsQ0FIUixDQUlFd0ksV0FBVyxDQUFFLElBSmYsQ0FLRThFLFFBQVEsQ0FBRSxJQUxaLENBTUVELE9BQU8sQ0FBRSxvQ0FOWCxDQU9FeEssS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSxxQ0FEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhWLENBSU5RLFdBQVcsQ0FBRSxJQUpQLENBS04zRixLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLDBDQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBQUQsQ0FLSixDQUNENWYsSUFBSSxDQUFFLDJDQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FIZixDQUlETyxXQUFXLENBQUUsSUFKWixDQUxJLENBTEQsQ0FBRCxDQVBULENBaEJPLENBTitCLENBQXhDLENBaURBO0FBQ0EsR0FBSWt2Qiw4QkFBNkIsQ0FBRyxDQUNsQzl1QyxJQUFJLENBQUUsc0JBRDRCLENBRWxDMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmEsQ0FHbEM3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIa0IsQ0FJbENRLFdBQVcsQ0FBRSxJQUpxQixDQUtsQytFLFdBQVcsQ0FBRSxLQUxxQixDQU1sQzFLLEtBQUssQ0FBRSxDQUNMNDBCLGlDQURLLENBQzhCLENBQ25DO0FBQ0E3dUMsSUFBSSxDQUFFLHlDQUY2QixDQUduQzJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhjLENBSW5DN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSm1CLENBS25DUSxXQUFXLENBQUUsSUFMc0IsQ0FNbkMzRixLQUFLLENBQUUsQ0FBQyxDQUNOO0FBQ0FqYSxJQUFJLENBQUUsbURBRkEsQ0FHTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhmLENBSU43RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FKVixDQUtOZ0IsV0FBVyxDQUFFLEtBTFAsQ0FNTjZFLE9BQU8sQ0FBRSxpQkFOSCxDQUFELENBT0osQ0FDRHprQixJQUFJLENBQUUsb0RBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEeUcsUUFBUSxDQUFFLElBSFQsQ0FJREMsV0FBVyxDQUFFLG9CQUpaLENBUEksQ0FONEIsQ0FEOUIsQ0FvQkosQ0FDRDtBQUNBM2tCLElBQUksQ0FBRSxnQ0FGTCxDQUdEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FKZixDQUtEbUIsV0FBVyxDQUFFLEtBTFosQ0FNRGlGLHFCQUFxQixDQUFFLGNBTnRCLENBcEJJLENBTjJCLENBQXBDLENBb0NBOzs7Ozs7R0FPQTNiLEdBQUcsQ0FBQzZsQyxvQkFBSixDQUEyQixTQUFTQyxHQUFULENBQWN0cEIsRUFBZCxDQUFrQixDQUMzQyxHQUFJNVUsS0FBSSxDQUFHLEVBQVgsQ0FFQTtBQUNBLEdBQUlnQyxJQUFKLENBQVNyRixJQUFULENBQWVpSixHQUFmLENBQ0EsSUFBSSxHQUFJdTRCLEdBQUUsQ0FBRyxDQUFiLENBQWdCQSxFQUFFLENBQUdELEdBQUcsQ0FBQy8wQixLQUFKLENBQVU5WSxNQUEvQixDQUF1QyxFQUFFOHRDLEVBQXpDLENBQTZDLENBQzNDO0FBQ0FuOEIsR0FBRyxDQUFHazhCLEdBQUcsQ0FBQy8wQixLQUFKLENBQVVnMUIsRUFBVixDQUFOLENBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxHQUFJdmtDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR29JLEdBQUcsQ0FBQ21ILEtBQUosQ0FBVTlZLE1BQTdCLENBQXFDLEVBQUV1SixDQUF2QyxDQUEwQyxDQUN4Q2dNLEdBQUcsQ0FBRyxFQUFOLENBQ0FqSixJQUFJLENBQUdxRixHQUFHLENBQUNtSCxLQUFKLENBQVV2UCxDQUFWLENBQVAsQ0FDQWdNLEdBQUcsQ0FBQ1UsSUFBSixDQUFXMkcsSUFBSSxDQUFDc0UsUUFBTCxDQUFjNVUsSUFBSSxDQUFDd00sS0FBTCxDQUFXLENBQVgsRUFBY0EsS0FBNUIsQ0FBWCxDQUNBdkQsR0FBRyxDQUFDdUQsS0FBSixDQUFZeE0sSUFBSSxDQUFDd00sS0FBTCxDQUFXLENBQVgsRUFBY0EsS0FBMUIsQ0FDQXZELEdBQUcsQ0FBQ3c0QixhQUFKLENBQW9CemhDLElBQUksQ0FBQ3dNLEtBQUwsQ0FBVyxDQUFYLEVBQWM3QyxJQUFsQyxDQUNBO0FBQ0EsR0FBR1YsR0FBRyxDQUFDVSxJQUFKLEdBQVlrTyxLQUFmLENBQXFCLENBQ25CNU8sR0FBRyxDQUFDMVcsSUFBSixDQUFXc2xCLElBQUksQ0FBQzVPLEdBQUcsQ0FBQ1UsSUFBTCxDQUFmLENBQ0EsR0FBR1YsR0FBRyxDQUFDMVcsSUFBSixHQUFZMHVDLFlBQWYsQ0FBNEIsQ0FDMUJoNEIsR0FBRyxDQUFDeTRCLFNBQUosQ0FBZ0JULFdBQVcsQ0FBQ2g0QixHQUFHLENBQUMxVyxJQUFMLENBQTNCLENBQ0QsQ0FDRixDQUNELEdBQUcwbEIsRUFBSCxDQUFPLENBQ0xBLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVTNGLEdBQUcsQ0FBQ1UsSUFBZCxFQUNBc08sRUFBRSxDQUFDckosTUFBSCxDQUFVM0YsR0FBRyxDQUFDdUQsS0FBZCxFQUNELENBQ0RuSixJQUFJLENBQUMxRCxJQUFMLENBQVVzSixHQUFWLEVBQ0QsQ0FDRixDQUVELE1BQU81RixLQUFQLENBQ0QsQ0FsQ0QsQ0FvQ0E7Ozs7O0dBTUE1SCxHQUFHLENBQUNrbUMsb0JBQUosQ0FBMkIsU0FBU3RoQyxVQUFULENBQXFCLENBQzlDLEdBQUlnRCxLQUFJLENBQUcsRUFBWCxDQUVBO0FBQ0EsSUFBSSxHQUFJbStCLEdBQUUsQ0FBRyxDQUFiLENBQWdCQSxFQUFFLENBQUduaEMsVUFBVSxDQUFDM00sTUFBaEMsQ0FBd0MsRUFBRTh0QyxFQUExQyxDQUE4QyxDQUM1QztBQUNBLEdBQUlJLElBQUcsQ0FBR3ZoQyxVQUFVLENBQUNtaEMsRUFBRCxDQUFwQixDQUVBO0FBQ0E7QUFDQSxHQUFJNzNCLEtBQUksQ0FBRzJHLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY2d0QixHQUFHLENBQUNwMUIsS0FBSixDQUFVLENBQVYsRUFBYUEsS0FBM0IsQ0FBWCxDQUNBLEdBQUlrSSxPQUFNLENBQUdrdEIsR0FBRyxDQUFDcDFCLEtBQUosQ0FBVSxDQUFWLEVBQWFBLEtBQTFCLENBQ0EsSUFBSSxHQUFJK2EsR0FBRSxDQUFHLENBQWIsQ0FBZ0JBLEVBQUUsQ0FBRzdTLE1BQU0sQ0FBQ2hoQixNQUE1QixDQUFvQyxFQUFFNnpCLEVBQXRDLENBQTBDLENBQ3hDLEdBQUl0ZSxJQUFHLENBQUcsRUFBVixDQUNBQSxHQUFHLENBQUNVLElBQUosQ0FBV0EsSUFBWCxDQUNBVixHQUFHLENBQUN1RCxLQUFKLENBQVlrSSxNQUFNLENBQUM2UyxFQUFELENBQU4sQ0FBVy9hLEtBQXZCLENBQ0F2RCxHQUFHLENBQUN3NEIsYUFBSixDQUFvQi9zQixNQUFNLENBQUM2UyxFQUFELENBQU4sQ0FBVzVkLElBQS9CLENBQ0E7QUFDQSxHQUFHVixHQUFHLENBQUNVLElBQUosR0FBWWtPLEtBQWYsQ0FBcUIsQ0FDbkI1TyxHQUFHLENBQUMxVyxJQUFKLENBQVdzbEIsSUFBSSxDQUFDNU8sR0FBRyxDQUFDVSxJQUFMLENBQWYsQ0FDQSxHQUFHVixHQUFHLENBQUMxVyxJQUFKLEdBQVkwdUMsWUFBZixDQUE0QixDQUMxQmg0QixHQUFHLENBQUN5NEIsU0FBSixDQUFnQlQsV0FBVyxDQUFDaDRCLEdBQUcsQ0FBQzFXLElBQUwsQ0FBM0IsQ0FDRCxDQUNGLENBQ0Q7QUFDQSxHQUFHMFcsR0FBRyxDQUFDVSxJQUFKLEdBQWFrTyxJQUFJLENBQUNncUIsZ0JBQXJCLENBQXVDLENBQ3JDNTRCLEdBQUcsQ0FBQzY0QixVQUFKLENBQWlCLEVBQWpCLENBQ0EsSUFBSSxHQUFJaGQsR0FBRSxDQUFHLENBQWIsQ0FBZ0JBLEVBQUUsQ0FBRzdiLEdBQUcsQ0FBQ3VELEtBQUosQ0FBVTlZLE1BQS9CLENBQXVDLEVBQUVveEIsRUFBekMsQ0FBNkMsQ0FDM0M3YixHQUFHLENBQUM2NEIsVUFBSixDQUFlbmlDLElBQWYsQ0FBb0JsRSxHQUFHLENBQUNzbUMsNEJBQUosQ0FBaUM5NEIsR0FBRyxDQUFDdUQsS0FBSixDQUFVc1ksRUFBVixDQUFqQyxDQUFwQixFQUNELENBQ0YsQ0FDRHpoQixJQUFJLENBQUMxRCxJQUFMLENBQVVzSixHQUFWLEVBQ0QsQ0FDRixDQUVELE1BQU81RixLQUFQLENBQ0QsQ0FwQ0QsQ0FzQ0E7Ozs7Ozs7Ozs7R0FXQSxRQUFTMitCLGNBQVQsQ0FBdUIvNEIsR0FBdkIsQ0FBNEJuVyxPQUE1QixDQUFxQyxDQUNuQyxHQUFHLE1BQU9BLFFBQVAsR0FBbUIsUUFBdEIsQ0FBZ0MsQ0FDOUJBLE9BQU8sQ0FBRyxDQUFDNHVDLFNBQVMsQ0FBRTV1QyxPQUFaLENBQVYsQ0FDRCxDQUVELEdBQUl1USxLQUFJLENBQUcsSUFBWCxDQUNBLEdBQUlyRCxLQUFKLENBQ0EsSUFBSSxHQUFJL0MsRUFBQyxDQUFHLENBQVosQ0FBZW9HLElBQUksR0FBSyxJQUFULEVBQWlCcEcsQ0FBQyxDQUFHZ00sR0FBRyxDQUFDNUksVUFBSixDQUFlM00sTUFBbkQsQ0FBMkQsRUFBRXVKLENBQTdELENBQWdFLENBQzlEK0MsSUFBSSxDQUFHaUosR0FBRyxDQUFDNUksVUFBSixDQUFlcEQsQ0FBZixDQUFQLENBQ0EsR0FBR25LLE9BQU8sQ0FBQzZXLElBQVIsRUFBZ0I3VyxPQUFPLENBQUM2VyxJQUFSLEdBQWlCM0osSUFBSSxDQUFDMkosSUFBekMsQ0FBK0MsQ0FDN0N0RyxJQUFJLENBQUdyRCxJQUFQLENBQ0QsQ0FGRCxJQUVPLElBQUdsTixPQUFPLENBQUNQLElBQVIsRUFBZ0JPLE9BQU8sQ0FBQ1AsSUFBUixHQUFpQnlOLElBQUksQ0FBQ3pOLElBQXpDLENBQStDLENBQ3BEOFEsSUFBSSxDQUFHckQsSUFBUCxDQUNELENBRk0sSUFFQSxJQUFHbE4sT0FBTyxDQUFDNHVDLFNBQVIsRUFBcUI1dUMsT0FBTyxDQUFDNHVDLFNBQVIsR0FBc0IxaEMsSUFBSSxDQUFDMGhDLFNBQW5ELENBQThELENBQ25FcitCLElBQUksQ0FBR3JELElBQVAsQ0FDRCxDQUNGLENBQ0QsTUFBT3FELEtBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJBLEdBQUk0K0IseUJBQXdCLENBQUcsUUFBM0JBLHlCQUEyQixDQUFTeHRCLEdBQVQsQ0FBY3hMLEdBQWQsQ0FBbUJpNUIsWUFBbkIsQ0FBaUMsQ0FDOUQsR0FBSS9wQyxPQUFNLENBQUcsRUFBYixDQUVBLEdBQUdzYyxHQUFHLEdBQUtvRCxJQUFJLENBQUMsWUFBRCxDQUFmLENBQStCLENBQzdCLE1BQU8xZixPQUFQLENBQ0QsQ0FFRCxHQUFHK3BDLFlBQUgsQ0FBaUIsQ0FDZi9wQyxNQUFNLENBQUcsQ0FDUG1CLElBQUksQ0FBRSxDQUNKNm9DLFlBQVksQ0FBRXRxQixJQUFJLENBQUMsTUFBRCxDQURkLENBREMsQ0FJUHVxQixHQUFHLENBQUUsQ0FDSEQsWUFBWSxDQUFFdHFCLElBQUksQ0FBQyxNQUFELENBRGYsQ0FFSHZlLElBQUksQ0FBRSxDQUNKNm9DLFlBQVksQ0FBRXRxQixJQUFJLENBQUMsTUFBRCxDQURkLENBRkgsQ0FKRSxDQVVQd3FCLFVBQVUsQ0FBRSxFQVZMLENBQVQsQ0FZRCxDQUVELEdBQUlyckIsUUFBTyxDQUFHLEVBQWQsQ0FDQSxHQUFJMWYsT0FBTSxDQUFHLEVBQWIsQ0FDQSxHQUFHLENBQUNnWixJQUFJLENBQUN3RyxRQUFMLENBQWM3TixHQUFkLENBQW1CazRCLDJCQUFuQixDQUFnRG5xQixPQUFoRCxDQUF5RDFmLE1BQXpELENBQUosQ0FBc0UsQ0FDcEUsR0FBSW5DLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLHlDQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQ21DLE1BQU4sQ0FBZUEsTUFBZixDQUNBLEtBQU1uQyxNQUFOLENBQ0QsQ0FFRCxHQUFHNmhCLE9BQU8sQ0FBQ3NyQixPQUFSLEdBQW9CeGpDLFNBQXZCLENBQWtDLENBQ2hDM0csTUFBTSxDQUFDbUIsSUFBUCxDQUFjbkIsTUFBTSxDQUFDbUIsSUFBUCxFQUFlLEVBQTdCLENBQ0FuQixNQUFNLENBQUNtQixJQUFQLENBQVk2b0MsWUFBWixDQUEyQjd4QixJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUNzckIsT0FBdEIsQ0FBM0IsQ0FDRCxDQUVELEdBQUd0ckIsT0FBTyxDQUFDdXJCLFVBQVIsR0FBdUJ6akMsU0FBMUIsQ0FBcUMsQ0FDbkMzRyxNQUFNLENBQUNpcUMsR0FBUCxDQUFhanFDLE1BQU0sQ0FBQ2lxQyxHQUFQLEVBQWMsRUFBM0IsQ0FDQWpxQyxNQUFNLENBQUNpcUMsR0FBUCxDQUFXRCxZQUFYLENBQTBCN3hCLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ3VyQixVQUF0QixDQUExQixDQUNBcHFDLE1BQU0sQ0FBQ2lxQyxHQUFQLENBQVc5b0MsSUFBWCxDQUFrQm5CLE1BQU0sQ0FBQ2lxQyxHQUFQLENBQVc5b0MsSUFBWCxFQUFtQixFQUFyQyxDQUNBbkIsTUFBTSxDQUFDaXFDLEdBQVAsQ0FBVzlvQyxJQUFYLENBQWdCNm9DLFlBQWhCLENBQStCN3hCLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ3dyQixjQUF0QixDQUEvQixDQUNELENBRUQsR0FBR3hyQixPQUFPLENBQUNxckIsVUFBUixHQUF1QnZqQyxTQUExQixDQUFxQyxDQUNuQzNHLE1BQU0sQ0FBQ2txQyxVQUFQLENBQW9CcnJCLE9BQU8sQ0FBQ3FyQixVQUFSLENBQW1CbC9CLFVBQW5CLENBQThCLENBQTlCLENBQXBCLENBQ0QsQ0FFRCxNQUFPaEwsT0FBUCxDQUNELENBL0NELENBaURBOzs7Ozs7Ozs7Ozs7OztHQWVBc0QsR0FBRyxDQUFDZ25DLGtCQUFKLENBQXlCLFNBQVNqYyxHQUFULENBQWNrYyxXQUFkLENBQTJCbHZCLE1BQTNCLENBQW1DLENBQzFELEdBQUluVSxJQUFHLENBQUdyRSxLQUFLLENBQUN3ckIsR0FBTixDQUFVNWdCLE1BQVYsQ0FBaUI0Z0IsR0FBakIsRUFBc0IsQ0FBdEIsQ0FBVixDQUVBLEdBQUdubkIsR0FBRyxDQUFDc0ssSUFBSixHQUFhLGFBQWIsRUFDRHRLLEdBQUcsQ0FBQ3NLLElBQUosR0FBYSxrQkFEWixFQUVEdEssR0FBRyxDQUFDc0ssSUFBSixHQUFhLHFCQUZmLENBRXNDLENBQ3BDLEdBQUl4VSxNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FBVSwyREFDcEIscUVBRFUsQ0FBWixDQUVBMkIsS0FBSyxDQUFDMDBCLFVBQU4sQ0FBbUJ4cUIsR0FBRyxDQUFDc0ssSUFBdkIsQ0FDQSxLQUFNeFUsTUFBTixDQUNELENBQ0QsR0FBR2tLLEdBQUcsQ0FBQ3FuQixRQUFKLEVBQWdCcm5CLEdBQUcsQ0FBQ3FuQixRQUFKLENBQWEvYyxJQUFiLEdBQXNCLFdBQXpDLENBQXNELENBQ3BELEtBQU0sSUFBSW5XLE1BQUosQ0FBVSwyREFBVixDQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUl5VixJQUFHLENBQUdxSCxJQUFJLENBQUNpRCxPQUFMLENBQWFsVSxHQUFHLENBQUMybkIsSUFBakIsQ0FBdUJ4VCxNQUF2QixDQUFWLENBRUEsTUFBTy9YLElBQUcsQ0FBQ2tuQyxtQkFBSixDQUF3QjE1QixHQUF4QixDQUE2Qnk1QixXQUE3QixDQUFQLENBQ0QsQ0FuQkQsQ0FxQkE7Ozs7Ozs7R0FRQWpuQyxHQUFHLENBQUNtbkMsZ0JBQUosQ0FBdUIsU0FBU0MsSUFBVCxDQUFldjdCLE9BQWYsQ0FBd0IsQ0FDN0M7QUFDQSxHQUFJakksSUFBRyxDQUFHLENBQ1JzSyxJQUFJLENBQUUsYUFERSxDQUVScWQsSUFBSSxDQUFFMVcsSUFBSSxDQUFDK0QsS0FBTCxDQUFXNVksR0FBRyxDQUFDcW5DLGlCQUFKLENBQXNCRCxJQUF0QixDQUFYLEVBQXdDNS9CLFFBQXhDLEVBRkUsQ0FBVixDQUlBLE1BQU9qSSxNQUFLLENBQUN3ckIsR0FBTixDQUFVeGdCLE1BQVYsQ0FBaUIzRyxHQUFqQixDQUFzQixDQUFDaUksT0FBTyxDQUFFQSxPQUFWLENBQXRCLENBQVAsQ0FDRCxDQVBELENBU0E7Ozs7OztHQU9BN0wsR0FBRyxDQUFDc25DLGdCQUFKLENBQXVCLFNBQVN2YyxHQUFULENBQWMsQ0FDbkMsR0FBSW5uQixJQUFHLENBQUdyRSxLQUFLLENBQUN3ckIsR0FBTixDQUFVNWdCLE1BQVYsQ0FBaUI0Z0IsR0FBakIsRUFBc0IsQ0FBdEIsQ0FBVixDQUVBLEdBQUdubkIsR0FBRyxDQUFDc0ssSUFBSixHQUFhLFlBQWIsRUFBNkJ0SyxHQUFHLENBQUNzSyxJQUFKLEdBQWEsZ0JBQTdDLENBQStELENBQzdELEdBQUl4VSxNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FBVSxxREFDcEIsK0NBRFUsQ0FBWixDQUVBMkIsS0FBSyxDQUFDMDBCLFVBQU4sQ0FBbUJ4cUIsR0FBRyxDQUFDc0ssSUFBdkIsQ0FDQSxLQUFNeFUsTUFBTixDQUNELENBQ0QsR0FBR2tLLEdBQUcsQ0FBQ3FuQixRQUFKLEVBQWdCcm5CLEdBQUcsQ0FBQ3FuQixRQUFKLENBQWEvYyxJQUFiLEdBQXNCLFdBQXpDLENBQXNELENBQ3BELEtBQU0sSUFBSW5XLE1BQUosQ0FBVSwwREFBVixDQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUl5VixJQUFHLENBQUdxSCxJQUFJLENBQUNpRCxPQUFMLENBQWFsVSxHQUFHLENBQUMybkIsSUFBakIsQ0FBVixDQUVBLE1BQU92ckIsSUFBRyxDQUFDd2xCLGlCQUFKLENBQXNCaFksR0FBdEIsQ0FBUCxDQUNELENBakJELENBbUJBOzs7Ozs7O0dBUUF4TixHQUFHLENBQUNDLGNBQUosQ0FBcUIsU0FBU3pHLEdBQVQsQ0FBY3FTLE9BQWQsQ0FBdUIsQ0FDMUM7QUFDQSxHQUFJakksSUFBRyxDQUFHLENBQ1JzSyxJQUFJLENBQUUsWUFERSxDQUVScWQsSUFBSSxDQUFFMVcsSUFBSSxDQUFDK0QsS0FBTCxDQUFXNVksR0FBRyxDQUFDNmxCLGVBQUosQ0FBb0Jyc0IsR0FBcEIsQ0FBWCxFQUFxQ2dPLFFBQXJDLEVBRkUsQ0FBVixDQUlBLE1BQU9qSSxNQUFLLENBQUN3ckIsR0FBTixDQUFVeGdCLE1BQVYsQ0FBaUIzRyxHQUFqQixDQUFzQixDQUFDaUksT0FBTyxDQUFFQSxPQUFWLENBQXRCLENBQVAsQ0FDRCxDQVBELENBU0E7Ozs7Ozs7R0FRQTdMLEdBQUcsQ0FBQ3VuQywwQkFBSixDQUFpQyxTQUFTL3RDLEdBQVQsQ0FBY3FTLE9BQWQsQ0FBdUIsQ0FDdEQ7QUFDQSxHQUFJakksSUFBRyxDQUFHLENBQ1JzSyxJQUFJLENBQUUsZ0JBREUsQ0FFUnFkLElBQUksQ0FBRTFXLElBQUksQ0FBQytELEtBQUwsQ0FBVzVZLEdBQUcsQ0FBQytsQix1QkFBSixDQUE0QnZzQixHQUE1QixDQUFYLEVBQTZDZ08sUUFBN0MsRUFGRSxDQUFWLENBSUEsTUFBT2pJLE1BQUssQ0FBQ3dyQixHQUFOLENBQVV4Z0IsTUFBVixDQUFpQjNHLEdBQWpCLENBQXNCLENBQUNpSSxPQUFPLENBQUVBLE9BQVYsQ0FBdEIsQ0FBUCxDQUNELENBUEQsQ0FTQTs7Ozs7Ozs7Ozs7OztHQWNBN0wsR0FBRyxDQUFDd25DLHVCQUFKLENBQThCLFNBQVNodUMsR0FBVCxDQUFjbkMsT0FBZCxDQUF1QixDQUNuREEsT0FBTyxDQUFHQSxPQUFPLEVBQUksRUFBckIsQ0FDQSxHQUFJbWxCLEdBQUUsQ0FBR25sQixPQUFPLENBQUNtbEIsRUFBUixFQUFjamQsS0FBSyxDQUFDaWQsRUFBTixDQUFTbVMsSUFBVCxDQUFjcHdCLE1BQWQsRUFBdkIsQ0FDQSxHQUFJMlAsS0FBSSxDQUFHN1csT0FBTyxDQUFDNlcsSUFBUixFQUFnQixjQUEzQixDQUVBLEdBQUl2SCxNQUFKLENBQ0EsT0FBT3VILElBQVAsRUFDQSxJQUFLLGNBQUwsQ0FDRXZILEtBQUssQ0FBR2tPLElBQUksQ0FBQytELEtBQUwsQ0FBVzVZLEdBQUcsQ0FBQytsQix1QkFBSixDQUE0QnZzQixHQUE1QixDQUFYLEVBQTZDZ08sUUFBN0MsRUFBUixDQUNBLE1BQ0YsSUFBSyxzQkFBTCxDQUNFYixLQUFLLENBQUdrTyxJQUFJLENBQUMrRCxLQUFMLENBQVc1WSxHQUFHLENBQUM2bEIsZUFBSixDQUFvQnJzQixHQUFwQixDQUFYLEVBQXFDZ08sUUFBckMsRUFBUixDQUNBLE1BQ0YsUUFDRSxLQUFNLElBQUl6UCxNQUFKLENBQVUsNkJBQStCVixPQUFPLENBQUM2VyxJQUF2QyxDQUE4QyxJQUF4RCxDQUFOLENBUkYsQ0FXQTtBQUNBc08sRUFBRSxDQUFDclAsS0FBSCxHQUNBcVAsRUFBRSxDQUFDckosTUFBSCxDQUFVeE0sS0FBVixFQUNBLEdBQUl5WSxPQUFNLENBQUc1QyxFQUFFLENBQUM0QyxNQUFILEVBQWIsQ0FDQSxHQUFHL25CLE9BQU8sQ0FBQ3lTLFFBQVIsR0FBcUIsS0FBeEIsQ0FBK0IsQ0FDN0IsR0FBSUksSUFBRyxDQUFHa1YsTUFBTSxDQUFDclcsS0FBUCxFQUFWLENBQ0EsR0FBRzFSLE9BQU8sQ0FBQ293QyxTQUFYLENBQXNCLENBQ3BCLE1BQU92OUIsSUFBRyxDQUFDbUgsS0FBSixDQUFVLE9BQVYsRUFBbUI3WSxJQUFuQixDQUF3Qm5CLE9BQU8sQ0FBQ293QyxTQUFoQyxDQUFQLENBQ0QsQ0FDRCxNQUFPdjlCLElBQVAsQ0FDRCxDQU5ELElBTU8sSUFBRzdTLE9BQU8sQ0FBQ3lTLFFBQVIsR0FBcUIsUUFBeEIsQ0FBa0MsQ0FDdkMsTUFBT3NWLE9BQU0sQ0FBQzVYLFFBQVAsRUFBUCxDQUNELENBRk0sSUFFQSxJQUFHblEsT0FBTyxDQUFDeVMsUUFBWCxDQUFxQixDQUMxQixLQUFNLElBQUkvUixNQUFKLENBQVUscUJBQXVCVixPQUFPLENBQUN5UyxRQUEvQixDQUEwQyxJQUFwRCxDQUFOLENBQ0QsQ0FDRCxNQUFPc1YsT0FBUCxDQUNELENBakNELENBbUNBOzs7Ozs7Ozs7Ozs7OztHQWVBcGYsR0FBRyxDQUFDMG5DLDJCQUFKLENBQWtDLFNBQVMzYyxHQUFULENBQWNrYyxXQUFkLENBQTJCbHZCLE1BQTNCLENBQW1DLENBQ25FLEdBQUluVSxJQUFHLENBQUdyRSxLQUFLLENBQUN3ckIsR0FBTixDQUFVNWdCLE1BQVYsQ0FBaUI0Z0IsR0FBakIsRUFBc0IsQ0FBdEIsQ0FBVixDQUVBLEdBQUdubkIsR0FBRyxDQUFDc0ssSUFBSixHQUFhLHFCQUFoQixDQUF1QyxDQUNyQyxHQUFJeFUsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUscURBQ3BCLCtDQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQzAwQixVQUFOLENBQW1CeHFCLEdBQUcsQ0FBQ3NLLElBQXZCLENBQ0EsS0FBTXhVLE1BQU4sQ0FDRCxDQUNELEdBQUdrSyxHQUFHLENBQUNxbkIsUUFBSixFQUFnQnJuQixHQUFHLENBQUNxbkIsUUFBSixDQUFhL2MsSUFBYixHQUFzQixXQUF6QyxDQUFzRCxDQUNwRCxLQUFNLElBQUluVyxNQUFKLENBQVUscURBQ2QsbUJBREksQ0FBTixDQUVELENBRUQ7QUFDQSxHQUFJeVYsSUFBRyxDQUFHcUgsSUFBSSxDQUFDaUQsT0FBTCxDQUFhbFUsR0FBRyxDQUFDMm5CLElBQWpCLENBQXVCeFQsTUFBdkIsQ0FBVixDQUVBLE1BQU8vWCxJQUFHLENBQUMybkMsNEJBQUosQ0FBaUNuNkIsR0FBakMsQ0FBc0N5NUIsV0FBdEMsQ0FBUCxDQUNELENBbEJELENBb0JBOzs7Ozs7O0dBUUFqbkMsR0FBRyxDQUFDNG5DLHlCQUFKLENBQWdDLFNBQVNDLEdBQVQsQ0FBY2g4QixPQUFkLENBQXVCLENBQ3JEO0FBQ0EsR0FBSWpJLElBQUcsQ0FBRyxDQUNSc0ssSUFBSSxDQUFFLHFCQURFLENBRVJxZCxJQUFJLENBQUUxVyxJQUFJLENBQUMrRCxLQUFMLENBQVc1WSxHQUFHLENBQUM4bkMsMEJBQUosQ0FBK0JELEdBQS9CLENBQVgsRUFBZ0RyZ0MsUUFBaEQsRUFGRSxDQUFWLENBSUEsTUFBT2pJLE1BQUssQ0FBQ3dyQixHQUFOLENBQVV4Z0IsTUFBVixDQUFpQjNHLEdBQWpCLENBQXNCLENBQUNpSSxPQUFPLENBQUVBLE9BQVYsQ0FBdEIsQ0FBUCxDQUNELENBUEQsQ0FTQTs7OztHQUtBN0wsR0FBRyxDQUFDK25DLGlCQUFKLENBQXdCLFVBQVcsQ0FDakMsR0FBSVgsS0FBSSxDQUFHLEVBQVgsQ0FDQUEsSUFBSSxDQUFDbGMsT0FBTCxDQUFlLElBQWYsQ0FDQWtjLElBQUksQ0FBQ1ksWUFBTCxDQUFvQixJQUFwQixDQUNBWixJQUFJLENBQUNhLFlBQUwsQ0FBb0IsSUFBcEIsQ0FDQWIsSUFBSSxDQUFDOWlCLFNBQUwsQ0FBaUIsSUFBakIsQ0FDQThpQixJQUFJLENBQUNjLE9BQUwsQ0FBZSxFQUFmLENBQ0FkLElBQUksQ0FBQ2MsT0FBTCxDQUFheEIsWUFBYixDQUE0QixJQUE1QixDQUNBVSxJQUFJLENBQUNlLFFBQUwsQ0FBZ0IsRUFBaEIsQ0FDQWYsSUFBSSxDQUFDZSxRQUFMLENBQWNDLFNBQWQsQ0FBMEIsR0FBSTlqQyxLQUFKLEVBQTFCLENBQ0E4aUMsSUFBSSxDQUFDZSxRQUFMLENBQWNFLFFBQWQsQ0FBeUIsR0FBSS9qQyxLQUFKLEVBQXpCLENBRUE4aUMsSUFBSSxDQUFDa0IsTUFBTCxDQUFjLEVBQWQsQ0FDQWxCLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWUMsUUFBWixDQUF1QixTQUFTQyxFQUFULENBQWEsQ0FDbEMsTUFBT2pDLGNBQWEsQ0FBQ2EsSUFBSSxDQUFDa0IsTUFBTixDQUFjRSxFQUFkLENBQXBCLENBQ0QsQ0FGRCxDQUdBcEIsSUFBSSxDQUFDa0IsTUFBTCxDQUFZRyxRQUFaLENBQXVCLFNBQVNsa0MsSUFBVCxDQUFlLENBQ3BDbWtDLGtCQUFrQixDQUFDLENBQUNua0MsSUFBRCxDQUFELENBQWxCLENBQ0E2aUMsSUFBSSxDQUFDa0IsTUFBTCxDQUFZMWpDLFVBQVosQ0FBdUJWLElBQXZCLENBQTRCSyxJQUE1QixFQUNELENBSEQsQ0FJQTZpQyxJQUFJLENBQUNrQixNQUFMLENBQVkxakMsVUFBWixDQUF5QixFQUF6QixDQUNBd2lDLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWXpxQyxJQUFaLENBQW1CLElBQW5CLENBRUF1cEMsSUFBSSxDQUFDdUIsT0FBTCxDQUFlLEVBQWYsQ0FDQXZCLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYUosUUFBYixDQUF3QixTQUFTQyxFQUFULENBQWEsQ0FDbkMsTUFBT2pDLGNBQWEsQ0FBQ2EsSUFBSSxDQUFDdUIsT0FBTixDQUFlSCxFQUFmLENBQXBCLENBQ0QsQ0FGRCxDQUdBcEIsSUFBSSxDQUFDdUIsT0FBTCxDQUFhRixRQUFiLENBQXdCLFNBQVNsa0MsSUFBVCxDQUFlLENBQ3JDbWtDLGtCQUFrQixDQUFDLENBQUNua0MsSUFBRCxDQUFELENBQWxCLENBQ0E2aUMsSUFBSSxDQUFDdUIsT0FBTCxDQUFhL2pDLFVBQWIsQ0FBd0JWLElBQXhCLENBQTZCSyxJQUE3QixFQUNELENBSEQsQ0FJQTZpQyxJQUFJLENBQUN1QixPQUFMLENBQWEvakMsVUFBYixDQUEwQixFQUExQixDQUNBd2lDLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYTlxQyxJQUFiLENBQW9CLElBQXBCLENBRUF1cEMsSUFBSSxDQUFDZixVQUFMLENBQWtCLEVBQWxCLENBQ0FlLElBQUksQ0FBQ2xuQyxTQUFMLENBQWlCLElBQWpCLENBQ0FrbkMsSUFBSSxDQUFDNXFCLEVBQUwsQ0FBVSxJQUFWLENBRUE7Ozs7O0tBTUE0cUIsSUFBSSxDQUFDd0IsVUFBTCxDQUFrQixTQUFTQyxLQUFULENBQWdCQyxRQUFoQixDQUEwQixDQUMxQztBQUNBSixrQkFBa0IsQ0FBQ0csS0FBRCxDQUFsQixDQUNBekIsSUFBSSxDQUFDdUIsT0FBTCxDQUFhL2pDLFVBQWIsQ0FBMEJpa0MsS0FBMUIsQ0FDQSxNQUFPekIsS0FBSSxDQUFDdUIsT0FBTCxDQUFhRyxRQUFwQixDQUNBLEdBQUdBLFFBQUgsQ0FBYSxDQUNYO0FBQ0ExQixJQUFJLENBQUN1QixPQUFMLENBQWFHLFFBQWIsQ0FBd0JBLFFBQXhCLENBQ0QsQ0FDRDFCLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYTlxQyxJQUFiLENBQW9CLElBQXBCLENBQ0QsQ0FWRCxDQVlBOzs7OztLQU1BdXBDLElBQUksQ0FBQzJCLFNBQUwsQ0FBaUIsU0FBU0YsS0FBVCxDQUFnQkMsUUFBaEIsQ0FBMEIsQ0FDekM7QUFDQUosa0JBQWtCLENBQUNHLEtBQUQsQ0FBbEIsQ0FDQXpCLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWTFqQyxVQUFaLENBQXlCaWtDLEtBQXpCLENBQ0EsTUFBT3pCLEtBQUksQ0FBQ2tCLE1BQUwsQ0FBWVEsUUFBbkIsQ0FDQSxHQUFHQSxRQUFILENBQWEsQ0FDWDtBQUNBMUIsSUFBSSxDQUFDa0IsTUFBTCxDQUFZUSxRQUFaLENBQXVCQSxRQUF2QixDQUNELENBQ0QxQixJQUFJLENBQUNrQixNQUFMLENBQVl6cUMsSUFBWixDQUFtQixJQUFuQixDQUNELENBVkQsQ0FZQTs7OztLQUtBdXBDLElBQUksQ0FBQzRCLGFBQUwsQ0FBcUIsU0FBU0MsSUFBVCxDQUFlLENBQ2xDLElBQUksR0FBSXpuQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUd5bkMsSUFBSSxDQUFDaHhDLE1BQXhCLENBQWdDLEVBQUV1SixDQUFsQyxDQUFxQyxDQUNuQzBuQywyQkFBMkIsQ0FBQ0QsSUFBSSxDQUFDem5DLENBQUQsQ0FBTCxDQUFVLENBQUM0bEMsSUFBSSxDQUFFQSxJQUFQLENBQVYsQ0FBM0IsQ0FDRCxDQUNEO0FBQ0FBLElBQUksQ0FBQ2YsVUFBTCxDQUFrQjRDLElBQWxCLENBQ0QsQ0FORCxDQVFBOzs7Ozs7OztLQVNBN0IsSUFBSSxDQUFDK0IsWUFBTCxDQUFvQixTQUFTOXhDLE9BQVQsQ0FBa0IsQ0FDcEMsR0FBRyxNQUFPQSxRQUFQLEdBQW1CLFFBQXRCLENBQWdDLENBQzlCQSxPQUFPLENBQUcsQ0FBQ1AsSUFBSSxDQUFFTyxPQUFQLENBQVYsQ0FDRCxDQUVELEdBQUl1USxLQUFJLENBQUcsSUFBWCxDQUNBLEdBQUl3aEMsSUFBSixDQUNBLElBQUksR0FBSTVuQyxFQUFDLENBQUcsQ0FBWixDQUFlb0csSUFBSSxHQUFLLElBQVQsRUFBaUJwRyxDQUFDLENBQUc0bEMsSUFBSSxDQUFDZixVQUFMLENBQWdCcHVDLE1BQXBELENBQTRELEVBQUV1SixDQUE5RCxDQUFpRSxDQUMvRDRuQyxHQUFHLENBQUdoQyxJQUFJLENBQUNmLFVBQUwsQ0FBZ0I3a0MsQ0FBaEIsQ0FBTixDQUNBLEdBQUduSyxPQUFPLENBQUMwRSxFQUFSLEVBQWNxdEMsR0FBRyxDQUFDcnRDLEVBQUosR0FBVzFFLE9BQU8sQ0FBQzBFLEVBQXBDLENBQXdDLENBQ3RDNkwsSUFBSSxDQUFHd2hDLEdBQVAsQ0FDRCxDQUZELElBRU8sSUFBRy94QyxPQUFPLENBQUNQLElBQVIsRUFBZ0JzeUMsR0FBRyxDQUFDdHlDLElBQUosR0FBYU8sT0FBTyxDQUFDUCxJQUF4QyxDQUE4QyxDQUNuRDhRLElBQUksQ0FBR3doQyxHQUFQLENBQ0QsQ0FDRixDQUNELE1BQU94aEMsS0FBUCxDQUNELENBaEJELENBa0JBOzs7OztLQU1Bdy9CLElBQUksQ0FBQzNpQixJQUFMLENBQVksU0FBU2pyQixHQUFULENBQWNnakIsRUFBZCxDQUFrQixDQUM1QjtBQUNBNHFCLElBQUksQ0FBQzVxQixFQUFMLENBQVVBLEVBQUUsRUFBSWpkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU21TLElBQVQsQ0FBY3B3QixNQUFkLEVBQWhCLENBQ0EsR0FBSW1vQyxhQUFZLENBQUd0cUIsSUFBSSxDQUFDZ3JCLElBQUksQ0FBQzVxQixFQUFMLENBQVF3QyxTQUFSLENBQW9CLG1CQUFyQixDQUF2QixDQUNBLEdBQUcsQ0FBQzBuQixZQUFKLENBQWtCLENBQ2hCLEdBQUlodEMsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUseUNBQ3BCLHVDQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQ3NsQixTQUFOLENBQWtCb29CLElBQUksQ0FBQzVxQixFQUFMLENBQVF3QyxTQUExQixDQUNBLEtBQU10bEIsTUFBTixDQUNELENBQ0QwdEMsSUFBSSxDQUFDYSxZQUFMLENBQW9CYixJQUFJLENBQUNjLE9BQUwsQ0FBYXhCLFlBQWIsQ0FBNEJBLFlBQWhELENBRUE7QUFDQVUsSUFBSSxDQUFDaUMsY0FBTCxDQUFzQnJwQyxHQUFHLENBQUNzcEMsaUJBQUosQ0FBc0JsQyxJQUF0QixDQUF0QixDQUNBLEdBQUl6Z0MsTUFBSyxDQUFHa08sSUFBSSxDQUFDK0QsS0FBTCxDQUFXd3VCLElBQUksQ0FBQ2lDLGNBQWhCLENBQVosQ0FFQTtBQUNBakMsSUFBSSxDQUFDNXFCLEVBQUwsQ0FBUXJKLE1BQVIsQ0FBZXhNLEtBQUssQ0FBQ2EsUUFBTixFQUFmLEVBQ0E0L0IsSUFBSSxDQUFDOWlCLFNBQUwsQ0FBaUI5cUIsR0FBRyxDQUFDaXJCLElBQUosQ0FBUzJpQixJQUFJLENBQUM1cUIsRUFBZCxDQUFqQixDQUNELENBbkJELENBcUJBOzs7Ozs7O0tBUUE0cUIsSUFBSSxDQUFDL2lCLE1BQUwsQ0FBYyxTQUFTa2xCLEtBQVQsQ0FBZ0IsQ0FDNUIsR0FBSTNoQyxLQUFJLENBQUcsS0FBWCxDQUVBLEdBQUcsQ0FBQ3cvQixJQUFJLENBQUNvQyxNQUFMLENBQVlELEtBQVosQ0FBSixDQUF3QixDQUN0QixHQUFJakIsT0FBTSxDQUFHaUIsS0FBSyxDQUFDakIsTUFBbkIsQ0FDQSxHQUFJSyxRQUFPLENBQUd2QixJQUFJLENBQUN1QixPQUFuQixDQUNBLEdBQUlqdkMsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsd0RBQ3BCLGtFQURvQixDQUVwQixvQkFGVSxDQUFaLENBR0EyQixLQUFLLENBQUMrdkMsY0FBTixDQUF1Qm5CLE1BQU0sQ0FBQzFqQyxVQUE5QixDQUNBbEwsS0FBSyxDQUFDZ3dDLFlBQU4sQ0FBcUJmLE9BQU8sQ0FBQy9qQyxVQUE3QixDQUNBLEtBQU1sTCxNQUFOLENBQ0QsQ0FFRCxHQUFJOGlCLEdBQUUsQ0FBRytzQixLQUFLLENBQUMvc0IsRUFBZixDQUNBLEdBQUdBLEVBQUUsR0FBSyxJQUFWLENBQWdCLENBQ2Q7QUFDQSxHQUFHK3NCLEtBQUssQ0FBQ3RCLFlBQU4sR0FBc0I3ckIsS0FBekIsQ0FBK0IsQ0FDN0IsR0FBSXBELElBQUcsQ0FBR29ELElBQUksQ0FBQ210QixLQUFLLENBQUN0QixZQUFQLENBQWQsQ0FDQSxPQUFPanZCLEdBQVAsRUFDQSxJQUFLLHVCQUFMLENBQ0V3RCxFQUFFLENBQUdqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNtUyxJQUFULENBQWNwd0IsTUFBZCxFQUFMLENBQ0EsTUFDRixJQUFLLHNCQUFMLENBQ0VpZSxFQUFFLENBQUdqZCxLQUFLLENBQUNpZCxFQUFOLENBQVM2VCxHQUFULENBQWE5eEIsTUFBYixFQUFMLENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0VpZSxFQUFFLENBQUdqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNhLE1BQVQsQ0FBZ0I5ZSxNQUFoQixFQUFMLENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0VpZSxFQUFFLENBQUdqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNtdEIsTUFBVCxDQUFnQnByQyxNQUFoQixFQUFMLENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0VpZSxFQUFFLENBQUdqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNnVSxNQUFULENBQWdCanlCLE1BQWhCLEVBQUwsQ0FDQSxNQUNGLElBQUssWUFBTCxDQUNFaWUsRUFBRSxDQUFHamQsS0FBSyxDQUFDaWQsRUFBTixDQUFTYSxNQUFULENBQWdCOWUsTUFBaEIsRUFBTCxDQUNBLE1BbEJGLENBb0JELENBQ0QsR0FBR2llLEVBQUUsR0FBSyxJQUFWLENBQWdCLENBQ2QsR0FBSTlpQixNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FBVSx5Q0FDcEIsd0JBRFUsQ0FBWixDQUVBMkIsS0FBSyxDQUFDdXVDLFlBQU4sQ0FBcUJzQixLQUFLLENBQUN0QixZQUEzQixDQUNBLEtBQU12dUMsTUFBTixDQUNELENBRUQ7QUFDQSxHQUFJMnZDLGVBQWMsQ0FBR0UsS0FBSyxDQUFDRixjQUFOLEVBQXdCcnBDLEdBQUcsQ0FBQ3NwQyxpQkFBSixDQUFzQkMsS0FBdEIsQ0FBN0MsQ0FDQSxHQUFJNWlDLE1BQUssQ0FBR2tPLElBQUksQ0FBQytELEtBQUwsQ0FBV3l3QixjQUFYLENBQVosQ0FDQTdzQixFQUFFLENBQUNySixNQUFILENBQVV4TSxLQUFLLENBQUNhLFFBQU4sRUFBVixFQUNELENBRUQsR0FBR2dWLEVBQUUsR0FBSyxJQUFWLENBQWdCLENBQ2QsR0FBSTNOLE9BQUosQ0FFQSxPQUFPMDZCLEtBQUssQ0FBQ3RCLFlBQWIsRUFDQSxJQUFLN3JCLEtBQUksQ0FBQ3d0QixxQkFBVixDQUNFLzZCLE1BQU0sQ0FBR3hMLFNBQVQsQ0FBcUIsb0NBQ3JCLE1BQ0YsSUFBSytZLEtBQUksQ0FBQyxZQUFELENBQVQsQ0FDRSxHQUFJdmUsS0FBSixDQUFVOG9DLEdBQVYsQ0FFQSxvQkFDQTlvQyxJQUFJLENBQUd1ZSxJQUFJLENBQUNtdEIsS0FBSyxDQUFDTSxtQkFBTixDQUEwQmxELEdBQTFCLENBQThCOW9DLElBQTlCLENBQW1DNm9DLFlBQXBDLENBQVgsQ0FDQSxHQUFHN29DLElBQUksR0FBS3dGLFNBQVQsRUFBc0I5RCxLQUFLLENBQUNpZCxFQUFOLENBQVMzZSxJQUFULElBQW1Cd0YsU0FBNUMsQ0FBdUQsQ0FDckQsR0FBSTNKLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLGdDQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQ3NmLEdBQU4sQ0FBWXV3QixLQUFLLENBQUNNLG1CQUFOLENBQTBCbEQsR0FBMUIsQ0FBOEI5b0MsSUFBOUIsQ0FBbUM2b0MsWUFBL0MsQ0FDQWh0QyxLQUFLLENBQUM1QyxJQUFOLENBQWErRyxJQUFiLENBQ0EsS0FBTW5FLE1BQU4sQ0FDRCxDQUVEaXRDLEdBQUcsQ0FBR3ZxQixJQUFJLENBQUNtdEIsS0FBSyxDQUFDTSxtQkFBTixDQUEwQmxELEdBQTFCLENBQThCRCxZQUEvQixDQUFWLENBQ0EsR0FBR0MsR0FBRyxHQUFLdGpDLFNBQVIsRUFBcUI5RCxLQUFLLENBQUNvbkMsR0FBTixDQUFVQSxHQUFWLElBQW1CdGpDLFNBQTNDLENBQXNELENBQ3BELEdBQUkzSixNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FBVSwyQkFBVixDQUFaLENBQ0EyQixLQUFLLENBQUNzZixHQUFOLENBQVl1d0IsS0FBSyxDQUFDTSxtQkFBTixDQUEwQmxELEdBQTFCLENBQThCRCxZQUExQyxDQUNBaHRDLEtBQUssQ0FBQzVDLElBQU4sQ0FBYTZ2QyxHQUFiLENBQ0EsS0FBTWp0QyxNQUFOLENBQ0QsQ0FFRGl0QyxHQUFHLENBQUdwbkMsS0FBSyxDQUFDb25DLEdBQU4sQ0FBVUEsR0FBVixFQUFlcG9DLE1BQWYsQ0FBc0JnQixLQUFLLENBQUNpZCxFQUFOLENBQVMzZSxJQUFULEVBQWVVLE1BQWYsRUFBdEIsQ0FBTixDQUVBLDhCQUNBVixJQUFJLENBQUd1ZSxJQUFJLENBQUNtdEIsS0FBSyxDQUFDTSxtQkFBTixDQUEwQmhzQyxJQUExQixDQUErQjZvQyxZQUFoQyxDQUFYLENBQ0EsR0FBRzdvQyxJQUFJLEdBQUt3RixTQUFULEVBQXNCOUQsS0FBSyxDQUFDaWQsRUFBTixDQUFTM2UsSUFBVCxJQUFtQndGLFNBQTVDLENBQXVELENBQ3JELEtBQU0sQ0FDSmpJLE9BQU8sQ0FBRSx1Q0FETCxDQUVKNGQsR0FBRyxDQUFFdXdCLEtBQUssQ0FBQ00sbUJBQU4sQ0FBMEJoc0MsSUFBMUIsQ0FBK0I2b0MsWUFGaEMsQ0FHSjV2QyxJQUFJLENBQUUrRyxJQUhGLENBQU4sQ0FLRCxDQUVEZ1IsTUFBTSxDQUFHdFAsS0FBSyxDQUFDdXFDLEdBQU4sQ0FBVXZyQyxNQUFWLENBQWlCZ0IsS0FBSyxDQUFDaWQsRUFBTixDQUFTM2UsSUFBVCxFQUFlVSxNQUFmLEVBQWpCLENBQTBDb29DLEdBQTFDLENBQ1A0QyxLQUFLLENBQUNNLG1CQUFOLENBQTBCakQsVUFEbkIsQ0FBVCxDQUVBLE1BdENGLENBeUNBO0FBQ0FoL0IsSUFBSSxDQUFHdy9CLElBQUksQ0FBQ2xuQyxTQUFMLENBQWVta0IsTUFBZixDQUNMN0gsRUFBRSxDQUFDNEMsTUFBSCxHQUFZNVgsUUFBWixFQURLLENBQ21CK2hDLEtBQUssQ0FBQ2psQixTQUR6QixDQUNvQ3pWLE1BRHBDLENBQVAsQ0FFRCxDQUVELE1BQU9qSCxLQUFQLENBQ0QsQ0F2R0QsQ0F5R0E7Ozs7Ozs7O0tBU0F3L0IsSUFBSSxDQUFDMkMsUUFBTCxDQUFnQixTQUFTQyxNQUFULENBQWlCLENBQy9CLEdBQUlwaUMsS0FBSSxDQUFHLEtBQVgsQ0FFQSxHQUFJcEcsRUFBQyxDQUFHNGxDLElBQUksQ0FBQ2tCLE1BQWIsQ0FDQSxHQUFJMWxDLEVBQUMsQ0FBR29uQyxNQUFNLENBQUNyQixPQUFmLENBRUE7QUFDQSxHQUFHbm5DLENBQUMsQ0FBQzNELElBQUYsRUFBVStFLENBQUMsQ0FBQy9FLElBQWYsQ0FBcUIsQ0FDbkIrSixJQUFJLENBQUlwRyxDQUFDLENBQUMzRCxJQUFGLEdBQVcrRSxDQUFDLENBQUMvRSxJQUFyQixDQUNELENBRkQsSUFFTyxJQUFHMkQsQ0FBQyxDQUFDb0QsVUFBRixDQUFhM00sTUFBYixHQUF3QjJLLENBQUMsQ0FBQ2dDLFVBQUYsQ0FBYTNNLE1BQXhDLENBQWdELENBQ3JEO0FBQ0EyUCxJQUFJLENBQUcsSUFBUCxDQUNBLEdBQUlxaUMsTUFBSixDQUFXQyxLQUFYLENBQ0EsSUFBSSxHQUFJL25DLEVBQUMsQ0FBRyxDQUFaLENBQWV5RixJQUFJLEVBQUl6RixDQUFDLENBQUdYLENBQUMsQ0FBQ29ELFVBQUYsQ0FBYTNNLE1BQXhDLENBQWdELEVBQUVrSyxDQUFsRCxDQUFxRCxDQUNuRDhuQyxLQUFLLENBQUd6b0MsQ0FBQyxDQUFDb0QsVUFBRixDQUFhekMsQ0FBYixDQUFSLENBQ0ErbkMsS0FBSyxDQUFHdG5DLENBQUMsQ0FBQ2dDLFVBQUYsQ0FBYXpDLENBQWIsQ0FBUixDQUNBLEdBQUc4bkMsS0FBSyxDQUFDLzdCLElBQU4sR0FBZWc4QixLQUFLLENBQUNoOEIsSUFBckIsRUFBNkIrN0IsS0FBSyxDQUFDbDVCLEtBQU4sR0FBZ0JtNUIsS0FBSyxDQUFDbjVCLEtBQXRELENBQTZELENBQzNEO0FBQ0FuSixJQUFJLENBQUcsS0FBUCxDQUNELENBQ0YsQ0FDRixDQUVELE1BQU9BLEtBQVAsQ0FDRCxDQXhCRCxDQTBCQTs7Ozs7Ozs7S0FTQXcvQixJQUFJLENBQUNvQyxNQUFMLENBQWMsU0FBU0QsS0FBVCxDQUFnQixDQUM1QixNQUFPQSxNQUFLLENBQUNRLFFBQU4sQ0FBZTNDLElBQWYsQ0FBUCxDQUNELENBRkQsQ0FJQTs7OztLQUtBQSxJQUFJLENBQUMrQyw0QkFBTCxDQUFvQyxVQUFXLENBQzdDOzs7Ozs7Ozs7O01BRDZDLENBYTdDO0FBQ0E7QUFDQTtBQUNBLE1BQU9ucUMsSUFBRyxDQUFDd25DLHVCQUFKLENBQTRCSixJQUFJLENBQUNsbkMsU0FBakMsQ0FBNEMsQ0FBQ2dPLElBQUksQ0FBRSxjQUFQLENBQTVDLENBQVAsQ0FDRCxDQWpCRCxDQW1CQTs7Ozs7O0tBT0FrNUIsSUFBSSxDQUFDZ0QsMEJBQUwsQ0FBa0MsVUFBVyxDQUMzQyxHQUFJcHhCLElBQUcsQ0FBR29ELElBQUksQ0FBQyxzQkFBRCxDQUFkLENBQ0EsSUFBSSxHQUFJNWEsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHNGxDLElBQUksQ0FBQ2YsVUFBTCxDQUFnQnB1QyxNQUFuQyxDQUEyQyxFQUFFdUosQ0FBN0MsQ0FBZ0QsQ0FDOUMsR0FBSTRuQyxJQUFHLENBQUdoQyxJQUFJLENBQUNmLFVBQUwsQ0FBZ0I3a0MsQ0FBaEIsQ0FBVixDQUNBLEdBQUc0bkMsR0FBRyxDQUFDcnRDLEVBQUosR0FBV2lkLEdBQWQsQ0FBbUIsQ0FDakIsR0FBSXF4QixJQUFHLENBQUdqRCxJQUFJLENBQUMrQyw0QkFBTCxHQUFvQzNpQyxRQUFwQyxFQUFWLENBQ0EsTUFBUWpJLE1BQUssQ0FBQ3dELElBQU4sQ0FBV3NJLFVBQVgsQ0FBc0IrOUIsR0FBRyxDQUFDa0Isb0JBQTFCLElBQW9ERCxHQUE1RCxDQUNELENBQ0YsQ0FDRCxNQUFPLE1BQVAsQ0FDRCxDQVZELENBWUEsTUFBT2pELEtBQVAsQ0FDRCxDQTFWRCxDQTRWQTs7Ozs7Ozs7Ozs7O0dBYUFwbkMsR0FBRyxDQUFDa25DLG1CQUFKLENBQTBCLFNBQVMxNUIsR0FBVCxDQUFjeTVCLFdBQWQsQ0FBMkIsQ0FDbkQ7QUFDQSxHQUFJMXJCLFFBQU8sQ0FBRyxFQUFkLENBQ0EsR0FBSTFmLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBRyxDQUFDZ1osSUFBSSxDQUFDd0csUUFBTCxDQUFjN04sR0FBZCxDQUFtQmk0Qix3QkFBbkIsQ0FBNkNscUIsT0FBN0MsQ0FBc0QxZixNQUF0RCxDQUFKLENBQW1FLENBQ2pFLEdBQUluQyxNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FBVSxrQ0FDcEIsNENBRFUsQ0FBWixDQUVBMkIsS0FBSyxDQUFDbUMsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5DLE1BQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSXNmLElBQUcsQ0FBR25FLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ2tLLFlBQXRCLENBQVYsQ0FDQSxHQUFHek0sR0FBRyxHQUFLaFosR0FBRyxDQUFDb2MsSUFBSixDQUFTd0ksYUFBcEIsQ0FBbUMsQ0FDakMsS0FBTSxJQUFJN3NCLE1BQUosQ0FBVSx5Q0FBVixDQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlxdkMsS0FBSSxDQUFHcG5DLEdBQUcsQ0FBQytuQyxpQkFBSixFQUFYLENBQ0FYLElBQUksQ0FBQ2xjLE9BQUwsQ0FBZTNQLE9BQU8sQ0FBQ2d2QixXQUFSLENBQ2JodkIsT0FBTyxDQUFDZ3ZCLFdBQVIsQ0FBb0I3aUMsVUFBcEIsQ0FBK0IsQ0FBL0IsQ0FEYSxDQUN1QixDQUR0QyxDQUVBLEdBQUk4aUMsT0FBTSxDQUFHanJDLEtBQUssQ0FBQ3dELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0I0UyxPQUFPLENBQUNrdkIsZ0JBQWhDLENBQWIsQ0FDQXJELElBQUksQ0FBQ1ksWUFBTCxDQUFvQndDLE1BQU0sQ0FBQ3poQyxLQUFQLEVBQXBCLENBQ0FxK0IsSUFBSSxDQUFDYSxZQUFMLENBQW9CMW9DLEtBQUssQ0FBQ3NWLElBQU4sQ0FBV3NFLFFBQVgsQ0FBb0JvQyxPQUFPLENBQUNtdkIsZ0JBQTVCLENBQXBCLENBQ0F0RCxJQUFJLENBQUN5QyxtQkFBTCxDQUEyQnJELHdCQUF3QixDQUNqRFksSUFBSSxDQUFDYSxZQUQ0QyxDQUM5QjFzQixPQUFPLENBQUNvdkIsbUJBRHNCLENBQ0QsSUFEQyxDQUFuRCxDQUVBdkQsSUFBSSxDQUFDYyxPQUFMLENBQWF4QixZQUFiLENBQTRCbm5DLEtBQUssQ0FBQ3NWLElBQU4sQ0FBV3NFLFFBQVgsQ0FBb0JvQyxPQUFPLENBQUNxdkIsb0JBQTVCLENBQTVCLENBQ0F4RCxJQUFJLENBQUNjLE9BQUwsQ0FBYTVjLFVBQWIsQ0FBMEJrYix3QkFBd0IsQ0FBQ1ksSUFBSSxDQUFDYyxPQUFMLENBQWF4QixZQUFkLENBQ2hEbnJCLE9BQU8sQ0FBQ3N2Qix1QkFEd0MsQ0FDZixLQURlLENBQWxELENBRUF6RCxJQUFJLENBQUM5aUIsU0FBTCxDQUFpQi9JLE9BQU8sQ0FBQ3V2QixhQUF6QixDQUVBLEdBQUkzQyxTQUFRLENBQUcsRUFBZixDQUNBLEdBQUc1c0IsT0FBTyxDQUFDd3ZCLG9CQUFSLEdBQWlDMW5DLFNBQXBDLENBQStDLENBQzdDOGtDLFFBQVEsQ0FBQ2prQyxJQUFULENBQWMyUSxJQUFJLENBQUN1RSxhQUFMLENBQW1CbUMsT0FBTyxDQUFDd3ZCLG9CQUEzQixDQUFkLEVBQ0QsQ0FDRCxHQUFHeHZCLE9BQU8sQ0FBQ3l2Qiw0QkFBUixHQUF5QzNuQyxTQUE1QyxDQUF1RCxDQUNyRDhrQyxRQUFRLENBQUNqa0MsSUFBVCxDQUFjMlEsSUFBSSxDQUFDcUYscUJBQUwsQ0FDWnFCLE9BQU8sQ0FBQ3l2Qiw0QkFESSxDQUFkLEVBRUQsQ0FDRCxHQUFHenZCLE9BQU8sQ0FBQzB2QixvQkFBUixHQUFpQzVuQyxTQUFwQyxDQUErQyxDQUM3QzhrQyxRQUFRLENBQUNqa0MsSUFBVCxDQUFjMlEsSUFBSSxDQUFDdUUsYUFBTCxDQUFtQm1DLE9BQU8sQ0FBQzB2QixvQkFBM0IsQ0FBZCxFQUNELENBQ0QsR0FBRzF2QixPQUFPLENBQUMydkIsNEJBQVIsR0FBeUM3bkMsU0FBNUMsQ0FBdUQsQ0FDckQ4a0MsUUFBUSxDQUFDamtDLElBQVQsQ0FBYzJRLElBQUksQ0FBQ3FGLHFCQUFMLENBQ1pxQixPQUFPLENBQUMydkIsNEJBREksQ0FBZCxFQUVELENBQ0QsR0FBRy9DLFFBQVEsQ0FBQ2x3QyxNQUFULENBQWtCLENBQXJCLENBQXdCLENBQ3RCLEtBQU0sSUFBSUYsTUFBSixDQUFVLHVEQUNkLGtEQURJLENBQU4sQ0FFRCxDQUNELEdBQUdvd0MsUUFBUSxDQUFDbHdDLE1BQVQsQ0FBa0IsQ0FBckIsQ0FBd0IsQ0FDdEIsS0FBTSxJQUFJRixNQUFKLENBQVUsdURBQ2QseURBREksQ0FBTixDQUVELENBQ0RxdkMsSUFBSSxDQUFDZSxRQUFMLENBQWNDLFNBQWQsQ0FBMEJELFFBQVEsQ0FBQyxDQUFELENBQWxDLENBQ0FmLElBQUksQ0FBQ2UsUUFBTCxDQUFjRSxRQUFkLENBQXlCRixRQUFRLENBQUMsQ0FBRCxDQUFqQyxDQUVBO0FBQ0FmLElBQUksQ0FBQ2lDLGNBQUwsQ0FBc0I5dEIsT0FBTyxDQUFDOHRCLGNBQTlCLENBRUEsR0FBR3BDLFdBQUgsQ0FBZ0IsQ0FDZDtBQUNBRyxJQUFJLENBQUM1cUIsRUFBTCxDQUFVLElBQVYsQ0FDQSxHQUFHNHFCLElBQUksQ0FBQ2EsWUFBTCxHQUFxQjdyQixLQUF4QixDQUE4QixDQUM1QixHQUFJcEQsSUFBRyxDQUFHb0QsSUFBSSxDQUFDZ3JCLElBQUksQ0FBQ2EsWUFBTixDQUFkLENBQ0EsT0FBT2p2QixHQUFQLEVBQ0EsSUFBSyx1QkFBTCxDQUNFb3VCLElBQUksQ0FBQzVxQixFQUFMLENBQVVqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNtUyxJQUFULENBQWNwd0IsTUFBZCxFQUFWLENBQ0EsTUFDRixJQUFLLHNCQUFMLENBQ0U2b0MsSUFBSSxDQUFDNXFCLEVBQUwsQ0FBVWpkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBUzZULEdBQVQsQ0FBYTl4QixNQUFiLEVBQVYsQ0FDQSxNQUNGLElBQUsseUJBQUwsQ0FDRTZvQyxJQUFJLENBQUM1cUIsRUFBTCxDQUFVamQsS0FBSyxDQUFDaWQsRUFBTixDQUFTYSxNQUFULENBQWdCOWUsTUFBaEIsRUFBVixDQUNBLE1BQ0YsSUFBSyx5QkFBTCxDQUNFNm9DLElBQUksQ0FBQzVxQixFQUFMLENBQVVqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNtdEIsTUFBVCxDQUFnQnByQyxNQUFoQixFQUFWLENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0U2b0MsSUFBSSxDQUFDNXFCLEVBQUwsQ0FBVWpkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU2dVLE1BQVQsQ0FBZ0JqeUIsTUFBaEIsRUFBVixDQUNBLE1BQ0YsSUFBSyxZQUFMLENBQ0U2b0MsSUFBSSxDQUFDNXFCLEVBQUwsQ0FBVWpkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU2EsTUFBVCxDQUFnQjllLE1BQWhCLEVBQVYsQ0FDQSxNQWxCRixDQW9CRCxDQUNELEdBQUc2b0MsSUFBSSxDQUFDNXFCLEVBQUwsR0FBWSxJQUFmLENBQXFCLENBQ25CLEdBQUk5aUIsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUseUNBQ3BCLHdCQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQ3V1QyxZQUFOLENBQXFCYixJQUFJLENBQUNhLFlBQTFCLENBQ0EsS0FBTXZ1QyxNQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlpTixNQUFLLENBQUdrTyxJQUFJLENBQUMrRCxLQUFMLENBQVd3dUIsSUFBSSxDQUFDaUMsY0FBaEIsQ0FBWixDQUNBakMsSUFBSSxDQUFDNXFCLEVBQUwsQ0FBUXJKLE1BQVIsQ0FBZXhNLEtBQUssQ0FBQ2EsUUFBTixFQUFmLEVBQ0QsQ0FFRDtBQUNBLEdBQUkyakMsSUFBRyxDQUFHNXJDLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU21TLElBQVQsQ0FBY3B3QixNQUFkLEVBQVYsQ0FDQTZvQyxJQUFJLENBQUNrQixNQUFMLENBQVlDLFFBQVosQ0FBdUIsU0FBU0MsRUFBVCxDQUFhLENBQ2xDLE1BQU9qQyxjQUFhLENBQUNhLElBQUksQ0FBQ2tCLE1BQU4sQ0FBY0UsRUFBZCxDQUFwQixDQUNELENBRkQsQ0FHQXBCLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWUcsUUFBWixDQUF1QixTQUFTbGtDLElBQVQsQ0FBZSxDQUNwQ21rQyxrQkFBa0IsQ0FBQyxDQUFDbmtDLElBQUQsQ0FBRCxDQUFsQixDQUNBNmlDLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWTFqQyxVQUFaLENBQXVCVixJQUF2QixDQUE0QkssSUFBNUIsRUFDRCxDQUhELENBSUE2aUMsSUFBSSxDQUFDa0IsTUFBTCxDQUFZMWpDLFVBQVosQ0FBeUI1RSxHQUFHLENBQUM2bEMsb0JBQUosQ0FBeUJ0cUIsT0FBTyxDQUFDNnZCLFVBQWpDLENBQTZDRCxHQUE3QyxDQUF6QixDQUNBLEdBQUc1dkIsT0FBTyxDQUFDOHZCLGtCQUFYLENBQStCLENBQzdCakUsSUFBSSxDQUFDa0IsTUFBTCxDQUFZUSxRQUFaLENBQXVCdnRCLE9BQU8sQ0FBQzh2QixrQkFBL0IsQ0FDRCxDQUNEakUsSUFBSSxDQUFDa0IsTUFBTCxDQUFZenFDLElBQVosQ0FBbUJzdEMsR0FBRyxDQUFDL3JCLE1BQUosR0FBYXJXLEtBQWIsRUFBbkIsQ0FFQTtBQUNBLEdBQUl1aUMsSUFBRyxDQUFHL3JDLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU21TLElBQVQsQ0FBY3B3QixNQUFkLEVBQVYsQ0FDQTZvQyxJQUFJLENBQUN1QixPQUFMLENBQWFKLFFBQWIsQ0FBd0IsU0FBU0MsRUFBVCxDQUFhLENBQ25DLE1BQU9qQyxjQUFhLENBQUNhLElBQUksQ0FBQ3VCLE9BQU4sQ0FBZUgsRUFBZixDQUFwQixDQUNELENBRkQsQ0FHQXBCLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYUYsUUFBYixDQUF3QixTQUFTbGtDLElBQVQsQ0FBZSxDQUNyQ21rQyxrQkFBa0IsQ0FBQyxDQUFDbmtDLElBQUQsQ0FBRCxDQUFsQixDQUNBNmlDLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYS9qQyxVQUFiLENBQXdCVixJQUF4QixDQUE2QkssSUFBN0IsRUFDRCxDQUhELENBSUE2aUMsSUFBSSxDQUFDdUIsT0FBTCxDQUFhL2pDLFVBQWIsQ0FBMEI1RSxHQUFHLENBQUM2bEMsb0JBQUosQ0FBeUJ0cUIsT0FBTyxDQUFDZ3dCLFdBQWpDLENBQThDRCxHQUE5QyxDQUExQixDQUNBLEdBQUcvdkIsT0FBTyxDQUFDaXdCLG1CQUFYLENBQWdDLENBQzlCcEUsSUFBSSxDQUFDdUIsT0FBTCxDQUFhRyxRQUFiLENBQXdCdnRCLE9BQU8sQ0FBQ2l3QixtQkFBaEMsQ0FDRCxDQUNEcEUsSUFBSSxDQUFDdUIsT0FBTCxDQUFhOXFDLElBQWIsQ0FBb0J5dEMsR0FBRyxDQUFDbHNCLE1BQUosR0FBYXJXLEtBQWIsRUFBcEIsQ0FFQTtBQUNBLEdBQUd3UyxPQUFPLENBQUNrd0IsY0FBWCxDQUEyQixDQUN6QnJFLElBQUksQ0FBQ2YsVUFBTCxDQUFrQnJtQyxHQUFHLENBQUMwckMsNkJBQUosQ0FBa0Nud0IsT0FBTyxDQUFDa3dCLGNBQTFDLENBQWxCLENBQ0QsQ0FGRCxJQUVPLENBQ0xyRSxJQUFJLENBQUNmLFVBQUwsQ0FBa0IsRUFBbEIsQ0FDRCxDQUVEO0FBQ0FlLElBQUksQ0FBQ2xuQyxTQUFMLENBQWlCRixHQUFHLENBQUN3bEIsaUJBQUosQ0FBc0JqSyxPQUFPLENBQUNvd0Isb0JBQTlCLENBQWpCLENBRUEsTUFBT3ZFLEtBQVAsQ0FDRCxDQTNJRCxDQTZJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdURBcG5DLEdBQUcsQ0FBQzByQyw2QkFBSixDQUFvQyxTQUFTekMsSUFBVCxDQUFlLENBQ2pELEdBQUlyaEMsS0FBSSxDQUFHLEVBQVgsQ0FDQSxJQUFJLEdBQUlwRyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUd5bkMsSUFBSSxDQUFDbDRCLEtBQUwsQ0FBVzlZLE1BQTlCLENBQXNDLEVBQUV1SixDQUF4QyxDQUEyQyxDQUN6QztBQUNBLEdBQUlvcUMsT0FBTSxDQUFHM0MsSUFBSSxDQUFDbDRCLEtBQUwsQ0FBV3ZQLENBQVgsQ0FBYixDQUNBLElBQUksR0FBSTZuQixHQUFFLENBQUcsQ0FBYixDQUFnQkEsRUFBRSxDQUFHdWlCLE1BQU0sQ0FBQzc2QixLQUFQLENBQWE5WSxNQUFsQyxDQUEwQyxFQUFFb3hCLEVBQTVDLENBQWdELENBQzlDemhCLElBQUksQ0FBQzFELElBQUwsQ0FBVWxFLEdBQUcsQ0FBQ3NtQyw0QkFBSixDQUFpQ3NGLE1BQU0sQ0FBQzc2QixLQUFQLENBQWFzWSxFQUFiLENBQWpDLENBQVYsRUFDRCxDQUNGLENBRUQsTUFBT3poQixLQUFQLENBQ0QsQ0FYRCxDQWFBOzs7Ozs7R0FPQTVILEdBQUcsQ0FBQ3NtQyw0QkFBSixDQUFtQyxTQUFTOEMsR0FBVCxDQUFjLENBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBSWpqQyxFQUFDLENBQUcsRUFBUixDQUNBQSxDQUFDLENBQUNwSyxFQUFGLENBQU84WSxJQUFJLENBQUNzRSxRQUFMLENBQWNpd0IsR0FBRyxDQUFDcjRCLEtBQUosQ0FBVSxDQUFWLEVBQWFBLEtBQTNCLENBQVAsQ0FDQTVLLENBQUMsQ0FBQzBsQyxRQUFGLENBQWEsS0FBYixDQUNBLEdBQUd6QyxHQUFHLENBQUNyNEIsS0FBSixDQUFVLENBQVYsRUFBYTdDLElBQWIsR0FBc0IyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUUsT0FBbkMsQ0FBNEMsQ0FDMUNsUCxDQUFDLENBQUMwbEMsUUFBRixDQUFjekMsR0FBRyxDQUFDcjRCLEtBQUosQ0FBVSxDQUFWLEVBQWFBLEtBQWIsQ0FBbUJySixVQUFuQixDQUE4QixDQUE5QixJQUFxQyxJQUFuRCxDQUNBdkIsQ0FBQyxDQUFDNEssS0FBRixDQUFVcTRCLEdBQUcsQ0FBQ3I0QixLQUFKLENBQVUsQ0FBVixFQUFhQSxLQUF2QixDQUNELENBSEQsSUFHTyxDQUNMNUssQ0FBQyxDQUFDNEssS0FBRixDQUFVcTRCLEdBQUcsQ0FBQ3I0QixLQUFKLENBQVUsQ0FBVixFQUFhQSxLQUF2QixDQUNELENBQ0Q7QUFDQSxHQUFHNUssQ0FBQyxDQUFDcEssRUFBRixHQUFRcWdCLEtBQVgsQ0FBaUIsQ0FDZmpXLENBQUMsQ0FBQ3JQLElBQUYsQ0FBU3NsQixJQUFJLENBQUNqVyxDQUFDLENBQUNwSyxFQUFILENBQWIsQ0FFQTtBQUNBLEdBQUdvSyxDQUFDLENBQUNyUCxJQUFGLEdBQVcsVUFBZCxDQUEwQixDQUN4QjtBQUNBLEdBQUlnMUMsR0FBRSxDQUFHajNCLElBQUksQ0FBQ2lELE9BQUwsQ0FBYTNSLENBQUMsQ0FBQzRLLEtBQWYsQ0FBVCxDQUNBLEdBQUl1RyxHQUFFLENBQUcsSUFBVCxDQUNBLEdBQUl5MEIsR0FBRSxDQUFHLElBQVQsQ0FDQSxHQUFHRCxFQUFFLENBQUMvNkIsS0FBSCxDQUFTOVksTUFBVCxDQUFrQixDQUFyQixDQUF3QixDQUN0QjtBQUNBO0FBQ0E7QUFDQXFmLEVBQUUsQ0FBR3cwQixFQUFFLENBQUMvNkIsS0FBSCxDQUFTckosVUFBVCxDQUFvQixDQUFwQixDQUFMLENBQ0Fxa0MsRUFBRSxDQUFHRCxFQUFFLENBQUMvNkIsS0FBSCxDQUFTOVksTUFBVCxDQUFrQixDQUFsQixDQUFzQjZ6QyxFQUFFLENBQUMvNkIsS0FBSCxDQUFTckosVUFBVCxDQUFvQixDQUFwQixDQUF0QixDQUErQyxDQUFwRCxDQUNELENBQ0Q7QUFDQXZCLENBQUMsQ0FBQzZsQyxnQkFBRixDQUFxQixDQUFDMTBCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQXJDLENBQ0FuUixDQUFDLENBQUM4bEMsY0FBRixDQUFtQixDQUFDMzBCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQW5DLENBQ0FuUixDQUFDLENBQUMrbEMsZUFBRixDQUFvQixDQUFDNTBCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQXBDLENBQ0FuUixDQUFDLENBQUNnbUMsZ0JBQUYsQ0FBcUIsQ0FBQzcwQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUFyQyxDQUNBblIsQ0FBQyxDQUFDaW1DLFlBQUYsQ0FBaUIsQ0FBQzkwQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUFqQyxDQUNBblIsQ0FBQyxDQUFDa21DLFdBQUYsQ0FBZ0IsQ0FBQy8wQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUFoQyxDQUNBblIsQ0FBQyxDQUFDbW1DLE9BQUYsQ0FBWSxDQUFDaDFCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQTVCLENBQ0FuUixDQUFDLENBQUNvbUMsWUFBRixDQUFpQixDQUFDajFCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQWpDLENBQ0FuUixDQUFDLENBQUNxbUMsWUFBRixDQUFpQixDQUFDVCxFQUFFLENBQUcsSUFBTixJQUFnQixJQUFqQyxDQUNELENBdEJELElBc0JPLElBQUc1bEMsQ0FBQyxDQUFDclAsSUFBRixHQUFXLGtCQUFkLENBQWtDLENBQ3ZDO0FBQ0E7QUFDQSxHQUFJZzFDLEdBQUUsQ0FBR2ozQixJQUFJLENBQUNpRCxPQUFMLENBQWEzUixDQUFDLENBQUM0SyxLQUFmLENBQVQsQ0FDQTtBQUNBLEdBQUcrNkIsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUzlZLE1BQVQsQ0FBa0IsQ0FBbEIsRUFBdUI2ekMsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUyxDQUFULEVBQVk3QyxJQUFaLEdBQXFCMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVFLE9BQXpELENBQWtFLENBQ2hFbFAsQ0FBQyxDQUFDc21DLEVBQUYsQ0FBUVgsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUyxDQUFULEVBQVlBLEtBQVosQ0FBa0JySixVQUFsQixDQUE2QixDQUE3QixJQUFvQyxJQUE1QyxDQUNELENBRkQsSUFFTyxDQUNMdkIsQ0FBQyxDQUFDc21DLEVBQUYsQ0FBTyxLQUFQLENBQ0QsQ0FDRDtBQUNBLEdBQUkxN0IsTUFBSyxDQUFHLElBQVosQ0FDQSxHQUFHKzZCLEVBQUUsQ0FBQy82QixLQUFILENBQVM5WSxNQUFULENBQWtCLENBQWxCLEVBQXVCNnpDLEVBQUUsQ0FBQy82QixLQUFILENBQVMsQ0FBVCxFQUFZN0MsSUFBWixHQUFxQjJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUF6RCxDQUFrRSxDQUNoRXZFLEtBQUssQ0FBRys2QixFQUFFLENBQUMvNkIsS0FBSCxDQUFTLENBQVQsRUFBWUEsS0FBcEIsQ0FDRCxDQUZELElBRU8sSUFBRys2QixFQUFFLENBQUMvNkIsS0FBSCxDQUFTOVksTUFBVCxDQUFrQixDQUFyQixDQUF3QixDQUM3QjhZLEtBQUssQ0FBRys2QixFQUFFLENBQUMvNkIsS0FBSCxDQUFTLENBQVQsRUFBWUEsS0FBcEIsQ0FDRCxDQUNELEdBQUdBLEtBQUssR0FBSyxJQUFiLENBQW1CLENBQ2pCNUssQ0FBQyxDQUFDdW1DLGlCQUFGLENBQXNCNzNCLElBQUksQ0FBQ3VHLFlBQUwsQ0FBa0JySyxLQUFsQixDQUF0QixDQUNELENBQ0YsQ0FwQk0sSUFvQkEsSUFBRzVLLENBQUMsQ0FBQ3JQLElBQUYsR0FBVyxhQUFkLENBQTZCLENBQ2xDO0FBQ0E7QUFDQSxHQUFJZzFDLEdBQUUsQ0FBR2ozQixJQUFJLENBQUNpRCxPQUFMLENBQWEzUixDQUFDLENBQUM0SyxLQUFmLENBQVQsQ0FDQSxJQUFJLEdBQUkrYSxHQUFFLENBQUcsQ0FBYixDQUFnQkEsRUFBRSxDQUFHZ2dCLEVBQUUsQ0FBQy82QixLQUFILENBQVM5WSxNQUE5QixDQUFzQyxFQUFFNnpCLEVBQXhDLENBQTRDLENBQzFDLEdBQUk5UyxJQUFHLENBQUduRSxJQUFJLENBQUNzRSxRQUFMLENBQWMyeUIsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUythLEVBQVQsRUFBYS9hLEtBQTNCLENBQVYsQ0FDQSxHQUFHaUksR0FBRyxHQUFJb0QsS0FBVixDQUFnQixDQUNkalcsQ0FBQyxDQUFDaVcsSUFBSSxDQUFDcEQsR0FBRCxDQUFMLENBQUQsQ0FBZSxJQUFmLENBQ0QsQ0FGRCxJQUVPLENBQ0w3UyxDQUFDLENBQUM2UyxHQUFELENBQUQsQ0FBUyxJQUFULENBQ0QsQ0FDRixDQUNGLENBWk0sSUFZQSxJQUFHN1MsQ0FBQyxDQUFDclAsSUFBRixHQUFXLFlBQWQsQ0FBNEIsQ0FDakM7QUFDQTtBQUNBLEdBQUlnMUMsR0FBRSxDQUFHajNCLElBQUksQ0FBQ2lELE9BQUwsQ0FBYTNSLENBQUMsQ0FBQzRLLEtBQWYsQ0FBVCxDQUNBLEdBQUl1RyxHQUFFLENBQUcsSUFBVCxDQUNBLEdBQUd3MEIsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUzlZLE1BQVQsQ0FBa0IsQ0FBckIsQ0FBd0IsQ0FDdEI7QUFDQTtBQUNBO0FBQ0FxZixFQUFFLENBQUd3MEIsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBU3JKLFVBQVQsQ0FBb0IsQ0FBcEIsQ0FBTCxDQUNELENBQ0Q7QUFDQXZCLENBQUMsQ0FBQ3pPLE1BQUYsQ0FBVyxDQUFDNGYsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBM0IsQ0FDQW5SLENBQUMsQ0FBQ3dtQyxNQUFGLENBQVcsQ0FBQ3IxQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUEzQixDQUNBblIsQ0FBQyxDQUFDeW1DLEtBQUYsQ0FBVSxDQUFDdDFCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQTFCLENBQ0FuUixDQUFDLENBQUMwbUMsT0FBRixDQUFZLENBQUN2MUIsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBNUIsQ0FDQW5SLENBQUMsQ0FBQzJtQyxRQUFGLENBQWEsQ0FBQ3gxQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUE3QixDQUNBblIsQ0FBQyxDQUFDNG1DLEtBQUYsQ0FBVSxDQUFDejFCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQTFCLENBQ0FuUixDQUFDLENBQUM2bUMsT0FBRixDQUFZLENBQUMxMUIsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBNUIsQ0FDQW5SLENBQUMsQ0FBQzhtQyxLQUFGLENBQVUsQ0FBQzMxQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUExQixDQUNELENBcEJNLElBb0JBLElBQ0xuUixDQUFDLENBQUNyUCxJQUFGLEdBQVcsZ0JBQVgsRUFDQXFQLENBQUMsQ0FBQ3JQLElBQUYsR0FBVyxlQUZOLENBRXVCLENBQzVCO0FBQ0FxUCxDQUFDLENBQUMrbUMsUUFBRixDQUFhLEVBQWIsQ0FFQTtBQUNBLEdBQUlDLEdBQUosQ0FDQSxHQUFJckIsR0FBRSxDQUFHajNCLElBQUksQ0FBQ2lELE9BQUwsQ0FBYTNSLENBQUMsQ0FBQzRLLEtBQWYsQ0FBVCxDQUNBLElBQUksR0FBSTVPLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzJwQyxFQUFFLENBQUMvNkIsS0FBSCxDQUFTOVksTUFBNUIsQ0FBb0MsRUFBRWtLLENBQXRDLENBQXlDLENBQ3ZDO0FBQ0FnckMsRUFBRSxDQUFHckIsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUzVPLENBQVQsQ0FBTCxDQUVBLEdBQUlpckMsUUFBTyxDQUFHLENBQ1psL0IsSUFBSSxDQUFFaS9CLEVBQUUsQ0FBQ2ovQixJQURHLENBRVo2QyxLQUFLLENBQUVvOEIsRUFBRSxDQUFDcDhCLEtBRkUsQ0FBZCxDQUlBNUssQ0FBQyxDQUFDK21DLFFBQUYsQ0FBV2hwQyxJQUFYLENBQWdCa3BDLE9BQWhCLEVBRUE7QUFDQSxPQUFPRCxFQUFFLENBQUNqL0IsSUFBVixFQUNBO0FBQ0EsSUFBSyxFQUFMLENBQ0E7QUFDQSxJQUFLLEVBQUwsQ0FDQTtBQUNBLElBQUssRUFBTCxDQUNFLE1BQ0Y7QUFDQSxJQUFLLEVBQUwsQ0FDRTtBQUNBay9CLE9BQU8sQ0FBQ2o3QixFQUFSLENBQWE1UyxLQUFLLENBQUN3RCxJQUFOLENBQVcwUCxTQUFYLENBQXFCMDZCLEVBQUUsQ0FBQ3A4QixLQUF4QixDQUFiLENBQ0EsTUFDRjtBQUNBLElBQUssRUFBTCxDQUNFcThCLE9BQU8sQ0FBQ3AwQixHQUFSLENBQWNuRSxJQUFJLENBQUNzRSxRQUFMLENBQWNnMEIsRUFBRSxDQUFDcDhCLEtBQWpCLENBQWQsQ0FDQSxNQUNGLFFBQ0U7QUFsQkYsQ0FvQkQsQ0FDRixDQXpDTSxJQXlDQSxJQUFHNUssQ0FBQyxDQUFDclAsSUFBRixHQUFXLHNCQUFkLENBQXNDLENBQzNDO0FBQ0E7QUFDQSxHQUFJZzFDLEdBQUUsQ0FBR2ozQixJQUFJLENBQUNpRCxPQUFMLENBQWEzUixDQUFDLENBQUM0SyxLQUFmLENBQVQsQ0FDQTVLLENBQUMsQ0FBQ21rQyxvQkFBRixDQUF5Qi9xQyxLQUFLLENBQUN3RCxJQUFOLENBQVd3SSxVQUFYLENBQXNCdWdDLEVBQUUsQ0FBQy82QixLQUF6QixDQUF6QixDQUNELENBQ0YsQ0FDRCxNQUFPNUssRUFBUCxDQUNELENBOUlELENBZ0pBOzs7Ozs7Ozs7Ozs7R0FhQW5HLEdBQUcsQ0FBQzJuQyw0QkFBSixDQUFtQyxTQUFTbjZCLEdBQVQsQ0FBY3k1QixXQUFkLENBQTJCLENBQzVEO0FBQ0EsR0FBSTFyQixRQUFPLENBQUcsRUFBZCxDQUNBLEdBQUkxZixPQUFNLENBQUcsRUFBYixDQUNBLEdBQUcsQ0FBQ2daLElBQUksQ0FBQ3dHLFFBQUwsQ0FBYzdOLEdBQWQsQ0FBbUJvNEIsNkJBQW5CLENBQWtEcnFCLE9BQWxELENBQTJEMWYsTUFBM0QsQ0FBSixDQUF3RSxDQUN0RSxHQUFJbkMsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsNENBQ3BCLHFEQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQ21DLE1BQU4sQ0FBZUEsTUFBZixDQUNBLEtBQU1uQyxNQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlzZixJQUFHLENBQUduRSxJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUNrSyxZQUF0QixDQUFWLENBQ0EsR0FBR3pNLEdBQUcsR0FBS2haLEdBQUcsQ0FBQ29jLElBQUosQ0FBU3dJLGFBQXBCLENBQW1DLENBQ2pDLEtBQU0sSUFBSTdzQixNQUFKLENBQVUseUNBQVYsQ0FBTixDQUNELENBRUQ7QUFDQSxHQUFJOHZDLElBQUcsQ0FBRzduQyxHQUFHLENBQUNxdEMsMEJBQUosRUFBVixDQUNBeEYsR0FBRyxDQUFDM2MsT0FBSixDQUFjM1AsT0FBTyxDQUFDK3hCLFVBQVIsQ0FBcUIveEIsT0FBTyxDQUFDK3hCLFVBQVIsQ0FBbUI1bEMsVUFBbkIsQ0FBOEIsQ0FBOUIsQ0FBckIsQ0FBd0QsQ0FBdEUsQ0FDQW1nQyxHQUFHLENBQUNJLFlBQUosQ0FBbUIxb0MsS0FBSyxDQUFDc1YsSUFBTixDQUFXc0UsUUFBWCxDQUFvQm9DLE9BQU8sQ0FBQ2d5QixlQUE1QixDQUFuQixDQUNBMUYsR0FBRyxDQUFDZ0MsbUJBQUosQ0FBMEJyRCx3QkFBd0IsQ0FDaERxQixHQUFHLENBQUNJLFlBRDRDLENBQzlCMXNCLE9BQU8sQ0FBQ2l5QixrQkFEc0IsQ0FDRixJQURFLENBQWxELENBRUEzRixHQUFHLENBQUNLLE9BQUosQ0FBWXhCLFlBQVosQ0FBMkJubkMsS0FBSyxDQUFDc1YsSUFBTixDQUFXc0UsUUFBWCxDQUFvQm9DLE9BQU8sQ0FBQ2d5QixlQUE1QixDQUEzQixDQUNBMUYsR0FBRyxDQUFDSyxPQUFKLENBQVk1YyxVQUFaLENBQXlCa2Isd0JBQXdCLENBQy9DcUIsR0FBRyxDQUFDSyxPQUFKLENBQVl4QixZQURtQyxDQUNyQm5yQixPQUFPLENBQUNpeUIsa0JBRGEsQ0FDTyxLQURQLENBQWpELENBRUEzRixHQUFHLENBQUN2akIsU0FBSixDQUFnQi9JLE9BQU8sQ0FBQ2t5QixZQUF4QixDQUVBO0FBQ0E1RixHQUFHLENBQUM2Rix3QkFBSixDQUErQm55QixPQUFPLENBQUNteUIsd0JBQXZDLENBRUEsR0FBR3pHLFdBQUgsQ0FBZ0IsQ0FDZDtBQUNBWSxHQUFHLENBQUNyckIsRUFBSixDQUFTLElBQVQsQ0FDQSxHQUFHcXJCLEdBQUcsQ0FBQ0ksWUFBSixHQUFvQjdyQixLQUF2QixDQUE2QixDQUMzQixHQUFJcEQsSUFBRyxDQUFHb0QsSUFBSSxDQUFDeXJCLEdBQUcsQ0FBQ0ksWUFBTCxDQUFkLENBQ0EsT0FBT2p2QixHQUFQLEVBQ0EsSUFBSyx1QkFBTCxDQUNFNnVCLEdBQUcsQ0FBQ3JyQixFQUFKLENBQVNqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNtUyxJQUFULENBQWNwd0IsTUFBZCxFQUFULENBQ0EsTUFDRixJQUFLLHNCQUFMLENBQ0VzcEMsR0FBRyxDQUFDcnJCLEVBQUosQ0FBU2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBUzZULEdBQVQsQ0FBYTl4QixNQUFiLEVBQVQsQ0FDQSxNQUNGLElBQUsseUJBQUwsQ0FDRXNwQyxHQUFHLENBQUNyckIsRUFBSixDQUFTamQsS0FBSyxDQUFDaWQsRUFBTixDQUFTYSxNQUFULENBQWdCOWUsTUFBaEIsRUFBVCxDQUNBLE1BQ0YsSUFBSyx5QkFBTCxDQUNFc3BDLEdBQUcsQ0FBQ3JyQixFQUFKLENBQVNqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNtdEIsTUFBVCxDQUFnQnByQyxNQUFoQixFQUFULENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0VzcEMsR0FBRyxDQUFDcnJCLEVBQUosQ0FBU2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU2dVLE1BQVQsQ0FBZ0JqeUIsTUFBaEIsRUFBVCxDQUNBLE1BQ0YsSUFBSyxZQUFMLENBQ0VzcEMsR0FBRyxDQUFDcnJCLEVBQUosQ0FBU2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU2EsTUFBVCxDQUFnQjllLE1BQWhCLEVBQVQsQ0FDQSxNQWxCRixDQW9CRCxDQUNELEdBQUdzcEMsR0FBRyxDQUFDcnJCLEVBQUosR0FBVyxJQUFkLENBQW9CLENBQ2xCLEdBQUk5aUIsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsbURBQ3BCLHdCQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQ3V1QyxZQUFOLENBQXFCSixHQUFHLENBQUNJLFlBQXpCLENBQ0EsS0FBTXZ1QyxNQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlpTixNQUFLLENBQUdrTyxJQUFJLENBQUMrRCxLQUFMLENBQVdpdkIsR0FBRyxDQUFDNkYsd0JBQWYsQ0FBWixDQUNBN0YsR0FBRyxDQUFDcnJCLEVBQUosQ0FBT3JKLE1BQVAsQ0FBY3hNLEtBQUssQ0FBQ2EsUUFBTixFQUFkLEVBQ0QsQ0FFRDtBQUNBLEdBQUk4akMsSUFBRyxDQUFHL3JDLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU21TLElBQVQsQ0FBY3B3QixNQUFkLEVBQVYsQ0FDQXNwQyxHQUFHLENBQUNjLE9BQUosQ0FBWUosUUFBWixDQUF1QixTQUFTQyxFQUFULENBQWEsQ0FDbEMsTUFBT2pDLGNBQWEsQ0FBQ3NCLEdBQUcsQ0FBQ2MsT0FBTCxDQUFjSCxFQUFkLENBQXBCLENBQ0QsQ0FGRCxDQUdBWCxHQUFHLENBQUNjLE9BQUosQ0FBWUYsUUFBWixDQUF1QixTQUFTbGtDLElBQVQsQ0FBZSxDQUNwQ21rQyxrQkFBa0IsQ0FBQyxDQUFDbmtDLElBQUQsQ0FBRCxDQUFsQixDQUNBc2pDLEdBQUcsQ0FBQ2MsT0FBSixDQUFZL2pDLFVBQVosQ0FBdUJWLElBQXZCLENBQTRCSyxJQUE1QixFQUNELENBSEQsQ0FJQXNqQyxHQUFHLENBQUNjLE9BQUosQ0FBWS9qQyxVQUFaLENBQXlCNUUsR0FBRyxDQUFDNmxDLG9CQUFKLENBQ3ZCdHFCLE9BQU8sQ0FBQ295QiwrQkFEZSxDQUNrQnJDLEdBRGxCLENBQXpCLENBRUF6RCxHQUFHLENBQUNjLE9BQUosQ0FBWTlxQyxJQUFaLENBQW1CeXRDLEdBQUcsQ0FBQ2xzQixNQUFKLEdBQWFyVyxLQUFiLEVBQW5CLENBRUE7QUFDQTgrQixHQUFHLENBQUMzbkMsU0FBSixDQUFnQkYsR0FBRyxDQUFDd2xCLGlCQUFKLENBQXNCakssT0FBTyxDQUFDb3dCLG9CQUE5QixDQUFoQixDQUVBO0FBQ0E5RCxHQUFHLENBQUMrRixZQUFKLENBQW1CLFNBQVNwRixFQUFULENBQWEsQ0FDOUIsTUFBT2pDLGNBQWEsQ0FBQ3NCLEdBQUQsQ0FBTVcsRUFBTixDQUFwQixDQUNELENBRkQsQ0FHQVgsR0FBRyxDQUFDZ0csWUFBSixDQUFtQixTQUFTdHBDLElBQVQsQ0FBZSxDQUNoQ21rQyxrQkFBa0IsQ0FBQyxDQUFDbmtDLElBQUQsQ0FBRCxDQUFsQixDQUNBc2pDLEdBQUcsQ0FBQ2pqQyxVQUFKLENBQWVWLElBQWYsQ0FBb0JLLElBQXBCLEVBQ0QsQ0FIRCxDQUlBc2pDLEdBQUcsQ0FBQ2pqQyxVQUFKLENBQWlCNUUsR0FBRyxDQUFDa21DLG9CQUFKLENBQ2YzcUIsT0FBTyxDQUFDdXlCLGtDQUFSLEVBQThDLEVBRC9CLENBQWpCLENBR0EsTUFBT2pHLElBQVAsQ0FDRCxDQWpHRCxDQW1HQTs7Ozs7O0dBT0E3bkMsR0FBRyxDQUFDcXRDLDBCQUFKLENBQWlDLFVBQVcsQ0FDMUMsR0FBSXhGLElBQUcsQ0FBRyxFQUFWLENBQ0FBLEdBQUcsQ0FBQzNjLE9BQUosQ0FBYyxJQUFkLENBQ0EyYyxHQUFHLENBQUNJLFlBQUosQ0FBbUIsSUFBbkIsQ0FDQUosR0FBRyxDQUFDdmpCLFNBQUosQ0FBZ0IsSUFBaEIsQ0FDQXVqQixHQUFHLENBQUNLLE9BQUosQ0FBYyxFQUFkLENBQ0FMLEdBQUcsQ0FBQ0ssT0FBSixDQUFZeEIsWUFBWixDQUEyQixJQUEzQixDQUVBbUIsR0FBRyxDQUFDYyxPQUFKLENBQWMsRUFBZCxDQUNBZCxHQUFHLENBQUNjLE9BQUosQ0FBWUosUUFBWixDQUF1QixTQUFTQyxFQUFULENBQWEsQ0FDbEMsTUFBT2pDLGNBQWEsQ0FBQ3NCLEdBQUcsQ0FBQ2MsT0FBTCxDQUFjSCxFQUFkLENBQXBCLENBQ0QsQ0FGRCxDQUdBWCxHQUFHLENBQUNjLE9BQUosQ0FBWUYsUUFBWixDQUF1QixTQUFTbGtDLElBQVQsQ0FBZSxDQUNwQ21rQyxrQkFBa0IsQ0FBQyxDQUFDbmtDLElBQUQsQ0FBRCxDQUFsQixDQUNBc2pDLEdBQUcsQ0FBQ2MsT0FBSixDQUFZL2pDLFVBQVosQ0FBdUJWLElBQXZCLENBQTRCSyxJQUE1QixFQUNELENBSEQsQ0FJQXNqQyxHQUFHLENBQUNjLE9BQUosQ0FBWS9qQyxVQUFaLENBQXlCLEVBQXpCLENBQ0FpakMsR0FBRyxDQUFDYyxPQUFKLENBQVk5cUMsSUFBWixDQUFtQixJQUFuQixDQUVBZ3FDLEdBQUcsQ0FBQzNuQyxTQUFKLENBQWdCLElBQWhCLENBQ0EybkMsR0FBRyxDQUFDampDLFVBQUosQ0FBaUIsRUFBakIsQ0FDQWlqQyxHQUFHLENBQUMrRixZQUFKLENBQW1CLFNBQVNwRixFQUFULENBQWEsQ0FDOUIsTUFBT2pDLGNBQWEsQ0FBQ3NCLEdBQUQsQ0FBTVcsRUFBTixDQUFwQixDQUNELENBRkQsQ0FHQVgsR0FBRyxDQUFDZ0csWUFBSixDQUFtQixTQUFTdHBDLElBQVQsQ0FBZSxDQUNoQ21rQyxrQkFBa0IsQ0FBQyxDQUFDbmtDLElBQUQsQ0FBRCxDQUFsQixDQUNBc2pDLEdBQUcsQ0FBQ2pqQyxVQUFKLENBQWVWLElBQWYsQ0FBb0JLLElBQXBCLEVBQ0QsQ0FIRCxDQUlBc2pDLEdBQUcsQ0FBQ3JyQixFQUFKLENBQVMsSUFBVCxDQUVBOzs7O0tBS0FxckIsR0FBRyxDQUFDZSxVQUFKLENBQWlCLFNBQVNDLEtBQVQsQ0FBZ0IsQ0FDL0I7QUFDQUgsa0JBQWtCLENBQUNHLEtBQUQsQ0FBbEIsQ0FDQWhCLEdBQUcsQ0FBQ2MsT0FBSixDQUFZL2pDLFVBQVosQ0FBeUJpa0MsS0FBekIsQ0FDQWhCLEdBQUcsQ0FBQ2MsT0FBSixDQUFZOXFDLElBQVosQ0FBbUIsSUFBbkIsQ0FDRCxDQUxELENBT0E7Ozs7S0FLQWdxQyxHQUFHLENBQUNrRyxhQUFKLENBQW9CLFNBQVNsRixLQUFULENBQWdCLENBQ2xDO0FBQ0FILGtCQUFrQixDQUFDRyxLQUFELENBQWxCLENBQ0FoQixHQUFHLENBQUNqakMsVUFBSixDQUFpQmlrQyxLQUFqQixDQUNELENBSkQsQ0FNQTs7Ozs7S0FNQWhCLEdBQUcsQ0FBQ3BqQixJQUFKLENBQVcsU0FBU2pyQixHQUFULENBQWNnakIsRUFBZCxDQUFrQixDQUMzQjtBQUNBcXJCLEdBQUcsQ0FBQ3JyQixFQUFKLENBQVNBLEVBQUUsRUFBSWpkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU21TLElBQVQsQ0FBY3B3QixNQUFkLEVBQWYsQ0FDQSxHQUFJbW9DLGFBQVksQ0FBR3RxQixJQUFJLENBQUN5ckIsR0FBRyxDQUFDcnJCLEVBQUosQ0FBT3dDLFNBQVAsQ0FBbUIsbUJBQXBCLENBQXZCLENBQ0EsR0FBRyxDQUFDMG5CLFlBQUosQ0FBa0IsQ0FDaEIsR0FBSWh0QyxNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FBVSxtREFDcEIsdUNBRFUsQ0FBWixDQUVBMkIsS0FBSyxDQUFDc2xCLFNBQU4sQ0FBa0I2b0IsR0FBRyxDQUFDcnJCLEVBQUosQ0FBT3dDLFNBQXpCLENBQ0EsS0FBTXRsQixNQUFOLENBQ0QsQ0FDRG11QyxHQUFHLENBQUNJLFlBQUosQ0FBbUJKLEdBQUcsQ0FBQ0ssT0FBSixDQUFZeEIsWUFBWixDQUEyQkEsWUFBOUMsQ0FFQTtBQUNBbUIsR0FBRyxDQUFDNkYsd0JBQUosQ0FBK0IxdEMsR0FBRyxDQUFDZ3VDLDJCQUFKLENBQWdDbkcsR0FBaEMsQ0FBL0IsQ0FDQSxHQUFJbGhDLE1BQUssQ0FBR2tPLElBQUksQ0FBQytELEtBQUwsQ0FBV2l2QixHQUFHLENBQUM2Rix3QkFBZixDQUFaLENBRUE7QUFDQTdGLEdBQUcsQ0FBQ3JyQixFQUFKLENBQU9ySixNQUFQLENBQWN4TSxLQUFLLENBQUNhLFFBQU4sRUFBZCxFQUNBcWdDLEdBQUcsQ0FBQ3ZqQixTQUFKLENBQWdCOXFCLEdBQUcsQ0FBQ2lyQixJQUFKLENBQVNvakIsR0FBRyxDQUFDcnJCLEVBQWIsQ0FBaEIsQ0FDRCxDQW5CRCxDQXFCQTs7Ozs7Ozs7OztLQVdBcXJCLEdBQUcsQ0FBQ3hqQixNQUFKLENBQWEsVUFBVyxDQUN0QixHQUFJemMsS0FBSSxDQUFHLEtBQVgsQ0FFQSxHQUFJNFUsR0FBRSxDQUFHcXJCLEdBQUcsQ0FBQ3JyQixFQUFiLENBQ0EsR0FBR0EsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDZDtBQUNBLEdBQUdxckIsR0FBRyxDQUFDSSxZQUFKLEdBQW9CN3JCLEtBQXZCLENBQTZCLENBQzNCO0FBQ0EsR0FBSXBELElBQUcsQ0FBR29ELElBQUksQ0FBQ3lyQixHQUFHLENBQUNJLFlBQUwsQ0FBZCxDQUNBLE9BQU9qdkIsR0FBUCxFQUNBLElBQUssdUJBQUwsQ0FDRXdELEVBQUUsQ0FBR2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU21TLElBQVQsQ0FBY3B3QixNQUFkLEVBQUwsQ0FDQSxNQUNGLElBQUssc0JBQUwsQ0FDRWllLEVBQUUsQ0FBR2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBUzZULEdBQVQsQ0FBYTl4QixNQUFiLEVBQUwsQ0FDQSxNQUNGLElBQUsseUJBQUwsQ0FDRWllLEVBQUUsQ0FBR2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU2EsTUFBVCxDQUFnQjllLE1BQWhCLEVBQUwsQ0FDQSxNQUNGLElBQUsseUJBQUwsQ0FDRWllLEVBQUUsQ0FBR2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU210QixNQUFULENBQWdCcHJDLE1BQWhCLEVBQUwsQ0FDQSxNQUNGLElBQUsseUJBQUwsQ0FDRWllLEVBQUUsQ0FBR2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU2dVLE1BQVQsQ0FBZ0JqeUIsTUFBaEIsRUFBTCxDQUNBLE1BQ0YsSUFBSyxZQUFMLENBQ0VpZSxFQUFFLENBQUdqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNhLE1BQVQsQ0FBZ0I5ZSxNQUFoQixFQUFMLENBQ0EsTUFsQkYsQ0FvQkQsQ0FDRCxHQUFHaWUsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDZCxHQUFJOWlCLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLG1EQUNwQix3QkFEVSxDQUFaLENBRUEyQixLQUFLLENBQUN1dUMsWUFBTixDQUFxQkosR0FBRyxDQUFDSSxZQUF6QixDQUNBLEtBQU12dUMsTUFBTixDQUNELENBRUQ7QUFDQSxHQUFJdTBDLElBQUcsQ0FBR3BHLEdBQUcsQ0FBQzZGLHdCQUFKLEVBQ1IxdEMsR0FBRyxDQUFDZ3VDLDJCQUFKLENBQWdDbkcsR0FBaEMsQ0FERixDQUVBLEdBQUlsaEMsTUFBSyxDQUFHa08sSUFBSSxDQUFDK0QsS0FBTCxDQUFXcTFCLEdBQVgsQ0FBWixDQUNBenhCLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVXhNLEtBQUssQ0FBQ2EsUUFBTixFQUFWLEVBQ0QsQ0FFRCxHQUFHZ1YsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDZCxHQUFJM04sT0FBSixDQUVBLE9BQU9nNUIsR0FBRyxDQUFDSSxZQUFYLEVBQ0EsSUFBSzdyQixLQUFJLENBQUN3dEIscUJBQVYsQ0FDRSxvQ0FDQSxNQUNGLElBQUt4dEIsS0FBSSxDQUFDLFlBQUQsQ0FBVCxDQUNFLEdBQUl2ZSxLQUFKLENBQVU4b0MsR0FBVixDQUVBLG9CQUNBOW9DLElBQUksQ0FBR3VlLElBQUksQ0FBQ3lyQixHQUFHLENBQUNnQyxtQkFBSixDQUF3QmxELEdBQXhCLENBQTRCOW9DLElBQTVCLENBQWlDNm9DLFlBQWxDLENBQVgsQ0FDQSxHQUFHN29DLElBQUksR0FBS3dGLFNBQVQsRUFBc0I5RCxLQUFLLENBQUNpZCxFQUFOLENBQVMzZSxJQUFULElBQW1Cd0YsU0FBNUMsQ0FBdUQsQ0FDckQsR0FBSTNKLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLGdDQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQ3NmLEdBQU4sQ0FBWTZ1QixHQUFHLENBQUNnQyxtQkFBSixDQUF3QmxELEdBQXhCLENBQTRCOW9DLElBQTVCLENBQWlDNm9DLFlBQTdDLENBQ0FodEMsS0FBSyxDQUFDNUMsSUFBTixDQUFhK0csSUFBYixDQUNBLEtBQU1uRSxNQUFOLENBQ0QsQ0FFRGl0QyxHQUFHLENBQUd2cUIsSUFBSSxDQUFDeXJCLEdBQUcsQ0FBQ2dDLG1CQUFKLENBQXdCbEQsR0FBeEIsQ0FBNEJELFlBQTdCLENBQVYsQ0FDQSxHQUFHQyxHQUFHLEdBQUt0akMsU0FBUixFQUFxQjlELEtBQUssQ0FBQ29uQyxHQUFOLENBQVVBLEdBQVYsSUFBbUJ0akMsU0FBM0MsQ0FBc0QsQ0FDcEQsR0FBSTNKLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLDJCQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQ3NmLEdBQU4sQ0FBWTZ1QixHQUFHLENBQUNnQyxtQkFBSixDQUF3QmxELEdBQXhCLENBQTRCRCxZQUF4QyxDQUNBaHRDLEtBQUssQ0FBQzVDLElBQU4sQ0FBYTZ2QyxHQUFiLENBQ0EsS0FBTWp0QyxNQUFOLENBQ0QsQ0FFRGl0QyxHQUFHLENBQUdwbkMsS0FBSyxDQUFDb25DLEdBQU4sQ0FBVUEsR0FBVixFQUFlcG9DLE1BQWYsQ0FBc0JnQixLQUFLLENBQUNpZCxFQUFOLENBQVMzZSxJQUFULEVBQWVVLE1BQWYsRUFBdEIsQ0FBTixDQUVBLDhCQUNBVixJQUFJLENBQUd1ZSxJQUFJLENBQUN5ckIsR0FBRyxDQUFDZ0MsbUJBQUosQ0FBd0Joc0MsSUFBeEIsQ0FBNkI2b0MsWUFBOUIsQ0FBWCxDQUNBLEdBQUc3b0MsSUFBSSxHQUFLd0YsU0FBVCxFQUFzQjlELEtBQUssQ0FBQ2lkLEVBQU4sQ0FBUzNlLElBQVQsSUFBbUJ3RixTQUE1QyxDQUF1RCxDQUNyRCxHQUFJM0osTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsdUNBQVYsQ0FBWixDQUNBMkIsS0FBSyxDQUFDc2YsR0FBTixDQUFZNnVCLEdBQUcsQ0FBQ2dDLG1CQUFKLENBQXdCaHNDLElBQXhCLENBQTZCNm9DLFlBQXpDLENBQ0FodEMsS0FBSyxDQUFDNUMsSUFBTixDQUFhK0csSUFBYixDQUNBLEtBQU1uRSxNQUFOLENBQ0QsQ0FFRG1WLE1BQU0sQ0FBR3RQLEtBQUssQ0FBQ3VxQyxHQUFOLENBQVV2ckMsTUFBVixDQUFpQmdCLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBUzNlLElBQVQsRUFBZVUsTUFBZixFQUFqQixDQUEwQ29vQyxHQUExQyxDQUNQa0IsR0FBRyxDQUFDZ0MsbUJBQUosQ0FBd0JqRCxVQURqQixDQUFULENBRUEsTUFyQ0YsQ0F3Q0E7QUFDQWgvQixJQUFJLENBQUdpZ0MsR0FBRyxDQUFDM25DLFNBQUosQ0FBY21rQixNQUFkLENBQ0w3SCxFQUFFLENBQUM0QyxNQUFILEdBQVk1WCxRQUFaLEVBREssQ0FDbUJxZ0MsR0FBRyxDQUFDdmpCLFNBRHZCLENBQ2tDelYsTUFEbEMsQ0FBUCxDQUVELENBRUQsTUFBT2pILEtBQVAsQ0FDRCxDQTdGRCxDQStGQSxNQUFPaWdDLElBQVAsQ0FDRCxDQTNMRCxDQTZMQTs7Ozs7O0dBT0EsUUFBU3FHLFVBQVQsQ0FBbUIxZ0MsR0FBbkIsQ0FBd0IsQ0FDdEI7QUFDQSxHQUFJNUYsS0FBSSxDQUFHaU4sSUFBSSxDQUFDdFcsTUFBTCxDQUNUc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBREYsQ0FDYUYsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBRHZCLENBQ2lDLElBRGpDLENBQ3VDLEVBRHZDLENBQVgsQ0FHQTtBQUNBLEdBQUkzUixLQUFKLENBQVVxRixHQUFWLENBQ0EsR0FBSWkvQixNQUFLLENBQUdyN0IsR0FBRyxDQUFDNUksVUFBaEIsQ0FDQSxJQUFJLEdBQUlwRCxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdxbkMsS0FBSyxDQUFDNXdDLE1BQXpCLENBQWlDLEVBQUV1SixDQUFuQyxDQUFzQyxDQUNwQytDLElBQUksQ0FBR3NrQyxLQUFLLENBQUNybkMsQ0FBRCxDQUFaLENBQ0EsR0FBSXVQLE1BQUssQ0FBR3hNLElBQUksQ0FBQ3dNLEtBQWpCLENBRUE7QUFDQSxHQUFJaTFCLGNBQWEsQ0FBR254QixJQUFJLENBQUNNLElBQUwsQ0FBVWlCLGVBQTlCLENBQ0EsR0FBRyxpQkFBbUI3UixLQUF0QixDQUE0QixDQUMxQnloQyxhQUFhLENBQUd6aEMsSUFBSSxDQUFDeWhDLGFBQXJCLENBRUEsR0FBR0EsYUFBYSxHQUFLbnhCLElBQUksQ0FBQ00sSUFBTCxDQUFVYSxJQUEvQixDQUFxQyxDQUNuQ2pGLEtBQUssQ0FBR3hSLEtBQUssQ0FBQ3dELElBQU4sQ0FBVytELFVBQVgsQ0FBc0JpSyxLQUF0QixDQUFSLENBQ0QsQ0FDRDtBQUNELENBRUQ7QUFDQTtBQUNBO0FBQ0FuSCxHQUFHLENBQUdpTCxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FBNUMsQ0FBaUQsSUFBakQsQ0FBdUQsQ0FDM0R0QixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjeFUsSUFBSSxDQUFDMkosSUFBbkIsRUFBeUIxRyxRQUF6QixFQURGLENBRjBELENBSTFEO0FBQ0FxTixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NpeEIsYUFBbEMsQ0FBaUQsS0FBakQsQ0FBd0RqMUIsS0FBeEQsQ0FMMEQsQ0FBNUQsQ0FEMkQsQ0FBdkQsQ0FBTixDQVNBbkosSUFBSSxDQUFDbUosS0FBTCxDQUFXN00sSUFBWCxDQUFnQjBGLEdBQWhCLEVBQ0QsQ0FFRCxNQUFPaEMsS0FBUCxDQUNELENBRUQ7Ozs7Ozs7R0FRQSxRQUFTdW1DLHFCQUFULENBQThCdEYsS0FBOUIsQ0FBcUMsQ0FDbkMsR0FBSWpoQyxLQUFJLENBQUcsRUFBWCxDQUNBLElBQUksR0FBSXBHLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3FuQyxLQUFLLENBQUM1d0MsTUFBekIsQ0FBaUMsRUFBRXVKLENBQW5DLENBQXNDLENBQ3BDLEdBQUkrQyxLQUFJLENBQUdza0MsS0FBSyxDQUFDcm5DLENBQUQsQ0FBaEIsQ0FDQSxHQUFHK0MsSUFBSSxDQUFDMGhDLFNBQUwsR0FDRDFoQyxJQUFJLENBQUN5aEMsYUFBTCxHQUF1Qm54QixJQUFJLENBQUNNLElBQUwsQ0FBVWEsSUFBakMsRUFDQXpSLElBQUksQ0FBQ3loQyxhQUFMLEdBQXVCbnhCLElBQUksQ0FBQ00sSUFBTCxDQUFVaUIsZUFEakMsRUFFQTdSLElBQUksQ0FBQ3loQyxhQUFMLEdBQXVCbnhCLElBQUksQ0FBQ00sSUFBTCxDQUFVa0IsU0FIaEMsQ0FBSCxDQUcrQyxDQUM3QyxHQUFJdEYsTUFBSyxDQUFHeE0sSUFBSSxDQUFDd00sS0FBakIsQ0FDQSxHQUFHeE0sSUFBSSxDQUFDeWhDLGFBQUwsR0FBdUJueEIsSUFBSSxDQUFDTSxJQUFMLENBQVVhLElBQXBDLENBQTBDLENBQ3hDakYsS0FBSyxDQUFHeFIsS0FBSyxDQUFDd0QsSUFBTixDQUFXK0QsVUFBWCxDQUFzQnZDLElBQUksQ0FBQ3dNLEtBQTNCLENBQVIsQ0FDRCxDQUNELEdBQUcsRUFBRXhNLElBQUksQ0FBQzBoQyxTQUFMLEdBQWtCcitCLEtBQXBCLENBQUgsQ0FBOEIsQ0FDNUJBLElBQUksQ0FBQ3JELElBQUksQ0FBQzBoQyxTQUFOLENBQUosQ0FBdUJsMUIsS0FBdkIsQ0FDRCxDQUZELElBRU8sSUFBR3hSLEtBQUssQ0FBQ3dELElBQU4sQ0FBV21DLE9BQVgsQ0FBbUIwQyxJQUFJLENBQUNyRCxJQUFJLENBQUMwaEMsU0FBTixDQUF2QixDQUFILENBQTZDLENBQ2xEcitCLElBQUksQ0FBQ3JELElBQUksQ0FBQzBoQyxTQUFOLENBQUosQ0FBcUIvaEMsSUFBckIsQ0FBMEI2TSxLQUExQixFQUNELENBRk0sSUFFQSxDQUNMbkosSUFBSSxDQUFDckQsSUFBSSxDQUFDMGhDLFNBQU4sQ0FBSixDQUF1QixDQUFDcitCLElBQUksQ0FBQ3JELElBQUksQ0FBQzBoQyxTQUFOLENBQUwsQ0FBdUJsMUIsS0FBdkIsQ0FBdkIsQ0FDRCxDQUNGLENBQ0YsQ0FDRCxNQUFPbkosS0FBUCxDQUNELENBRUQ7Ozs7R0FLQSxRQUFTOGdDLG1CQUFULENBQTRCRyxLQUE1QixDQUFtQyxDQUNqQyxHQUFJdGtDLEtBQUosQ0FDQSxJQUFJLEdBQUkvQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdxbkMsS0FBSyxDQUFDNXdDLE1BQXpCLENBQWlDLEVBQUV1SixDQUFuQyxDQUFzQyxDQUNwQytDLElBQUksQ0FBR3NrQyxLQUFLLENBQUNybkMsQ0FBRCxDQUFaLENBRUE7QUFDQSxHQUFHLE1BQU8rQyxLQUFJLENBQUN6TixJQUFaLEdBQXFCLFdBQXhCLENBQXFDLENBQ25DLEdBQUd5TixJQUFJLENBQUMySixJQUFMLEVBQWEzSixJQUFJLENBQUMySixJQUFMLEdBQWFsTyxJQUFHLENBQUNvYyxJQUFqQyxDQUF1QyxDQUNyQzdYLElBQUksQ0FBQ3pOLElBQUwsQ0FBWWtKLEdBQUcsQ0FBQ29jLElBQUosQ0FBUzdYLElBQUksQ0FBQzJKLElBQWQsQ0FBWixDQUNELENBRkQsSUFFTyxJQUFHM0osSUFBSSxDQUFDMGhDLFNBQUwsRUFBa0IxaEMsSUFBSSxDQUFDMGhDLFNBQUwsR0FBa0JULFlBQXZDLENBQW9ELENBQ3pEamhDLElBQUksQ0FBQ3pOLElBQUwsQ0FBWWtKLEdBQUcsQ0FBQ29jLElBQUosQ0FBU29wQixXQUFXLENBQUNqaEMsSUFBSSxDQUFDMGhDLFNBQU4sQ0FBcEIsQ0FBWixDQUNELENBQ0YsQ0FFRDtBQUNBLEdBQUcsTUFBTzFoQyxLQUFJLENBQUMySixJQUFaLEdBQXFCLFdBQXhCLENBQXFDLENBQ25DLEdBQUczSixJQUFJLENBQUN6TixJQUFMLEVBQWF5TixJQUFJLENBQUN6TixJQUFMLEdBQWFrSixJQUFHLENBQUNvYyxJQUFqQyxDQUF1QyxDQUNyQzdYLElBQUksQ0FBQzJKLElBQUwsQ0FBWWxPLEdBQUcsQ0FBQ29jLElBQUosQ0FBUzdYLElBQUksQ0FBQ3pOLElBQWQsQ0FBWixDQUNELENBRkQsSUFFTyxDQUNMLEdBQUk0QyxNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FBVSwrQkFBVixDQUFaLENBQ0EyQixLQUFLLENBQUMwMEMsU0FBTixDQUFrQjdwQyxJQUFsQixDQUNBLEtBQU03SyxNQUFOLENBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBRyxNQUFPNkssS0FBSSxDQUFDMGhDLFNBQVosR0FBMEIsV0FBN0IsQ0FBMEMsQ0FDeEMsR0FBRzFoQyxJQUFJLENBQUN6TixJQUFMLEVBQWF5TixJQUFJLENBQUN6TixJQUFMLEdBQWEwdUMsWUFBN0IsQ0FBMEMsQ0FDeENqaEMsSUFBSSxDQUFDMGhDLFNBQUwsQ0FBaUJULFdBQVcsQ0FBQ2poQyxJQUFJLENBQUN6TixJQUFOLENBQTVCLENBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBR3lOLElBQUksQ0FBQzJKLElBQUwsR0FBY2tPLElBQUksQ0FBQ2dxQixnQkFBdEIsQ0FBd0MsQ0FDdEM3aEMsSUFBSSxDQUFDOHBDLGdCQUFMLENBQXdCLElBQXhCLENBQ0E5cEMsSUFBSSxDQUFDeWhDLGFBQUwsQ0FBcUJueEIsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQS9CLENBQ0EsR0FBRyxDQUFDM1IsSUFBSSxDQUFDd00sS0FBTixFQUFleE0sSUFBSSxDQUFDOGhDLFVBQXZCLENBQW1DLENBQ2pDOWhDLElBQUksQ0FBQ3dNLEtBQUwsQ0FBYSxFQUFiLENBQ0EsSUFBSSxHQUFJc1ksR0FBRSxDQUFHLENBQWIsQ0FBZ0JBLEVBQUUsQ0FBRzlrQixJQUFJLENBQUM4aEMsVUFBTCxDQUFnQnB1QyxNQUFyQyxDQUE2QyxFQUFFb3hCLEVBQS9DLENBQW1ELENBQ2pEOWtCLElBQUksQ0FBQ3dNLEtBQUwsQ0FBVzdNLElBQVgsQ0FBZ0JsRSxHQUFHLENBQUNzdUMsMEJBQUosQ0FDZHBGLDJCQUEyQixDQUFDM2tDLElBQUksQ0FBQzhoQyxVQUFMLENBQWdCaGQsRUFBaEIsQ0FBRCxDQURiLENBQWhCLEVBRUQsQ0FDRixDQUNGLENBRUQsR0FBRyxNQUFPOWtCLEtBQUksQ0FBQ3dNLEtBQVosR0FBc0IsV0FBekIsQ0FBc0MsQ0FDcEMsR0FBSXJYLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLGdDQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQzAwQyxTQUFOLENBQWtCN3BDLElBQWxCLENBQ0EsS0FBTTdLLE1BQU4sQ0FDRCxDQUNGLENBQ0YsQ0FFRDs7Ozs7Ozs7R0FTQSxRQUFTd3ZDLDRCQUFULENBQXFDL2lDLENBQXJDLENBQXdDOU8sT0FBeEMsQ0FBaUQsQ0FDL0NBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBRUE7QUFDQSxHQUFHLE1BQU84TyxFQUFDLENBQUNyUCxJQUFULEdBQWtCLFdBQXJCLENBQWtDLENBQ2hDLEdBQUdxUCxDQUFDLENBQUNwSyxFQUFGLEVBQVFvSyxDQUFDLENBQUNwSyxFQUFGLEdBQVFpRSxJQUFHLENBQUNvYyxJQUF2QixDQUE2QixDQUMzQmpXLENBQUMsQ0FBQ3JQLElBQUYsQ0FBU2tKLEdBQUcsQ0FBQ29jLElBQUosQ0FBU2pXLENBQUMsQ0FBQ3BLLEVBQVgsQ0FBVCxDQUNELENBQ0YsQ0FFRDtBQUNBLEdBQUcsTUFBT29LLEVBQUMsQ0FBQ3BLLEVBQVQsR0FBZ0IsV0FBbkIsQ0FBZ0MsQ0FDOUIsR0FBR29LLENBQUMsQ0FBQ3JQLElBQUYsRUFBVXFQLENBQUMsQ0FBQ3JQLElBQUYsR0FBVWtKLElBQUcsQ0FBQ29jLElBQTNCLENBQWlDLENBQy9CalcsQ0FBQyxDQUFDcEssRUFBRixDQUFPaUUsR0FBRyxDQUFDb2MsSUFBSixDQUFTalcsQ0FBQyxDQUFDclAsSUFBWCxDQUFQLENBQ0QsQ0FGRCxJQUVPLENBQ0wsR0FBSTRDLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLDZCQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQzYwQyxTQUFOLENBQWtCcG9DLENBQWxCLENBQ0EsS0FBTXpNLE1BQU4sQ0FDRCxDQUNGLENBRUQsR0FBRyxNQUFPeU0sRUFBQyxDQUFDNEssS0FBVCxHQUFtQixXQUF0QixDQUFtQyxDQUNqQyxNQUFPNUssRUFBUCxDQUNELENBRUQ7QUFFQTtBQUNBLEdBQUdBLENBQUMsQ0FBQ3JQLElBQUYsR0FBVyxVQUFkLENBQTBCLENBQ3hCO0FBQ0EsR0FBSXdoQixPQUFNLENBQUcsQ0FBYixDQUNBLEdBQUloQixHQUFFLENBQUcsSUFBVCxDQUNBLEdBQUl5MEIsR0FBRSxDQUFHLElBQVQsQ0FDQSxHQUFHNWxDLENBQUMsQ0FBQzZsQyxnQkFBTCxDQUF1QixDQUNyQjEwQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUduUyxDQUFDLENBQUM4bEMsY0FBTCxDQUFxQixDQUNuQjMwQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUduUyxDQUFDLENBQUMrbEMsZUFBTCxDQUFzQixDQUNwQjUwQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUduUyxDQUFDLENBQUNnbUMsZ0JBQUwsQ0FBdUIsQ0FDckI3MEIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHblMsQ0FBQyxDQUFDaW1DLFlBQUwsQ0FBbUIsQ0FDakI5MEIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHblMsQ0FBQyxDQUFDa21DLFdBQUwsQ0FBa0IsQ0FDaEIvMEIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHblMsQ0FBQyxDQUFDbW1DLE9BQUwsQ0FBYyxDQUNaaDFCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBQ0QsR0FBR25TLENBQUMsQ0FBQ29tQyxZQUFMLENBQW1CLENBQ2pCajFCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBQ0QsR0FBR25TLENBQUMsQ0FBQ3FtQyxZQUFMLENBQW1CLENBQ2pCVCxFQUFFLEVBQUksSUFBTixDQUNBenpCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FFRDtBQUNBLEdBQUl2SCxNQUFLLENBQUc5SyxNQUFNLENBQUNDLFlBQVAsQ0FBb0JvUyxNQUFwQixDQUFaLENBQ0EsR0FBR3l6QixFQUFFLEdBQUssQ0FBVixDQUFhLENBQ1hoN0IsS0FBSyxFQUFJOUssTUFBTSxDQUFDQyxZQUFQLENBQW9Cb1IsRUFBcEIsRUFBMEJyUixNQUFNLENBQUNDLFlBQVAsQ0FBb0I2bEMsRUFBcEIsQ0FBbkMsQ0FDRCxDQUZELElBRU8sSUFBR3owQixFQUFFLEdBQUssQ0FBVixDQUFhLENBQ2xCdkcsS0FBSyxFQUFJOUssTUFBTSxDQUFDQyxZQUFQLENBQW9Cb1IsRUFBcEIsQ0FBVCxDQUNELENBQ0RuUixDQUFDLENBQUM0SyxLQUFGLENBQVU4RCxJQUFJLENBQUN0VyxNQUFMLENBQ1JzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FESCxDQUNjRixJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FEeEIsQ0FDbUMsS0FEbkMsQ0FDMEN4RSxLQUQxQyxDQUFWLENBRUQsQ0FuREQsSUFtRE8sSUFBRzVLLENBQUMsQ0FBQ3JQLElBQUYsR0FBVyxrQkFBZCxDQUFrQyxDQUN2QztBQUNBcVAsQ0FBQyxDQUFDNEssS0FBRixDQUFVOEQsSUFBSSxDQUFDdFcsTUFBTCxDQUNSc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBREgsQ0FDY0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBRHhCLENBQ2tDLElBRGxDLENBQ3dDLEVBRHhDLENBQVYsQ0FFQTtBQUNBLEdBQUcvUCxDQUFDLENBQUNzbUMsRUFBTCxDQUFTLENBQ1B0bUMsQ0FBQyxDQUFDNEssS0FBRixDQUFRQSxLQUFSLENBQWM3TSxJQUFkLENBQW1CMlEsSUFBSSxDQUFDdFcsTUFBTCxDQUNqQnNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURNLENBQ0tGLElBQUksQ0FBQ00sSUFBTCxDQUFVRSxPQURmLENBQ3dCLEtBRHhCLENBRWpCcFAsTUFBTSxDQUFDQyxZQUFQLENBQW9CLElBQXBCLENBRmlCLENBQW5CLEVBR0QsQ0FDRCxHQUFHLHFCQUF1QkMsRUFBMUIsQ0FBNkIsQ0FDM0JBLENBQUMsQ0FBQzRLLEtBQUYsQ0FBUUEsS0FBUixDQUFjN00sSUFBZCxDQUFtQjJRLElBQUksQ0FBQ3RXLE1BQUwsQ0FDakJzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FETSxDQUNLRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FEZixDQUN3QixLQUR4QixDQUVqQlQsSUFBSSxDQUFDcUcsWUFBTCxDQUFrQi9VLENBQUMsQ0FBQ3VtQyxpQkFBcEIsRUFBdUNsbEMsUUFBdkMsRUFGaUIsQ0FBbkIsRUFHRCxDQUNGLENBZk0sSUFlQSxJQUFHckIsQ0FBQyxDQUFDclAsSUFBRixHQUFXLGFBQWQsQ0FBNkIsQ0FDbEM7QUFDQXFQLENBQUMsQ0FBQzRLLEtBQUYsQ0FBVThELElBQUksQ0FBQ3RXLE1BQUwsQ0FDUnNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURILENBQ2NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUR4QixDQUNrQyxJQURsQyxDQUN3QyxFQUR4QyxDQUFWLENBRUEsR0FBSWl3QixJQUFHLENBQUdoZ0MsQ0FBQyxDQUFDNEssS0FBRixDQUFRQSxLQUFsQixDQUNBLElBQUksR0FBSXZYLElBQVIsR0FBZTJNLEVBQWYsQ0FBa0IsQ0FDaEIsR0FBR0EsQ0FBQyxDQUFDM00sR0FBRCxDQUFELEdBQVcsSUFBZCxDQUFvQixDQUNsQixTQUNELENBQ0Q7QUFDQSxHQUFHQSxHQUFHLEdBQUk0aUIsS0FBVixDQUFnQixDQUNkK3BCLEdBQUcsQ0FBQ2ppQyxJQUFKLENBQVMyUSxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUNQLEtBRE8sQ0FDQWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjcUQsSUFBSSxDQUFDNWlCLEdBQUQsQ0FBbEIsRUFBeUJnTyxRQUF6QixFQURBLENBQVQsRUFFRCxDQUhELElBR08sSUFBR2hPLEdBQUcsQ0FBQ2dXLE9BQUosQ0FBWSxHQUFaLElBQXFCLENBQUMsQ0FBekIsQ0FBNEIsQ0FDakM7QUFDQTIyQixHQUFHLENBQUNqaUMsSUFBSixDQUFTMlEsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FDUCxLQURPLENBQ0FiLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY3ZmLEdBQWQsRUFBbUJnTyxRQUFuQixFQURBLENBQVQsRUFFRCxDQUNGLENBQ0YsQ0FuQk0sSUFtQkEsSUFBR3JCLENBQUMsQ0FBQ3JQLElBQUYsR0FBVyxZQUFkLENBQTRCLENBQ2pDO0FBQ0E7QUFDQSxHQUFJd2hCLE9BQU0sQ0FBRyxDQUFiLENBQ0EsR0FBSWhCLEdBQUUsQ0FBRyxJQUFULENBRUEsR0FBR25SLENBQUMsQ0FBQ3pPLE1BQUwsQ0FBYSxDQUNYNGYsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHblMsQ0FBQyxDQUFDd21DLE1BQUwsQ0FBYSxDQUNYcjFCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBQ0QsR0FBR25TLENBQUMsQ0FBQ3ltQyxLQUFMLENBQVksQ0FDVnQxQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUduUyxDQUFDLENBQUMwbUMsT0FBTCxDQUFjLENBQ1p2MUIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHblMsQ0FBQyxDQUFDMm1DLFFBQUwsQ0FBZSxDQUNieDFCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBQ0QsR0FBR25TLENBQUMsQ0FBQzRtQyxLQUFMLENBQVksQ0FDVnoxQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUduUyxDQUFDLENBQUM2bUMsT0FBTCxDQUFjLENBQ1oxMUIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHblMsQ0FBQyxDQUFDOG1DLEtBQUwsQ0FBWSxDQUNWMzFCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBRUQ7QUFDQSxHQUFJdkgsTUFBSyxDQUFHOUssTUFBTSxDQUFDQyxZQUFQLENBQW9Cb1MsTUFBcEIsQ0FBWixDQUNBLEdBQUdoQixFQUFFLEdBQUssQ0FBVixDQUFhLENBQ1h2RyxLQUFLLEVBQUk5SyxNQUFNLENBQUNDLFlBQVAsQ0FBb0JvUixFQUFwQixDQUFULENBQ0QsQ0FDRG5SLENBQUMsQ0FBQzRLLEtBQUYsQ0FBVThELElBQUksQ0FBQ3RXLE1BQUwsQ0FDUnNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURILENBQ2NGLElBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUR4QixDQUNtQyxLQURuQyxDQUMwQ3hFLEtBRDFDLENBQVYsQ0FFRCxDQTlDTSxJQThDQSxJQUFHNUssQ0FBQyxDQUFDclAsSUFBRixHQUFXLGdCQUFYLEVBQStCcVAsQ0FBQyxDQUFDclAsSUFBRixHQUFXLGVBQTdDLENBQThELENBQ25FO0FBQ0FxUCxDQUFDLENBQUM0SyxLQUFGLENBQVU4RCxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxFQUE1RCxDQUFWLENBRUEsR0FBSWszQixRQUFKLENBQ0EsSUFBSSxHQUFJanJDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR2dFLENBQUMsQ0FBQyttQyxRQUFGLENBQVdqMUMsTUFBOUIsQ0FBc0MsRUFBRWtLLENBQXhDLENBQTJDLENBQ3pDaXJDLE9BQU8sQ0FBR2puQyxDQUFDLENBQUMrbUMsUUFBRixDQUFXL3FDLENBQVgsQ0FBVixDQUNBLEdBQUk0TyxNQUFLLENBQUdxOEIsT0FBTyxDQUFDcjhCLEtBQXBCLENBQ0E7QUFDQSxHQUFHcThCLE9BQU8sQ0FBQ2wvQixJQUFSLEdBQWlCLENBQWpCLEVBQXNCay9CLE9BQU8sQ0FBQ2o3QixFQUFqQyxDQUFxQyxDQUNuQ3BCLEtBQUssQ0FBR3hSLEtBQUssQ0FBQ3dELElBQU4sQ0FBV21QLFdBQVgsQ0FBdUJrN0IsT0FBTyxDQUFDajdCLEVBQS9CLENBQVIsQ0FDQSxHQUFHcEIsS0FBSyxHQUFLLElBQWIsQ0FBbUIsQ0FDakIsR0FBSXJYLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUNWLDJEQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQzYwQyxTQUFOLENBQWtCcG9DLENBQWxCLENBQ0EsS0FBTXpNLE1BQU4sQ0FDRCxDQUNGLENBUkQsSUFRTyxJQUFHMHpDLE9BQU8sQ0FBQ2wvQixJQUFSLEdBQWlCLENBQXBCLENBQXVCLENBQzVCO0FBQ0EsR0FBR2svQixPQUFPLENBQUNwMEIsR0FBWCxDQUFnQixDQUNkakksS0FBSyxDQUFHOEQsSUFBSSxDQUFDa0UsUUFBTCxDQUFjbEUsSUFBSSxDQUFDa0UsUUFBTCxDQUFjcTBCLE9BQU8sQ0FBQ3AwQixHQUF0QixDQUFkLENBQVIsQ0FDRCxDQUZELElBRU8sQ0FDTDtBQUNBakksS0FBSyxDQUFHOEQsSUFBSSxDQUFDa0UsUUFBTCxDQUFjaEksS0FBZCxDQUFSLENBQ0QsQ0FDRixDQUNENUssQ0FBQyxDQUFDNEssS0FBRixDQUFRQSxLQUFSLENBQWM3TSxJQUFkLENBQW1CMlEsSUFBSSxDQUFDdFcsTUFBTCxDQUNqQnNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFETSxDQUNZbTRCLE9BQU8sQ0FBQ2wvQixJQURwQixDQUMwQixLQUQxQixDQUVqQjZDLEtBRmlCLENBQW5CLEVBR0QsQ0FDRixDQTlCTSxJQThCQSxJQUFHNUssQ0FBQyxDQUFDclAsSUFBRixHQUFXLHNCQUFYLEVBQXFDTyxPQUFPLENBQUMrdkMsSUFBaEQsQ0FBc0QsQ0FDM0QsR0FBSWlELElBQUcsQ0FBR2h6QyxPQUFPLENBQUMrdkMsSUFBUixDQUFhK0MsNEJBQWIsRUFBVixDQUNBaGtDLENBQUMsQ0FBQ21rQyxvQkFBRixDQUF5QkQsR0FBRyxDQUFDdGhDLEtBQUosRUFBekIsQ0FDQTtBQUNBNUMsQ0FBQyxDQUFDNEssS0FBRixDQUFVOEQsSUFBSSxDQUFDdFcsTUFBTCxDQUNSc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBREgsQ0FDY0YsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRHhCLENBQ3FDLEtBRHJDLENBQzRDNjBCLEdBQUcsQ0FBQzdpQyxRQUFKLEVBRDVDLENBQVYsQ0FFRCxDQU5NLElBTUEsSUFBR3JCLENBQUMsQ0FBQ3JQLElBQUYsR0FBVyx3QkFBWCxFQUF1Q08sT0FBTyxDQUFDK3ZDLElBQWxELENBQXdELENBQzdEO0FBQ0FqaEMsQ0FBQyxDQUFDNEssS0FBRixDQUFVOEQsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsRUFBNUQsQ0FBVixDQUNBLEdBQUlpd0IsSUFBRyxDQUFHaGdDLENBQUMsQ0FBQzRLLEtBQUYsQ0FBUUEsS0FBbEIsQ0FFQSxHQUFHNUssQ0FBQyxDQUFDcW9DLGFBQUwsQ0FBb0IsQ0FDbEIsR0FBSUEsY0FBYSxDQUFJcm9DLENBQUMsQ0FBQ3FvQyxhQUFGLEdBQW9CLElBQXBCLENBQ25CbjNDLE9BQU8sQ0FBQyt2QyxJQUFSLENBQWErQyw0QkFBYixHQUE0QzNpQyxRQUE1QyxFQURtQixDQUVuQnJCLENBQUMsQ0FBQ3FvQyxhQUZKLENBR0FySSxHQUFHLENBQUNqaUMsSUFBSixDQUNFMlEsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxLQUE1QyxDQUFtRHU1QixhQUFuRCxDQURGLEVBRUQsQ0FFRCxHQUFHcm9DLENBQUMsQ0FBQ3NvQyxtQkFBTCxDQUEwQixDQUN4QixHQUFJQSxvQkFBbUIsQ0FBRyxDQUN4QjU1QixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hEaTVCLFNBQVMsQ0FBQy9uQyxDQUFDLENBQUNzb0MsbUJBQUYsR0FBMEIsSUFBMUIsQ0FDUnAzQyxPQUFPLENBQUMrdkMsSUFBUixDQUFha0IsTUFETCxDQUNjbmlDLENBQUMsQ0FBQ3NvQyxtQkFEakIsQ0FEdUMsQ0FBbEQsQ0FEd0IsQ0FBMUIsQ0FNQXRJLEdBQUcsQ0FBQ2ppQyxJQUFKLENBQ0UyUSxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtEdzVCLG1CQUFsRCxDQURGLEVBRUQsQ0FFRCxHQUFHdG9DLENBQUMsQ0FBQzZoQyxZQUFMLENBQW1CLENBQ2pCLEdBQUlBLGFBQVksQ0FBR3pvQyxLQUFLLENBQUN3RCxJQUFOLENBQVdzSSxVQUFYLENBQXNCbEYsQ0FBQyxDQUFDNmhDLFlBQUYsR0FBbUIsSUFBbkIsQ0FDdkMzd0MsT0FBTyxDQUFDK3ZDLElBQVIsQ0FBYVksWUFEMEIsQ0FDWDdoQyxDQUFDLENBQUM2aEMsWUFEYixDQUFuQixDQUVBN0IsR0FBRyxDQUFDamlDLElBQUosQ0FDRTJRLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsS0FBNUMsQ0FBbUQreUIsWUFBbkQsQ0FERixFQUVELENBQ0YsQ0E5Qk0sSUE4QkEsSUFBSTdoQyxDQUFDLENBQUNyUCxJQUFGLEdBQVcsdUJBQWYsQ0FBd0MsQ0FDN0NxUCxDQUFDLENBQUM0SyxLQUFGLENBQVU4RCxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxFQUE1RCxDQUFWLENBQ0EsR0FBSWl3QixJQUFHLENBQUdoZ0MsQ0FBQyxDQUFDNEssS0FBRixDQUFRQSxLQUFsQixDQUVBO0FBQ0EsR0FBSTI5QixPQUFNLENBQUc3NUIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsRUFBNUQsQ0FBYixDQUVBO0FBQ0EsR0FBSXk0QixxQkFBb0IsQ0FBRzk1QixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELEVBQWxELENBQTNCLENBQ0EsR0FBSW00QixRQUFKLENBQ0EsSUFBSSxHQUFJanJDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR2dFLENBQUMsQ0FBQyttQyxRQUFGLENBQVdqMUMsTUFBOUIsQ0FBc0MsRUFBRWtLLENBQXhDLENBQTJDLENBQ3pDaXJDLE9BQU8sQ0FBR2puQyxDQUFDLENBQUMrbUMsUUFBRixDQUFXL3FDLENBQVgsQ0FBVixDQUNBLEdBQUk0TyxNQUFLLENBQUdxOEIsT0FBTyxDQUFDcjhCLEtBQXBCLENBQ0E7QUFDQSxHQUFHcThCLE9BQU8sQ0FBQ2wvQixJQUFSLEdBQWlCLENBQWpCLEVBQXNCay9CLE9BQU8sQ0FBQ2o3QixFQUFqQyxDQUFxQyxDQUNuQ3BCLEtBQUssQ0FBR3hSLEtBQUssQ0FBQ3dELElBQU4sQ0FBV21QLFdBQVgsQ0FBdUJrN0IsT0FBTyxDQUFDajdCLEVBQS9CLENBQVIsQ0FDQSxHQUFHcEIsS0FBSyxHQUFLLElBQWIsQ0FBbUIsQ0FDakIsR0FBSXJYLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUNWLDJEQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQzYwQyxTQUFOLENBQWtCcG9DLENBQWxCLENBQ0EsS0FBTXpNLE1BQU4sQ0FDRCxDQUNGLENBUkQsSUFRTyxJQUFHMHpDLE9BQU8sQ0FBQ2wvQixJQUFSLEdBQWlCLENBQXBCLENBQXVCLENBQzVCO0FBQ0EsR0FBR2svQixPQUFPLENBQUNwMEIsR0FBWCxDQUFnQixDQUNkakksS0FBSyxDQUFHOEQsSUFBSSxDQUFDa0UsUUFBTCxDQUFjbEUsSUFBSSxDQUFDa0UsUUFBTCxDQUFjcTBCLE9BQU8sQ0FBQ3AwQixHQUF0QixDQUFkLENBQVIsQ0FDRCxDQUZELElBRU8sQ0FDTDtBQUNBakksS0FBSyxDQUFHOEQsSUFBSSxDQUFDa0UsUUFBTCxDQUFjaEksS0FBZCxDQUFSLENBQ0QsQ0FDRixDQUNENDlCLG9CQUFvQixDQUFDNTlCLEtBQXJCLENBQTJCN00sSUFBM0IsQ0FBZ0MyUSxJQUFJLENBQUN0VyxNQUFMLENBQzlCc1csSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQURtQixDQUNEbTRCLE9BQU8sQ0FBQ2wvQixJQURQLENBQ2EsS0FEYixDQUU5QjZDLEtBRjhCLENBQWhDLEVBR0QsQ0FFRDtBQUNBMjlCLE1BQU0sQ0FBQzM5QixLQUFQLENBQWE3TSxJQUFiLENBQWtCMlEsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxJQUE1QyxDQUFrRCxDQUFDMDVCLG9CQUFELENBQWxELENBQWxCLEVBQ0F4SSxHQUFHLENBQUNqaUMsSUFBSixDQUFTd3FDLE1BQVQsRUFDRCxDQUVEO0FBQ0EsR0FBRyxNQUFPdm9DLEVBQUMsQ0FBQzRLLEtBQVQsR0FBbUIsV0FBdEIsQ0FBbUMsQ0FDakMsR0FBSXJYLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLGdDQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQzYwQyxTQUFOLENBQWtCcG9DLENBQWxCLENBQ0EsS0FBTXpNLE1BQU4sQ0FDRCxDQUVELE1BQU95TSxFQUFQLENBQ0QsQ0FFRDs7Ozs7O0dBT0EsUUFBU3lvQywyQkFBVCxDQUFvQzUxQixHQUFwQyxDQUF5Q3RjLE1BQXpDLENBQWlELENBQy9DLE9BQU9zYyxHQUFQLEVBQ0EsSUFBS29ELEtBQUksQ0FBQyxZQUFELENBQVQsQ0FDRSxHQUFJNUssTUFBSyxDQUFHLEVBQVosQ0FFQSxHQUFHOVUsTUFBTSxDQUFDbUIsSUFBUCxDQUFZNm9DLFlBQVosR0FBNkJyakMsU0FBaEMsQ0FBMkMsQ0FDekNtTyxLQUFLLENBQUN0TixJQUFOLENBQVcyUSxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQzNESixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRHJCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY3JjLE1BQU0sQ0FBQ21CLElBQVAsQ0FBWTZvQyxZQUExQixFQUF3Q2wvQixRQUF4QyxFQURGLENBRDBELENBRzFEcU4sSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU0sSUFBNUMsQ0FBa0QsS0FBbEQsQ0FBeUQsRUFBekQsQ0FIMEQsQ0FBNUQsQ0FEMkQsQ0FBbEQsQ0FBWCxFQU9ELENBRUQsR0FBRy9ZLE1BQU0sQ0FBQ2lxQyxHQUFQLENBQVdELFlBQVgsR0FBNEJyakMsU0FBL0IsQ0FBMEMsQ0FDeENtTyxLQUFLLENBQUN0TixJQUFOLENBQVcyUSxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQzNESixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRHJCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY3JjLE1BQU0sQ0FBQ2lxQyxHQUFQLENBQVdELFlBQXpCLEVBQXVDbC9CLFFBQXZDLEVBREYsQ0FEMEQsQ0FHMURxTixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRHJCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY3JjLE1BQU0sQ0FBQ2lxQyxHQUFQLENBQVc5b0MsSUFBWCxDQUFnQjZvQyxZQUE5QixFQUE0Q2wvQixRQUE1QyxFQURGLENBRDBELENBRzFEcU4sSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU0sSUFBNUMsQ0FBa0QsS0FBbEQsQ0FBeUQsRUFBekQsQ0FIMEQsQ0FBNUQsQ0FIMEQsQ0FBNUQsQ0FEMkQsQ0FBbEQsQ0FBWCxFQVdELENBRUQsR0FBRy9ZLE1BQU0sQ0FBQ2txQyxVQUFQLEdBQXNCdmpDLFNBQXpCLENBQW9DLENBQ2xDbU8sS0FBSyxDQUFDdE4sSUFBTixDQUFXMlEsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxJQUE1QyxDQUFrRCxDQUMzREosSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRVQsSUFBSSxDQUFDcUcsWUFBTCxDQUFrQnhlLE1BQU0sQ0FBQ2txQyxVQUF6QixFQUFxQ3AvQixRQUFyQyxFQURGLENBRDJELENBQWxELENBQVgsRUFJRCxDQUVELE1BQU9xTixLQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RDFFLEtBQTVELENBQVAsQ0FFRixRQUNFLE1BQU9xRCxLQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTSxJQUE1QyxDQUFrRCxLQUFsRCxDQUF5RCxFQUF6RCxDQUFQLENBdENGLENBd0NELENBRUQ7Ozs7Ozs7R0FRQSxRQUFTbzVCLHFCQUFULENBQThCaEgsR0FBOUIsQ0FBbUMsQ0FDakM7QUFDQSxHQUFJamdDLEtBQUksQ0FBR2lOLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0QsRUFBbEQsQ0FBWCxDQUVBO0FBQ0EsR0FBRzR5QixHQUFHLENBQUNqakMsVUFBSixDQUFlM00sTUFBZixHQUEwQixDQUE3QixDQUFnQyxDQUM5QixNQUFPMlAsS0FBUCxDQUNELENBRUQ7QUFDQSxHQUFJaWhDLE1BQUssQ0FBR2hCLEdBQUcsQ0FBQ2pqQyxVQUFoQixDQUNBLElBQUksR0FBSXBELEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3FuQyxLQUFLLENBQUM1d0MsTUFBekIsQ0FBaUMsRUFBRXVKLENBQW5DLENBQXNDLENBQ3BDLEdBQUkrQyxLQUFJLENBQUdza0MsS0FBSyxDQUFDcm5DLENBQUQsQ0FBaEIsQ0FDQSxHQUFJdVAsTUFBSyxDQUFHeE0sSUFBSSxDQUFDd00sS0FBakIsQ0FFQTtBQUNBLEdBQUlpMUIsY0FBYSxDQUFHbnhCLElBQUksQ0FBQ00sSUFBTCxDQUFVYSxJQUE5QixDQUNBLEdBQUcsaUJBQW1CelIsS0FBdEIsQ0FBNEIsQ0FDMUJ5aEMsYUFBYSxDQUFHemhDLElBQUksQ0FBQ3loQyxhQUFyQixDQUNELENBQ0QsR0FBR0EsYUFBYSxHQUFLbnhCLElBQUksQ0FBQ00sSUFBTCxDQUFVYSxJQUEvQixDQUFxQyxDQUNuQ2pGLEtBQUssQ0FBR3hSLEtBQUssQ0FBQ3dELElBQU4sQ0FBVytELFVBQVgsQ0FBc0JpSyxLQUF0QixDQUFSLENBQ0QsQ0FDRCxHQUFJczlCLGlCQUFnQixDQUFHLEtBQXZCLENBQ0EsR0FBRyxvQkFBc0I5cEMsS0FBekIsQ0FBK0IsQ0FDN0I4cEMsZ0JBQWdCLENBQUc5cEMsSUFBSSxDQUFDOHBDLGdCQUF4QixDQUNELENBQ0Q7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFJbEksSUFBRyxDQUFHdHhCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQ3BFO0FBQ0FyQixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUFpRCxLQUFqRCxDQUNFYixJQUFJLENBQUNrRSxRQUFMLENBQWN4VSxJQUFJLENBQUMySixJQUFuQixFQUF5QjFHLFFBQXpCLEVBREYsQ0FGb0UsQ0FJcEVxTixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FBNUMsQ0FBaUQsSUFBakQsQ0FBdUQsQ0FDckQ7QUFDQXRCLElBQUksQ0FBQ3RXLE1BQUwsQ0FDRXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURiLENBQ3dCaXhCLGFBRHhCLENBQ3VDcUksZ0JBRHZDLENBQ3lEdDlCLEtBRHpELENBRnFELENBQXZELENBSm9FLENBQTVELENBQVYsQ0FVQW5KLElBQUksQ0FBQ21KLEtBQUwsQ0FBVzdNLElBQVgsQ0FBZ0JpaUMsR0FBaEIsRUFDRCxDQUVELE1BQU92K0IsS0FBUCxDQUNELENBRUQsR0FBTWtuQyxXQUFVLENBQUcsR0FBSXhxQyxLQUFKLENBQVMsc0JBQVQsQ0FBbkIsQ0FDQSxHQUFNeXFDLFdBQVUsQ0FBRyxHQUFJenFDLEtBQUosQ0FBUyxzQkFBVCxDQUFuQixDQUVBOzs7Ozs7O0dBUUMsUUFBUzBxQyxZQUFULENBQXFCMTFCLElBQXJCLENBQTBCLENBQ3pCLEdBQUdBLElBQUksRUFBSXcxQixVQUFSLEVBQXNCeDFCLElBQUksQ0FBR3kxQixVQUFoQyxDQUE0QyxDQUMxQyxNQUFPbDZCLEtBQUksQ0FBQ3RXLE1BQUwsQ0FDTHNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUROLENBQ2lCRixJQUFJLENBQUNNLElBQUwsQ0FBVW1CLE9BRDNCLENBQ29DLEtBRHBDLENBRUx6QixJQUFJLENBQUM2RixhQUFMLENBQW1CcEIsSUFBbkIsQ0FGSyxDQUFQLENBR0QsQ0FKRCxJQUlPLENBQ0wsTUFBT3pFLEtBQUksQ0FBQ3RXLE1BQUwsQ0FDTHNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUROLENBQ2lCRixJQUFJLENBQUNNLElBQUwsQ0FBVW9CLGVBRDNCLENBQzRDLEtBRDVDLENBRUwxQixJQUFJLENBQUNvRyxxQkFBTCxDQUEyQjNCLElBQTNCLENBRkssQ0FBUCxDQUdELENBQ0YsQ0FFRDs7Ozs7O0dBT0F0WixHQUFHLENBQUNzcEMsaUJBQUosQ0FBd0IsU0FBU2xDLElBQVQsQ0FBZSxDQUNyQztBQUNBLEdBQUlnQixVQUFTLENBQUc0RyxXQUFXLENBQUM1SCxJQUFJLENBQUNlLFFBQUwsQ0FBY0MsU0FBZixDQUEzQixDQUNBLEdBQUlDLFNBQVEsQ0FBRzJHLFdBQVcsQ0FBQzVILElBQUksQ0FBQ2UsUUFBTCxDQUFjRSxRQUFmLENBQTFCLENBQ0EsR0FBSTRHLElBQUcsQ0FBR3A2QixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUNwRTtBQUNBckIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxJQUE1QyxDQUFrRCxDQUNoRDtBQUNBSixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUE1QyxDQUFxRCxLQUFyRCxDQUNFVCxJQUFJLENBQUNxRyxZQUFMLENBQWtCa3NCLElBQUksQ0FBQ2xjLE9BQXZCLEVBQWdDMWpCLFFBQWhDLEVBREYsQ0FGZ0QsQ0FBbEQsQ0FGb0UsQ0FPcEU7QUFDQXFOLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0UvVixLQUFLLENBQUN3RCxJQUFOLENBQVdzSSxVQUFYLENBQXNCKzdCLElBQUksQ0FBQ1ksWUFBM0IsQ0FERixDQVJvRSxDQVVwRTtBQUNBbnpCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEO0FBQ0FyQixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUFpRCxLQUFqRCxDQUNFYixJQUFJLENBQUNrRSxRQUFMLENBQWNxdUIsSUFBSSxDQUFDYyxPQUFMLENBQWF4QixZQUEzQixFQUF5Q2wvQixRQUF6QyxFQURGLENBRjBELENBSTFEO0FBQ0FvbkMsMEJBQTBCLENBQ3hCeEgsSUFBSSxDQUFDYyxPQUFMLENBQWF4QixZQURXLENBQ0dVLElBQUksQ0FBQ2MsT0FBTCxDQUFhNWMsVUFEaEIsQ0FMZ0MsQ0FBNUQsQ0FYb0UsQ0FtQnBFO0FBQ0E0aUIsU0FBUyxDQUFDOUcsSUFBSSxDQUFDa0IsTUFBTixDQXBCMkQsQ0FxQnBFO0FBQ0F6ekIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMURreUIsU0FEMEQsQ0FFMURDLFFBRjBELENBQTVELENBdEJvRSxDQTBCcEU7QUFDQTZGLFNBQVMsQ0FBQzlHLElBQUksQ0FBQ3VCLE9BQU4sQ0EzQjJELENBNEJwRTtBQUNBM29DLEdBQUcsQ0FBQzZsQixlQUFKLENBQW9CdWhCLElBQUksQ0FBQ2xuQyxTQUF6QixDQTdCb0UsQ0FBNUQsQ0FBVixDQWdDQSxHQUFHa25DLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWVEsUUFBZixDQUF5QixDQUN2QjtBQUNBbUcsR0FBRyxDQUFDbCtCLEtBQUosQ0FBVTdNLElBQVYsQ0FDRTJRLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0QsQ0FDaERKLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVJLFNBQTVDLENBQXVELEtBQXZELENBQ0U7QUFDQXRQLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQixJQUFwQixFQUNBa2hDLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWVEsUUFIZCxDQURnRCxDQUFsRCxDQURGLEVBU0QsQ0FDRCxHQUFHMUIsSUFBSSxDQUFDdUIsT0FBTCxDQUFhRyxRQUFoQixDQUEwQixDQUN4QjtBQUNBbUcsR0FBRyxDQUFDbCtCLEtBQUosQ0FBVTdNLElBQVYsQ0FDRTJRLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0QsQ0FDaERKLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVJLFNBQTVDLENBQXVELEtBQXZELENBQ0U7QUFDQXRQLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQixJQUFwQixFQUNBa2hDLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYUcsUUFIZixDQURnRCxDQUFsRCxDQURGLEVBU0QsQ0FFRCxHQUFHMUIsSUFBSSxDQUFDZixVQUFMLENBQWdCcHVDLE1BQWhCLENBQXlCLENBQTVCLENBQStCLENBQzdCO0FBQ0FnM0MsR0FBRyxDQUFDbCtCLEtBQUosQ0FBVTdNLElBQVYsQ0FBZWxFLEdBQUcsQ0FBQ2t2QywyQkFBSixDQUFnQzlILElBQUksQ0FBQ2YsVUFBckMsQ0FBZixFQUNELENBRUQsTUFBTzRJLElBQVAsQ0FDRCxDQW5FRCxDQXFFQTs7Ozs7OztHQVFBanZDLEdBQUcsQ0FBQ2d1QywyQkFBSixDQUFrQyxTQUFTbkcsR0FBVCxDQUFjLENBQzlDO0FBQ0EsR0FBSW9HLElBQUcsQ0FBR3A1QixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUNwRTtBQUNBckIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRVQsSUFBSSxDQUFDcUcsWUFBTCxDQUFrQjJzQixHQUFHLENBQUMzYyxPQUF0QixFQUErQjFqQixRQUEvQixFQURGLENBRm9FLENBSXBFO0FBQ0EwbUMsU0FBUyxDQUFDckcsR0FBRyxDQUFDYyxPQUFMLENBTDJELENBTXBFO0FBQ0Ezb0MsR0FBRyxDQUFDNmxCLGVBQUosQ0FBb0JnaUIsR0FBRyxDQUFDM25DLFNBQXhCLENBUG9FLENBUXBFO0FBQ0EydUMsb0JBQW9CLENBQUNoSCxHQUFELENBVGdELENBQTVELENBQVYsQ0FZQSxNQUFPb0csSUFBUCxDQUNELENBZkQsQ0FpQkE7Ozs7OztHQU9BanVDLEdBQUcsQ0FBQ212Qyx1QkFBSixDQUE4QixTQUFTQyxFQUFULENBQWEsQ0FDekMsTUFBT2xCLFVBQVMsQ0FBQ2tCLEVBQUQsQ0FBaEIsQ0FDRCxDQUZELENBSUE7Ozs7OztHQU9BcHZDLEdBQUcsQ0FBQ3FuQyxpQkFBSixDQUF3QixTQUFTRCxJQUFULENBQWUsQ0FDckM7QUFDQSxHQUFJaUMsZUFBYyxDQUFHakMsSUFBSSxDQUFDaUMsY0FBTCxFQUF1QnJwQyxHQUFHLENBQUNzcEMsaUJBQUosQ0FBc0JsQyxJQUF0QixDQUE1QyxDQUVBO0FBQ0EsTUFBT3Z5QixLQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUNqRTtBQUNBbXpCLGNBRmlFLENBR2pFO0FBQ0F4MEIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY3F1QixJQUFJLENBQUNhLFlBQW5CLEVBQWlDemdDLFFBQWpDLEVBREYsQ0FGMEQsQ0FJMUQ7QUFDQW9uQywwQkFBMEIsQ0FBQ3hILElBQUksQ0FBQ2EsWUFBTixDQUFvQmIsSUFBSSxDQUFDeUMsbUJBQXpCLENBTGdDLENBQTVELENBSmlFLENBV2pFO0FBQ0FoMUIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FBNUMsQ0FBdUQsS0FBdkQsQ0FDRXRQLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQixJQUFwQixFQUE0QmtoQyxJQUFJLENBQUM5aUIsU0FEbkMsQ0FaaUUsQ0FBNUQsQ0FBUCxDQWVELENBcEJELENBc0JBOzs7Ozs7R0FPQXRrQixHQUFHLENBQUNrdkMsMkJBQUosQ0FBa0MsU0FBU2pHLElBQVQsQ0FBZSxDQUMvQztBQUNBLEdBQUlyaEMsS0FBSSxDQUFHaU4sSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxJQUE1QyxDQUFrRCxFQUFsRCxDQUFYLENBRUE7QUFDQSxHQUFJa3hCLElBQUcsQ0FBR3R4QixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxFQUE1RCxDQUFWLENBQ0F0TyxJQUFJLENBQUNtSixLQUFMLENBQVc3TSxJQUFYLENBQWdCaWlDLEdBQWhCLEVBRUEsSUFBSSxHQUFJM2tDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3luQyxJQUFJLENBQUNoeEMsTUFBeEIsQ0FBZ0MsRUFBRXVKLENBQWxDLENBQXFDLENBQ25DMmtDLEdBQUcsQ0FBQ3AxQixLQUFKLENBQVU3TSxJQUFWLENBQWVsRSxHQUFHLENBQUNzdUMsMEJBQUosQ0FBK0JyRixJQUFJLENBQUN6bkMsQ0FBRCxDQUFuQyxDQUFmLEVBQ0QsQ0FFRCxNQUFPb0csS0FBUCxDQUNELENBYkQsQ0FlQTs7Ozs7O0dBT0E1SCxHQUFHLENBQUNzdUMsMEJBQUosQ0FBaUMsU0FBU2xGLEdBQVQsQ0FBYyxDQUM3QztBQUNBLEdBQUl3QyxPQUFNLENBQUcvMkIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsRUFBNUQsQ0FBYixDQUVBO0FBQ0EwMUIsTUFBTSxDQUFDNzZCLEtBQVAsQ0FBYTdNLElBQWIsQ0FBa0IyUSxJQUFJLENBQUN0VyxNQUFMLENBQ2hCc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBREssQ0FDTUYsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBRGhCLENBQ3FCLEtBRHJCLENBRWhCYixJQUFJLENBQUNrRSxRQUFMLENBQWNxd0IsR0FBRyxDQUFDcnRDLEVBQWxCLEVBQXNCeUwsUUFBdEIsRUFGZ0IsQ0FBbEIsRUFJQTtBQUNBLEdBQUc0aEMsR0FBRyxDQUFDeUMsUUFBUCxDQUFpQixDQUNmO0FBQ0FELE1BQU0sQ0FBQzc2QixLQUFQLENBQWE3TSxJQUFiLENBQWtCMlEsSUFBSSxDQUFDdFcsTUFBTCxDQUNoQnNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURLLENBQ01GLElBQUksQ0FBQ00sSUFBTCxDQUFVRSxPQURoQixDQUN5QixLQUR6QixDQUVoQnBQLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQixJQUFwQixDQUZnQixDQUFsQixFQUdELENBRUQsR0FBSTZLLE1BQUssQ0FBR3E0QixHQUFHLENBQUNyNEIsS0FBaEIsQ0FDQSxHQUFHLE1BQU9xNEIsSUFBRyxDQUFDcjRCLEtBQVgsR0FBcUIsUUFBeEIsQ0FBa0MsQ0FDaEM7QUFDQUEsS0FBSyxDQUFHOEQsSUFBSSxDQUFDK0QsS0FBTCxDQUFXN0gsS0FBWCxFQUFrQnZKLFFBQWxCLEVBQVIsQ0FDRCxDQUVEO0FBQ0Fva0MsTUFBTSxDQUFDNzZCLEtBQVAsQ0FBYTdNLElBQWIsQ0FBa0IyUSxJQUFJLENBQUN0VyxNQUFMLENBQ2hCc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBREssQ0FDTUYsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRGhCLENBQzZCLEtBRDdCLENBQ29DekUsS0FEcEMsQ0FBbEIsRUFHQSxNQUFPNjZCLE9BQVAsQ0FDRCxDQTVCRCxDQThCQTs7Ozs7O0dBT0E1ckMsR0FBRyxDQUFDOG5DLDBCQUFKLENBQWlDLFNBQVNELEdBQVQsQ0FBYyxDQUM3QztBQUNBLEdBQUlvRyxJQUFHLENBQUdwRyxHQUFHLENBQUM2Rix3QkFBSixFQUNSMXRDLEdBQUcsQ0FBQ2d1QywyQkFBSixDQUFnQ25HLEdBQWhDLENBREYsQ0FHQTtBQUNBLE1BQU9oekIsS0FBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDakU7QUFDQSszQixHQUZpRSxDQUdqRTtBQUNBcDVCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEO0FBQ0FyQixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUFpRCxLQUFqRCxDQUNFYixJQUFJLENBQUNrRSxRQUFMLENBQWM4dUIsR0FBRyxDQUFDSSxZQUFsQixFQUFnQ3pnQyxRQUFoQyxFQURGLENBRjBELENBSTFEO0FBQ0FvbkMsMEJBQTBCLENBQUMvRyxHQUFHLENBQUNJLFlBQUwsQ0FBbUJKLEdBQUcsQ0FBQ2dDLG1CQUF2QixDQUxnQyxDQUE1RCxDQUppRSxDQVdqRTtBQUNBaDFCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVJLFNBQTVDLENBQXVELEtBQXZELENBQ0V0UCxNQUFNLENBQUNDLFlBQVAsQ0FBb0IsSUFBcEIsRUFBNEIyaEMsR0FBRyxDQUFDdmpCLFNBRGxDLENBWmlFLENBQTVELENBQVAsQ0FlRCxDQXJCRCxDQXVCQTs7Ozs7OztHQVFBdGtCLEdBQUcsQ0FBQ3F2QyxhQUFKLENBQW9CLFNBQVNDLEtBQVQsQ0FBZ0IsQ0FDbEM7QUFDQSxHQUFJQyxRQUFPLENBQUcsQ0FDWjtBQUNBRCxLQUFLLENBQUUsRUFGSyxDQUFkLENBS0E7Ozs7Ozs7S0FRQUMsT0FBTyxDQUFDQyxTQUFSLENBQW9CLFNBQVNwSSxJQUFULENBQWUsQ0FDakMsR0FBSXgvQixLQUFJLENBQUc2bkMsWUFBWSxDQUFDckksSUFBSSxDQUFDa0IsTUFBTixDQUF2QixDQUVBO0FBQ0E7Ozs7OztPQVFBLE1BQU8xZ0MsS0FBUCxDQUNELENBYkQsQ0FlQTs7Ozs7S0FNQTJuQyxPQUFPLENBQUNHLGNBQVIsQ0FBeUIsU0FBU3RJLElBQVQsQ0FBZSxDQUN0QztBQUNBLEdBQUcsTUFBT0EsS0FBUCxHQUFnQixRQUFuQixDQUE2QixDQUMzQkEsSUFBSSxDQUFHN25DLEtBQUssQ0FBQ1MsR0FBTixDQUFVZ25DLGtCQUFWLENBQTZCSSxJQUE3QixDQUFQLENBQ0QsQ0FFRHVJLG9CQUFvQixDQUFDdkksSUFBSSxDQUFDdUIsT0FBTixDQUFwQixDQUVBLEdBQUcsQ0FBQzRHLE9BQU8sQ0FBQ0ssY0FBUixDQUF1QnhJLElBQXZCLENBQUosQ0FBa0MsQ0FBRztBQUNuQyxHQUFHQSxJQUFJLENBQUN1QixPQUFMLENBQWE5cUMsSUFBYixHQUFxQjB4QyxRQUFPLENBQUNELEtBQWhDLENBQXVDLENBQ3JDO0FBQ0EsR0FBSTM0QixJQUFHLENBQUc0NEIsT0FBTyxDQUFDRCxLQUFSLENBQWNsSSxJQUFJLENBQUN1QixPQUFMLENBQWE5cUMsSUFBM0IsQ0FBVixDQUNBLEdBQUcsQ0FBQzBCLEtBQUssQ0FBQ3dELElBQU4sQ0FBV21DLE9BQVgsQ0FBbUJ5UixHQUFuQixDQUFKLENBQTZCLENBQzNCQSxHQUFHLENBQUcsQ0FBQ0EsR0FBRCxDQUFOLENBQ0QsQ0FDREEsR0FBRyxDQUFDelMsSUFBSixDQUFTa2pDLElBQVQsRUFDQW1JLE9BQU8sQ0FBQ0QsS0FBUixDQUFjbEksSUFBSSxDQUFDdUIsT0FBTCxDQUFhOXFDLElBQTNCLEVBQW1DOFksR0FBbkMsQ0FDRCxDQVJELElBUU8sQ0FDTDQ0QixPQUFPLENBQUNELEtBQVIsQ0FBY2xJLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYTlxQyxJQUEzQixFQUFtQ3VwQyxJQUFuQyxDQUNELENBQ0YsQ0FDRixDQXJCRCxDQXVCQTs7Ozs7OztLQVFBbUksT0FBTyxDQUFDSyxjQUFSLENBQXlCLFNBQVN4SSxJQUFULENBQWUsQ0FDdEM7QUFDQSxHQUFHLE1BQU9BLEtBQVAsR0FBZ0IsUUFBbkIsQ0FBNkIsQ0FDM0JBLElBQUksQ0FBRzduQyxLQUFLLENBQUNTLEdBQU4sQ0FBVWduQyxrQkFBVixDQUE2QkksSUFBN0IsQ0FBUCxDQUNELENBRUQsR0FBSS8xQixNQUFLLENBQUdvK0IsWUFBWSxDQUFDckksSUFBSSxDQUFDdUIsT0FBTixDQUF4QixDQUNBLEdBQUcsQ0FBQ3QzQixLQUFKLENBQVcsQ0FDVCxNQUFPLE1BQVAsQ0FDRCxDQUNELEdBQUcsQ0FBQzlSLEtBQUssQ0FBQ3dELElBQU4sQ0FBV21DLE9BQVgsQ0FBbUJtTSxLQUFuQixDQUFKLENBQStCLENBQzdCQSxLQUFLLENBQUcsQ0FBQ0EsS0FBRCxDQUFSLENBQ0QsQ0FDRDtBQUNBLEdBQUl3K0IsS0FBSSxDQUFHaDdCLElBQUksQ0FBQytELEtBQUwsQ0FBVzVZLEdBQUcsQ0FBQ3FuQyxpQkFBSixDQUFzQkQsSUFBdEIsQ0FBWCxFQUF3QzUvQixRQUF4QyxFQUFYLENBQ0EsSUFBSSxHQUFJaEcsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHNlAsS0FBSyxDQUFDcFosTUFBekIsQ0FBaUMsRUFBRXVKLENBQW5DLENBQXNDLENBQ3BDLEdBQUlzdUMsS0FBSSxDQUFHajdCLElBQUksQ0FBQytELEtBQUwsQ0FBVzVZLEdBQUcsQ0FBQ3FuQyxpQkFBSixDQUFzQmgyQixLQUFLLENBQUM3UCxDQUFELENBQTNCLENBQVgsRUFBNENnRyxRQUE1QyxFQUFYLENBQ0EsR0FBR3FvQyxJQUFJLEdBQUtDLElBQVosQ0FBa0IsQ0FDaEIsTUFBTyxLQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sTUFBUCxDQUNELENBdEJELENBd0JBOzs7O0tBS0FQLE9BQU8sQ0FBQ1EsbUJBQVIsQ0FBOEIsVUFBVyxDQUN2QyxHQUFJQyxTQUFRLENBQUcsRUFBZixDQUVBLElBQUksR0FBSW55QyxLQUFSLEdBQWdCMHhDLFFBQU8sQ0FBQ0QsS0FBeEIsQ0FBK0IsQ0FDN0IsR0FBR0MsT0FBTyxDQUFDRCxLQUFSLENBQWM1c0MsY0FBZCxDQUE2QjdFLElBQTdCLENBQUgsQ0FBdUMsQ0FDckMsR0FBSWtULE1BQUssQ0FBR3crQixPQUFPLENBQUNELEtBQVIsQ0FBY3p4QyxJQUFkLENBQVosQ0FDQSxHQUFHLENBQUMwQixLQUFLLENBQUN3RCxJQUFOLENBQVdtQyxPQUFYLENBQW1CNkwsS0FBbkIsQ0FBSixDQUErQixDQUM3QmkvQixRQUFRLENBQUM5ckMsSUFBVCxDQUFjNk0sS0FBZCxFQUNELENBRkQsSUFFTyxDQUNMLElBQUksR0FBSXZQLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3VQLEtBQUssQ0FBQzlZLE1BQXpCLENBQWlDLEVBQUV1SixDQUFuQyxDQUFzQyxDQUNwQ3d1QyxRQUFRLENBQUM5ckMsSUFBVCxDQUFjNk0sS0FBSyxDQUFDdlAsQ0FBRCxDQUFuQixFQUNELENBQ0YsQ0FDRixDQUNGLENBRUQsTUFBT3d1QyxTQUFQLENBQ0QsQ0FqQkQsQ0FtQkE7Ozs7Ozs7O0tBU0FULE9BQU8sQ0FBQ1UsaUJBQVIsQ0FBNEIsU0FBUzdJLElBQVQsQ0FBZSxDQUN6QyxHQUFJN3RDLE9BQUosQ0FFQTtBQUNBLEdBQUcsTUFBTzZ0QyxLQUFQLEdBQWdCLFFBQW5CLENBQTZCLENBQzNCQSxJQUFJLENBQUc3bkMsS0FBSyxDQUFDUyxHQUFOLENBQVVnbkMsa0JBQVYsQ0FBNkJJLElBQTdCLENBQVAsQ0FDRCxDQUNEdUksb0JBQW9CLENBQUN2SSxJQUFJLENBQUN1QixPQUFOLENBQXBCLENBQ0EsR0FBRyxDQUFDNEcsT0FBTyxDQUFDSyxjQUFSLENBQXVCeEksSUFBdkIsQ0FBSixDQUFrQyxDQUNoQyxNQUFPLEtBQVAsQ0FDRCxDQUVELEdBQUkvMUIsTUFBSyxDQUFHbytCLFlBQVksQ0FBQ3JJLElBQUksQ0FBQ3VCLE9BQU4sQ0FBeEIsQ0FFQSxHQUFHLENBQUNwcEMsS0FBSyxDQUFDd0QsSUFBTixDQUFXbUMsT0FBWCxDQUFtQm1NLEtBQW5CLENBQUosQ0FBK0IsQ0FDN0I5WCxNQUFNLENBQUdnMkMsT0FBTyxDQUFDRCxLQUFSLENBQWNsSSxJQUFJLENBQUN1QixPQUFMLENBQWE5cUMsSUFBM0IsQ0FBVCxDQUNBLE1BQU8weEMsUUFBTyxDQUFDRCxLQUFSLENBQWNsSSxJQUFJLENBQUN1QixPQUFMLENBQWE5cUMsSUFBM0IsQ0FBUCxDQUNBLE1BQU90RSxPQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUlzMkMsS0FBSSxDQUFHaDdCLElBQUksQ0FBQytELEtBQUwsQ0FBVzVZLEdBQUcsQ0FBQ3FuQyxpQkFBSixDQUFzQkQsSUFBdEIsQ0FBWCxFQUF3QzUvQixRQUF4QyxFQUFYLENBQ0EsSUFBSSxHQUFJaEcsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHNlAsS0FBSyxDQUFDcFosTUFBekIsQ0FBaUMsRUFBRXVKLENBQW5DLENBQXNDLENBQ3BDLEdBQUlzdUMsS0FBSSxDQUFHajdCLElBQUksQ0FBQytELEtBQUwsQ0FBVzVZLEdBQUcsQ0FBQ3FuQyxpQkFBSixDQUFzQmgyQixLQUFLLENBQUM3UCxDQUFELENBQTNCLENBQVgsRUFBNENnRyxRQUE1QyxFQUFYLENBQ0EsR0FBR3FvQyxJQUFJLEdBQUtDLElBQVosQ0FBa0IsQ0FDaEJ2MkMsTUFBTSxDQUFHOFgsS0FBSyxDQUFDN1AsQ0FBRCxDQUFkLENBQ0E2UCxLQUFLLENBQUMyQixNQUFOLENBQWF4UixDQUFiLENBQWdCLENBQWhCLEVBQ0QsQ0FDRixDQUNELEdBQUc2UCxLQUFLLENBQUNwWixNQUFOLEdBQWlCLENBQXBCLENBQXVCLENBQ3JCLE1BQU9zM0MsUUFBTyxDQUFDRCxLQUFSLENBQWNsSSxJQUFJLENBQUN1QixPQUFMLENBQWE5cUMsSUFBM0IsQ0FBUCxDQUNELENBRUQsTUFBT3RFLE9BQVAsQ0FDRCxDQWxDRCxDQW9DQSxRQUFTazJDLGFBQVQsQ0FBc0I5RyxPQUF0QixDQUErQixDQUM3QmdILG9CQUFvQixDQUFDaEgsT0FBRCxDQUFwQixDQUNBLE1BQU80RyxRQUFPLENBQUNELEtBQVIsQ0FBYzNHLE9BQU8sQ0FBQzlxQyxJQUF0QixHQUErQixJQUF0QyxDQUNELENBRUQsUUFBUzh4QyxxQkFBVCxDQUE4QmhILE9BQTlCLENBQXVDLENBQ3JDO0FBQ0EsR0FBRyxDQUFDQSxPQUFPLENBQUM5cUMsSUFBWixDQUFrQixDQUNoQixHQUFJMmUsR0FBRSxDQUFHamQsS0FBSyxDQUFDaWQsRUFBTixDQUFTbVMsSUFBVCxDQUFjcHdCLE1BQWQsRUFBVCxDQUNBb3FDLE9BQU8sQ0FBQy9qQyxVQUFSLENBQXNCNUUsR0FBRyxDQUFDNmxDLG9CQUFKLENBQXlCcUksU0FBUyxDQUFDdkYsT0FBRCxDQUFsQyxDQUE2Q25zQixFQUE3QyxDQUF0QixDQUNBbXNCLE9BQU8sQ0FBQzlxQyxJQUFSLENBQWUyZSxFQUFFLENBQUM0QyxNQUFILEdBQVlyVyxLQUFaLEVBQWYsQ0FDRCxDQUNGLENBRUQ7QUFDQSxHQUFHdW1DLEtBQUgsQ0FBVSxDQUNSO0FBQ0EsSUFBSSxHQUFJOXRDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzh0QyxLQUFLLENBQUNyM0MsTUFBekIsQ0FBaUMsRUFBRXVKLENBQW5DLENBQXNDLENBQ3BDLEdBQUk0bEMsS0FBSSxDQUFHa0ksS0FBSyxDQUFDOXRDLENBQUQsQ0FBaEIsQ0FDQSt0QyxPQUFPLENBQUNHLGNBQVIsQ0FBdUJ0SSxJQUF2QixFQUNELENBQ0YsQ0FFRCxNQUFPbUksUUFBUCxDQUNELENBeExELENBMExBOztHQUdBdnZDLEdBQUcsQ0FBQ2t3QyxnQkFBSixDQUF1QixDQUNyQkMsZUFBZSxDQUFFLDBCQURJLENBRXJCQyx1QkFBdUIsQ0FBRSxrQ0FGSixDQUdyQkMsbUJBQW1CLENBQUUsOEJBSEEsQ0FJckJDLG1CQUFtQixDQUFFLDhCQUpBLENBS3JCQyxtQkFBbUIsQ0FBRSw4QkFMQSxDQU1yQkMsVUFBVSxDQUFFLHVDQU5TLENBQXZCLENBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1QkF4d0MsR0FBRyxDQUFDeXdDLHNCQUFKLENBQTZCLFNBQVNsQixPQUFULENBQWtCbUIsS0FBbEIsQ0FBeUJyc0IsTUFBekIsQ0FBaUMsQ0FDNUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBRDRELENBMkY1RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkEzRjRELENBa0k1RDtBQUNBO0FBQ0Fxc0IsS0FBSyxDQUFHQSxLQUFLLENBQUMxc0MsS0FBTixDQUFZLENBQVosQ0FBUixDQUNBLEdBQUlzckMsTUFBSyxDQUFHb0IsS0FBSyxDQUFDMXNDLEtBQU4sQ0FBWSxDQUFaLENBQVosQ0FFQTtBQUNBLEdBQUlLLElBQUcsQ0FBRyxHQUFJQyxLQUFKLEVBQVYsQ0FFQTtBQUNBO0FBQ0EsR0FBSStoQixNQUFLLENBQUcsSUFBWixDQUNBLEdBQUkzc0IsTUFBSyxDQUFHLElBQVosQ0FDQSxHQUFJd2UsTUFBSyxDQUFHLENBQVosQ0FDQSxFQUFHLENBQ0QsR0FBSWt2QixLQUFJLENBQUdzSixLQUFLLENBQUM1Z0MsS0FBTixFQUFYLENBQ0EsR0FBSWs2QixPQUFNLENBQUcsSUFBYixDQUNBLEdBQUkyRyxXQUFVLENBQUcsS0FBakIsQ0FFQTtBQUNBLEdBQUd0c0MsR0FBRyxDQUFHK2lDLElBQUksQ0FBQ2UsUUFBTCxDQUFjQyxTQUFwQixFQUFpQy9qQyxHQUFHLENBQUcraUMsSUFBSSxDQUFDZSxRQUFMLENBQWNFLFFBQXhELENBQWtFLENBQ2hFM3VDLEtBQUssQ0FBRyxDQUNOMEIsT0FBTyxDQUFFLDhDQURILENBRU4xQixLQUFLLENBQUVzRyxHQUFHLENBQUNrd0MsZ0JBQUosQ0FBcUJJLG1CQUZ0QixDQUdObEksU0FBUyxDQUFFaEIsSUFBSSxDQUFDZSxRQUFMLENBQWNDLFNBSG5CLENBSU5DLFFBQVEsQ0FBRWpCLElBQUksQ0FBQ2UsUUFBTCxDQUFjRSxRQUpsQixDQUtOaGtDLEdBQUcsQ0FBRUEsR0FMQyxDQUFSLENBT0QsQ0FFRDtBQUNBLEdBQUczSyxLQUFLLEdBQUssSUFBYixDQUFtQixDQUNqQnN3QyxNQUFNLENBQUcwRyxLQUFLLENBQUMsQ0FBRCxDQUFMLEVBQVluQixPQUFPLENBQUNDLFNBQVIsQ0FBa0JwSSxJQUFsQixDQUFyQixDQUNBLEdBQUc0QyxNQUFNLEdBQUssSUFBZCxDQUFvQixDQUNsQjtBQUNBLEdBQUc1QyxJQUFJLENBQUMyQyxRQUFMLENBQWMzQyxJQUFkLENBQUgsQ0FBd0IsQ0FDdEJ1SixVQUFVLENBQUcsSUFBYixDQUNBM0csTUFBTSxDQUFHNUMsSUFBVCxDQUNELENBQ0YsQ0FFRCxHQUFHNEMsTUFBSCxDQUFXLENBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUk0RyxRQUFPLENBQUc1RyxNQUFkLENBQ0EsR0FBRyxDQUFDenFDLEtBQUssQ0FBQ3dELElBQU4sQ0FBV21DLE9BQVgsQ0FBbUIwckMsT0FBbkIsQ0FBSixDQUFpQyxDQUMvQkEsT0FBTyxDQUFHLENBQUNBLE9BQUQsQ0FBVixDQUNELENBRUQ7QUFDQSxHQUFJQyxTQUFRLENBQUcsS0FBZixDQUNBLE1BQU0sQ0FBQ0EsUUFBRCxFQUFhRCxPQUFPLENBQUMzNEMsTUFBUixDQUFpQixDQUFwQyxDQUF1QyxDQUNyQyt4QyxNQUFNLENBQUc0RyxPQUFPLENBQUM5Z0MsS0FBUixFQUFULENBQ0EsR0FBSSxDQUNGK2dDLFFBQVEsQ0FBRzdHLE1BQU0sQ0FBQzNsQixNQUFQLENBQWMraUIsSUFBZCxDQUFYLENBQ0QsQ0FBQyxNQUFNOTRCLEVBQU4sQ0FBVSxDQUNWO0FBQ0QsQ0FDRixDQUVELEdBQUcsQ0FBQ3VpQyxRQUFKLENBQWMsQ0FDWm4zQyxLQUFLLENBQUcsQ0FDTjBCLE9BQU8sQ0FBRSxtQ0FESCxDQUVOMUIsS0FBSyxDQUFFc0csR0FBRyxDQUFDa3dDLGdCQUFKLENBQXFCQyxlQUZ0QixDQUFSLENBSUQsQ0FDRixDQUVELEdBQUd6MkMsS0FBSyxHQUFLLElBQVYsR0FBbUIsQ0FBQ3N3QyxNQUFELEVBQVcyRyxVQUE5QixHQUNELENBQUNwQixPQUFPLENBQUNLLGNBQVIsQ0FBdUJ4SSxJQUF2QixDQURILENBQ2lDLENBQy9CO0FBQ0ExdEMsS0FBSyxDQUFHLENBQ04wQixPQUFPLENBQUUsNkJBREgsQ0FFTjFCLEtBQUssQ0FBRXNHLEdBQUcsQ0FBQ2t3QyxnQkFBSixDQUFxQk0sVUFGdEIsQ0FBUixDQUlELENBQ0YsQ0FFRDtBQUVBO0FBQ0EsR0FBRzkyQyxLQUFLLEdBQUssSUFBVixFQUFrQnN3QyxNQUFsQixFQUE0QixDQUFDNUMsSUFBSSxDQUFDMkMsUUFBTCxDQUFjQyxNQUFkLENBQWhDLENBQXVELENBQ3JEO0FBQ0F0d0MsS0FBSyxDQUFHLENBQ04wQixPQUFPLENBQUUsZ0NBREgsQ0FFTjFCLEtBQUssQ0FBRXNHLEdBQUcsQ0FBQ2t3QyxnQkFBSixDQUFxQkMsZUFGdEIsQ0FBUixDQUlELENBRUQ7QUFFQTtBQUVBO0FBQ0EsR0FBR3oyQyxLQUFLLEdBQUssSUFBYixDQUFtQixDQUNqQjtBQUNBLEdBQUlvM0MsR0FBRSxDQUFHLENBQ1BDLFFBQVEsQ0FBRSxJQURILENBRVBDLGdCQUFnQixDQUFFLElBRlgsQ0FBVCxDQUlBLElBQUksR0FBSXh2QyxFQUFDLENBQUcsQ0FBWixDQUFlOUgsS0FBSyxHQUFLLElBQVYsRUFBa0I4SCxDQUFDLENBQUc0bEMsSUFBSSxDQUFDZixVQUFMLENBQWdCcHVDLE1BQXJELENBQTZELEVBQUV1SixDQUEvRCxDQUFrRSxDQUNoRSxHQUFJNG5DLElBQUcsQ0FBR2hDLElBQUksQ0FBQ2YsVUFBTCxDQUFnQjdrQyxDQUFoQixDQUFWLENBQ0EsR0FBRzRuQyxHQUFHLENBQUN5QyxRQUFKLEVBQWdCLEVBQUV6QyxHQUFHLENBQUN0eUMsSUFBSixHQUFZZzZDLEdBQWQsQ0FBbkIsQ0FBc0MsQ0FDcENwM0MsS0FBSyxDQUFHLENBQ04wQixPQUFPLENBQ0wsb0RBRkksQ0FHTjFCLEtBQUssQ0FBRXNHLEdBQUcsQ0FBQ2t3QyxnQkFBSixDQUFxQkUsdUJBSHRCLENBQVIsQ0FLRCxDQUNGLENBQ0YsQ0FFRDtBQUNBO0FBQ0EsR0FBRzEyQyxLQUFLLEdBQUssSUFBVixHQUNBLENBQUMyc0IsS0FBRCxFQUFXcXFCLEtBQUssQ0FBQ3o0QyxNQUFOLEdBQWlCLENBQWpCLEdBQXVCLENBQUMreEMsTUFBRCxFQUFXMkcsVUFBbEMsQ0FEWCxDQUFILENBQytELENBQzdEO0FBQ0EsR0FBSU0sTUFBSyxDQUFHN0osSUFBSSxDQUFDK0IsWUFBTCxDQUFrQixrQkFBbEIsQ0FBWixDQUNBLEdBQUkrSCxZQUFXLENBQUc5SixJQUFJLENBQUMrQixZQUFMLENBQWtCLFVBQWxCLENBQWxCLENBQ0EsR0FBRytILFdBQVcsR0FBSyxJQUFuQixDQUF5QixDQUN2QjtBQUNBO0FBQ0EsR0FBRyxDQUFDQSxXQUFXLENBQUM3RSxXQUFiLEVBQTRCNEUsS0FBSyxHQUFLLElBQXpDLENBQStDLENBQzdDO0FBQ0F2M0MsS0FBSyxDQUFHLENBQ04wQixPQUFPLENBQ0wscURBQ0EsZ0RBREEsQ0FFQSxxREFGQSxDQUdBLGtEQUhBLENBSUEsV0FOSSxDQU9OMUIsS0FBSyxDQUFFc0csR0FBRyxDQUFDa3dDLGdCQUFKLENBQXFCQyxlQVB0QixDQUFSLENBU0QsQ0FDRixDQUNEO0FBQ0EsR0FBR3oyQyxLQUFLLEdBQUssSUFBVixFQUFrQnUzQyxLQUFLLEdBQUssSUFBNUIsRUFBb0MsQ0FBQ0EsS0FBSyxDQUFDeEUsRUFBOUMsQ0FBa0QsQ0FDaEQ7QUFDQS95QyxLQUFLLENBQUcsQ0FDTjBCLE9BQU8sQ0FDTCwwREFDQSxjQUhJLENBSU4xQixLQUFLLENBQUVzRyxHQUFHLENBQUNrd0MsZ0JBQUosQ0FBcUJDLGVBSnRCLENBQVIsQ0FNRCxDQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUd6MkMsS0FBSyxHQUFLLElBQVYsRUFBa0J3M0MsV0FBVyxHQUFLLElBQWxDLEVBQ0QscUJBQXVCRCxNQUR6QixDQUNnQyxDQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUlFLFFBQU8sQ0FBR2o1QixLQUFLLENBQUcsQ0FBdEIsQ0FDQSxHQUFHaTVCLE9BQU8sQ0FBR0YsS0FBSyxDQUFDdkUsaUJBQW5CLENBQXNDLENBQ3BDO0FBQ0FoekMsS0FBSyxDQUFHLENBQ04wQixPQUFPLENBQ0wsMERBRkksQ0FHTjFCLEtBQUssQ0FBRXNHLEdBQUcsQ0FBQ2t3QyxnQkFBSixDQUFxQkMsZUFIdEIsQ0FBUixDQUtELENBQ0YsQ0FDRixDQUVEO0FBQ0EsR0FBSWlCLElBQUcsQ0FBSTEzQyxLQUFLLEdBQUssSUFBWCxDQUFtQixJQUFuQixDQUEwQkEsS0FBSyxDQUFDQSxLQUExQyxDQUNBLEdBQUkyM0MsSUFBRyxDQUFHaHRCLE1BQU0sQ0FBR0EsTUFBTSxDQUFDK3NCLEdBQUQsQ0FBTWw1QixLQUFOLENBQWFvM0IsS0FBYixDQUFULENBQStCOEIsR0FBL0MsQ0FDQSxHQUFHQyxHQUFHLEdBQUssSUFBWCxDQUFpQixDQUNmO0FBQ0EzM0MsS0FBSyxDQUFHLElBQVIsQ0FDRCxDQUhELElBR08sQ0FDTDtBQUNBLEdBQUcwM0MsR0FBRyxHQUFLLElBQVgsQ0FBaUIsQ0FDZjEzQyxLQUFLLENBQUcsQ0FDTjBCLE9BQU8sQ0FBRSwyQ0FESCxDQUVOMUIsS0FBSyxDQUFFc0csR0FBRyxDQUFDa3dDLGdCQUFKLENBQXFCQyxlQUZ0QixDQUFSLENBSUQsQ0FFRDtBQUNBLEdBQUdrQixHQUFHLEVBQUlBLEdBQUcsR0FBSyxDQUFsQixDQUFxQixDQUNuQjtBQUNBLEdBQUcsUUFBT0EsR0FBUCxJQUFlLFFBQWYsRUFBMkIsQ0FBQzl4QyxLQUFLLENBQUN3RCxJQUFOLENBQVdtQyxPQUFYLENBQW1CbXNDLEdBQW5CLENBQS9CLENBQXdELENBQ3RELEdBQUdBLEdBQUcsQ0FBQ2oyQyxPQUFQLENBQWdCLENBQ2IxQixLQUFLLENBQUMwQixPQUFOLENBQWdCaTJDLEdBQUcsQ0FBQ2oyQyxPQUFwQixDQUNGLENBQ0QsR0FBR2kyQyxHQUFHLENBQUMzM0MsS0FBUCxDQUFjLENBQ1pBLEtBQUssQ0FBQ0EsS0FBTixDQUFjMjNDLEdBQUcsQ0FBQzMzQyxLQUFsQixDQUNELENBQ0YsQ0FQRCxJQU9PLElBQUcsTUFBTzIzQyxJQUFQLEdBQWUsUUFBbEIsQ0FBNEIsQ0FDakM7QUFDQTMzQyxLQUFLLENBQUNBLEtBQU4sQ0FBYzIzQyxHQUFkLENBQ0QsQ0FDRixDQUVEO0FBQ0EsS0FBTTMzQyxNQUFOLENBQ0QsQ0FFRDtBQUNBMnNCLEtBQUssQ0FBRyxLQUFSLENBQ0EsRUFBRW5PLEtBQUYsQ0FDRCxDQXBNRCxNQW9NUXc0QixLQUFLLENBQUN6NEMsTUFBTixDQUFlLENBcE12QixFQXNNQSxNQUFPLEtBQVAsQ0FDRCxDQXRWRCxDQXlWQSxLQUFPLENBM2xmRyxDQTRsZlYsUUE1bGZVLENBNmxmVixLQUFPLFNBQVNnSixNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7R0FPQSxHQUFJL0IsTUFBSyxDQUFHK0IsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQTtBQUNBLEdBQUl3b0MsSUFBRyxDQUFHN29DLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQnpCLEtBQUssQ0FBQ3VxQyxHQUFOLENBQVl2cUMsS0FBSyxDQUFDdXFDLEdBQU4sRUFBYSxFQUFwRCxDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkFBLEdBQUcsQ0FBQ3ZyQyxNQUFKLENBQWEsU0FBU2xILE9BQVQsQ0FBa0IsQ0FDN0I7QUFDQSxHQUFHaU0sU0FBUyxDQUFDckwsTUFBVixHQUFxQixDQUF4QixDQUEyQixDQUN6QlosT0FBTyxDQUFHLENBQ1JtbEIsRUFBRSxDQUFFbFosU0FBUyxDQUFDLENBQUQsQ0FETCxDQUVScWpDLEdBQUcsQ0FBRXJqQyxTQUFTLENBQUMsQ0FBRCxDQUZOLENBR1JzakMsVUFBVSxDQUFFdGpDLFNBQVMsQ0FBQyxDQUFELENBSGIsQ0FBVixDQUtELENBRUQsR0FBSXpGLEtBQUksQ0FBR3hHLE9BQU8sQ0FBQ21sQixFQUFuQixDQUNBLEdBQUltcUIsSUFBRyxDQUFHdHZDLE9BQU8sQ0FBQ3N2QyxHQUFsQixDQUNBLEdBQUlsUSxLQUFJLENBQUc1NEIsSUFBSSxDQUFDZ3hCLFlBQWhCLENBRUEsR0FBSXlpQixNQUFLLENBQUdqNkMsT0FBTyxDQUFDdTFCLElBQVIsRUFBZ0IsSUFBNUIsQ0FDQSxHQUFHLE1BQU8wa0IsTUFBUCxHQUFpQixRQUFwQixDQUE4QixDQUM1QjtBQUNBQSxLQUFLLENBQUcveEMsS0FBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBWCxDQUF3QjJvQyxLQUF4QixDQUFSLENBQ0QsQ0FFRCxHQUFJQyxLQUFKLENBQ0EsR0FBRyxjQUFnQmw2QyxRQUFuQixDQUE0QixDQUMxQms2QyxJQUFJLENBQUdsNkMsT0FBTyxDQUFDdXZDLFVBQWYsQ0FDRCxDQUZELElBRU8sSUFBRzBLLEtBQUssR0FBSyxJQUFiLENBQW1CLENBQ3hCQyxJQUFJLENBQUdELEtBQUssQ0FBQ3I1QyxNQUFOLEVBQVAsQ0FDRCxDQUZNLElBRUEsQ0FDTCxLQUFNLElBQUlGLE1BQUosQ0FBVSx1REFBVixDQUFOLENBQ0QsQ0FFRCxHQUFHdTVDLEtBQUssR0FBSyxJQUFWLEVBQWtCQSxLQUFLLENBQUNyNUMsTUFBTixLQUFtQnM1QyxJQUF4QyxDQUE4QyxDQUM1QyxLQUFNLElBQUl4NUMsTUFBSixDQUFVLHdEQUFWLENBQU4sQ0FDRCxDQUVELEdBQUl5bEIsS0FBSSxDQUFHbm1CLE9BQU8sQ0FBQ21tQixJQUFSLEVBQWdCamUsS0FBSyxDQUFDL0IsTUFBakMsQ0FFQSxHQUFJZzBDLE9BQU0sQ0FBRyxFQUFiLENBRUE7Ozs7Ozs7Ozs7S0FXQUEsTUFBTSxDQUFDam5DLE1BQVAsQ0FBZ0IsU0FBU2lTLEVBQVQsQ0FBYWkxQixPQUFiLENBQXNCLENBQ3BDLEdBQUlqd0MsRUFBSixDQUNBLEdBQUlrd0MsT0FBTSxDQUFHRCxPQUFPLENBQUcsQ0FBdkIsQ0FDQSxHQUFJRSxNQUFLLENBQUdwMEMsSUFBSSxDQUFDeU0sSUFBTCxDQUFVMG5DLE1BQU0sQ0FBRyxDQUFuQixDQUFaLENBRUEsNkRBQ0EsR0FBSUUsTUFBSyxDQUFHcDFCLEVBQUUsQ0FBQzRDLE1BQUgsR0FBWTVYLFFBQVosRUFBWixDQUVBLHNFQUNBLEdBQUdtcUMsS0FBSyxDQUFHbGIsSUFBSSxDQUFHOGEsSUFBUCxDQUFjLENBQXpCLENBQTRCLENBQzFCLEtBQU0sSUFBSXg1QyxNQUFKLENBQVUsaUNBQVYsQ0FBTixDQUNELENBRUQ7MkNBRUEsR0FBSTYwQixLQUFKLENBQ0EsR0FBRzBrQixLQUFLLEdBQUssSUFBYixDQUFtQixDQUNqQjFrQixJQUFJLENBQUdwUCxJQUFJLENBQUNDLFlBQUwsQ0FBa0I4ekIsSUFBbEIsQ0FBUCxDQUNELENBRkQsSUFFTyxDQUNMM2tCLElBQUksQ0FBRzBrQixLQUFLLENBQUMzcUMsS0FBTixFQUFQLENBQ0QsQ0FFRCwrREFDQSxHQUFJa3JDLEdBQUUsQ0FBRyxHQUFJdHlDLE1BQUssQ0FBQ3dELElBQU4sQ0FBVzJDLFVBQWYsRUFBVCxDQUNBbXNDLEVBQUUsQ0FBQ25yQyxZQUFILENBQWdCLENBQWhCLENBQW1CLENBQW5CLEVBQ0FtckMsRUFBRSxDQUFDcHJDLFFBQUgsQ0FBWW1yQyxLQUFaLEVBQ0FDLEVBQUUsQ0FBQ3ByQyxRQUFILENBQVltbUIsSUFBWixFQUVBLDBEQUNBL3VCLElBQUksQ0FBQ3NQLEtBQUwsR0FDQXRQLElBQUksQ0FBQ3NWLE1BQUwsQ0FBWTArQixFQUFFLENBQUNycUMsUUFBSCxFQUFaLEVBQ0EsR0FBSW9zQixFQUFDLENBQUcvMUIsSUFBSSxDQUFDdWhCLE1BQUwsR0FBYzVYLFFBQWQsRUFBUixDQUVBO3FEQUVBLEdBQUlzcUMsR0FBRSxDQUFHLEdBQUl2eUMsTUFBSyxDQUFDd0QsSUFBTixDQUFXMkMsVUFBZixFQUFULENBQ0Fvc0MsRUFBRSxDQUFDcHJDLFlBQUgsQ0FBZ0IsQ0FBaEIsQ0FBbUJpckMsS0FBSyxDQUFHSixJQUFSLENBQWU5YSxJQUFmLENBQXNCLENBQXpDLEVBRUE7OEJBRUFxYixFQUFFLENBQUMxckMsT0FBSCxDQUFXLElBQVgsRUFDQTByQyxFQUFFLENBQUNyckMsUUFBSCxDQUFZbW1CLElBQVosRUFDQSxHQUFJbWxCLEdBQUUsQ0FBR0QsRUFBRSxDQUFDdHFDLFFBQUgsRUFBVCxDQUVBLCtDQUNBLEdBQUl3cUMsUUFBTyxDQUFHTCxLQUFLLENBQUdsYixJQUFSLENBQWUsQ0FBN0IsQ0FDQSxHQUFJd2IsT0FBTSxDQUFHdEwsR0FBRyxDQUFDbG5DLFFBQUosQ0FBYW0wQixDQUFiLENBQWdCb2UsT0FBaEIsQ0FBYixDQUVBLHdDQUNBLEdBQUlFLFNBQVEsQ0FBRyxFQUFmLENBQ0EsSUFBSTF3QyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUd3d0MsT0FBZixDQUF3Qnh3QyxDQUFDLEVBQXpCLENBQTZCLENBQzNCMHdDLFFBQVEsRUFBSWpzQyxNQUFNLENBQUNDLFlBQVAsQ0FBb0I2ckMsRUFBRSxDQUFDcnFDLFVBQUgsQ0FBY2xHLENBQWQsRUFBbUJ5d0MsTUFBTSxDQUFDdnFDLFVBQVAsQ0FBa0JsRyxDQUFsQixDQUF2QyxDQUFaLENBQ0QsQ0FFRDsrQkFFQSxHQUFJMndDLEtBQUksQ0FBSSxRQUFXLEVBQUlSLEtBQUosQ0FBWUQsTUFBeEIsQ0FBbUMsSUFBOUMsQ0FDQVEsUUFBUSxDQUFHanNDLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQmdzQyxRQUFRLENBQUN4cUMsVUFBVCxDQUFvQixDQUFwQixFQUF5QixDQUFDeXFDLElBQTlDLEVBQ1RELFFBQVEsQ0FBQ3owQyxNQUFULENBQWdCLENBQWhCLENBREYsQ0FHQTt3QkFFQSxNQUFPeTBDLFNBQVEsQ0FBR3RlLENBQVgsQ0FBZTN0QixNQUFNLENBQUNDLFlBQVAsQ0FBb0IsSUFBcEIsQ0FBdEIsQ0FDRCxDQS9ERCxDQWlFQTs7Ozs7Ozs7Ozs7O0tBYUFzckMsTUFBTSxDQUFDbnRCLE1BQVAsQ0FBZ0IsU0FBU3V0QixLQUFULENBQWdCeHJCLEVBQWhCLENBQW9CcXJCLE9BQXBCLENBQTZCLENBQzNDLEdBQUlqd0MsRUFBSixDQUNBLEdBQUlrd0MsT0FBTSxDQUFHRCxPQUFPLENBQUcsQ0FBdkIsQ0FDQSxHQUFJRSxNQUFLLENBQUdwMEMsSUFBSSxDQUFDeU0sSUFBTCxDQUFVMG5DLE1BQU0sQ0FBRyxDQUFuQixDQUFaLENBRUE7O3VEQUdBdHJCLEVBQUUsQ0FBR0EsRUFBRSxDQUFDM29CLE1BQUgsQ0FBVSxDQUFDazBDLEtBQVgsQ0FBTCxDQUVBLG9FQUNBLEdBQUdBLEtBQUssQ0FBR2xiLElBQUksQ0FBRzhhLElBQVAsQ0FBYyxDQUF6QixDQUE0QixDQUMxQixLQUFNLElBQUl4NUMsTUFBSixDQUFVLHdEQUFWLENBQU4sQ0FDRCxDQUVEO2tEQUVBLEdBQUdxdUIsRUFBRSxDQUFDMWUsVUFBSCxDQUFjaXFDLEtBQUssQ0FBRyxDQUF0QixJQUE2QixJQUFoQyxDQUFzQyxDQUNwQyxLQUFNLElBQUk1NUMsTUFBSixDQUFVLHVDQUFWLENBQU4sQ0FDRCxDQUVEOzJDQUVBLEdBQUlpNkMsUUFBTyxDQUFHTCxLQUFLLENBQUdsYixJQUFSLENBQWUsQ0FBN0IsQ0FDQSxHQUFJeWIsU0FBUSxDQUFHOXJCLEVBQUUsQ0FBQzNvQixNQUFILENBQVUsQ0FBVixDQUFhdTBDLE9BQWIsQ0FBZixDQUNBLEdBQUlwZSxFQUFDLENBQUd4TixFQUFFLENBQUMzb0IsTUFBSCxDQUFVdTBDLE9BQVYsQ0FBbUJ2YixJQUFuQixDQUFSLENBRUE7Z0ZBRUEsR0FBSTBiLEtBQUksQ0FBSSxRQUFXLEVBQUlSLEtBQUosQ0FBWUQsTUFBeEIsQ0FBbUMsSUFBOUMsQ0FDQSxHQUFHLENBQUNRLFFBQVEsQ0FBQ3hxQyxVQUFULENBQW9CLENBQXBCLEVBQXlCeXFDLElBQTFCLElBQW9DLENBQXZDLENBQTBDLENBQ3hDLEtBQU0sSUFBSXA2QyxNQUFKLENBQVUsMkNBQVYsQ0FBTixDQUNELENBRUQsK0NBQ0EsR0FBSWs2QyxPQUFNLENBQUd0TCxHQUFHLENBQUNsbkMsUUFBSixDQUFhbTBCLENBQWIsQ0FBZ0JvZSxPQUFoQixDQUFiLENBRUEsdUNBQ0EsR0FBSUQsR0FBRSxDQUFHLEVBQVQsQ0FDQSxJQUFJdndDLENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsQ0FBR3d3QyxPQUFmLENBQXdCeHdDLENBQUMsRUFBekIsQ0FBNkIsQ0FDM0J1d0MsRUFBRSxFQUFJOXJDLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQmdzQyxRQUFRLENBQUN4cUMsVUFBVCxDQUFvQmxHLENBQXBCLEVBQXlCeXdDLE1BQU0sQ0FBQ3ZxQyxVQUFQLENBQWtCbEcsQ0FBbEIsQ0FBN0MsQ0FBTixDQUNELENBRUQ7d0JBRUF1d0MsRUFBRSxDQUFHOXJDLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjZyQyxFQUFFLENBQUNycUMsVUFBSCxDQUFjLENBQWQsRUFBbUIsQ0FBQ3lxQyxJQUF4QyxFQUFnREosRUFBRSxDQUFDdDBDLE1BQUgsQ0FBVSxDQUFWLENBQXJELENBRUE7Ozt5Q0FJQSxHQUFJMjBDLFNBQVEsQ0FBR1QsS0FBSyxDQUFHbGIsSUFBUixDQUFlOGEsSUFBZixDQUFzQixDQUFyQyxDQUNBLElBQUkvdkMsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHNHdDLFFBQWYsQ0FBeUI1d0MsQ0FBQyxFQUExQixDQUE4QixDQUM1QixHQUFHdXdDLEVBQUUsQ0FBQ3JxQyxVQUFILENBQWNsRyxDQUFkLElBQXFCLElBQXhCLENBQThCLENBQzVCLEtBQU0sSUFBSXpKLE1BQUosQ0FBVSxzQ0FBVixDQUFOLENBQ0QsQ0FDRixDQUVELEdBQUdnNkMsRUFBRSxDQUFDcnFDLFVBQUgsQ0FBYzBxQyxRQUFkLElBQTRCLElBQS9CLENBQXFDLENBQ25DLEtBQU0sSUFBSXI2QyxNQUFKLENBQVUsbURBQVYsQ0FBTixDQUNELENBRUQsaURBQ0EsR0FBSTYwQixLQUFJLENBQUdtbEIsRUFBRSxDQUFDdDBDLE1BQUgsQ0FBVSxDQUFDOHpDLElBQVgsQ0FBWCxDQUVBLGdFQUNBLEdBQUlNLEdBQUUsQ0FBRyxHQUFJdHlDLE1BQUssQ0FBQ3dELElBQU4sQ0FBVzJDLFVBQWYsRUFBVCxDQUNBbXNDLEVBQUUsQ0FBQ25yQyxZQUFILENBQWdCLENBQWhCLENBQW1CLENBQW5CLEVBQ0FtckMsRUFBRSxDQUFDcHJDLFFBQUgsQ0FBWW1yQyxLQUFaLEVBQ0FDLEVBQUUsQ0FBQ3ByQyxRQUFILENBQVltbUIsSUFBWixFQUVBLDREQUNBL3VCLElBQUksQ0FBQ3NQLEtBQUwsR0FDQXRQLElBQUksQ0FBQ3NWLE1BQUwsQ0FBWTArQixFQUFFLENBQUNycUMsUUFBSCxFQUFaLEVBQ0EsR0FBSTZxQyxHQUFFLENBQUd4MEMsSUFBSSxDQUFDdWhCLE1BQUwsR0FBYzVYLFFBQWQsRUFBVCxDQUVBLDJFQUNBLE1BQU9vc0IsRUFBQyxHQUFLeWUsRUFBYixDQUNELENBOUVELENBZ0ZBLE1BQU9iLE9BQVAsQ0FDRCxDQS9NRCxDQWtOQSxLQUFPLENBbDFmRyxDQW0xZlYsUUFuMWZVLENBbzFmVixLQUFPLFNBQVN2d0MsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0REEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBTCxNQUFNLENBQUNELE9BQVAsQ0FBaUJNLG1CQUFtQixDQUFDLENBQUQsQ0FBcEMsQ0FHQSxLQUFPLENBMTFmRyxDQTIxZlYsUUEzMWZVLENBNDFmVixLQUFPLFNBQVNMLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7Ozs7R0FRQSxHQUFJL0IsTUFBSyxDQUFHK0IsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBRUE7QUFDQSxHQUFJdVQsS0FBSSxDQUFHdFYsS0FBSyxDQUFDc1YsSUFBakIsQ0FFQSxxREFDQSxHQUFJN1UsSUFBRyxDQUFHaUIsTUFBTSxDQUFDRCxPQUFQLENBQWlCekIsS0FBSyxDQUFDUyxHQUFOLENBQVlULEtBQUssQ0FBQ1MsR0FBTixFQUFhLEVBQXBELENBRUE7Ozs7Ozs7O0dBU0FBLEdBQUcsQ0FBQ3N5QyxRQUFKLENBQWUsU0FBU3ZuQixHQUFULENBQWMsQ0FDM0IsR0FBSW5uQixJQUFHLENBQUdyRSxLQUFLLENBQUN3ckIsR0FBTixDQUFVNWdCLE1BQVYsQ0FBaUI0Z0IsR0FBakIsRUFBc0IsQ0FBdEIsQ0FBVixDQUNBLEdBQUdubkIsR0FBRyxDQUFDcW5CLFFBQUosRUFBZ0JybkIsR0FBRyxDQUFDcW5CLFFBQUosQ0FBYS9jLElBQWIsR0FBc0IsV0FBekMsQ0FBc0QsQ0FDcEQsS0FBTSxJQUFJblcsTUFBSixDQUFVLGlEQUFWLENBQU4sQ0FDRCxDQUNELE1BQU93SCxNQUFLLENBQUN3RCxJQUFOLENBQVc0RixZQUFYLENBQXdCL0UsR0FBRyxDQUFDMm5CLElBQTVCLENBQVAsQ0FDRCxDQU5ELENBUUE7Ozs7OztHQU9BdnJCLEdBQUcsQ0FBQ3V5QyxpQkFBSixDQUF3QixTQUFTeG5CLEdBQVQsQ0FBYyxDQUNwQyxHQUFJbm5CLElBQUcsQ0FBR3JFLEtBQUssQ0FBQ3dyQixHQUFOLENBQVU1Z0IsTUFBVixDQUFpQjRnQixHQUFqQixFQUFzQixDQUF0QixDQUFWLENBRUEsR0FBR25uQixHQUFHLENBQUNzSyxJQUFKLEdBQWEsYUFBYixFQUE4QnRLLEdBQUcsQ0FBQ3NLLElBQUosR0FBYSxpQkFBOUMsQ0FBaUUsQ0FDL0QsR0FBSXhVLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLCtDQUNwQix3REFEVSxDQUFaLENBRUEyQixLQUFLLENBQUMwMEIsVUFBTixDQUFtQnhxQixHQUFHLENBQUNzSyxJQUF2QixDQUNBLEtBQU14VSxNQUFOLENBQ0QsQ0FDRCxHQUFHa0ssR0FBRyxDQUFDcW5CLFFBQUosRUFBZ0JybkIsR0FBRyxDQUFDcW5CLFFBQUosQ0FBYS9jLElBQWIsR0FBc0IsV0FBekMsQ0FBc0QsQ0FDcEQsS0FBTSxJQUFJblcsTUFBSixDQUFVLDJEQUFWLENBQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSXlWLElBQUcsQ0FBR3FILElBQUksQ0FBQ2lELE9BQUwsQ0FBYWxVLEdBQUcsQ0FBQzJuQixJQUFqQixDQUFWLENBRUEsTUFBT3ZyQixJQUFHLENBQUN3akIsa0JBQUosQ0FBdUJoVyxHQUF2QixDQUFQLENBQ0QsQ0FqQkQsQ0FtQkE7Ozs7Ozs7R0FRQXhOLEdBQUcsQ0FBQ0csZUFBSixDQUFzQixTQUFTM0csR0FBVCxDQUFjcVMsT0FBZCxDQUF1QixDQUMzQztBQUNBLEdBQUlqSSxJQUFHLENBQUcsQ0FDUnNLLElBQUksQ0FBRSxpQkFERSxDQUVScWQsSUFBSSxDQUFFMVcsSUFBSSxDQUFDK0QsS0FBTCxDQUFXNVksR0FBRyxDQUFDcWxCLGdCQUFKLENBQXFCN3JCLEdBQXJCLENBQVgsRUFBc0NnTyxRQUF0QyxFQUZFLENBQVYsQ0FJQSxNQUFPakksTUFBSyxDQUFDd3JCLEdBQU4sQ0FBVXhnQixNQUFWLENBQWlCM0csR0FBakIsQ0FBc0IsQ0FBQ2lJLE9BQU8sQ0FBRUEsT0FBVixDQUF0QixDQUFQLENBQ0QsQ0FQRCxDQVNBOzs7Ozs7O0dBUUE3TCxHQUFHLENBQUN3eUMsbUJBQUosQ0FBMEIsU0FBU3h5QyxHQUFULENBQWM2TCxPQUFkLENBQXVCLENBQy9DO0FBQ0EsR0FBSWpJLElBQUcsQ0FBRyxDQUNSc0ssSUFBSSxDQUFFLGFBREUsQ0FFUnFkLElBQUksQ0FBRTFXLElBQUksQ0FBQytELEtBQUwsQ0FBVzVZLEdBQVgsRUFBZ0J3SCxRQUFoQixFQUZFLENBQVYsQ0FJQSxNQUFPakksTUFBSyxDQUFDd3JCLEdBQU4sQ0FBVXhnQixNQUFWLENBQWlCM0csR0FBakIsQ0FBc0IsQ0FBQ2lJLE9BQU8sQ0FBRUEsT0FBVixDQUF0QixDQUFQLENBQ0QsQ0FQRCxDQVVBLEtBQU8sQ0F0OGZHLENBdThmVixRQXY4ZlUsQ0F3OGZWLEtBQU8sU0FBUzVLLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCLENBRWpDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQThCQSxHQUFJNUMsSUFBRyxDQUFHLEVBQVYsQ0FDQTZDLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVDLEdBQWpCLENBRUE7QUFDQSxHQUFJcTBDLGtCQUFpQixDQUFHLEVBQXhCLENBRUE7Ozs7Ozs7O0dBU0FyMEMsR0FBRyxDQUFDbU0sTUFBSixDQUFhLFNBQVNPLEtBQVQsQ0FBZ0I0bkMsUUFBaEIsQ0FBMEI3bUMsT0FBMUIsQ0FBbUMsQ0FDOUMsR0FBRyxNQUFPNm1DLFNBQVAsR0FBb0IsUUFBdkIsQ0FBaUMsQ0FDL0IsS0FBTSxJQUFJQyxVQUFKLENBQWMsOEJBQWQsQ0FBTixDQUNELENBQ0QsR0FBRzltQyxPQUFPLEdBQUt4SSxTQUFaLEVBQXlCLE1BQU93SSxRQUFQLEdBQW1CLFFBQS9DLENBQXlELENBQ3ZELEtBQU0sSUFBSThtQyxVQUFKLENBQWMsNkJBQWQsQ0FBTixDQUNELENBRUQsR0FBSTVtQyxPQUFNLENBQUcsRUFBYixDQUVBLEdBQUcsRUFBRWpCLEtBQUssV0FBWTlFLFdBQW5CLENBQUgsQ0FBbUMsQ0FDakM7QUFDQStGLE1BQU0sQ0FBRzZtQyxxQkFBcUIsQ0FBQzluQyxLQUFELENBQVE0bkMsUUFBUixDQUE5QixDQUNELENBSEQsSUFHTyxDQUNMLEdBQUlseEMsRUFBQyxDQUFHLENBQVIsQ0FDQSxHQUFJcXhDLEtBQUksQ0FBR0gsUUFBUSxDQUFDejZDLE1BQXBCLENBQ0EsR0FBSW91QixNQUFLLENBQUdxc0IsUUFBUSxDQUFDdm1DLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBWixDQUNBLEdBQUkybUMsT0FBTSxDQUFHLENBQUMsQ0FBRCxDQUFiLENBQ0EsSUFBSXR4QyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUdzSixLQUFLLENBQUM3UyxNQUFyQixDQUE2QixFQUFFdUosQ0FBL0IsQ0FBa0MsQ0FDaEMsSUFBSSxHQUFJd0wsRUFBQyxDQUFHLENBQVIsQ0FBV3U0QixLQUFLLENBQUd6NkIsS0FBSyxDQUFDdEosQ0FBRCxDQUE1QixDQUFpQ3dMLENBQUMsQ0FBRzhsQyxNQUFNLENBQUM3NkMsTUFBNUMsQ0FBb0QsRUFBRStVLENBQXRELENBQXlELENBQ3ZEdTRCLEtBQUssRUFBSXVOLE1BQU0sQ0FBQzlsQyxDQUFELENBQU4sRUFBYSxDQUF0QixDQUNBOGxDLE1BQU0sQ0FBQzlsQyxDQUFELENBQU4sQ0FBWXU0QixLQUFLLENBQUdzTixJQUFwQixDQUNBdE4sS0FBSyxDQUFJQSxLQUFLLENBQUdzTixJQUFULENBQWlCLENBQXpCLENBQ0QsQ0FFRCxNQUFNdE4sS0FBSyxDQUFHLENBQWQsQ0FBaUIsQ0FDZnVOLE1BQU0sQ0FBQzV1QyxJQUFQLENBQVlxaEMsS0FBSyxDQUFHc04sSUFBcEIsRUFDQXROLEtBQUssQ0FBSUEsS0FBSyxDQUFHc04sSUFBVCxDQUFpQixDQUF6QixDQUNELENBQ0YsQ0FFRDtBQUNBLElBQUlyeEMsQ0FBQyxDQUFHLENBQVIsQ0FBV3NKLEtBQUssQ0FBQ3RKLENBQUQsQ0FBTCxHQUFhLENBQWIsRUFBa0JBLENBQUMsQ0FBR3NKLEtBQUssQ0FBQzdTLE1BQU4sQ0FBZSxDQUFoRCxDQUFtRCxFQUFFdUosQ0FBckQsQ0FBd0QsQ0FDdER1SyxNQUFNLEVBQUlzYSxLQUFWLENBQ0QsQ0FDRDtBQUNBLElBQUk3a0IsQ0FBQyxDQUFHc3hDLE1BQU0sQ0FBQzc2QyxNQUFQLENBQWdCLENBQXhCLENBQTJCdUosQ0FBQyxFQUFJLENBQWhDLENBQW1DLEVBQUVBLENBQXJDLENBQXdDLENBQ3RDdUssTUFBTSxFQUFJMm1DLFFBQVEsQ0FBQ0ksTUFBTSxDQUFDdHhDLENBQUQsQ0FBUCxDQUFsQixDQUNELENBQ0YsQ0FFRCxHQUFHcUssT0FBSCxDQUFZLENBQ1YsR0FBSTRDLE1BQUssQ0FBRyxHQUFJdlYsT0FBSixDQUFXLE9BQVMyUyxPQUFULENBQW1CLEdBQTlCLENBQW1DLEdBQW5DLENBQVosQ0FDQUUsTUFBTSxDQUFHQSxNQUFNLENBQUNzRixLQUFQLENBQWE1QyxLQUFiLEVBQW9CalcsSUFBcEIsQ0FBeUIsTUFBekIsQ0FBVCxDQUNELENBRUQsTUFBT3VULE9BQVAsQ0FDRCxDQS9DRCxDQWlEQTs7Ozs7OztHQVFBM04sR0FBRyxDQUFDK0wsTUFBSixDQUFhLFNBQVNXLEtBQVQsQ0FBZ0I0bkMsUUFBaEIsQ0FBMEIsQ0FDckMsR0FBRyxNQUFPNW5DLE1BQVAsR0FBaUIsUUFBcEIsQ0FBOEIsQ0FDNUIsS0FBTSxJQUFJNm5DLFVBQUosQ0FBYywyQkFBZCxDQUFOLENBQ0QsQ0FDRCxHQUFHLE1BQU9ELFNBQVAsR0FBb0IsUUFBdkIsQ0FBaUMsQ0FDL0IsS0FBTSxJQUFJQyxVQUFKLENBQWMsOEJBQWQsQ0FBTixDQUNELENBRUQsR0FBSUksTUFBSyxDQUFHTixpQkFBaUIsQ0FBQ0MsUUFBRCxDQUE3QixDQUNBLEdBQUcsQ0FBQ0ssS0FBSixDQUFXLENBQ1Q7QUFDQUEsS0FBSyxDQUFHTixpQkFBaUIsQ0FBQ0MsUUFBRCxDQUFqQixDQUE4QixFQUF0QyxDQUNBLElBQUksR0FBSWx4QyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdreEMsUUFBUSxDQUFDejZDLE1BQTVCLENBQW9DLEVBQUV1SixDQUF0QyxDQUF5QyxDQUN2Q3V4QyxLQUFLLENBQUNMLFFBQVEsQ0FBQ2hyQyxVQUFULENBQW9CbEcsQ0FBcEIsQ0FBRCxDQUFMLENBQWdDQSxDQUFoQyxDQUNELENBQ0YsQ0FFRDtBQUNBc0osS0FBSyxDQUFHQSxLQUFLLENBQUN2UyxPQUFOLENBQWMsS0FBZCxDQUFxQixFQUFyQixDQUFSLENBRUEsR0FBSXM2QyxLQUFJLENBQUdILFFBQVEsQ0FBQ3o2QyxNQUFwQixDQUNBLEdBQUlvdUIsTUFBSyxDQUFHcXNCLFFBQVEsQ0FBQ3ZtQyxNQUFULENBQWdCLENBQWhCLENBQVosQ0FDQSxHQUFJeEYsTUFBSyxDQUFHLENBQUMsQ0FBRCxDQUFaLENBQ0EsSUFBSSxHQUFJbkYsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHc0osS0FBSyxDQUFDN1MsTUFBekIsQ0FBaUN1SixDQUFDLEVBQWxDLENBQXNDLENBQ3BDLEdBQUl1UCxNQUFLLENBQUdnaUMsS0FBSyxDQUFDam9DLEtBQUssQ0FBQ3BELFVBQU4sQ0FBaUJsRyxDQUFqQixDQUFELENBQWpCLENBQ0EsR0FBR3VQLEtBQUssR0FBSzFOLFNBQWIsQ0FBd0IsQ0FDdEIsT0FDRCxDQUVELElBQUksR0FBSTJKLEVBQUMsQ0FBRyxDQUFSLENBQVd1NEIsS0FBSyxDQUFHeDBCLEtBQXZCLENBQThCL0QsQ0FBQyxDQUFHckcsS0FBSyxDQUFDMU8sTUFBeEMsQ0FBZ0QsRUFBRStVLENBQWxELENBQXFELENBQ25EdTRCLEtBQUssRUFBSTUrQixLQUFLLENBQUNxRyxDQUFELENBQUwsQ0FBVzZsQyxJQUFwQixDQUNBbHNDLEtBQUssQ0FBQ3FHLENBQUQsQ0FBTCxDQUFXdTRCLEtBQUssQ0FBRyxJQUFuQixDQUNBQSxLQUFLLEdBQUssQ0FBVixDQUNELENBRUQsTUFBTUEsS0FBSyxDQUFHLENBQWQsQ0FBaUIsQ0FDZjUrQixLQUFLLENBQUN6QyxJQUFOLENBQVdxaEMsS0FBSyxDQUFHLElBQW5CLEVBQ0FBLEtBQUssR0FBSyxDQUFWLENBQ0QsQ0FDRixDQUVEO0FBQ0EsSUFBSSxHQUFJbm9DLEVBQUMsQ0FBRyxDQUFaLENBQWUwTixLQUFLLENBQUMxTixDQUFELENBQUwsR0FBYWlwQixLQUFiLEVBQXNCanBCLENBQUMsQ0FBRzBOLEtBQUssQ0FBQzdTLE1BQU4sQ0FBZSxDQUF4RCxDQUEyRCxFQUFFbUYsQ0FBN0QsQ0FBZ0UsQ0FDOUR1SixLQUFLLENBQUN6QyxJQUFOLENBQVcsQ0FBWCxFQUNELENBRUQsR0FBRyxNQUFPNEIsT0FBUCxHQUFrQixXQUFyQixDQUFrQyxDQUNoQyxNQUFPQSxPQUFNLENBQUNrdEMsSUFBUCxDQUFZcnNDLEtBQUssQ0FBQ25NLE9BQU4sRUFBWixDQUFQLENBQ0QsQ0FFRCxNQUFPLElBQUl3TCxXQUFKLENBQWVXLEtBQUssQ0FBQ25NLE9BQU4sRUFBZixDQUFQLENBQ0QsQ0FuREQsQ0FxREEsUUFBU280QyxzQkFBVCxDQUErQjluQyxLQUEvQixDQUFzQzRuQyxRQUF0QyxDQUFnRCxDQUM5QyxHQUFJbHhDLEVBQUMsQ0FBRyxDQUFSLENBQ0EsR0FBSXF4QyxLQUFJLENBQUdILFFBQVEsQ0FBQ3o2QyxNQUFwQixDQUNBLEdBQUlvdUIsTUFBSyxDQUFHcXNCLFFBQVEsQ0FBQ3ZtQyxNQUFULENBQWdCLENBQWhCLENBQVosQ0FDQSxHQUFJMm1DLE9BQU0sQ0FBRyxDQUFDLENBQUQsQ0FBYixDQUNBLElBQUl0eEMsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHc0osS0FBSyxDQUFDN1MsTUFBTixFQUFmLENBQStCLEVBQUV1SixDQUFqQyxDQUFvQyxDQUNsQyxJQUFJLEdBQUl3TCxFQUFDLENBQUcsQ0FBUixDQUFXdTRCLEtBQUssQ0FBR3o2QixLQUFLLENBQUN0QyxFQUFOLENBQVNoSCxDQUFULENBQXZCLENBQW9Dd0wsQ0FBQyxDQUFHOGxDLE1BQU0sQ0FBQzc2QyxNQUEvQyxDQUF1RCxFQUFFK1UsQ0FBekQsQ0FBNEQsQ0FDMUR1NEIsS0FBSyxFQUFJdU4sTUFBTSxDQUFDOWxDLENBQUQsQ0FBTixFQUFhLENBQXRCLENBQ0E4bEMsTUFBTSxDQUFDOWxDLENBQUQsQ0FBTixDQUFZdTRCLEtBQUssQ0FBR3NOLElBQXBCLENBQ0F0TixLQUFLLENBQUlBLEtBQUssQ0FBR3NOLElBQVQsQ0FBaUIsQ0FBekIsQ0FDRCxDQUVELE1BQU10TixLQUFLLENBQUcsQ0FBZCxDQUFpQixDQUNmdU4sTUFBTSxDQUFDNXVDLElBQVAsQ0FBWXFoQyxLQUFLLENBQUdzTixJQUFwQixFQUNBdE4sS0FBSyxDQUFJQSxLQUFLLENBQUdzTixJQUFULENBQWlCLENBQXpCLENBQ0QsQ0FDRixDQUVELEdBQUk5bUMsT0FBTSxDQUFHLEVBQWIsQ0FFQTtBQUNBLElBQUl2SyxDQUFDLENBQUcsQ0FBUixDQUFXc0osS0FBSyxDQUFDdEMsRUFBTixDQUFTaEgsQ0FBVCxJQUFnQixDQUFoQixFQUFxQkEsQ0FBQyxDQUFHc0osS0FBSyxDQUFDN1MsTUFBTixHQUFpQixDQUFyRCxDQUF3RCxFQUFFdUosQ0FBMUQsQ0FBNkQsQ0FDM0R1SyxNQUFNLEVBQUlzYSxLQUFWLENBQ0QsQ0FDRDtBQUNBLElBQUk3a0IsQ0FBQyxDQUFHc3hDLE1BQU0sQ0FBQzc2QyxNQUFQLENBQWdCLENBQXhCLENBQTJCdUosQ0FBQyxFQUFJLENBQWhDLENBQW1DLEVBQUVBLENBQXJDLENBQXdDLENBQ3RDdUssTUFBTSxFQUFJMm1DLFFBQVEsQ0FBQ0ksTUFBTSxDQUFDdHhDLENBQUQsQ0FBUCxDQUFsQixDQUNELENBRUQsTUFBT3VLLE9BQVAsQ0FDRCxDQUdELEtBQU8sQ0F0b2dCRyxDQXVvZ0JWLFFBdm9nQlUsQ0F3b2dCVixLQUFPLFNBQVM5SyxNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7OztHQVNBLEdBQUkvQixNQUFLLENBQUcrQixtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUVBLEdBQUkrYixPQUFNLENBQUdwYyxNQUFNLENBQUNELE9BQVAsQ0FBaUJ6QixLQUFLLENBQUM4ZCxNQUFOLENBQWU5ZCxLQUFLLENBQUM4ZCxNQUFOLEVBQWdCLEVBQTdELENBQ0E5ZCxLQUFLLENBQUNpZCxFQUFOLENBQVNhLE1BQVQsQ0FBa0I5ZCxLQUFLLENBQUNpZCxFQUFOLENBQVNDLFVBQVQsQ0FBb0JZLE1BQXBCLENBQTZCQSxNQUEvQyxDQUVBOzs7O0dBS0FBLE1BQU0sQ0FBQzllLE1BQVAsQ0FBZ0IsVUFBVyxDQUN6QjtBQUNBLEdBQUcsQ0FBQ2ltQyxZQUFKLENBQWtCLENBQ2hCcGMsS0FBSyxHQUNOLENBRUQ7QUFDQSxHQUFJcWMsT0FBTSxDQUFHLElBQWIsQ0FFQTtBQUNBLEdBQUk3VCxPQUFNLENBQUdyeEIsS0FBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBWCxFQUFiLENBRUE7QUFDQSxHQUFJd2YsR0FBRSxDQUFHLEdBQUkvdkIsTUFBSixDQUFVLEVBQVYsQ0FBVCxDQUVBO0FBQ0EsR0FBSW9rQixHQUFFLENBQUcsQ0FDUHdDLFNBQVMsQ0FBRSxRQURKLENBRVA4UCxXQUFXLENBQUUsRUFGTixDQUdQRCxZQUFZLENBQUUsRUFIUCxDQUlQO0FBQ0E2VixhQUFhLENBQUUsQ0FMUixDQU1QO0FBQ0FDLGlCQUFpQixDQUFFLElBUFosQ0FRUDtBQUNBQyxpQkFBaUIsQ0FBRSxDQVRaLENBQVQsQ0FZQTs7OztLQUtBcG9CLEVBQUUsQ0FBQ3JQLEtBQUgsQ0FBVyxVQUFXLENBQ3BCO0FBQ0FxUCxFQUFFLENBQUNrb0IsYUFBSCxDQUFtQixDQUFuQixDQUVBO0FBQ0Fsb0IsRUFBRSxDQUFDbW9CLGlCQUFILENBQXVCbm9CLEVBQUUsQ0FBQ3FvQixlQUFILENBQXFCLEVBQTVDLENBQ0EsR0FBSUMsT0FBTSxDQUFHdG9CLEVBQUUsQ0FBQ29vQixpQkFBSCxDQUF1QixDQUFwQyxDQUNBLElBQUksR0FBSXBqQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdzakMsTUFBbkIsQ0FBMkIsRUFBRXRqQyxDQUE3QixDQUFnQyxDQUM5QmdiLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQnpnQyxJQUFyQixDQUEwQixDQUExQixFQUNELENBQ0Qwc0IsTUFBTSxDQUFHcnhCLEtBQUssQ0FBQ3dELElBQU4sQ0FBVzRGLFlBQVgsRUFBVCxDQUNBODdCLE1BQU0sQ0FBRyxDQUNQTSxFQUFFLENBQUUsVUFERyxDQUVQQyxFQUFFLENBQUUsVUFGRyxDQUdQQyxFQUFFLENBQUUsVUFIRyxDQUlQQyxFQUFFLENBQUUsVUFKRyxDQUtQQyxFQUFFLENBQUUsVUFMRyxDQU1QOE4sRUFBRSxDQUFFLFVBTkcsQ0FPUEMsRUFBRSxDQUFFLFVBUEcsQ0FRUEMsRUFBRSxDQUFFLFVBUkcsQ0FBVCxDQVVBLE1BQU8zMkIsR0FBUCxDQUNELENBdEJELENBdUJBO0FBQ0FBLEVBQUUsQ0FBQ3JQLEtBQUgsR0FFQTs7Ozs7Ozs7O0tBVUFxUCxFQUFFLENBQUNySixNQUFILENBQVksU0FBU3ZQLEdBQVQsQ0FBY2tHLFFBQWQsQ0FBd0IsQ0FDbEMsR0FBR0EsUUFBUSxHQUFLLE1BQWhCLENBQXdCLENBQ3RCbEcsR0FBRyxDQUFHckUsS0FBSyxDQUFDd0QsSUFBTixDQUFXK0QsVUFBWCxDQUFzQmxELEdBQXRCLENBQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSWtGLElBQUcsQ0FBR2xGLEdBQUcsQ0FBQzNMLE1BQWQsQ0FDQXVrQixFQUFFLENBQUNrb0IsYUFBSCxFQUFvQjU3QixHQUFwQixDQUNBQSxHQUFHLENBQUcsQ0FBRUEsR0FBRyxDQUFHLFdBQVAsR0FBd0IsQ0FBekIsQ0FBNEJBLEdBQUcsR0FBSyxDQUFwQyxDQUFOLENBQ0EsSUFBSSxHQUFJdEgsRUFBQyxDQUFHZ2IsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCMXNDLE1BQXJCLENBQThCLENBQTFDLENBQTZDdUosQ0FBQyxFQUFJLENBQWxELENBQXFELEVBQUVBLENBQXZELENBQTBELENBQ3hEZ2IsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCbmpDLENBQXJCLEdBQTJCc0gsR0FBRyxDQUFDLENBQUQsQ0FBOUIsQ0FDQUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFTQSxHQUFHLENBQUMsQ0FBRCxDQUFILEVBQVcwVCxFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJuakMsQ0FBckIsRUFBMEIsV0FBM0IsR0FBNEMsQ0FBdEQsQ0FBVCxDQUNBZ2IsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCbmpDLENBQXJCLEVBQTBCZ2IsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCbmpDLENBQXJCLElBQTRCLENBQXRELENBQ0FzSCxHQUFHLENBQUMsQ0FBRCxDQUFILENBQVdBLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBUyxXQUFWLEdBQTJCLENBQXJDLENBQ0QsQ0FFRDtBQUNBOG5CLE1BQU0sQ0FBQ25xQixRQUFQLENBQWdCN0MsR0FBaEIsRUFFQTtBQUNBd2hDLE9BQU8sQ0FBQ1gsTUFBRCxDQUFTdGMsRUFBVCxDQUFheUksTUFBYixDQUFQLENBRUE7QUFDQSxHQUFHQSxNQUFNLENBQUMvcUIsSUFBUCxDQUFjLElBQWQsRUFBc0IrcUIsTUFBTSxDQUFDMzRCLE1BQVAsS0FBb0IsQ0FBN0MsQ0FBZ0QsQ0FDOUMyNEIsTUFBTSxDQUFDaG9CLE9BQVAsR0FDRCxDQUVELE1BQU80VCxHQUFQLENBQ0QsQ0E1QkQsQ0E4QkE7Ozs7S0FLQUEsRUFBRSxDQUFDNEMsTUFBSCxDQUFZLFVBQVcsQ0FDckI7OzsyQ0FEcUIsQ0FNckI7Ozs7Ozs7Ozs7Ozs7cUVBZUEsR0FBSWltQixXQUFVLENBQUc5bEMsS0FBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBWCxFQUFqQixDQUNBMDhCLFVBQVUsQ0FBQzUrQixRQUFYLENBQW9CbXFCLE1BQU0sQ0FBQ2pxQixLQUFQLEVBQXBCLEVBRUE7QUFDQSxHQUFJOFEsVUFBUyxDQUNYK0UsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCbm9CLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQjFzQyxNQUFyQixDQUE4QixDQUFuRCxFQUNBdWtCLEVBQUUsQ0FBQ29vQixpQkFGTCxDQUlBO0FBQ0E7QUFDQTtBQUNBLEdBQUkzVCxTQUFRLENBQUd4WixTQUFTLENBQUkrRSxFQUFFLENBQUNzUyxXQUFILENBQWlCLENBQTdDLENBQ0F1VyxVQUFVLENBQUM1K0IsUUFBWCxDQUFvQjYrQixRQUFRLENBQUM3bkMsTUFBVCxDQUFnQixDQUFoQixDQUFtQitlLEVBQUUsQ0FBQ3NTLFdBQUgsQ0FBaUJtQyxRQUFwQyxDQUFwQixFQUVBO0FBQ0E7QUFDQSxHQUFJamdCLEtBQUosQ0FBVXUwQixLQUFWLENBQ0EsR0FBSXBrQixLQUFJLENBQUczRSxFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUIsQ0FBckIsRUFBMEIsQ0FBckMsQ0FDQSxJQUFJLEdBQUluakMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHZ2IsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCMXNDLE1BQXJCLENBQThCLENBQWpELENBQW9ELEVBQUV1SixDQUF0RCxDQUF5RCxDQUN2RHdQLElBQUksQ0FBR3dMLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQm5qQyxDQUFDLENBQUcsQ0FBekIsRUFBOEIsQ0FBckMsQ0FDQStqQyxLQUFLLENBQUl2MEIsSUFBSSxDQUFHLFdBQVIsR0FBeUIsQ0FBakMsQ0FDQW1RLElBQUksRUFBSW9rQixLQUFSLENBQ0FGLFVBQVUsQ0FBQ3ArQixRQUFYLENBQW9Ca2EsSUFBSSxHQUFLLENBQTdCLEVBQ0FBLElBQUksQ0FBR25RLElBQUksR0FBSyxDQUFoQixDQUNELENBQ0RxMEIsVUFBVSxDQUFDcCtCLFFBQVgsQ0FBb0JrYSxJQUFwQixFQUVBLEdBQUlqVyxHQUFFLENBQUcsQ0FDUDY1QixFQUFFLENBQUVOLE1BQU0sQ0FBQ00sRUFESixDQUVQQyxFQUFFLENBQUVQLE1BQU0sQ0FBQ08sRUFGSixDQUdQQyxFQUFFLENBQUVSLE1BQU0sQ0FBQ1EsRUFISixDQUlQQyxFQUFFLENBQUVULE1BQU0sQ0FBQ1MsRUFKSixDQUtQQyxFQUFFLENBQUVWLE1BQU0sQ0FBQ1UsRUFMSixDQU1QOE4sRUFBRSxDQUFFeE8sTUFBTSxDQUFDd08sRUFOSixDQU9QQyxFQUFFLENBQUV6TyxNQUFNLENBQUN5TyxFQVBKLENBUVBDLEVBQUUsQ0FBRTFPLE1BQU0sQ0FBQzBPLEVBUkosQ0FBVCxDQVVBL04sT0FBTyxDQUFDbDZCLEVBQUQsQ0FBS2lkLEVBQUwsQ0FBU2tkLFVBQVQsQ0FBUCxDQUNBLEdBQUl6OUIsS0FBSSxDQUFHckksS0FBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBWCxFQUFYLENBQ0FmLElBQUksQ0FBQ1gsUUFBTCxDQUFjaUUsRUFBRSxDQUFDNjVCLEVBQWpCLEVBQ0FuOUIsSUFBSSxDQUFDWCxRQUFMLENBQWNpRSxFQUFFLENBQUM4NUIsRUFBakIsRUFDQXA5QixJQUFJLENBQUNYLFFBQUwsQ0FBY2lFLEVBQUUsQ0FBQys1QixFQUFqQixFQUNBcjlCLElBQUksQ0FBQ1gsUUFBTCxDQUFjaUUsRUFBRSxDQUFDZzZCLEVBQWpCLEVBQ0F0OUIsSUFBSSxDQUFDWCxRQUFMLENBQWNpRSxFQUFFLENBQUNpNkIsRUFBakIsRUFDQXY5QixJQUFJLENBQUNYLFFBQUwsQ0FBY2lFLEVBQUUsQ0FBQytuQyxFQUFqQixFQUNBcnJDLElBQUksQ0FBQ1gsUUFBTCxDQUFjaUUsRUFBRSxDQUFDZ29DLEVBQWpCLEVBQ0F0ckMsSUFBSSxDQUFDWCxRQUFMLENBQWNpRSxFQUFFLENBQUNpb0MsRUFBakIsRUFDQSxNQUFPdnJDLEtBQVAsQ0FDRCxDQXJFRCxDQXVFQSxNQUFPNFUsR0FBUCxDQUNELENBaExELENBa0xBO0FBQ0EsR0FBSThvQixTQUFRLENBQUcsSUFBZixDQUNBLEdBQUlkLGFBQVksQ0FBRyxLQUFuQixDQUVBO0FBQ0EsR0FBSTRPLEdBQUUsQ0FBRyxJQUFULENBRUE7O0dBR0EsUUFBU2hyQixNQUFULEVBQWlCLENBQ2Y7QUFDQWtkLFFBQVEsQ0FBR3IvQixNQUFNLENBQUNDLFlBQVAsQ0FBb0IsR0FBcEIsQ0FBWCxDQUNBby9CLFFBQVEsRUFBSS9sQyxLQUFLLENBQUN3RCxJQUFOLENBQVdnSSxVQUFYLENBQXNCOUUsTUFBTSxDQUFDQyxZQUFQLENBQW9CLElBQXBCLENBQXRCLENBQWlELEVBQWpELENBQVosQ0FFQTtBQUNBa3RDLEVBQUUsQ0FBRyxDQUNILFVBREcsQ0FDUyxVQURULENBQ3FCLFVBRHJCLENBQ2lDLFVBRGpDLENBRUgsVUFGRyxDQUVTLFVBRlQsQ0FFcUIsVUFGckIsQ0FFaUMsVUFGakMsQ0FHSCxVQUhHLENBR1MsVUFIVCxDQUdxQixVQUhyQixDQUdpQyxVQUhqQyxDQUlILFVBSkcsQ0FJUyxVQUpULENBSXFCLFVBSnJCLENBSWlDLFVBSmpDLENBS0gsVUFMRyxDQUtTLFVBTFQsQ0FLcUIsVUFMckIsQ0FLaUMsVUFMakMsQ0FNSCxVQU5HLENBTVMsVUFOVCxDQU1xQixVQU5yQixDQU1pQyxVQU5qQyxDQU9ILFVBUEcsQ0FPUyxVQVBULENBT3FCLFVBUHJCLENBT2lDLFVBUGpDLENBUUgsVUFSRyxDQVFTLFVBUlQsQ0FRcUIsVUFSckIsQ0FRaUMsVUFSakMsQ0FTSCxVQVRHLENBU1MsVUFUVCxDQVNxQixVQVRyQixDQVNpQyxVQVRqQyxDQVVILFVBVkcsQ0FVUyxVQVZULENBVXFCLFVBVnJCLENBVWlDLFVBVmpDLENBV0gsVUFYRyxDQVdTLFVBWFQsQ0FXcUIsVUFYckIsQ0FXaUMsVUFYakMsQ0FZSCxVQVpHLENBWVMsVUFaVCxDQVlxQixVQVpyQixDQVlpQyxVQVpqQyxDQWFILFVBYkcsQ0FhUyxVQWJULENBYXFCLFVBYnJCLENBYWlDLFVBYmpDLENBY0gsVUFkRyxDQWNTLFVBZFQsQ0FjcUIsVUFkckIsQ0FjaUMsVUFkakMsQ0FlSCxVQWZHLENBZVMsVUFmVCxDQWVxQixVQWZyQixDQWVpQyxVQWZqQyxDQWdCSCxVQWhCRyxDQWdCUyxVQWhCVCxDQWdCcUIsVUFoQnJCLENBZ0JpQyxVQWhCakMsQ0FBTCxDQWtCQTtBQUNBNU8sWUFBWSxDQUFHLElBQWYsQ0FDRCxDQUVEOzs7Ozs7R0FPQSxRQUFTWSxRQUFULENBQWlCeGlDLENBQWpCLENBQW9CaW5CLENBQXBCLENBQXVCbGpCLEtBQXZCLENBQThCLENBQzVCO0FBQ0EsR0FBSXFiLEdBQUosQ0FBUUMsRUFBUixDQUFZb3hCLEVBQVosQ0FBZ0Jwb0MsRUFBaEIsQ0FBb0Jxb0MsRUFBcEIsQ0FBd0JDLEdBQXhCLENBQTZCL3hDLENBQTdCLENBQWdDaXBCLENBQWhDLENBQW1DN2tCLENBQW5DLENBQXNDaEUsQ0FBdEMsQ0FBeUNDLENBQXpDLENBQTRDc0UsQ0FBNUMsQ0FBK0NxNUIsQ0FBL0MsQ0FBa0QzQixDQUFsRCxDQUFxRGpLLENBQXJELENBQ0EsR0FBSTlxQixJQUFHLENBQUduQyxLQUFLLENBQUMxTyxNQUFOLEVBQVYsQ0FDQSxNQUFNNlEsR0FBRyxFQUFJLEVBQWIsQ0FBaUIsQ0FDZjtBQUNBO0FBQ0EsSUFBSXRILENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsQ0FBRyxFQUFmLENBQW1CLEVBQUVBLENBQXJCLENBQXdCLENBQ3RCcW9CLENBQUMsQ0FBQ3JvQixDQUFELENBQUQsQ0FBT21GLEtBQUssQ0FBQ21CLFFBQU4sRUFBUCxDQUNELENBQ0QsS0FBTXRHLENBQUMsQ0FBRyxFQUFWLENBQWMsRUFBRUEsQ0FBaEIsQ0FBbUIsQ0FDakI7QUFDQXdnQixFQUFFLENBQUc2SCxDQUFDLENBQUNyb0IsQ0FBQyxDQUFHLENBQUwsQ0FBTixDQUNBd2dCLEVBQUUsQ0FDQSxDQUFFQSxFQUFFLEdBQUssRUFBUixDQUFlQSxFQUFFLEVBQUksRUFBdEIsR0FDRUEsRUFBRSxHQUFLLEVBQVIsQ0FBZUEsRUFBRSxFQUFJLEVBRHRCLEVBRUNBLEVBQUUsR0FBSyxFQUhWLENBSUE7QUFDQUMsRUFBRSxDQUFHNEgsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxFQUFMLENBQU4sQ0FDQXlnQixFQUFFLENBQ0EsQ0FBRUEsRUFBRSxHQUFLLENBQVIsQ0FBY0EsRUFBRSxFQUFJLEVBQXJCLEdBQ0VBLEVBQUUsR0FBSyxFQUFSLENBQWVBLEVBQUUsRUFBSSxFQUR0QixFQUVDQSxFQUFFLEdBQUssQ0FIVixDQUlBO0FBQ0E0SCxDQUFDLENBQUNyb0IsQ0FBRCxDQUFELENBQVF3Z0IsRUFBRSxDQUFHNkgsQ0FBQyxDQUFDcm9CLENBQUMsQ0FBRyxDQUFMLENBQU4sQ0FBZ0J5Z0IsRUFBaEIsQ0FBcUI0SCxDQUFDLENBQUNyb0IsQ0FBQyxDQUFHLEVBQUwsQ0FBdkIsQ0FBbUMsQ0FBMUMsQ0FDRCxDQUVEO0FBQ0FpcEIsQ0FBQyxDQUFHN25CLENBQUMsQ0FBQ21pQyxFQUFOLENBQ0FuL0IsQ0FBQyxDQUFHaEQsQ0FBQyxDQUFDb2lDLEVBQU4sQ0FDQXBqQyxDQUFDLENBQUdnQixDQUFDLENBQUNxaUMsRUFBTixDQUNBcGpDLENBQUMsQ0FBR2UsQ0FBQyxDQUFDc2lDLEVBQU4sQ0FDQS8rQixDQUFDLENBQUd2RCxDQUFDLENBQUN1aUMsRUFBTixDQUNBM0YsQ0FBQyxDQUFHNThCLENBQUMsQ0FBQ3F3QyxFQUFOLENBQ0FwVixDQUFDLENBQUdqN0IsQ0FBQyxDQUFDc3dDLEVBQU4sQ0FDQXRmLENBQUMsQ0FBR2h4QixDQUFDLENBQUN1d0MsRUFBTixDQUVBO0FBQ0EsSUFBSTN4QyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUcsRUFBZixDQUFtQixFQUFFQSxDQUFyQixDQUF3QixDQUN0QjtBQUNBeUosRUFBRSxDQUNBLENBQUU5RSxDQUFDLEdBQUssQ0FBUCxDQUFhQSxDQUFDLEVBQUksRUFBbkIsR0FDRUEsQ0FBQyxHQUFLLEVBQVAsQ0FBY0EsQ0FBQyxFQUFJLEVBRHBCLEdBRUVBLENBQUMsR0FBSyxFQUFQLENBQWNBLENBQUMsRUFBSSxDQUZwQixDQURGLENBSUE7QUFDQW10QyxFQUFFLENBQUd6VixDQUFDLENBQUkxM0IsQ0FBQyxFQUFJcTVCLENBQUMsQ0FBRzNCLENBQVIsQ0FBWCxDQUNBO0FBQ0F3VixFQUFFLENBQ0EsQ0FBRTVvQixDQUFDLEdBQUssQ0FBUCxDQUFhQSxDQUFDLEVBQUksRUFBbkIsR0FDRUEsQ0FBQyxHQUFLLEVBQVAsQ0FBY0EsQ0FBQyxFQUFJLEVBRHBCLEdBRUVBLENBQUMsR0FBSyxFQUFQLENBQWNBLENBQUMsRUFBSSxFQUZwQixDQURGLENBSUE7QUFDQThvQixHQUFHLENBQUk5b0IsQ0FBQyxDQUFHN2tCLENBQUwsQ0FBV2hFLENBQUMsRUFBSTZvQixDQUFDLENBQUc3a0IsQ0FBUixDQUFsQixDQUVBO0FBQ0FvYyxFQUFFLENBQUc0UixDQUFDLENBQUczb0IsRUFBSixDQUFTcW9DLEVBQVQsQ0FBY0YsRUFBRSxDQUFDNXhDLENBQUQsQ0FBaEIsQ0FBc0Jxb0IsQ0FBQyxDQUFDcm9CLENBQUQsQ0FBNUIsQ0FDQXlnQixFQUFFLENBQUdveEIsRUFBRSxDQUFHRSxHQUFWLENBQ0EzZixDQUFDLENBQUdpSyxDQUFKLENBQ0FBLENBQUMsQ0FBRzJCLENBQUosQ0FDQUEsQ0FBQyxDQUFHcjVCLENBQUosQ0FDQTtBQUNBO0FBQ0FBLENBQUMsQ0FBSXRFLENBQUMsQ0FBR21nQixFQUFMLEdBQWEsQ0FBakIsQ0FDQW5nQixDQUFDLENBQUdELENBQUosQ0FDQUEsQ0FBQyxDQUFHZ0UsQ0FBSixDQUNBQSxDQUFDLENBQUc2a0IsQ0FBSixDQUNBO0FBQ0E7QUFDQUEsQ0FBQyxDQUFJekksRUFBRSxDQUFHQyxFQUFOLEdBQWMsQ0FBbEIsQ0FDRCxDQUVEO0FBQ0FyZixDQUFDLENBQUNtaUMsRUFBRixDQUFRbmlDLENBQUMsQ0FBQ21pQyxFQUFGLENBQU90YSxDQUFSLENBQWEsQ0FBcEIsQ0FDQTduQixDQUFDLENBQUNvaUMsRUFBRixDQUFRcGlDLENBQUMsQ0FBQ29pQyxFQUFGLENBQU9wL0IsQ0FBUixDQUFhLENBQXBCLENBQ0FoRCxDQUFDLENBQUNxaUMsRUFBRixDQUFRcmlDLENBQUMsQ0FBQ3FpQyxFQUFGLENBQU9yakMsQ0FBUixDQUFhLENBQXBCLENBQ0FnQixDQUFDLENBQUNzaUMsRUFBRixDQUFRdGlDLENBQUMsQ0FBQ3NpQyxFQUFGLENBQU9yakMsQ0FBUixDQUFhLENBQXBCLENBQ0FlLENBQUMsQ0FBQ3VpQyxFQUFGLENBQVF2aUMsQ0FBQyxDQUFDdWlDLEVBQUYsQ0FBT2gvQixDQUFSLENBQWEsQ0FBcEIsQ0FDQXZELENBQUMsQ0FBQ3F3QyxFQUFGLENBQVFyd0MsQ0FBQyxDQUFDcXdDLEVBQUYsQ0FBT3pULENBQVIsQ0FBYSxDQUFwQixDQUNBNThCLENBQUMsQ0FBQ3N3QyxFQUFGLENBQVF0d0MsQ0FBQyxDQUFDc3dDLEVBQUYsQ0FBT3JWLENBQVIsQ0FBYSxDQUFwQixDQUNBajdCLENBQUMsQ0FBQ3V3QyxFQUFGLENBQVF2d0MsQ0FBQyxDQUFDdXdDLEVBQUYsQ0FBT3ZmLENBQVIsQ0FBYSxDQUFwQixDQUNBOXFCLEdBQUcsRUFBSSxFQUFQLENBQ0QsQ0FDRixDQUdELEtBQU8sQ0FuOWdCRyxDQW85Z0JWLFFBcDlnQlUsQ0FxOWdCVixLQUFPLFNBQVM3SCxNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7Ozs7O0dBV0EsR0FBSS9CLE1BQUssQ0FBRytCLG1CQUFtQixDQUFDLENBQUQsQ0FBL0IsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUVBLEdBQUlzYyxRQUFPLENBQUcsSUFBZCxDQUNBLEdBQUdyZSxLQUFLLENBQUN3RCxJQUFOLENBQVdnQyxRQUFYLEVBQXVCLENBQUN4RixLQUFLLENBQUNsSSxPQUFOLENBQWN3TCxpQkFBdEMsRUFDRCxDQUFDRyxPQUFPLENBQUNnQyxRQUFSLENBQWlCLGFBQWpCLENBREgsQ0FDb0MsQ0FDbEM0WSxPQUFPLENBQUd0YyxtQkFBbUIsQ0FBQyxFQUFELENBQTdCLENBQ0QsQ0FFRCxjQUNBLEdBQUlrYyxLQUFJLENBQUd2YyxNQUFNLENBQUNELE9BQVAsQ0FBaUJ6QixLQUFLLENBQUNpZSxJQUFOLENBQWFqZSxLQUFLLENBQUNpZSxJQUFOLEVBQWMsRUFBdkQsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkFBLElBQUksQ0FBQ2pmLE1BQUwsQ0FBYyxTQUFTaTFDLE1BQVQsQ0FBaUIsQ0FDN0IsR0FBSWoyQixJQUFHLENBQUcsQ0FDUmkyQixNQUFNLENBQUVBLE1BREEsQ0FFUmg2QyxHQUFHLENBQUUsSUFGRyxDQUdSeWpCLElBQUksQ0FBRSxJQUhFLENBSVJ3MkIsSUFBSSxDQUFFLElBSkUsQ0FLUjtBQUNBQyxPQUFPLENBQUUsQ0FORCxDQU9SO0FBQ0FDLFNBQVMsQ0FBRSxDQVJILENBU1I7QUFDQUMsUUFBUSxDQUFFLEVBVkYsQ0FBVixDQWFBO0FBQ0EsR0FBSXAzQixHQUFFLENBQUdnM0IsTUFBTSxDQUFDaDNCLEVBQWhCLENBQ0EsR0FBSXEzQixNQUFLLENBQUcsR0FBSXo3QyxNQUFKLENBQVUsRUFBVixDQUFaLENBQ0EsSUFBSSxHQUFJb0osRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLEVBQW5CLENBQXVCLEVBQUVBLENBQXpCLENBQTRCLENBQzFCcXlDLEtBQUssQ0FBQ3J5QyxDQUFELENBQUwsQ0FBV2diLEVBQUUsQ0FBQ2plLE1BQUgsRUFBWCxDQUNELENBQ0RnZixHQUFHLENBQUNzMkIsS0FBSixDQUFZQSxLQUFaLENBRUE7QUFDQXQyQixHQUFHLENBQUN1MkIsSUFBSixDQUFXLENBQVgsQ0FFQTs7Ozs7Ozs7O0tBVUF2MkIsR0FBRyxDQUFDOWQsUUFBSixDQUFlLFNBQVM0SSxLQUFULENBQWdCOUUsUUFBaEIsQ0FBMEIsQ0FDdkM7QUFDQSxHQUFHLENBQUNBLFFBQUosQ0FBYyxDQUNaLE1BQU9nYSxJQUFHLENBQUN3MkIsWUFBSixDQUFpQjFyQyxLQUFqQixDQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUk2VSxPQUFNLENBQUdLLEdBQUcsQ0FBQ2kyQixNQUFKLENBQVd0MkIsTUFBeEIsQ0FDQSxHQUFJRSxVQUFTLENBQUdHLEdBQUcsQ0FBQ2kyQixNQUFKLENBQVdwMkIsU0FBM0IsQ0FDQSxHQUFJUCxVQUFTLENBQUdVLEdBQUcsQ0FBQ2kyQixNQUFKLENBQVczMkIsU0FBM0IsQ0FDQSxHQUFJRyxXQUFVLENBQUdPLEdBQUcsQ0FBQ2kyQixNQUFKLENBQVd4MkIsVUFBNUIsQ0FDQSxHQUFJcFgsRUFBQyxDQUFHckcsS0FBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBWCxFQUFSLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBNFUsR0FBRyxDQUFDL2pCLEdBQUosQ0FBVSxJQUFWLENBRUFpRyxRQUFRLEdBRVIsUUFBU0EsU0FBVCxDQUFrQjJVLEdBQWxCLENBQXVCLENBQ3JCLEdBQUdBLEdBQUgsQ0FBUSxDQUNOLE1BQU83USxTQUFRLENBQUM2USxHQUFELENBQWYsQ0FDRCxDQUVEO0FBQ0EsR0FBR3hPLENBQUMsQ0FBQzNOLE1BQUYsSUFBY29RLEtBQWpCLENBQXdCLENBQ3RCLE1BQU85RSxTQUFRLENBQUMsSUFBRCxDQUFPcUMsQ0FBQyxDQUFDNEIsUUFBRixDQUFXYSxLQUFYLENBQVAsQ0FBZixDQUNELENBRUQ7QUFDQSxHQUFHa1YsR0FBRyxDQUFDbzJCLFNBQUosQ0FBZ0IsT0FBbkIsQ0FBNEIsQ0FDMUJwMkIsR0FBRyxDQUFDL2pCLEdBQUosQ0FBVSxJQUFWLENBQ0QsQ0FFRCxHQUFHK2pCLEdBQUcsQ0FBQy9qQixHQUFKLEdBQVksSUFBZixDQUFxQixDQUNuQjtBQUNBLE1BQU8rRixNQUFLLENBQUN3RCxJQUFOLENBQVdFLFFBQVgsQ0FBb0IsVUFBVyxDQUNwQyt3QyxPQUFPLENBQUN2MEMsUUFBRCxDQUFQLENBQ0QsQ0FGTSxDQUFQLENBR0QsQ0FFRDtBQUNBLEdBQUlrSCxNQUFLLENBQUd1VyxNQUFNLENBQUNLLEdBQUcsQ0FBQy9qQixHQUFMLENBQVUrakIsR0FBRyxDQUFDTixJQUFkLENBQWxCLENBQ0FNLEdBQUcsQ0FBQ28yQixTQUFKLEVBQWlCaHRDLEtBQUssQ0FBQzFPLE1BQXZCLENBQ0EyTixDQUFDLENBQUNhLFFBQUYsQ0FBV0UsS0FBWCxFQUVBO0FBQ0E0VyxHQUFHLENBQUMvakIsR0FBSixDQUFVcWpCLFNBQVMsQ0FBQ0ssTUFBTSxDQUFDSyxHQUFHLENBQUMvakIsR0FBTCxDQUFVNGpCLFNBQVMsQ0FBQ0csR0FBRyxDQUFDTixJQUFMLENBQW5CLENBQVAsQ0FBbkIsQ0FDQU0sR0FBRyxDQUFDTixJQUFKLENBQVdELFVBQVUsQ0FBQ0UsTUFBTSxDQUFDSyxHQUFHLENBQUMvakIsR0FBTCxDQUFVK2pCLEdBQUcsQ0FBQ04sSUFBZCxDQUFQLENBQXJCLENBRUExZCxLQUFLLENBQUN3RCxJQUFOLENBQVdJLFlBQVgsQ0FBd0IxRCxRQUF4QixFQUNELENBQ0YsQ0F2REQsQ0F5REE7Ozs7OztLQU9BOGQsR0FBRyxDQUFDdzJCLFlBQUosQ0FBbUIsU0FBUzFyQyxLQUFULENBQWdCLENBQ2pDO0FBQ0EsR0FBSTZVLE9BQU0sQ0FBR0ssR0FBRyxDQUFDaTJCLE1BQUosQ0FBV3QyQixNQUF4QixDQUNBLEdBQUlFLFVBQVMsQ0FBR0csR0FBRyxDQUFDaTJCLE1BQUosQ0FBV3AyQixTQUEzQixDQUNBLEdBQUlQLFVBQVMsQ0FBR1UsR0FBRyxDQUFDaTJCLE1BQUosQ0FBVzMyQixTQUEzQixDQUNBLEdBQUlHLFdBQVUsQ0FBR08sR0FBRyxDQUFDaTJCLE1BQUosQ0FBV3gyQixVQUE1QixDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQU8sR0FBRyxDQUFDL2pCLEdBQUosQ0FBVSxJQUFWLENBRUEsR0FBSW9NLEVBQUMsQ0FBR3JHLEtBQUssQ0FBQ3dELElBQU4sQ0FBVzRGLFlBQVgsRUFBUixDQUNBLE1BQU0vQyxDQUFDLENBQUMzTixNQUFGLEdBQWFvUSxLQUFuQixDQUEwQixDQUN4QjtBQUNBLEdBQUdrVixHQUFHLENBQUNvMkIsU0FBSixDQUFnQixPQUFuQixDQUE0QixDQUMxQnAyQixHQUFHLENBQUMvakIsR0FBSixDQUFVLElBQVYsQ0FDRCxDQUVELEdBQUcrakIsR0FBRyxDQUFDL2pCLEdBQUosR0FBWSxJQUFmLENBQXFCLENBQ25CeTZDLFdBQVcsR0FDWixDQUVEO0FBQ0EsR0FBSXR0QyxNQUFLLENBQUd1VyxNQUFNLENBQUNLLEdBQUcsQ0FBQy9qQixHQUFMLENBQVUrakIsR0FBRyxDQUFDTixJQUFkLENBQWxCLENBQ0FNLEdBQUcsQ0FBQ28yQixTQUFKLEVBQWlCaHRDLEtBQUssQ0FBQzFPLE1BQXZCLENBQ0EyTixDQUFDLENBQUNhLFFBQUYsQ0FBV0UsS0FBWCxFQUVBO0FBQ0E0VyxHQUFHLENBQUMvakIsR0FBSixDQUFVcWpCLFNBQVMsQ0FBQ0ssTUFBTSxDQUFDSyxHQUFHLENBQUMvakIsR0FBTCxDQUFVNGpCLFNBQVMsQ0FBQ0csR0FBRyxDQUFDTixJQUFMLENBQW5CLENBQVAsQ0FBbkIsQ0FDQU0sR0FBRyxDQUFDTixJQUFKLENBQVdELFVBQVUsQ0FBQ0UsTUFBTSxDQUFDSyxHQUFHLENBQUMvakIsR0FBTCxDQUFVK2pCLEdBQUcsQ0FBQ04sSUFBZCxDQUFQLENBQXJCLENBQ0QsQ0FFRCxNQUFPclgsRUFBQyxDQUFDNEIsUUFBRixDQUFXYSxLQUFYLENBQVAsQ0FDRCxDQXBDRCxDQXNDQTs7OztLQUtBLFFBQVMyckMsUUFBVCxDQUFpQnp3QyxRQUFqQixDQUEyQixDQUN6QixHQUFHZ2EsR0FBRyxDQUFDczJCLEtBQUosQ0FBVSxDQUFWLEVBQWFuUCxhQUFiLEVBQThCLEVBQWpDLENBQXFDLENBQ25Dd1AsS0FBSyxHQUNMLE1BQU8zd0MsU0FBUSxFQUFmLENBQ0QsQ0FDRDtBQUNBLEdBQUk0d0MsT0FBTSxDQUFJLEdBQUs1MkIsR0FBRyxDQUFDczJCLEtBQUosQ0FBVSxDQUFWLEVBQWFuUCxhQUFuQixFQUFxQyxDQUFsRCxDQUNBbm5CLEdBQUcsQ0FBQzYyQixRQUFKLENBQWFELE1BQWIsQ0FBcUIsU0FBUy8vQixHQUFULENBQWN6TixLQUFkLENBQXFCLENBQ3hDLEdBQUd5TixHQUFILENBQVEsQ0FDTixNQUFPN1EsU0FBUSxDQUFDNlEsR0FBRCxDQUFmLENBQ0QsQ0FDRG1KLEdBQUcsQ0FBQ1UsT0FBSixDQUFZdFgsS0FBWixFQUNBdXRDLEtBQUssR0FDTDN3QyxRQUFRLEdBQ1QsQ0FQRCxFQVFELENBRUQ7O0tBR0EsUUFBUzB3QyxZQUFULEVBQXVCLENBQ3JCLEdBQUcxMkIsR0FBRyxDQUFDczJCLEtBQUosQ0FBVSxDQUFWLEVBQWFuUCxhQUFiLEVBQThCLEVBQWpDLENBQXFDLENBQ25DLE1BQU93UCxNQUFLLEVBQVosQ0FDRCxDQUNEO0FBQ0EsR0FBSUMsT0FBTSxDQUFJLEdBQUs1MkIsR0FBRyxDQUFDczJCLEtBQUosQ0FBVSxDQUFWLEVBQWFuUCxhQUFuQixFQUFxQyxDQUFsRCxDQUNBbm5CLEdBQUcsQ0FBQ1UsT0FBSixDQUFZVixHQUFHLENBQUM4MkIsWUFBSixDQUFpQkYsTUFBakIsQ0FBWixFQUNBRCxLQUFLLEdBQ04sQ0FFRDs7S0FHQSxRQUFTQSxNQUFULEVBQWlCLENBQ2Y7QUFDQTMyQixHQUFHLENBQUNtMkIsT0FBSixDQUFlbjJCLEdBQUcsQ0FBQ20yQixPQUFKLEdBQWdCLFVBQWpCLENBQStCLENBQS9CLENBQW1DbjJCLEdBQUcsQ0FBQ20yQixPQUFKLENBQWMsQ0FBL0QsQ0FFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBLEdBQUlsM0IsR0FBRSxDQUFHZSxHQUFHLENBQUNpMkIsTUFBSixDQUFXaDNCLEVBQVgsQ0FBY2plLE1BQWQsRUFBVCxDQUVBO0FBQ0FpZSxFQUFFLENBQUNySixNQUFILENBQVVvSyxHQUFHLENBQUNxMkIsUUFBZCxFQUVBO0FBQ0E7QUFDQSxHQUFJVSxPQUFNLENBQUcsQ0FBYixDQUNBLElBQUksR0FBSWwzQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsRUFBbkIsQ0FBdUIsRUFBRUEsQ0FBekIsQ0FBNEIsQ0FDMUIsR0FBR21nQixHQUFHLENBQUNtMkIsT0FBSixDQUFjWSxNQUFkLEdBQXlCLENBQTVCLENBQStCLENBQzdCOTNCLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVW9LLEdBQUcsQ0FBQ3MyQixLQUFKLENBQVV6MkMsQ0FBVixFQUFhZ2lCLE1BQWIsR0FBc0I1WCxRQUF0QixFQUFWLEVBQ0ErVixHQUFHLENBQUNzMkIsS0FBSixDQUFVejJDLENBQVYsRUFBYStQLEtBQWIsR0FDRCxDQUNEbW5DLE1BQU0sQ0FBR0EsTUFBTSxFQUFJLENBQW5CLENBQ0QsQ0FFRDtBQUNBLzJCLEdBQUcsQ0FBQ3EyQixRQUFKLENBQWVwM0IsRUFBRSxDQUFDNEMsTUFBSCxHQUFZNVgsUUFBWixFQUFmLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQWdWLEVBQUUsQ0FBQ3JQLEtBQUgsR0FDQXFQLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVW9LLEdBQUcsQ0FBQ3EyQixRQUFkLEVBQ0EsR0FBSVcsVUFBUyxDQUFHLzNCLEVBQUUsQ0FBQzRDLE1BQUgsR0FBWTVYLFFBQVosRUFBaEIsQ0FFQTtBQUNBK1YsR0FBRyxDQUFDL2pCLEdBQUosQ0FBVStqQixHQUFHLENBQUNpMkIsTUFBSixDQUFXMzJCLFNBQVgsQ0FBcUJVLEdBQUcsQ0FBQ3EyQixRQUF6QixDQUFWLENBQ0FyMkIsR0FBRyxDQUFDTixJQUFKLENBQVdNLEdBQUcsQ0FBQ2kyQixNQUFKLENBQVd4MkIsVUFBWCxDQUFzQnUzQixTQUF0QixDQUFYLENBQ0FoM0IsR0FBRyxDQUFDbzJCLFNBQUosQ0FBZ0IsQ0FBaEIsQ0FDRCxDQUVEOzs7Ozs7O0tBUUEsUUFBU2EsZ0JBQVQsQ0FBeUJMLE1BQXpCLENBQWlDLENBQy9CO0FBQ0EsR0FBSXgyQixnQkFBZSxDQUFHLElBQXRCLENBQ0EsR0FBRyxNQUFPemhCLE9BQVAsR0FBa0IsV0FBckIsQ0FBa0MsQ0FDaEMsR0FBSTBoQixRQUFPLENBQUcxaEIsTUFBTSxDQUFDMmhCLE1BQVAsRUFBaUIzaEIsTUFBTSxDQUFDNGhCLFFBQXRDLENBQ0EsR0FBR0YsT0FBTyxFQUFJQSxPQUFPLENBQUNELGVBQXRCLENBQXVDLENBQ3JDQSxlQUFlLENBQUcseUJBQVM1WCxHQUFULENBQWMsQ0FDOUIsTUFBTzZYLFFBQU8sQ0FBQ0QsZUFBUixDQUF3QjVYLEdBQXhCLENBQVAsQ0FDRCxDQUZELENBR0QsQ0FDRixDQUVELEdBQUlILEVBQUMsQ0FBR3JHLEtBQUssQ0FBQ3dELElBQU4sQ0FBVzRGLFlBQVgsRUFBUixDQUNBLEdBQUdnVixlQUFILENBQW9CLENBQ2xCLE1BQU0vWCxDQUFDLENBQUMzTixNQUFGLEdBQWFrOEMsTUFBbkIsQ0FBMkIsQ0FDekI7QUFDQTtBQUNBLEdBQUk5ckMsTUFBSyxDQUFHOUssSUFBSSxDQUFDNkssR0FBTCxDQUFTLENBQVQsQ0FBWTdLLElBQUksQ0FBQytLLEdBQUwsQ0FBUzZyQyxNQUFNLENBQUd2dUMsQ0FBQyxDQUFDM04sTUFBRixFQUFsQixDQUE4QixLQUE5QixFQUF1QyxDQUFuRCxDQUFaLENBQ0EsR0FBSXc4QyxRQUFPLENBQUcsR0FBSUMsWUFBSixDQUFnQm4zQyxJQUFJLENBQUMyVyxLQUFMLENBQVc3TCxLQUFYLENBQWhCLENBQWQsQ0FDQSxHQUFJLENBQ0ZzVixlQUFlLENBQUM4MkIsT0FBRCxDQUFmLENBQ0EsSUFBSSxHQUFJanpDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR2l6QyxPQUFPLENBQUN4OEMsTUFBM0IsQ0FBbUMsRUFBRXVKLENBQXJDLENBQXdDLENBQ3RDb0UsQ0FBQyxDQUFDcUIsUUFBRixDQUFXd3RDLE9BQU8sQ0FBQ2p6QyxDQUFELENBQWxCLEVBQ0QsQ0FDRixDQUFDLE1BQU0yRSxDQUFOLENBQVMsQ0FDVCxvQ0FDQSxHQUFHLEVBQUUsTUFBT3d1QyxtQkFBUCxHQUE4QixXQUE5QixFQUNIeHVDLENBQUMsV0FBWXd1QyxtQkFEWixDQUFILENBQ29DLENBQ2xDLEtBQU14dUMsRUFBTixDQUNELENBQ0YsQ0FDRixDQUNGLENBRUQ7QUFDQSxHQUFHUCxDQUFDLENBQUMzTixNQUFGLEdBQWFrOEMsTUFBaEIsQ0FBd0IsQ0FDdEI7OzhDQUdBLEdBQUlTLEdBQUosQ0FBUUMsRUFBUixDQUFZN2pDLElBQVosQ0FDQSxHQUFJaU0sS0FBSSxDQUFHMWYsSUFBSSxDQUFDMlcsS0FBTCxDQUFXM1csSUFBSSxDQUFDQyxNQUFMLEdBQWdCLFFBQTNCLENBQVgsQ0FDQSxNQUFNb0ksQ0FBQyxDQUFDM04sTUFBRixHQUFhazhDLE1BQW5CLENBQTJCLENBQ3pCVSxFQUFFLENBQUcsT0FBUzUzQixJQUFJLENBQUcsTUFBaEIsQ0FBTCxDQUNBMjNCLEVBQUUsQ0FBRyxPQUFTMzNCLElBQUksRUFBSSxFQUFqQixDQUFMLENBQ0E0M0IsRUFBRSxFQUFJLENBQUNELEVBQUUsQ0FBRyxNQUFOLEdBQWlCLEVBQXZCLENBQ0FDLEVBQUUsRUFBSUQsRUFBRSxFQUFJLEVBQVosQ0FDQUMsRUFBRSxDQUFHLENBQUNBLEVBQUUsQ0FBRyxVQUFOLEdBQXFCQSxFQUFFLEVBQUksRUFBM0IsQ0FBTCxDQUNBNTNCLElBQUksQ0FBRzQzQixFQUFFLENBQUcsVUFBWixDQUVBO0FBQ0EsSUFBSSxHQUFJcnpDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxDQUFuQixDQUFzQixFQUFFQSxDQUF4QixDQUEyQixDQUN6QjtBQUNBd1AsSUFBSSxDQUFHaU0sSUFBSSxJQUFNemIsQ0FBQyxFQUFJLENBQVgsQ0FBWCxDQUNBd1AsSUFBSSxFQUFJelQsSUFBSSxDQUFDMlcsS0FBTCxDQUFXM1csSUFBSSxDQUFDQyxNQUFMLEdBQWdCLE1BQTNCLENBQVIsQ0FDQW9JLENBQUMsQ0FBQ1EsT0FBRixDQUFVSCxNQUFNLENBQUNDLFlBQVAsQ0FBb0I4SyxJQUFJLENBQUcsSUFBM0IsQ0FBVixFQUNELENBQ0YsQ0FDRixDQUVELE1BQU9wTCxFQUFDLENBQUM0QixRQUFGLENBQVcyc0MsTUFBWCxDQUFQLENBQ0QsQ0FDRDtBQUNBLEdBQUd2MkIsT0FBSCxDQUFZLENBQ1Y7QUFDQUwsR0FBRyxDQUFDNjJCLFFBQUosQ0FBZSxTQUFTRCxNQUFULENBQWlCNXdDLFFBQWpCLENBQTJCLENBQ3hDcWEsT0FBTyxDQUFDazNCLFdBQVIsQ0FBb0JYLE1BQXBCLENBQTRCLFNBQVMvL0IsR0FBVCxDQUFjek4sS0FBZCxDQUFxQixDQUMvQyxHQUFHeU4sR0FBSCxDQUFRLENBQ04sTUFBTzdRLFNBQVEsQ0FBQzZRLEdBQUQsQ0FBZixDQUNELENBQ0Q3USxRQUFRLENBQUMsSUFBRCxDQUFPb0QsS0FBSyxDQUFDak8sUUFBTixFQUFQLENBQVIsQ0FDRCxDQUxELEVBTUQsQ0FQRCxDQVFBO0FBQ0E2a0IsR0FBRyxDQUFDODJCLFlBQUosQ0FBbUIsU0FBU0YsTUFBVCxDQUFpQixDQUNsQyxNQUFPdjJCLFFBQU8sQ0FBQ2szQixXQUFSLENBQW9CWCxNQUFwQixFQUE0Qno3QyxRQUE1QixFQUFQLENBQ0QsQ0FGRCxDQUdELENBZEQsSUFjTyxDQUNMNmtCLEdBQUcsQ0FBQzYyQixRQUFKLENBQWUsU0FBU0QsTUFBVCxDQUFpQjV3QyxRQUFqQixDQUEyQixDQUN4QyxHQUFJLENBQ0ZBLFFBQVEsQ0FBQyxJQUFELENBQU9peEMsZUFBZSxDQUFDTCxNQUFELENBQXRCLENBQVIsQ0FDRCxDQUFDLE1BQU1odUMsQ0FBTixDQUFTLENBQ1Q1QyxRQUFRLENBQUM0QyxDQUFELENBQVIsQ0FDRCxDQUNGLENBTkQsQ0FPQW9YLEdBQUcsQ0FBQzgyQixZQUFKLENBQW1CRyxlQUFuQixDQUNELENBRUQ7Ozs7S0FLQWozQixHQUFHLENBQUNVLE9BQUosQ0FBYyxTQUFTdFgsS0FBVCxDQUFnQixDQUM1QjtBQUNBLEdBQUkwQixNQUFLLENBQUcxQixLQUFLLENBQUMxTyxNQUFsQixDQUNBLElBQUksR0FBSXVKLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzZHLEtBQW5CLENBQTBCLEVBQUU3RyxDQUE1QixDQUErQixDQUM3QitiLEdBQUcsQ0FBQ3MyQixLQUFKLENBQVV0MkIsR0FBRyxDQUFDdTJCLElBQWQsRUFBb0IzZ0MsTUFBcEIsQ0FBMkJ4TSxLQUFLLENBQUNsSixNQUFOLENBQWErRCxDQUFiLENBQWdCLENBQWhCLENBQTNCLEVBQ0ErYixHQUFHLENBQUN1MkIsSUFBSixDQUFZdjJCLEdBQUcsQ0FBQ3UyQixJQUFKLEdBQWEsRUFBZCxDQUFvQixDQUFwQixDQUF3QnYyQixHQUFHLENBQUN1MkIsSUFBSixDQUFXLENBQTlDLENBQ0QsQ0FDRixDQVBELENBU0E7Ozs7O0tBTUF2MkIsR0FBRyxDQUFDUSxVQUFKLENBQWlCLFNBQVN2YyxDQUFULENBQVlXLENBQVosQ0FBZSxDQUM5QixHQUFJd0UsTUFBSyxDQUFHLEVBQVosQ0FDQSxJQUFJLEdBQUl4QixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdoRCxDQUFuQixDQUFzQmdELENBQUMsRUFBSSxDQUEzQixDQUE4QixDQUM1QndCLEtBQUssRUFBSVYsTUFBTSxDQUFDQyxZQUFQLENBQXFCMUUsQ0FBQyxFQUFJMkQsQ0FBTixDQUFXLElBQS9CLENBQVQsQ0FDRCxDQUNEb1ksR0FBRyxDQUFDVSxPQUFKLENBQVl0WCxLQUFaLEVBQ0QsQ0FORCxDQVFBOzs7Ozs7O0tBUUE0VyxHQUFHLENBQUN3M0IsY0FBSixDQUFxQixTQUFTeGdDLE1BQVQsQ0FBaUIsQ0FDcEM7QUFDQSxHQUFHQSxNQUFNLEdBQUtwVCxJQUFkLENBQW9CLENBQ2xCb2MsR0FBRyxDQUFDNjJCLFFBQUosQ0FBZSxTQUFTRCxNQUFULENBQWlCNXdDLFFBQWpCLENBQTJCLENBQ3hDLFFBQVN5eEMsU0FBVCxDQUFrQjd1QyxDQUFsQixDQUFxQixDQUNuQixHQUFJOU0sS0FBSSxDQUFHOE0sQ0FBQyxDQUFDOU0sSUFBYixDQUNBLEdBQUdBLElBQUksQ0FBQ2tHLEtBQUwsRUFBY2xHLElBQUksQ0FBQ2tHLEtBQUwsQ0FBV2llLElBQTVCLENBQWtDLENBQ2hDcmMsSUFBSSxDQUFDOHpDLG1CQUFMLENBQXlCLFNBQXpCLENBQW9DRCxRQUFwQyxFQUNBenhDLFFBQVEsQ0FBQ2xLLElBQUksQ0FBQ2tHLEtBQUwsQ0FBV2llLElBQVgsQ0FBZ0JwSixHQUFqQixDQUFzQi9hLElBQUksQ0FBQ2tHLEtBQUwsQ0FBV2llLElBQVgsQ0FBZ0I3VyxLQUF0QyxDQUFSLENBQ0QsQ0FDRixDQUNEeEYsSUFBSSxDQUFDZ0QsZ0JBQUwsQ0FBc0IsU0FBdEIsQ0FBaUM2d0MsUUFBakMsRUFDQTd6QyxJQUFJLENBQUM5QyxXQUFMLENBQWlCLENBQUNrQixLQUFLLENBQUUsQ0FBQ2llLElBQUksQ0FBRSxDQUFDMjJCLE1BQU0sQ0FBRUEsTUFBVCxDQUFQLENBQVIsQ0FBakIsRUFDRCxDQVZELENBV0QsQ0FaRCxJQVlPLENBQ0w7QUFDQSxHQUFJYSxTQUFRLENBQUcsUUFBWEEsU0FBVyxDQUFTN3VDLENBQVQsQ0FBWSxDQUN6QixHQUFJOU0sS0FBSSxDQUFHOE0sQ0FBQyxDQUFDOU0sSUFBYixDQUNBLEdBQUdBLElBQUksQ0FBQ2tHLEtBQUwsRUFBY2xHLElBQUksQ0FBQ2tHLEtBQUwsQ0FBV2llLElBQTVCLENBQWtDLENBQ2hDRCxHQUFHLENBQUM2MkIsUUFBSixDQUFhLzZDLElBQUksQ0FBQ2tHLEtBQUwsQ0FBV2llLElBQVgsQ0FBZ0IyMkIsTUFBN0IsQ0FBcUMsU0FBUy8vQixHQUFULENBQWN6TixLQUFkLENBQXFCLENBQ3hENE4sTUFBTSxDQUFDbFcsV0FBUCxDQUFtQixDQUFDa0IsS0FBSyxDQUFFLENBQUNpZSxJQUFJLENBQUUsQ0FBQ3BKLEdBQUcsQ0FBRUEsR0FBTixDQUFXek4sS0FBSyxDQUFFQSxLQUFsQixDQUFQLENBQVIsQ0FBbkIsRUFDRCxDQUZELEVBR0QsQ0FDRixDQVBELENBUUE7QUFDQTROLE1BQU0sQ0FBQ3BRLGdCQUFQLENBQXdCLFNBQXhCLENBQW1DNndDLFFBQW5DLEVBQ0QsQ0FDRixDQTNCRCxDQTZCQSxNQUFPejNCLElBQVAsQ0FDRCxDQTFYRCxDQTZYQSxLQUFPLENBNzNoQkcsQ0E4M2hCVixRQTkzaEJVLENBKzNoQlYsS0FBTyxTQUFTdGMsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7Ozs7O0dBVUEsR0FBSS9CLE1BQUssQ0FBRytCLG1CQUFtQixDQUFDLENBQUQsQ0FBL0IsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUVBLEdBQUk0ekMsUUFBTyxDQUFHLENBQ1osSUFEWSxDQUNOLElBRE0sQ0FDQSxJQURBLENBQ00sSUFETixDQUNZLElBRFosQ0FDa0IsSUFEbEIsQ0FDd0IsSUFEeEIsQ0FDOEIsSUFEOUIsQ0FDb0MsSUFEcEMsQ0FDMEMsSUFEMUMsQ0FDZ0QsSUFEaEQsQ0FDc0QsSUFEdEQsQ0FDNEQsSUFENUQsQ0FDa0UsSUFEbEUsQ0FDd0UsSUFEeEUsQ0FDOEUsSUFEOUUsQ0FFWixJQUZZLENBRU4sSUFGTSxDQUVBLElBRkEsQ0FFTSxJQUZOLENBRVksSUFGWixDQUVrQixJQUZsQixDQUV3QixJQUZ4QixDQUU4QixJQUY5QixDQUVvQyxJQUZwQyxDQUUwQyxJQUYxQyxDQUVnRCxJQUZoRCxDQUVzRCxJQUZ0RCxDQUU0RCxJQUY1RCxDQUVrRSxJQUZsRSxDQUV3RSxJQUZ4RSxDQUU4RSxJQUY5RSxDQUdaLElBSFksQ0FHTixJQUhNLENBR0EsSUFIQSxDQUdNLElBSE4sQ0FHWSxJQUhaLENBR2tCLElBSGxCLENBR3dCLElBSHhCLENBRzhCLElBSDlCLENBR29DLElBSHBDLENBRzBDLElBSDFDLENBR2dELElBSGhELENBR3NELElBSHRELENBRzRELElBSDVELENBR2tFLElBSGxFLENBR3dFLElBSHhFLENBRzhFLElBSDlFLENBSVosSUFKWSxDQUlOLElBSk0sQ0FJQSxJQUpBLENBSU0sSUFKTixDQUlZLElBSlosQ0FJa0IsSUFKbEIsQ0FJd0IsSUFKeEIsQ0FJOEIsSUFKOUIsQ0FJb0MsSUFKcEMsQ0FJMEMsSUFKMUMsQ0FJZ0QsSUFKaEQsQ0FJc0QsSUFKdEQsQ0FJNEQsSUFKNUQsQ0FJa0UsSUFKbEUsQ0FJd0UsSUFKeEUsQ0FJOEUsSUFKOUUsQ0FLWixJQUxZLENBS04sSUFMTSxDQUtBLElBTEEsQ0FLTSxJQUxOLENBS1ksSUFMWixDQUtrQixJQUxsQixDQUt3QixJQUx4QixDQUs4QixJQUw5QixDQUtvQyxJQUxwQyxDQUswQyxJQUwxQyxDQUtnRCxJQUxoRCxDQUtzRCxJQUx0RCxDQUs0RCxJQUw1RCxDQUtrRSxJQUxsRSxDQUt3RSxJQUx4RSxDQUs4RSxJQUw5RSxDQU1aLElBTlksQ0FNTixJQU5NLENBTUEsSUFOQSxDQU1NLElBTk4sQ0FNWSxJQU5aLENBTWtCLElBTmxCLENBTXdCLElBTnhCLENBTThCLElBTjlCLENBTW9DLElBTnBDLENBTTBDLElBTjFDLENBTWdELElBTmhELENBTXNELElBTnRELENBTTRELElBTjVELENBTWtFLElBTmxFLENBTXdFLElBTnhFLENBTThFLElBTjlFLENBT1osSUFQWSxDQU9OLElBUE0sQ0FPQSxJQVBBLENBT00sSUFQTixDQU9ZLElBUFosQ0FPa0IsSUFQbEIsQ0FPd0IsSUFQeEIsQ0FPOEIsSUFQOUIsQ0FPb0MsSUFQcEMsQ0FPMEMsSUFQMUMsQ0FPZ0QsSUFQaEQsQ0FPc0QsSUFQdEQsQ0FPNEQsSUFQNUQsQ0FPa0UsSUFQbEUsQ0FPd0UsSUFQeEUsQ0FPOEUsSUFQOUUsQ0FRWixJQVJZLENBUU4sSUFSTSxDQVFBLElBUkEsQ0FRTSxJQVJOLENBUVksSUFSWixDQVFrQixJQVJsQixDQVF3QixJQVJ4QixDQVE4QixJQVI5QixDQVFvQyxJQVJwQyxDQVEwQyxJQVIxQyxDQVFnRCxJQVJoRCxDQVFzRCxJQVJ0RCxDQVE0RCxJQVI1RCxDQVFrRSxJQVJsRSxDQVF3RSxJQVJ4RSxDQVE4RSxJQVI5RSxDQVNaLElBVFksQ0FTTixJQVRNLENBU0EsSUFUQSxDQVNNLElBVE4sQ0FTWSxJQVRaLENBU2tCLElBVGxCLENBU3dCLElBVHhCLENBUzhCLElBVDlCLENBU29DLElBVHBDLENBUzBDLElBVDFDLENBU2dELElBVGhELENBU3NELElBVHRELENBUzRELElBVDVELENBU2tFLElBVGxFLENBU3dFLElBVHhFLENBUzhFLElBVDlFLENBVVosSUFWWSxDQVVOLElBVk0sQ0FVQSxJQVZBLENBVU0sSUFWTixDQVVZLElBVlosQ0FVa0IsSUFWbEIsQ0FVd0IsSUFWeEIsQ0FVOEIsSUFWOUIsQ0FVb0MsSUFWcEMsQ0FVMEMsSUFWMUMsQ0FVZ0QsSUFWaEQsQ0FVc0QsSUFWdEQsQ0FVNEQsSUFWNUQsQ0FVa0UsSUFWbEUsQ0FVd0UsSUFWeEUsQ0FVOEUsSUFWOUUsQ0FXWixJQVhZLENBV04sSUFYTSxDQVdBLElBWEEsQ0FXTSxJQVhOLENBV1ksSUFYWixDQVdrQixJQVhsQixDQVd3QixJQVh4QixDQVc4QixJQVg5QixDQVdvQyxJQVhwQyxDQVcwQyxJQVgxQyxDQVdnRCxJQVhoRCxDQVdzRCxJQVh0RCxDQVc0RCxJQVg1RCxDQVdrRSxJQVhsRSxDQVd3RSxJQVh4RSxDQVc4RSxJQVg5RSxDQVlaLElBWlksQ0FZTixJQVpNLENBWUEsSUFaQSxDQVlNLElBWk4sQ0FZWSxJQVpaLENBWWtCLElBWmxCLENBWXdCLElBWnhCLENBWThCLElBWjlCLENBWW9DLElBWnBDLENBWTBDLElBWjFDLENBWWdELElBWmhELENBWXNELElBWnRELENBWTRELElBWjVELENBWWtFLElBWmxFLENBWXdFLElBWnhFLENBWThFLElBWjlFLENBYVosSUFiWSxDQWFOLElBYk0sQ0FhQSxJQWJBLENBYU0sSUFiTixDQWFZLElBYlosQ0Fha0IsSUFibEIsQ0Fhd0IsSUFieEIsQ0FhOEIsSUFiOUIsQ0Fhb0MsSUFicEMsQ0FhMEMsSUFiMUMsQ0FhZ0QsSUFiaEQsQ0Fhc0QsSUFidEQsQ0FhNEQsSUFiNUQsQ0Fha0UsSUFibEUsQ0Fhd0UsSUFieEUsQ0FhOEUsSUFiOUUsQ0FjWixJQWRZLENBY04sSUFkTSxDQWNBLElBZEEsQ0FjTSxJQWROLENBY1ksSUFkWixDQWNrQixJQWRsQixDQWN3QixJQWR4QixDQWM4QixJQWQ5QixDQWNvQyxJQWRwQyxDQWMwQyxJQWQxQyxDQWNnRCxJQWRoRCxDQWNzRCxJQWR0RCxDQWM0RCxJQWQ1RCxDQWNrRSxJQWRsRSxDQWN3RSxJQWR4RSxDQWM4RSxJQWQ5RSxDQWVaLElBZlksQ0FlTixJQWZNLENBZUEsSUFmQSxDQWVNLElBZk4sQ0FlWSxJQWZaLENBZWtCLElBZmxCLENBZXdCLElBZnhCLENBZThCLElBZjlCLENBZW9DLElBZnBDLENBZTBDLElBZjFDLENBZWdELElBZmhELENBZXNELElBZnRELENBZTRELElBZjVELENBZWtFLElBZmxFLENBZXdFLElBZnhFLENBZThFLElBZjlFLENBZ0JaLElBaEJZLENBZ0JOLElBaEJNLENBZ0JBLElBaEJBLENBZ0JNLElBaEJOLENBZ0JZLElBaEJaLENBZ0JrQixJQWhCbEIsQ0FnQndCLElBaEJ4QixDQWdCOEIsSUFoQjlCLENBZ0JvQyxJQWhCcEMsQ0FnQjBDLElBaEIxQyxDQWdCZ0QsSUFoQmhELENBZ0JzRCxJQWhCdEQsQ0FnQjRELElBaEI1RCxDQWdCa0UsSUFoQmxFLENBZ0J3RSxJQWhCeEUsQ0FnQjhFLElBaEI5RSxDQUFkLENBbUJBLEdBQUl0eUMsRUFBQyxDQUFHLENBQUMsQ0FBRCxDQUFJLENBQUosQ0FBTyxDQUFQLENBQVUsQ0FBVixDQUFSLENBRUE7Ozs7Ozs7OztHQVVBLEdBQUl1eUMsSUFBRyxDQUFHLFFBQU5BLElBQU0sQ0FBU0MsSUFBVCxDQUFlajBCLElBQWYsQ0FBcUIsQ0FDN0IsTUFBU2kwQixLQUFJLEVBQUlqMEIsSUFBVCxDQUFpQixNQUFsQixDQUE2QixDQUFDaTBCLElBQUksQ0FBRyxNQUFSLEdBQW9CLEdBQUtqMEIsSUFBN0QsQ0FDRCxDQUZELENBSUE7Ozs7Ozs7OztHQVVBLEdBQUlrMEIsSUFBRyxDQUFHLFFBQU5BLElBQU0sQ0FBU0QsSUFBVCxDQUFlajBCLElBQWYsQ0FBcUIsQ0FDN0IsTUFBUSxDQUFDaTBCLElBQUksQ0FBRyxNQUFSLEdBQW1CajBCLElBQXBCLENBQThCaTBCLElBQUksRUFBSyxHQUFLajBCLElBQWYsQ0FBd0IsTUFBNUQsQ0FDRCxDQUZELENBSUEsYUFDQWxnQixNQUFNLENBQUNELE9BQVAsQ0FBaUJ6QixLQUFLLENBQUNrdkIsR0FBTixDQUFZbHZCLEtBQUssQ0FBQ2t2QixHQUFOLEVBQWEsRUFBMUMsQ0FFQTs7Ozs7O0dBT0FsdkIsS0FBSyxDQUFDa3ZCLEdBQU4sQ0FBVTZtQixTQUFWLENBQXNCLFNBQVM5N0MsR0FBVCxDQUFjKzdDLFVBQWQsQ0FBMEIsQ0FDOUMsR0FBRyxNQUFPLzdDLElBQVAsR0FBZSxRQUFsQixDQUE0QixDQUMxQkEsR0FBRyxDQUFHK0YsS0FBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBWCxDQUF3Qm5QLEdBQXhCLENBQU4sQ0FDRCxDQUNEKzdDLFVBQVUsQ0FBR0EsVUFBVSxFQUFJLEdBQTNCLENBRUEsZ0VBQ0EsR0FBSUMsRUFBQyxDQUFHaDhDLEdBQVIsQ0FDQSxHQUFJaThDLEVBQUMsQ0FBR2o4QyxHQUFHLENBQUN2QixNQUFKLEVBQVIsQ0FDQSxHQUFJeTlDLEdBQUUsQ0FBR0gsVUFBVCxDQUNBLEdBQUlJLEdBQUUsQ0FBR3A0QyxJQUFJLENBQUN5TSxJQUFMLENBQVUwckMsRUFBRSxDQUFHLENBQWYsQ0FBVCxDQUNBLEdBQUlFLEdBQUUsQ0FBRyxPQUFTRixFQUFFLENBQUcsSUFBZCxDQUFULENBQ0EsR0FBSWwwQyxFQUFKLENBRUEsSUFBSUEsQ0FBQyxDQUFHaTBDLENBQVIsQ0FBV2owQyxDQUFDLENBQUcsR0FBZixDQUFvQkEsQ0FBQyxFQUFyQixDQUF5QixDQUN2QmcwQyxDQUFDLENBQUNwdkMsT0FBRixDQUFVOHVDLE9BQU8sQ0FBRU0sQ0FBQyxDQUFDaHRDLEVBQUYsQ0FBS2hILENBQUMsQ0FBRyxDQUFULEVBQWNnMEMsQ0FBQyxDQUFDaHRDLEVBQUYsQ0FBS2hILENBQUMsQ0FBR2kwQyxDQUFULENBQWYsQ0FBOEIsSUFBL0IsQ0FBakIsRUFDRCxDQUVERCxDQUFDLENBQUMvc0MsS0FBRixDQUFRLElBQU1rdEMsRUFBZCxDQUFrQlQsT0FBTyxDQUFDTSxDQUFDLENBQUNodEMsRUFBRixDQUFLLElBQU1tdEMsRUFBWCxFQUFpQkMsRUFBbEIsQ0FBekIsRUFFQSxJQUFJcDBDLENBQUMsQ0FBRyxJQUFNbTBDLEVBQWQsQ0FBa0JuMEMsQ0FBQyxFQUFJLENBQXZCLENBQTBCQSxDQUFDLEVBQTNCLENBQStCLENBQzdCZzBDLENBQUMsQ0FBQy9zQyxLQUFGLENBQVFqSCxDQUFSLENBQVcwekMsT0FBTyxDQUFDTSxDQUFDLENBQUNodEMsRUFBRixDQUFLaEgsQ0FBQyxDQUFHLENBQVQsRUFBY2cwQyxDQUFDLENBQUNodEMsRUFBRixDQUFLaEgsQ0FBQyxDQUFHbTBDLEVBQVQsQ0FBZixDQUFsQixFQUNELENBRUQsTUFBT0gsRUFBUCxDQUNELENBekJELENBMkJBOzs7Ozs7OztHQVNBLEdBQUkxcUIsYUFBWSxDQUFHLFFBQWZBLGFBQWUsQ0FBU3R4QixHQUFULENBQWMybkIsSUFBZCxDQUFvQlgsT0FBcEIsQ0FBNkIsQ0FDOUMsR0FBSW1RLFFBQU8sQ0FBRyxLQUFkLENBQXFCQyxNQUFNLENBQUcsSUFBOUIsQ0FBb0NpbEIsT0FBTyxDQUFHLElBQTlDLENBQW9EcmtCLEdBQUcsQ0FBRyxJQUExRCxDQUNBLEdBQUlza0IsU0FBSixDQUFjQyxTQUFkLENBQ0EsR0FBSXYwQyxFQUFKLENBQU93TCxDQUFQLENBQVVncEMsQ0FBQyxDQUFHLEVBQWQsQ0FFQSx3Q0FDQXg4QyxHQUFHLENBQUcrRixLQUFLLENBQUNrdkIsR0FBTixDQUFVNm1CLFNBQVYsQ0FBb0I5N0MsR0FBcEIsQ0FBeUIybkIsSUFBekIsQ0FBTixDQUNBLElBQUkzZixDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUcsRUFBZixDQUFtQkEsQ0FBQyxFQUFwQixDQUF3QixDQUN0QncwQyxDQUFDLENBQUM5eEMsSUFBRixDQUFPMUssR0FBRyxDQUFDdU8sVUFBSixFQUFQLEVBQ0QsQ0FFRCxHQUFHeVksT0FBSCxDQUFZLENBQ1Y7Ozs7T0FLQXMxQixRQUFRLENBQUcsa0JBQVNHLENBQVQsQ0FBWSxDQUNyQixJQUFJejBDLENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsQ0FBRyxDQUFmLENBQWtCQSxDQUFDLEVBQW5CLENBQXVCLENBQ3JCeTBDLENBQUMsQ0FBQ3owQyxDQUFELENBQUQsRUFBUXcwQyxDQUFDLENBQUNocEMsQ0FBRCxDQUFELEVBQVFpcEMsQ0FBQyxDQUFDLENBQUN6MEMsQ0FBQyxDQUFHLENBQUwsRUFBVSxDQUFYLENBQUQsQ0FBaUJ5MEMsQ0FBQyxDQUFDLENBQUN6MEMsQ0FBQyxDQUFHLENBQUwsRUFBVSxDQUFYLENBQTFCLEdBQ0osQ0FBQ3kwQyxDQUFDLENBQUMsQ0FBQ3owQyxDQUFDLENBQUcsQ0FBTCxFQUFVLENBQVgsQ0FBSCxDQUFvQnkwQyxDQUFDLENBQUMsQ0FBQ3owQyxDQUFDLENBQUcsQ0FBTCxFQUFVLENBQVgsQ0FEaEIsQ0FBUixDQUVBeTBDLENBQUMsQ0FBQ3owQyxDQUFELENBQUQsQ0FBTzJ6QyxHQUFHLENBQUNjLENBQUMsQ0FBQ3owQyxDQUFELENBQUYsQ0FBT29CLENBQUMsQ0FBQ3BCLENBQUQsQ0FBUixDQUFWLENBQ0F3TCxDQUFDLEdBQ0YsQ0FDRixDQVBELENBU0E7Ozs7T0FLQStvQyxTQUFTLENBQUcsbUJBQVNFLENBQVQsQ0FBWSxDQUN0QixJQUFJejBDLENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsQ0FBRyxDQUFmLENBQWtCQSxDQUFDLEVBQW5CLENBQXVCLENBQ3JCeTBDLENBQUMsQ0FBQ3owQyxDQUFELENBQUQsRUFBUXcwQyxDQUFDLENBQUNDLENBQUMsQ0FBQyxDQUFDejBDLENBQUMsQ0FBRyxDQUFMLEVBQVUsQ0FBWCxDQUFELENBQWlCLEVBQWxCLENBQVQsQ0FDRCxDQUNGLENBSkQsQ0FLRCxDQXpCRCxJQXlCTyxDQUNMOzs7O09BS0FzMEMsUUFBUSxDQUFHLGtCQUFTRyxDQUFULENBQVksQ0FDckIsSUFBSXowQyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLEVBQUksQ0FBaEIsQ0FBbUJBLENBQUMsRUFBcEIsQ0FBd0IsQ0FDdEJ5MEMsQ0FBQyxDQUFDejBDLENBQUQsQ0FBRCxDQUFPNnpDLEdBQUcsQ0FBQ1ksQ0FBQyxDQUFDejBDLENBQUQsQ0FBRixDQUFPb0IsQ0FBQyxDQUFDcEIsQ0FBRCxDQUFSLENBQVYsQ0FDQXkwQyxDQUFDLENBQUN6MEMsQ0FBRCxDQUFELEVBQVF3MEMsQ0FBQyxDQUFDaHBDLENBQUQsQ0FBRCxFQUFRaXBDLENBQUMsQ0FBQyxDQUFDejBDLENBQUMsQ0FBRyxDQUFMLEVBQVUsQ0FBWCxDQUFELENBQWlCeTBDLENBQUMsQ0FBQyxDQUFDejBDLENBQUMsQ0FBRyxDQUFMLEVBQVUsQ0FBWCxDQUExQixHQUNKLENBQUN5MEMsQ0FBQyxDQUFDLENBQUN6MEMsQ0FBQyxDQUFHLENBQUwsRUFBVSxDQUFYLENBQUgsQ0FBb0J5MEMsQ0FBQyxDQUFDLENBQUN6MEMsQ0FBQyxDQUFHLENBQUwsRUFBVSxDQUFYLENBRGhCLENBQVIsQ0FFQXdMLENBQUMsR0FDRixDQUNGLENBUEQsQ0FTQTs7OztPQUtBK29DLFNBQVMsQ0FBRyxtQkFBU0UsQ0FBVCxDQUFZLENBQ3RCLElBQUl6MEMsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxFQUFJLENBQWhCLENBQW1CQSxDQUFDLEVBQXBCLENBQXdCLENBQ3RCeTBDLENBQUMsQ0FBQ3owQyxDQUFELENBQUQsRUFBUXcwQyxDQUFDLENBQUNDLENBQUMsQ0FBQyxDQUFDejBDLENBQUMsQ0FBRyxDQUFMLEVBQVUsQ0FBWCxDQUFELENBQWlCLEVBQWxCLENBQVQsQ0FDRCxDQUNGLENBSkQsQ0FLRCxDQUVEOzs7Ozs7Ozs7Ozs7S0FhQSxHQUFJMDBDLFFBQU8sQ0FBRyxRQUFWQSxRQUFVLENBQVNDLElBQVQsQ0FBZSxDQUMzQixHQUFJRixFQUFDLENBQUcsRUFBUixDQUVBLCtEQUNBLElBQUl6MEMsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHLENBQWYsQ0FBa0JBLENBQUMsRUFBbkIsQ0FBdUIsQ0FDckIsR0FBSWlPLElBQUcsQ0FBR21oQixNQUFNLENBQUM3b0IsVUFBUCxFQUFWLENBRUEsR0FBR3lwQixHQUFHLEdBQUssSUFBWCxDQUFpQixDQUNmLEdBQUdoUixPQUFILENBQVksQ0FDViwyQ0FDQS9RLEdBQUcsRUFBSStoQixHQUFHLENBQUN6cEIsVUFBSixFQUFQLENBQ0QsQ0FIRCxJQUdPLENBQ0wsd0RBQ0F5cEIsR0FBRyxDQUFDdHFCLFVBQUosQ0FBZXVJLEdBQWYsRUFDRCxDQUNGLENBRUR3bUMsQ0FBQyxDQUFDL3hDLElBQUYsQ0FBT3VMLEdBQUcsQ0FBRyxNQUFiLEVBQ0QsQ0FFRCw0Q0FDQXpDLENBQUMsQ0FBR3dULE9BQU8sQ0FBRyxDQUFILENBQU8sRUFBbEIsQ0FFQSx5QkFDQSxJQUFJLEdBQUk0MUIsSUFBRyxDQUFHLENBQWQsQ0FBaUJBLEdBQUcsQ0FBR0QsSUFBSSxDQUFDbCtDLE1BQTVCLENBQW9DbStDLEdBQUcsRUFBdkMsQ0FBMkMsQ0FDekMsSUFBSSxHQUFJeHRCLElBQUcsQ0FBRyxDQUFkLENBQWlCQSxHQUFHLENBQUd1dEIsSUFBSSxDQUFDQyxHQUFELENBQUosQ0FBVSxDQUFWLENBQXZCLENBQXFDeHRCLEdBQUcsRUFBeEMsQ0FBNEMsQ0FDMUN1dEIsSUFBSSxDQUFDQyxHQUFELENBQUosQ0FBVSxDQUFWLEVBQWFILENBQWIsRUFDRCxDQUNGLENBRUQseUNBQ0EsSUFBSXowQyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUcsQ0FBZixDQUFrQkEsQ0FBQyxFQUFuQixDQUF1QixDQUNyQixHQUFHZ3dCLEdBQUcsR0FBSyxJQUFYLENBQWlCLENBQ2YsR0FBR2hSLE9BQUgsQ0FBWSxDQUNWOzREQUVBZ1IsR0FBRyxDQUFDdHFCLFVBQUosQ0FBZSt1QyxDQUFDLENBQUN6MEMsQ0FBRCxDQUFoQixFQUNELENBSkQsSUFJTyxDQUNMeTBDLENBQUMsQ0FBQ3owQyxDQUFELENBQUQsRUFBUWd3QixHQUFHLENBQUN6cEIsVUFBSixFQUFSLENBQ0QsQ0FDRixDQUVEOHRDLE9BQU8sQ0FBQzN1QyxVQUFSLENBQW1CK3VDLENBQUMsQ0FBQ3owQyxDQUFELENBQXBCLEVBQ0QsQ0FDRixDQTVDRCxDQThDQSwwQkFDQSxHQUFJMGIsT0FBTSxDQUFHLElBQWIsQ0FDQUEsTUFBTSxDQUFHLENBQ1A7Ozs7Ozs7OztPQVVBL1AsS0FBSyxDQUFFLGVBQVNxYSxFQUFULENBQWF6YixNQUFiLENBQXFCLENBQzFCLEdBQUd5YixFQUFILENBQU8sQ0FDTCxjQUNBLEdBQUcsTUFBT0EsR0FBUCxHQUFjLFFBQWpCLENBQTJCLENBQ3pCQSxFQUFFLENBQUdqb0IsS0FBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBWCxDQUF3QjZlLEVBQXhCLENBQUwsQ0FDRCxDQUNGLENBRURtSixPQUFPLENBQUcsS0FBVixDQUNBQyxNQUFNLENBQUdyeEIsS0FBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBWCxFQUFULENBQ0FrdEMsT0FBTyxDQUFHOXBDLE1BQU0sRUFBSSxHQUFJeE0sTUFBSyxDQUFDd0QsSUFBTixDQUFXNEYsWUFBZixFQUFwQixDQUNBNm9CLEdBQUcsQ0FBR2hLLEVBQU4sQ0FFQXRLLE1BQU0sQ0FBQ25SLE1BQVAsQ0FBZ0I4cEMsT0FBaEIsQ0FDRCxDQXpCTSxDQTJCUDs7OztPQUtBMWlDLE1BQU0sQ0FBRSxnQkFBU3JJLEtBQVQsQ0FBZ0IsQ0FDdEIsR0FBRyxDQUFDNmxCLE9BQUosQ0FBYSxDQUNYO0FBQ0FDLE1BQU0sQ0FBQ3JwQixTQUFQLENBQWlCdUQsS0FBakIsRUFDRCxDQUVELE1BQU04bEIsTUFBTSxDQUFDMzRCLE1BQVAsSUFBbUIsQ0FBekIsQ0FBNEIsQ0FDMUJpK0MsT0FBTyxDQUFDLENBQ0osQ0FBRSxDQUFGLENBQUtKLFFBQUwsQ0FESSxDQUVKLENBQUUsQ0FBRixDQUFLQyxTQUFMLENBRkksQ0FHSixDQUFFLENBQUYsQ0FBS0QsUUFBTCxDQUhJLENBSUosQ0FBRSxDQUFGLENBQUtDLFNBQUwsQ0FKSSxDQUtKLENBQUUsQ0FBRixDQUFLRCxRQUFMLENBTEksQ0FBRCxDQUFQLENBT0QsQ0FDRixDQS9DTSxDQWlEUDs7Ozs7OztPQVFBcHZCLE1BQU0sQ0FBRSxnQkFBU3FLLEdBQVQsQ0FBYyxDQUNwQixHQUFJbnBCLEtBQUksQ0FBRyxJQUFYLENBRUEsR0FBRzRZLE9BQUgsQ0FBWSxDQUNWLEdBQUd1USxHQUFILENBQVEsQ0FDTm5wQixJQUFJLENBQUdtcEIsR0FBRyxDQUFDLENBQUQsQ0FBSUgsTUFBSixDQUFZLENBQUNwUSxPQUFiLENBQVYsQ0FDRCxDQUZELElBRU8sQ0FDTDtBQUNBO0FBQ0EsR0FBSThRLFFBQU8sQ0FBSVYsTUFBTSxDQUFDMzRCLE1BQVAsS0FBb0IsQ0FBckIsQ0FBMEIsQ0FBMUIsQ0FBK0IsRUFBSTI0QixNQUFNLENBQUMzNEIsTUFBUCxFQUFqRCxDQUNBMjRCLE1BQU0sQ0FBQ2xxQixZQUFQLENBQW9CNHFCLE9BQXBCLENBQTZCQSxPQUE3QixFQUNELENBQ0YsQ0FFRCxHQUFHMXBCLElBQUgsQ0FBUyxDQUNQO0FBQ0Erb0IsT0FBTyxDQUFHLElBQVYsQ0FDQXpULE1BQU0sQ0FBQy9KLE1BQVAsR0FDRCxDQUVELEdBQUcsQ0FBQ3FOLE9BQUosQ0FBYSxDQUNYO0FBQ0E1WSxJQUFJLENBQUlncEIsTUFBTSxDQUFDMzRCLE1BQVAsS0FBb0IsQ0FBNUIsQ0FDQSxHQUFHMlAsSUFBSCxDQUFTLENBQ1AsR0FBR21wQixHQUFILENBQVEsQ0FDTm5wQixJQUFJLENBQUdtcEIsR0FBRyxDQUFDLENBQUQsQ0FBSThrQixPQUFKLENBQWEsQ0FBQ3IxQixPQUFkLENBQVYsQ0FDRCxDQUZELElBRU8sQ0FDTDtBQUNBLEdBQUkxWCxJQUFHLENBQUcrc0MsT0FBTyxDQUFDNTlDLE1BQVIsRUFBVixDQUNBLEdBQUlvUSxNQUFLLENBQUd3dEMsT0FBTyxDQUFDcnRDLEVBQVIsQ0FBV00sR0FBRyxDQUFHLENBQWpCLENBQVosQ0FFQSxHQUFHVCxLQUFLLENBQUdTLEdBQVgsQ0FBZ0IsQ0FDZGxCLElBQUksQ0FBRyxLQUFQLENBQ0QsQ0FGRCxJQUVPLENBQ0w7QUFDQWl1QyxPQUFPLENBQUNodEMsUUFBUixDQUFpQlIsS0FBakIsRUFDRCxDQUNGLENBQ0YsQ0FDRixDQUVELE1BQU9ULEtBQVAsQ0FDRCxDQW5HTSxDQUFULENBc0dBLE1BQU9zVixPQUFQLENBQ0QsQ0FuT0QsQ0FxT0E7Ozs7Ozs7Ozs7Ozs7R0FjQTNkLEtBQUssQ0FBQ2t2QixHQUFOLENBQVVsSCxlQUFWLENBQTRCLFNBQVMvdEIsR0FBVCxDQUFjZ3VCLEVBQWQsQ0FBa0J6YixNQUFsQixDQUEwQixDQUNwRCxHQUFJbVIsT0FBTSxDQUFHM2QsS0FBSyxDQUFDa3ZCLEdBQU4sQ0FBVTlHLHNCQUFWLENBQWlDbnVCLEdBQWpDLENBQXNDLEdBQXRDLENBQWIsQ0FDQTBqQixNQUFNLENBQUMvUCxLQUFQLENBQWFxYSxFQUFiLENBQWlCemIsTUFBakIsRUFDQSxNQUFPbVIsT0FBUCxDQUNELENBSkQsQ0FNQTs7Ozs7Ozs7Ozs7O0dBYUEzZCxLQUFLLENBQUNrdkIsR0FBTixDQUFVOUcsc0JBQVYsQ0FBbUMsU0FBU251QixHQUFULENBQWMybkIsSUFBZCxDQUFvQixDQUNyRCxNQUFPMkosYUFBWSxDQUFDdHhCLEdBQUQsQ0FBTTJuQixJQUFOLENBQVksSUFBWixDQUFuQixDQUNELENBRkQsQ0FJQTs7Ozs7Ozs7Ozs7OztHQWNBNWhCLEtBQUssQ0FBQ2t2QixHQUFOLENBQVU3RyxlQUFWLENBQTRCLFNBQVNwdUIsR0FBVCxDQUFjZ3VCLEVBQWQsQ0FBa0J6YixNQUFsQixDQUEwQixDQUNwRCxHQUFJbVIsT0FBTSxDQUFHM2QsS0FBSyxDQUFDa3ZCLEdBQU4sQ0FBVTVHLHNCQUFWLENBQWlDcnVCLEdBQWpDLENBQXNDLEdBQXRDLENBQWIsQ0FDQTBqQixNQUFNLENBQUMvUCxLQUFQLENBQWFxYSxFQUFiLENBQWlCemIsTUFBakIsRUFDQSxNQUFPbVIsT0FBUCxDQUNELENBSkQsQ0FNQTs7Ozs7Ozs7Ozs7O0dBYUEzZCxLQUFLLENBQUNrdkIsR0FBTixDQUFVNUcsc0JBQVYsQ0FBbUMsU0FBU3J1QixHQUFULENBQWMybkIsSUFBZCxDQUFvQixDQUNyRCxNQUFPMkosYUFBWSxDQUFDdHhCLEdBQUQsQ0FBTTJuQixJQUFOLENBQVksS0FBWixDQUFuQixDQUNELENBRkQsQ0FLQSxLQUFPLENBN3hpQkcsQ0E4eGlCVixRQTl4aUJVLENBK3hpQlYsS0FBTyxTQUFTbGdCLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkNBLEdBQUkvQixNQUFLLENBQUcrQixtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBRUE7QUFDQSxHQUFJNmlCLE1BQUssQ0FBR2xqQixNQUFNLENBQUNELE9BQVAsQ0FBaUJ6QixLQUFLLENBQUM0a0IsS0FBTixDQUFjNWtCLEtBQUssQ0FBQzRrQixLQUFOLEVBQWUsRUFBMUQsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkFBLEtBQUssQ0FBQ0MsZUFBTixDQUF3QixTQUFTNXFCLEdBQVQsQ0FBYzRCLE9BQWQsQ0FBdUIvRCxPQUF2QixDQUFnQyxDQUN0RDtBQUNBLEdBQUlnL0MsTUFBSixDQUNBLEdBQUlwNUIsS0FBSixDQUNBLEdBQUlULEdBQUosQ0FDQSxHQUFJODVCLE9BQUosQ0FDQTtBQUNBLEdBQUcsTUFBT2ovQyxRQUFQLEdBQW1CLFFBQXRCLENBQWdDLENBQzlCZy9DLEtBQUssQ0FBR2gvQyxPQUFSLENBQ0E0bEIsSUFBSSxDQUFHM1osU0FBUyxDQUFDLENBQUQsQ0FBVCxFQUFnQkQsU0FBdkIsQ0FDQW1aLEVBQUUsQ0FBR2xaLFNBQVMsQ0FBQyxDQUFELENBQVQsRUFBZ0JELFNBQXJCLENBQ0QsQ0FKRCxJQUlPLElBQUdoTSxPQUFILENBQVksQ0FDakJnL0MsS0FBSyxDQUFHaC9DLE9BQU8sQ0FBQ2cvQyxLQUFSLEVBQWlCaHpDLFNBQXpCLENBQ0E0WixJQUFJLENBQUc1bEIsT0FBTyxDQUFDNGxCLElBQVIsRUFBZ0I1WixTQUF2QixDQUNBbVosRUFBRSxDQUFHbmxCLE9BQU8sQ0FBQ21sQixFQUFSLEVBQWNuWixTQUFuQixDQUNBLEdBQUdoTSxPQUFPLENBQUNrL0MsSUFBUixFQUFnQmwvQyxPQUFPLENBQUNrL0MsSUFBUixDQUFhLzVCLEVBQWhDLENBQW9DLENBQ2xDODVCLE1BQU0sQ0FBR2ovQyxPQUFPLENBQUNrL0MsSUFBUixDQUFhLzVCLEVBQXRCLENBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBRyxDQUFDQSxFQUFKLENBQVEsQ0FDTkEsRUFBRSxDQUFHamQsS0FBSyxDQUFDaWQsRUFBTixDQUFTbVMsSUFBVCxDQUFjcHdCLE1BQWQsRUFBTCxDQUNELENBRkQsSUFFTyxDQUNMaWUsRUFBRSxDQUFDclAsS0FBSCxHQUNELENBRUQ7QUFDQSxHQUFHLENBQUNtcEMsTUFBSixDQUFZLENBQ1ZBLE1BQU0sQ0FBRzk1QixFQUFULENBQ0QsQ0FFRDtBQUNBLEdBQUlnNkIsVUFBUyxDQUFHajVDLElBQUksQ0FBQ3lNLElBQUwsQ0FBVXhRLEdBQUcsQ0FBQzJJLENBQUosQ0FBTTZkLFNBQU4sR0FBb0IsQ0FBOUIsQ0FBaEIsQ0FDQSxHQUFJeTJCLFVBQVMsQ0FBR0QsU0FBUyxDQUFHLEVBQUloNkIsRUFBRSxDQUFDcVMsWUFBbkIsQ0FBa0MsQ0FBbEQsQ0FDQSxHQUFHenpCLE9BQU8sQ0FBQ25ELE1BQVIsQ0FBaUJ3K0MsU0FBcEIsQ0FBK0IsQ0FDN0IsR0FBSS84QyxNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FBVSw4Q0FBVixDQUFaLENBQ0EyQixLQUFLLENBQUN6QixNQUFOLENBQWVtRCxPQUFPLENBQUNuRCxNQUF2QixDQUNBeUIsS0FBSyxDQUFDKzhDLFNBQU4sQ0FBa0JBLFNBQWxCLENBQ0EsS0FBTS84QyxNQUFOLENBQ0QsQ0FFRCxHQUFHLENBQUMyOEMsS0FBSixDQUFXLENBQ1RBLEtBQUssQ0FBRyxFQUFSLENBQ0QsQ0FDRDc1QixFQUFFLENBQUNySixNQUFILENBQVVrakMsS0FBVixDQUFpQixLQUFqQixFQUNBLEdBQUlLLE1BQUssQ0FBR2w2QixFQUFFLENBQUM0QyxNQUFILEVBQVosQ0FFQSxHQUFJdTNCLEdBQUUsQ0FBRyxFQUFULENBQ0EsR0FBSUMsVUFBUyxDQUFHSCxTQUFTLENBQUdyN0MsT0FBTyxDQUFDbkQsTUFBcEMsQ0FDQSxJQUFLLEdBQUl1SixFQUFDLENBQUcsQ0FBYixDQUFnQkEsQ0FBQyxDQUFHbzFDLFNBQXBCLENBQStCcDFDLENBQUMsRUFBaEMsQ0FBb0MsQ0FDbENtMUMsRUFBRSxFQUFJLE1BQU4sQ0FDRCxDQUVELEdBQUl4ZSxHQUFFLENBQUd1ZSxLQUFLLENBQUNsdkMsUUFBTixHQUFtQm12QyxFQUFuQixDQUF3QixNQUF4QixDQUFpQ3Y3QyxPQUExQyxDQUVBLEdBQUcsQ0FBQzZoQixJQUFKLENBQVUsQ0FDUkEsSUFBSSxDQUFHMWQsS0FBSyxDQUFDL0IsTUFBTixDQUFhZ0ssUUFBYixDQUFzQmdWLEVBQUUsQ0FBQ3FTLFlBQXpCLENBQVAsQ0FDRCxDQUZELElBRU8sSUFBRzVSLElBQUksQ0FBQ2hsQixNQUFMLEdBQWdCdWtCLEVBQUUsQ0FBQ3FTLFlBQXRCLENBQW9DLENBQ3pDLEdBQUluMUIsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsaURBQ3BCLDBCQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQ205QyxVQUFOLENBQW1CNTVCLElBQUksQ0FBQ2hsQixNQUF4QixDQUNBeUIsS0FBSyxDQUFDbTFCLFlBQU4sQ0FBcUJyUyxFQUFFLENBQUNxUyxZQUF4QixDQUNBLEtBQU1uMUIsTUFBTixDQUNELENBRUQsR0FBSXU0QyxPQUFNLENBQUc2RSxRQUFRLENBQUM3NUIsSUFBRCxDQUFPdTVCLFNBQVMsQ0FBR2g2QixFQUFFLENBQUNxUyxZQUFmLENBQThCLENBQXJDLENBQXdDeW5CLE1BQXhDLENBQXJCLENBQ0EsR0FBSXBFLFNBQVEsQ0FBRzN5QyxLQUFLLENBQUN3RCxJQUFOLENBQVdpSSxRQUFYLENBQW9CbXRCLEVBQXBCLENBQXdCOFosTUFBeEIsQ0FBZ0M5WixFQUFFLENBQUNsZ0MsTUFBbkMsQ0FBZixDQUVBLEdBQUk4K0MsU0FBUSxDQUFHRCxRQUFRLENBQUM1RSxRQUFELENBQVcxMUIsRUFBRSxDQUFDcVMsWUFBZCxDQUE0QnluQixNQUE1QixDQUF2QixDQUNBLEdBQUlVLFdBQVUsQ0FBR3ozQyxLQUFLLENBQUN3RCxJQUFOLENBQVdpSSxRQUFYLENBQW9CaVMsSUFBcEIsQ0FBMEI4NUIsUUFBMUIsQ0FBb0M5NUIsSUFBSSxDQUFDaGxCLE1BQXpDLENBQWpCLENBRUE7QUFDQSxNQUFPLE9BQVMrK0MsVUFBVCxDQUFzQjlFLFFBQTdCLENBQ0QsQ0ExRUQsQ0E0RUE7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkEvdEIsS0FBSyxDQUFDSyxlQUFOLENBQXdCLFNBQVNockIsR0FBVCxDQUFjNHNCLEVBQWQsQ0FBa0IvdUIsT0FBbEIsQ0FBMkIsQ0FDakQ7QUFDQSxHQUFJZy9DLE1BQUosQ0FDQSxHQUFJNzVCLEdBQUosQ0FDQSxHQUFJODVCLE9BQUosQ0FDQTtBQUNBLEdBQUcsTUFBT2ovQyxRQUFQLEdBQW1CLFFBQXRCLENBQWdDLENBQzlCZy9DLEtBQUssQ0FBR2gvQyxPQUFSLENBQ0FtbEIsRUFBRSxDQUFHbFosU0FBUyxDQUFDLENBQUQsQ0FBVCxFQUFnQkQsU0FBckIsQ0FDRCxDQUhELElBR08sSUFBR2hNLE9BQUgsQ0FBWSxDQUNqQmcvQyxLQUFLLENBQUdoL0MsT0FBTyxDQUFDZy9DLEtBQVIsRUFBaUJoekMsU0FBekIsQ0FDQW1aLEVBQUUsQ0FBR25sQixPQUFPLENBQUNtbEIsRUFBUixFQUFjblosU0FBbkIsQ0FDQSxHQUFHaE0sT0FBTyxDQUFDay9DLElBQVIsRUFBZ0JsL0MsT0FBTyxDQUFDay9DLElBQVIsQ0FBYS81QixFQUFoQyxDQUFvQyxDQUNsQzg1QixNQUFNLENBQUdqL0MsT0FBTyxDQUFDay9DLElBQVIsQ0FBYS81QixFQUF0QixDQUNELENBQ0YsQ0FFRDtBQUNBLEdBQUlnNkIsVUFBUyxDQUFHajVDLElBQUksQ0FBQ3lNLElBQUwsQ0FBVXhRLEdBQUcsQ0FBQzJJLENBQUosQ0FBTTZkLFNBQU4sR0FBb0IsQ0FBOUIsQ0FBaEIsQ0FFQSxHQUFHb0csRUFBRSxDQUFDbnVCLE1BQUgsR0FBY3UrQyxTQUFqQixDQUE0QixDQUMxQixHQUFJOThDLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLCtDQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQ3pCLE1BQU4sQ0FBZW11QixFQUFFLENBQUNudUIsTUFBbEIsQ0FDQXlCLEtBQUssQ0FBQ3U5QyxjQUFOLENBQXVCVCxTQUF2QixDQUNBLEtBQU05OEMsTUFBTixDQUNELENBRUQ7QUFDQSxHQUFHOGlCLEVBQUUsR0FBS25aLFNBQVYsQ0FBcUIsQ0FDbkJtWixFQUFFLENBQUdqZCxLQUFLLENBQUNpZCxFQUFOLENBQVNtUyxJQUFULENBQWNwd0IsTUFBZCxFQUFMLENBQ0QsQ0FGRCxJQUVPLENBQ0xpZSxFQUFFLENBQUNyUCxLQUFILEdBQ0QsQ0FFRDtBQUNBLEdBQUcsQ0FBQ21wQyxNQUFKLENBQVksQ0FDVkEsTUFBTSxDQUFHOTVCLEVBQVQsQ0FDRCxDQUVELEdBQUdnNkIsU0FBUyxDQUFHLEVBQUloNkIsRUFBRSxDQUFDcVMsWUFBUCxDQUFzQixDQUFyQyxDQUF3QyxDQUN0QyxLQUFNLElBQUk5MkIsTUFBSixDQUFVLG9EQUFWLENBQU4sQ0FDRCxDQUVELEdBQUcsQ0FBQ3MrQyxLQUFKLENBQVcsQ0FDVEEsS0FBSyxDQUFHLEVBQVIsQ0FDRCxDQUNENzVCLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVWtqQyxLQUFWLENBQWlCLEtBQWpCLEVBQ0EsR0FBSUssTUFBSyxDQUFHbDZCLEVBQUUsQ0FBQzRDLE1BQUgsR0FBWTVYLFFBQVosRUFBWixDQUVBO0FBQ0EsR0FBSStZLEVBQUMsQ0FBRzZGLEVBQUUsQ0FBQ2phLE1BQUgsQ0FBVSxDQUFWLENBQVIsQ0FDQSxHQUFJNnFDLFdBQVUsQ0FBRzV3QixFQUFFLENBQUMvWSxTQUFILENBQWEsQ0FBYixDQUFnQm1QLEVBQUUsQ0FBQ3FTLFlBQUgsQ0FBa0IsQ0FBbEMsQ0FBakIsQ0FDQSxHQUFJcWpCLFNBQVEsQ0FBRzlyQixFQUFFLENBQUMvWSxTQUFILENBQWEsRUFBSW1QLEVBQUUsQ0FBQ3FTLFlBQXBCLENBQWYsQ0FFQSxHQUFJa29CLFNBQVEsQ0FBR0QsUUFBUSxDQUFDNUUsUUFBRCxDQUFXMTFCLEVBQUUsQ0FBQ3FTLFlBQWQsQ0FBNEJ5bkIsTUFBNUIsQ0FBdkIsQ0FDQSxHQUFJcjVCLEtBQUksQ0FBRzFkLEtBQUssQ0FBQ3dELElBQU4sQ0FBV2lJLFFBQVgsQ0FBb0Jnc0MsVUFBcEIsQ0FBZ0NELFFBQWhDLENBQTBDQyxVQUFVLENBQUMvK0MsTUFBckQsQ0FBWCxDQUVBLEdBQUlnNkMsT0FBTSxDQUFHNkUsUUFBUSxDQUFDNzVCLElBQUQsQ0FBT3U1QixTQUFTLENBQUdoNkIsRUFBRSxDQUFDcVMsWUFBZixDQUE4QixDQUFyQyxDQUF3Q3luQixNQUF4QyxDQUFyQixDQUNBLEdBQUl2RSxHQUFFLENBQUd4eUMsS0FBSyxDQUFDd0QsSUFBTixDQUFXaUksUUFBWCxDQUFvQmtuQyxRQUFwQixDQUE4QkQsTUFBOUIsQ0FBc0NDLFFBQVEsQ0FBQ2o2QyxNQUEvQyxDQUFULENBRUEsR0FBSWkvQyxXQUFVLENBQUduRixFQUFFLENBQUMxa0MsU0FBSCxDQUFhLENBQWIsQ0FBZ0JtUCxFQUFFLENBQUNxUyxZQUFuQixDQUFqQixDQUVBO0FBQ0EsR0FBSW4xQixNQUFLLENBQUk2bUIsQ0FBQyxHQUFLLE1BQW5CLENBRUE7QUFDQSxJQUFJLEdBQUkvZSxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdnYixFQUFFLENBQUNxUyxZQUF0QixDQUFvQyxFQUFFcnRCLENBQXRDLENBQXlDLENBQ3ZDOUgsS0FBSyxFQUFLZzlDLEtBQUssQ0FBQ3ZxQyxNQUFOLENBQWEzSyxDQUFiLElBQW9CMDFDLFVBQVUsQ0FBQy9xQyxNQUFYLENBQWtCM0ssQ0FBbEIsQ0FBOUIsQ0FDRCxDQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUkyMUMsTUFBSyxDQUFHLENBQVosQ0FDQSxHQUFJQyxNQUFLLENBQUc1NkIsRUFBRSxDQUFDcVMsWUFBZixDQUNBLElBQUksR0FBSTdoQixFQUFDLENBQUd3UCxFQUFFLENBQUNxUyxZQUFmLENBQTZCN2hCLENBQUMsQ0FBRytrQyxFQUFFLENBQUM5NUMsTUFBcEMsQ0FBNEMrVSxDQUFDLEVBQTdDLENBQWlELENBQy9DLEdBQUl5RSxLQUFJLENBQUdzZ0MsRUFBRSxDQUFDcnFDLFVBQUgsQ0FBY3NGLENBQWQsQ0FBWCxDQUVBLEdBQUlxcUMsS0FBSSxDQUFJNWxDLElBQUksQ0FBRyxHQUFSLENBQWUsR0FBMUIsQ0FFQTtBQUNBLEdBQUk2bEMsV0FBVSxDQUFHSCxLQUFLLENBQUcsTUFBSCxDQUFZLE1BQWxDLENBQ0F6OUMsS0FBSyxFQUFLK1gsSUFBSSxDQUFHNmxDLFVBQWpCLENBRUE7QUFDQUgsS0FBSyxDQUFHQSxLQUFLLENBQUdFLElBQWhCLENBQ0FELEtBQUssRUFBSUQsS0FBVCxDQUNELENBRUQsR0FBR3o5QyxLQUFLLEVBQUlxNEMsRUFBRSxDQUFDcnFDLFVBQUgsQ0FBYzB2QyxLQUFkLElBQXlCLEdBQXJDLENBQTBDLENBQ3hDLEtBQU0sSUFBSXIvQyxNQUFKLENBQVUsNkJBQVYsQ0FBTixDQUNELENBRUQsTUFBT2c2QyxHQUFFLENBQUMxa0MsU0FBSCxDQUFhK3BDLEtBQUssQ0FBRyxDQUFyQixDQUFQLENBQ0QsQ0E5RkQsQ0FnR0EsUUFBU04sU0FBVCxDQUFrQjc1QixJQUFsQixDQUF3QnM2QixVQUF4QixDQUFvQzE1QyxJQUFwQyxDQUEwQyxDQUN4QztBQUNBLEdBQUcsQ0FBQ0EsSUFBSixDQUFVLENBQ1JBLElBQUksQ0FBRzBCLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU21TLElBQVQsQ0FBY3B3QixNQUFkLEVBQVAsQ0FDRCxDQUNELEdBQUk2TSxFQUFDLENBQUcsRUFBUixDQUNBLEdBQUkvQyxNQUFLLENBQUc5SyxJQUFJLENBQUN5TSxJQUFMLENBQVV1dEMsVUFBVSxDQUFHMTVDLElBQUksQ0FBQ2d4QixZQUE1QixDQUFaLENBQ0EsSUFBSSxHQUFJcnRCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzZHLEtBQW5CLENBQTBCLEVBQUU3RyxDQUE1QixDQUErQixDQUM3QixHQUFJSSxFQUFDLENBQUdxRSxNQUFNLENBQUNDLFlBQVAsQ0FDTDFFLENBQUMsRUFBSSxFQUFOLENBQVksSUFETixDQUNhQSxDQUFDLEVBQUksRUFBTixDQUFZLElBRHhCLENBQytCQSxDQUFDLEVBQUksQ0FBTixDQUFXLElBRHpDLENBQytDQSxDQUFDLENBQUcsSUFEbkQsQ0FBUixDQUVBM0QsSUFBSSxDQUFDc1AsS0FBTCxHQUNBdFAsSUFBSSxDQUFDc1YsTUFBTCxDQUFZOEosSUFBSSxDQUFHcmIsQ0FBbkIsRUFDQXdKLENBQUMsRUFBSXZOLElBQUksQ0FBQ3VoQixNQUFMLEdBQWM1WCxRQUFkLEVBQUwsQ0FDRCxDQUNELE1BQU80RCxFQUFDLENBQUNpQyxTQUFGLENBQVksQ0FBWixDQUFla3FDLFVBQWYsQ0FBUCxDQUNELENBR0QsS0FBTyxDQXZqakJHLENBd2pqQlYsUUF4ampCVSxDQXlqakJWLEtBQU8sU0FBU3QyQyxNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7R0FPQSxHQUFJL0IsTUFBSyxDQUFHK0IsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUVBLENBQUMsVUFBVyxDQUVaO0FBQ0EsR0FBRy9CLEtBQUssQ0FBQ29uQixLQUFULENBQWdCLENBQ2QxbEIsTUFBTSxDQUFDRCxPQUFQLENBQWlCekIsS0FBSyxDQUFDb25CLEtBQXZCLENBQ0EsT0FDRCxDQUVELGVBQ0EsR0FBSUEsTUFBSyxDQUFHMWxCLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQnpCLEtBQUssQ0FBQ29uQixLQUFOLENBQWNwbkIsS0FBSyxDQUFDb25CLEtBQU4sRUFBZSxFQUExRCxDQUVBLEdBQUluSSxXQUFVLENBQUdqZixLQUFLLENBQUNrZixJQUFOLENBQVdELFVBQTVCLENBRUE7QUFDQSxHQUFJRSxhQUFZLENBQUcsQ0FBQyxDQUFELENBQUksQ0FBSixDQUFPLENBQVAsQ0FBVSxDQUFWLENBQWEsQ0FBYixDQUFnQixDQUFoQixDQUFtQixDQUFuQixDQUFzQixDQUF0QixDQUFuQixDQUNBLEdBQUltRCxPQUFNLENBQUcsR0FBSXJELFdBQUosQ0FBZSxJQUFmLENBQWIsQ0FDQXFELE1BQU0sQ0FBQ0YsT0FBUCxDQUFlLEVBQWYsRUFDQSxHQUFJSSxNQUFLLENBQUcsUUFBUkEsTUFBUSxDQUFTNWMsQ0FBVCxDQUFZb2IsQ0FBWixDQUFlLENBQUMsTUFBT3BiLEVBQUMsQ0FBQ29iLENBQVQsQ0FBWSxDQUF4QyxDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJBb0csS0FBSyxDQUFDQyxxQkFBTixDQUE4QixTQUFTekYsSUFBVCxDQUFlOXBCLE9BQWYsQ0FBd0JrTSxRQUF4QixDQUFrQyxDQUM5RCxHQUFHLE1BQU9sTSxRQUFQLEdBQW1CLFVBQXRCLENBQWtDLENBQ2hDa00sUUFBUSxDQUFHbE0sT0FBWCxDQUNBQSxPQUFPLENBQUcsRUFBVixDQUNELENBQ0RBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBRUE7QUFDQSxHQUFJMm5CLFVBQVMsQ0FBRzNuQixPQUFPLENBQUMybkIsU0FBUixFQUFxQixVQUFyQyxDQUNBLEdBQUcsTUFBT0EsVUFBUCxHQUFxQixRQUF4QixDQUFrQyxDQUNoQ0EsU0FBUyxDQUFHLENBQUNsb0IsSUFBSSxDQUFFa29CLFNBQVAsQ0FBWixDQUNELENBQ0RBLFNBQVMsQ0FBQzNuQixPQUFWLENBQW9CMm5CLFNBQVMsQ0FBQzNuQixPQUFWLEVBQXFCLEVBQXpDLENBRUE7QUFDQSxHQUFJbW1CLEtBQUksQ0FBR25tQixPQUFPLENBQUNtbUIsSUFBUixFQUFnQmplLEtBQUssQ0FBQy9CLE1BQWpDLENBQ0EsR0FBSTRqQixJQUFHLENBQUcsQ0FDUjtBQUNBQyxTQUFTLENBQUUsbUJBQVNsYyxDQUFULENBQVksQ0FDckIsR0FBSVMsRUFBQyxDQUFHNFgsSUFBSSxDQUFDQyxZQUFMLENBQWtCdFksQ0FBQyxDQUFDbE4sTUFBcEIsQ0FBUixDQUNBLElBQUksR0FBSXVKLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzJELENBQUMsQ0FBQ2xOLE1BQXJCLENBQTZCLEVBQUV1SixDQUEvQixDQUFrQyxDQUNoQzJELENBQUMsQ0FBQzNELENBQUQsQ0FBRCxDQUFPb0UsQ0FBQyxDQUFDOEIsVUFBRixDQUFhbEcsQ0FBYixDQUFQLENBQ0QsQ0FDRixDQVBPLENBQVYsQ0FVQSxHQUFHd2QsU0FBUyxDQUFDbG9CLElBQVYsR0FBbUIsVUFBdEIsQ0FBa0MsQ0FDaEMsTUFBTzBnRCxrQkFBaUIsQ0FBQ3IyQixJQUFELENBQU9DLEdBQVAsQ0FBWXBDLFNBQVMsQ0FBQzNuQixPQUF0QixDQUErQmtNLFFBQS9CLENBQXhCLENBQ0QsQ0FFRCxLQUFNLElBQUl4TCxNQUFKLENBQVUsdUNBQXlDaW5CLFNBQVMsQ0FBQ2xvQixJQUE3RCxDQUFOLENBQ0QsQ0EvQkQsQ0FpQ0EsUUFBUzBnRCxrQkFBVCxDQUEyQnIyQixJQUEzQixDQUFpQ0MsR0FBakMsQ0FBc0MvcEIsT0FBdEMsQ0FBK0NrTSxRQUEvQyxDQUF5RCxDQUN2RCxHQUFHLFdBQWFsTSxRQUFoQixDQUF5QixDQUN2QixNQUFPb2dELDZCQUE0QixDQUFDdDJCLElBQUQsQ0FBT0MsR0FBUCxDQUFZL3BCLE9BQVosQ0FBcUJrTSxRQUFyQixDQUFuQyxDQUNELENBQ0QsTUFBT20wQyxnQ0FBK0IsQ0FBQ3YyQixJQUFELENBQU9DLEdBQVAsQ0FBWS9wQixPQUFaLENBQXFCa00sUUFBckIsQ0FBdEMsQ0FDRCxDQUVELFFBQVNtMEMsZ0NBQVQsQ0FBeUN2MkIsSUFBekMsQ0FBK0NDLEdBQS9DLENBQW9EL3BCLE9BQXBELENBQTZEa00sUUFBN0QsQ0FBdUUsQ0FDckU7QUFDQSxHQUFJK08sSUFBRyxDQUFHcWxDLGNBQWMsQ0FBQ3gyQixJQUFELENBQU9DLEdBQVAsQ0FBeEIsQ0FFQTs7OzZCQUlBLEdBQUlVLFNBQVEsQ0FBRyxDQUFmLENBRUE7QUFDQSxHQUFJODFCLFFBQU8sQ0FBR0MsbUJBQW1CLENBQUN2bEMsR0FBRyxDQUFDME4sU0FBSixFQUFELENBQWpDLENBQ0EsR0FBRyxvQkFBc0Izb0IsUUFBekIsQ0FBa0MsQ0FDaEN1Z0QsT0FBTyxDQUFHdmdELE9BQU8sQ0FBQ3lnRCxnQkFBbEIsQ0FDRCxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBSUMsYUFBWSxDQUFHLEVBQW5CLENBQ0EsR0FBRyxnQkFBa0IxZ0QsUUFBckIsQ0FBOEIsQ0FDNUIwZ0QsWUFBWSxDQUFHMWdELE9BQU8sQ0FBQzBnRCxZQUF2QixDQUNELENBRURDLFNBQVMsQ0FBQzFsQyxHQUFELENBQU02TyxJQUFOLENBQVlDLEdBQVosQ0FBaUJVLFFBQWpCLENBQTJCODFCLE9BQTNCLENBQW9DRyxZQUFwQyxDQUFrRHgwQyxRQUFsRCxDQUFULENBQ0QsQ0FFRCxRQUFTeTBDLFVBQVQsQ0FBbUIxbEMsR0FBbkIsQ0FBd0I2TyxJQUF4QixDQUE4QkMsR0FBOUIsQ0FBbUNVLFFBQW5DLENBQTZDODFCLE9BQTdDLENBQXNERyxZQUF0RCxDQUFvRXgwQyxRQUFwRSxDQUE4RSxDQUM1RSxHQUFJNEosTUFBSyxDQUFHLENBQUMsR0FBSTdJLEtBQUosRUFBYixDQUNBLEVBQUcsQ0FDRDtBQUNBLEdBQUdnTyxHQUFHLENBQUMwTixTQUFKLEdBQWtCbUIsSUFBckIsQ0FBMkIsQ0FDekI3TyxHQUFHLENBQUdxbEMsY0FBYyxDQUFDeDJCLElBQUQsQ0FBT0MsR0FBUCxDQUFwQixDQUNELENBQ0Q7QUFDQSxHQUFHOU8sR0FBRyxDQUFDbVEsZUFBSixDQUFvQm0xQixPQUFwQixDQUFILENBQWlDLENBQy9CLE1BQU9yMEMsU0FBUSxDQUFDLElBQUQsQ0FBTytPLEdBQVAsQ0FBZixDQUNELENBQ0Q7QUFDQUEsR0FBRyxDQUFDaVEsVUFBSixDQUFlN0QsWUFBWSxDQUFDb0QsUUFBUSxHQUFLLENBQWQsQ0FBM0IsQ0FBNkMsQ0FBN0MsRUFDRCxDQVhELE1BV1FpMkIsWUFBWSxDQUFHLENBQWYsRUFBcUIsQ0FBQyxHQUFJenpDLEtBQUosRUFBRCxDQUFjNkksS0FBZCxDQUFzQjRxQyxZQVhuRCxFQWFBO0FBQ0F4NEMsS0FBSyxDQUFDd0QsSUFBTixDQUFXSSxZQUFYLENBQXdCLFVBQVcsQ0FDakM2MEMsU0FBUyxDQUFDMWxDLEdBQUQsQ0FBTTZPLElBQU4sQ0FBWUMsR0FBWixDQUFpQlUsUUFBakIsQ0FBMkI4MUIsT0FBM0IsQ0FBb0NHLFlBQXBDLENBQWtEeDBDLFFBQWxELENBQVQsQ0FDRCxDQUZELEVBR0QsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVNrMEMsNkJBQVQsQ0FBc0N0MkIsSUFBdEMsQ0FBNENDLEdBQTVDLENBQWlEL3BCLE9BQWpELENBQTBEa00sUUFBMUQsQ0FBb0UsQ0FDbEU7QUFDQSxHQUFHLE1BQU9nUSxPQUFQLEdBQWtCLFdBQXJCLENBQWtDLENBQ2hDLE1BQU9ta0MsZ0NBQStCLENBQUN2MkIsSUFBRCxDQUFPQyxHQUFQLENBQVkvcEIsT0FBWixDQUFxQmtNLFFBQXJCLENBQXRDLENBQ0QsQ0FFRDtBQUNBLEdBQUkrTyxJQUFHLENBQUdxbEMsY0FBYyxDQUFDeDJCLElBQUQsQ0FBT0MsR0FBUCxDQUF4QixDQUVBO0FBQ0EsR0FBSXBOLFdBQVUsQ0FBRzNjLE9BQU8sQ0FBQ2lkLE9BQXpCLENBQ0EsR0FBSWtTLFNBQVEsQ0FBR252QixPQUFPLENBQUNtdkIsUUFBUixFQUFvQixHQUFuQyxDQUNBLEdBQUl5eEIsTUFBSyxDQUFHenhCLFFBQVEsQ0FBRyxFQUFYLENBQWdCLENBQTVCLENBQ0EsR0FBSTNtQixhQUFZLENBQUd4SSxPQUFPLENBQUN3SSxZQUFSLEVBQXdCLHVCQUEzQyxDQUNBLEdBQUdtVSxVQUFVLEdBQUssQ0FBQyxDQUFuQixDQUFzQixDQUNwQixNQUFPelUsTUFBSyxDQUFDd0QsSUFBTixDQUFXbVEsYUFBWCxDQUF5QixTQUFTa0IsR0FBVCxDQUFjaEIsS0FBZCxDQUFxQixDQUNuRCxHQUFHZ0IsR0FBSCxDQUFRLENBQ047QUFDQWhCLEtBQUssQ0FBRyxDQUFSLENBQ0QsQ0FDRFksVUFBVSxDQUFHWixLQUFLLENBQUcsQ0FBckIsQ0FDQTNULFFBQVEsR0FDVCxDQVBNLENBQVAsQ0FRRCxDQUNEQSxRQUFRLEdBRVIsUUFBU0EsU0FBVCxFQUFvQixDQUNsQjtBQUNBdVUsVUFBVSxDQUFHelcsSUFBSSxDQUFDNkssR0FBTCxDQUFTLENBQVQsQ0FBWTRMLFVBQVosQ0FBYixDQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EsR0FBSU0sUUFBTyxDQUFHLEVBQWQsQ0FDQSxJQUFJLEdBQUk5UyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUd3UyxVQUFuQixDQUErQixFQUFFeFMsQ0FBakMsQ0FBb0MsQ0FDbEM7QUFDQThTLE9BQU8sQ0FBQzlTLENBQUQsQ0FBUCxDQUFhLEdBQUkrUixPQUFKLENBQVcxVCxZQUFYLENBQWIsQ0FDRCxDQUNELEdBQUlxNEMsUUFBTyxDQUFHbGtDLFVBQWQsQ0FFQTtBQUNBLElBQUksR0FBSXhTLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3dTLFVBQW5CLENBQStCLEVBQUV4UyxDQUFqQyxDQUFvQyxDQUNsQzhTLE9BQU8sQ0FBQzlTLENBQUQsQ0FBUCxDQUFXMkMsZ0JBQVgsQ0FBNEIsU0FBNUIsQ0FBdUNnMEMsYUFBdkMsRUFDRCxDQUVEOzs7Ozs7Ozs7Ozs7eURBY0EsR0FBSUMsTUFBSyxDQUFHLEtBQVosQ0FDQSxRQUFTRCxjQUFULENBQXVCaHlDLENBQXZCLENBQTBCLENBQ3hCO0FBQ0EsR0FBR2l5QyxLQUFILENBQVUsQ0FDUixPQUNELENBRUQsRUFBRUYsT0FBRixDQUNBLEdBQUk3K0MsS0FBSSxDQUFHOE0sQ0FBQyxDQUFDOU0sSUFBYixDQUNBLEdBQUdBLElBQUksQ0FBQysrQyxLQUFSLENBQWUsQ0FDYjtBQUNBLElBQUksR0FBSTUyQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUc4UyxPQUFPLENBQUNyYyxNQUEzQixDQUFtQyxFQUFFdUosQ0FBckMsQ0FBd0MsQ0FDdEM4UyxPQUFPLENBQUM5UyxDQUFELENBQVAsQ0FBV2dULFNBQVgsR0FDRCxDQUNENGpDLEtBQUssQ0FBRyxJQUFSLENBQ0EsTUFBTzcwQyxTQUFRLENBQUMsSUFBRCxDQUFPLEdBQUlpYixXQUFKLENBQWVubEIsSUFBSSxDQUFDc3RCLEtBQXBCLENBQTJCLEVBQTNCLENBQVAsQ0FBZixDQUNELENBRUQ7QUFDQSxHQUFHclUsR0FBRyxDQUFDME4sU0FBSixHQUFrQm1CLElBQXJCLENBQTJCLENBQ3pCN08sR0FBRyxDQUFHcWxDLGNBQWMsQ0FBQ3gyQixJQUFELENBQU9DLEdBQVAsQ0FBcEIsQ0FDRCxDQUVEO0FBQ0EsR0FBSWxYLElBQUcsQ0FBR29JLEdBQUcsQ0FBQzVaLFFBQUosQ0FBYSxFQUFiLENBQVYsQ0FFQTtBQUNBeU4sQ0FBQyxDQUFDMGQsTUFBRixDQUFTeGxCLFdBQVQsQ0FBcUIsQ0FDbkI2TCxHQUFHLENBQUVBLEdBRGMsQ0FFbkJzYyxRQUFRLENBQUVBLFFBRlMsQ0FBckIsRUFLQWxVLEdBQUcsQ0FBQ2lRLFVBQUosQ0FBZTAxQixLQUFmLENBQXNCLENBQXRCLEVBQ0QsQ0FDRixDQUNGLENBRUQ7Ozs7Ozs7R0FRQSxRQUFTTixlQUFULENBQXdCeDJCLElBQXhCLENBQThCQyxHQUE5QixDQUFtQyxDQUNqQyxHQUFJOU8sSUFBRyxDQUFHLEdBQUlrTSxXQUFKLENBQWUyQyxJQUFmLENBQXFCQyxHQUFyQixDQUFWLENBQ0E7QUFDQSxHQUFJZSxNQUFLLENBQUdoQixJQUFJLENBQUcsQ0FBbkIsQ0FDQSxHQUFHLENBQUM3TyxHQUFHLENBQUM4UCxPQUFKLENBQVlELEtBQVosQ0FBSixDQUF3QixDQUN0QjdQLEdBQUcsQ0FBQytQLFNBQUosQ0FBYzdELFVBQVUsQ0FBQ21CLEdBQVgsQ0FBZTJDLFNBQWYsQ0FBeUJILEtBQXpCLENBQWQsQ0FBK0NKLEtBQS9DLENBQXNEelAsR0FBdEQsRUFDRCxDQUNEO0FBQ0FBLEdBQUcsQ0FBQ2lRLFVBQUosQ0FBZSxHQUFLalEsR0FBRyxDQUFDbU4sR0FBSixDQUFRb0MsTUFBUixFQUFnQlcsU0FBaEIsRUFBcEIsQ0FBaUQsQ0FBakQsRUFDQSxNQUFPbFEsSUFBUCxDQUNELENBRUQ7Ozs7Ozs7OztHQVVBLFFBQVN1bEMsb0JBQVQsQ0FBNkIxMkIsSUFBN0IsQ0FBbUMsQ0FDakMsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxHQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxHQUFYLENBQWdCLE1BQU8sR0FBUCxDQUNoQixHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEdBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxHQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxHQUFYLENBQWdCLE1BQU8sRUFBUCxDQUNoQixHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEVBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxFQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxHQUFYLENBQWdCLE1BQU8sRUFBUCxDQUNoQixHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEVBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxFQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxJQUFYLENBQWlCLE1BQU8sRUFBUCxDQUNqQixNQUFPLEVBQVAsQ0FDRCxDQUVBLENBNVJELElBK1JBLEtBQU8sQ0F0MmpCRyxDQXUyakJWLFFBdjJqQlUsQ0F3MmpCVixLQUFPLFNBQVNsZ0IsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQStGQSxHQUFJL0IsTUFBSyxDQUFHK0IsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBRUE7QUFDQSxHQUFJdVQsS0FBSSxDQUFHdFYsS0FBSyxDQUFDc1YsSUFBakIsQ0FDQSxHQUFJN1UsSUFBRyxDQUFHVCxLQUFLLENBQUNTLEdBQWhCLENBRUE7QUFDQSxHQUFJcTRDLElBQUcsQ0FBR3AzQyxNQUFNLENBQUNELE9BQVAsQ0FBaUJ6QixLQUFLLENBQUMrNEMsTUFBTixDQUFlLzRDLEtBQUssQ0FBQys0QyxNQUFOLEVBQWdCLEVBQTFELENBRUEsR0FBSUMscUJBQW9CLENBQUcsQ0FDekJ6aEQsSUFBSSxDQUFFLGFBRG1CLENBRXpCMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRkksQ0FHekI3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIUyxDQUdFO0FBQzNCUSxXQUFXLENBQUUsSUFKWSxDQUt6QjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUseUJBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxhQUxILENBQUQsQ0FNSixDQUNEemtCLElBQUksQ0FBRSxxQkFETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUZwQixDQUdEeUIsV0FBVyxDQUFFLElBSFosQ0FJRCtFLFdBQVcsQ0FBRSxTQUpaLENBTkksQ0FMa0IsQ0FBM0IsQ0FtQkEsR0FBSSs4QixhQUFZLENBQUcsQ0FDakIxaEQsSUFBSSxDQUFFLEtBRFcsQ0FFakIyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGSixDQUdqQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhDLENBSWpCUSxXQUFXLENBQUUsSUFKSSxDQUtqQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsYUFEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUhWLENBSU5vQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLFNBTEgsQ0FBRCxDQU9QZzlCLG9CQVBPLENBT2UsQ0FDcEJ6aEQsSUFBSSxDQUFFLGFBRGMsQ0FFcEIyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGRCxDQUdwQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhJLENBSXBCUSxXQUFXLENBQUUsSUFKTyxDQUtwQjhFLFFBQVEsQ0FBRSxJQUxVLENBTXBCQyxXQUFXLENBQUUsS0FOTyxDQU9wQjFLLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsaUJBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIVixDQUdxQjtBQUMzQlEsV0FBVyxDQUFFLElBSlAsQ0FLTjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsaUNBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIVixDQUdxQjtBQUMzQlEsV0FBVyxDQUFFLElBSlAsQ0FLTjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsMkNBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxjQUxILENBQUQsQ0FNSixDQUNEemtCLElBQUksQ0FBRSw0Q0FETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0QwRyxXQUFXLENBQUUsd0JBSFosQ0FOSSxDQUxELENBQUQsQ0FnQkosQ0FDRDNrQixJQUFJLENBQUUsd0JBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBSGYsQ0FJRGtCLFdBQVcsQ0FBRSxLQUpaLENBS0Q2RSxPQUFPLENBQUUsV0FMUixDQWhCSSxDQUxELENBQUQsQ0E0QkosQ0FDRHprQixJQUFJLENBQUUscUJBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBSGYsQ0FJRGtCLFdBQVcsQ0FBRSxLQUpaLENBS0Q2RSxPQUFPLENBQUUsU0FMUixDQTVCSSxDQWtDSixDQUNEemtCLElBQUksQ0FBRSx3QkFETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIZixDQUlEb0IsV0FBVyxDQUFFLEtBSlosQ0FLRDhFLFFBQVEsQ0FBRSxJQUxULENBTURELE9BQU8sQ0FBRSxlQU5SLENBbENJLENBUGEsQ0FQZixDQUxVLENBQW5CLENBZ0VBLEdBQUlrOUIsaUJBQWdCLENBQUcsQ0FDckIzaEQsSUFBSSxDQUFFLFNBRGUsQ0FFckIyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGQSxDQUdyQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhLLENBSXJCUSxXQUFXLENBQUUsSUFKUSxDQUtyQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsZUFEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLE9BTEgsQ0FBRCxDQU1KLENBQ0R6a0IsSUFBSSxDQUFFLGtCQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRnBCLENBR0R5QixXQUFXLENBQUUsSUFIWixDQUlEK0UsV0FBVyxDQUFFLFVBSlosQ0FOSSxDQVdKLENBQ0Qza0IsSUFBSSxDQUFFLHVCQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FIZixDQUlETyxXQUFXLENBQUUsSUFKWixDQUtEOEUsUUFBUSxDQUFFLElBTFQsQ0FNREQsT0FBTyxDQUFFLGVBTlIsQ0FYSSxDQUxjLENBQXZCLENBMEJBLEdBQUltOUIsbUJBQWtCLENBQUcsQ0FDdkI1aEQsSUFBSSxDQUFFLFdBRGlCLENBRXZCMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRkUsQ0FHdkI3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFITyxDQUl2QlEsV0FBVyxDQUFFLElBSlUsQ0FLdkIzRixLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLGtCQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsS0FMSCxDQUFELENBTUosQ0FDRHprQixJQUFJLENBQUUsc0JBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVnQixHQUhmLENBSURPLFdBQVcsQ0FBRSxJQUpaLENBS0Q2RSxPQUFPLENBQUUsUUFMUixDQU5JLENBTGdCLENBQXpCLENBb0JBLEdBQUlvOUIsaUJBQWdCLENBQUcsQ0FDckI3aEQsSUFBSSxDQUFFLFNBRGUsQ0FFckIyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGQSxDQUdyQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhLLENBSXJCUSxXQUFXLENBQUUsSUFKUSxDQUtyQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsZ0JBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxRQUxILENBQUQsQ0FNSixDQUNEemtCLElBQUksQ0FBRSxtQkFETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUZwQixDQUdEeUIsV0FBVyxDQUFFLElBSFosQ0FJRDtzREFFQTNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsc0JBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNDLEtBQUwsQ0FBV1UsV0FIWCxDQUlOa0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxNQUxILENBQUQsQ0FOTixDQU5JLENBTGMsQ0FBdkIsQ0EyQkE7Ozs7Ozs7Ozs7O0dBWUEsUUFBU3E5QixvQkFBVCxDQUE2QkMsWUFBN0IsQ0FBMkNDLFFBQTNDLENBQXFEQyxTQUFyRCxDQUFnRUMsT0FBaEUsQ0FBeUUsQ0FDdkUsR0FBSXovQyxPQUFNLENBQUcsRUFBYixDQUVBLElBQUksR0FBSWlJLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3EzQyxZQUFZLENBQUM1Z0QsTUFBaEMsQ0FBd0N1SixDQUFDLEVBQXpDLENBQTZDLENBQzNDLElBQUksR0FBSXdMLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzZyQyxZQUFZLENBQUNyM0MsQ0FBRCxDQUFaLENBQWdCeTNDLFFBQWhCLENBQXlCaGhELE1BQTVDLENBQW9EK1UsQ0FBQyxFQUFyRCxDQUF5RCxDQUN2RCxHQUFJa3NDLElBQUcsQ0FBR0wsWUFBWSxDQUFDcjNDLENBQUQsQ0FBWixDQUFnQnkzQyxRQUFoQixDQUF5QmpzQyxDQUF6QixDQUFWLENBQ0EsR0FBR2dzQyxPQUFPLEdBQUszMUMsU0FBWixFQUF5QjYxQyxHQUFHLENBQUNockMsSUFBSixHQUFhOHFDLE9BQXpDLENBQWtELENBQ2hELFNBQ0QsQ0FDRDtBQUNBLEdBQUdGLFFBQVEsR0FBSyxJQUFoQixDQUFzQixDQUNwQnYvQyxNQUFNLENBQUMySyxJQUFQLENBQVlnMUMsR0FBWixFQUNBLFNBQ0QsQ0FDRCxHQUFHQSxHQUFHLENBQUN0MEMsVUFBSixDQUFlazBDLFFBQWYsSUFBNkJ6MUMsU0FBN0IsRUFDRDYxQyxHQUFHLENBQUN0MEMsVUFBSixDQUFlazBDLFFBQWYsRUFBeUJ0cEMsT0FBekIsQ0FBaUN1cEMsU0FBakMsR0FBK0MsQ0FEakQsQ0FDb0QsQ0FDbER4L0MsTUFBTSxDQUFDMkssSUFBUCxDQUFZZzFDLEdBQVosRUFDRCxDQUNGLENBQ0YsQ0FFRCxNQUFPMy9DLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7OztHQVNBOCtDLEdBQUcsQ0FBQ2MsY0FBSixDQUFxQixTQUFTM3JDLEdBQVQsQ0FBY3VLLE1BQWQsQ0FBc0IwVSxRQUF0QixDQUFnQyxDQUNuRDtBQUNBLEdBQUcsTUFBTzFVLE9BQVAsR0FBa0IsUUFBckIsQ0FBK0IsQ0FDN0IwVSxRQUFRLENBQUcxVSxNQUFYLENBQ0FBLE1BQU0sQ0FBRyxJQUFULENBQ0QsQ0FIRCxJQUdPLElBQUdBLE1BQU0sR0FBSzFVLFNBQWQsQ0FBeUIsQ0FDOUIwVSxNQUFNLENBQUcsSUFBVCxDQUNELENBRUQ7QUFDQSxHQUFJd0QsUUFBTyxDQUFHLEVBQWQsQ0FDQSxHQUFJMWYsT0FBTSxDQUFHLEVBQWIsQ0FDQSxHQUFHLENBQUNnWixJQUFJLENBQUN3RyxRQUFMLENBQWM3TixHQUFkLENBQW1CZ3JDLFlBQW5CLENBQWlDajlCLE9BQWpDLENBQTBDMWYsTUFBMUMsQ0FBSixDQUF1RCxDQUNyRCxHQUFJbkMsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsNEJBQ3BCLHFDQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQ21DLE1BQU4sQ0FBZW5DLEtBQWYsQ0FDQSxLQUFNQSxNQUFOLENBQ0QsQ0FFRCxHQUFJMC9DLElBQUcsQ0FBRyxDQUNSbHVCLE9BQU8sQ0FBRTNQLE9BQU8sQ0FBQzJQLE9BQVIsQ0FBZ0J4akIsVUFBaEIsQ0FBMkIsQ0FBM0IsQ0FERCxDQUVSbXhDLFlBQVksQ0FBRSxFQUZOLENBSVI7Ozs7Ozs7Ozs7OztPQWFBUSxPQUFPLENBQUUsaUJBQVM1K0MsTUFBVCxDQUFpQixDQUN4QixHQUFJbU4sS0FBSSxDQUFHLEVBQVgsQ0FFQSxHQUFJMHhDLFdBQUosQ0FDQSxHQUFHLGNBQWdCNytDLE9BQW5CLENBQTJCLENBQ3pCNitDLFVBQVUsQ0FBRzcrQyxNQUFNLENBQUM2K0MsVUFBcEIsQ0FDRCxDQUZELElBRU8sSUFBRyxpQkFBbUI3K0MsT0FBdEIsQ0FBOEIsQ0FDbkM2K0MsVUFBVSxDQUFHLzVDLEtBQUssQ0FBQ3dELElBQU4sQ0FBV3NJLFVBQVgsQ0FBc0I1USxNQUFNLENBQUM4K0MsYUFBN0IsQ0FBYixDQUNELENBRUQ7QUFDQSxHQUFHRCxVQUFVLEdBQUtqMkMsU0FBZixFQUE0QixFQUFFLGdCQUFrQjVJLE9BQXBCLENBQTVCLEVBQ0QsV0FBYUEsT0FEZixDQUN1QixDQUNyQm1OLElBQUksQ0FBQ25OLE1BQU0sQ0FBQ3UrQyxPQUFSLENBQUosQ0FBdUJKLG1CQUFtQixDQUN4Q1EsR0FBRyxDQUFDUCxZQURvQyxDQUN0QixJQURzQixDQUNoQixJQURnQixDQUNWcCtDLE1BQU0sQ0FBQ3UrQyxPQURHLENBQTFDLENBRUQsQ0FFRCxHQUFHTSxVQUFVLEdBQUtqMkMsU0FBbEIsQ0FBNkIsQ0FDM0J1RSxJQUFJLENBQUMweEMsVUFBTCxDQUFrQlYsbUJBQW1CLENBQ25DUSxHQUFHLENBQUNQLFlBRCtCLENBQ2pCLFlBRGlCLENBRW5DUyxVQUZtQyxDQUV2QjcrQyxNQUFNLENBQUN1K0MsT0FGZ0IsQ0FBckMsQ0FHRCxDQUNELEdBQUcsZ0JBQWtCditDLE9BQXJCLENBQTZCLENBQzNCbU4sSUFBSSxDQUFDNHhDLFlBQUwsQ0FBb0JaLG1CQUFtQixDQUNyQ1EsR0FBRyxDQUFDUCxZQURpQyxDQUNuQixjQURtQixDQUVyQ3ArQyxNQUFNLENBQUMrK0MsWUFGOEIsQ0FFaEIvK0MsTUFBTSxDQUFDdStDLE9BRlMsQ0FBdkMsQ0FHRCxDQUVELE1BQU9weEMsS0FBUCxDQUNELENBOUNPLENBZ0RSOzs7Ozs7Ozs7T0FVQTZ4QyxxQkFBcUIsQ0FBRSwrQkFBU0QsWUFBVCxDQUF1QlIsT0FBdkIsQ0FBZ0MsQ0FDckQsTUFBT0osb0JBQW1CLENBQ3hCUSxHQUFHLENBQUNQLFlBRG9CLENBQ04sY0FETSxDQUNVVyxZQURWLENBQ3dCUixPQUR4QixDQUExQixDQUVELENBN0RPLENBK0RSOzs7Ozs7Ozs7T0FVQVUsbUJBQW1CLENBQUUsNkJBQVNKLFVBQVQsQ0FBcUJOLE9BQXJCLENBQThCLENBQ2pELE1BQU9KLG9CQUFtQixDQUN4QlEsR0FBRyxDQUFDUCxZQURvQixDQUNOLFlBRE0sQ0FDUVMsVUFEUixDQUNvQk4sT0FEcEIsQ0FBMUIsQ0FFRCxDQTVFTyxDQUFWLENBK0VBLEdBQUd6OUIsT0FBTyxDQUFDMlAsT0FBUixDQUFnQnhqQixVQUFoQixDQUEyQixDQUEzQixJQUFrQyxDQUFyQyxDQUF3QyxDQUN0QyxHQUFJaE8sTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsb0RBQVYsQ0FBWixDQUNBMkIsS0FBSyxDQUFDd3hCLE9BQU4sQ0FBZ0IzUCxPQUFPLENBQUMyUCxPQUFSLENBQWdCeGpCLFVBQWhCLENBQTJCLENBQTNCLENBQWhCLENBQ0EsS0FBTWhPLE1BQU4sQ0FDRCxDQUVELEdBQUdtYixJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUNvK0IsV0FBdEIsSUFBdUMzNUMsR0FBRyxDQUFDb2MsSUFBSixDQUFTL2lCLElBQW5ELENBQXlELENBQ3ZELEdBQUlLLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLHdEQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQ3NmLEdBQU4sQ0FBWW5FLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ28rQixXQUF0QixDQUFaLENBQ0EsS0FBTWpnRCxNQUFOLENBQ0QsQ0FFRCxHQUFJTCxLQUFJLENBQUdraUIsT0FBTyxDQUFDcStCLE9BQVIsQ0FBZ0I3b0MsS0FBaEIsQ0FBc0IsQ0FBdEIsQ0FBWCxDQUNBLEdBQUcxWCxJQUFJLENBQUNvZCxRQUFMLEdBQWtCNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQTdCLEVBQ0ExYixJQUFJLENBQUM2VSxJQUFMLEdBQWMyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FEM0IsQ0FDd0MsQ0FDdEMsS0FBTSxJQUFJemQsTUFBSixDQUFVLHVEQUFWLENBQU4sQ0FDRCxDQUNEc0IsSUFBSSxDQUFHd2dELGdCQUFnQixDQUFDeGdELElBQUQsQ0FBdkIsQ0FFQTtBQUNBLEdBQUdraUIsT0FBTyxDQUFDdStCLEdBQVgsQ0FBZ0IsQ0FDZCxHQUFJdDlCLEdBQUUsQ0FBRyxJQUFULENBQ0EsR0FBSXU5QixZQUFXLENBQUcsQ0FBbEIsQ0FDQSxHQUFJQyxhQUFZLENBQUdubEMsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDeStCLFlBQXRCLENBQW5CLENBQ0EsT0FBT0EsWUFBUCxFQUNBLElBQUtoNkMsSUFBRyxDQUFDb2MsSUFBSixDQUFTdVMsSUFBZCxDQUNFblMsRUFBRSxDQUFHamQsS0FBSyxDQUFDaWQsRUFBTixDQUFTbVMsSUFBVCxDQUFjcHdCLE1BQWQsRUFBTCxDQUNBdzdDLFdBQVcsQ0FBRyxFQUFkLENBQ0EsTUFDRixJQUFLLzVDLElBQUcsQ0FBQ29jLElBQUosQ0FBU2lCLE1BQWQsQ0FDRWIsRUFBRSxDQUFHamQsS0FBSyxDQUFDaWQsRUFBTixDQUFTYSxNQUFULENBQWdCOWUsTUFBaEIsRUFBTCxDQUNBdzdDLFdBQVcsQ0FBRyxFQUFkLENBQ0EsTUFDRixJQUFLLzVDLElBQUcsQ0FBQ29jLElBQUosQ0FBU3V0QixNQUFkLENBQ0VudEIsRUFBRSxDQUFHamQsS0FBSyxDQUFDaWQsRUFBTixDQUFTbXRCLE1BQVQsQ0FBZ0JwckMsTUFBaEIsRUFBTCxDQUNBdzdDLFdBQVcsQ0FBRyxFQUFkLENBQ0EsTUFDRixJQUFLLzVDLElBQUcsQ0FBQ29jLElBQUosQ0FBU29VLE1BQWQsQ0FDRWhVLEVBQUUsQ0FBR2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU2dVLE1BQVQsQ0FBZ0JqeUIsTUFBaEIsRUFBTCxDQUNBdzdDLFdBQVcsQ0FBRyxFQUFkLENBQ0EsTUFDRixJQUFLLzVDLElBQUcsQ0FBQ29jLElBQUosQ0FBU2lVLEdBQWQsQ0FDRTdULEVBQUUsQ0FBR2pkLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBUzZULEdBQVQsQ0FBYTl4QixNQUFiLEVBQUwsQ0FDQXc3QyxXQUFXLENBQUcsRUFBZCxDQUNBLE1BcEJGLENBc0JBLEdBQUd2OUIsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDZCxLQUFNLElBQUl6a0IsTUFBSixDQUFVLDJDQUE2Q2lpRCxZQUF2RCxDQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlDLFFBQU8sQ0FBRyxHQUFJMTZDLE1BQUssQ0FBQ3dELElBQU4sQ0FBVzJDLFVBQWYsQ0FBMEI2VixPQUFPLENBQUMwK0IsT0FBbEMsQ0FBZCxDQUNBLEdBQUlDLGNBQWEsQ0FBSyxpQkFBbUIzK0IsUUFBcEIsQ0FDbkJqUSxRQUFRLENBQUMvTCxLQUFLLENBQUN3RCxJQUFOLENBQVd3SSxVQUFYLENBQXNCZ1EsT0FBTyxDQUFDMitCLGFBQTlCLENBQUQsQ0FBK0MsRUFBL0MsQ0FEVyxDQUMwQyxDQUQvRCxDQUVBLEdBQUlDLE9BQU0sQ0FBRzlCLEdBQUcsQ0FBQ3AxQixXQUFKLENBQ1h3SixRQURXLENBQ0R3dEIsT0FEQyxDQUNRLENBRFIsQ0FDV0MsYUFEWCxDQUMwQkgsV0FEMUIsQ0FDdUN2OUIsRUFEdkMsQ0FBYixDQUVBLEdBQUlzOUIsSUFBRyxDQUFHdjZDLEtBQUssQ0FBQ28zQixJQUFOLENBQVdwNEIsTUFBWCxFQUFWLENBQ0F1N0MsR0FBRyxDQUFDM3NDLEtBQUosQ0FBVXFQLEVBQVYsQ0FBYzI5QixNQUFkLEVBQ0FMLEdBQUcsQ0FBQzNtQyxNQUFKLENBQVc5WixJQUFJLENBQUMwWCxLQUFoQixFQUNBLEdBQUlxcEMsU0FBUSxDQUFHTixHQUFHLENBQUN4aUIsTUFBSixFQUFmLENBQ0EsR0FBRzhpQixRQUFRLENBQUM1eUMsUUFBVCxLQUF3QitULE9BQU8sQ0FBQzgrQixTQUFuQyxDQUE4QyxDQUM1QyxLQUFNLElBQUl0aUQsTUFBSixDQUFVLHNEQUFWLENBQU4sQ0FDRCxDQUNGLENBRUR1aUQsd0JBQXdCLENBQUNsQixHQUFELENBQU0vL0MsSUFBSSxDQUFDMFgsS0FBWCxDQUFrQmdILE1BQWxCLENBQTBCMFUsUUFBMUIsQ0FBeEIsQ0FDQSxNQUFPMnNCLElBQVAsQ0FDRCxDQXJLRCxDQXVLQTs7Ozs7Ozs7Ozs7R0FZQSxRQUFTUyxpQkFBVCxDQUEwQnhnRCxJQUExQixDQUFnQyxDQUM5QjtBQUNBO0FBQ0EsR0FBR0EsSUFBSSxDQUFDdWQsUUFBTCxFQUFpQnZkLElBQUksQ0FBQ3FkLFdBQXpCLENBQXNDLENBQ3BDLEdBQUkzRixNQUFLLENBQUd4UixLQUFLLENBQUN3RCxJQUFOLENBQVc0RixZQUFYLEVBQVosQ0FDQSxJQUFJLEdBQUluSCxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUduSSxJQUFJLENBQUMwWCxLQUFMLENBQVc5WSxNQUE5QixDQUFzQyxFQUFFdUosQ0FBeEMsQ0FBMkMsQ0FDekN1UCxLQUFLLENBQUN0SyxRQUFOLENBQWVwTixJQUFJLENBQUMwWCxLQUFMLENBQVd2UCxDQUFYLEVBQWN1UCxLQUE3QixFQUNELENBQ0QxWCxJQUFJLENBQUN1ZCxRQUFMLENBQWdCdmQsSUFBSSxDQUFDcWQsV0FBTCxDQUFtQixLQUFuQyxDQUNBcmQsSUFBSSxDQUFDMFgsS0FBTCxDQUFhQSxLQUFLLENBQUN2SixRQUFOLEVBQWIsQ0FDRCxDQUNELE1BQU9uTyxLQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7O0dBVUEsUUFBU2loRCx5QkFBVCxDQUFrQ2xCLEdBQWxDLENBQXVDbUIsUUFBdkMsQ0FBaUR4aUMsTUFBakQsQ0FBeUQwVSxRQUF6RCxDQUFtRSxDQUNqRTh0QixRQUFRLENBQUcxbEMsSUFBSSxDQUFDaUQsT0FBTCxDQUFheWlDLFFBQWIsQ0FBdUJ4aUMsTUFBdkIsQ0FBWCxDQUE0QywrQkFFNUMsR0FBR3dpQyxRQUFRLENBQUM5akMsUUFBVCxHQUFzQjVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUFqQyxFQUNBd2xDLFFBQVEsQ0FBQ3JzQyxJQUFULEdBQWtCMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBRDVCLEVBRUFxa0MsUUFBUSxDQUFDN2pDLFdBQVQsR0FBeUIsSUFGNUIsQ0FFa0MsQ0FDaEMsS0FBTSxJQUFJM2UsTUFBSixDQUFVLDhDQUNkLHlCQURJLENBQU4sQ0FFRCxDQUVELElBQUksR0FBSXlKLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRys0QyxRQUFRLENBQUN4cEMsS0FBVCxDQUFlOVksTUFBbEMsQ0FBMEN1SixDQUFDLEVBQTNDLENBQStDLENBQzdDLEdBQUlnNUMsWUFBVyxDQUFHRCxRQUFRLENBQUN4cEMsS0FBVCxDQUFldlAsQ0FBZixDQUFsQixDQUVBO0FBQ0EsR0FBSStaLFFBQU8sQ0FBRyxFQUFkLENBQ0EsR0FBSTFmLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBRyxDQUFDZ1osSUFBSSxDQUFDd0csUUFBTCxDQUFjbS9CLFdBQWQsQ0FBMkJqQyxvQkFBM0IsQ0FBaURoOUIsT0FBakQsQ0FBMEQxZixNQUExRCxDQUFKLENBQXVFLENBQ3JFLEdBQUluQyxNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FBVSwwQkFBVixDQUFaLENBQ0EyQixLQUFLLENBQUNtQyxNQUFOLENBQWVBLE1BQWYsQ0FDQSxLQUFNbkMsTUFBTixDQUNELENBRUQsR0FBSThULElBQUcsQ0FBRyxDQUNSd2dCLFNBQVMsQ0FBRSxLQURILENBQVYsQ0FHQSxHQUFJNnFCLGFBQVksQ0FBRyxJQUFuQixDQUNBLEdBQUl4L0MsS0FBSSxDQUFHa2lCLE9BQU8sQ0FBQ3ErQixPQUFSLENBQWdCN29DLEtBQWhCLENBQXNCLENBQXRCLENBQVgsQ0FDQSxPQUFPOEQsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDbytCLFdBQXRCLENBQVAsRUFDQSxJQUFLMzVDLElBQUcsQ0FBQ29jLElBQUosQ0FBUy9pQixJQUFkLENBQ0UsR0FBR0EsSUFBSSxDQUFDb2QsUUFBTCxHQUFrQjVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUE3QixFQUNBMWIsSUFBSSxDQUFDNlUsSUFBTCxHQUFjMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRDNCLENBQ3dDLENBQ3RDLEtBQU0sSUFBSXpkLE1BQUosQ0FBVSxtREFBVixDQUFOLENBQ0QsQ0FDRDhnRCxZQUFZLENBQUdnQixnQkFBZ0IsQ0FBQ3hnRCxJQUFELENBQWhCLENBQXVCMFgsS0FBdEMsQ0FDQSxNQUNGLElBQUsvUSxJQUFHLENBQUNvYyxJQUFKLENBQVM0USxhQUFkLENBQ0U2ckIsWUFBWSxDQUFHNEIsb0JBQW9CLENBQUNwaEQsSUFBRCxDQUFPb3pCLFFBQVAsQ0FBbkMsQ0FDQWpmLEdBQUcsQ0FBQ3dnQixTQUFKLENBQWdCLElBQWhCLENBQ0EsTUFDRixRQUNFLEdBQUl0MEIsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsa0NBQVYsQ0FBWixDQUNBMkIsS0FBSyxDQUFDaWdELFdBQU4sQ0FBb0I5a0MsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDbytCLFdBQXRCLENBQXBCLENBQ0EsS0FBTWpnRCxNQUFOLENBZkYsQ0FrQkE4VCxHQUFHLENBQUN5ckMsUUFBSixDQUFleUIsbUJBQW1CLENBQUM3QixZQUFELENBQWU5Z0MsTUFBZixDQUF1QjBVLFFBQXZCLENBQWxDLENBQ0Eyc0IsR0FBRyxDQUFDUCxZQUFKLENBQWlCMzBDLElBQWpCLENBQXNCc0osR0FBdEIsRUFDRCxDQUNGLENBRUQ7Ozs7Ozs7R0FRQSxRQUFTaXRDLHFCQUFULENBQThCcGhELElBQTlCLENBQW9Db3pCLFFBQXBDLENBQThDLENBQzVDLEdBQUlsUixRQUFPLENBQUcsRUFBZCxDQUNBLEdBQUkxZixPQUFNLENBQUcsRUFBYixDQUNBLEdBQUcsQ0FBQ2daLElBQUksQ0FBQ3dHLFFBQUwsQ0FDRmhpQixJQURFLENBQ0lrRyxLQUFLLENBQUNvN0MsS0FBTixDQUFZOWxDLElBQVosQ0FBaUIrbEMsc0JBRHJCLENBQzZDci9CLE9BRDdDLENBQ3NEMWYsTUFEdEQsQ0FBSixDQUNtRSxDQUNqRSxHQUFJbkMsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsbUNBQVYsQ0FBWixDQUNBMkIsS0FBSyxDQUFDbUMsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5DLE1BQU4sQ0FDRCxDQUVELEdBQUlzZixJQUFHLENBQUduRSxJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUNvK0IsV0FBdEIsQ0FBVixDQUNBLEdBQUczZ0MsR0FBRyxHQUFLaFosR0FBRyxDQUFDb2MsSUFBSixDQUFTL2lCLElBQXBCLENBQTBCLENBQ3hCLEdBQUlLLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUNWLHVEQURVLENBQVosQ0FFQTJCLEtBQUssQ0FBQ3NmLEdBQU4sQ0FBWUEsR0FBWixDQUNBLEtBQU10ZixNQUFOLENBQ0QsQ0FFRDtBQUNBc2YsR0FBRyxDQUFHbkUsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDcy9CLFlBQXRCLENBQU4sQ0FDQSxHQUFJMzlCLE9BQU0sQ0FBR2xkLEdBQUcsQ0FBQ29zQixHQUFKLENBQVEwQixTQUFSLENBQWtCOVUsR0FBbEIsQ0FBdUJ1QyxPQUFPLENBQUN1L0IsWUFBL0IsQ0FBNkNydUIsUUFBN0MsQ0FBYixDQUVBO0FBQ0EsR0FBSXN1QixxQkFBb0IsQ0FBR2xCLGdCQUFnQixDQUFDdCtCLE9BQU8sQ0FBQ3cvQixvQkFBVCxDQUEzQyxDQUNBLEdBQUkvc0IsVUFBUyxDQUFHenVCLEtBQUssQ0FBQ3dELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0JveUMsb0JBQW9CLENBQUNocUMsS0FBN0MsQ0FBaEIsQ0FFQW1NLE1BQU0sQ0FBQy9KLE1BQVAsQ0FBYzZhLFNBQWQsRUFDQSxHQUFHLENBQUM5USxNQUFNLENBQUN3SixNQUFQLEVBQUosQ0FBcUIsQ0FDbkIsS0FBTSxJQUFJM3VCLE1BQUosQ0FBVSx5Q0FBVixDQUFOLENBQ0QsQ0FFRCxNQUFPbWxCLE9BQU0sQ0FBQ25SLE1BQVAsQ0FBY3ZFLFFBQWQsRUFBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7R0FXQSxRQUFTa3pDLG9CQUFULENBQTZCN0IsWUFBN0IsQ0FBMkM5Z0MsTUFBM0MsQ0FBbUQwVSxRQUFuRCxDQUE2RCxDQUMzRDtBQUNBLEdBQUcsQ0FBQzFVLE1BQUQsRUFBVzhnQyxZQUFZLENBQUM1Z0QsTUFBYixHQUF3QixDQUF0QyxDQUF5QyxDQUN2QyxNQUFPLEVBQVAsQ0FDRCxDQUVEO0FBQ0E0Z0QsWUFBWSxDQUFHaGtDLElBQUksQ0FBQ2lELE9BQUwsQ0FBYStnQyxZQUFiLENBQTJCOWdDLE1BQTNCLENBQWYsQ0FFQSxHQUFHOGdDLFlBQVksQ0FBQ3BpQyxRQUFiLEdBQTBCNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXJDLEVBQ0Q4akMsWUFBWSxDQUFDM3FDLElBQWIsR0FBc0IyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFEL0IsRUFFRDJpQyxZQUFZLENBQUNuaUMsV0FBYixHQUE2QixJQUYvQixDQUVxQyxDQUNuQyxLQUFNLElBQUkzZSxNQUFKLENBQ0osNERBREksQ0FBTixDQUVELENBRUQsR0FBSWlqRCxJQUFHLENBQUcsRUFBVixDQUNBLElBQUksR0FBSXg1QyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdxM0MsWUFBWSxDQUFDOW5DLEtBQWIsQ0FBbUI5WSxNQUF0QyxDQUE4Q3VKLENBQUMsRUFBL0MsQ0FBbUQsQ0FDakQsR0FBSXk1QyxRQUFPLENBQUdwQyxZQUFZLENBQUM5bkMsS0FBYixDQUFtQnZQLENBQW5CLENBQWQsQ0FFQTtBQUNBLEdBQUkrWixRQUFPLENBQUcsRUFBZCxDQUNBLEdBQUkxZixPQUFNLENBQUcsRUFBYixDQUNBLEdBQUcsQ0FBQ2daLElBQUksQ0FBQ3dHLFFBQUwsQ0FBYzQvQixPQUFkLENBQXVCeEMsZ0JBQXZCLENBQXlDbDlCLE9BQXpDLENBQWtEMWYsTUFBbEQsQ0FBSixDQUErRCxDQUM3RCxHQUFJbkMsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsc0JBQVYsQ0FBWixDQUNBMkIsS0FBSyxDQUFDbUMsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5DLE1BQU4sQ0FDRCxDQUVELGlEQUNBLEdBQUl3L0MsSUFBRyxDQUFHLENBQ1JockMsSUFBSSxDQUFFMkcsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDMi9CLEtBQXRCLENBREUsQ0FFUnQyQyxVQUFVLENBQUV1MkMsb0JBQW9CLENBQUM1L0IsT0FBTyxDQUFDNi9CLGFBQVQsQ0FGeEIsQ0FBVixDQUlBSixHQUFHLENBQUM5MkMsSUFBSixDQUFTZzFDLEdBQVQsRUFFQSxHQUFJbUMsVUFBSixDQUFlQyxPQUFmLENBQ0EsR0FBSUMsUUFBTyxDQUFHaGdDLE9BQU8sQ0FBQ2lnQyxRQUFSLENBQWlCenFDLEtBQWpCLENBQXVCLENBQXZCLENBQWQsQ0FDQSxPQUFPbW9DLEdBQUcsQ0FBQ2hyQyxJQUFYLEVBQ0UsSUFBS2xPLElBQUcsQ0FBQ29jLElBQUosQ0FBU3EvQixtQkFBZCxDQUNFOzt3Q0FHQUYsT0FBTyxDQUFHdjdDLEdBQUcsQ0FBQzR0QixxQkFBSixDQUEwQjJ0QixPQUExQixDQUFtQzl1QixRQUFuQyxDQUFWLENBQ0EsR0FBRzh1QixPQUFPLEdBQUssSUFBZixDQUFxQixDQUNuQixLQUFNLElBQUl4akQsTUFBSixDQUNKLDBEQURJLENBQU4sQ0FFRCxDQUVELGtCQUNGLElBQUtpSSxJQUFHLENBQUNvYyxJQUFKLENBQVNzL0IsTUFBZCxDQUNFOzs0Q0FHQSxHQUFJLENBQ0Z4QyxHQUFHLENBQUMxL0MsR0FBSixDQUFVd0csR0FBRyxDQUFDd2pCLGtCQUFKLENBQXVCKzNCLE9BQXZCLENBQVYsQ0FDRCxDQUFDLE1BQU1wMUMsQ0FBTixDQUFTLENBQ1Q7QUFDQSt5QyxHQUFHLENBQUMxL0MsR0FBSixDQUFVLElBQVYsQ0FDQTAvQyxHQUFHLENBQUNya0MsSUFBSixDQUFXMG1DLE9BQVgsQ0FDRCxDQUNELFNBQVcseUJBRWIsSUFBS3Y3QyxJQUFHLENBQUNvYyxJQUFKLENBQVN1L0IsT0FBZCxDQUNFOzt3RUFHQU4sU0FBUyxDQUFHMUMsZ0JBQVosQ0FDQTJDLE9BQU8sQ0FBRyxrQkFBVyxDQUNuQixHQUFHem1DLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ3FnQyxNQUF0QixJQUFrQzU3QyxHQUFHLENBQUNvYyxJQUFKLENBQVN5L0IsZUFBOUMsQ0FBK0QsQ0FDN0QsR0FBSW5pRCxNQUFLLENBQUcsR0FBSTNCLE1BQUosQ0FDVixxREFEVSxDQUFaLENBRUEyQixLQUFLLENBQUNzZixHQUFOLENBQVluRSxJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUNxZ0MsTUFBdEIsQ0FBWixDQUNBLEtBQU1saUQsTUFBTixDQUNELENBRUQ7QUFDQSxHQUFJb2lELFNBQVEsQ0FBR2puQyxJQUFJLENBQUNpRCxPQUFMLENBQWF5RCxPQUFPLENBQUM2ckIsSUFBckIsQ0FBMkJydkIsTUFBM0IsQ0FBZixDQUNBLEdBQUksQ0FDRm1oQyxHQUFHLENBQUM5UixJQUFKLENBQVdwbkMsR0FBRyxDQUFDa25DLG1CQUFKLENBQXdCNFUsUUFBeEIsQ0FBa0MsSUFBbEMsQ0FBWCxDQUNELENBQUMsTUFBTTMxQyxDQUFOLENBQVMsQ0FDVDtBQUNBK3lDLEdBQUcsQ0FBQzlSLElBQUosQ0FBVyxJQUFYLENBQ0E4UixHQUFHLENBQUNya0MsSUFBSixDQUFXaW5DLFFBQVgsQ0FDRCxDQUNGLENBakJELENBa0JBLE1BRUYsUUFDRSxHQUFJcGlELE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLG1DQUFWLENBQVosQ0FDQTJCLEtBQUssQ0FBQ3NmLEdBQU4sQ0FBWWtnQyxHQUFHLENBQUNockMsSUFBaEIsQ0FDQSxLQUFNeFUsTUFBTixDQXJESixDQXdEQSw2RUFDQSxHQUFHMmhELFNBQVMsR0FBS2g0QyxTQUFkLEVBQ0EsQ0FBQ3dSLElBQUksQ0FBQ3dHLFFBQUwsQ0FBY2tnQyxPQUFkLENBQXVCRixTQUF2QixDQUFrQzkvQixPQUFsQyxDQUEyQzFmLE1BQTNDLENBREosQ0FDd0QsQ0FDdEQsR0FBSW5DLE1BQUssQ0FBRyxHQUFJM0IsTUFBSixDQUFVLHVCQUF5QnNqRCxTQUFTLENBQUN2a0QsSUFBN0MsQ0FBWixDQUNBNEMsS0FBSyxDQUFDbUMsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5DLE1BQU4sQ0FDRCxDQUVELDREQUNBNGhELE9BQU8sR0FDUixDQUVELE1BQU9OLElBQVAsQ0FDRCxDQUVEOzs7Ozs7R0FPQSxRQUFTRyxxQkFBVCxDQUE4QnYyQyxVQUE5QixDQUEwQyxDQUN4QyxHQUFJbTNDLGFBQVksQ0FBRyxFQUFuQixDQUVBLEdBQUduM0MsVUFBVSxHQUFLdkIsU0FBbEIsQ0FBNkIsQ0FDM0IsSUFBSSxHQUFJN0IsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHb0QsVUFBVSxDQUFDM00sTUFBOUIsQ0FBc0MsRUFBRXVKLENBQXhDLENBQTJDLENBQ3pDLEdBQUkrWixRQUFPLENBQUcsRUFBZCxDQUNBLEdBQUkxZixPQUFNLENBQUcsRUFBYixDQUNBLEdBQUcsQ0FBQ2daLElBQUksQ0FBQ3dHLFFBQUwsQ0FBY3pXLFVBQVUsQ0FBQ3BELENBQUQsQ0FBeEIsQ0FBNkJrM0Msa0JBQTdCLENBQWlEbjlCLE9BQWpELENBQTBEMWYsTUFBMUQsQ0FBSixDQUF1RSxDQUNyRSxHQUFJbkMsTUFBSyxDQUFHLEdBQUkzQixNQUFKLENBQVUsbUNBQVYsQ0FBWixDQUNBMkIsS0FBSyxDQUFDbUMsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5DLE1BQU4sQ0FDRCxDQUVELEdBQUlzZixJQUFHLENBQUduRSxJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUN2QyxHQUF0QixDQUFWLENBQ0EsR0FBR2haLEdBQUcsQ0FBQ29jLElBQUosQ0FBU3BELEdBQVQsSUFBa0IzVixTQUFyQixDQUFnQyxDQUM5QjtBQUNBLFNBQ0QsQ0FFRDA0QyxZQUFZLENBQUMvN0MsR0FBRyxDQUFDb2MsSUFBSixDQUFTcEQsR0FBVCxDQUFELENBQVosQ0FBOEIsRUFBOUIsQ0FDQSxJQUFJLEdBQUloTSxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUd1TyxPQUFPLENBQUN0QyxNQUFSLENBQWVoaEIsTUFBbEMsQ0FBMEMsRUFBRStVLENBQTVDLENBQStDLENBQzdDK3VDLFlBQVksQ0FBQy83QyxHQUFHLENBQUNvYyxJQUFKLENBQVNwRCxHQUFULENBQUQsQ0FBWixDQUE0QjlVLElBQTVCLENBQWlDcVgsT0FBTyxDQUFDdEMsTUFBUixDQUFlak0sQ0FBZixFQUFrQitELEtBQW5ELEVBQ0QsQ0FDRixDQUNGLENBRUQsTUFBT2dyQyxhQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCQTFELEdBQUcsQ0FBQzJELFlBQUosQ0FBbUIsU0FBU3hpRCxHQUFULENBQWM0dEMsSUFBZCxDQUFvQjNhLFFBQXBCLENBQThCcDFCLE9BQTlCLENBQXVDLENBQ3hEO0FBQ0FBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0FBLE9BQU8sQ0FBQ3ExQixRQUFSLENBQW1CcjFCLE9BQU8sQ0FBQ3ExQixRQUFSLEVBQW9CLENBQXZDLENBQ0FyMUIsT0FBTyxDQUFDZ1IsS0FBUixDQUFnQmhSLE9BQU8sQ0FBQ2dSLEtBQVIsRUFBaUIsSUFBakMsQ0FDQWhSLE9BQU8sQ0FBQzJuQixTQUFSLENBQW9CM25CLE9BQU8sQ0FBQzJuQixTQUFSLEVBQXFCM25CLE9BQU8sQ0FBQ3dqRCxZQUE3QixFQUE2QyxRQUFqRSxDQUNBLEdBQUcsRUFBRSxVQUFZeGpELFFBQWQsQ0FBSCxDQUEyQixDQUN6QkEsT0FBTyxDQUFDNGtELE1BQVIsQ0FBaUIsSUFBakIsQ0FDRCxDQUNELEdBQUcsRUFBRSxjQUFnQjVrRCxRQUFsQixDQUFILENBQStCLENBQzdCQSxPQUFPLENBQUNpaUQsVUFBUixDQUFxQixJQUFyQixDQUNELENBQ0QsR0FBRyxFQUFFLHNCQUF3QmppRCxRQUExQixDQUFILENBQXVDLENBQ3JDQSxPQUFPLENBQUM2a0Qsa0JBQVIsQ0FBNkIsSUFBN0IsQ0FDRCxDQUVELEdBQUk1QyxXQUFVLENBQUdqaUQsT0FBTyxDQUFDaWlELFVBQXpCLENBQ0EsR0FBSTZDLFNBQUosQ0FDQSxHQUFHN0MsVUFBVSxHQUFLLElBQWxCLENBQXdCLENBQ3RCQSxVQUFVLENBQUcvNUMsS0FBSyxDQUFDd0QsSUFBTixDQUFXc0ksVUFBWCxDQUFzQml1QyxVQUF0QixDQUFiLENBQ0QsQ0FGRCxJQUVPLElBQUdqaUQsT0FBTyxDQUFDNmtELGtCQUFYLENBQStCLENBQ3BDO0FBQ0EsR0FBRzlVLElBQUgsQ0FBUyxDQUNQLEdBQUlnVixXQUFVLENBQUc3OEMsS0FBSyxDQUFDd0QsSUFBTixDQUFXbUMsT0FBWCxDQUFtQmtpQyxJQUFuQixFQUEyQkEsSUFBSSxDQUFDLENBQUQsQ0FBL0IsQ0FBcUNBLElBQXRELENBQ0EsR0FBRyxNQUFPZ1YsV0FBUCxHQUFzQixRQUF6QixDQUFtQyxDQUNqQ0EsVUFBVSxDQUFHcDhDLEdBQUcsQ0FBQ2duQyxrQkFBSixDQUF1Qm9WLFVBQXZCLENBQWIsQ0FDRCxDQUNELEdBQUl6dEIsS0FBSSxDQUFHcHZCLEtBQUssQ0FBQ2lkLEVBQU4sQ0FBU21TLElBQVQsQ0FBY3B3QixNQUFkLEVBQVgsQ0FDQW93QixJQUFJLENBQUN4YixNQUFMLENBQVkwQixJQUFJLENBQUMrRCxLQUFMLENBQVc1WSxHQUFHLENBQUNxbkMsaUJBQUosQ0FBc0IrVSxVQUF0QixDQUFYLEVBQThDNTBDLFFBQTlDLEVBQVosRUFDQTh4QyxVQUFVLENBQUczcUIsSUFBSSxDQUFDdlAsTUFBTCxHQUFjNVgsUUFBZCxFQUFiLENBQ0QsQ0FSRCxJQVFPLENBQ0w7QUFDQTtBQUNBO0FBQ0E4eEMsVUFBVSxDQUFHLzVDLEtBQUssQ0FBQy9CLE1BQU4sQ0FBYWdLLFFBQWIsQ0FBc0IsRUFBdEIsQ0FBYixDQUNELENBQ0YsQ0FFRCxHQUFJcWhDLE1BQUssQ0FBRyxFQUFaLENBQ0EsR0FBR3lRLFVBQVUsR0FBSyxJQUFsQixDQUF3QixDQUN0QnpRLEtBQUssQ0FBQzNrQyxJQUFOLENBQ0U7QUFDQTJRLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEO0FBQ0FyQixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUFpRCxLQUFqRCxDQUNFYixJQUFJLENBQUNrRSxRQUFMLENBQWMvWSxHQUFHLENBQUNvYyxJQUFKLENBQVNrOUIsVUFBdkIsRUFBbUM5eEMsUUFBbkMsRUFERixDQUYwRCxDQUkxRDtBQUNBcU4sSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWdCLEdBQTVDLENBQWlELElBQWpELENBQXVELENBQ3JEdEIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FBNUMsQ0FBeUQsS0FBekQsQ0FDRThqQyxVQURGLENBRHFELENBQXZELENBTDBELENBQTVELENBRkYsRUFZRCxDQUNELEdBQUcsZ0JBQWtCamlELFFBQXJCLENBQThCLENBQzVCd3hDLEtBQUssQ0FBQzNrQyxJQUFOLENBQ0U7QUFDQTJRLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEO0FBQ0FyQixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUFpRCxLQUFqRCxDQUNFYixJQUFJLENBQUNrRSxRQUFMLENBQWMvWSxHQUFHLENBQUNvYyxJQUFKLENBQVNvOUIsWUFBdkIsRUFBcUNoeUMsUUFBckMsRUFERixDQUYwRCxDQUkxRDtBQUNBcU4sSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWdCLEdBQTVDLENBQWlELElBQWpELENBQXVELENBQ3JEdEIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVXFCLFNBQTVDLENBQXVELEtBQXZELENBQ0VuZixPQUFPLENBQUNtaUQsWUFEVixDQURxRCxDQUF2RCxDQUwwRCxDQUE1RCxDQUZGLEVBWUQsQ0FFRCxHQUFHM1EsS0FBSyxDQUFDNXdDLE1BQU4sQ0FBZSxDQUFsQixDQUFxQixDQUNuQmtrRCxRQUFRLENBQUd0bkMsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWdCLEdBQTVDLENBQWlELElBQWpELENBQXVEMHlCLEtBQXZELENBQVgsQ0FDRCxDQUVEO0FBQ0EsR0FBSXdULFNBQVEsQ0FBRyxFQUFmLENBRUE7QUFDQSxHQUFJM0wsTUFBSyxDQUFHLEVBQVosQ0FDQSxHQUFHdEosSUFBSSxHQUFLLElBQVosQ0FBa0IsQ0FDaEIsR0FBRzduQyxLQUFLLENBQUN3RCxJQUFOLENBQVdtQyxPQUFYLENBQW1Ca2lDLElBQW5CLENBQUgsQ0FBNkIsQ0FDM0JzSixLQUFLLENBQUd0SixJQUFSLENBQ0QsQ0FGRCxJQUVPLENBQ0xzSixLQUFLLENBQUcsQ0FBQ3RKLElBQUQsQ0FBUixDQUNELENBQ0YsQ0FFRCxHQUFJa1YsYUFBWSxDQUFHLEVBQW5CLENBQ0EsSUFBSSxHQUFJOTZDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR2t2QyxLQUFLLENBQUN6NEMsTUFBekIsQ0FBaUMsRUFBRXVKLENBQW5DLENBQXNDLENBQ3BDO0FBQ0E0bEMsSUFBSSxDQUFHc0osS0FBSyxDQUFDbHZDLENBQUQsQ0FBWixDQUNBLEdBQUcsTUFBTzRsQyxLQUFQLEdBQWdCLFFBQW5CLENBQTZCLENBQzNCQSxJQUFJLENBQUdwbkMsR0FBRyxDQUFDZ25DLGtCQUFKLENBQXVCSSxJQUF2QixDQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUltVixhQUFZLENBQUkvNkMsQ0FBQyxHQUFLLENBQVAsQ0FBWTI2QyxRQUFaLENBQXVCOTRDLFNBQTFDLENBQ0EsR0FBSXk0QyxTQUFRLENBQUc5N0MsR0FBRyxDQUFDcW5DLGlCQUFKLENBQXNCRCxJQUF0QixDQUFmLENBQ0EsR0FBSW9WLFlBQVcsQ0FDYjNuQyxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjL1ksR0FBRyxDQUFDb2MsSUFBSixDQUFTdS9CLE9BQXZCLEVBQWdDbjBDLFFBQWhDLEVBREYsQ0FGMEQsQ0FJMUQ7QUFDQXFOLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0QsQ0FDaEQ7QUFDQUosSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBYy9ZLEdBQUcsQ0FBQ29jLElBQUosQ0FBU3kvQixlQUF2QixFQUF3Q3IwQyxRQUF4QyxFQURGLENBRjBELENBSTFEO0FBQ0FxTixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hESixJQUFJLENBQUN0VyxNQUFMLENBQ0VzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEYixDQUN3QkYsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRGxDLENBQytDLEtBRC9DLENBRUVYLElBQUksQ0FBQytELEtBQUwsQ0FBV2tqQyxRQUFYLEVBQXFCdDBDLFFBQXJCLEVBRkYsQ0FEZ0QsQ0FBbEQsQ0FMMEQsQ0FBNUQsQ0FGZ0QsQ0FBbEQsQ0FMMEQsQ0FpQjFEO0FBQ0ErMEMsWUFsQjBELENBQTVELENBREYsQ0FxQkFELFlBQVksQ0FBQ3A0QyxJQUFiLENBQWtCczRDLFdBQWxCLEVBQ0QsQ0FFRCxHQUFHRixZQUFZLENBQUNya0QsTUFBYixDQUFzQixDQUF6QixDQUE0QixDQUMxQjtBQUNBLEdBQUl3a0QsaUJBQWdCLENBQUc1bkMsSUFBSSxDQUFDdFcsTUFBTCxDQUNyQnNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURVLENBQ0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQURYLENBQ3FCLElBRHJCLENBQzJCb21DLFlBRDNCLENBQXZCLENBR0E7QUFDQSxHQUFJSSxPQUFNLENBQ1I7QUFDQTduQyxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRTtBQUNBYixJQUFJLENBQUNrRSxRQUFMLENBQWMvWSxHQUFHLENBQUNvYyxJQUFKLENBQVMvaUIsSUFBdkIsRUFBNkJtTyxRQUE3QixFQUZGLENBRjBELENBSzFEO0FBQ0FxTixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hESixJQUFJLENBQUN0VyxNQUFMLENBQ0VzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEYixDQUN3QkYsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRGxDLENBQytDLEtBRC9DLENBRUVYLElBQUksQ0FBQytELEtBQUwsQ0FBVzZqQyxnQkFBWCxFQUE2QmoxQyxRQUE3QixFQUZGLENBRGdELENBQWxELENBTjBELENBQTVELENBRkYsQ0FjQTYwQyxRQUFRLENBQUNuNEMsSUFBVCxDQUFjdzRDLE1BQWQsRUFDRCxDQUVEO0FBQ0EsR0FBSWhCLE9BQU0sQ0FBRyxJQUFiLENBQ0EsR0FBR2xpRCxHQUFHLEdBQUssSUFBWCxDQUFpQixDQUNmO0FBQ0EsR0FBSW1qRCxPQUFNLENBQUczOEMsR0FBRyxDQUFDMGtCLGlCQUFKLENBQXNCMWtCLEdBQUcsQ0FBQ3FsQixnQkFBSixDQUFxQjdyQixHQUFyQixDQUF0QixDQUFiLENBQ0EsR0FBR2l6QixRQUFRLEdBQUssSUFBaEIsQ0FBc0IsQ0FDcEI7QUFDQWl2QixNQUFNLENBQUc3bUMsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDbkU7QUFDQXJCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBYy9ZLEdBQUcsQ0FBQ29jLElBQUosQ0FBU3MvQixNQUF2QixFQUErQmwwQyxRQUEvQixFQURGLENBRm1FLENBSW5FO0FBQ0FxTixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hEO0FBQ0EwbkMsTUFGZ0QsQ0FBbEQsQ0FMbUUsQ0FTbkU7QUFDQVIsUUFWbUUsQ0FBNUQsQ0FBVCxDQVlELENBZEQsSUFjTyxDQUNMO0FBQ0FULE1BQU0sQ0FBRzdtQyxJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUNuRTtBQUNBckIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjL1ksR0FBRyxDQUFDb2MsSUFBSixDQUFTcS9CLG1CQUF2QixFQUE0Q2owQyxRQUE1QyxFQURGLENBRm1FLENBSW5FO0FBQ0FxTixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hEO0FBQ0FqVixHQUFHLENBQUN3c0IscUJBQUosQ0FBMEJtd0IsTUFBMUIsQ0FBa0Nsd0IsUUFBbEMsQ0FBNENwMUIsT0FBNUMsQ0FGZ0QsQ0FBbEQsQ0FMbUUsQ0FTbkU7QUFDQThrRCxRQVZtRSxDQUE1RCxDQUFULENBWUQsQ0FFRDtBQUNBLEdBQUlTLGdCQUFlLENBQ2pCL25DLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQUN3bEMsTUFBRCxDQUE1RCxDQURGLENBR0E7QUFDQSxHQUFJbUIsTUFBSyxDQUNQO0FBQ0Fob0MsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0U7QUFDQWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjL1ksR0FBRyxDQUFDb2MsSUFBSixDQUFTL2lCLElBQXZCLEVBQTZCbU8sUUFBN0IsRUFGRixDQUYwRCxDQUsxRDtBQUNBcU4sSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxJQUE1QyxDQUFrRCxDQUNoREosSUFBSSxDQUFDdFcsTUFBTCxDQUNFc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRGIsQ0FDd0JGLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQURsQyxDQUMrQyxLQUQvQyxDQUVFWCxJQUFJLENBQUMrRCxLQUFMLENBQVdna0MsZUFBWCxFQUE0QnAxQyxRQUE1QixFQUZGLENBRGdELENBQWxELENBTjBELENBQTVELENBRkYsQ0FjQTYwQyxRQUFRLENBQUNuNEMsSUFBVCxDQUFjMjRDLEtBQWQsRUFDRCxDQUVEO0FBQ0EsR0FBSUMsS0FBSSxDQUFHam9DLElBQUksQ0FBQ3RXLE1BQUwsQ0FDVHNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURGLENBQ2FGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUR2QixDQUNpQyxJQURqQyxDQUN1Q21tQyxRQUR2QyxDQUFYLENBR0EsR0FBSVUsUUFBSixDQUNBLEdBQUcxbEQsT0FBTyxDQUFDNGtELE1BQVgsQ0FBbUIsQ0FDakI7QUFDQSxHQUFJdHRCLEtBQUksQ0FBR3B2QixLQUFLLENBQUNpZCxFQUFOLENBQVNtUyxJQUFULENBQWNwd0IsTUFBZCxFQUFYLENBQ0EsR0FBSTA3QyxRQUFPLENBQUcsR0FBSTE2QyxNQUFLLENBQUN3RCxJQUFOLENBQVcyQyxVQUFmLENBQ1puRyxLQUFLLENBQUMvQixNQUFOLENBQWFnSyxRQUFiLENBQXNCblEsT0FBTyxDQUFDcTFCLFFBQTlCLENBRFksQ0FBZCxDQUVBLEdBQUlya0IsTUFBSyxDQUFHaFIsT0FBTyxDQUFDZ1IsS0FBcEIsQ0FDQTtBQUNBLEdBQUk3TyxJQUFHLENBQUc2K0MsR0FBRyxDQUFDcDFCLFdBQUosQ0FBZ0J3SixRQUFoQixDQUEwQnd0QixPQUExQixDQUFtQyxDQUFuQyxDQUFzQzV4QyxLQUF0QyxDQUE2QyxFQUE3QyxDQUFWLENBQ0EsR0FBSXl4QyxJQUFHLENBQUd2NkMsS0FBSyxDQUFDbzNCLElBQU4sQ0FBV3A0QixNQUFYLEVBQVYsQ0FDQXU3QyxHQUFHLENBQUMzc0MsS0FBSixDQUFVd2hCLElBQVYsQ0FBZ0JuMUIsR0FBaEIsRUFDQXNnRCxHQUFHLENBQUMzbUMsTUFBSixDQUFXMEIsSUFBSSxDQUFDK0QsS0FBTCxDQUFXa2tDLElBQVgsRUFBaUJ0MUMsUUFBakIsRUFBWCxFQUNBLEdBQUk0eUMsU0FBUSxDQUFHTixHQUFHLENBQUN4aUIsTUFBSixFQUFmLENBQ0F5bEIsT0FBTyxDQUFHbG9DLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQ3BFO0FBQ0FyQixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBYy9ZLEdBQUcsQ0FBQ29jLElBQUosQ0FBU3VTLElBQXZCLEVBQTZCbm5CLFFBQTdCLEVBREYsQ0FGMEQsQ0FJMUQ7QUFDQXFOLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVNLElBQTVDLENBQWtELEtBQWxELENBQXlELEVBQXpELENBTDBELENBQTVELENBRjBELENBUzFEO0FBQ0FaLElBQUksQ0FBQ3RXLE1BQUwsQ0FDRXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURiLENBQ3dCRixJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FEbEMsQ0FFRSxLQUZGLENBRVM0a0MsUUFBUSxDQUFDNXlDLFFBQVQsRUFGVCxDQVYwRCxDQUE1RCxDQUZvRSxDQWdCcEU7QUFDQXFOLElBQUksQ0FBQ3RXLE1BQUwsQ0FDRXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURiLENBQ3dCRixJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FEbEMsQ0FDK0MsS0FEL0MsQ0FDc0R5a0MsT0FBTyxDQUFDenlDLFFBQVIsRUFEdEQsQ0FqQm9FLENBbUJwRTtBQUNBcU4sSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRVQsSUFBSSxDQUFDcUcsWUFBTCxDQUFrQjdTLEtBQWxCLEVBQXlCYixRQUF6QixFQURGLENBcEJvRSxDQUE1RCxDQUFWLENBd0JELENBRUQ7QUFDQSxNQUFPcU4sS0FBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDakU7QUFDQXJCLElBQUksQ0FBQ3RXLE1BQUwsQ0FBWXNXLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0VULElBQUksQ0FBQ3FHLFlBQUwsQ0FBa0IsQ0FBbEIsRUFBcUIxVCxRQUFyQixFQURGLENBRmlFLENBSWpFO0FBQ0FxTixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDdFcsTUFBTCxDQUFZc1csSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRTtBQUNBYixJQUFJLENBQUNrRSxRQUFMLENBQWMvWSxHQUFHLENBQUNvYyxJQUFKLENBQVMvaUIsSUFBdkIsRUFBNkJtTyxRQUE3QixFQUZGLENBRjBELENBSzFEO0FBQ0FxTixJQUFJLENBQUN0VyxNQUFMLENBQVlzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hESixJQUFJLENBQUN0VyxNQUFMLENBQ0VzVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEYixDQUN3QkYsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRGxDLENBQytDLEtBRC9DLENBRUVYLElBQUksQ0FBQytELEtBQUwsQ0FBV2trQyxJQUFYLEVBQWlCdDFDLFFBQWpCLEVBRkYsQ0FEZ0QsQ0FBbEQsQ0FOMEQsQ0FBNUQsQ0FMaUUsQ0FpQmpFdTFDLE9BakJpRSxDQUE1RCxDQUFQLENBbUJELENBdlFELENBeVFBOzs7Ozs7Ozs7Ozs7R0FhQTFFLEdBQUcsQ0FBQ3AxQixXQUFKLENBQWtCMWpCLEtBQUssQ0FBQzZzQixHQUFOLENBQVV1QixpQkFBNUIsQ0FHQSxLQUFPLENBOTVsQkcsQ0ErNWxCVixRQS81bEJVLENBZzZsQlYsS0FBTyxTQUFTMXNCLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZHQSxHQUFJL0IsTUFBSyxDQUFHK0IsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQTtBQUNBLEdBQUl1VCxLQUFJLENBQUd0VixLQUFLLENBQUNzVixJQUFqQixDQUVBO0FBQ0EsR0FBSW1vQyxJQUFHLENBQUcvN0MsTUFBTSxDQUFDRCxPQUFQLENBQWlCekIsS0FBSyxDQUFDMDlDLFNBQU4sQ0FBa0IxOUMsS0FBSyxDQUFDMDlDLFNBQU4sRUFBbUIsRUFBaEUsQ0FDQTE5QyxLQUFLLENBQUNvN0MsS0FBTixDQUFjcDdDLEtBQUssQ0FBQ283QyxLQUFOLEVBQWUsRUFBN0IsQ0FDQXA3QyxLQUFLLENBQUNvN0MsS0FBTixDQUFZOWxDLElBQVosQ0FBbUJtb0MsR0FBbkIsQ0FFQSxHQUFJekUscUJBQW9CLENBQUcsQ0FDekJ6aEQsSUFBSSxDQUFFLGFBRG1CLENBRXpCMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRkksQ0FHekI3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIUyxDQUl6QlEsV0FBVyxDQUFFLElBSlksQ0FLekIzRixLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLHlCQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsYUFMSCxDQUFELENBTUosQ0FDRHprQixJQUFJLENBQUUscUJBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRC9HLElBQUksQ0FBRSxDQUhMLENBSUR3SSxXQUFXLENBQUUsSUFKWixDQUtEOEUsUUFBUSxDQUFFLElBTFQsQ0FNREMsV0FBVyxDQUFFLFNBTlosQ0FOSSxDQUxrQixDQUEzQixDQW9CQXVoQyxHQUFHLENBQUN6RSxvQkFBSixDQUEyQkEsb0JBQTNCLENBRUEsR0FBSTJFLDhCQUE2QixDQUFHLENBQ2xDcG1ELElBQUksQ0FBRSxzQkFENEIsQ0FFbEMyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGYSxDQUdsQzdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhrQixDQUlsQ1EsV0FBVyxDQUFFLElBSnFCLENBS2xDM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSxrQ0FEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGFBTEgsQ0FBRCxDQU1KLENBQ0R6a0IsSUFBSSxDQUFFLGlEQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhmLENBSURRLFdBQVcsQ0FBRSxJQUpaLENBS0QzRixLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLDJEQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsY0FMSCxDQUFELENBTUosQ0FDRHprQixJQUFJLENBQUUsMkRBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEMEcsV0FBVyxDQUFFLGNBSFosQ0FOSSxDQUxOLENBTkksQ0FzQkosQ0FDRDNrQixJQUFJLENBQUUsdUNBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRC9HLElBQUksQ0FBRSxDQUhMLENBSUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQkFxTixPQUFPLENBQUUsa0JBOUJSLENBK0JERSxXQUFXLENBQUUsc0JBL0JaLENBdEJJLENBTDJCLENBQXBDLENBOERBdWhDLEdBQUcsQ0FBQ0csc0JBQUosQ0FBNkIsQ0FDM0JybUQsSUFBSSxDQUFFLGVBRHFCLENBRTNCMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRk0sQ0FHM0I3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIVyxDQUkzQlEsV0FBVyxDQUFFLElBSmMsQ0FLM0IzRixLQUFLLENBQUUsQ0FBQyxDQUNOamEsSUFBSSxDQUFFLHVCQURBLENBRU4yZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSFYsQ0FJTm9CLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsU0FMSCxDQUFELENBTUosQ0FDRHprQixJQUFJLENBQUUsOEJBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVnQixHQUhmLENBSURPLFdBQVcsQ0FBRSxJQUpaLENBS0QrRSxXQUFXLENBQUUsZ0JBTFosQ0FOSSxFQVlKc1gsTUFaSSxDQVlHbXFCLDZCQVpILENBTG9CLENBQTdCLENBb0JBRixHQUFHLENBQUNwQyxzQkFBSixDQUE2QixDQUMzQjlqRCxJQUFJLENBQUUsZUFEcUIsQ0FFM0IyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGTSxDQUczQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhXLENBSTNCUSxXQUFXLENBQUUsSUFKYyxDQUszQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsdUJBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIVixDQUlOb0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxTQUxILENBQUQsRUFNSndYLE1BTkksQ0FNR21xQiw2QkFOSCxDQUxvQixDQUE3QixDQWNBLEdBQUlFLGdCQUFlLENBQUcsQ0FDcEJ0bUQsSUFBSSxDQUFFLFlBRGMsQ0FFcEIyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGRCxDQUdwQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhJLENBSXBCUSxXQUFXLENBQUUsSUFKTyxDQUtwQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsb0JBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIVixDQUlOb0IsV0FBVyxDQUFFLEtBSlAsQ0FBRCxDQUtKLENBQ0Q1ZixJQUFJLENBQUUsa0NBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGYsQ0FJRFEsV0FBVyxDQUFFLElBSlosQ0FLRDNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUseUNBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIVixDQUlOUSxXQUFXLENBQUUsSUFKUCxDQUtOK0UsV0FBVyxDQUFFLFFBTFAsQ0FBRCxDQU1KLENBQ0Qza0IsSUFBSSxDQUFFLCtDQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUhmLENBSURvQixXQUFXLENBQUUsS0FKWixDQUtENkUsT0FBTyxDQUFFLFFBTFIsQ0FOSSxDQUxOLENBTEksQ0F1QkosQ0FDRHprQixJQUFJLENBQUUsNEJBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGYsQ0FJRFEsV0FBVyxDQUFFLElBSlosQ0FLRDNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsc0NBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxpQkFMSCxDQUFELENBTUosQ0FDRHprQixJQUFJLENBQUUsc0NBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEMkIsV0FBVyxDQUFFLEtBSFosQ0FJRCtFLFdBQVcsQ0FBRSxpQkFKWixDQUtERCxRQUFRLENBQUUsSUFMVCxDQU5JLENBTE4sQ0F2QkksQ0F5Q0osQ0FDRDFrQixJQUFJLENBQUUsb0NBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRC9HLElBQUksQ0FBRSxDQUhMLENBSUR3SSxXQUFXLENBQUUsSUFKWixDQUtEOEUsUUFBUSxDQUFFLElBTFQsQ0FNREQsT0FBTyxDQUFFLHlCQU5SLENBekNJLENBZ0RKLENBQ0R6a0IsSUFBSSxDQUFFLHNDQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhmLENBSURRLFdBQVcsQ0FBRSxJQUpaLENBS0Q2RSxPQUFPLENBQUUsb0JBTFIsQ0FoREksQ0FzREosQ0FDRHprQixJQUFJLENBQUUsNEJBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBSGYsQ0FJRGtCLFdBQVcsQ0FBRSxLQUpaLENBS0Q2RSxPQUFPLENBQUUsV0FMUixDQXRESSxDQTRESixDQUNEemtCLElBQUksQ0FBRSxzQ0FETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUZwQixDQUdEL0csSUFBSSxDQUFFLENBSEwsQ0FJRHdJLFdBQVcsQ0FBRSxJQUpaLENBS0Q4RSxRQUFRLENBQUUsSUFMVCxDQU1ERCxPQUFPLENBQUUsMkJBTlIsQ0E1REksQ0FMYSxDQUF0QixDQTJFQXloQyxHQUFHLENBQUNLLG1CQUFKLENBQTBCLENBQ3hCdm1ELElBQUksQ0FBRSxZQURrQixDQUV4QjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZHLENBR3hCN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSFEsQ0FJeEJRLFdBQVcsQ0FBRSxJQUpXLENBS3hCM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSxvQkFEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUhWLENBSU5vQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLFNBTEgsQ0FBRCxDQU1KLENBQ0R6a0IsSUFBSSxDQUFFLDZCQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FIZixDQUlETyxXQUFXLENBQUUsSUFKWixDQUtEK0UsV0FBVyxDQUFFLGtCQUxaLENBTkksQ0FhUDg4QixvQkFiTyxDQWNQLENBQ0V6aEQsSUFBSSxDQUFFLHlCQURSLENBRUUyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRnZCLENBR0UvRyxJQUFJLENBQUUsQ0FIUixDQUlFc04sUUFBUSxDQUFFLElBSlosQ0FLRUMsV0FBVyxDQUFFLGNBTGYsQ0FkTyxDQW9CSixDQUNEM2tCLElBQUksQ0FBRSx1Q0FETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUZwQixDQUdEL0csSUFBSSxDQUFFLENBSEwsQ0FJRHNOLFFBQVEsQ0FBRSxJQUpULENBS0RDLFdBQVcsQ0FBRSxNQUxaLENBcEJJLENBMEJKLENBQ0Qza0IsSUFBSSxDQUFFLHdCQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FIZixDQUlEb0YsT0FBTyxDQUFFLGFBSlIsQ0FLREMsUUFBUSxDQUFFLElBTFQsQ0FNRHpLLEtBQUssQ0FBRSxDQUFDcXNDLGVBQUQsQ0FOTixDQTFCSSxDQUxpQixDQUExQixDQXlDQUosR0FBRyxDQUFDTSxzQkFBSixDQUE2QixDQUMzQnhtRCxJQUFJLENBQUUsZUFEcUIsQ0FFM0IyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGTSxDQUczQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhXLENBSTNCUSxXQUFXLENBQUUsSUFKYyxDQUszQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05qYSxJQUFJLENBQUUsdUJBREEsQ0FFTjJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIVixDQUlOb0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxTQUxILENBQUQsQ0FNSixDQUNEemtCLElBQUksQ0FBRSwrQkFETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIZixDQUlEUSxXQUFXLENBQUUsSUFKWixDQUtEM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSxzQ0FEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhWLENBSU5RLFdBQVcsQ0FBRSxJQUpQLENBS04rRSxXQUFXLENBQUUsUUFMUCxDQUFELENBTUosQ0FDRDNrQixJQUFJLENBQUUsNENBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSGYsQ0FJRG9CLFdBQVcsQ0FBRSxLQUpaLENBS0Q2RSxPQUFPLENBQUUsUUFMUixDQU5JLENBTE4sQ0FOSSxDQXdCSixDQUNEemtCLElBQUksQ0FBRSxzQ0FETCxDQUVEMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIZixDQUlEUSxXQUFXLENBQUUsSUFKWixDQUtEM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmphLElBQUksQ0FBRSxnREFEQSxDQUVOMmYsUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGNBTEgsQ0FBRCxDQU1KLENBQ0R6a0IsSUFBSSxDQUFFLGdEQURMLENBRUQyZixRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDJCLFdBQVcsQ0FBRSxLQUhaLENBSUQrRSxXQUFXLENBQUUsY0FKWixDQU5JLENBTE4sQ0F4QkksQ0F5Q0osQ0FDRDNrQixJQUFJLENBQUUsNEJBREwsQ0FFRDJmLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBSGYsQ0FJRGtCLFdBQVcsQ0FBRSxLQUpaLENBS0Q2RSxPQUFPLENBQUUsUUFMUixDQXpDSSxDQUxvQixDQUE3QixDQXdEQSxLQUFPLENBN3ptQkcsQ0E4em1CVixRQTl6bUJVLENBK3ptQlYsS0FBTyxTQUFTdGEsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7O0dBT0EsR0FBSS9CLE1BQUssQ0FBRytCLG1CQUFtQixDQUFDLENBQUQsQ0FBL0IsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUVBTCxNQUFNLENBQUNELE9BQVAsQ0FBaUJ6QixLQUFLLENBQUNvbkMsR0FBTixDQUFZcG5DLEtBQUssQ0FBQ29uQyxHQUFOLEVBQWEsRUFBMUMsQ0FDQXBuQyxLQUFLLENBQUNvbkMsR0FBTixDQUFVNFAsSUFBVixDQUFpQmgzQyxLQUFLLENBQUNnM0MsSUFBdkIsQ0FHQSxLQUFPLENBLzBtQkcsQ0FnMW1CVixRQWgxbUJVLENBaTFtQlYsS0FBTyxTQUFTdDFDLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7Ozs7O0dBU0EsR0FBSS9CLE1BQUssQ0FBRytCLG1CQUFtQixDQUFDLENBQUQsQ0FBL0IsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUVBL0IsS0FBSyxDQUFDb25DLEdBQU4sQ0FBWXBuQyxLQUFLLENBQUNvbkMsR0FBTixFQUFhLEVBQXpCLENBQ0EsR0FBSTRQLEtBQUksQ0FBR3QxQyxNQUFNLENBQUNELE9BQVAsQ0FBaUJ6QixLQUFLLENBQUNvbkMsR0FBTixDQUFVNFAsSUFBVixDQUFpQmgzQyxLQUFLLENBQUNnM0MsSUFBTixDQUFhaDNDLEtBQUssQ0FBQ2czQyxJQUFOLEVBQWMsRUFBeEUsQ0FFQTs7Ozs7O0dBT0FBLElBQUksQ0FBQ2g0QyxNQUFMLENBQWMsU0FBU2llLEVBQVQsQ0FBYSxDQUN6QixHQUFJbXFCLElBQUcsQ0FBRyxDQUNSOzs7Ozs7T0FPQWxuQyxRQUFRLENBQUUsa0JBQVN3ZCxJQUFULENBQWUrMEIsT0FBZixDQUF3QixDQUNoQyx5Q0FDQSxHQUFJNW1DLEVBQUMsQ0FBRyxHQUFJN0wsTUFBSyxDQUFDd0QsSUFBTixDQUFXMkMsVUFBZixFQUFSLENBRUEsc0VBQ0EsR0FBSW9ELElBQUcsQ0FBR3ZMLElBQUksQ0FBQ3lNLElBQUwsQ0FBVWdvQyxPQUFPLENBQUd4MUIsRUFBRSxDQUFDcVMsWUFBdkIsQ0FBVixDQUNBLElBQUksR0FBSXJ0QixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdzSCxHQUFuQixDQUF3QnRILENBQUMsRUFBekIsQ0FBNkIsQ0FDM0IsZ0VBQ0EsR0FBSUksRUFBQyxDQUFHLEdBQUlyQyxNQUFLLENBQUN3RCxJQUFOLENBQVcyQyxVQUFmLEVBQVIsQ0FDQTlELENBQUMsQ0FBQ3FGLFFBQUYsQ0FBV3pGLENBQVgsRUFFQTt1QkFFQWdiLEVBQUUsQ0FBQ3JQLEtBQUgsR0FDQXFQLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVThKLElBQUksQ0FBR3JiLENBQUMsQ0FBQzRGLFFBQUYsRUFBakIsRUFDQTRELENBQUMsQ0FBQzdELFNBQUYsQ0FBWWlWLEVBQUUsQ0FBQzRDLE1BQUgsRUFBWixFQUNELENBRUQsc0VBQ0FoVSxDQUFDLENBQUN2QyxRQUFGLENBQVd1QyxDQUFDLENBQUNuVCxNQUFGLEdBQWErNUMsT0FBeEIsRUFDQSxNQUFPNW1DLEVBQUMsQ0FBQzVELFFBQUYsRUFBUCxDQUNELENBN0JPLENBQVYsQ0FnQ0EsTUFBT20vQixJQUFQLENBQ0QsQ0FsQ0QsQ0FxQ0EsS0FBTyxDQTk0bUJHLENBakVNLENBQWhCLEVBaTltQkMsQ0EzOW1CRCxFIiwiZmlsZSI6ImRpc2NvdXJzZS1jbGllbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcImRpc2NvdXJzZS1jbGllbnRcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZGlzY291cnNlLWNsaWVudFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJkaXNjb3Vyc2UtY2xpZW50XCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBpbnN0YWxsIGEgSlNPTlAgY2FsbGJhY2sgZm9yIGNodW5rIGxvYWRpbmdcbiBcdGZ1bmN0aW9uIHdlYnBhY2tKc29ucENhbGxiYWNrKGRhdGEpIHtcbiBcdFx0dmFyIGNodW5rSWRzID0gZGF0YVswXTtcbiBcdFx0dmFyIG1vcmVNb2R1bGVzID0gZGF0YVsxXTtcblxuXG4gXHRcdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuIFx0XHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcbiBcdFx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMCwgcmVzb2x2ZXMgPSBbXTtcbiBcdFx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG4gXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG4gXHRcdFx0XHRyZXNvbHZlcy5wdXNoKGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSk7XG4gXHRcdFx0fVxuIFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG4gXHRcdH1cbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZihwYXJlbnRKc29ucEZ1bmN0aW9uKSBwYXJlbnRKc29ucEZ1bmN0aW9uKGRhdGEpO1xuXG4gXHRcdHdoaWxlKHJlc29sdmVzLmxlbmd0aCkge1xuIFx0XHRcdHJlc29sdmVzLnNoaWZ0KCkoKTtcbiBcdFx0fVxuXG4gXHR9O1xuXG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4gXHQvLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbiBcdC8vIFByb21pc2UgPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG4gXHR2YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuIFx0XHRcImRpc2NvdXJzZS1jbGllbnQuanNcIjogMFxuIFx0fTtcblxuXG5cbiBcdC8vIHNjcmlwdCBwYXRoIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBqc29ucFNjcmlwdFNyYyhjaHVua0lkKSB7XG4gXHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgKHt9W2NodW5rSWRdfHxjaHVua0lkKSArIFwiLmpzXCJcbiBcdH1cblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG4gXHQvLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3NcbiBcdC8vIFNpbmNlIGFsbCByZWZlcmVuY2VkIGNodW5rcyBhcmUgYWxyZWFkeSBpbmNsdWRlZFxuIFx0Ly8gaW4gdGhpcyBmaWxlLCB0aGlzIGZ1bmN0aW9uIGlzIGVtcHR5IGhlcmUuXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSBmdW5jdGlvbiByZXF1aXJlRW5zdXJlKCkge1xuIFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gXHR9O1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm9lID0gZnVuY3Rpb24oZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgdGhyb3cgZXJyOyB9O1xuXG4gXHR2YXIganNvbnBBcnJheSA9IHdpbmRvd1tcIndlYnBhY2tKc29ucGRpc2NvdXJzZV9jbGllbnRcIl0gPSB3aW5kb3dbXCJ3ZWJwYWNrSnNvbnBkaXNjb3Vyc2VfY2xpZW50XCJdIHx8IFtdO1xuIFx0dmFyIG9sZEpzb25wRnVuY3Rpb24gPSBqc29ucEFycmF5LnB1c2guYmluZChqc29ucEFycmF5KTtcbiBcdGpzb25wQXJyYXkucHVzaCA9IHdlYnBhY2tKc29ucENhbGxiYWNrO1xuIFx0anNvbnBBcnJheSA9IGpzb25wQXJyYXkuc2xpY2UoKTtcbiBcdGZvcih2YXIgaSA9IDA7IGkgPCBqc29ucEFycmF5Lmxlbmd0aDsgaSsrKSB3ZWJwYWNrSnNvbnBDYWxsYmFjayhqc29ucEFycmF5W2ldKTtcbiBcdHZhciBwYXJlbnRKc29ucEZ1bmN0aW9uID0gb2xkSnNvbnBGdW5jdGlvbjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvZGlzY291cnNlLmpzXCIpO1xuIiwiLyohIChjKSBBbmRyZWEgR2lhbW1hcmNoaSAtIElTQyAqL1xudmFyIHNlbGYgPSB0aGlzIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9O1xudHJ5IHtcbiAgKGZ1bmN0aW9uIChVUkxTZWFyY2hQYXJhbXMsIHBsdXMpIHtcbiAgICBpZiAoXG4gICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKCdxPSUyQicpLmdldCgncScpICE9PSBwbHVzIHx8XG4gICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKHtxOiBwbHVzfSkuZ2V0KCdxJykgIT09IHBsdXMgfHxcbiAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoW1sncScsIHBsdXNdXSkuZ2V0KCdxJykgIT09IHBsdXMgfHxcbiAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoJ3E9XFxuJykudG9TdHJpbmcoKSAhPT0gJ3E9JTBBJyB8fFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyh7cTogJyAmJ30pLnRvU3RyaW5nKCkgIT09ICdxPSslMjYnXG4gICAgKVxuICAgICAgdGhyb3cgVVJMU2VhcmNoUGFyYW1zO1xuICAgIHNlbGYuVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xuICB9KFVSTFNlYXJjaFBhcmFtcywgJysnKSk7XG59IGNhdGNoKFVSTFNlYXJjaFBhcmFtcykge1xuICAoZnVuY3Rpb24gKE9iamVjdCwgU3RyaW5nLCBpc0FycmF5KSB7J3VzZSBzdHJpY3QnO1xuICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB2YXIgZmluZCA9IC9bISdcXChcXCl+XXwlMjB8JTAwL2c7XG4gICAgdmFyIHBsdXMgPSAvXFwrL2c7XG4gICAgdmFyIHJlcGxhY2UgPSB7XG4gICAgICAnISc6ICclMjEnLFxuICAgICAgXCInXCI6ICclMjcnLFxuICAgICAgJygnOiAnJTI4JyxcbiAgICAgICcpJzogJyUyOScsXG4gICAgICAnfic6ICclN0UnLFxuICAgICAgJyUyMCc6ICcrJyxcbiAgICAgICclMDAnOiAnXFx4MDAnXG4gICAgfTtcbiAgICB2YXIgcHJvdG8gPSB7XG4gICAgICBhcHBlbmQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGFwcGVuZFRvKHRoaXMuX3VuZ2FwLCBrZXksIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBkZWxldGU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3VuZ2FwW2tleV07XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpID8gdGhpcy5fdW5nYXBba2V5XVswXSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZ2V0QWxsOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpID8gdGhpcy5fdW5nYXBba2V5XS5zbGljZSgwKSA6IFtdO1xuICAgICAgfSxcbiAgICAgIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5IGluIHRoaXMuX3VuZ2FwO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdW5nYXBba2V5XSA9IFtTdHJpbmcodmFsdWUpXTtcbiAgICAgIH0sXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2VsZi5fdW5nYXApXG4gICAgICAgICAgc2VsZi5fdW5nYXBba2V5XS5mb3JFYWNoKGludm9rZSwga2V5KTtcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlKHZhbHVlKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgU3RyaW5nKGtleSksIHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0sXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcXVlcnkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX3VuZ2FwKSB7XG4gICAgICAgICAgdmFyIGVuY29kZWQgPSBlbmNvZGUoa2V5KTtcbiAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3VuZ2FwW2tleV07XG4gICAgICAgICAgICBpIDwgdmFsdWUubGVuZ3RoOyBpKytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHF1ZXJ5LnB1c2goZW5jb2RlZCArICc9JyArIGVuY29kZSh2YWx1ZVtpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnkuam9pbignJicpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIga2V5IGluIHByb3RvKVxuICAgICAgZGVmaW5lUHJvcGVydHkoVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZSwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBwcm90b1trZXldXG4gICAgICB9KTtcbiAgICBzZWxmLlVSTFNlYXJjaFBhcmFtcyA9IFVSTFNlYXJjaFBhcmFtcztcbiAgICBmdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMocXVlcnkpIHtcbiAgICAgIHZhciBkaWN0ID0gY3JlYXRlKG51bGwpO1xuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ191bmdhcCcsIHt2YWx1ZTogZGljdH0pO1xuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgIXF1ZXJ5OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVvZiBxdWVyeSA9PT0gJ3N0cmluZyc6XG4gICAgICAgICAgaWYgKHF1ZXJ5LmNoYXJBdCgwKSA9PT0gJz8nKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAgcGFpcnMgPSBxdWVyeS5zcGxpdCgnJicpLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBwYWlycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFpcnNbaV07XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB2YWx1ZS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICBpZiAoLTEgPCBpbmRleCkge1xuICAgICAgICAgICAgICBhcHBlbmRUbyhcbiAgICAgICAgICAgICAgICBkaWN0LFxuICAgICAgICAgICAgICAgIGRlY29kZSh2YWx1ZS5zbGljZSgwLCBpbmRleCkpLFxuICAgICAgICAgICAgICAgIGRlY29kZSh2YWx1ZS5zbGljZShpbmRleCArIDEpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGgpe1xuICAgICAgICAgICAgICBhcHBlbmRUbyhcbiAgICAgICAgICAgICAgICBkaWN0LFxuICAgICAgICAgICAgICAgIGRlY29kZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaXNBcnJheShxdWVyeSk6XG4gICAgICAgICAgZm9yICh2YXJcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gcXVlcnkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHF1ZXJ5W2ldO1xuICAgICAgICAgICAgYXBwZW5kVG8oZGljdCwgdmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZvckVhY2gnIGluIHF1ZXJ5OlxuICAgICAgICAgIHF1ZXJ5LmZvckVhY2goYWRkRWFjaCwgZGljdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHF1ZXJ5KVxuICAgICAgICAgICAgYXBwZW5kVG8oZGljdCwga2V5LCBxdWVyeVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFYWNoKHZhbHVlLCBrZXkpIHtcbiAgICAgIGFwcGVuZFRvKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBhcHBlbmRUbyhkaWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgcmVzID0gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsJykgOiB2YWx1ZTtcbiAgICAgIGlmIChrZXkgaW4gZGljdClcbiAgICAgICAgZGljdFtrZXldLnB1c2gocmVzKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZGljdFtrZXldID0gW3Jlc107XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UocGx1cywgJyAnKSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKGZpbmQsIHJlcGxhY2VyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlcihtYXRjaCkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VbbWF0Y2hdO1xuICAgIH1cblxuICB9KE9iamVjdCwgU3RyaW5nLCBBcnJheS5pc0FycmF5KSk7XG59XG5cbihmdW5jdGlvbiAoVVJMU2VhcmNoUGFyYW1zUHJvdG8pIHtcblxuICB2YXIgaXRlcmFibGUgPSBmYWxzZTtcbiAgdHJ5IHsgaXRlcmFibGUgPSAhIVN5bWJvbC5pdGVyYXRvcjsgfSBjYXRjaCAob19PKSB7fVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghKCdmb3JFYWNoJyBpbiBVUkxTZWFyY2hQYXJhbXNQcm90bykpIHtcbiAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMudG9TdHJpbmcoKVxuICAgICAgICAgIC5yZXBsYWNlKC89W1xcc1xcU10qPyg/OiZ8JCkvZywgJz0nKVxuICAgICAgICAgIC5zcGxpdCgnPScpXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghbmFtZS5sZW5ndGggfHwgbmFtZSBpbiBuYW1lcylcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgKG5hbWVzW25hbWVdID0gc2VsZi5nZXRBbGwobmFtZSkpLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ2tleXMnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgdGhpcy5wdXNoKGtleSk7IH0pO1xuICAgIH07XG4gIH1cblxuICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ3ZhbHVlcycgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8udmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgdGhpcy5wdXNoKHZhbHVlKTsgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghKCdlbnRyaWVzJyBpbiBVUkxTZWFyY2hQYXJhbXNQcm90bykpIHtcbiAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7IHRoaXMucHVzaChba2V5LCB2YWx1ZV0pOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGl0ZXJhYmxlICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvW1N5bWJvbC5pdGVyYXRvcl0gPSBVUkxTZWFyY2hQYXJhbXNQcm90by5lbnRyaWVzO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ3NvcnQnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLnNvcnQgPSBmdW5jdGlvbiBzb3J0KCkge1xuICAgICAgdmFyXG4gICAgICAgIGVudHJpZXMgPSB0aGlzLmVudHJpZXMoKSxcbiAgICAgICAgZW50cnkgPSBlbnRyaWVzLm5leHQoKSxcbiAgICAgICAgZG9uZSA9IGVudHJ5LmRvbmUsXG4gICAgICAgIGtleXMgPSBbXSxcbiAgICAgICAgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgaSwga2V5LCB2YWx1ZVxuICAgICAgO1xuICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgIHZhbHVlID0gZW50cnkudmFsdWU7XG4gICAgICAgIGtleSA9IHZhbHVlWzBdO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgaWYgKCEoa2V5IGluIHZhbHVlcykpIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1trZXldLnB1c2godmFsdWVbMV0pO1xuICAgICAgICBlbnRyeSA9IGVudHJpZXMubmV4dCgpO1xuICAgICAgICBkb25lID0gZW50cnkuZG9uZTtcbiAgICAgIH1cbiAgICAgIC8vIG5vdCB0aGUgY2hhbXBpb24gaW4gZWZmaWNpZW5jeVxuICAgICAgLy8gYnV0IHRoZXNlIHR3byBiaXRzIGp1c3QgZG8gdGhlIGpvYlxuICAgICAga2V5cy5zb3J0KCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRlbGV0ZShrZXlzW2ldKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHRoaXMuYXBwZW5kKGtleSwgdmFsdWVzW2tleV0uc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yKHNlbGYsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgc2VsZi5mb3JFYWNoKGNhbGxiYWNrLCBpdGVtcyk7XG4gICAgcmV0dXJuIGl0ZXJhYmxlID9cbiAgICAgIGl0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKSA6XG4gICAgICB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgICB9XG4gICAgICB9O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKGZ1bmN0aW9uIChPYmplY3QpIHtcbiAgICB2YXJcbiAgICAgIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICBjcmVhdGVTZWFyY2hQYXJhbXNQb2xsdXRlID0gZnVuY3Rpb24gKHNlYXJjaCkge1xuICAgICAgICBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5hcHBlbmQuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICBzZWFyY2guc2V0LmNhbGwodGhpcy5fdXNwLCBuYW1lID8gKCc/JyArIG5hbWUpIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlbChuYW1lKSB7XG4gICAgICAgICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uZGVsZXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICBzZWFyY2guc2V0LmNhbGwodGhpcy5fdXNwLCBuYW1lID8gKCc/JyArIG5hbWUpIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLnNldC5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLl91c3AsIG5hbWUgPyAoJz8nICsgbmFtZSkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzcCwgdmFsdWUpIHtcbiAgICAgICAgICBzcC5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICAgICAgc3AuZGVsZXRlID0gZGVsO1xuICAgICAgICAgIHNwLnNldCA9IHNldDtcbiAgICAgICAgICByZXR1cm4gZFAoc3AsICdfdXNwJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTZWFyY2hQYXJhbXNDcmVhdGUgPSBmdW5jdGlvbiAocG9sbHV0ZVNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgc3ApIHtcbiAgICAgICAgICBkUChcbiAgICAgICAgICAgIG9iaiwgJ19zZWFyY2hQYXJhbXMnLCB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiBwb2xsdXRlU2VhcmNoUGFyYW1zKHNwLCBvYmopXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gc3A7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdXBkYXRlU2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKHNwKSB7XG4gICAgICAgIHZhciBhcHBlbmQgPSBzcC5hcHBlbmQ7XG4gICAgICAgIHNwLmFwcGVuZCA9IFVSTFNlYXJjaFBhcmFtc1Byb3RvLmFwcGVuZDtcbiAgICAgICAgVVJMU2VhcmNoUGFyYW1zLmNhbGwoc3AsIHNwLl91c3Auc2VhcmNoLnNsaWNlKDEpKTtcbiAgICAgICAgc3AuYXBwZW5kID0gYXBwZW5kO1xuICAgICAgfSxcbiAgICAgIHZlcmlmeVNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uIChvYmosIENsYXNzKSB7XG4gICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIENsYXNzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIidzZWFyY2hQYXJhbXMnIGFjY2Vzc2VkIG9uIGFuIG9iamVjdCB0aGF0IFwiICtcbiAgICAgICAgICBcImRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgXCIgKyBDbGFzcy5uYW1lXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXBncmFkZUNsYXNzID0gZnVuY3Rpb24gKENsYXNzKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgIENsYXNzUHJvdG8gPSBDbGFzcy5wcm90b3R5cGUsXG4gICAgICAgICAgc2VhcmNoUGFyYW1zID0gZ09QRChDbGFzc1Byb3RvLCAnc2VhcmNoUGFyYW1zJyksXG4gICAgICAgICAgaHJlZiA9IGdPUEQoQ2xhc3NQcm90bywgJ2hyZWYnKSxcbiAgICAgICAgICBzZWFyY2ggPSBnT1BEKENsYXNzUHJvdG8sICdzZWFyY2gnKSxcbiAgICAgICAgICBjcmVhdGVTZWFyY2hQYXJhbXNcbiAgICAgICAgO1xuICAgICAgICBpZiAoIXNlYXJjaFBhcmFtcyAmJiBzZWFyY2ggJiYgc2VhcmNoLnNldCkge1xuICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtc0NyZWF0ZShcbiAgICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc1BvbGx1dGUoc2VhcmNoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgICAgICAgICBDbGFzc1Byb3RvLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBocmVmOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaHJlZi5nZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3AgPSB0aGlzLl9zZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgICBocmVmLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzcCkgdXBkYXRlU2VhcmNoUGFyYW1zKHNwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNlYXJjaDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaC5nZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3AgPSB0aGlzLl9zZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgICBzZWFyY2guc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNwKSB1cGRhdGVTZWFyY2hQYXJhbXMoc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2ZXJpZnlTZWFyY2hQYXJhbXModGhpcywgQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaFBhcmFtcyB8fCBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXModGhpcy5zZWFyY2guc2xpY2UoMSkpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3ApIHtcbiAgICAgICAgICAgICAgICAgIHZlcmlmeVNlYXJjaFBhcmFtcyh0aGlzLCBDbGFzcyk7XG4gICAgICAgICAgICAgICAgICBjcmVhdGVTZWFyY2hQYXJhbXModGhpcywgc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA7XG4gICAgdHJ5IHtcbiAgICAgIHVwZ3JhZGVDbGFzcyhIVE1MQW5jaG9yRWxlbWVudCk7XG4gICAgICBpZiAoL15mdW5jdGlvbnxvYmplY3QkLy50ZXN0KHR5cGVvZiBVUkwpICYmIFVSTC5wcm90b3R5cGUpXG4gICAgICAgIHVwZ3JhZGVDbGFzcyhVUkwpO1xuICAgIH0gY2F0Y2ggKG1laCkge31cbiAgfShPYmplY3QpKTtcblxufShzZWxmLlVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUsIE9iamVjdCkpO1xuZXhwb3J0IGRlZmF1bHQgc2VsZi5VUkxTZWFyY2hQYXJhbXM7XG4iLCIvKipcbiAqIEBhdXRob3IgS3VpdG9zXG4gKiBAaG9tZXBhZ2UgaHR0cHM6Ly9naXRodWIuY29tL2t1aXRvcy9cbiAqIEBzaW5jZSAyMDE3LTEwLTEyXG4gKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgTFJVQ2FjaGUgZnJvbSAnbHJ1LWNhY2hlJztcbmltcG9ydCBidWlsZFNvcnRlZFVSTCBmcm9tICcuL3V0aWxzL2J1aWxkU29ydGVkVVJMJztcbmltcG9ydCBpc0NhY2hlTGlrZSBmcm9tICcuL3V0aWxzL2lzQ2FjaGVMaWtlJztcbnZhciBGSVZFX01JTlVURVMgPSAxMDAwICogNjAgKiA1O1xudmFyIENBUEFDSVRZID0gMTAwO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FjaGVBZGFwdGVyRW5oYW5jZXIoYWRhcHRlciwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLmVuYWJsZWRCeURlZmF1bHQsIGVuYWJsZWRCeURlZmF1bHQgPSBfYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9hLCBfYiA9IG9wdGlvbnMuY2FjaGVGbGFnLCBjYWNoZUZsYWcgPSBfYiA9PT0gdm9pZCAwID8gJ2NhY2hlJyA6IF9iLCBfYyA9IG9wdGlvbnMuZGVmYXVsdENhY2hlLCBkZWZhdWx0Q2FjaGUgPSBfYyA9PT0gdm9pZCAwID8gbmV3IExSVUNhY2hlKHsgbWF4QWdlOiBGSVZFX01JTlVURVMsIG1heDogQ0FQQUNJVFkgfSkgOiBfYztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgdXJsID0gY29uZmlnLnVybCwgbWV0aG9kID0gY29uZmlnLm1ldGhvZCwgcGFyYW1zID0gY29uZmlnLnBhcmFtcywgcGFyYW1zU2VyaWFsaXplciA9IGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyLCBmb3JjZVVwZGF0ZSA9IGNvbmZpZy5mb3JjZVVwZGF0ZTtcbiAgICAgICAgdmFyIHVzZUNhY2hlID0gKGNvbmZpZ1tjYWNoZUZsYWddICE9PSB2b2lkIDAgJiYgY29uZmlnW2NhY2hlRmxhZ10gIT09IG51bGwpID8gY29uZmlnW2NhY2hlRmxhZ10gOiBlbmFibGVkQnlEZWZhdWx0O1xuICAgICAgICBpZiAobWV0aG9kID09PSAnZ2V0JyAmJiB1c2VDYWNoZSkge1xuICAgICAgICAgICAgLy8gaWYgaGFkIHByb3ZpZGUgYSBzcGVjaWZpZWQgY2FjaGUsIHRoZW4gdXNlIGl0IGluc3RlYWRcbiAgICAgICAgICAgIHZhciBjYWNoZV8xID0gaXNDYWNoZUxpa2UodXNlQ2FjaGUpID8gdXNlQ2FjaGUgOiBkZWZhdWx0Q2FjaGU7XG4gICAgICAgICAgICAvLyBidWlsZCB0aGUgaW5kZXggYWNjb3JkaW5nIHRvIHRoZSB1cmwgYW5kIHBhcmFtc1xuICAgICAgICAgICAgdmFyIGluZGV4XzEgPSBidWlsZFNvcnRlZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcik7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VQcm9taXNlID0gY2FjaGVfMS5nZXQoaW5kZXhfMSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlUHJvbWlzZSB8fCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZSA9IChmdW5jdGlvbiAoKSB7IHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbl8xO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGFkYXB0ZXIoY29uZmlnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZV8xLmRlbChpbmRleF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVhc29uXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pOyB9KSgpO1xuICAgICAgICAgICAgICAgIC8vIHB1dCB0aGUgcHJvbWlzZSBmb3IgdGhlIG5vbi10cmFuc2Zvcm1lZCByZXNwb25zZSBpbnRvIGNhY2hlIGFzIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICBjYWNoZV8xLnNldChpbmRleF8xLCByZXNwb25zZVByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkxPR0dFUl9MRVZFTCA9PT0gJ2luZm8nKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJyZXF1ZXN0IGNhY2hlZCBieSBjYWNoZSBhZGFwdGVyOiBcIiArIGluZGV4XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRhcHRlcihjb25maWcpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZUFkYXB0ZXJFbmhhbmNlci5qcy5tYXAiLCIvKipcbiAqIEBhdXRob3IgS3VpdG9zXG4gKiBAaG9tZXBhZ2UgaHR0cHM6Ly9naXRodWIuY29tL2t1aXRvcy9cbiAqIEBzaW5jZSAyMDE3LTA5LTI4XG4gKi9cbmltcG9ydCBDYWNoZSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IGNhY2hlQWRhcHRlckVuaGFuY2VyIGZyb20gJy4vY2FjaGVBZGFwdGVyRW5oYW5jZXInO1xuaW1wb3J0IHRocm90dGxlQWRhcHRlckVuaGFuY2VyIGZyb20gJy4vdGhyb3R0bGVBZGFwdGVyRW5oYW5jZXInO1xuZXhwb3J0IHsgQ2FjaGUsIGNhY2hlQWRhcHRlckVuaGFuY2VyLCB0aHJvdHRsZUFkYXB0ZXJFbmhhbmNlciwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxuICogQGF1dGhvciBLdWl0b3NcbiAqIEBob21lcGFnZSBodHRwczovL2dpdGh1Yi5jb20va3VpdG9zL1xuICogQHNpbmNlIDIwMTctMTAtMTFcbiAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBMUlVDYWNoZSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IGJ1aWxkU29ydGVkVVJMIGZyb20gJy4vdXRpbHMvYnVpbGRTb3J0ZWRVUkwnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGhyb3R0bGVBZGFwdGVyRW5oYW5jZXIoYWRhcHRlciwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLnRocmVzaG9sZCwgdGhyZXNob2xkID0gX2EgPT09IHZvaWQgMCA/IDEwMDAgOiBfYSwgX2IgPSBvcHRpb25zLmNhY2hlLCBjYWNoZSA9IF9iID09PSB2b2lkIDAgPyBuZXcgTFJVQ2FjaGUoeyBtYXg6IDEwIH0pIDogX2I7XG4gICAgdmFyIHJlY29yZENhY2hlV2l0aFJlcXVlc3QgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzcG9uc2VQcm9taXNlID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlLCByZWFzb25fMTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGFkYXB0ZXIoY29uZmlnKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGluZGV4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2VdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb25fMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmRlbChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWFzb25fMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9KSgpO1xuICAgICAgICBjYWNoZS5zZXQoaW5kZXgsIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHZhbHVlOiByZXNwb25zZVByb21pc2UsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdmFyIHVybCA9IGNvbmZpZy51cmwsIG1ldGhvZCA9IGNvbmZpZy5tZXRob2QsIHBhcmFtcyA9IGNvbmZpZy5wYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIgPSBjb25maWcucGFyYW1zU2VyaWFsaXplcjtcbiAgICAgICAgdmFyIGluZGV4ID0gYnVpbGRTb3J0ZWRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpO1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGNhY2hlZFJlY29yZCA9IGNhY2hlLmdldChpbmRleCkgfHwgeyB0aW1lc3RhbXA6IG5vdyB9O1xuICAgICAgICBpZiAobWV0aG9kID09PSAnZ2V0Jykge1xuICAgICAgICAgICAgaWYgKG5vdyAtIGNhY2hlZFJlY29yZC50aW1lc3RhbXAgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlUHJvbWlzZSA9IGNhY2hlZFJlY29yZC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5MT0dHRVJfTEVWRUwgPT09ICdpbmZvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInJlcXVlc3QgY2FjaGVkIGJ5IHRocm90dGxlIGFkYXB0ZXI6IFwiICsgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZENhY2hlV2l0aFJlcXVlc3QoaW5kZXgsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGVBZGFwdGVyRW5oYW5jZXIuanMubWFwIiwiLyoqXG4gKiBAYXV0aG9yIEt1aXRvc1xuICogQGhvbWVwYWdlIGh0dHBzOi8vZ2l0aHViLmNvbS9rdWl0b3MvXG4gKiBAc2luY2UgMjAxNy0xMC0xMlxuICovXG5pbXBvcnQgYnVpbGRVUkwgZnJvbSAnYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRTb3J0ZWRVUkwoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBidWlsdFVSTCA9IGJ1aWxkVVJMLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgdmFyIF9hID0gYnVpbHRVUkwuc3BsaXQoJz8nKSwgdXJsUGF0aCA9IF9hWzBdLCBxdWVyeVN0cmluZyA9IF9hWzFdO1xuICAgIGlmIChxdWVyeVN0cmluZykge1xuICAgICAgICB2YXIgcGFyYW1zUGFpciA9IHF1ZXJ5U3RyaW5nLnNwbGl0KCcmJyk7XG4gICAgICAgIHJldHVybiB1cmxQYXRoICsgXCI/XCIgKyBwYXJhbXNQYWlyLnNvcnQoKS5qb2luKCcmJyk7XG4gICAgfVxuICAgIHJldHVybiBidWlsdFVSTDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkU29ydGVkVVJMLmpzLm1hcCIsIi8qKlxuICogQGF1dGhvciBLdWl0b3NcbiAqIEBob21lcGFnZSBodHRwczovL2dpdGh1Yi5jb20va3VpdG9zL1xuICogQHNpbmNlIDIwMTgtMDMtMTlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNDYWNoZUxpa2UoY2FjaGUpIHtcbiAgICByZXR1cm4gISEoY2FjaGUuc2V0ICYmIGNhY2hlLmdldCAmJiBjYWNoZS5kZWwgJiZcbiAgICAgICAgdHlwZW9mIGNhY2hlLmdldCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2FjaGUuc2V0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYWNoZS5kZWwgPT09ICdmdW5jdGlvbicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNDYWNoZUxpa2UuanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSAmJiB3aW5kb3cuYnRvYS5iaW5kKHdpbmRvdykpIHx8IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idG9hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRFdmVudCA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgSUUgOC85IENPUlMgc3VwcG9ydFxuICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiZcbiAgICAgICAgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIGxvYWRFdmVudCA9ICdvbmxvYWQnO1xuICAgICAgeERvbWFpbiA9IHRydWU7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge307XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdFtsb2FkRXZlbnRdID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0ICYmICF4RG9tYWluKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzIwMSlcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgdmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xuXG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLndpdGhDcmVkZW50aWFscykge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UodXRpbHMubWVyZ2UoZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHttZXRob2Q6ICdnZXQnfSwgdGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gU3VwcG9ydCBiYXNlVVJMIGNvbmZpZ1xuICBpZiAoY29uZmlnLmJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwoY29uZmlnLnVybCkpIHtcbiAgICBjb25maWcudXJsID0gY29tYmluZVVSTHMoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVycyB8fCB7fVxuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGJ0b2EgcG9seWZpbGwgZm9yIElFPDEwIGNvdXJ0ZXN5IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGNoYW1iZXJzL0Jhc2U2NC5qc1xuXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5mdW5jdGlvbiBFKCkge1xuICB0aGlzLm1lc3NhZ2UgPSAnU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyJztcbn1cbkUucHJvdG90eXBlID0gbmV3IEVycm9yO1xuRS5wcm90b3R5cGUuY29kZSA9IDU7XG5FLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbmZ1bmN0aW9uIGJ0b2EoaW5wdXQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCk7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgZm9yIChcbiAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzO1xuICAgIC8vIGlmIHRoZSBuZXh0IHN0ciBpbmRleCBkb2VzIG5vdCBleGlzdDpcbiAgICAvLyAgIGNoYW5nZSB0aGUgbWFwcGluZyB0YWJsZSB0byBcIj1cIlxuICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICBzdHIuY2hhckF0KGlkeCB8IDApIHx8IChtYXAgPSAnPScsIGlkeCAlIDEpO1xuICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICkge1xuICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaWR4ICs9IDMgLyA0KTtcbiAgICBpZiAoY2hhckNvZGUgPiAweEZGKSB7XG4gICAgICB0aHJvdyBuZXcgRSgpO1xuICAgIH1cbiAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ0b2E7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTQwL2dpLCAnQCcpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgIH1cblxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ3Vuc2NvcGFibGVzJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgaGlkZShBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIGNyZWF0ZShudWxsKSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvZGVQb2ludEF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1hdCcpO1xuXG4vLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjb2RlUG9pbnRBdChTLCBpbmRleCwgdHJ1ZSkubGVuZ3RoIDogMSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgJyArIChuYW1lID8gbmFtZSArICcgJyA6ICcnKSArICdpbnZvY2F0aW9uJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZicpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgndG9TdHJpbmdUYWcnKTtcbnZhciBUWVBFRF9BUlJBWV9UQUcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJykoJ1RZUEVEX0FSUkFZX1RBRycpO1xuXG52YXIgRGF0YVZpZXcgPSBnbG9iYWwuRGF0YVZpZXc7XG52YXIgRGF0YVZpZXdQcm90b3R5cGUgPSBEYXRhVmlldyAmJiBEYXRhVmlldy5wcm90b3R5cGU7XG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkgJiYgSW50OEFycmF5LnByb3RvdHlwZTtcbnZhciBVaW50OENsYW1wZWRBcnJheSA9IGdsb2JhbC5VaW50OENsYW1wZWRBcnJheTtcbnZhciBVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSA9IFVpbnQ4Q2xhbXBlZEFycmF5ICYmIFVpbnQ4Q2xhbXBlZEFycmF5LnByb3RvdHlwZTtcbnZhciBUeXBlZEFycmF5ID0gSW50OEFycmF5ICYmIGdldFByb3RvdHlwZU9mKEludDhBcnJheSk7XG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IEludDhBcnJheVByb3RvdHlwZSAmJiBnZXRQcm90b3R5cGVPZihJbnQ4QXJyYXlQcm90b3R5cGUpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaXNQcm90b3R5cGVPZiA9IE9iamVjdFByb3RvdHlwZS5pc1Byb3RvdHlwZU9mO1xuXG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBOQVRJVkVfQVJSQVlfQlVGRkVSICYmICEhc2V0UHJvdG90eXBlT2Y7XG52YXIgVFlQRURfQVJSQVlfVEFHX1JFUUlSRUQgPSBmYWxzZTtcbnZhciBOQU1FO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QgPSB7XG4gIEludDhBcnJheTogMSxcbiAgVWludDhBcnJheTogMSxcbiAgVWludDhDbGFtcGVkQXJyYXk6IDEsXG4gIEludDE2QXJyYXk6IDIsXG4gIFVpbnQxNkFycmF5OiAyLFxuICBJbnQzMkFycmF5OiA0LFxuICBVaW50MzJBcnJheTogNCxcbiAgRmxvYXQzMkFycmF5OiA0LFxuICBGbG9hdDY0QXJyYXk6IDhcbn07XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZihpdCk7XG4gIHJldHVybiBrbGFzcyA9PT0gJ0RhdGFWaWV3JyB8fCBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGNsYXNzb2YoaXQpKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNUeXBlZEFycmF5KGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheScpO1xufTtcblxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoQykge1xuICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICBpZiAoaXNQcm90b3R5cGVPZi5jYWxsKFR5cGVkQXJyYXksIEMpKSByZXR1cm4gQztcbiAgfSBlbHNlIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSBpZiAoaGFzKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBOQU1FKSkge1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxbQVJSQVldO1xuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgKEMgPT09IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciB8fCBpc1Byb3RvdHlwZU9mLmNhbGwoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBDKSkpIHtcbiAgICAgIHJldHVybiBDO1xuICAgIH1cbiAgfSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGV4cG9ydFByb3RvID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCkge1xuICBpZiAoIURFU0NSSVBUT1JTKSByZXR1cm47XG4gIGlmIChmb3JjZWQpIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSwgS0VZKSkge1xuICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXTtcbiAgICB9XG4gIH1cbiAgaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlW0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgcmVkZWZpbmUoVHlwZWRBcnJheVByb3RvdHlwZSwgS0VZLCBmb3JjZWQgPyBwcm9wZXJ0eVxuICAgICAgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIEludDhBcnJheVByb3RvdHlwZVtLRVldIHx8IHByb3BlcnR5KTtcbiAgfVxufTtcblxudmFyIGV4cG9ydFN0YXRpYyA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQpIHtcbiAgdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgaWYgKGZvcmNlZCkgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgS0VZKSkge1xuICAgICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghVHlwZWRBcnJheVtLRVldIHx8IGZvcmNlZCkge1xuICAgICAgLy8gVjggfiBDaHJvbWUgNDktNTAgYCVUeXBlZEFycmF5JWAgbWV0aG9kcyBhcmUgbm9uLXdyaXRhYmxlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZWRlZmluZShUeXBlZEFycmF5LCBLRVksIGZvcmNlZCA/IHByb3BlcnR5IDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBJbnQ4QXJyYXlbS0VZXSB8fCBwcm9wZXJ0eSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfVxuICBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV0gfHwgZm9yY2VkKSkge1xuICAgICAgcmVkZWZpbmUoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVksIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBpZiAoIWdsb2JhbFtOQU1FXSkgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IGZhbHNlO1xufVxuXG4vLyBXZWJLaXQgYnVnIC0gdHlwZWQgYXJyYXlzIGNvbnN0cnVjdG9ycyBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZVxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIHx8IHR5cGVvZiBUeXBlZEFycmF5ICE9ICdmdW5jdGlvbicgfHwgVHlwZWRBcnJheSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgVHlwZWRBcnJheSA9IGZ1bmN0aW9uIFR5cGVkQXJyYXkoKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuICB9O1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbFtOQU1FXSkgc2V0UHJvdG90eXBlT2YoZ2xvYmFsW05BTUVdLCBUeXBlZEFycmF5KTtcbiAgfVxufVxuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgIVR5cGVkQXJyYXlQcm90b3R5cGUgfHwgVHlwZWRBcnJheVByb3RvdHlwZSA9PT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5LnByb3RvdHlwZTtcbiAgaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIGlmIChnbG9iYWxbTkFNRV0pIHNldFByb3RvdHlwZU9mKGdsb2JhbFtOQU1FXS5wcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICB9XG59XG5cbi8vIFdlYktpdCBidWcgLSBvbmUgbW9yZSBvYmplY3QgaW4gVWludDhDbGFtcGVkQXJyYXkgcHJvdG90eXBlIGNoYWluXG5pZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBnZXRQcm90b3R5cGVPZihVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSkgIT09IFR5cGVkQXJyYXlQcm90b3R5cGUpIHtcbiAgc2V0UHJvdG90eXBlT2YoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xufVxuXG5pZiAoREVTQ1JJUFRPUlMgJiYgIWhhcyhUeXBlZEFycmF5UHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCA9IHRydWU7XG4gIGRlZmluZVByb3BlcnR5KFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRoaXMpID8gdGhpc1tUWVBFRF9BUlJBWV9UQUddIDogdW5kZWZpbmVkO1xuICB9IH0pO1xuICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWxbTkFNRV0pIHtcbiAgICBoaWRlKGdsb2JhbFtOQU1FXSwgVFlQRURfQVJSQVlfVEFHLCBOQU1FKTtcbiAgfVxufVxuXG4vLyBXZWJLaXQgYnVnIC0gdGhlIHNhbWUgcGFyZW50IHByb3RvdHlwZSBmb3IgdHlwZWQgYXJyYXlzIGFuZCBkYXRhIHZpZXdcbmlmIChOQVRJVkVfQVJSQVlfQlVGRkVSICYmIHNldFByb3RvdHlwZU9mICYmIGdldFByb3RvdHlwZU9mKERhdGFWaWV3UHJvdG90eXBlKSAhPT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gIHNldFByb3RvdHlwZU9mKERhdGFWaWV3UHJvdG90eXBlLCBPYmplY3RQcm90b3R5cGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTkFUSVZFX0FSUkFZX0JVRkZFUjogTkFUSVZFX0FSUkFZX0JVRkZFUixcbiAgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUzogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyxcbiAgVFlQRURfQVJSQVlfVEFHOiBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCAmJiBUWVBFRF9BUlJBWV9UQUcsXG4gIGFUeXBlZEFycmF5OiBhVHlwZWRBcnJheSxcbiAgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcbiAgZXhwb3J0UHJvdG86IGV4cG9ydFByb3RvLFxuICBleHBvcnRTdGF0aWM6IGV4cG9ydFN0YXRpYyxcbiAgaXNWaWV3OiBpc1ZpZXcsXG4gIGlzVHlwZWRBcnJheTogaXNUeXBlZEFycmF5LFxuICBUeXBlZEFycmF5OiBUeXBlZEFycmF5LFxuICBUeXBlZEFycmF5UHJvdG90eXBlOiBUeXBlZEFycmF5UHJvdG90eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpLk5BVElWRV9BUlJBWV9CVUZGRVI7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZpbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCc7XG52YXIgTmF0aXZlQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkQXJyYXlCdWZmZXIgPSBOYXRpdmVBcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG52YXIgSW5maW5pdHkgPSAxIC8gMDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG52YXIgcGFja0lFRUU3NTQgPSBmdW5jdGlvbiAobnVtYmVyLCBtYW50aXNzYUxlbmd0aCwgYnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShieXRlcyk7XG4gIHZhciBleHBvbmVudExlbmd0aCA9IGJ5dGVzICogOCAtIG1hbnRpc3NhTGVuZ3RoIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBleHBvbmVudExlbmd0aCkgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1hbnRpc3NhTGVuZ3RoID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgc2lnbiA9IG51bWJlciA8IDAgfHwgbnVtYmVyID09PSAwICYmIDEgLyBudW1iZXIgPCAwID8gMSA6IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBleHBvbmVudCwgbWFudGlzc2EsIGM7XG4gIG51bWJlciA9IGFicyhudW1iZXIpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmIChudW1iZXIgIT0gbnVtYmVyIHx8IG51bWJlciA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgbWFudGlzc2EgPSBudW1iZXIgIT0gbnVtYmVyID8gMSA6IDA7XG4gICAgZXhwb25lbnQgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGV4cG9uZW50ID0gZmxvb3IobG9nKG51bWJlcikgLyBMTjIpO1xuICAgIGlmIChudW1iZXIgKiAoYyA9IHBvdygyLCAtZXhwb25lbnQpKSA8IDEpIHtcbiAgICAgIGV4cG9uZW50LS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IDEpIHtcbiAgICAgIG51bWJlciArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlciArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyICogYyA+PSAyKSB7XG4gICAgICBleHBvbmVudCsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtYW50aXNzYSA9IDA7XG4gICAgICBleHBvbmVudCA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChleHBvbmVudCArIGVCaWFzID49IDEpIHtcbiAgICAgIG1hbnRpc3NhID0gKG51bWJlciAqIGMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hbnRpc3NhID0gbnVtYmVyICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgICAgZXhwb25lbnQgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbWFudGlzc2FMZW5ndGggPj0gODsgYnVmZmVyW2luZGV4KytdID0gbWFudGlzc2EgJiAyNTUsIG1hbnRpc3NhIC89IDI1NiwgbWFudGlzc2FMZW5ndGggLT0gOCk7XG4gIGV4cG9uZW50ID0gZXhwb25lbnQgPDwgbWFudGlzc2FMZW5ndGggfCBtYW50aXNzYTtcbiAgZXhwb25lbnRMZW5ndGggKz0gbWFudGlzc2FMZW5ndGg7XG4gIGZvciAoOyBleHBvbmVudExlbmd0aCA+IDA7IGJ1ZmZlcltpbmRleCsrXSA9IGV4cG9uZW50ICYgMjU1LCBleHBvbmVudCAvPSAyNTYsIGV4cG9uZW50TGVuZ3RoIC09IDgpO1xuICBidWZmZXJbLS1pbmRleF0gfD0gc2lnbiAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbnZhciB1bnBhY2tJRUVFNzU0ID0gZnVuY3Rpb24gKGJ1ZmZlciwgbWFudGlzc2FMZW5ndGgpIHtcbiAgdmFyIGJ5dGVzID0gYnVmZmVyLmxlbmd0aDtcbiAgdmFyIGV4cG9uZW50TGVuZ3RoID0gYnl0ZXMgKiA4IC0gbWFudGlzc2FMZW5ndGggLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGV4cG9uZW50TGVuZ3RoKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZXhwb25lbnRMZW5ndGggLSA3O1xuICB2YXIgaW5kZXggPSBieXRlcyAtIDE7XG4gIHZhciBzaWduID0gYnVmZmVyW2luZGV4LS1dO1xuICB2YXIgZXhwb25lbnQgPSBzaWduICYgMTI3O1xuICB2YXIgbWFudGlzc2E7XG4gIHNpZ24gPj49IDc7XG4gIGZvciAoOyBuQml0cyA+IDA7IGV4cG9uZW50ID0gZXhwb25lbnQgKiAyNTYgKyBidWZmZXJbaW5kZXhdLCBpbmRleC0tLCBuQml0cyAtPSA4KTtcbiAgbWFudGlzc2EgPSBleHBvbmVudCAmICgxIDw8IC1uQml0cykgLSAxO1xuICBleHBvbmVudCA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtYW50aXNzYUxlbmd0aDtcbiAgZm9yICg7IG5CaXRzID4gMDsgbWFudGlzc2EgPSBtYW50aXNzYSAqIDI1NiArIGJ1ZmZlcltpbmRleF0sIGluZGV4LS0sIG5CaXRzIC09IDgpO1xuICBpZiAoZXhwb25lbnQgPT09IDApIHtcbiAgICBleHBvbmVudCA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChleHBvbmVudCA9PT0gZU1heCkge1xuICAgIHJldHVybiBtYW50aXNzYSA/IE5hTiA6IHNpZ24gPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtYW50aXNzYSA9IG1hbnRpc3NhICsgcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICBleHBvbmVudCA9IGV4cG9uZW50IC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzaWduID8gLTEgOiAxKSAqIG1hbnRpc3NhICogcG93KDIsIGV4cG9uZW50IC0gbWFudGlzc2FMZW5ndGgpO1xufTtcblxudmFyIHVucGFja0ludDMyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyWzNdIDw8IDI0IHwgYnVmZmVyWzJdIDw8IDE2IHwgYnVmZmVyWzFdIDw8IDggfCBidWZmZXJbMF07XG59O1xuXG52YXIgcGFja0ludDggPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRl07XG59O1xuXG52YXIgcGFja0ludDE2ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gW251bWJlciAmIDB4RkYsIG51bWJlciA+PiA4ICYgMHhGRl07XG59O1xuXG52YXIgcGFja0ludDMyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gW251bWJlciAmIDB4RkYsIG51bWJlciA+PiA4ICYgMHhGRiwgbnVtYmVyID4+IDE2ICYgMHhGRiwgbnVtYmVyID4+IDI0ICYgMHhGRl07XG59O1xuXG52YXIgcGFja0Zsb2F0MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChudW1iZXIsIDIzLCA0KTtcbn07XG5cbnZhciBwYWNrRmxvYXQ2NCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KG51bWJlciwgNTIsIDgpO1xufTtcblxudmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwga2V5KSB7XG4gIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yW1BST1RPVFlQRV0sIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcylba2V5XTsgfSB9KTtcbn07XG5cbnZhciBnZXQgPSBmdW5jdGlvbiAodmlldywgY291bnQsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlKHZpZXcpO1xuICBpZiAoaW50SW5kZXggKyBjb3VudCA+IHN0b3JlLmJ5dGVMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgYnl0ZXMgPSBnZXRJbnRlcm5hbFN0YXRlKHN0b3JlLmJ1ZmZlcikuYnl0ZXM7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcbiAgdmFyIHBhY2sgPSBieXRlcy5zbGljZShzdGFydCwgc3RhcnQgKyBjb3VudCk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn07XG5cbnZhciBzZXQgPSBmdW5jdGlvbiAodmlldywgY291bnQsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgdmFyIHN0b3JlID0gZ2V0SW50ZXJuYWxTdGF0ZSh2aWV3KTtcbiAgaWYgKGludEluZGV4ICsgY291bnQgPiBzdG9yZS5ieXRlTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIGJ5dGVzID0gZ2V0SW50ZXJuYWxTdGF0ZShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHN0b3JlLmJ5dGVPZmZzZXQ7XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIGJ5dGVzW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGNvdW50IC0gaSAtIDFdO1xufTtcblxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleChsZW5ndGgpO1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgYnl0ZXM6IGFycmF5RmlsbC5jYWxsKG5ldyBBcnJheShieXRlTGVuZ3RoKSwgMCksXG4gICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoXG4gICAgfSk7XG4gICAgaWYgKCFERVNDUklQVE9SUykgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBnZXRJbnRlcm5hbFN0YXRlKGJ1ZmZlcikuYnl0ZUxlbmd0aDtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0Jyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICBieXRlT2Zmc2V0OiBvZmZzZXRcbiAgICB9KTtcbiAgICBpZiAoIURFU0NSSVBUT1JTKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J5dGVPZmZzZXQnKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJbnQzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMyk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1Mik7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0ludDgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJbnQ4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSW50MTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSW50MTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0ludDMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0ludDMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0NjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBOYXRpdmVBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKE5hTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgcmV0dXJuIE5hdGl2ZUFycmF5QnVmZmVyLm5hbWUgIT0gQVJSQVlfQlVGRkVSO1xuICB9KSkge1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG90eXBlID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBOYXRpdmVBcnJheUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvciAodmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZUFycmF5QnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkgaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgTmF0aXZlQXJyYXlCdWZmZXJba2V5XSk7XG4gICAgfVxuICAgIEFycmF5QnVmZmVyUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdGVzdFZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgbmF0aXZlU2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHRlc3RWaWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHRlc3RWaWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh0ZXN0Vmlldy5nZXRJbnQ4KDApIHx8ICF0ZXN0Vmlldy5nZXRJbnQ4KDEpKSByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIG5hdGl2ZVNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIG5hdGl2ZVNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW5gIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvcHl3aXRoaW5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCAvKiA9IDAgKi8sIHN0YXJ0IC8qID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgdG8gPSB0b0Fic29sdXRlSW5kZXgodGFyZ2V0LCBsZW4pO1xuICB2YXIgZnJvbSA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgY291bnQgPSBNYXRoLm1pbigoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKTtcbiAgdmFyIGluYyA9IDE7XG4gIGlmIChmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpIHtcbiAgICBpbmMgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byArPSBjb3VudCAtIDE7XG4gIH1cbiAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgbmF0aXZlRm9yRWFjaCA9IFtdLmZvckVhY2g7XG52YXIgaW50ZXJuYWxGb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZHMnKSgwKTtcblxudmFyIFNMT1BQWV9NRVRIT0QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpKCdmb3JFYWNoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxubW9kdWxlLmV4cG9ydHMgPSBTTE9QUFlfTUVUSE9EID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gaW50ZXJuYWxGb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG59IDogbmF0aXZlRm9yRWFjaDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZiAobWFwcGluZykgbWFwZm4gPSBiaW5kKG1hcGZuLCBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgLy8gaWYgdGhlIHRhcmdldCBpcyBub3QgaXRlcmFibGUgb3IgaXQncyBhbiBhcnJheSB3aXRoIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIGEgc2ltcGxlIGNhc2VcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEMoKTtcbiAgICBmb3IgKDshKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmdcbiAgICAgICAgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSlcbiAgICAgICAgOiBzdGVwLnZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgcmVzdWx0ID0gbmV3IEMobGVuZ3RoKTtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG4vLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBuYXRpdmVMYXN0SW5kZXhPZiA9IFtdLmxhc3RJbmRleE9mO1xuXG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhbmF0aXZlTGFzdEluZGV4T2YgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xudmFyIFNMT1BQWV9NRVRIT0QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpKCdsYXN0SW5kZXhPZicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5sYXN0aW5kZXhvZlxubW9kdWxlLmV4cG9ydHMgPSAoTkVHQVRJVkVfWkVSTyB8fCBTTE9QUFlfTUVUSE9EKSA/IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pIHtcbiAgLy8gY29udmVydCAtMCB0byArMFxuICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuIG5hdGl2ZUxhc3RJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICBmb3IgKDtpbmRleCA+PSAwOyBpbmRleC0tKSBpZiAoaW5kZXggaW4gTykgaWYgKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KSByZXR1cm4gaW5kZXggfHwgMDtcbiAgcmV0dXJuIC0xO1xufSA6IG5hdGl2ZUxhc3RJbmRleE9mO1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHJldHVybiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFycmF5LmNvbnN0cnVjdG9yID0ge307XG4gICAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBmb286IDEgfTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICB9KTtcbn07XG4iLCJ2YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG4vLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsIHNwZWNpZmljQ3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiB0YXJnZXQucHVzaCh2YWx1ZSk7ICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7ICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYXJndW1lbnRzTGVuZ3RoIDwgMikgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdzcGVjaWVzJyk7XG5cbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gbmV3IChDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEMpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQpO1xuICAgIH07XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB2YXIgcmV0dXJuTWV0aG9kID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXR1cm5NZXRob2QgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0dXJuTWV0aG9kLmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgb2JqZWN0W0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwidmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhcyh0YXJnZXQsIGtleSkpIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUnKS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UsIHRydWUpO1xuICBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmICghSVNfUFVSRSAmJiBnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaGlkZShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmF0aXZlSXRlcmF0b3IuY2FsbCh0aGlzKTsgfTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoKCFJU19QVVJFIHx8IEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBoaWRlKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICRleHBvcnQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dyYXBwZWQtd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICB2YXIgU3ltYm9sID0gcGF0aC5TeW1ib2wgfHwgKHBhdGguU3ltYm9sID0ge30pO1xuICBpZiAoIWhhcyhTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eShTeW1ib2wsIE5BTUUsIHtcbiAgICB2YWx1ZTogd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKE5BTUUpXG4gIH0pO1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGV4aXN0ID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gZXhpc3QgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuIiwiLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG4iLCJ2YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcblxuLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3RLZXlzKGl0KTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpO1xuICAgIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsW1RBUkdFVF0gfHwgc2V0R2xvYmFsKFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBoaWRlKHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxudmFyIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gI3JlcGxhY2UgbmVlZHMgYnVpbHQtaW4gc3VwcG9ydCBmb3IgbmFtZWQgZ3JvdXBzLlxuICAvLyAjbWF0Y2ggd29ya3MgZmluZSBiZWNhdXNlIGl0IGp1c3QgcmV0dXJuIHRoZSBleGVjIHJlc3VsdHMsIGV2ZW4gaWYgaXQgaGFzXG4gIC8vIGEgXCJncm9wc1wiIHByb3BlcnR5LlxuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxuLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4vLyBXZWV4IEpTIGhhcyBmcm96ZW4gYnVpbHQtaW4gcHJvdG90eXBlcywgc28gdXNlIHRyeSAvIGNhdGNoIHdyYXBwZXJcbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAvKD86KS87XG4gIHZhciBvcmlnaW5hbEV4ZWMgPSByZS5leGVjO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JpZ2luYWxFeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gIHZhciByZXN1bHQgPSAnYWInLnNwbGl0KHJlKTtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggIT09IDIgfHwgcmVzdWx0WzBdICE9PSAnYScgfHwgcmVzdWx0WzFdICE9PSAnYic7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMsIHNoYW0pIHtcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbChLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcblxuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICB9XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIChLRVkgPT09ICdyZXBsYWNlJyAmJiAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMpIHx8XG4gICAgKEtFWSA9PT0gJ3NwbGl0JyAmJiAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDKVxuICApIHtcbiAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICBpZiAocmVnZXhwLmV4ZWMgPT09IHJlZ2V4cEV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XG4gICAgfSk7XG4gICAgdmFyIHN0cmluZ01ldGhvZCA9IG1ldGhvZHNbMF07XG4gICAgdmFyIHJlZ2V4TWV0aG9kID0gbWV0aG9kc1sxXTtcblxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyaW5nTWV0aG9kKTtcbiAgICByZWRlZmluZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJlZ2V4TWV0aG9kLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcmVnZXhNZXRob2QuY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgICBpZiAoc2hhbSkgaGlkZShSZWdFeHAucHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKSgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTtcbiIsInZhciBwYXRoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhdGgnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PSAnZnVuY3Rpb24nID8gdmFyaWFibGUgOiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24ocGF0aFtuYW1lc3BhY2VdKSB8fCBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pXG4gICAgOiBwYXRoW25hbWVzcGFjZV0gJiYgcGF0aFtuYW1lc3BhY2VdW21ldGhvZF0gfHwgZ2xvYmFsW25hbWVzcGFjZV0gJiYgZ2xvYmFsW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChpdCk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JNZXRob2QgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgfSByZXR1cm4gYW5PYmplY3QoaXRlcmF0b3JNZXRob2QuY2FsbChpdCkpO1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIHdpbmRvdy5NYXRoID09IE1hdGggPyB3aW5kb3dcbiAgOiB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgY29uc29sZSA9IGdsb2JhbC5jb25zb2xlO1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGNvbnNvbGUuZXJyb3IoYSkgOiBjb25zb2xlLmVycm9yKGEsIGIpO1xuICB9XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLmRvY3VtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50JykoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgcmV0dXJuICFPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XG59IDogT2JqZWN0O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuIiwidmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciBvYmplY3RIYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgV2Vha01hcCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKS5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCkge1xuICB2YXIgc3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG4gIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcbiAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgd21zZXQuY2FsbChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGhpZGUoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY2xhc3NvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IHR5cGVvZiBkZXRlY3Rpb24gPT0gJ2Z1bmN0aW9uJyA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNyZWdleHBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYmluZC1jb250ZXh0Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcnKTtcbnZhciBCUkVBSyA9IHt9O1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBmbiwgdGhhdCwgRU5UUklFUywgSVRFUkFUT1IpIHtcbiAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGZuLCB0aGF0LCBFTlRSSUVTID8gMiA6IDEpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBzdGVwO1xuXG4gIGlmIChJVEVSQVRPUikge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG4gIH0gZWxzZSB7XG4gICAgaXRlckZuID0gZ2V0SXRlcmF0b3JNZXRob2QoaXRlcmFibGUpO1xuICAgIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gRU5UUklFUyA/IGJvdW5kRnVuY3Rpb24oYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogYm91bmRGdW5jdGlvbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBCUkVBSykgcmV0dXJuIEJSRUFLO1xuICAgICAgfSByZXR1cm47XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpO1xuICB9XG5cbiAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgIGlmIChjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBib3VuZEZ1bmN0aW9uLCBzdGVwLnZhbHVlLCBFTlRSSUVTKSA9PT0gQlJFQUspIHJldHVybiBCUkVBSztcbiAgfVxufTtcblxuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuaWYgKFtdLmtleXMpIHtcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IHRydWU7XG4gIGVsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG5pZiAoSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuaWYgKCFJU19QVVJFICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdGFzaycpLnNldDtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlci1hZ2VudCcpO1xudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIElTX05PREUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsLCAncXVldWVNaWNyb3Rhc2snKTtcbnZhciBxdWV1ZU1pY3JvdGFzayA9IHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciAmJiBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IudmFsdWU7XG5cbnZhciBmbHVzaCwgaGVhZCwgbGFzdCwgbm90aWZ5LCB0b2dnbGUsIG5vZGUsIHByb21pc2U7XG5cbi8vIG1vZGVybiBlbmdpbmVzIGhhdmUgcXVldWVNaWNyb3Rhc2sgbWV0aG9kXG5pZiAoIXF1ZXVlTWljcm90YXNrKSB7XG4gIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChJU19OT0RFICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChJU19OT0RFKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICB9IGVsc2UgaWYgKE11dGF0aW9uT2JzZXJ2ZXIgJiYgIS8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0L2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVldWVNaWNyb3Rhc2sgfHwgZnVuY3Rpb24gKGZuKSB7XG4gIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgaWYgKCFoZWFkKSB7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5KCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59O1xuIiwiLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHJldHVybiAhU3RyaW5nKFN5bWJvbCgpKTtcbn0pO1xuIiwidmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVybCA9IG5ldyBVUkwoJ2I/ZT0xJywgJ2h0dHA6Ly9hJyk7XG4gIHZhciBzZWFyY2hQYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICB1cmwucGF0aG5hbWUgPSAnYyUyMGQnO1xuICByZXR1cm4gKElTX1BVUkUgJiYgIXVybC50b0pTT04pXG4gICAgfHwgIXNlYXJjaFBhcmFtcy5zb3J0XG4gICAgfHwgdXJsLmhyZWYgIT09ICdodHRwOi8vYS9jJTIwZD9lPTEnXG4gICAgfHwgc2VhcmNoUGFyYW1zLmdldCgnZScpICE9PSAnMSdcbiAgICB8fCBTdHJpbmcobmV3IFVSTFNlYXJjaFBhcmFtcygnP2E9MScpKSAhPT0gJ2E9MSdcbiAgICB8fCAhc2VhcmNoUGFyYW1zW0lURVJBVE9SXVxuICAgIC8vIHRocm93cyBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cHM6Ly9hQGInKS51c2VybmFtZSAhPT0gJ2EnXG4gICAgfHwgbmV3IFVSTFNlYXJjaFBhcmFtcyhuZXcgVVJMU2VhcmNoUGFyYW1zKCdhPWInKSkuZ2V0KCdhJykgIT09ICdiJ1xuICAgIC8vIG5vdCBwdW55Y29kZWQgaW4gRWRnZVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly/RgtC10YHRgicpLmhvc3QgIT09ICd4bi0tZTFheWJjJ1xuICAgIC8vIG5vdCBlc2NhcGVkIGluIENocm9tZSA2Mi1cbiAgICB8fCBuZXcgVVJMKCdodHRwOi8vYSPQsScpLmhhc2ggIT09ICcjJUQwJUIxJztcbn0pO1xuIiwidmFyIG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG52YXIgV2Vha01hcCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKS5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChuYXRpdmVGdW5jdGlvblRvU3RyaW5nLmNhbGwoV2Vha01hcCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIG5hdGl2ZUFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhbmF0aXZlQXNzaWduIHx8IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikgeyBCW2Nocl0gPSBjaHI7IH0pO1xuICByZXR1cm4gbmF0aXZlQXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cyhuYXRpdmVBc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IG9iamVjdEtleXMoUykuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6IG5hdGl2ZUFzc2lnbjtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaHRtbCcpO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBzY3JpcHQgPSAnc2NyaXB0JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIganMgPSAnamF2YScgKyBzY3JpcHQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhqcyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyBzY3JpcHQgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvJyArIHNjcmlwdCArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKVtJRV9QUk9UT10gPSB0cnVlO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2krK10sIFByb3BlcnRpZXNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIXByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJ1xuICAgID8gZ2V0V2luZG93TmFtZXMoaXQpXG4gICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgIW5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIHZhbGlkYXRlU2V0UHJvdG90eXBlT2ZBcmd1bWVudHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdmFsaWRhdGUtc2V0LXByb3RvdHlwZS1vZi1hcmd1bWVudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgY29ycmVjdFNldHRlciA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIHNldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldDtcbiAgICBzZXR0ZXIuY2FsbCh0ZXN0LCBbXSk7XG4gICAgY29ycmVjdFNldHRlciA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICB2YWxpZGF0ZVNldFByb3RvdHlwZU9mQXJndW1lbnRzKE8sIHByb3RvKTtcbiAgICBpZiAoY29ycmVjdFNldHRlcikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgIT09ICdbb2JqZWN0IHpdJyA/IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59IDogdGVzdC50b1N0cmluZztcbiIsInZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLlJlZmxlY3Q7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwidmFyIG5hdGl2ZVBhcnNlRmxvYXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJykucGFyc2VGbG9hdDtcbnZhciBpbnRlcm5hbFN0cmluZ1RyaW0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0nKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xudmFyIEZPUkNFRCA9IDEgLyBuYXRpdmVQYXJzZUZsb2F0KHdoaXRlc3BhY2VzICsgJy0wJykgIT09IC1JbmZpbml0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBGT1JDRUQgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cikge1xuICB2YXIgc3RyaW5nID0gaW50ZXJuYWxTdHJpbmdUcmltKFN0cmluZyhzdHIpLCAzKTtcbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZVBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6IG5hdGl2ZVBhcnNlRmxvYXQ7XG4iLCJ2YXIgbmF0aXZlUGFyc2VJbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJykucGFyc2VJbnQ7XG52YXIgaW50ZXJuYWxTdHJpbmdUcmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJyk7XG52YXIgd2hpdGVzcGFjZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2hpdGVzcGFjZXMnKTtcbnZhciBoZXggPSAvXlstK10/MFt4WF0vO1xudmFyIEZPUkNFRCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzA4JykgIT09IDggfHwgbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMHgxNicpICE9PSAyMjtcblxubW9kdWxlLmV4cG9ydHMgPSBGT1JDRUQgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gIHZhciBzdHJpbmcgPSBpbnRlcm5hbFN0cmluZ1RyaW0oU3RyaW5nKHN0ciksIDMpO1xuICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6IG5hdGl2ZVBhcnNlSW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlLCB2YWx1ZTogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuICB9XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcy9ibG9iL21hc3Rlci9wdW55Y29kZS5qc1xudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbnZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcbnZhciByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxcdTAwN0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHUwMDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nOyAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG52YXIgT1ZFUkZMT1dfRVJST1IgPSAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnO1xudmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKi9cbnZhciB1Y3MyZGVjb2RlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIHZhciBjb3VudGVyID0gMDtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuICAgICAgdmFyIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBMb3cgc3Vycm9nYXRlLlxuICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcbiAgICAgICAgLy8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgY291bnRlci0tO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIChkaWdpdCkge1xuICAvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuICAvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbiAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKi9cbnZhciBhZGFwdCA9IGZ1bmN0aW9uIChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgdmFyIGsgPSAwO1xuICBkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuICBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG4gIGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG4gICAgZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuICB9XG4gIHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBtYXgtc3RhdGVtZW50c1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gW107XG5cbiAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cbiAgaW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuICAvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG4gIHZhciBuID0gaW5pdGlhbE47XG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG4gIHZhciBpLCBjdXJyZW50VmFsdWU7XG5cbiAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcbiAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG4gIHZhciBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoOyAvLyBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblxuICAvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuICBpZiAoYmFzaWNMZW5ndGgpIHtcbiAgICBvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuICB9XG5cbiAgLy8gTWFpbiBlbmNvZGluZyBsb29wOlxuICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHQgbGFyZ2VyIG9uZTpcbiAgICB2YXIgbSA9IG1heEludDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcbiAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuICAgIHZhciBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG4gICAgaWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcbiAgICAgIHRocm93IFJhbmdlRXJyb3IoT1ZFUkZMT1dfRVJST1IpO1xuICAgIH1cblxuICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG4gICAgbiA9IG07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKE9WRVJGTE9XX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cbiAgICAgICAgdmFyIHEgPSBkZWx0YTtcbiAgICAgICAgZm9yICh2YXIgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG4gICAgICAgICAgdmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuICAgICAgICAgIGlmIChxIDwgdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgdmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCkpKTtcbiAgICAgICAgICBxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxKSkpO1xuICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgICsraGFuZGxlZENQQ291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgKytkZWx0YTtcbiAgICArK247XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBlbmNvZGVkID0gW107XG4gIHZhciBsYWJlbHMgPSBpbnB1dC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx1MDAyRScpLnNwbGl0KCcuJyk7XG4gIHZhciBpLCBsYWJlbDtcbiAgZm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgIGVuY29kZWQucHVzaChyZWdleE5vbkFTQ0lJLnRlc3QobGFiZWwpID8gJ3huLS0nICsgZW5jb2RlKGxhYmVsKSA6IGxhYmVsKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZC5qb2luKCcuJyk7XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcbnZhciBuYXRpdmVGdW5jdGlvblRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXRvLXN0cmluZycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcobmF0aXZlRnVuY3Rpb25Ub1N0cmluZykuc3BsaXQoJ3RvU3RyaW5nJyk7XG5cbnJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKSgnaW5zcGVjdFNvdXJjZScsIGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gbmF0aXZlRnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTtcbn0pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdW5zYWZlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy51bnNhZmUgOiBmYWxzZTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMuZW51bWVyYWJsZSA6IGZhbHNlO1xuICB2YXIgbm9UYXJnZXRHZXQgPSBvcHRpb25zID8gISFvcHRpb25zLm5vVGFyZ2V0R2V0IDogZmFsc2U7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnICYmICFoYXModmFsdWUsICduYW1lJykpIGhpZGUodmFsdWUsICduYW1lJywga2V5KTtcbiAgICBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSkuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogJycpO1xuICB9XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICAgIHNpbXBsZSA9IHRydWU7XG4gIH1cbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gIGVsc2UgaGlkZShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgbmF0aXZlRnVuY3Rpb25Ub1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vY2xhc3NvZi1yYXcnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9yZWdleHAtZXhlYycpO1xuXG4vLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChjbGFzc29mKFIpICE9PSAnUmVnRXhwJykge1xuICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4cEV4ZWMuY2FsbChSLCBTKTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4cEZsYWdzID0gcmVxdWlyZSgnLi9yZWdleHAtZmxhZ3MnKTtcblxudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG4vLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxuLy8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxudmFyIG5hdGl2ZVJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG5cbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvO1xuICB2YXIgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTEubGFzdEluZGV4ICE9PSAwIHx8IHJlMi5sYXN0SW5kZXggIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwocmUsIHN0cik7XG5cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZS5sYXN0SW5kZXggPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgbmF0aXZlUmVwbGFjZS5jYWxsKG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hlZEV4ZWM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gYFNhbWVWYWx1ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zYW1ldmFsdWVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgaGlkZShnbG9iYWwsIGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDID0gZ2V0QnVpbHRJbihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRlZmluZVByb3BlcnR5KEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShpdCwgVE9fU1RSSU5HX1RBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4wLjEnLFxuICBtb2RlOiByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICFtZXRob2QgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsLG5vLXRocm93LWxpdGVyYWxcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7IHRocm93IDE7IH0sIDEpO1xuICB9KTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ3NwZWNpZXMnKTtcblxuLy8gYFNwZWNpZXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29uc3RydWN0b3IgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbi8vIENPTlZFUlRfVE9fU1RSSU5HOiB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIENPTlZFUlRfVE9fU1RSSU5HOiBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHBvcywgQ09OVkVSVF9UT19TVFJJTkcpIHtcbiAgdmFyIFMgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGF0KSk7XG4gIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlcihwb3MpO1xuICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgfHwgKHNlY29uZCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdFxuICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGVhdGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGVhdFxubW9kdWxlLmV4cG9ydHMgPSAnJy5yZXBlYXQgfHwgZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbnVtYmVyIG9mIHJlcGV0aXRpb25zJyk7XG4gIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXN1bHQgKz0gc3RyO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIHdoaXRlc3BhY2UgPSAnWycgKyByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2hpdGVzcGFjZXMnKSArICddJztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbVN0YXJ0XG4vLyAyIC0+IFN0cmluZyN0cmltRW5kXG4vLyAzIC0+IFN0cmluZyN0cmltXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcsIFRZUEUpIHtcbiAgc3RyaW5nID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoc3RyaW5nKSk7XG4gIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYmluZC1jb250ZXh0Jyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9odG1sJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xudmFyIHNldCA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXIgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5cbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuXG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldCB8fCAhY2xlYXIpIHtcbiAgc2V0ID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYmluZChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhiaW5kKHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGJpbmQocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoYmluZChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGNsZWFyOiBjbGVhclxufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGB0aGlzTnVtYmVyVmFsdWVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGhpc251bWJlcnZhbHVlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInICYmIGNsYXNzb2YodmFsdWUpICE9ICdOdW1iZXInKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuICB9XG4gIHJldHVybiArdmFsdWU7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4obGVuZ3RoLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgVG9JbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGggb3IgaW5kZXgnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4iLCIvLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuIiwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0Jyk7XG4gIHJldHVybiBvZmZzZXQ7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmlmIChyZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKSkge1xuICB2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuICB2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbiAgdmFyIFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXlzLWNvbnN0cnVjdG9ycy1yZXF1aXJlcy13cmFwcGVycycpO1xuICB2YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG4gIHZhciBBcnJheUJ1ZmZlck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXInKTtcbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbiAgdmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbiAgdmFyIHRvSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXgnKTtcbiAgdmFyIHRvT2Zmc2V0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9mZnNldCcpO1xuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG4gIHZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuICB2YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbiAgdmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcbiAgdmFyIHR5cGVkQXJyYXlGcm9tID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWZyb20nKTtcbiAgdmFyIGFycmF5Rm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2RzJykoMCk7XG4gIHZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJyk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xuICB2YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xuICB2YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xuICB2YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIHZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4gIHZhciBBcnJheUJ1ZmZlciA9IEFycmF5QnVmZmVyTW9kdWxlLkFycmF5QnVmZmVyO1xuICB2YXIgRGF0YVZpZXcgPSBBcnJheUJ1ZmZlck1vZHVsZS5EYXRhVmlldztcbiAgdmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M7XG4gIHZhciBUWVBFRF9BUlJBWV9UQUcgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLlRZUEVEX0FSUkFZX1RBRztcbiAgdmFyIFR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLlR5cGVkQXJyYXk7XG4gIHZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5UeXBlZEFycmF5UHJvdG90eXBlO1xuICB2YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgdmFyIGlzVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuaXNUeXBlZEFycmF5O1xuICB2YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xuICB2YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCc7XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKEMpKShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShpdCwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcylba2V5XTtcbiAgICB9IH0pO1xuICB9O1xuXG4gIHZhciBpc0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIGtsYXNzO1xuICAgIHJldHVybiBpdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoaXQpKSA9PSAnQXJyYXlCdWZmZXInIHx8IGtsYXNzID09ICdTaGFyZWRBcnJheUJ1ZmZlcic7XG4gIH07XG5cbiAgdmFyIGlzVHlwZWRBcnJheUluZGV4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzVHlwZWRBcnJheSh0YXJnZXQpXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG5cbiAgdmFyIHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gIH07XG5cbiAgdmFyIHdyYXBwZWREZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGlzVHlwZWRBcnJheUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2NyaXB0b3IpXG4gICAgICAmJiBoYXMoZGVzY3JpcHRvciwgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzY3JpcHRvciwgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2NyaXB0b3IsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykgfHwgZGVzY3JpcHRvci53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2NyaXB0b3IsICdlbnVtZXJhYmxlJykgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlKVxuICAgICkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gIH07XG5cbiAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGRlZmluZVByb3BlcnR5TW9kdWxlLmYgPSB3cmFwcGVkRGVmaW5lUHJvcGVydHk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdidWZmZXInKTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J5dGVPZmZzZXQnKTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2xlbmd0aCcpO1xuICB9XG5cbiAgJGV4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfSwge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICBkZWZpbmVQcm9wZXJ0eTogd3JhcHBlZERlZmluZVByb3BlcnR5XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIHZhciBDT05TVFJVQ1RPUl9OQU1FID0gVFlQRSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBUWVBFO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIFRZUEU7XG4gICAgdmFyIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtDT05TVFJVQ1RPUl9OQU1FXTtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB2YXIgZXhwb3J0ZWQgPSB7fTtcblxuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIHJldHVybiBkYXRhLnZpZXdbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5ieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweEZGID8gMHhGRiA6IHZhbHVlICYgMHhGRjtcbiAgICAgIGRhdGEudmlld1tTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLmJ5dGVPZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGg7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgYnl0ZU9mZnNldCA9IHRvT2Zmc2V0KG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgYnl0ZU9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0eXBlZEFycmF5RnJvbS5jYWxsKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgICAgYnl0ZU9mZnNldDogYnl0ZU9mZnNldCxcbiAgICAgICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgIHZpZXc6IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihUeXBlZEFycmF5Q29uc3RydWN0b3IsIFR5cGVkQXJyYXkpO1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShUeXBlZEFycmF5UHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMpIHtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsIHR5cGVkQXJyYXlPZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5Q29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIoZGF0YSkpIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSwgdG9PZmZzZXQodHlwZWRBcnJheU9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgIDogdHlwZWRBcnJheU9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSwgdG9PZmZzZXQodHlwZWRBcnJheU9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgOiBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEpO1xuICAgICAgICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlGcm9tLmNhbGwoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG4gICAgICBhcnJheUZvckVhY2goZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvciwga2V5LCBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3Jba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGU7XG4gICAgfVxuXG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZS5jb25zdHJ1Y3RvciAhPT0gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBpZiAoVFlQRURfQVJSQVlfVEFHKSBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgVFlQRURfQVJSQVlfVEFHLCBDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgJGV4cG9ydCh7XG4gICAgICBnbG9iYWw6IHRydWUsIGZvcmNlZDogVHlwZWRBcnJheUNvbnN0cnVjdG9yICE9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3Rvciwgc2hhbTogIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1NcbiAgICB9LCBleHBvcnRlZCk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcbiAgICB9XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpKSB7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcbiAgICB9XG5cbiAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwidmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGksIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkge1xuICAgIGl0ZXJhdG9yID0gaXRlcmF0b3JNZXRob2QuY2FsbChPKTtcbiAgICBPID0gW107XG4gICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgTy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgIH1cbiAgfVxuICBpZiAobWFwcGluZyAmJiBhcmd1bWVudHNMZW5ndGggPiAyKSB7XG4gICAgbWFwZm4gPSBiaW5kKG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICB9XG4gIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKHRoaXMpKShsZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpLk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M7XG52YXIgQXJyYXlCdWZmZXIgPSBnbG9iYWwuQXJyYXlCdWZmZXI7XG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBJbnQ4QXJyYXkoMSk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBuZXcgSW50OEFycmF5KC0xKTtcbn0pIHx8ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIG5ldyBJbnQ4QXJyYXkoKTtcbiAgbmV3IEludDhBcnJheShudWxsKTtcbiAgbmV3IEludDhBcnJheSgxLjUpO1xuICBuZXcgSW50OEFycmF5KGl0ZXJhYmxlKTtcbn0sIHRydWUpIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gU2FmYXJpIDExIGJ1Z1xuICByZXR1cm4gbmV3IEludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoMiksIDEsIHVuZGVmaW5lZCkubGVuZ3RoICE9PSAxO1xufSk7XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiICsgU3RyaW5nKHByb3RvKSArICcgYXMgYSBwcm90b3R5cGUnKTtcbiAgfVxufTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKS5TeW1ib2w7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9IE5BVElWRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdXG4gICAgfHwgKE5BVElWRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG4iLCIvLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbm1vZHVsZS5leHBvcnRzID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXInKVtBUlJBWV9CVUZGRVJdO1xudmFyIE5hdGl2ZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpW0FSUkFZX0JVRkZFUl07XG5cbi8vIGBBcnJheUJ1ZmZlcmAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5YnVmZmVyLWNvbnN0cnVjdG9yXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogTmF0aXZlQXJyYXlCdWZmZXIgIT09IEFycmF5QnVmZmVyIH0sIHtcbiAgQXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyXG59KTtcblxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIEFycmF5QnVmZmVyID0gQXJyYXlCdWZmZXJNb2R1bGUuQXJyYXlCdWZmZXI7XG52YXIgRGF0YVZpZXcgPSBBcnJheUJ1ZmZlck1vZHVsZS5EYXRhVmlldztcbnZhciBuYXRpdmVBcnJheUJ1ZmZlclNsaWNlID0gQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlO1xuXG52YXIgSU5DT1JSRUNUX1NMSUNFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIW5ldyBBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KTtcblxuLy8gYEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheWJ1ZmZlci5wcm90b3R5cGUuc2xpY2VcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ0FycmF5QnVmZmVyJywgcHJvdG86IHRydWUsIHVuc2FmZTogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfU0xJQ0UgfSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmIChuYXRpdmVBcnJheUJ1ZmZlclNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuYXRpdmVBcnJheUJ1ZmZlclNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbiAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTb3VyY2UgPSBuZXcgRGF0YVZpZXcodGhpcyk7XG4gICAgdmFyIHZpZXdUYXJnZXQgPSBuZXcgRGF0YVZpZXcocmVzdWx0KTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChmaXJzdCA8IGZpbikge1xuICAgICAgdmlld1RhcmdldC5zZXRVaW50OChpbmRleCsrLCB2aWV3U291cmNlLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQgPSAnTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJztcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSAhcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG59KTtcblxudmFyIFNQRUNJRVNfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpKCdjb25jYXQnKTtcblxudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gIGlmICghaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoTyk7XG59O1xuXG52YXIgRk9SQ0VEID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIVNQRUNJRVNfU1VQUE9SVDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KGFyZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuICAgIGZvciAoaSA9IC0xLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoaXNDb25jYXRTcHJlYWRhYmxlKEUpKSB7XG4gICAgICAgIGxlbiA9IHRvTGVuZ3RoKEUubGVuZ3RoKTtcbiAgICAgICAgaWYgKG4gKyBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrLCBuKyspIGlmIChrIGluIEUpIGNyZWF0ZVByb3BlcnR5KEEsIG4sIEVba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG4gPj0gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KEEsIG4rKywgRSk7XG4gICAgICB9XG4gICAgfVxuICAgIEEubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaW50ZXJuYWxGaWx0ZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kcycpKDIpO1xuXG52YXIgU1BFQ0lFU19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0JykoJ2ZpbHRlcicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gaW50ZXJuYWxGaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mb3ItZWFjaCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogW10uZm9yRWFjaCAhPSBmb3JFYWNoIH0sIHsgZm9yRWFjaDogZm9yRWFjaCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbnRlcm5hbEluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgbmF0aXZlSW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbnZhciBORUdBVElWRV9aRVJPID0gISFuYXRpdmVJbmRleE9mICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xudmFyIFNMT1BQWV9NRVRIT0QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpKCdpbmRleE9mJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBORUdBVElWRV9aRVJPIHx8IFNMT1BQWV9NRVRIT0QgfSwge1xuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gbmF0aXZlSW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogaW50ZXJuYWxJbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiLy8gYEFycmF5LmlzQXJyYXlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkuaXNhcnJheVxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnQXJyYXknLCBzdGF0OiB0cnVlIH0sIHsgaXNBcnJheTogcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5JykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvcicpO1xudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBuYXRpdmVKb2luID0gW10uam9pbjtcblxudmFyIEVTM19TVFJJTkdTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0JykgIT0gT2JqZWN0O1xudmFyIFNMT1BQWV9NRVRIT0QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpKCdqb2luJywgJywnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5qb2luYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5qb2luXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEVTM19TVFJJTkdTIHx8IFNMT1BQWV9NRVRIT0QgfSwge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiBuYXRpdmVKb2luLmNhbGwodG9JbmRleGVkT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludGVybmFsTWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZHMnKSgxKTtcblxudmFyIFNQRUNJRVNfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpKCdtYXAnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNQRUNJRVNfU1VQUE9SVCB9LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuIGludGVybmFsTWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludGVybmFsUmVkdWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXJlZHVjZScpO1xuXG52YXIgU0xPUFBZX01FVEhPRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJykoJ3JlZHVjZScpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFNMT1BQWV9NRVRIT0QgfSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuIGludGVybmFsUmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdzcGVjaWVzJyk7XG52YXIgbmF0aXZlU2xpY2UgPSBbXS5zbGljZTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxudmFyIFNQRUNJRVNfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpKCdzbGljZScpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zbGljZVxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgLy8gaW5saW5lIGBBcnJheVNwZWNpZXNDcmVhdGVgIGZvciB1c2FnZSBuYXRpdmUgYEFycmF5I3NsaWNlYCB3aGVyZSBpdCdzIHBvc3NpYmxlXG4gICAgdmFyIENvbnN0cnVjdG9yLCByZXN1bHQsIG47XG4gICAgaWYgKGlzQXJyYXkoTykpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gTy5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIENvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBpc0FycmF5KENvbnN0cnVjdG9yLnByb3RvdHlwZSkpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcltTUEVDSUVTXTtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU2xpY2UuY2FsbChPLCBrLCBmaW4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgPSBuZXcgKENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgPyBBcnJheSA6IENvbnN0cnVjdG9yKShtYXgoZmluIC0gaywgMCkpO1xuICAgIGZvciAobiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBpZiAoayBpbiBPKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7XG52YXIgTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGV4Y2VlZGVkJztcblxudmFyIFNQRUNJRVNfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpKCdzcGxpY2UnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zcGxpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNwbGljZVxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNQRUNJRVNfU1VQUE9SVCB9LCB7XG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCAvKiAsIC4uLml0ZW1zICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBhY3R1YWxTdGFydCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaW5zZXJ0Q291bnQsIGFjdHVhbERlbGV0ZUNvdW50LCBBLCBrLCBmcm9tLCB0bztcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAwKSB7XG4gICAgICBpbnNlcnRDb3VudCA9IGFjdHVhbERlbGV0ZUNvdW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMSkge1xuICAgICAgaW5zZXJ0Q291bnQgPSAwO1xuICAgICAgYWN0dWFsRGVsZXRlQ291bnQgPSBsZW4gLSBhY3R1YWxTdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhcmd1bWVudHNMZW5ndGggLSAyO1xuICAgICAgYWN0dWFsRGVsZXRlQ291bnQgPSBtaW4obWF4KHRvSW50ZWdlcihkZWxldGVDb3VudCksIDApLCBsZW4gLSBhY3R1YWxTdGFydCk7XG4gICAgfVxuICAgIGlmIChsZW4gKyBpbnNlcnRDb3VudCAtIGFjdHVhbERlbGV0ZUNvdW50ID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQpO1xuICAgIH1cbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIGFjdHVhbERlbGV0ZUNvdW50KTtcbiAgICBmb3IgKGsgPSAwOyBrIDwgYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgZnJvbSA9IGFjdHVhbFN0YXJ0ICsgaztcbiAgICAgIGlmIChmcm9tIGluIE8pIGNyZWF0ZVByb3BlcnR5KEEsIGssIE9bZnJvbV0pO1xuICAgIH1cbiAgICBBLmxlbmd0aCA9IGFjdHVhbERlbGV0ZUNvdW50O1xuICAgIGlmIChpbnNlcnRDb3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICBmb3IgKGsgPSBhY3R1YWxTdGFydDsgayA8IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQ7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgICB9XG4gICAgICBmb3IgKGsgPSBsZW47IGsgPiBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50OyBrLS0pIGRlbGV0ZSBPW2sgLSAxXTtcbiAgICB9IGVsc2UgaWYgKGluc2VydENvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrID4gYWN0dWFsU3RhcnQ7IGstLSkge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50IC0gMTtcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQgLSAxO1xuICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGsgPSAwOyBrIDwgaW5zZXJ0Q291bnQ7IGsrKykge1xuICAgICAgT1trICsgYWN0dWFsU3RhcnRdID0gYXJndW1lbnRzW2sgKyAyXTtcbiAgICB9XG4gICAgTy5sZW5ndGggPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50O1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcbiIsInZhciBOQVRJVkVfQVJSQVlfQlVGRkVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKS5OQVRJVkVfQVJSQVlfQlVGRkVSO1xuXG4vLyBgRGF0YVZpZXdgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kYXRhdmlldy1jb25zdHJ1Y3RvclxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfQVJSQVlfQlVGRkVSIH0sIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXInKS5EYXRhVmlld1xufSk7XG4iLCIvLyBgRGF0ZS5ub3dgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0ZS5ub3dcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ0RhdGUnLCBzdGF0OiB0cnVlIH0sIHtcbiAgbm93OiBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG59KTtcbiIsInZhciBEYXRlUHJvdG90eXBlID0gRGF0ZS5wcm90b3R5cGU7XG52YXIgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSc7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBuYXRpdmVEYXRlVG9TdHJpbmcgPSBEYXRlUHJvdG90eXBlW1RPX1NUUklOR107XG52YXIgZ2V0VGltZSA9IERhdGVQcm90b3R5cGUuZ2V0VGltZTtcblxuLy8gYERhdGUucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRhdGUucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSkge1xuICByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKShEYXRlUHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IG5hdGl2ZURhdGVUb1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn1cbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmcgPSBGdW5jdGlvblByb3RvdHlwZS50b1N0cmluZztcbnZhciBuYW1lUkUgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS87XG52YXIgTkFNRSA9ICduYW1lJztcblxuLy8gRnVuY3Rpb24gaW5zdGFuY2VzIGAubmFtZWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWluc3RhbmNlcy1uYW1lXG5pZiAoREVTQ1JJUFRPUlMgJiYgIShOQU1FIGluIEZ1bmN0aW9uUHJvdG90eXBlKSkge1xuICBkZWZpbmVQcm9wZXJ0eShGdW5jdGlvblByb3RvdHlwZSwgTkFNRSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nLmNhbGwodGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgdGhpc051bWJlclZhbHVlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1yZXBlYXQnKTtcbnZhciBuYXRpdmVUb0ZpeGVkID0gMS4wLnRvRml4ZWQ7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGRhdGEgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciBjMiA9IGM7XG4gIHdoaWxlICgrK2kgPCA2KSB7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xuXG52YXIgZGl2aWRlID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgYyA9IDA7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xuXG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaWYgKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCkge1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpXSk7XG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKCcwJywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcblxudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcblxudmFyIGxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBuID0gMDtcbiAgdmFyIHgyID0geDtcbiAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUgKHgyID49IDIpIHtcbiAgICBuICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbi8vIGBOdW1iZXIucHJvdG90eXBlLnRvRml4ZWRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLnByb3RvdHlwZS50b2ZpeGVkXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyB0YXJnZXQ6ICdOdW1iZXInLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBuYXRpdmVUb0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgbmF0aXZlVG9GaXhlZC5jYWxsKHt9KTtcbn0pIH0sIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgIHZhciB4ID0gdGhpc051bWJlclZhbHVlKHRoaXMpO1xuICAgIHZhciBmID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKTtcbiAgICB2YXIgcyA9ICcnO1xuICAgIHZhciBtID0gJzAnO1xuICAgIHZhciBlLCB6LCBqLCBrO1xuICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHRocm93IFJhbmdlRXJyb3IoJ0luY29ycmVjdCBmcmFjdGlvbiBkaWdpdHMnKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKHggIT0geCkgcmV0dXJuICdOYU4nO1xuICAgIGlmICh4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSkgcmV0dXJuIFN0cmluZyh4KTtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHMgPSAnLSc7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGlmICh4ID4gMWUtMjEpIHtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBqID0gZjtcbiAgICAgICAgd2hpbGUgKGogPj0gNykge1xuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgaiAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICBqID0gZSAtIDE7XG4gICAgICAgIHdoaWxlIChqID49IDIzKSB7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKCcwJywgZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmID4gMCkge1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKCcwJywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIURFU0NSSVBUT1JTLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mXG59KTtcbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoMSk7IH0pO1xudmFyIEZPUkNFRCA9ICFERVNDUklQVE9SUyB8fCBGQUlMU19PTl9QUklNSVRJVkVTO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JbmRleGVkT2JqZWN0KGl0KSwga2V5KTtcbiAgfVxufSk7XG4iLCJ2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKShmdW5jdGlvbiAoKSB7IG5hdGl2ZUtleXMoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyB9LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdChpdCkpO1xuICB9XG59KTtcbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKHRvU3RyaW5nICE9PSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJykoT2JqZWN0UHJvdG90eXBlLCAndG9TdHJpbmcnLCB0b1N0cmluZywgeyB1bnNhZmU6IHRydWUgfSk7XG59XG4iLCJ2YXIgcGFyc2VGbG9hdEltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhcnNlLWZsb2F0Jyk7XG5cbi8vIGBwYXJzZUZsb2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogcGFyc2VGbG9hdCAhPSBwYXJzZUZsb2F0SW1wbGVtZW50YXRpb24gfSwge1xuICBwYXJzZUZsb2F0OiBwYXJzZUZsb2F0SW1wbGVtZW50YXRpb25cbn0pO1xuIiwidmFyIHBhcnNlSW50SW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGFyc2UtaW50Jyk7XG5cbi8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBwYXJzZUludCAhPSBwYXJzZUludEltcGxlbWVudGF0aW9uIH0sIHtcbiAgcGFyc2VJbnQ6IHBhcnNlSW50SW1wbGVtZW50YXRpb25cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWljcm90YXNrJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgaG9zdFJlcG9ydEVycm9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnMnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wZXJmb3JtJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZXItYWdlbnQnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ3NwZWNpZXMnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFBST01JU0UpO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvciA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkZmV0Y2ggPSBnbG9iYWwuZmV0Y2g7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52OCB8fCAnJztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG52YXIgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHk7XG52YXIgSVNfTk9ERSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIERJU1BBVENIX0VWRU5UID0gISEoZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRXZlbnQgJiYgZ2xvYmFsLmRpc3BhdGNoRXZlbnQpO1xudmFyIFVOSEFORExFRF9SRUpFQ1RJT04gPSAndW5oYW5kbGVkcmVqZWN0aW9uJztcbnZhciBSRUpFQ1RJT05fSEFORExFRCA9ICdyZWplY3Rpb25oYW5kbGVkJztcbnZhciBQRU5ESU5HID0gMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcbnZhciBIQU5ETEVEID0gMTtcbnZhciBVTkhBTkRMRUQgPSAyO1xudmFyIEludGVybmFsLCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgUHJvbWlzZVdyYXBwZXI7XG5cbnZhciBGT1JDRUQgPSBpc0ZvcmNlZChQUk9NSVNFLCBmdW5jdGlvbiAoKSB7XG4gIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICB2YXIgcHJvbWlzZSA9IFByb21pc2VDb25zdHJ1Y3Rvci5yZXNvbHZlKDEpO1xuICB2YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4gIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW1NQRUNJRVNdID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gIH07XG4gIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgcmV0dXJuICEoKElTX05PREUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuICAgICYmICghSVNfUFVSRSB8fCBwcm9taXNlWydmaW5hbGx5J10pXG4gICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG4gICAgLy8gdjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgJiYgdjguaW5kZXhPZignNi42JykgIT09IDBcbiAgICAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lLzY2JykgPT09IC0xKTtcbn0pO1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9IEZPUkNFRCB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBQcm9taXNlQ29uc3RydWN0b3IuYWxsKGl0ZXJhYmxlKVsnY2F0Y2gnXShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlLCBpc1JlamVjdCkge1xuICBpZiAoc3RhdGUubm90aWZpZWQpIHJldHVybjtcbiAgc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBzdGF0ZS5yZWFjdGlvbnM7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIG9rID0gc3RhdGUuc3RhdGUgPT0gRlVMRklMTEVEO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSwgc3RhdGUpO1xuICAgICAgICAgICAgc3RhdGUucmVqZWN0aW9uID0gSEFORExFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gbWF5IHRocm93XG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBzdGF0ZS5yZWFjdGlvbnMgPSBbXTtcbiAgICBzdGF0ZS5ub3RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhc3RhdGUucmVqZWN0aW9uKSBvblVuaGFuZGxlZChwcm9taXNlLCBzdGF0ZSk7XG4gIH0pO1xufTtcblxudmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgcHJvbWlzZSwgcmVhc29uKSB7XG4gIHZhciBldmVudCwgaGFuZGxlcjtcbiAgaWYgKERJU1BBVENIX0VWRU5UKSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBldmVudC5yZWFzb24gPSByZWFzb247XG4gICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgICBnbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKGhhbmRsZXIgPSBnbG9iYWxbJ29uJyArIG5hbWVdKSBoYW5kbGVyKGV2ZW50KTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIElTX1VOSEFORExFRCA9IGlzVW5oYW5kbGVkKHN0YXRlKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoSVNfTk9ERSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChVTkhBTkRMRURfUkVKRUNUSU9OLCBwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBzdGF0ZS5yZWplY3Rpb24gPSBJU19OT0RFIHx8IGlzVW5oYW5kbGVkKHN0YXRlKSA/IFVOSEFORExFRCA6IEhBTkRMRUQ7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucmVqZWN0aW9uICE9PSBIQU5ETEVEICYmICFzdGF0ZS5wYXJlbnQ7XG59O1xuXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kID0gZnVuY3Rpb24gKGZuLCBwcm9taXNlLCBzdGF0ZSwgdW53cmFwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBmbihwcm9taXNlLCBzdGF0ZSwgdmFsdWUsIHVud3JhcCk7XG4gIH07XG59O1xuXG52YXIgaW50ZXJuYWxSZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICBub3RpZnkocHJvbWlzZSwgc3RhdGUsIHRydWUpO1xufTtcblxudmFyIGludGVybmFsUmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsXG4gICAgICAgICAgICBiaW5kKGludGVybmFsUmVzb2x2ZSwgcHJvbWlzZSwgd3JhcHBlciwgc3RhdGUpLFxuICAgICAgICAgICAgYmluZChpbnRlcm5hbFJlamVjdCwgcHJvbWlzZSwgd3JhcHBlciwgc3RhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpbnRlcm5hbFJlamVjdChwcm9taXNlLCB3cmFwcGVyLCBlcnJvciwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHN0YXRlLnN0YXRlID0gRlVMRklMTEVEO1xuICAgICAgbm90aWZ5KHByb21pc2UsIHN0YXRlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGludGVybmFsUmVqZWN0KHByb21pc2UsIHsgZG9uZTogZmFsc2UgfSwgZXJyb3IsIHN0YXRlKTtcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmIChGT1JDRUQpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yLCBQUk9NSVNFKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZChpbnRlcm5hbFJlc29sdmUsIHRoaXMsIHN0YXRlKSwgYmluZChpbnRlcm5hbFJlamVjdCwgdGhpcywgc3RhdGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW50ZXJuYWxSZWplY3QodGhpcywgc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICAgIHR5cGU6IFBST01JU0UsXG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIG5vdGlmaWVkOiBmYWxzZSxcbiAgICAgIHBhcmVudDogZmFsc2UsXG4gICAgICByZWFjdGlvbnM6IFtdLFxuICAgICAgcmVqZWN0aW9uOiBmYWxzZSxcbiAgICAgIHN0YXRlOiBQRU5ESU5HLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsJykoUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgIC8vIGBQcm9taXNlLnByb3RvdHlwZS50aGVuYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS50aGVuXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IElTX05PREUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG4gICAgICBzdGF0ZS5yZWFjdGlvbnMucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAoc3RhdGUuc3RhdGUgIT0gUEVORElORykgbm90aWZ5KHRoaXMsIHN0YXRlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZShwcm9taXNlKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGJpbmQoaW50ZXJuYWxSZXNvbHZlLCBwcm9taXNlLCBzdGF0ZSk7XG4gICAgdGhpcy5yZWplY3QgPSBiaW5kKGludGVybmFsUmVqZWN0LCBwcm9taXNlLCBzdGF0ZSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xuXG4gIC8vIHdyYXAgZmV0Y2ggcmVzdWx0XG4gIGlmICghSVNfUFVSRSAmJiB0eXBlb2YgJGZldGNoID09ICdmdW5jdGlvbicpICRleHBvcnQoeyBnbG9iYWw6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKGlucHV0KSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoUHJvbWlzZUNvbnN0cnVjdG9yLCAkZmV0Y2guYXBwbHkoZ2xvYmFsLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gIH0pO1xufVxuXG4kZXhwb3J0KHsgZ2xvYmFsOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7IFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvciB9KTtcblxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJykoUHJvbWlzZUNvbnN0cnVjdG9yLCBQUk9NSVNFLCBmYWxzZSwgdHJ1ZSk7XG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcblxuUHJvbWlzZVdyYXBwZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGBQcm9taXNlLnJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucmVqZWN0XG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIGNhcGFiaWxpdHkucmVqZWN0LmNhbGwodW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuJGV4cG9ydCh7IHRhcmdldDogUFJPTUlTRSwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJU19QVVJFIHx8IEZPUkNFRCB9LCB7XG4gIC8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKElTX1BVUkUgJiYgdGhpcyA9PT0gUHJvbWlzZVdyYXBwZXIgPyBQcm9taXNlQ29uc3RydWN0b3IgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG5cbiRleHBvcnQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIC8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gYFByb21pc2UucmFjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucmFjZVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgTUFUQ0ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnbWF0Y2gnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cCcpO1xudmFyIGdldEZsYWdzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFncycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBOYXRpdmVSZWdFeHAgPSBnbG9iYWwuUmVnRXhwO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IE5hdGl2ZVJlZ0V4cC5wcm90b3R5cGU7XG52YXIgcmUxID0gL2EvZztcbnZhciByZTIgPSAvYS9nO1xuXG4vLyBcIm5ld1wiIHNob3VsZCBjcmVhdGUgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z1xudmFyIENPUlJFQ1RfTkVXID0gbmV3IE5hdGl2ZVJlZ0V4cChyZTEpICE9PSByZTE7XG5cbnZhciBGT1JDRUQgPSBpc0ZvcmNlZCgnUmVnRXhwJywgREVTQ1JJUFRPUlMgJiYgKCFDT1JSRUNUX05FVyB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJlMltNQVRDSF0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuIE5hdGl2ZVJlZ0V4cChyZTEpICE9IHJlMSB8fCBOYXRpdmVSZWdFeHAocmUyKSA9PSByZTIgfHwgTmF0aXZlUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpO1xuXG4vLyBgUmVnRXhwYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLWNvbnN0cnVjdG9yXG5pZiAoRk9SQ0VEKSB7XG4gIHZhciBSZWdFeHBXcmFwcGVyID0gZnVuY3Rpb24gUmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgdmFyIHRoaXNJc1JlZ0V4cCA9IHRoaXMgaW5zdGFuY2VvZiBSZWdFeHBXcmFwcGVyO1xuICAgIHZhciBwYXR0ZXJuSXNSZWdFeHAgPSBpc1JlZ0V4cChwYXR0ZXJuKTtcbiAgICB2YXIgZmxhZ3NBcmVVbmRlZmluZWQgPSBmbGFncyA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGhpc0lzUmVnRXhwICYmIHBhdHRlcm5Jc1JlZ0V4cCAmJiBwYXR0ZXJuLmNvbnN0cnVjdG9yID09PSBSZWdFeHBXcmFwcGVyICYmIGZsYWdzQXJlVW5kZWZpbmVkID8gcGF0dGVyblxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBOYXRpdmVSZWdFeHAocGF0dGVybklzUmVnRXhwICYmICFmbGFnc0FyZVVuZGVmaW5lZCA/IHBhdHRlcm4uc291cmNlIDogcGF0dGVybiwgZmxhZ3MpXG4gICAgICAgIDogTmF0aXZlUmVnRXhwKChwYXR0ZXJuSXNSZWdFeHAgPSBwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwV3JhcHBlcilcbiAgICAgICAgICA/IHBhdHRlcm4uc291cmNlXG4gICAgICAgICAgOiBwYXR0ZXJuLCBwYXR0ZXJuSXNSZWdFeHAgJiYgZmxhZ3NBcmVVbmRlZmluZWQgPyBnZXRGbGFncy5jYWxsKHBhdHRlcm4pIDogZmxhZ3MpXG4gICAgICAsIHRoaXNJc1JlZ0V4cCA/IHRoaXMgOiBSZWdFeHBQcm90b3R5cGUsIFJlZ0V4cFdyYXBwZXIpO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5IGluIFJlZ0V4cFdyYXBwZXIgfHwgZGVmaW5lUHJvcGVydHkoUmVnRXhwV3JhcHBlciwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5hdGl2ZVJlZ0V4cFtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoaXQpIHsgTmF0aXZlUmVnRXhwW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlUmVnRXhwKTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSBwcm94eShrZXlzW2krK10pO1xuICBSZWdFeHBQcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWdFeHBXcmFwcGVyO1xuICBSZWdFeHBXcmFwcGVyLnByb3RvdHlwZSA9IFJlZ0V4cFByb3RvdHlwZTtcbiAgcmVkZWZpbmUoZ2xvYmFsLCAnUmVnRXhwJywgUmVnRXhwV3JhcHBlcik7XG59XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAtQEBzcGVjaWVzXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG5cbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ1JlZ0V4cCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IC8uLy5leGVjICE9PSByZWdleHBFeGVjIH0sIHtcbiAgZXhlYzogcmVnZXhwRXhlY1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBmbGFncyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZmxhZ3MnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgbmF0aXZlVG9TdHJpbmcgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIE5PVF9HRU5FUklDID0gZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlVG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxudmFyIElOQ09SUkVDVF9OQU1FID0gbmF0aXZlVG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkc7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/IGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjb2RlUG9pbnRBdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctYXQnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG52YXIgU1RSSU5HX0lURVJBVE9SID0gJ1N0cmluZyBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLUBAaXRlcmF0b3JcbmRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gICAgc3RyaW5nOiBTdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gY29kZVBvaW50QXQoc3RyaW5nLCBpbmRleCwgdHJ1ZSk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcblxuLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMnKShcbiAgJ21hdGNoJyxcbiAgMSxcbiAgZnVuY3Rpb24gKE1BVENILCBuYXRpdmVNYXRjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgICAgIGZ1bmN0aW9uIG1hdGNoKHJlZ2V4cCkge1xuICAgICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICAgIHZhciBtYXRjaGVyID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgICAgIHJldHVybiBtYXRjaGVyICE9PSB1bmRlZmluZWQgPyBtYXRjaGVyLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgICAgIH0sXG4gICAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAbWF0Y2hcbiAgICAgIGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVNYXRjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuXG4gICAgICAgIGlmICghcnguZ2xvYmFsKSByZXR1cm4gcmVnRXhwRXhlYyhyeCwgUyk7XG5cbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIEEgPSBbXTtcbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICAgIEFbbl0gPSBtYXRjaFN0cjtcbiAgICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbiA9PT0gMCA/IG51bGwgOiBBO1xuICAgICAgfVxuICAgIF07XG4gIH1cbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXCQoWyQmYCddfFxcZFxcZD98PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmYCddfFxcZFxcZD8pL2c7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpKFxuICAncmVwbGFjZScsXG4gIDIsXG4gIGZ1bmN0aW9uIChSRVBMQUNFLCBuYXRpdmVSZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICAgIHZhciByZXBsYWNlciA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgICByZXR1cm4gcmVwbGFjZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gcmVwbGFjZXIuY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgICAgIDogbmF0aXZlUmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgICAgZnVuY3Rpb24gKHJlZ2V4cCwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG5cbiAgICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG5cbiAgICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG4gICAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSBicmVhaztcblxuICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcblxuICAgICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWNjdW11bGF0ZWRSZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHNbaV07XG5cbiAgICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG1heChtaW4odG9JbnRlZ2VyKHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcbiAgICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgICBpZiAoZnVuY3Rpb25hbFJlcGxhY2UpIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IFN0cmluZyhyZXBsYWNlVmFsdWUuYXBwbHkodW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICBuZXh0U291cmNlUG9zaXRpb24gPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW11bGF0ZWRSZXN1bHQgKyBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbik7XG4gICAgICB9XG4gICAgXTtcblxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICAgIGZ1bmN0aW9uIGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgICAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcbiAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUmVwbGFjZS5jYWxsKHJlcGxhY2VtZW50LCBzeW1ib2xzLCBmdW5jdGlvbiAobWF0Y2gsIGNoKSB7XG4gICAgICAgIHZhciBjYXB0dXJlO1xuICAgICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHN0ci5zbGljZSh0YWlsUG9zKTtcbiAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgc2FtZVZhbHVlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NhbWUtdmFsdWUnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpKFxuICAnc2VhcmNoJyxcbiAgMSxcbiAgZnVuY3Rpb24gKFNFQVJDSCwgbmF0aXZlU2VhcmNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gYFN0cmluZy5wcm90b3R5cGUuc2VhcmNoYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc2VhcmNoXG4gICAgICBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgICAgdmFyIHNlYXJjaGVyID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgICAgICByZXR1cm4gc2VhcmNoZXIgIT09IHVuZGVmaW5lZCA/IHNlYXJjaGVyLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gICAgICB9LFxuICAgICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzZWFyY2hcbiAgICAgIGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVTZWFyY2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcblxuICAgICAgICB2YXIgcHJldmlvdXNMYXN0SW5kZXggPSByeC5sYXN0SW5kZXg7XG4gICAgICAgIGlmICghc2FtZVZhbHVlKHByZXZpb3VzTGFzdEluZGV4LCAwKSkgcngubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgICBpZiAoIXNhbWVWYWx1ZShyeC5sYXN0SW5kZXgsIHByZXZpb3VzTGFzdEluZGV4KSkgcngubGFzdEluZGV4ID0gcHJldmlvdXNMYXN0SW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyAtMSA6IHJlc3VsdC5pbmRleDtcbiAgICAgIH1cbiAgICBdO1xuICB9XG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcmVnZXhwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGNhbGxSZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgYXJyYXlQdXNoID0gW10ucHVzaDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBNQVhfVUlOVDMyID0gMHhGRkZGRkZGRjtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCd4JywgJ3knKSAtPiAveC95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciBTVVBQT1JUU19ZID0gIWZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuICFSZWdFeHAoTUFYX1VJTlQzMiwgJ3knKTsgfSk7XG5cbi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJykoXG4gICdzcGxpdCcsXG4gIDIsXG4gIGZ1bmN0aW9uIChTUExJVCwgbmF0aXZlU3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICAgIHZhciBpbnRlcm5hbFNwbGl0O1xuICAgIGlmIChcbiAgICAgICdhYmJjJy5zcGxpdCgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPSA0IHx8XG4gICAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9IDIgfHxcbiAgICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT0gNCB8fFxuICAgICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMSB8fFxuICAgICAgJycuc3BsaXQoLy4/LykubGVuZ3RoXG4gICAgKSB7XG4gICAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHJldHVybiBbc3RyaW5nXTtcbiAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZVNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSByZWdleHBFeGVjLmNhbGwoc2VwYXJhdG9yQ29weSwgc3RyaW5nKSkge1xuICAgICAgICAgIGxhc3RJbmRleCA9IHNlcGFyYXRvckNvcHkubGFzdEluZGV4O1xuICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkgYXJyYXlQdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW0pIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VwYXJhdG9yQ29weS5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW0gPyBvdXRwdXQuc2xpY2UoMCwgbGltKSA6IG91dHB1dDtcbiAgICAgIH07XG4gICAgLy8gQ2hha3JhLCBWOFxuICAgIH0gZWxzZSBpZiAoJzAnLnNwbGl0KHVuZGVmaW5lZCwgMCkubGVuZ3RoKSB7XG4gICAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBuYXRpdmVTcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaW50ZXJuYWxTcGxpdCA9IG5hdGl2ZVNwbGl0O1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc3BsaXRcbiAgICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgICB2YXIgc3BsaXR0ZXIgPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICAgICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHNwbGl0dGVyLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgICA6IGludGVybmFsU3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgfSxcbiAgICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzcGxpdFxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFRoaXMgY2Fubm90IGJlIHByb3Blcmx5IHBvbHlmaWxsZWQgaW4gZW5naW5lcyB0aGF0IGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIHRoZSAneScgZmxhZy5cbiAgICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoaW50ZXJuYWxTcGxpdCwgcmVnZXhwLCB0aGlzLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gbmF0aXZlU3BsaXQpO1xuICAgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICAgIHZhciB1bmljb2RlTWF0Y2hpbmcgPSByeC51bmljb2RlO1xuICAgICAgICB2YXIgZmxhZ3MgPSAocnguaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocngudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChTVVBQT1JUU19ZID8gJ3knIDogJ2cnKTtcblxuICAgICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICAgIHZhciBzcGxpdHRlciA9IG5ldyBDKFNVUFBPUlRTX1kgPyByeCA6ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJywgZmxhZ3MpO1xuICAgICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoUy5sZW5ndGggPT09IDApIHJldHVybiBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgUykgPT09IG51bGwgPyBbU10gOiBbXTtcbiAgICAgICAgdmFyIHAgPSAwO1xuICAgICAgICB2YXIgcSA9IDA7XG4gICAgICAgIHZhciBBID0gW107XG4gICAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBTVVBQT1JUU19ZID8gcSA6IDA7XG4gICAgICAgICAgdmFyIHogPSBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgU1VQUE9SVFNfWSA/IFMgOiBTLnNsaWNlKHEpKTtcbiAgICAgICAgICB2YXIgZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB6ID09PSBudWxsIHx8XG4gICAgICAgICAgICAoZSA9IG1pbih0b0xlbmd0aChzcGxpdHRlci5sYXN0SW5kZXggKyAoU1VQUE9SVFNfWSA/IDAgOiBxKSksIFMubGVuZ3RoKSkgPT09IHBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQS5wdXNoKFMuc2xpY2UocCwgcSkpO1xuICAgICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gei5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgQS5wdXNoKHpbaV0pO1xuICAgICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxID0gcCA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEEucHVzaChTLnNsaWNlKHApKTtcbiAgICAgICAgcmV0dXJuIEE7XG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgIVNVUFBPUlRTX1lcbik7XG4iLCIvLyBgU3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvbmAgZ2V0dGVyXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uXG4ndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMnKTtcbnZhciBOYXRpdmVTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJykuU3ltYm9sO1xuXG5pZiAoREVTQ1JJUFRPUlMgJiYgdHlwZW9mIE5hdGl2ZVN5bWJvbCA9PSAnZnVuY3Rpb24nICYmICghKCdkZXNjcmlwdGlvbicgaW4gTmF0aXZlU3ltYm9sLnByb3RvdHlwZSkgfHxcbiAgLy8gU2FmYXJpIDEyIGJ1Z1xuICBOYXRpdmVTeW1ib2woKS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkXG4pKSB7XG4gIHZhciBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUgPSB7fTtcbiAgLy8gd3JhcCBTeW1ib2wgY29uc3RydWN0b3IgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHVuZGVmaW5lZCBkZXNjcmlwdGlvblxuICB2YXIgU3ltYm9sV3JhcHBlciA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzIGluc3RhbmNlb2YgU3ltYm9sV3JhcHBlclxuICAgICAgPyBuZXcgTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKVxuICAgICAgLy8gaW4gRWRnZSAxMywgU3RyaW5nKFN5bWJvbCh1bmRlZmluZWQpKSA9PT0gJ1N5bWJvbCh1bmRlZmluZWQpJ1xuICAgICAgOiBkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gTmF0aXZlU3ltYm9sKCkgOiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJycpIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZVtyZXN1bHRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKFN5bWJvbFdyYXBwZXIsIE5hdGl2ZVN5bWJvbCk7XG4gIHZhciBzeW1ib2xQcm90b3R5cGUgPSBTeW1ib2xXcmFwcGVyLnByb3RvdHlwZSA9IE5hdGl2ZVN5bWJvbC5wcm90b3R5cGU7XG4gIHN5bWJvbFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bWJvbFdyYXBwZXI7XG5cbiAgdmFyIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgbmF0aXZlID0gU3RyaW5nKE5hdGl2ZVN5bWJvbCgndGVzdCcpKSA9PSAnU3ltYm9sKHRlc3QpJztcbiAgdmFyIHJlZ2V4cCA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87XG4gIGRlZmluZVByb3BlcnR5KHN5bWJvbFByb3RvdHlwZSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIHN5bWJvbCA9IGlzT2JqZWN0KHRoaXMpID8gdGhpcy52YWx1ZU9mKCkgOiB0aGlzO1xuICAgICAgdmFyIHN0cmluZyA9IHN5bWJvbFRvU3RyaW5nLmNhbGwoc3ltYm9sKTtcbiAgICAgIGlmIChoYXMoRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlLCBzeW1ib2wpKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZGVzYyA9IG5hdGl2ZSA/IHN0cmluZy5zbGljZSg3LCAtMSkgOiBzdHJpbmcucmVwbGFjZShyZWdleHAsICckMScpO1xuICAgICAgcmV0dXJuIGRlc2MgPT09ICcnID8gdW5kZWZpbmVkIDogZGVzYztcbiAgICB9XG4gIH0pO1xuXG4gIHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHsgU3ltYm9sOiBTeW1ib2xXcmFwcGVyIH0pO1xufVxuIiwiLy8gYFN5bWJvbC5pdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5pdGVyYXRvclxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpKCdpdGVyYXRvcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd3JhcHBlZC13ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBISURERU4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpKCdoaWRkZW4nKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTWU1CT0wpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIG5hdGl2ZUpTT05TdHJpbmdpZnkgPSBKU09OICYmIEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90b3R5cGVTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIGtleSk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlW2tleV07XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBpdCAhPT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlLCBrZXksIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpO1xuICB9XG59IDogbmF0aXZlRGVmaW5lUHJvcGVydHk7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZywgZGVzY3JpcHRpb24pIHtcbiAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG5hdGl2ZU9iamVjdENyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzZXRJbnRlcm5hbFN0YXRlKHN5bWJvbCwge1xuICAgIHR5cGU6IFNZTUJPTCxcbiAgICB0YWc6IHRhZyxcbiAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb25cbiAgfSk7XG4gIGlmICghREVTQ1JJUFRPUlMpIHN5bWJvbC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICByZXR1cm4gc3ltYm9sO1xufTtcblxudmFyIGlzU3ltYm9sID0gTkFUSVZFX1NZTUJPTCAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGl0KSBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSkgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoaXQsIEhJRERFTiwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gbmF0aXZlT2JqZWN0Q3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjcmlwdG9yKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKTtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0luZGV4ZWRPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBuYXRpdmVPYmplY3RDcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMobmF0aXZlT2JqZWN0Q3JlYXRlKGl0KSwgUCk7XG59O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSW5kZXhlZE9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmICFoYXMoaGlkZGVuS2V5cywga2V5KSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvdHlwZTtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhJU19PUCA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG90eXBlLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wtY29uc3RydWN0b3JcbmlmICghTkFUSVZFX1NZTUJPTCkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciB0YWcgPSB1aWQoZGVzY3JpcHRpb24pO1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUpIHNldHRlci5jYWxsKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzY3JpcHRvcih0aGlzLCB0YWcsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIFVTRV9TRVRURVIpIHNldFN5bWJvbERlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IHNldHRlciB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcsIGRlc2NyaXB0aW9uKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gIH0pO1xuXG4gIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZiA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoJFN5bWJvbFtQUk9UT1RZUEVdLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIUlTX1BVUkUpIHtcbiAgICAgIHJlZGVmaW5lKE9iamVjdFByb3RvdHlwZSwgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cblxuICB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdlbGxLbm93blN5bWJvbChuYW1lKSwgbmFtZSk7XG4gIH07XG59XG5cbiRleHBvcnQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsIHNoYW06ICFOQVRJVkVfU1lNQk9MIH0sIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gb2JqZWN0S2V5cyhXZWxsS25vd25TeW1ib2xzU3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykge1xuICBkZWZpbmVXZWxsS25vd25TeW1ib2wod2VsbEtub3duU3ltYm9sc1trKytdKTtcbn1cblxuJGV4cG9ydCh7IHRhcmdldDogU1lNQk9MLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLmtleWZvclxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG59KTtcblxuJGV4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlzeW1ib2xzXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIGBKU09OLnN0cmluZ2lmeWAgbWV0aG9kIGJlaGF2aW9yIHdpdGggc3ltYm9sc1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtanNvbi5zdHJpbmdpZnlcbkpTT04gJiYgJGV4cG9ydCh7IHRhcmdldDogJ0pTT04nLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgcmV0dXJuIG5hdGl2ZUpTT05TdHJpbmdpZnkoW3N5bWJvbF0pICE9ICdbbnVsbF0nXG4gICAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gICAgfHwgbmF0aXZlSlNPTlN0cmluZ2lmeSh7IGE6IHN5bWJvbCB9KSAhPSAne30nXG4gICAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgICB8fCBuYXRpdmVKU09OU3RyaW5naWZ5KE9iamVjdChzeW1ib2wpKSAhPSAne30nO1xufSkgfSwge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIG5hdGl2ZUpTT05TdHJpbmdpZnkuYXBwbHkoSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmlmICghJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0pIGhpZGUoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCBTWU1CT0wpO1xuXG5oaWRkZW5LZXlzW0hJRERFTl0gPSB0cnVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5Q29weVdpdGhpbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1jb3B5LXdpdGhpbicpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuY29weVdpdGhpbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmNvcHl3aXRoaW5cbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2NvcHlXaXRoaW4nLCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKGFUeXBlZEFycmF5KHRoaXMpLCB0YXJnZXQsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcnJheUV2ZXJ5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZHMnKSg0KTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZXZlcnlcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2V2ZXJ5JywgZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuIGFycmF5RXZlcnkoYVR5cGVkQXJyYXkodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1maWxsJyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZmlsbFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdmaWxsJywgZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHtcbiAgcmV0dXJuIGFycmF5RmlsbC5hcHBseShhVHlwZWRBcnJheSh0aGlzKSwgYXJndW1lbnRzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kcycpKDIpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maWx0ZXJcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2ZpbHRlcicsIGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICB2YXIgbGlzdCA9IGFycmF5RmlsdGVyKGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IoQykpKGxlbmd0aCk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcnJheUZpbmRJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2RzJykoNik7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maW5kaW5kZXhcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2ZpbmRJbmRleCcsIGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiBhcnJheUZpbmRJbmRleChhVHlwZWRBcnJheSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcnJheUZpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kcycpKDUpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbmRcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2ZpbmQnLCBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuIGFycmF5RmluZChhVHlwZWRBcnJheSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcnJheUZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kcycpKDApO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZvcmVhY2hcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2ZvckVhY2gnLCBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIGFycmF5Rm9yRWFjaChhVHlwZWRBcnJheSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpKHRydWUpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5pbmNsdWRlc1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnaW5jbHVkZXMnLCBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gIHJldHVybiBhcnJheUluY2x1ZGVzKGFUeXBlZEFycmF5KHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuaW5kZXhvZlxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnaW5kZXhPZicsIGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICByZXR1cm4gYXJyYXlJbmRleE9mKGFUeXBlZEFycmF5KHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLlVpbnQ4QXJyYXk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnaXRlcmF0b3InKTtcbnZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbnZhciBhcnJheUtleXMgPSBBcnJheUl0ZXJhdG9ycy5rZXlzO1xudmFyIGFycmF5RW50cmllcyA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXM7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFByb3RvID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bztcbnZhciBuYXRpdmVUeXBlZEFycmF5SXRlcmF0b3IgPSBVaW50OEFycmF5ICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlW0lURVJBVE9SXTtcblxudmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISFuYXRpdmVUeXBlZEFycmF5SXRlcmF0b3JcbiAgJiYgKG5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8IG5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZCk7XG5cbnZhciB0eXBlZEFycmF5VmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbChhVHlwZWRBcnJheSh0aGlzKSk7XG59O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZW50cmllc1xuZXhwb3J0UHJvdG8oJ2VudHJpZXMnLCBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwoYVR5cGVkQXJyYXkodGhpcykpO1xufSk7XG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUua2V5c1xuZXhwb3J0UHJvdG8oJ2tleXMnLCBmdW5jdGlvbiBrZXlzKCkge1xuICByZXR1cm4gYXJyYXlLZXlzLmNhbGwoYVR5cGVkQXJyYXkodGhpcykpO1xufSk7XG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS52YWx1ZXNcbmV4cG9ydFByb3RvKCd2YWx1ZXMnLCB0eXBlZEFycmF5VmFsdWVzLCAhQ09SUkVDVF9JVEVSX05BTUUpO1xuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5leHBvcnRQcm90byhJVEVSQVRPUiwgdHlwZWRBcnJheVZhbHVlcywgIUNPUlJFQ1RfSVRFUl9OQU1FKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgYXJyYXlKb2luID0gW10uam9pbjtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuam9pbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmpvaW5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnam9pbicsIGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gIHJldHVybiBhcnJheUpvaW4uYXBwbHkoYVR5cGVkQXJyYXkodGhpcyksIGFyZ3VtZW50cyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcnJheUxhc3RJbmRleE9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWxhc3QtaW5kZXgtb2YnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmxhc3RJbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUubGFzdGluZGV4b2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnbGFzdEluZGV4T2YnLCBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KGFUeXBlZEFycmF5KHRoaXMpLCBhcmd1bWVudHMpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxudmFyIGludGVybmFsVHlwZWRBcnJheU1hcCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2RzJykoMSwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPLmNvbnN0cnVjdG9yKSkpKGxlbmd0aCk7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUubWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUubWFwXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdtYXAnLCBmdW5jdGlvbiBtYXAobWFwZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiBpbnRlcm5hbFR5cGVkQXJyYXlNYXAoYVR5cGVkQXJyYXkodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgYXJyYXlSZWR1Y2VSaWdodCA9IFtdLnJlZHVjZVJpZ2h0O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZWR1Y2VSaWNodGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3JlZHVjZVJpZ2h0JywgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseShhVHlwZWRBcnJheSh0aGlzKSwgYXJndW1lbnRzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBhcnJheVJlZHVjZSA9IFtdLnJlZHVjZTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUucmVkdWNlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3JlZHVjZScsIGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gIHJldHVybiBhcnJheVJlZHVjZS5hcHBseShhVHlwZWRBcnJheSh0aGlzKSwgYXJndW1lbnRzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUucmV2ZXJzZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnJldmVyc2VcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3JldmVyc2UnLCBmdW5jdGlvbiByZXZlcnNlKCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBsZW5ndGggPSBhVHlwZWRBcnJheSh0aGF0KS5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgdmFsdWU7XG4gIHdoaWxlIChpbmRleCA8IG1pZGRsZSkge1xuICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgIHRoYXRbbGVuZ3RoXSA9IHZhbHVlO1xuICB9IHJldHVybiB0aGF0O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9PZmZzZXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2Zmc2V0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG52YXIgRk9SQ0VEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgbmV3IEludDhBcnJheSgxKS5zZXQoe30pO1xufSk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNldGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNldFxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnc2V0JywgZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICBhVHlwZWRBcnJheSh0aGlzKTtcbiAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSk7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgdmFyIHNyYyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gIHZhciBsZW4gPSB0b0xlbmd0aChzcmMubGVuZ3RoKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgaWYgKGxlbiArIG9mZnNldCA+IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoJyk7XG4gIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG59LCBGT1JDRUQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG52YXIgRk9SQ0VEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgbmV3IEludDhBcnJheSgxKS5zbGljZSgpO1xufSk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc2xpY2VcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3NsaWNlJywgZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICB2YXIgbGlzdCA9IGFycmF5U2xpY2UuY2FsbChhVHlwZWRBcnJheSh0aGlzKSwgc3RhcnQsIGVuZCk7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IoQykpKGxlbmd0aCk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gIHJldHVybiByZXN1bHQ7XG59LCBGT1JDRUQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5U29tZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2RzJykoMyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zb21lYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc29tZVxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnc29tZScsIGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuIGFycmF5U29tZShhVHlwZWRBcnJheSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGFycmF5U29ydCA9IFtdLnNvcnQ7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zb3J0XG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdzb3J0JywgZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgcmV0dXJuIGFycmF5U29ydC5jYWxsKGFUeXBlZEFycmF5KHRoaXMpLCBjb21wYXJlZm4pO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnN1YmFycmF5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc3ViYXJyYXlcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3N1YmFycmF5JywgZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICB2YXIgTyA9IGFUeXBlZEFycmF5KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gTy5sZW5ndGg7XG4gIHZhciBiZWdpbkluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW5ndGgpO1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgTy5jb25zdHJ1Y3RvcikpKFxuICAgIE8uYnVmZmVyLFxuICAgIE8uYnl0ZU9mZnNldCArIGJlZ2luSW5kZXggKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gYmVnaW5JbmRleClcbiAgKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEludDhBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKS5JbnQ4QXJyYXk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IFtdLnRvTG9jYWxlU3RyaW5nO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxudmFyIFRPX0xPQ0FMRV9CVUcgPSAhIUludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgSW50OEFycmF5KDEpKTtcbn0pO1xudmFyIEZPUkNFRCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBJbnQ4QXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgSW50OEFycmF5LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS50b2xvY2FsZXN0cmluZ1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygndG9Mb2NhbGVTdHJpbmcnLCBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbChhVHlwZWRBcnJheSh0aGlzKSkgOiBhVHlwZWRBcnJheSh0aGlzKSwgYXJndW1lbnRzKTtcbn0sIEZPUkNFRCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKS5VaW50OEFycmF5O1xudmFyIFVpbnQ4QXJyYXlQcm90b3R5cGUgPSBVaW50OEFycmF5ICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFycmF5VG9TdHJpbmcgPSBbXS50b1N0cmluZztcbnZhciBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG5pZiAocmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkgeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSkge1xuICBhcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICB9O1xufVxuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnRvc3RyaW5nXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCd0b1N0cmluZycsIGFycmF5VG9TdHJpbmcsIChVaW50OEFycmF5UHJvdG90eXBlIHx8IHt9KS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKTtcbiIsIi8vIGBVaW50MTZBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yJykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCIvLyBgVWludDMyQXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbnJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvcicpKCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwiLy8gYFVpbnQ4QXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbnJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvcicpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInZhciBET01JdGVyYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcycpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2gnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUgJiYgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoICE9PSBmb3JFYWNoKSB0cnkge1xuICAgIGhpZGUoQ29sbGVjdGlvblByb3RvdHlwZSwgJ2ZvckVhY2gnLCBmb3JFYWNoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggPSBmb3JFYWNoO1xuICB9XG59XG4iLCJ2YXIgRE9NSXRlcmFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMnKTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGhpZGUoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUddKSBoaWRlKENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSkgdHJ5IHtcbiAgICAgICAgaGlkZShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Rhc2snKTtcbnZhciBGT1JDRUQgPSAhZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCAhZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xuXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyBnbG9iYWw6IHRydWUsIGJpbmQ6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgc2V0SW1tZWRpYXRlOiB0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6IHRhc2suY2xlYXJcbn0pO1xuIiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlci1hZ2VudCcpO1xudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbnZhciBNU0lFID0gL01TSUUgLlxcLi8udGVzdCh1c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHNldCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGZuLCB0aW1lIC8qICwgLi4uYXJncyAqLykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGZhbHNlO1xuICAgIHJldHVybiBzZXQoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSA6IGZuLCB0aW1lKTtcbiAgfTtcbn07XG5cbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IGdsb2JhbDogdHJ1ZSwgYmluZDogdHJ1ZSwgZm9yY2VkOiBNU0lFIH0sIHtcbiAgc2V0VGltZW91dDogd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIFVTRV9OQVRJVkVfVVJMID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS11cmwnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lLWFsbCcpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBnZXRJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3InKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnaXRlcmF0b3InKTtcbnZhciBVUkxfU0VBUkNIX1BBUkFNUyA9ICdVUkxTZWFyY2hQYXJhbXMnO1xudmFyIFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SID0gVVJMX1NFQVJDSF9QQVJBTVMgKyAnSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoVVJMX1NFQVJDSF9QQVJBTVMpO1xudmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SKTtcblxudmFyIHBsdXMgPSAvXFwrL2c7XG52YXIgc2VxdWVuY2VzID0gQXJyYXkoNCk7XG5cbnZhciBwZXJjZW50U2VxdWVuY2UgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgcmV0dXJuIHNlcXVlbmNlc1tieXRlcyAtIDFdIHx8IChzZXF1ZW5jZXNbYnl0ZXMgLSAxXSA9IFJlZ0V4cCgnKCg/OiVbXFxcXGRhLWZdezJ9KXsnICsgYnl0ZXMgKyAnfSknLCAnZ2knKSk7XG59O1xuXG52YXIgcGVyY2VudERlY29kZSA9IGZ1bmN0aW9uIChzZXF1ZW5jZSkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc2VxdWVuY2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgfVxufTtcblxudmFyIGRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBpdC5yZXBsYWNlKHBsdXMsICcgJyk7XG4gIHZhciBieXRlcyA9IDQ7XG4gIHdoaWxlIChieXRlcykge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHBlcmNlbnRTZXF1ZW5jZShieXRlcy0tKSwgcGVyY2VudERlY29kZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBmaW5kID0gL1shJygpfl18JTIwL2c7XG5cbnZhciByZXBsYWNlID0ge1xuICAnISc6ICclMjEnLFxuICBcIidcIjogJyUyNycsXG4gICcoJzogJyUyOCcsXG4gICcpJzogJyUyOScsXG4gICd+JzogJyU3RScsXG4gICclMjAnOiAnKydcbn07XG5cbnZhciByZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICByZXR1cm4gcmVwbGFjZVttYXRjaF07XG59O1xuXG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoaXQpLnJlcGxhY2UoZmluZCwgcmVwbGFjZXIpO1xufTtcblxudmFyIHBhcnNlU2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKHJlc3VsdCwgcXVlcnkpIHtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBxdWVyeS5zcGxpdCgnJicpO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYXR0cmlidXRlLCBlbnRyeTtcbiAgICB3aGlsZSAoaSA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2krK107XG4gICAgICBpZiAoYXR0cmlidXRlLmxlbmd0aCkge1xuICAgICAgICBlbnRyeSA9IGF0dHJpYnV0ZS5zcGxpdCgnPScpO1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAga2V5OiBkZXNlcmlhbGl6ZShlbnRyeS5zaGlmdCgpKSxcbiAgICAgICAgICB2YWx1ZTogZGVzZXJpYWxpemUoZW50cnkuam9pbignPScpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciB1cGRhdGVTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgdGhpcy5lbnRyaWVzLmxlbmd0aCA9IDA7XG4gIHBhcnNlU2VhcmNoUGFyYW1zKHRoaXMuZW50cmllcywgcXVlcnkpO1xufTtcblxudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgaWYgKHBhc3NlZCA8IHJlcXVpcmVkKSB0aHJvdyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG59O1xuXG52YXIgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKGZ1bmN0aW9uIEl0ZXJhdG9yKHBhcmFtcywga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUixcbiAgICBpdGVyYXRvcjogZ2V0SXRlcmF0b3IoZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZShwYXJhbXMpLmVudHJpZXMpLFxuICAgIGtpbmQ6IGtpbmRcbiAgfSk7XG59LCAnSXRlcmF0b3InLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIHN0ZXAgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gIGlmICghc3RlcC5kb25lKSB7XG4gICAgc3RlcC52YWx1ZSA9IGtpbmQgPT09ICdrZXlzJyA/IGVudHJ5LmtleSA6IGtpbmQgPT09ICd2YWx1ZXMnID8gZW50cnkudmFsdWUgOiBbZW50cnkua2V5LCBlbnRyeS52YWx1ZV07XG4gIH0gcmV0dXJuIHN0ZXA7XG59KTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtc2AgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLXVybHNlYXJjaHBhcmFtc1xudmFyIFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gVVJMU2VhcmNoUGFyYW1zKC8qIGluaXQgKi8pIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciwgVVJMX1NFQVJDSF9QQVJBTVMpO1xuICB2YXIgaW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBlbnRyaWVzID0gW107XG4gIHZhciBpdGVyYXRvck1ldGhvZCwgaXRlcmF0b3IsIHN0ZXAsIGVudHJ5SXRlcmF0b3IsIGZpcnN0LCBzZWNvbmQsIGtleTtcblxuICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICB0eXBlOiBVUkxfU0VBUkNIX1BBUkFNUyxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIHVwZGF0ZVVSTDogbnVsbCxcbiAgICB1cGRhdGVTZWFyY2hQYXJhbXM6IHVwZGF0ZVNlYXJjaFBhcmFtc1xuICB9KTtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzT2JqZWN0KGluaXQpKSB7XG4gICAgICBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKGluaXQpO1xuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvck1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoaW5pdCk7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBlbnRyeUl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoYW5PYmplY3Qoc3RlcC52YWx1ZSkpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChmaXJzdCA9IGVudHJ5SXRlcmF0b3IubmV4dCgpKS5kb25lIHx8XG4gICAgICAgICAgICAoc2Vjb25kID0gZW50cnlJdGVyYXRvci5uZXh0KCkpLmRvbmUgfHxcbiAgICAgICAgICAgICFlbnRyeUl0ZXJhdG9yLm5leHQoKS5kb25lXG4gICAgICAgICAgKSB0aHJvdyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHNlcXVlbmNlIHdpdGggbGVuZ3RoIDInKTtcbiAgICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6IGZpcnN0LnZhbHVlICsgJycsIHZhbHVlOiBzZWNvbmQudmFsdWUgKyAnJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGZvciAoa2V5IGluIGluaXQpIGlmIChoYXNPd24oaW5pdCwga2V5KSkgZW50cmllcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiBpbml0W2tleV0gKyAnJyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VTZWFyY2hQYXJhbXMoZW50cmllcywgdHlwZW9mIGluaXQgPT09ICdzdHJpbmcnID8gaW5pdC5jaGFyQXQoMCkgPT09ICc/JyA/IGluaXQuc2xpY2UoMSkgOiBpbml0IDogaW5pdCArICcnKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnJlZGVmaW5lQWxsKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwge1xuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5hcHBlbnRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtYXBwZW5kXG4gIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICBzdGF0ZS5lbnRyaWVzLnB1c2goeyBrZXk6IG5hbWUgKyAnJywgdmFsdWU6IHZhbHVlICsgJycgfSk7XG4gICAgaWYgKHN0YXRlLnVwZGF0ZVVSTCkgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmRlbGV0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1kZWxldGVcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gICAgdmFyIGtleSA9IG5hbWUgKyAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgaWYgKGVudHJpZXNbaV0ua2V5ID09PSBrZXkpIGVudHJpZXMuc3BsaWNlKGksIDEpO1xuICAgICAgZWxzZSBpKys7XG4gICAgfVxuICAgIGlmIChzdGF0ZS51cGRhdGVVUkwpIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5nZXRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZ2V0XG4gIGdldDogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIga2V5ID0gbmFtZSArICcnO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIGlmIChlbnRyaWVzW2ldLmtleSA9PT0ga2V5KSByZXR1cm4gZW50cmllc1tpXS52YWx1ZTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZ2V0QWxsYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWdldGFsbFxuICBnZXRBbGw6IGZ1bmN0aW9uIGdldEFsbChuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFyIGtleSA9IG5hbWUgKyAnJztcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykgaWYgKGVudHJpZXNbaV0ua2V5ID09PSBrZXkpIHJlc3VsdC5wdXNoKGVudHJpZXNbaV0udmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmhhc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1oYXNcbiAgaGFzOiBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgZW50cmllcy5sZW5ndGgpIGlmIChlbnRyaWVzW2krK10ua2V5ID09PSBrZXkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc2V0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLXNldFxuICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcyk7XG4gICAgdmFyIGVudHJpZXMgPSBzdGF0ZS5lbnRyaWVzO1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gICAgdmFyIHZhbCA9IHZhbHVlICsgJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICBmb3IgKDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgIGlmIChlbnRyeS5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoZm91bmQpIGVudHJpZXMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvdW5kKSBlbnRyaWVzLnB1c2goeyBrZXk6IGtleSwgdmFsdWU6IHZhbCB9KTtcbiAgICBpZiAoc3RhdGUudXBkYXRlVVJMKSBzdGF0ZS51cGRhdGVVUkwoKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1zb3J0XG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gICAgLy8gQXJyYXkjc29ydCBpcyBub3Qgc3RhYmxlIGluIHNvbWUgZW5naW5lc1xuICAgIHZhciBzbGljZSA9IGVudHJpZXMuc2xpY2UoKTtcbiAgICB2YXIgZW50cnksIGksIGo7XG4gICAgZW50cmllcy5sZW5ndGggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzbGljZS5sZW5ndGg7IGkrKykge1xuICAgICAgZW50cnkgPSBzbGljZVtpXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIGlmIChlbnRyaWVzW2pdLmtleSA+IGVudHJ5LmtleSkge1xuICAgICAgICBlbnRyaWVzLnNwbGljZShqLCAwLCBlbnRyeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGkpIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS51cGRhdGVVUkwpIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjayAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2ssIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIHdoaWxlIChpIDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpKytdO1xuICAgICAgYm91bmRGdW5jdGlvbihlbnRyeS52YWx1ZSwgZW50cnkua2V5LCB0aGlzKTtcbiAgICB9XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ2tleXMnKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudmFsdWVzYCBtZXRob2RcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAndmFsdWVzJyk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ2VudHJpZXMnKTtcbiAgfVxufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG5yZWRlZmluZShVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsIElURVJBVE9SLCBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUuZW50cmllcyk7XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsc2VhcmNocGFyYW1zLXN0cmluZ2lmaWNhdGlvbi1iZWhhdmlvclxucmVkZWZpbmUoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgZW50cnk7XG4gIHdoaWxlIChpIDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICBlbnRyeSA9IGVudHJpZXNbaSsrXTtcbiAgICByZXN1bHQucHVzaChzZXJpYWxpemUoZW50cnkua2V5KSArICc9JyArIHNlcmlhbGl6ZShlbnRyeS52YWx1ZSkpO1xuICB9IHJldHVybiByZXN1bHQuam9pbignJicpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKShVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciwgVVJMX1NFQVJDSF9QQVJBTVMpO1xuXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogIVVTRV9OQVRJVkVfVVJMIH0sIHtcbiAgVVJMU2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvclxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBVUkxTZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLFxuICBnZXRTdGF0ZTogZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBVU0VfTkFUSVZFX1VSTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtdXJsJyk7XG52YXIgTmF0aXZlVVJMID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLlVSTDtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbicpO1xudmFyIGFycmF5RnJvbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mcm9tJyk7XG52YXIgY29kZVBvaW50QXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLWF0Jyk7XG52YXIgdG9BU0NJSSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wdW55Y29kZS10by1hc2NpaScpO1xudmFyIFVSTFNlYXJjaFBhcmFtc01vZHVsZSA9IHJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zJyk7XG52YXIgVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zTW9kdWxlLlVSTFNlYXJjaFBhcmFtcztcbnZhciBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlID0gVVJMU2VhcmNoUGFyYW1zTW9kdWxlLmdldFN0YXRlO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxVUkxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKCdVUkwnKTtcbnZhciBwb3cgPSBNYXRoLnBvdztcblxudmFyIElOVkFMSURfQVVUSE9SSVRZID0gJ0ludmFsaWQgYXV0aG9yaXR5JztcbnZhciBJTlZBTElEX1NDSEVNRSA9ICdJbnZhbGlkIHNjaGVtZSc7XG52YXIgSU5WQUxJRF9IT1NUID0gJ0ludmFsaWQgaG9zdCc7XG52YXIgSU5WQUxJRF9QT1JUID0gJ0ludmFsaWQgcG9ydCc7XG5cbnZhciBBTFBIQSA9IC9bYS16QS1aXS87XG52YXIgQUxQSEFOVU1FUklDID0gL1thLXpBLVowLTkrXFwtLl0vO1xudmFyIERJR0lUID0gL1xcZC87XG52YXIgSEVYX1NUQVJUID0gL14oMHh8MFgpLztcbnZhciBPQ1QgPSAvXlswLTddKyQvO1xudmFyIERFQyA9IC9eXFxkKyQvO1xudmFyIEhFWCA9IC9eWzAtOUEtRmEtZl0rJC87XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlQgPSAvXFx1MDAwMHxcXHUwMDA5fFxcdTAwMEF8XFx1MDAwRHxcXHUwMDIwfCN8JXxcXC98OnxcXD98QHxcXFt8XFxcXHxcXF0vO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UX0VYQ0xVRElOR19QRVJDRU5UID0gL1xcdTAwMDB8XFx1MDAwOXxcXHUwMDBBfFxcdTAwMER8XFx1MDAyMHwjfFxcL3w6fFxcP3xAfFxcW3xcXFxcfFxcXS87XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIExFQURJTkdfQU5EX1RSQUlMSU5HX0MwX0NPTlRST0xfT1JfU1BBQ0UgPSAvXltcXHUwMDAwLVxcdTAwMUZcXHUwMDIwXSt8W1xcdTAwMDAtXFx1MDAxRlxcdTAwMjBdKyQvZztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgVEFCX0FORF9ORVdfTElORSA9IC9cXHUwMDA5fFxcdTAwMEF8XFx1MDAwRC9nO1xudmFyIEVPRjtcblxudmFyIHBhcnNlSG9zdCA9IGZ1bmN0aW9uICh1cmwsIGlucHV0KSB7XG4gIHZhciByZXN1bHQsIGNvZGVQb2ludHMsIGk7XG4gIGlmIChpbnB1dC5jaGFyQXQoMCkgPT0gJ1snKSB7XG4gICAgaWYgKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSAhPSAnXScpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgcmVzdWx0ID0gcGFyc2VJUHY2KGlucHV0LnNsaWNlKDEsIC0xKSk7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgdXJsLmhvc3QgPSByZXN1bHQ7XG4gIC8vIG9wYXF1ZSBob3N0XG4gIH0gZWxzZSBpZiAoIWlzU3BlY2lhbCh1cmwpKSB7XG4gICAgaWYgKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQudGVzdChpbnB1dCkpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgcmVzdWx0ID0gJyc7XG4gICAgY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHJlc3VsdCArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaV0sIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgIHVybC5ob3N0ID0gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIGlucHV0ID0gdG9BU0NJSShpbnB1dCk7XG4gICAgaWYgKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlQudGVzdChpbnB1dCkpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgcmVzdWx0ID0gcGFyc2VJUHY0KGlucHV0KTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgIHVybC5ob3N0ID0gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgcGFyc2VJUHY0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBwYXJ0cyA9IGlucHV0LnNwbGl0KCcuJyk7XG4gIHZhciBwYXJ0c0xlbmd0aCwgbnVtYmVycywgaSwgcGFydCwgUiwgbiwgaXB2NDtcbiAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdID09ICcnKSB7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCkgcGFydHMucG9wKCk7XG4gIH1cbiAgcGFydHNMZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG4gIGlmIChwYXJ0c0xlbmd0aCA+IDQpIHJldHVybiBpbnB1dDtcbiAgbnVtYmVycyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgcGFydHNMZW5ndGg7IGkrKykge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PSAnJykgcmV0dXJuIGlucHV0O1xuICAgIFIgPSAxMDtcbiAgICBpZiAocGFydC5sZW5ndGggPiAxICYmIHBhcnQuY2hhckF0KDApID09ICcwJykge1xuICAgICAgUiA9IEhFWF9TVEFSVC50ZXN0KHBhcnQpID8gMTYgOiA4O1xuICAgICAgcGFydCA9IHBhcnQuc2xpY2UoUiA9PSA4ID8gMSA6IDIpO1xuICAgIH1cbiAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShSID09IDEwID8gREVDIDogUiA9PSA4ID8gT0NUIDogSEVYKS50ZXN0KHBhcnQpKSByZXR1cm4gaW5wdXQ7XG4gICAgICBuID0gcGFyc2VJbnQocGFydCwgUik7XG4gICAgfVxuICAgIG51bWJlcnMucHVzaChuKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGFydHNMZW5ndGg7IGkrKykge1xuICAgIG4gPSBudW1iZXJzW2ldO1xuICAgIGlmIChpID09IHBhcnRzTGVuZ3RoIC0gMSkge1xuICAgICAgaWYgKG4gPj0gcG93KDI1NiwgNSAtIHBhcnRzTGVuZ3RoKSkgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChuID4gMjU1KSByZXR1cm4gbnVsbDtcbiAgfVxuICBpcHY0ID0gbnVtYmVycy5wb3AoKTtcbiAgZm9yIChpID0gMDsgaSA8IG51bWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBpcHY0ICs9IG51bWJlcnNbaV0gKiBwb3coMjU2LCAzIC0gaSk7XG4gIH1cbiAgcmV0dXJuIGlwdjQ7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbnZhciBwYXJzZUlQdjYgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdmFyIGFkZHJlc3MgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gIHZhciBwaWVjZUluZGV4ID0gMDtcbiAgdmFyIGNvbXByZXNzID0gbnVsbDtcbiAgdmFyIHBvaW50ZXIgPSAwO1xuICB2YXIgdmFsdWUsIGxlbmd0aCwgbnVtYmVyc1NlZW4sIGlwdjRQaWVjZSwgbnVtYmVyLCBzd2Fwcywgc3dhcDtcblxuICB2YXIgY2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaW5wdXQuY2hhckF0KHBvaW50ZXIpO1xuICB9O1xuXG4gIGlmIChjaGFyKCkgPT0gJzonKSB7XG4gICAgaWYgKGlucHV0LmNoYXJBdCgxKSAhPSAnOicpIHJldHVybjtcbiAgICBwb2ludGVyICs9IDI7XG4gICAgcGllY2VJbmRleCsrO1xuICAgIGNvbXByZXNzID0gcGllY2VJbmRleDtcbiAgfVxuICB3aGlsZSAoY2hhcigpKSB7XG4gICAgaWYgKHBpZWNlSW5kZXggPT0gOCkgcmV0dXJuO1xuICAgIGlmIChjaGFyKCkgPT0gJzonKSB7XG4gICAgICBpZiAoY29tcHJlc3MgIT09IG51bGwpIHJldHVybjtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIHBpZWNlSW5kZXgrKztcbiAgICAgIGNvbXByZXNzID0gcGllY2VJbmRleDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IGxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKGxlbmd0aCA8IDQgJiYgSEVYLnRlc3QoY2hhcigpKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgcGFyc2VJbnQoY2hhcigpLCAxNik7XG4gICAgICBwb2ludGVyKys7XG4gICAgICBsZW5ndGgrKztcbiAgICB9XG4gICAgaWYgKGNoYXIoKSA9PSAnLicpIHtcbiAgICAgIGlmIChsZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgcG9pbnRlciAtPSBsZW5ndGg7XG4gICAgICBpZiAocGllY2VJbmRleCA+IDYpIHJldHVybjtcbiAgICAgIG51bWJlcnNTZWVuID0gMDtcbiAgICAgIHdoaWxlIChjaGFyKCkpIHtcbiAgICAgICAgaXB2NFBpZWNlID0gbnVsbDtcbiAgICAgICAgaWYgKG51bWJlcnNTZWVuID4gMCkge1xuICAgICAgICAgIGlmIChjaGFyKCkgPT0gJy4nICYmIG51bWJlcnNTZWVuIDwgNCkgcG9pbnRlcisrO1xuICAgICAgICAgIGVsc2UgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRElHSVQudGVzdChjaGFyKCkpKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChESUdJVC50ZXN0KGNoYXIoKSkpIHtcbiAgICAgICAgICBudW1iZXIgPSBwYXJzZUludChjaGFyKCksIDEwKTtcbiAgICAgICAgICBpZiAoaXB2NFBpZWNlID09PSBudWxsKSBpcHY0UGllY2UgPSBudW1iZXI7XG4gICAgICAgICAgZWxzZSBpZiAoaXB2NFBpZWNlID09IDApIHJldHVybjtcbiAgICAgICAgICBlbHNlIGlwdjRQaWVjZSA9IGlwdjRQaWVjZSAqIDEwICsgbnVtYmVyO1xuICAgICAgICAgIGlmIChpcHY0UGllY2UgPiAyNTUpIHJldHVybjtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzc1twaWVjZUluZGV4XSA9IGFkZHJlc3NbcGllY2VJbmRleF0gKiAyNTYgKyBpcHY0UGllY2U7XG4gICAgICAgIG51bWJlcnNTZWVuKys7XG4gICAgICAgIGlmIChudW1iZXJzU2VlbiA9PSAyIHx8IG51bWJlcnNTZWVuID09IDQpIHBpZWNlSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChudW1iZXJzU2VlbiAhPSA0KSByZXR1cm47XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNoYXIoKSA9PSAnOicpIHtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIGlmICghY2hhcigpKSByZXR1cm47XG4gICAgfSBlbHNlIGlmIChjaGFyKCkpIHJldHVybjtcbiAgICBhZGRyZXNzW3BpZWNlSW5kZXgrK10gPSB2YWx1ZTtcbiAgfVxuICBpZiAoY29tcHJlc3MgIT09IG51bGwpIHtcbiAgICBzd2FwcyA9IHBpZWNlSW5kZXggLSBjb21wcmVzcztcbiAgICBwaWVjZUluZGV4ID0gNztcbiAgICB3aGlsZSAocGllY2VJbmRleCAhPSAwICYmIHN3YXBzID4gMCkge1xuICAgICAgc3dhcCA9IGFkZHJlc3NbcGllY2VJbmRleF07XG4gICAgICBhZGRyZXNzW3BpZWNlSW5kZXgtLV0gPSBhZGRyZXNzW2NvbXByZXNzICsgc3dhcHMgLSAxXTtcbiAgICAgIGFkZHJlc3NbY29tcHJlc3MgKyAtLXN3YXBzXSA9IHN3YXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBpZWNlSW5kZXggIT0gOCkgcmV0dXJuO1xuICByZXR1cm4gYWRkcmVzcztcbn07XG5cbnZhciBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZSA9IGZ1bmN0aW9uIChpcHY2KSB7XG4gIHZhciBtYXhJbmRleCA9IG51bGw7XG4gIHZhciBtYXhMZW5ndGggPSAxO1xuICB2YXIgY3VyclN0YXJ0ID0gbnVsbDtcbiAgdmFyIGN1cnJMZW5ndGggPSAwO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgODsgaSsrKSB7XG4gICAgaWYgKGlwdjZbaV0gIT09IDApIHtcbiAgICAgIGlmIChjdXJyTGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VyclN0YXJ0O1xuICAgICAgICBtYXhMZW5ndGggPSBjdXJyTGVuZ3RoO1xuICAgICAgfVxuICAgICAgY3VyclN0YXJ0ID0gbnVsbDtcbiAgICAgIGN1cnJMZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyclN0YXJ0ID09PSBudWxsKSBjdXJyU3RhcnQgPSBpO1xuICAgICAgKytjdXJyTGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAoY3Vyckxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgIG1heEluZGV4ID0gY3VyclN0YXJ0O1xuICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG1heEluZGV4O1xufTtcblxudmFyIHNlcmlhbGl6ZUhvc3QgPSBmdW5jdGlvbiAoaG9zdCkge1xuICB2YXIgcmVzdWx0LCBpLCBjb21wcmVzcywgaWdub3JlMDtcbiAgLy8gaXB2NFxuICBpZiAodHlwZW9mIGhvc3QgPT0gJ251bWJlcicpIHtcbiAgICByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICByZXN1bHQudW5zaGlmdChob3N0ICUgMjU2KTtcbiAgICAgIGhvc3QgPSBNYXRoLmZsb29yKGhvc3QgLyAyNTYpO1xuICAgIH0gcmV0dXJuIHJlc3VsdC5qb2luKCcuJyk7XG4gIC8vIGlwdjZcbiAgfSBlbHNlIGlmICh0eXBlb2YgaG9zdCA9PSAnb2JqZWN0Jykge1xuICAgIHJlc3VsdCA9ICcnO1xuICAgIGNvbXByZXNzID0gZmluZExvbmdlc3RaZXJvU2VxdWVuY2UoaG9zdCk7XG4gICAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgaWYgKGlnbm9yZTAgJiYgaG9zdFtpXSA9PT0gMCkgY29udGludWU7XG4gICAgICBpZiAoaWdub3JlMCkgaWdub3JlMCA9IGZhbHNlO1xuICAgICAgaWYgKGNvbXByZXNzID09PSBpKSB7XG4gICAgICAgIHJlc3VsdCArPSBpID8gJzonIDogJzo6JztcbiAgICAgICAgaWdub3JlMCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gaG9zdFtpXS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChpIDwgNykgcmVzdWx0ICs9ICc6JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdbJyArIHJlc3VsdCArICddJztcbiAgfSByZXR1cm4gaG9zdDtcbn07XG5cbnZhciBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0ID0ge307XG52YXIgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0LCB7XG4gICcgJzogMSwgJ1wiJzogMSwgJzwnOiAxLCAnPic6IDEsICdgJzogMVxufSk7XG52YXIgcGF0aFBlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIGZyYWdtZW50UGVyY2VudEVuY29kZVNldCwge1xuICAnIyc6IDEsICc/JzogMSwgJ3snOiAxLCAnfSc6IDFcbn0pO1xudmFyIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgcGF0aFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAgJy8nOiAxLCAnOic6IDEsICc7JzogMSwgJz0nOiAxLCAnQCc6IDEsICdbJzogMSwgJ1xcXFwnOiAxLCAnXSc6IDEsICdeJzogMSwgJ3wnOiAxXG59KTtcblxudmFyIHBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbiAoY2hhciwgc2V0KSB7XG4gIHZhciBjb2RlID0gY29kZVBvaW50QXQoY2hhciwgMCk7XG4gIHJldHVybiBjb2RlID4gMHgyMCAmJiBjb2RlIDwgMHg3RiAmJiAhaGFzKHNldCwgY2hhcikgPyBjaGFyIDogZW5jb2RlVVJJQ29tcG9uZW50KGNoYXIpO1xufTtcblxudmFyIHNwZWNpYWxTY2hlbWVzID0ge1xuICBmdHA6IDIxLFxuICBmaWxlOiBudWxsLFxuICBnb3BoZXI6IDcwLFxuICBodHRwOiA4MCxcbiAgaHR0cHM6IDQ0MyxcbiAgd3M6IDgwLFxuICB3c3M6IDQ0M1xufTtcblxudmFyIGlzU3BlY2lhbCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgcmV0dXJuIGhhcyhzcGVjaWFsU2NoZW1lcywgdXJsLnNjaGVtZSk7XG59O1xuXG52YXIgaW5jbHVkZXNDcmVkZW50aWFscyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgcmV0dXJuIHVybC51c2VybmFtZSAhPSAnJyB8fCB1cmwucGFzc3dvcmQgIT0gJyc7XG59O1xuXG52YXIgY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0ID0gZnVuY3Rpb24gKHVybCkge1xuICByZXR1cm4gIXVybC5ob3N0IHx8IHVybC5jYW5ub3RCZUFCYXNlVVJMIHx8IHVybC5zY2hlbWUgPT0gJ2ZpbGUnO1xufTtcblxudmFyIGlzV2luZG93c0RyaXZlTGV0dGVyID0gZnVuY3Rpb24gKHN0cmluZywgbm9ybWFsaXplZCkge1xuICB2YXIgc2Vjb25kO1xuICByZXR1cm4gc3RyaW5nLmxlbmd0aCA9PSAyICYmIEFMUEhBLnRlc3Qoc3RyaW5nLmNoYXJBdCgwKSlcbiAgICAmJiAoKHNlY29uZCA9IHN0cmluZy5jaGFyQXQoMSkpID09ICc6JyB8fCAoIW5vcm1hbGl6ZWQgJiYgc2Vjb25kID09ICd8JykpO1xufTtcblxudmFyIHN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciB0aGlyZDtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPiAxICYmIGlzV2luZG93c0RyaXZlTGV0dGVyKHN0cmluZy5zbGljZSgwLCAyKSkgJiYgKFxuICAgIHN0cmluZy5sZW5ndGggPT0gMiB8fFxuICAgICgodGhpcmQgPSBzdHJpbmcuY2hhckF0KDIpKSA9PT0gJy8nIHx8IHRoaXJkID09PSAnXFxcXCcgfHwgdGhpcmQgPT09ICc/JyB8fCB0aGlyZCA9PT0gJyMnKVxuICApO1xufTtcblxudmFyIHNob3J0ZW5VUkxzUGF0aCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgdmFyIHBhdGggPSB1cmwucGF0aDtcbiAgdmFyIHBhdGhTaXplID0gcGF0aC5sZW5ndGg7XG4gIGlmIChwYXRoU2l6ZSAmJiAodXJsLnNjaGVtZSAhPSAnZmlsZScgfHwgcGF0aFNpemUgIT0gMSB8fCAhaXNXaW5kb3dzRHJpdmVMZXR0ZXIocGF0aFswXSwgdHJ1ZSkpKSB7XG4gICAgcGF0aC5wb3AoKTtcbiAgfVxufTtcblxudmFyIGlzU2luZ2xlRG90ID0gZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnQgPT09ICcuJyB8fCBzZWdtZW50LnRvTG93ZXJDYXNlKCkgPT09ICclMmUnO1xufTtcblxudmFyIGlzRG91YmxlRG90ID0gZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgc2VnbWVudCA9IHNlZ21lbnQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHNlZ21lbnQgPT09ICcuLicgfHwgc2VnbWVudCA9PT0gJyUyZS4nIHx8IHNlZ21lbnQgPT09ICcuJTJlJyB8fCBzZWdtZW50ID09PSAnJTJlJTJlJztcbn07XG5cbi8vIFN0YXRlczpcbnZhciBTQ0hFTUVfU1RBUlQgPSB7fTtcbnZhciBTQ0hFTUUgPSB7fTtcbnZhciBOT19TQ0hFTUUgPSB7fTtcbnZhciBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWSA9IHt9O1xudmFyIFBBVEhfT1JfQVVUSE9SSVRZID0ge307XG52YXIgUkVMQVRJVkUgPSB7fTtcbnZhciBSRUxBVElWRV9TTEFTSCA9IHt9O1xudmFyIFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVMgPSB7fTtcbnZhciBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUyA9IHt9O1xudmFyIEFVVEhPUklUWSA9IHt9O1xudmFyIEhPU1QgPSB7fTtcbnZhciBIT1NUTkFNRSA9IHt9O1xudmFyIFBPUlQgPSB7fTtcbnZhciBGSUxFID0ge307XG52YXIgRklMRV9TTEFTSCA9IHt9O1xudmFyIEZJTEVfSE9TVCA9IHt9O1xudmFyIFBBVEhfU1RBUlQgPSB7fTtcbnZhciBQQVRIID0ge307XG52YXIgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSCA9IHt9O1xudmFyIFFVRVJZID0ge307XG52YXIgRlJBR01FTlQgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG52YXIgcGFyc2VVUkwgPSBmdW5jdGlvbiAodXJsLCBpbnB1dCwgc3RhdGVPdmVycmlkZSwgYmFzZSkge1xuICB2YXIgc3RhdGUgPSBzdGF0ZU92ZXJyaWRlIHx8IFNDSEVNRV9TVEFSVDtcbiAgdmFyIHBvaW50ZXIgPSAwO1xuICB2YXIgYnVmZmVyID0gJyc7XG4gIHZhciBzZWVuQXQgPSBmYWxzZTtcbiAgdmFyIHNlZW5CcmFja2V0ID0gZmFsc2U7XG4gIHZhciBzZWVuUGFzc3dvcmRUb2tlbiA9IGZhbHNlO1xuICB2YXIgY29kZVBvaW50cywgY2hhciwgYnVmZmVyQ29kZVBvaW50cywgZmFpbHVyZTtcblxuICBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgdXJsLnVzZXJuYW1lID0gJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gJyc7XG4gICAgdXJsLmhvc3QgPSBudWxsO1xuICAgIHVybC5wb3J0ID0gbnVsbDtcbiAgICB1cmwucGF0aCA9IFtdO1xuICAgIHVybC5xdWVyeSA9IG51bGw7XG4gICAgdXJsLmZyYWdtZW50ID0gbnVsbDtcbiAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IGZhbHNlO1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShMRUFESU5HX0FORF9UUkFJTElOR19DMF9DT05UUk9MX09SX1NQQUNFLCAnJyk7XG4gIH1cblxuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoVEFCX0FORF9ORVdfTElORSwgJycpO1xuXG4gIGNvZGVQb2ludHMgPSBhcnJheUZyb20oaW5wdXQpO1xuXG4gIHdoaWxlIChwb2ludGVyIDw9IGNvZGVQb2ludHMubGVuZ3RoKSB7XG4gICAgY2hhciA9IGNvZGVQb2ludHNbcG9pbnRlcl07XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBTQ0hFTUVfU1RBUlQ6XG4gICAgICAgIGlmIChjaGFyICYmIEFMUEhBLnRlc3QoY2hhcikpIHtcbiAgICAgICAgICBidWZmZXIgKz0gY2hhci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHN0YXRlID0gU0NIRU1FO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgc3RhdGUgPSBOT19TQ0hFTUU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gSU5WQUxJRF9TQ0hFTUU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNDSEVNRTpcbiAgICAgICAgaWYgKGNoYXIgJiYgKEFMUEhBTlVNRVJJQy50ZXN0KGNoYXIpIHx8IGNoYXIgPT0gJysnIHx8IGNoYXIgPT0gJy0nIHx8IGNoYXIgPT0gJy4nKSkge1xuICAgICAgICAgIGJ1ZmZlciArPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnOicpIHtcbiAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoaXNTcGVjaWFsKHVybCkgIT0gaGFzKHNwZWNpYWxTY2hlbWVzLCBidWZmZXIpKSB8fFxuICAgICAgICAgICAgICAoYnVmZmVyID09ICdmaWxlJyAmJiAoaW5jbHVkZXNDcmVkZW50aWFscyh1cmwpIHx8IHVybC5wb3J0ICE9PSBudWxsKSkgfHxcbiAgICAgICAgICAgICAgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmICF1cmwuaG9zdClcbiAgICAgICAgICAgICkgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cmwuc2NoZW1lID0gYnVmZmVyO1xuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBpZiAoaXNTcGVjaWFsKHVybCkgJiYgc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0gPT0gdXJsLnBvcnQpIHVybC5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEZJTEU7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1NwZWNpYWwodXJsKSAmJiBiYXNlICYmIGJhc2Uuc2NoZW1lID09IHVybC5zY2hlbWUpIHtcbiAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1NwZWNpYWwodXJsKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEhfT1JfQVVUSE9SSVRZO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgICAgICAgICB1cmwucGF0aC5wdXNoKCcnKTtcbiAgICAgICAgICAgIHN0YXRlID0gQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IE5PX1NDSEVNRTtcbiAgICAgICAgICBwb2ludGVyID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTk9fU0NIRU1FOlxuICAgICAgICBpZiAoIWJhc2UgfHwgKGJhc2UuY2Fubm90QmVBQmFzZVVSTCAmJiBjaGFyICE9ICcjJykpIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgaWYgKGJhc2UuY2Fubm90QmVBQmFzZVVSTCAmJiBjaGFyID09ICcjJykge1xuICAgICAgICAgIHVybC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgdXJsLmNhbm5vdEJlQUJhc2VVUkwgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBiYXNlLnNjaGVtZSA9PSAnZmlsZScgPyBGSUxFIDogUkVMQVRJVkU7XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBjYXNlIFNQRUNJQUxfUkVMQVRJVkVfT1JfQVVUSE9SSVRZOlxuICAgICAgICBpZiAoY2hhciA9PSAnLycgJiYgY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBSRUxBVElWRTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBicmVhaztcblxuICAgICAgY2FzZSBQQVRIX09SX0FVVEhPUklUWTpcbiAgICAgICAgaWYgKGNoYXIgPT0gJy8nKSB7XG4gICAgICAgICAgc3RhdGUgPSBBVVRIT1JJVFk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVMQVRJVkU6XG4gICAgICAgIHVybC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICAgICAgaWYgKGNoYXIgPT0gRU9GKSB7XG4gICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcvJyB8fCAoY2hhciA9PSAnXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpKSB7XG4gICAgICAgICAgc3RhdGUgPSBSRUxBVElWRV9TTEFTSDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICc/Jykge1xuICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gUVVFUlk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcbiAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgICAgICAgdXJsLnBhdGgucG9wKCk7XG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIFJFTEFUSVZFX1NMQVNIOlxuICAgICAgICBpZiAoaXNTcGVjaWFsKHVybCkgJiYgKGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFwnKSkge1xuICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnLycpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVM6XG4gICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XG4gICAgICAgIGlmIChjaGFyICE9ICcvJyB8fCBidWZmZXIuY2hhckF0KHBvaW50ZXIgKyAxKSAhPSAnLycpIGNvbnRpbnVlO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTOlxuICAgICAgICBpZiAoY2hhciAhPSAnLycgJiYgY2hhciAhPSAnXFxcXCcpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBicmVhaztcblxuICAgICAgY2FzZSBBVVRIT1JJVFk6XG4gICAgICAgIGlmIChjaGFyID09ICdAJykge1xuICAgICAgICAgIGlmIChzZWVuQXQpIGJ1ZmZlciA9ICclNDAnICsgYnVmZmVyO1xuICAgICAgICAgIHNlZW5BdCA9IHRydWU7XG4gICAgICAgICAgYnVmZmVyQ29kZVBvaW50cyA9IGFycmF5RnJvbShidWZmZXIpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyQ29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IGJ1ZmZlckNvZGVQb2ludHNbaV07XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID09ICc6JyAmJiAhc2VlblBhc3N3b3JkVG9rZW4pIHtcbiAgICAgICAgICAgICAgc2VlblBhc3N3b3JkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbmNvZGVkQ29kZVBvaW50cyA9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50LCB1c2VyaW5mb1BlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICAgICAgaWYgKHNlZW5QYXNzd29yZFRva2VuKSB1cmwucGFzc3dvcmQgKz0gZW5jb2RlZENvZGVQb2ludHM7XG4gICAgICAgICAgICBlbHNlIHVybC51c2VybmFtZSArPSBlbmNvZGVkQ29kZVBvaW50cztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgY2hhciA9PSBFT0YgfHwgY2hhciA9PSAnLycgfHwgY2hhciA9PSAnPycgfHwgY2hhciA9PSAnIycgfHxcbiAgICAgICAgICAoY2hhciA9PSAnXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChzZWVuQXQgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9BVVRIT1JJVFk7XG4gICAgICAgICAgcG9pbnRlciAtPSBhcnJheUZyb20oYnVmZmVyKS5sZW5ndGggKyAxO1xuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gSE9TVDtcbiAgICAgICAgfSBlbHNlIGJ1ZmZlciArPSBjaGFyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIT1NUOlxuICAgICAgY2FzZSBIT1NUTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgdXJsLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICBzdGF0ZSA9IEZJTEVfSE9TVDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICc6JyAmJiAhc2VlbkJyYWNrZXQpIHtcbiAgICAgICAgICBpZiAoYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgICAgIGZhaWx1cmUgPSBwYXJzZUhvc3QodXJsLCBidWZmZXIpO1xuICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IFBPUlQ7XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgPT0gSE9TVE5BTUUpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fFxuICAgICAgICAgIChjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGlzU3BlY2lhbCh1cmwpICYmIGJ1ZmZlciA9PSAnJykgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSAmJiBidWZmZXIgPT0gJycgJiYgKGluY2x1ZGVzQ3JlZGVudGlhbHModXJsKSB8fCB1cmwucG9ydCAhPT0gbnVsbCkpIHJldHVybjtcbiAgICAgICAgICBmYWlsdXJlID0gcGFyc2VIb3N0KHVybCwgYnVmZmVyKTtcbiAgICAgICAgICBpZiAoZmFpbHVyZSkgcmV0dXJuIGZhaWx1cmU7XG4gICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT0gJ1snKSBzZWVuQnJhY2tldCA9IHRydWU7XG4gICAgICAgICAgZWxzZSBpZiAoY2hhciA9PSAnXScpIHNlZW5CcmFja2V0ID0gZmFsc2U7XG4gICAgICAgICAgYnVmZmVyICs9IGNoYXI7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAgIGNhc2UgUE9SVDpcbiAgICAgICAgaWYgKERJR0lULnRlc3QoY2hhcikpIHtcbiAgICAgICAgICBidWZmZXIgKz0gY2hhcjtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fFxuICAgICAgICAgIChjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkgfHxcbiAgICAgICAgICBzdGF0ZU92ZXJyaWRlXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChidWZmZXIgIT0gJycpIHtcbiAgICAgICAgICAgIHZhciBwb3J0ID0gcGFyc2VJbnQoYnVmZmVyLCAxMCk7XG4gICAgICAgICAgICBpZiAocG9ydCA+IDB4RkZGRikgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gKGlzU3BlY2lhbCh1cmwpICYmIHBvcnQgPT09IHNwZWNpYWxTY2hlbWVzW3VybC5zY2hlbWVdKSA/IG51bGwgOiBwb3J0O1xuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRklMRTpcbiAgICAgICAgdXJsLnNjaGVtZSA9ICdmaWxlJztcbiAgICAgICAgaWYgKGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFwnKSBzdGF0ZSA9IEZJTEVfU0xBU0g7XG4gICAgICAgIGVsc2UgaWYgKGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT0gRU9GKSB7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnPycpIHtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJyMnKSB7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoY29kZVBvaW50cy5zbGljZShwb2ludGVyKS5qb2luKCcnKSkpIHtcbiAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICAgIHNob3J0ZW5VUkxzUGF0aCh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBicmVhaztcblxuICAgICAgY2FzZSBGSUxFX1NMQVNIOlxuICAgICAgICBpZiAoY2hhciA9PSAnLycgfHwgY2hhciA9PSAnXFxcXCcpIHtcbiAgICAgICAgICBzdGF0ZSA9IEZJTEVfSE9TVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZSAmJiBiYXNlLnNjaGVtZSA9PSAnZmlsZScgJiYgIXN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoY29kZVBvaW50cy5zbGljZShwb2ludGVyKS5qb2luKCcnKSkpIHtcbiAgICAgICAgICBpZiAoaXNXaW5kb3dzRHJpdmVMZXR0ZXIoYmFzZS5wYXRoWzBdLCB0cnVlKSkgdXJsLnBhdGgucHVzaChiYXNlLnBhdGhbMF0pO1xuICAgICAgICAgIGVsc2UgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICBjb250aW51ZTtcblxuICAgICAgY2FzZSBGSUxFX0hPU1Q6XG4gICAgICAgIGlmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykge1xuICAgICAgICAgIGlmICghc3RhdGVPdmVycmlkZSAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgfSBlbHNlIGlmIChidWZmZXIgPT0gJycpIHtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gJyc7XG4gICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSkgcmV0dXJuO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmYWlsdXJlID0gcGFyc2VIb3N0KHVybCwgYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICAgIGlmICh1cmwuaG9zdCA9PSAnbG9jYWxob3N0JykgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSF9TVEFSVDtcbiAgICAgICAgICB9IGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgYnVmZmVyICs9IGNoYXI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFBBVEhfU1RBUlQ6XG4gICAgICAgIGlmIChpc1NwZWNpYWwodXJsKSkge1xuICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICBpZiAoY2hhciAhPSAnLycgJiYgY2hhciAhPSAnXFxcXCcpIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNoYXIgPT0gJz8nKSB7XG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSAmJiBjaGFyID09ICcjJykge1xuICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciAhPSBFT0YpIHtcbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgaWYgKGNoYXIgIT0gJy8nKSBjb250aW51ZTtcbiAgICAgICAgfSBicmVhaztcblxuICAgICAgY2FzZSBQQVRIOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgY2hhciA9PSBFT0YgfHwgY2hhciA9PSAnLycgfHxcbiAgICAgICAgICAoY2hhciA9PSAnXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpIHx8XG4gICAgICAgICAgKCFzdGF0ZU92ZXJyaWRlICYmIChjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChpc0RvdWJsZURvdChidWZmZXIpKSB7XG4gICAgICAgICAgICBzaG9ydGVuVVJMc1BhdGgodXJsKTtcbiAgICAgICAgICAgIGlmIChjaGFyICE9ICcvJyAmJiAhKGNoYXIgPT0gJ1xcXFwnICYmIGlzU3BlY2lhbCh1cmwpKSkge1xuICAgICAgICAgICAgICB1cmwucGF0aC5wdXNoKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU2luZ2xlRG90KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIGlmIChjaGFyICE9ICcvJyAmJiAhKGNoYXIgPT0gJ1xcXFwnICYmIGlzU3BlY2lhbCh1cmwpKSkge1xuICAgICAgICAgICAgICB1cmwucGF0aC5wdXNoKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmICF1cmwucGF0aC5sZW5ndGggJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgICBpZiAodXJsLmhvc3QpIHVybC5ob3N0ID0gJyc7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5jaGFyQXQoMCkgKyAnOic7IC8vIG5vcm1hbGl6ZSB3aW5kb3dzIGRyaXZlIGxldHRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsLnBhdGgucHVzaChidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgKGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnKSkge1xuICAgICAgICAgICAgd2hpbGUgKHVybC5wYXRoLmxlbmd0aCA+IDEgJiYgdXJsLnBhdGhbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgIHVybC5wYXRoLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyID09ICc/Jykge1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgcGF0aFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEg6XG4gICAgICAgIGlmIChjaGFyID09ICc/Jykge1xuICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gUVVFUlk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcbiAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgIT0gRU9GKSB7XG4gICAgICAgICAgdXJsLnBhdGhbMF0gKz0gcGVyY2VudEVuY29kZShjaGFyLCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgfSBicmVhaztcblxuICAgICAgY2FzZSBRVUVSWTpcbiAgICAgICAgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNoYXIgPT0gJyMnKSB7XG4gICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyICE9IEVPRikge1xuICAgICAgICAgIGlmIChjaGFyID09IFwiJ1wiICYmIGlzU3BlY2lhbCh1cmwpKSB1cmwucXVlcnkgKz0gJyUyNyc7XG4gICAgICAgICAgZWxzZSBpZiAoY2hhciA9PSAnIycpIHVybC5xdWVyeSArPSAnJTIzJztcbiAgICAgICAgICBlbHNlIHVybC5xdWVyeSArPSBwZXJjZW50RW5jb2RlKGNoYXIsIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIEZSQUdNRU5UOlxuICAgICAgICBpZiAoY2hhciAhPSBFT0YpIHVybC5mcmFnbWVudCArPSBwZXJjZW50RW5jb2RlKGNoYXIsIGZyYWdtZW50UGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvaW50ZXIrKztcbiAgfVxufTtcblxuLy8gYFVSTGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLWNsYXNzXG52YXIgVVJMQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBVUkwodXJsIC8qICwgYmFzZSAqLykge1xuICB2YXIgdGhhdCA9IGFuSW5zdGFuY2UodGhpcywgVVJMQ29uc3RydWN0b3IsICdVUkwnKTtcbiAgdmFyIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIHVybFN0cmluZyA9IFN0cmluZyh1cmwpO1xuICB2YXIgc3RhdGUgPSBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHsgdHlwZTogJ1VSTCcgfSk7XG4gIHZhciBiYXNlU3RhdGUsIGZhaWx1cmU7XG4gIGlmIChiYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoYmFzZSBpbnN0YW5jZW9mIFVSTENvbnN0cnVjdG9yKSBiYXNlU3RhdGUgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKGJhc2UpO1xuICAgIGVsc2Uge1xuICAgICAgZmFpbHVyZSA9IHBhcnNlVVJMKGJhc2VTdGF0ZSA9IHt9LCBTdHJpbmcoYmFzZSkpO1xuICAgICAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvcihmYWlsdXJlKTtcbiAgICB9XG4gIH1cbiAgZmFpbHVyZSA9IHBhcnNlVVJMKHN0YXRlLCB1cmxTdHJpbmcsIG51bGwsIGJhc2VTdGF0ZSk7XG4gIGlmIChmYWlsdXJlKSB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XG4gIHZhciBzZWFyY2hQYXJhbXMgPSBzdGF0ZS5zZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIHZhciBzZWFyY2hQYXJhbXNTdGF0ZSA9IGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUoc2VhcmNoUGFyYW1zKTtcbiAgc2VhcmNoUGFyYW1zU3RhdGUudXBkYXRlU2VhcmNoUGFyYW1zKHN0YXRlLnF1ZXJ5KTtcbiAgc2VhcmNoUGFyYW1zU3RhdGUudXBkYXRlVVJMID0gZnVuY3Rpb24gKCkge1xuICAgIHN0YXRlLnF1ZXJ5ID0gU3RyaW5nKHNlYXJjaFBhcmFtcykgfHwgbnVsbDtcbiAgfTtcbiAgaWYgKCFERVNDUklQVE9SUykge1xuICAgIHRoYXQuaHJlZiA9IHNlcmlhbGl6ZVVSTC5jYWxsKHRoYXQpO1xuICAgIHRoYXQub3JpZ2luID0gZ2V0T3JpZ2luLmNhbGwodGhhdCk7XG4gICAgdGhhdC5wcm90b2NvbCA9IGdldFByb3RvY29sLmNhbGwodGhhdCk7XG4gICAgdGhhdC51c2VybmFtZSA9IGdldFVzZXJuYW1lLmNhbGwodGhhdCk7XG4gICAgdGhhdC5wYXNzd29yZCA9IGdldFBhc3N3b3JkLmNhbGwodGhhdCk7XG4gICAgdGhhdC5ob3N0ID0gZ2V0SG9zdC5jYWxsKHRoYXQpO1xuICAgIHRoYXQuaG9zdG5hbWUgPSBnZXRIb3N0bmFtZS5jYWxsKHRoYXQpO1xuICAgIHRoYXQucG9ydCA9IGdldFBvcnQuY2FsbCh0aGF0KTtcbiAgICB0aGF0LnBhdGhuYW1lID0gZ2V0UGF0aG5hbWUuY2FsbCh0aGF0KTtcbiAgICB0aGF0LnNlYXJjaCA9IGdldFNlYXJjaC5jYWxsKHRoYXQpO1xuICAgIHRoYXQuc2VhcmNoUGFyYW1zID0gZ2V0U2VhcmNoUGFyYW1zLmNhbGwodGhhdCk7XG4gICAgdGhhdC5oYXNoID0gZ2V0SGFzaC5jYWxsKHRoYXQpO1xuICB9XG59O1xuXG52YXIgVVJMUHJvdG90eXBlID0gVVJMQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG52YXIgc2VyaWFsaXplVVJMID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgdmFyIHNjaGVtZSA9IHVybC5zY2hlbWU7XG4gIHZhciB1c2VybmFtZSA9IHVybC51c2VybmFtZTtcbiAgdmFyIHBhc3N3b3JkID0gdXJsLnBhc3N3b3JkO1xuICB2YXIgaG9zdCA9IHVybC5ob3N0O1xuICB2YXIgcG9ydCA9IHVybC5wb3J0O1xuICB2YXIgcGF0aCA9IHVybC5wYXRoO1xuICB2YXIgcXVlcnkgPSB1cmwucXVlcnk7XG4gIHZhciBmcmFnbWVudCA9IHVybC5mcmFnbWVudDtcbiAgdmFyIG91dHB1dCA9IHNjaGVtZSArICc6JztcbiAgaWYgKGhvc3QgIT09IG51bGwpIHtcbiAgICBvdXRwdXQgKz0gJy8vJztcbiAgICBpZiAoaW5jbHVkZXNDcmVkZW50aWFscyh1cmwpKSB7XG4gICAgICBvdXRwdXQgKz0gdXNlcm5hbWUgKyAocGFzc3dvcmQgPyAnOicgKyBwYXNzd29yZCA6ICcnKSArICdAJztcbiAgICB9XG4gICAgb3V0cHV0ICs9IHNlcmlhbGl6ZUhvc3QoaG9zdCk7XG4gICAgaWYgKHBvcnQgIT09IG51bGwpIG91dHB1dCArPSAnOicgKyBwb3J0O1xuICB9IGVsc2UgaWYgKHNjaGVtZSA9PSAnZmlsZScpIG91dHB1dCArPSAnLy8nO1xuICBvdXRwdXQgKz0gdXJsLmNhbm5vdEJlQUJhc2VVUkwgPyBwYXRoWzBdIDogcGF0aC5sZW5ndGggPyAnLycgKyBwYXRoLmpvaW4oJy8nKSA6ICcnO1xuICBpZiAocXVlcnkgIT09IG51bGwpIG91dHB1dCArPSAnPycgKyBxdWVyeTtcbiAgaWYgKGZyYWdtZW50ICE9PSBudWxsKSBvdXRwdXQgKz0gJyMnICsgZnJhZ21lbnQ7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG52YXIgZ2V0T3JpZ2luID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgdmFyIHNjaGVtZSA9IHVybC5zY2hlbWU7XG4gIHZhciBwb3J0ID0gdXJsLnBvcnQ7XG4gIGlmIChzY2hlbWUgPT0gJ2Jsb2InKSB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKHNjaGVtZS5wYXRoWzBdKS5vcmlnaW47XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuICBpZiAoc2NoZW1lID09ICdmaWxlJyB8fCAhaXNTcGVjaWFsKHVybCkpIHJldHVybiAnbnVsbCc7XG4gIHJldHVybiBzY2hlbWUgKyAnOi8vJyArIHNlcmlhbGl6ZUhvc3QodXJsLmhvc3QpICsgKHBvcnQgIT09IG51bGwgPyAnOicgKyBwb3J0IDogJycpO1xufTtcblxudmFyIGdldFByb3RvY29sID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5zY2hlbWUgKyAnOic7XG59O1xuXG52YXIgZ2V0VXNlcm5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnVzZXJuYW1lO1xufTtcblxudmFyIGdldFBhc3N3b3JkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5wYXNzd29yZDtcbn07XG5cbnZhciBnZXRIb3N0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgdmFyIGhvc3QgPSB1cmwuaG9zdDtcbiAgdmFyIHBvcnQgPSB1cmwucG9ydDtcbiAgcmV0dXJuIGhvc3QgPT09IG51bGwgPyAnJ1xuICAgIDogcG9ydCA9PT0gbnVsbCA/IHNlcmlhbGl6ZUhvc3QoaG9zdClcbiAgICA6IHNlcmlhbGl6ZUhvc3QoaG9zdCkgKyAnOicgKyBwb3J0O1xufTtcblxudmFyIGdldEhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaG9zdCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcykuaG9zdDtcbiAgcmV0dXJuIGhvc3QgPT09IG51bGwgPyAnJyA6IHNlcmlhbGl6ZUhvc3QoaG9zdCk7XG59O1xuXG52YXIgZ2V0UG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBvcnQgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnBvcnQ7XG4gIHJldHVybiBwb3J0ID09PSBudWxsID8gJycgOiBTdHJpbmcocG9ydCk7XG59O1xuXG52YXIgZ2V0UGF0aG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICB2YXIgcGF0aCA9IHVybC5wYXRoO1xuICByZXR1cm4gdXJsLmNhbm5vdEJlQUJhc2VVUkwgPyBwYXRoWzBdIDogcGF0aC5sZW5ndGggPyAnLycgKyBwYXRoLmpvaW4oJy8nKSA6ICcnO1xufTtcblxudmFyIGdldFNlYXJjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5xdWVyeTtcbiAgcmV0dXJuIHF1ZXJ5ID8gJz8nICsgcXVlcnkgOiAnJztcbn07XG5cbnZhciBnZXRTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnNlYXJjaFBhcmFtcztcbn07XG5cbnZhciBnZXRIYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZnJhZ21lbnQgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLmZyYWdtZW50O1xuICByZXR1cm4gZnJhZ21lbnQgPyAnIycgKyBmcmFnbWVudCA6ICcnO1xufTtcblxudmFyIGFjY2Vzc29yRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChnZXR0ZXIsIHNldHRlcikge1xuICByZXR1cm4geyBnZXQ6IGdldHRlciwgc2V0OiBzZXR0ZXIsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSB9O1xufTtcblxuaWYgKERFU0NSSVBUT1JTKSB7XG4gIGRlZmluZVByb3BlcnRpZXMoVVJMUHJvdG90eXBlLCB7XG4gICAgLy8gYFVSTC5wcm90b3R5cGUuaHJlZmAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaHJlZlxuICAgIGhyZWY6IGFjY2Vzc29yRGVzY3JpcHRvcihzZXJpYWxpemVVUkwsIGZ1bmN0aW9uIChocmVmKSB7XG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgICAgIHZhciB1cmxTdHJpbmcgPSBTdHJpbmcoaHJlZik7XG4gICAgICB2YXIgZmFpbHVyZSA9IHBhcnNlVVJMKHVybCwgdXJsU3RyaW5nKTtcbiAgICAgIGlmIChmYWlsdXJlKSB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XG4gICAgICBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHVybC5zZWFyY2hQYXJhbXMpLnVwZGF0ZVNlYXJjaFBhcmFtcyh1cmwucXVlcnkpO1xuICAgIH0pLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLm9yaWdpbmAgZ2V0dGVyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLW9yaWdpblxuICAgIG9yaWdpbjogYWNjZXNzb3JEZXNjcmlwdG9yKGdldE9yaWdpbiksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUucHJvdG9jb2xgIGFjY2Vzc29ycyBwYWlyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXByb3RvY29sXG4gICAgcHJvdG9jb2w6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRQcm90b2NvbCwgZnVuY3Rpb24gKHByb3RvY29sKSB7XG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgICAgIHBhcnNlVVJMKHVybCwgU3RyaW5nKHByb3RvY29sKSArICc6JywgU0NIRU1FX1NUQVJUKTtcbiAgICB9KSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS51c2VybmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtdXNlcm5hbWVcbiAgICB1c2VybmFtZTogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFVzZXJuYW1lLCBmdW5jdGlvbiAodXNlcm5hbWUpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oU3RyaW5nKHVzZXJuYW1lKSk7XG4gICAgICBpZiAoY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KHVybCkpIHJldHVybjtcbiAgICAgIHVybC51c2VybmFtZSA9ICcnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVybC51c2VybmFtZSArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaV0sIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICAgICB9XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUucGFzc3dvcmRgIGFjY2Vzc29ycyBwYWlyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhc3N3b3JkXG4gICAgcGFzc3dvcmQ6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRQYXNzd29yZCwgZnVuY3Rpb24gKHBhc3N3b3JkKSB7XG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgICAgIHZhciBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKFN0cmluZyhwYXNzd29yZCkpO1xuICAgICAgaWYgKGNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydCh1cmwpKSByZXR1cm47XG4gICAgICB1cmwucGFzc3dvcmQgPSAnJztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cmwucGFzc3dvcmQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2ldLCB1c2VyaW5mb1BlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLmhvc3RgIGFjY2Vzc29ycyBwYWlyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhvc3RcbiAgICBob3N0OiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0SG9zdCwgZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgaWYgKHVybC5jYW5ub3RCZUFCYXNlVVJMKSByZXR1cm47XG4gICAgICBwYXJzZVVSTCh1cmwsIFN0cmluZyhob3N0KSwgSE9TVCk7XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuaG9zdG5hbWVgIGFjY2Vzc29ycyBwYWlyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhvc3RuYW1lXG4gICAgaG9zdG5hbWU6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRIb3N0bmFtZSwgZnVuY3Rpb24gKGhvc3RuYW1lKSB7XG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgICAgIGlmICh1cmwuY2Fubm90QmVBQmFzZVVSTCkgcmV0dXJuO1xuICAgICAgcGFyc2VVUkwodXJsLCBTdHJpbmcoaG9zdG5hbWUpLCBIT1NUTkFNRSk7XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUucG9ydGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcG9ydFxuICAgIHBvcnQ6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRQb3J0LCBmdW5jdGlvbiAocG9ydCkge1xuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICAgICBpZiAoY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KHVybCkpIHJldHVybjtcbiAgICAgIHBvcnQgPSBTdHJpbmcocG9ydCk7XG4gICAgICBpZiAocG9ydCA9PSAnJykgdXJsLnBvcnQgPSBudWxsO1xuICAgICAgZWxzZSBwYXJzZVVSTCh1cmwsIHBvcnQsIFBPUlQpO1xuICAgIH0pLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnBhdGhuYW1lYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wYXRobmFtZVxuICAgIHBhdGhuYW1lOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0UGF0aG5hbWUsIGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICAgICBpZiAodXJsLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICAgIHVybC5wYXRoID0gW107XG4gICAgICBwYXJzZVVSTCh1cmwsIHBhdGhuYW1lICsgJycsIFBBVEhfU1RBUlQpO1xuICAgIH0pLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnNlYXJjaGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtc2VhcmNoXG4gICAgc2VhcmNoOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0U2VhcmNoLCBmdW5jdGlvbiAoc2VhcmNoKSB7XG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgICAgIHNlYXJjaCA9IFN0cmluZyhzZWFyY2gpO1xuICAgICAgaWYgKHNlYXJjaCA9PSAnJykge1xuICAgICAgICB1cmwucXVlcnkgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCc/JyA9PSBzZWFyY2guY2hhckF0KDApKSBzZWFyY2ggPSBzZWFyY2guc2xpY2UoMSk7XG4gICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICBwYXJzZVVSTCh1cmwsIHNlYXJjaCwgUVVFUlkpO1xuICAgICAgfVxuICAgICAgZ2V0SW50ZXJuYWxTZWFyY2hQYXJhbXNTdGF0ZSh1cmwuc2VhcmNoUGFyYW1zKS51cGRhdGVTZWFyY2hQYXJhbXModXJsLnF1ZXJ5KTtcbiAgICB9KSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5zZWFyY2hQYXJhbXNgIGdldHRlclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1zZWFyY2hwYXJhbXNcbiAgICBzZWFyY2hQYXJhbXM6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRTZWFyY2hQYXJhbXMpLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLmhhc2hgIGFjY2Vzc29ycyBwYWlyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhhc2hcbiAgICBoYXNoOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0SGFzaCwgZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgaGFzaCA9IFN0cmluZyhoYXNoKTtcbiAgICAgIGlmIChoYXNoID09ICcnKSB7XG4gICAgICAgIHVybC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgnIycgPT0gaGFzaC5jaGFyQXQoMCkpIGhhc2ggPSBoYXNoLnNsaWNlKDEpO1xuICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICBwYXJzZVVSTCh1cmwsIGhhc2gsIEZSQUdNRU5UKTtcbiAgICB9KVxuICB9KTtcbn1cblxuLy8gYFVSTC5wcm90b3R5cGUudG9KU09OYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC10b2pzb25cbnJlZGVmaW5lKFVSTFByb3RvdHlwZSwgJ3RvSlNPTicsIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZVVSTC5jYWxsKHRoaXMpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vLyBgVVJMLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI1VSTC1zdHJpbmdpZmljYXRpb24tYmVoYXZpb3JcbnJlZGVmaW5lKFVSTFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBzZXJpYWxpemVVUkwuY2FsbCh0aGlzKTtcbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuaWYgKE5hdGl2ZVVSTCkge1xuICB2YXIgbmF0aXZlQ3JlYXRlT2JqZWN0VVJMID0gTmF0aXZlVVJMLmNyZWF0ZU9iamVjdFVSTDtcbiAgdmFyIG5hdGl2ZVJldm9rZU9iamVjdFVSTCA9IE5hdGl2ZVVSTC5yZXZva2VPYmplY3RVUkw7XG4gIC8vIGBVUkwuY3JlYXRlT2JqZWN0VVJMYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9jcmVhdGVPYmplY3RVUkxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmIChuYXRpdmVDcmVhdGVPYmplY3RVUkwpIHJlZGVmaW5lKFVSTENvbnN0cnVjdG9yLCAnY3JlYXRlT2JqZWN0VVJMJywgZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMKGJsb2IpIHtcbiAgICByZXR1cm4gbmF0aXZlQ3JlYXRlT2JqZWN0VVJMLmFwcGx5KE5hdGl2ZVVSTCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIC8vIGBVUkwucmV2b2tlT2JqZWN0VVJMYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9yZXZva2VPYmplY3RVUkxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmIChuYXRpdmVSZXZva2VPYmplY3RVUkwpIHJlZGVmaW5lKFVSTENvbnN0cnVjdG9yLCAncmV2b2tlT2JqZWN0VVJMJywgZnVuY3Rpb24gcmV2b2tlT2JqZWN0VVJMKHVybCkge1xuICAgIHJldHVybiBuYXRpdmVSZXZva2VPYmplY3RVUkwuYXBwbHkoTmF0aXZlVVJMLCBhcmd1bWVudHMpO1xuICB9KTtcbn1cblxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJykoVVJMQ29uc3RydWN0b3IsICdVUkwnKTtcblxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgVVJMOiBVUkxDb25zdHJ1Y3RvclxufSk7XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuSlNFbmNyeXB0ID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBCSV9STSA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG5mdW5jdGlvbiBpbnQyY2hhcihuKSB7XG4gICAgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTtcbn1cbi8vI3JlZ2lvbiBCSVRfT1BFUkFUSU9OU1xuLy8gKHB1YmxpYykgdGhpcyAmIGFcbmZ1bmN0aW9uIG9wX2FuZCh4LCB5KSB7XG4gICAgcmV0dXJuIHggJiB5O1xufVxuLy8gKHB1YmxpYykgdGhpcyB8IGFcbmZ1bmN0aW9uIG9wX29yKHgsIHkpIHtcbiAgICByZXR1cm4geCB8IHk7XG59XG4vLyAocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgsIHkpIHtcbiAgICByZXR1cm4geCBeIHk7XG59XG4vLyAocHVibGljKSB0aGlzICYgfmFcbmZ1bmN0aW9uIG9wX2FuZG5vdCh4LCB5KSB7XG4gICAgcmV0dXJuIHggJiB+eTtcbn1cbi8vIHJldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuICAgIGlmICh4ID09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh4ICYgMHhmZmZmKSA9PSAwKSB7XG4gICAgICAgIHggPj49IDE2O1xuICAgICAgICByICs9IDE2O1xuICAgIH1cbiAgICBpZiAoKHggJiAweGZmKSA9PSAwKSB7XG4gICAgICAgIHggPj49IDg7XG4gICAgICAgIHIgKz0gODtcbiAgICB9XG4gICAgaWYgKCh4ICYgMHhmKSA9PSAwKSB7XG4gICAgICAgIHggPj49IDQ7XG4gICAgICAgIHIgKz0gNDtcbiAgICB9XG4gICAgaWYgKCh4ICYgMykgPT0gMCkge1xuICAgICAgICB4ID4+PSAyO1xuICAgICAgICByICs9IDI7XG4gICAgfVxuICAgIGlmICgoeCAmIDEpID09IDApIHtcbiAgICAgICAgKytyO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbi8vIHJldHVybiBudW1iZXIgb2YgMSBiaXRzIGluIHhcbmZ1bmN0aW9uIGNiaXQoeCkge1xuICAgIHZhciByID0gMDtcbiAgICB3aGlsZSAoeCAhPSAwKSB7XG4gICAgICAgIHggJj0geCAtIDE7XG4gICAgICAgICsrcjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG4vLyNlbmRyZWdpb24gQklUX09QRVJBVElPTlNcblxudmFyIGI2NG1hcCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xudmFyIGI2NHBhZCA9IFwiPVwiO1xuZnVuY3Rpb24gaGV4MmI2NChoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGM7XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgZm9yIChpID0gMDsgaSArIDMgPD0gaC5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoaSwgaSArIDMpLCAxNik7XG4gICAgICAgIHJldCArPSBiNjRtYXAuY2hhckF0KGMgPj4gNikgKyBiNjRtYXAuY2hhckF0KGMgJiA2Myk7XG4gICAgfVxuICAgIGlmIChpICsgMSA9PSBoLmxlbmd0aCkge1xuICAgICAgICBjID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoaSwgaSArIDEpLCAxNik7XG4gICAgICAgIHJldCArPSBiNjRtYXAuY2hhckF0KGMgPDwgMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGkgKyAyID09IGgubGVuZ3RoKSB7XG4gICAgICAgIGMgPSBwYXJzZUludChoLnN1YnN0cmluZyhpLCBpICsgMiksIDE2KTtcbiAgICAgICAgcmV0ICs9IGI2NG1hcC5jaGFyQXQoYyA+PiAyKSArIGI2NG1hcC5jaGFyQXQoKGMgJiAzKSA8PCA0KTtcbiAgICB9XG4gICAgd2hpbGUgKChyZXQubGVuZ3RoICYgMykgPiAwKSB7XG4gICAgICAgIHJldCArPSBiNjRwYWQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vLyBjb252ZXJ0IGEgYmFzZTY0IHN0cmluZyB0byBoZXhcbmZ1bmN0aW9uIGI2NHRvaGV4KHMpIHtcbiAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICB2YXIgaTtcbiAgICB2YXIgayA9IDA7IC8vIGI2NCBzdGF0ZSwgMC0zXG4gICAgdmFyIHNsb3AgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBiNjRwYWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ID0gYjY0bWFwLmluZGV4T2Yocy5jaGFyQXQoaSkpO1xuICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrID09IDApIHtcbiAgICAgICAgICAgIHJldCArPSBpbnQyY2hhcih2ID4+IDIpO1xuICAgICAgICAgICAgc2xvcCA9IHYgJiAzO1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoayA9PSAxKSB7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIoKHNsb3AgPDwgMikgfCAodiA+PiA0KSk7XG4gICAgICAgICAgICBzbG9wID0gdiAmIDB4ZjtcbiAgICAgICAgICAgIGsgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGsgPT0gMikge1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKHNsb3ApO1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKHYgPj4gMik7XG4gICAgICAgICAgICBzbG9wID0gdiAmIDM7XG4gICAgICAgICAgICBrID0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBpbnQyY2hhcigoc2xvcCA8PCAyKSB8ICh2ID4+IDQpKTtcbiAgICAgICAgICAgIHJldCArPSBpbnQyY2hhcih2ICYgMHhmKTtcbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChrID09IDEpIHtcbiAgICAgICAgcmV0ICs9IGludDJjaGFyKHNsb3AgPDwgMik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cblxuLy8gSGV4IEphdmFTY3JpcHQgZGVjb2RlclxuLy8gQ29weXJpZ2h0IChjKSAyMDA4LTIwMTMgTGFwbyBMdWNoaW5pIDxsYXBvQGxhcG8uaXQ+XG4vLyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbi8vIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbi8vIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4vLyBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4vLyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4vLyBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCBpbW1lZDogdHJ1ZSwgbGF0ZWRlZjogdHJ1ZSwgdW5kZWY6IHRydWUsIHJlZ2V4ZGFzaDogZmFsc2UgKi9cbnZhciBkZWNvZGVyO1xudmFyIEhleCA9IHtcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAoZGVjb2RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaGV4ID0gXCIwMTIzNDU2Nzg5QUJDREVGXCI7XG4gICAgICAgICAgICB2YXIgaWdub3JlID0gXCIgXFxmXFxuXFxyXFx0XFx1MDBBMFxcdTIwMjhcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWNvZGVyID0ge307XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXJbaGV4LmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGV4ID0gaGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAxMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyW2hleC5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpZ25vcmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyW2lnbm9yZS5jaGFyQXQoaSldID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICB2YXIgYml0cyA9IDA7XG4gICAgICAgIHZhciBjaGFyX2NvdW50ID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gYS5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA9PSBcIj1cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyA9IGRlY29kZXJbY107XG4gICAgICAgICAgICBpZiAoYyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgY2hhcmFjdGVyIGF0IG9mZnNldCBcIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cyB8PSBjO1xuICAgICAgICAgICAgaWYgKCsrY2hhcl9jb3VudCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gYml0cztcbiAgICAgICAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAgICAgICBjaGFyX2NvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpdHMgPDw9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJfY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhleCBlbmNvZGluZyBpbmNvbXBsZXRlOiA0IGJpdHMgbWlzc2luZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn07XG5cbi8vIEJhc2U2NCBKYXZhU2NyaXB0IGRlY29kZXJcbi8vIENvcHlyaWdodCAoYykgMjAwOC0yMDEzIExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0PlxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4vLyBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXG52YXIgZGVjb2RlciQxO1xudmFyIEJhc2U2NCA9IHtcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAoZGVjb2RlciQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbiAgICAgICAgICAgIHZhciBpZ25vcmUgPSBcIj0gXFxmXFxuXFxyXFx0XFx1MDBBMFxcdTIwMjhcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWNvZGVyJDEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyJDFbYjY0LmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlnbm9yZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXIkMVtpZ25vcmUuY2hhckF0KGkpXSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgdmFyIGJpdHMgPSAwO1xuICAgICAgICB2YXIgY2hhcl9jb3VudCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGEuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSBkZWNvZGVyJDFbY107XG4gICAgICAgICAgICBpZiAoYyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgY2hhcmFjdGVyIGF0IG9mZnNldCBcIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0cyB8PSBjO1xuICAgICAgICAgICAgaWYgKCsrY2hhcl9jb3VudCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gKGJpdHMgPj4gMTYpO1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSBiaXRzICYgMHhGRjtcbiAgICAgICAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAgICAgICBjaGFyX2NvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpdHMgPDw9IDY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjaGFyX2NvdW50KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFzZTY0IGVuY29kaW5nIGluY29tcGxldGU6IGF0IGxlYXN0IDIgYml0cyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDEwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiAxNik7XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gKGJpdHMgPj4gOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSxcbiAgICByZTogLy0tLS0tQkVHSU4gW14tXSstLS0tLShbQS1aYS16MC05K1xcLz1cXHNdKyktLS0tLUVORCBbXi1dKy0tLS0tfGJlZ2luLWJhc2U2NFteXFxuXStcXG4oW0EtWmEtejAtOStcXC89XFxzXSspPT09PS8sXG4gICAgdW5hcm1vcjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIG0gPSBCYXNlNjQucmUuZXhlYyhhKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGlmIChtWzFdKSB7XG4gICAgICAgICAgICAgICAgYSA9IG1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtWzJdKSB7XG4gICAgICAgICAgICAgICAgYSA9IG1bMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdFeHAgb3V0IG9mIHN5bmNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJhc2U2NC5kZWNvZGUoYSk7XG4gICAgfVxufTtcblxuLy8gQmlnIGludGVnZXIgYmFzZS0xMCBwcmludGluZyBsaWJyYXJ5XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQgTGFwbyBMdWNoaW5pIDxsYXBvQGxhcG8uaXQ+XG4vLyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbi8vIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbi8vIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4vLyBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4vLyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4vLyBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCBpbW1lZDogdHJ1ZSwgbGF0ZWRlZjogdHJ1ZSwgdW5kZWY6IHRydWUsIHJlZ2V4ZGFzaDogZmFsc2UgKi9cbnZhciBtYXggPSAxMDAwMDAwMDAwMDAwMDsgLy8gYmlnZ2VzdCBpbnRlZ2VyIHRoYXQgY2FuIHN0aWxsIGZpdCAyXjUzIHdoZW4gbXVsdGlwbGllZCBieSAyNTZcbnZhciBJbnQxMCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnQxMCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1ZiA9IFsrdmFsdWUgfHwgMF07XG4gICAgfVxuICAgIEludDEwLnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiAobSwgYykge1xuICAgICAgICAvLyBhc3NlcnQobSA8PSAyNTYpXG4gICAgICAgIHZhciBiID0gdGhpcy5idWY7XG4gICAgICAgIHZhciBsID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdCA9IGJbaV0gKiBtICsgYztcbiAgICAgICAgICAgIGlmICh0IDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjID0gMCB8ICh0IC8gbWF4KTtcbiAgICAgICAgICAgICAgICB0IC09IGMgKiBtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiW2ldID0gdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA+IDApIHtcbiAgICAgICAgICAgIGJbaV0gPSBjO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnQxMC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gYXNzZXJ0KG0gPD0gMjU2KVxuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xuICAgICAgICB2YXIgbCA9IGIubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHQgPSBiW2ldIC0gYztcbiAgICAgICAgICAgIGlmICh0IDwgMCkge1xuICAgICAgICAgICAgICAgIHQgKz0gbWF4O1xuICAgICAgICAgICAgICAgIGMgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiW2ldID0gdDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYltiLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgICAgICBiLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnQxMC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICBpZiAoKGJhc2UgfHwgMTApICE9IDEwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IGJhc2UgMTAgaXMgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gdGhpcy5idWY7XG4gICAgICAgIHZhciBzID0gYltiLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBiLmxlbmd0aCAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBzICs9IChtYXggKyBiW2ldKS50b1N0cmluZygpLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIEludDEwLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xuICAgICAgICB2YXIgdiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBiLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICB2ID0gdiAqIG1heCArIGJbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgICBJbnQxMC5wcm90b3R5cGUuc2ltcGxpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5idWY7XG4gICAgICAgIHJldHVybiAoYi5sZW5ndGggPT0gMSkgPyBiWzBdIDogdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBJbnQxMDtcbn0oKSk7XG5cbi8vIEFTTi4xIEphdmFTY3JpcHQgZGVjb2RlclxudmFyIGVsbGlwc2lzID0gXCJcXHUyMDI2XCI7XG52YXIgcmVUaW1lUyA9IC9eKFxcZFxcZCkoMFsxLTldfDFbMC0yXSkoMFsxLTldfFsxMl1cXGR8M1swMV0pKFswMV1cXGR8MlswLTNdKSg/OihbMC01XVxcZCkoPzooWzAtNV1cXGQpKD86Wy4sXShcXGR7MSwzfSkpPyk/KT8oWnxbLStdKD86WzBdXFxkfDFbMC0yXSkoWzAtNV1cXGQpPyk/JC87XG52YXIgcmVUaW1lTCA9IC9eKFxcZFxcZFxcZFxcZCkoMFsxLTldfDFbMC0yXSkoMFsxLTldfFsxMl1cXGR8M1swMV0pKFswMV1cXGR8MlswLTNdKSg/OihbMC01XVxcZCkoPzooWzAtNV1cXGQpKD86Wy4sXShcXGR7MSwzfSkpPyk/KT8oWnxbLStdKD86WzBdXFxkfDFbMC0yXSkoWzAtNV1cXGQpPyk/JC87XG5mdW5jdGlvbiBzdHJpbmdDdXQoc3RyLCBsZW4pIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IGxlbikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGxlbikgKyBlbGxpcHNpcztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbnZhciBTdHJlYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyZWFtKGVuYywgcG9zKSB7XG4gICAgICAgIHRoaXMuaGV4RGlnaXRzID0gXCIwMTIzNDU2Nzg5QUJDREVGXCI7XG4gICAgICAgIGlmIChlbmMgaW5zdGFuY2VvZiBTdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuZW5jID0gZW5jLmVuYztcbiAgICAgICAgICAgIHRoaXMucG9zID0gZW5jLnBvcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVuYyBzaG91bGQgYmUgYW4gYXJyYXkgb3IgYSBiaW5hcnkgc3RyaW5nXG4gICAgICAgICAgICB0aGlzLmVuYyA9IGVuYztcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN0cmVhbS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMucG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmVuYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVlc3RpbmcgYnl0ZSBvZmZzZXQgXCIgKyBwb3MgKyBcIiBvbiBhIHN0cmVhbSBvZiBsZW5ndGggXCIgKyB0aGlzLmVuYy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoaXMuZW5jKSA/IHRoaXMuZW5jLmNoYXJDb2RlQXQocG9zKSA6IHRoaXMuZW5jW3Bvc107XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLmhleEJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gdGhpcy5oZXhEaWdpdHMuY2hhckF0KChiID4+IDQpICYgMHhGKSArIHRoaXMuaGV4RGlnaXRzLmNoYXJBdChiICYgMHhGKTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuaGV4RHVtcCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCByYXcpIHtcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgcyArPSB0aGlzLmhleEJ5dGUodGhpcy5nZXQoaSkpO1xuICAgICAgICAgICAgaWYgKHJhdyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaSAmIDB4Rikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4NzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gXCIgIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHhGOlxuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuaXNBU0NJSSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZ2V0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTc2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVN0cmluZ0lTTyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmdldChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlU3RyaW5nVVRGID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7KSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZ2V0KGkrKyk7XG4gICAgICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChjID4gMTkxKSAmJiAoYyA8IDIyNCkpIHtcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgxRikgPDwgNikgfCAodGhpcy5nZXQoaSsrKSAmIDB4M0YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDBGKSA8PCAxMikgfCAoKHRoaXMuZ2V0KGkrKykgJiAweDNGKSA8PCA2KSB8ICh0aGlzLmdldChpKyspICYgMHgzRikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVN0cmluZ0JNUCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICB2YXIgaGk7XG4gICAgICAgIHZhciBsbztcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOykge1xuICAgICAgICAgICAgaGkgPSB0aGlzLmdldChpKyspO1xuICAgICAgICAgICAgbG8gPSB0aGlzLmdldChpKyspO1xuICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGhpIDw8IDgpIHwgbG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlVGltZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzaG9ydFllYXIpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnBhcnNlU3RyaW5nSVNPKHN0YXJ0LCBlbmQpO1xuICAgICAgICB2YXIgbSA9IChzaG9ydFllYXIgPyByZVRpbWVTIDogcmVUaW1lTCkuZXhlYyhzKTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJVbnJlY29nbml6ZWQgdGltZTogXCIgKyBzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG9ydFllYXIpIHtcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHF1ZXJ5aW5nIHRoZSB0aW1lciwgdXNlIHRoZSBmaXhlZCByYW5nZSBbMTk3MCwgMjA2OV1cbiAgICAgICAgICAgIC8vIGl0IHdpbGwgY29uZm9ybSB3aXRoIElUVSBYLjQwMCBbLTEwLCArNDBdIHNsaWRpbmcgd2luZG93IHVudGlsIDIwMzBcbiAgICAgICAgICAgIG1bMV0gPSArbVsxXTtcbiAgICAgICAgICAgIG1bMV0gKz0gKCttWzFdIDwgNzApID8gMjAwMCA6IDE5MDA7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IG1bMV0gKyBcIi1cIiArIG1bMl0gKyBcIi1cIiArIG1bM10gKyBcIiBcIiArIG1bNF07XG4gICAgICAgIGlmIChtWzVdKSB7XG4gICAgICAgICAgICBzICs9IFwiOlwiICsgbVs1XTtcbiAgICAgICAgICAgIGlmIChtWzZdKSB7XG4gICAgICAgICAgICAgICAgcyArPSBcIjpcIiArIG1bNl07XG4gICAgICAgICAgICAgICAgaWYgKG1bN10pIHtcbiAgICAgICAgICAgICAgICAgICAgcyArPSBcIi5cIiArIG1bN107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtWzhdKSB7XG4gICAgICAgICAgICBzICs9IFwiIFVUQ1wiO1xuICAgICAgICAgICAgaWYgKG1bOF0gIT0gXCJaXCIpIHtcbiAgICAgICAgICAgICAgICBzICs9IG1bOF07XG4gICAgICAgICAgICAgICAgaWYgKG1bOV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcyArPSBcIjpcIiArIG1bOV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZUludGVnZXIgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0KHN0YXJ0KTtcbiAgICAgICAgdmFyIG5lZyA9ICh2ID4gMTI3KTtcbiAgICAgICAgdmFyIHBhZCA9IG5lZyA/IDI1NSA6IDA7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgLy8gc2tpcCB1bnVzZWZ1bCBiaXRzIChub3QgYWxsb3dlZCBpbiBERVIpXG4gICAgICAgIHdoaWxlICh2ID09IHBhZCAmJiArK3N0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5nZXQoc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmVnID8gLTEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNob3cgYml0IGxlbmd0aCBvZiBodWdlIGludGVnZXJzXG4gICAgICAgIGlmIChsZW4gPiA0KSB7XG4gICAgICAgICAgICBzID0gdjtcbiAgICAgICAgICAgIGxlbiA8PD0gMztcbiAgICAgICAgICAgIHdoaWxlICgoKCtzIF4gcGFkKSAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgICAgICBzID0gK3MgPDwgMTtcbiAgICAgICAgICAgICAgICAtLWxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBcIihcIiArIGxlbiArIFwiIGJpdClcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWNvZGUgdGhlIGludGVnZXJcbiAgICAgICAgaWYgKG5lZykge1xuICAgICAgICAgICAgdiA9IHYgLSAyNTY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBuZXcgSW50MTAodik7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgbi5tdWxBZGQoMjU2LCB0aGlzLmdldChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMgKyBuLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlQml0U3RyaW5nID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdW51c2VkQml0ID0gdGhpcy5nZXQoc3RhcnQpO1xuICAgICAgICB2YXIgbGVuQml0ID0gKChlbmQgLSBzdGFydCAtIDEpIDw8IDMpIC0gdW51c2VkQml0O1xuICAgICAgICB2YXIgaW50cm8gPSBcIihcIiArIGxlbkJpdCArIFwiIGJpdClcXG5cIjtcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQgKyAxOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5nZXQoaSk7XG4gICAgICAgICAgICB2YXIgc2tpcCA9IChpID09IGVuZCAtIDEpID8gdW51c2VkQml0IDogMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSA3OyBqID49IHNraXA7IC0taikge1xuICAgICAgICAgICAgICAgIHMgKz0gKGIgPj4gaikgJiAxID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRybyArIHN0cmluZ0N1dChzLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRybyArIHM7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlT2N0ZXRTdHJpbmcgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQVNDSUkoc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQodGhpcy5wYXJzZVN0cmluZ0lTTyhzdGFydCwgZW5kKSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIHZhciBzID0gXCIoXCIgKyBsZW4gKyBcIiBieXRlKVxcblwiO1xuICAgICAgICBtYXhMZW5ndGggLz0gMjsgLy8gd2Ugd29yayBpbiBieXRlc1xuICAgICAgICBpZiAobGVuID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIG1heExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgcyArPSB0aGlzLmhleEJ5dGUodGhpcy5nZXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHMgKz0gZWxsaXBzaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlT0lEID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG1heExlbmd0aCkge1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIHZhciBuID0gbmV3IEludDEwKCk7XG4gICAgICAgIHZhciBiaXRzID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQoaSk7XG4gICAgICAgICAgICBuLm11bEFkZCgxMjgsIHYgJiAweDdGKTtcbiAgICAgICAgICAgIGJpdHMgKz0gNztcbiAgICAgICAgICAgIGlmICghKHYgJiAweDgwKSkgeyAvLyBmaW5pc2hlZFxuICAgICAgICAgICAgICAgIGlmIChzID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLnNpbXBsaWZ5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuIGluc3RhbmNlb2YgSW50MTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uc3ViKDgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBcIjIuXCIgKyBuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IG4gPCA4MCA/IG4gPCA0MCA/IDAgOiAxIDogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBtICsgXCIuXCIgKyAobiAtIG0gKiA0MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXCIuXCIgKyBuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHMsIG1heExlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4gPSBuZXcgSW50MTAoKTtcbiAgICAgICAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0cyA+IDApIHtcbiAgICAgICAgICAgIHMgKz0gXCIuaW5jb21wbGV0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmVhbTtcbn0oKSk7XG52YXIgQVNOMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBU04xKHN0cmVhbSwgaGVhZGVyLCBsZW5ndGgsIHRhZywgc3ViKSB7XG4gICAgICAgIGlmICghKHRhZyBpbnN0YW5jZW9mIEFTTjFUYWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRhZyB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuc3ViID0gc3ViO1xuICAgIH1cbiAgICBBU04xLnByb3RvdHlwZS50eXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnRhZy50YWdDbGFzcykge1xuICAgICAgICAgICAgY2FzZSAwOiAvLyB1bml2ZXJzYWxcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudGFnLnRhZ051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFT0NcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQk9PTEVBTlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJTlRFR0VSXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJJVF9TVFJJTkdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiT0NURVRfU1RSSU5HXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5VTExcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiT0JKRUNUX0lERU5USUZJRVJcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiT2JqZWN0RGVzY3JpcHRvclwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDg6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFWFRFUk5BTFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSRUFMXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVOVU1FUkFURURcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDBCOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRU1CRURERURfUERWXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlVURjhTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU0VRVUVOQ0VcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU0VUXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk51bWVyaWNTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUHJpbnRhYmxlU3RyaW5nXCI7IC8vIEFTQ0lJIHN1YnNldFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJUZWxldGV4U3RyaW5nXCI7IC8vIGFrYSBUNjFTdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVmlkZW90ZXhTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSUE1U3RyaW5nXCI7IC8vIEFTQ0lJXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlVUQ1RpbWVcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR2VuZXJhbGl6ZWRUaW1lXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdyYXBoaWNTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDFBOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVmlzaWJsZVN0cmluZ1wiOyAvLyBBU0NJSSBzdWJzZXRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR2VuZXJhbFN0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MUM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJVbml2ZXJzYWxTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDFFOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQk1QU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlVuaXZlcnNhbF9cIiArIHRoaXMudGFnLnRhZ051bWJlci50b1N0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIkFwcGxpY2F0aW9uX1wiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCkgKyBcIl1cIjsgLy8gQ29udGV4dFxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIlByaXZhdGVfXCIgKyB0aGlzLnRhZy50YWdOdW1iZXIudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnBvc0NvbnRlbnQoKTtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGguYWJzKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKCF0aGlzLnRhZy5pc1VuaXZlcnNhbCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgKyB0aGlzLnN1Yi5sZW5ndGggKyBcIiBlbGVtKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBhcnNlT2N0ZXRTdHJpbmcoY29udGVudCwgY29udGVudCArIGxlbiwgbWF4TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMudGFnLnRhZ051bWJlcikge1xuICAgICAgICAgICAgY2FzZSAweDAxOiAvLyBCT09MRUFOXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnN0cmVhbS5nZXQoY29udGVudCkgPT09IDApID8gXCJmYWxzZVwiIDogXCJ0cnVlXCI7XG4gICAgICAgICAgICBjYXNlIDB4MDI6IC8vIElOVEVHRVJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucGFyc2VJbnRlZ2VyKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4pO1xuICAgICAgICAgICAgY2FzZSAweDAzOiAvLyBCSVRfU1RSSU5HXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViID8gXCIoXCIgKyB0aGlzLnN1Yi5sZW5ndGggKyBcIiBlbGVtKVwiIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGFyc2VCaXRTdHJpbmcoY29udGVudCwgY29udGVudCArIGxlbiwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgMHgwNDogLy8gT0NURVRfU1RSSU5HXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViID8gXCIoXCIgKyB0aGlzLnN1Yi5sZW5ndGggKyBcIiBlbGVtKVwiIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGFyc2VPY3RldFN0cmluZyhjb250ZW50LCBjb250ZW50ICsgbGVuLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgLy8gY2FzZSAweDA1OiAvLyBOVUxMXG4gICAgICAgICAgICBjYXNlIDB4MDY6IC8vIE9CSkVDVF9JREVOVElGSUVSXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBhcnNlT0lEKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sIG1heExlbmd0aCk7XG4gICAgICAgICAgICAvLyBjYXNlIDB4MDc6IC8vIE9iamVjdERlc2NyaXB0b3JcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwODogLy8gRVhURVJOQUxcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwOTogLy8gUkVBTFxuICAgICAgICAgICAgLy8gY2FzZSAweDBBOiAvLyBFTlVNRVJBVEVEXG4gICAgICAgICAgICAvLyBjYXNlIDB4MEI6IC8vIEVNQkVEREVEX1BEVlxuICAgICAgICAgICAgY2FzZSAweDEwOiAvLyBTRVFVRU5DRVxuICAgICAgICAgICAgY2FzZSAweDExOiAvLyBTRVRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgdGhpcy5zdWIubGVuZ3RoICsgXCIgZWxlbSlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihubyBlbGVtKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMHgwQzogLy8gVVRGOFN0cmluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQodGhpcy5zdHJlYW0ucGFyc2VTdHJpbmdVVEYoY29udGVudCwgY29udGVudCArIGxlbiksIG1heExlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4MTI6IC8vIE51bWVyaWNTdHJpbmdcbiAgICAgICAgICAgIGNhc2UgMHgxMzogLy8gUHJpbnRhYmxlU3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MTQ6IC8vIFRlbGV0ZXhTdHJpbmdcbiAgICAgICAgICAgIGNhc2UgMHgxNTogLy8gVmlkZW90ZXhTdHJpbmdcbiAgICAgICAgICAgIGNhc2UgMHgxNjogLy8gSUE1U3RyaW5nXG4gICAgICAgICAgICAvLyBjYXNlIDB4MTk6IC8vIEdyYXBoaWNTdHJpbmdcbiAgICAgICAgICAgIGNhc2UgMHgxQTogLy8gVmlzaWJsZVN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgMHgxQjogLy8gR2VuZXJhbFN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgMHgxQzogLy8gVW5pdmVyc2FsU3RyaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dCh0aGlzLnN0cmVhbS5wYXJzZVN0cmluZ0lTTyhjb250ZW50LCBjb250ZW50ICsgbGVuKSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgMHgxRTogLy8gQk1QU3RyaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dCh0aGlzLnN0cmVhbS5wYXJzZVN0cmluZ0JNUChjb250ZW50LCBjb250ZW50ICsgbGVuKSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgMHgxNzogLy8gVVRDVGltZVxuICAgICAgICAgICAgY2FzZSAweDE4OiAvLyBHZW5lcmFsaXplZFRpbWVcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucGFyc2VUaW1lKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sICh0aGlzLnRhZy50YWdOdW1iZXIgPT0gMHgxNykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVOYW1lKCkgKyBcIkBcIiArIHRoaXMuc3RyZWFtLnBvcyArIFwiW2hlYWRlcjpcIiArIHRoaXMuaGVhZGVyICsgXCIsbGVuZ3RoOlwiICsgdGhpcy5sZW5ndGggKyBcIixzdWI6XCIgKyAoKHRoaXMuc3ViID09PSBudWxsKSA/IFwibnVsbFwiIDogdGhpcy5zdWIubGVuZ3RoKSArIFwiXVwiO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUudG9QcmV0dHlTdHJpbmcgPSBmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgIGlmIChpbmRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5kZW50ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IGluZGVudCArIHRoaXMudHlwZU5hbWUoKSArIFwiIEBcIiArIHRoaXMuc3RyZWFtLnBvcztcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID49IDApIHtcbiAgICAgICAgICAgIHMgKz0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMudGFnLnRhZ0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBzICs9IFwiIChjb25zdHJ1Y3RlZClcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy50YWcuaXNVbml2ZXJzYWwoKSAmJiAoKHRoaXMudGFnLnRhZ051bWJlciA9PSAweDAzKSB8fCAodGhpcy50YWcudGFnTnVtYmVyID09IDB4MDQpKSkgJiYgKHRoaXMuc3ViICE9PSBudWxsKSkge1xuICAgICAgICAgICAgcyArPSBcIiAoZW5jYXBzdWxhdGVzKVwiO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gXCJcXG5cIjtcbiAgICAgICAgaWYgKHRoaXMuc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gXCIgIFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHRoaXMuc3ViLmxlbmd0aDsgaSA8IG1heDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcyArPSB0aGlzLnN1YltpXS50b1ByZXR0eVN0cmluZyhpbmRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUucG9zU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb3M7XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS5wb3NDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9zICsgdGhpcy5oZWFkZXI7XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS5wb3NFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb3MgKyB0aGlzLmhlYWRlciArIE1hdGguYWJzKHRoaXMubGVuZ3RoKTtcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0uaGV4RHVtcCh0aGlzLnBvc1N0YXJ0KCksIHRoaXMucG9zRW5kKCksIHRydWUpO1xuICAgIH07XG4gICAgQVNOMS5kZWNvZGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHZhciBidWYgPSBzdHJlYW0uZ2V0KCk7XG4gICAgICAgIHZhciBsZW4gPSBidWYgJiAweDdGO1xuICAgICAgICBpZiAobGVuID09IGJ1Zikge1xuICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyByZWFzb24gdG8gdXNlIEludDEwLCBhcyBpdCB3b3VsZCBiZSBhIGh1Z2UgYnVmZmVyIGFueXdheXNcbiAgICAgICAgaWYgKGxlbiA+IDYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvdmVyIDQ4IGJpdHMgbm90IHN1cHBvcnRlZCBhdCBwb3NpdGlvbiBcIiArIChzdHJlYW0ucG9zIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IC8vIHVuZGVmaW5lZFxuICAgICAgICBidWYgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBidWYgPSAoYnVmICogMjU2KSArIHN0cmVhbS5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGhleGFkZWNpbWFsIHZhbHVlIChhcyBhIHN0cmluZykgb2YgdGhlIGN1cnJlbnQgQVNOLjEgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEFTTjEucHJvdG90eXBlLmdldEhleFN0cmluZ1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGV4U3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5oZWFkZXIgKiAyO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggKiAyO1xuICAgICAgICByZXR1cm4gaGV4U3RyaW5nLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgfTtcbiAgICBBU04xLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIHN0cmVhbTtcbiAgICAgICAgaWYgKCEoc3RyIGluc3RhbmNlb2YgU3RyZWFtKSkge1xuICAgICAgICAgICAgc3RyZWFtID0gbmV3IFN0cmVhbShzdHIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtID0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJlYW1TdGFydCA9IG5ldyBTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgdmFyIHRhZyA9IG5ldyBBU04xVGFnKHN0cmVhbSk7XG4gICAgICAgIHZhciBsZW4gPSBBU04xLmRlY29kZUxlbmd0aChzdHJlYW0pO1xuICAgICAgICB2YXIgc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgICAgICB2YXIgaGVhZGVyID0gc3RhcnQgLSBzdHJlYW1TdGFydC5wb3M7XG4gICAgICAgIHZhciBzdWIgPSBudWxsO1xuICAgICAgICB2YXIgZ2V0U3ViID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgaWYgKGxlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGRlZmluaXRlIGxlbmd0aFxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXRbcmV0Lmxlbmd0aF0gPSBBU04xLmRlY29kZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnBvcyAhPSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGVudCBzaXplIGlzIG5vdCBjb3JyZWN0IGZvciBjb250YWluZXIgc3RhcnRpbmcgYXQgb2Zmc2V0IFwiICsgc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBsZW5ndGhcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IEFTTjEuZGVjb2RlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy50YWcuaXNFT0MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W3JldC5sZW5ndGhdID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGFydCAtIHN0cmVhbS5wb3M7IC8vIHVuZGVmaW5lZCBsZW5ndGhzIGFyZSByZXByZXNlbnRlZCBhcyBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhjZXB0aW9uIHdoaWxlIGRlY29kaW5nIHVuZGVmaW5lZCBsZW5ndGggY29udGVudDogXCIgKyBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGFnLnRhZ0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICAvLyBtdXN0IGhhdmUgdmFsaWQgY29udGVudFxuICAgICAgICAgICAgc3ViID0gZ2V0U3ViKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnLmlzVW5pdmVyc2FsKCkgJiYgKCh0YWcudGFnTnVtYmVyID09IDB4MDMpIHx8ICh0YWcudGFnTnVtYmVyID09IDB4MDQpKSkge1xuICAgICAgICAgICAgLy8gc29tZXRpbWVzIEJpdFN0cmluZyBhbmQgT2N0ZXRTdHJpbmcgYXJlIHVzZWQgdG8gZW5jYXBzdWxhdGUgQVNOLjFcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZy50YWdOdW1iZXIgPT0gMHgwMykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmdldCgpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJJVCBTVFJJTkdzIHdpdGggdW51c2VkIGJpdHMgY2Fubm90IGVuY2Fwc3VsYXRlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWIgPSBnZXRTdWIoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Yi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViW2ldLnRhZy5pc0VPQygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFT0MgaXMgbm90IHN1cHBvc2VkIHRvIGJlIGFjdHVhbCBjb250ZW50LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gYnV0IHNpbGVudGx5IGlnbm9yZSB3aGVuIHRoZXkgZG9uJ3RcbiAgICAgICAgICAgICAgICBzdWIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsZW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBjYW4ndCBza2lwIG92ZXIgYW4gaW52YWxpZCB0YWcgd2l0aCB1bmRlZmluZWQgbGVuZ3RoIGF0IG9mZnNldCBcIiArIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5wb3MgPSBzdGFydCArIE1hdGguYWJzKGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU04xKHN0cmVhbVN0YXJ0LCBoZWFkZXIsIGxlbiwgdGFnLCBzdWIpO1xuICAgIH07XG4gICAgcmV0dXJuIEFTTjE7XG59KCkpO1xudmFyIEFTTjFUYWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQVNOMVRhZyhzdHJlYW0pIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHN0cmVhbS5nZXQoKTtcbiAgICAgICAgdGhpcy50YWdDbGFzcyA9IGJ1ZiA+PiA2O1xuICAgICAgICB0aGlzLnRhZ0NvbnN0cnVjdGVkID0gKChidWYgJiAweDIwKSAhPT0gMCk7XG4gICAgICAgIHRoaXMudGFnTnVtYmVyID0gYnVmICYgMHgxRjtcbiAgICAgICAgaWYgKHRoaXMudGFnTnVtYmVyID09IDB4MUYpIHsgLy8gbG9uZyB0YWdcbiAgICAgICAgICAgIHZhciBuID0gbmV3IEludDEwKCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYnVmID0gc3RyZWFtLmdldCgpO1xuICAgICAgICAgICAgICAgIG4ubXVsQWRkKDEyOCwgYnVmICYgMHg3Rik7XG4gICAgICAgICAgICB9IHdoaWxlIChidWYgJiAweDgwKTtcbiAgICAgICAgICAgIHRoaXMudGFnTnVtYmVyID0gbi5zaW1wbGlmeSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFTTjFUYWcucHJvdG90eXBlLmlzVW5pdmVyc2FsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdDbGFzcyA9PT0gMHgwMDtcbiAgICB9O1xuICAgIEFTTjFUYWcucHJvdG90eXBlLmlzRU9DID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdDbGFzcyA9PT0gMHgwMCAmJiB0aGlzLnRhZ051bWJlciA9PT0gMHgwMDtcbiAgICB9O1xuICAgIHJldHVybiBBU04xVGFnO1xufSgpKTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDA1ICBUb20gV3Vcbi8vIEJpdHMgcGVyIGRpZ2l0XG52YXIgZGJpdHM7XG4vLyBKYXZhU2NyaXB0IGVuZ2luZSBhbmFseXNpc1xudmFyIGNhbmFyeSA9IDB4ZGVhZGJlZWZjYWZlO1xudmFyIGpfbG0gPSAoKGNhbmFyeSAmIDB4ZmZmZmZmKSA9PSAweGVmY2FmZSk7XG4vLyNyZWdpb25cbnZhciBsb3dwcmltZXMgPSBbMiwgMywgNSwgNywgMTEsIDEzLCAxNywgMTksIDIzLCAyOSwgMzEsIDM3LCA0MSwgNDMsIDQ3LCA1MywgNTksIDYxLCA2NywgNzEsIDczLCA3OSwgODMsIDg5LCA5NywgMTAxLCAxMDMsIDEwNywgMTA5LCAxMTMsIDEyNywgMTMxLCAxMzcsIDEzOSwgMTQ5LCAxNTEsIDE1NywgMTYzLCAxNjcsIDE3MywgMTc5LCAxODEsIDE5MSwgMTkzLCAxOTcsIDE5OSwgMjExLCAyMjMsIDIyNywgMjI5LCAyMzMsIDIzOSwgMjQxLCAyNTEsIDI1NywgMjYzLCAyNjksIDI3MSwgMjc3LCAyODEsIDI4MywgMjkzLCAzMDcsIDMxMSwgMzEzLCAzMTcsIDMzMSwgMzM3LCAzNDcsIDM0OSwgMzUzLCAzNTksIDM2NywgMzczLCAzNzksIDM4MywgMzg5LCAzOTcsIDQwMSwgNDA5LCA0MTksIDQyMSwgNDMxLCA0MzMsIDQzOSwgNDQzLCA0NDksIDQ1NywgNDYxLCA0NjMsIDQ2NywgNDc5LCA0ODcsIDQ5MSwgNDk5LCA1MDMsIDUwOSwgNTIxLCA1MjMsIDU0MSwgNTQ3LCA1NTcsIDU2MywgNTY5LCA1NzEsIDU3NywgNTg3LCA1OTMsIDU5OSwgNjAxLCA2MDcsIDYxMywgNjE3LCA2MTksIDYzMSwgNjQxLCA2NDMsIDY0NywgNjUzLCA2NTksIDY2MSwgNjczLCA2NzcsIDY4MywgNjkxLCA3MDEsIDcwOSwgNzE5LCA3MjcsIDczMywgNzM5LCA3NDMsIDc1MSwgNzU3LCA3NjEsIDc2OSwgNzczLCA3ODcsIDc5NywgODA5LCA4MTEsIDgyMSwgODIzLCA4MjcsIDgyOSwgODM5LCA4NTMsIDg1NywgODU5LCA4NjMsIDg3NywgODgxLCA4ODMsIDg4NywgOTA3LCA5MTEsIDkxOSwgOTI5LCA5MzcsIDk0MSwgOTQ3LCA5NTMsIDk2NywgOTcxLCA5NzcsIDk4MywgOTkxLCA5OTddO1xudmFyIGxwbGltID0gKDEgPDwgMjYpIC8gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGggLSAxXTtcbi8vI2VuZHJlZ2lvblxuLy8gKHB1YmxpYykgQ29uc3RydWN0b3JcbnZhciBCaWdJbnRlZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpZ0ludGVnZXIoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbU51bWJlcihhLCBiLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKGEsIDI1Nik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8jcmVnaW9uIFBVQkxJQ1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gYm5Ub1N0cmluZztcbiAgICAvLyAocHVibGljKSByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIGluIGdpdmVuIHJhZGl4XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAodGhpcy5zIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiLVwiICsgdGhpcy5uZWdhdGUoKS50b1N0cmluZyhiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaztcbiAgICAgICAgaWYgKGIgPT0gMTYpIHtcbiAgICAgICAgICAgIGsgPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gOCkge1xuICAgICAgICAgICAgayA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSAyKSB7XG4gICAgICAgICAgICBrID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDMyKSB7XG4gICAgICAgICAgICBrID0gNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDQpIHtcbiAgICAgICAgICAgIGsgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga20gPSAoMSA8PCBrKSAtIDE7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB2YXIgbSA9IGZhbHNlO1xuICAgICAgICB2YXIgciA9IFwiXCI7XG4gICAgICAgIHZhciBpID0gdGhpcy50O1xuICAgICAgICB2YXIgcCA9IHRoaXMuREIgLSAoaSAqIHRoaXMuREIpICUgaztcbiAgICAgICAgaWYgKGktLSA+IDApIHtcbiAgICAgICAgICAgIGlmIChwIDwgdGhpcy5EQiAmJiAoZCA9IHRoaXNbaV0gPj4gcCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgciA9IGludDJjaGFyKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwIDwgaykge1xuICAgICAgICAgICAgICAgICAgICBkID0gKHRoaXNbaV0gJiAoKDEgPDwgcCkgLSAxKSkgPDwgKGsgLSBwKTtcbiAgICAgICAgICAgICAgICAgICAgZCB8PSB0aGlzWy0taV0gPj4gKHAgKz0gdGhpcy5EQiAtIGspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldID4+IChwIC09IGspKSAmIGttO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwICs9IHRoaXMuREI7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICByICs9IGludDJjaGFyKGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbSA/IHIgOiBcIjBcIjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGJuTmVnYXRlO1xuICAgIC8vIChwdWJsaWMpIC10aGlzXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcywgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gYm5BYnM7XG4gICAgLy8gKHB1YmxpYykgfHRoaXN8XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucyA8IDApID8gdGhpcy5uZWdhdGUoKSA6IHRoaXM7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBibkNvbXBhcmVUbztcbiAgICAvLyAocHVibGljKSByZXR1cm4gKyBpZiB0aGlzID4gYSwgLSBpZiB0aGlzIDwgYSwgMCBpZiBlcXVhbFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5zIC0gYS5zO1xuICAgICAgICBpZiAociAhPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IHRoaXMudDtcbiAgICAgICAgciA9IGkgLSBhLnQ7XG4gICAgICAgIGlmIChyICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zIDwgMCkgPyAtciA6IHI7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoKHIgPSB0aGlzW2ldIC0gYVtpXSkgIT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gYm5CaXRMZW5ndGg7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHRoZSBudW1iZXIgb2YgYml0cyBpbiBcInRoaXNcIlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5EQiAqICh0aGlzLnQgLSAxKSArIG5iaXRzKHRoaXNbdGhpcy50IC0gMV0gXiAodGhpcy5zICYgdGhpcy5ETSkpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kID0gYm5Nb2Q7XG4gICAgLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYWJzKCkuZGl2UmVtVG8oYSwgbnVsbCwgcik7XG4gICAgICAgIGlmICh0aGlzLnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSB7XG4gICAgICAgICAgICBhLnN1YlRvKHIsIHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG4gICAgLy8gKHB1YmxpYykgdGhpc15lICUgbSwgMCA8PSBlIDwgMl4zMlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvd0ludCA9IGZ1bmN0aW9uIChlLCBtKSB7XG4gICAgICAgIHZhciB6O1xuICAgICAgICBpZiAoZSA8IDI1NiB8fCBtLmlzRXZlbigpKSB7XG4gICAgICAgICAgICB6ID0gbmV3IENsYXNzaWMobSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwKGUsIHopO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2xvbmUgPSBibkNsb25lO1xuICAgIC8vIChwdWJsaWMpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuY29weVRvKHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmludFZhbHVlID0gYm5JbnRWYWx1ZTtcbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgaW50ZWdlclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmludFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zIDwgMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0gLSB0aGlzLkRWO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50ID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50ID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxuICAgICAgICByZXR1cm4gKCh0aGlzWzFdICYgKCgxIDw8ICgzMiAtIHRoaXMuREIpKSAtIDEpKSA8PCB0aGlzLkRCKSB8IHRoaXNbMF07XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJ5dGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnQgPT0gMCkgPyB0aGlzLnMgOiAodGhpc1swXSA8PCAyNCkgPj4gMjQ7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaG9ydFZhbHVlID0gYm5TaG9ydFZhbHVlO1xuICAgIC8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hvcnRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnQgPT0gMCkgPyB0aGlzLnMgOiAodGhpc1swXSA8PCAxNikgPj4gMTY7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBiblNpZ051bTtcbiAgICAvLyAocHVibGljKSAwIGlmIHRoaXMgPT0gMCwgMSBpZiB0aGlzID4gMFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNpZ251bSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpc1swXSA8PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBiblRvQnl0ZUFycmF5O1xuICAgIC8vIChwdWJsaWMpIGNvbnZlcnQgdG8gYmlnZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnQ7XG4gICAgICAgIHZhciByID0gW107XG4gICAgICAgIHJbMF0gPSB0aGlzLnM7XG4gICAgICAgIHZhciBwID0gdGhpcy5EQiAtIChpICogdGhpcy5EQikgJSA4O1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICBpZiAoaS0tID4gMCkge1xuICAgICAgICAgICAgaWYgKHAgPCB0aGlzLkRCICYmIChkID0gdGhpc1tpXSA+PiBwKSAhPSAodGhpcy5zICYgdGhpcy5ETSkgPj4gcCkge1xuICAgICAgICAgICAgICAgIHJbaysrXSA9IGQgfCAodGhpcy5zIDw8ICh0aGlzLkRCIC0gcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwIDwgOCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gKHRoaXNbaV0gJiAoKDEgPDwgcCkgLSAxKSkgPDwgKDggLSBwKTtcbiAgICAgICAgICAgICAgICAgICAgZCB8PSB0aGlzWy0taV0gPj4gKHAgKz0gdGhpcy5EQiAtIDgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldID4+IChwIC09IDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgKz0gdGhpcy5EQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGQgJiAweDgwKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgfD0gLTI1NjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPT0gMCAmJiAodGhpcy5zICYgMHg4MCkgIT0gKGQgJiAweDgwKSkge1xuICAgICAgICAgICAgICAgICAgICArK2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID4gMCB8fCBkICE9IHRoaXMucykge1xuICAgICAgICAgICAgICAgICAgICByW2srK10gPSBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPT0gMCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW4gPSBibk1pbjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpIDwgMCkgPyB0aGlzIDogYTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1heCA9IGJuTWF4O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPiAwKSA/IHRoaXMgOiBhO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kID0gYm5BbmQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfYW5kLCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vciA9IGJuT3I7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9vciwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfeG9yLCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9hbmRub3QsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xuICAgIC8vIChwdWJsaWMpIH50aGlzXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByW2ldID0gdGhpcy5ETSAmIH50aGlzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgICAgci5zID0gfnRoaXMucztcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBiblNoaWZ0TGVmdDtcbiAgICAvLyAocHVibGljKSB0aGlzIDw8IG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuclNoaWZ0VG8oLW4sIHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sU2hpZnRUbyhuLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBiblNoaWZ0UmlnaHQ7XG4gICAgLy8gKHB1YmxpYykgdGhpcyA+PiBuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5sU2hpZnRUbygtbiwgcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJTaGlmdFRvKG4sIHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXQ7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKiB0aGlzLkRCICsgbGJpdCh0aGlzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudCAqIHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYml0Q291bnQgPSBibkJpdENvdW50O1xuICAgIC8vIChwdWJsaWMpIHJldHVybiBudW1iZXIgb2Ygc2V0IGJpdHNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSAwO1xuICAgICAgICB2YXIgeCA9IHRoaXMucyAmIHRoaXMuRE07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHtcbiAgICAgICAgICAgIHIgKz0gY2JpdCh0aGlzW2ldIF4geCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuICAgIC8vIChwdWJsaWMpIHRydWUgaWZmIG50aCBiaXQgaXMgc2V0XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudGVzdEJpdCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihuIC8gdGhpcy5EQik7XG4gICAgICAgIGlmIChqID49IHRoaXMudCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnMgIT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgodGhpc1tqXSAmICgxIDw8IChuICUgdGhpcy5EQikpKSAhPSAwKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNldEJpdCA9IGJuU2V0Qml0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgfCAoMTw8bilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zZXRCaXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3Bfb3IpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2xlYXJCaXQgPSBibkNsZWFyQml0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgJiB+KDE8PG4pXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2xlYXJCaXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3BfYW5kbm90KTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZsaXBCaXQgPSBibkZsaXBCaXQ7XG4gICAgLy8gKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZsaXBCaXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3BfeG9yKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZCA9IGJuQWRkO1xuICAgIC8vIChwdWJsaWMpIHRoaXMgKyBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5hZGRUbyhhLCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG4gICAgLy8gKHB1YmxpYykgdGhpcyAtIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuc3ViVG8oYSwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBibk11bHRpcGx5O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgKiBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLm11bHRpcGx5VG8oYSwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gYm5EaXZpZGU7XG4gICAgLy8gKHB1YmxpYykgdGhpcyAvIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmRpdlJlbVRvKGEsIHIsIG51bGwpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuICAgIC8vIChwdWJsaWMpIHRoaXMgJSBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhhLCBudWxsLCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGVBbmRSZW1haW5kZXIgPSBibkRpdmlkZUFuZFJlbWFpbmRlcjtcbiAgICAvLyAocHVibGljKSBbdGhpcy9hLHRoaXMlYV1cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGVBbmRSZW1haW5kZXIgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcSA9IG5iaSgpO1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmRpdlJlbVRvKGEsIHEsIHIpO1xuICAgICAgICByZXR1cm4gW3EsIHJdO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gYm5Nb2RQb3c7XG4gICAgLy8gKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGZ1bmN0aW9uIChlLCBtKSB7XG4gICAgICAgIHZhciBpID0gZS5iaXRMZW5ndGgoKTtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIHZhciByID0gbmJ2KDEpO1xuICAgICAgICB2YXIgejtcbiAgICAgICAgaWYgKGkgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA8IDE4KSB7XG4gICAgICAgICAgICBrID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgICAgICAgIGsgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPCAxNDQpIHtcbiAgICAgICAgICAgIGsgPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPCA3NjgpIHtcbiAgICAgICAgICAgIGsgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgayA9IDY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCA4KSB7XG4gICAgICAgICAgICB6ID0gbmV3IENsYXNzaWMobSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgeiA9IG5ldyBCYXJyZXR0KG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeiA9IG5ldyBNb250Z29tZXJ5KG0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZWNvbXB1dGF0aW9uXG4gICAgICAgIHZhciBnID0gW107XG4gICAgICAgIHZhciBuID0gMztcbiAgICAgICAgdmFyIGsxID0gayAtIDE7XG4gICAgICAgIHZhciBrbSA9ICgxIDw8IGspIC0gMTtcbiAgICAgICAgZ1sxXSA9IHouY29udmVydCh0aGlzKTtcbiAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgICB2YXIgZzIgPSBuYmkoKTtcbiAgICAgICAgICAgIHouc3FyVG8oZ1sxXSwgZzIpO1xuICAgICAgICAgICAgd2hpbGUgKG4gPD0ga20pIHtcbiAgICAgICAgICAgICAgICBnW25dID0gbmJpKCk7XG4gICAgICAgICAgICAgICAgei5tdWxUbyhnMiwgZ1tuIC0gMl0sIGdbbl0pO1xuICAgICAgICAgICAgICAgIG4gKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaiA9IGUudCAtIDE7XG4gICAgICAgIHZhciB3O1xuICAgICAgICB2YXIgaXMxID0gdHJ1ZTtcbiAgICAgICAgdmFyIHIyID0gbmJpKCk7XG4gICAgICAgIHZhciB0O1xuICAgICAgICBpID0gbmJpdHMoZVtqXSkgLSAxO1xuICAgICAgICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBrMSkge1xuICAgICAgICAgICAgICAgIHcgPSAoZVtqXSA+PiAoaSAtIGsxKSkgJiBrbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSAoZVtqXSAmICgoMSA8PCAoaSArIDEpKSAtIDEpKSA8PCAoazEgLSBpKTtcbiAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdyB8PSBlW2ogLSAxXSA+PiAodGhpcy5EQiArIGkgLSBrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IGs7XG4gICAgICAgICAgICB3aGlsZSAoKHcgJiAxKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdyA+Pj0gMTtcbiAgICAgICAgICAgICAgICAtLW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgLT0gbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgaSArPSB0aGlzLkRCO1xuICAgICAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpczEpIHsgLy8gcmV0ID09IDEsIGRvbid0IGJvdGhlciBzcXVhcmluZyBvciBtdWx0aXBseWluZyBpdFxuICAgICAgICAgICAgICAgIGdbd10uY29weVRvKHIpO1xuICAgICAgICAgICAgICAgIGlzMSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgICAgICAgICB6LnNxclRvKHIyLCByKTtcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgei5zcXJUbyhyLCByMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ID0gcjtcbiAgICAgICAgICAgICAgICAgICAgciA9IHIyO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHoubXVsVG8ocjIsIGdbd10sIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGogPj0gMCAmJiAoZVtqXSAmICgxIDw8IGkpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgei5zcXJUbyhyLCByMik7XG4gICAgICAgICAgICAgICAgdCA9IHI7XG4gICAgICAgICAgICAgICAgciA9IHIyO1xuICAgICAgICAgICAgICAgIHIyID0gdDtcbiAgICAgICAgICAgICAgICBpZiAoLS1pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5EQiAtIDE7XG4gICAgICAgICAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ZXJzZSA9IGJuTW9kSW52ZXJzZTtcbiAgICAvLyAocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHZhciBhYyA9IG0uaXNFdmVuKCk7XG4gICAgICAgIGlmICgodGhpcy5pc0V2ZW4oKSAmJiBhYykgfHwgbS5zaWdudW0oKSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1ID0gbS5jbG9uZSgpO1xuICAgICAgICB2YXIgdiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFyIGEgPSBuYnYoMSk7XG4gICAgICAgIHZhciBiID0gbmJ2KDApO1xuICAgICAgICB2YXIgYyA9IG5idigwKTtcbiAgICAgICAgdmFyIGQgPSBuYnYoMSk7XG4gICAgICAgIHdoaWxlICh1LnNpZ251bSgpICE9IDApIHtcbiAgICAgICAgICAgIHdoaWxlICh1LmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgdS5yU2hpZnRUbygxLCB1KTtcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhLmlzRXZlbigpIHx8ICFiLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmFkZFRvKHRoaXMsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5zdWJUbyhtLCBiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhLnJTaGlmdFRvKDEsIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYi5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICBiLnN1YlRvKG0sIGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiLnJTaGlmdFRvKDEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHYuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICB2LnJTaGlmdFRvKDEsIHYpO1xuICAgICAgICAgICAgICAgIGlmIChhYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWMuaXNFdmVuKCkgfHwgIWQuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuYWRkVG8odGhpcywgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnN1YlRvKG0sIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGMuclNoaWZ0VG8oMSwgYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuc3ViVG8obSwgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQuclNoaWZ0VG8oMSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodS5jb21wYXJlVG8odikgPj0gMCkge1xuICAgICAgICAgICAgICAgIHUuc3ViVG8odiwgdSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjKSB7XG4gICAgICAgICAgICAgICAgICAgIGEuc3ViVG8oYywgYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIuc3ViVG8oZCwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2LnN1YlRvKHUsIHYpO1xuICAgICAgICAgICAgICAgIGlmIChhYykge1xuICAgICAgICAgICAgICAgICAgICBjLnN1YlRvKGEsIGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkLnN1YlRvKGIsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludGVnZXIuWkVSTztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5jb21wYXJlVG8obSkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuc3VidHJhY3QobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuc2lnbnVtKCkgPCAwKSB7XG4gICAgICAgICAgICBkLmFkZFRvKG0sIGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuc2lnbnVtKCkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5hZGQobSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUucG93ID0gYm5Qb3c7XG4gICAgLy8gKHB1YmxpYykgdGhpc15lXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwKGUsIG5ldyBOdWxsRXhwKCkpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZ2NkID0gYm5HQ0Q7XG4gICAgLy8gKHB1YmxpYykgZ2NkKHRoaXMsYSkgKEhBQyAxNC41NClcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgeCA9ICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhciB5ID0gKGEucyA8IDApID8gYS5uZWdhdGUoKSA6IGEuY2xvbmUoKTtcbiAgICAgICAgaWYgKHguY29tcGFyZVRvKHkpIDwgMCkge1xuICAgICAgICAgICAgdmFyIHQgPSB4O1xuICAgICAgICAgICAgeCA9IHk7XG4gICAgICAgICAgICB5ID0gdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIHZhciBnID0geS5nZXRMb3dlc3RTZXRCaXQoKTtcbiAgICAgICAgaWYgKGcgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGcpIHtcbiAgICAgICAgICAgIGcgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnID4gMCkge1xuICAgICAgICAgICAgeC5yU2hpZnRUbyhnLCB4KTtcbiAgICAgICAgICAgIHkuclNoaWZ0VG8oZywgeSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHguc2lnbnVtKCkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICB4LnJTaGlmdFRvKGksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeS5yU2hpZnRUbyhpLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgeC5zdWJUbyh5LCB4KTtcbiAgICAgICAgICAgICAgICB4LnJTaGlmdFRvKDEsIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeS5zdWJUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICB5LnJTaGlmdFRvKDEsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnID4gMCkge1xuICAgICAgICAgICAgeS5sU2hpZnRUbyhnLCB5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IGJuSXNQcm9iYWJsZVByaW1lO1xuICAgIC8vIChwdWJsaWMpIHRlc3QgcHJpbWFsaXR5IHdpdGggY2VydGFpbnR5ID49IDEtLjVedFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgeCA9IHRoaXMuYWJzKCk7XG4gICAgICAgIGlmICh4LnQgPT0gMSAmJiB4WzBdIDw9IGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoeFswXSA9PSBsb3dwcmltZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4LmlzRXZlbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IDE7XG4gICAgICAgIHdoaWxlIChpIDwgbG93cHJpbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG0gPSBsb3dwcmltZXNbaV07XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBsb3dwcmltZXMubGVuZ3RoICYmIG0gPCBscGxpbSkge1xuICAgICAgICAgICAgICAgIG0gKj0gbG93cHJpbWVzW2orK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtID0geC5tb2RJbnQobSk7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgICAgICBpZiAobSAlIGxvd3ByaW1lc1tpKytdID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geC5taWxsZXJSYWJpbih0KTtcbiAgICB9O1xuICAgIC8vI2VuZHJlZ2lvbiBQVUJMSUNcbiAgICAvLyNyZWdpb24gUFJPVEVDVEVEXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIGNvcHkgdGhpcyB0byByXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICByW2ldID0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByLnQgPSB0aGlzLnQ7XG4gICAgICAgIHIucyA9IHRoaXMucztcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21JbnQgPSBibnBGcm9tSW50O1xuICAgIC8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIGludGVnZXIgdmFsdWUgeCwgLURWIDw9IHggPCBEVlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21JbnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnQgPSAxO1xuICAgICAgICB0aGlzLnMgPSAoeCA8IDApID8gLTEgOiAwO1xuICAgICAgICBpZiAoeCA+IDApIHtcbiAgICAgICAgICAgIHRoaXNbMF0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHggPCAtMSkge1xuICAgICAgICAgICAgdGhpc1swXSA9IHggKyB0aGlzLkRWO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGJucEZyb21TdHJpbmc7XG4gICAgLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gc3RyaW5nIGFuZCByYWRpeFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAocywgYikge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgaWYgKGIgPT0gMTYpIHtcbiAgICAgICAgICAgIGsgPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gOCkge1xuICAgICAgICAgICAgayA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSAyNTYpIHtcbiAgICAgICAgICAgIGsgPSA4O1xuICAgICAgICAgICAgLyogYnl0ZSBhcnJheSAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMikge1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSAzMikge1xuICAgICAgICAgICAgayA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSA0KSB7XG4gICAgICAgICAgICBrID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVJhZGl4KHMsIGIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudCA9IDA7XG4gICAgICAgIHRoaXMucyA9IDA7XG4gICAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICAgIHZhciBtaSA9IGZhbHNlO1xuICAgICAgICB2YXIgc2ggPSAwO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHZhciB4ID0gKGsgPT0gOCkgPyAoK3NbaV0pICYgMHhmZiA6IGludEF0KHMsIGkpO1xuICAgICAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNoID09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCsrXSA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaCArIGsgPiB0aGlzLkRCKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQgLSAxXSB8PSAoeCAmICgoMSA8PCAodGhpcy5EQiAtIHNoKSkgLSAxKSkgPDwgc2g7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSAoeCA+PiAodGhpcy5EQiAtIHNoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCAtIDFdIHw9IHggPDwgc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaCArPSBrO1xuICAgICAgICAgICAgaWYgKHNoID49IHRoaXMuREIpIHtcbiAgICAgICAgICAgICAgICBzaCAtPSB0aGlzLkRCO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrID09IDggJiYgKCgrc1swXSkgJiAweDgwKSAhPSAwKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSAtMTtcbiAgICAgICAgICAgIGlmIChzaCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCAtIDFdIHw9ICgoMSA8PCAodGhpcy5EQiAtIHNoKSkgLSAxKSA8PCBzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsYW1wKCk7XG4gICAgICAgIGlmIChtaSkge1xuICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGFtcCA9IGJucENsYW1wO1xuICAgIC8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMucyAmIHRoaXMuRE07XG4gICAgICAgIHdoaWxlICh0aGlzLnQgPiAwICYmIHRoaXNbdGhpcy50IC0gMV0gPT0gYykge1xuICAgICAgICAgICAgLS10aGlzLnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRsU2hpZnRUbyA9IGJucERMU2hpZnRUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuKkRCXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGxTaGlmdFRvID0gZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICByW2kgKyBuXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICByW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByLnQgPSB0aGlzLnQgKyBuO1xuICAgICAgICByLnMgPSB0aGlzLnM7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gbipEQlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRyU2hpZnRUbyA9IGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBuOyBpIDwgdGhpcy50OyArK2kpIHtcbiAgICAgICAgICAgIHJbaSAtIG5dID0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByLnQgPSBNYXRoLm1heCh0aGlzLnQgLSBuLCAwKTtcbiAgICAgICAgci5zID0gdGhpcy5zO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubFNoaWZ0VG8gPSBibnBMU2hpZnRUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubFNoaWZ0VG8gPSBmdW5jdGlvbiAobiwgcikge1xuICAgICAgICB2YXIgYnMgPSBuICUgdGhpcy5EQjtcbiAgICAgICAgdmFyIGNicyA9IHRoaXMuREIgLSBicztcbiAgICAgICAgdmFyIGJtID0gKDEgPDwgY2JzKSAtIDE7XG4gICAgICAgIHZhciBkcyA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpO1xuICAgICAgICB2YXIgYyA9ICh0aGlzLnMgPDwgYnMpICYgdGhpcy5ETTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICByW2kgKyBkcyArIDFdID0gKHRoaXNbaV0gPj4gY2JzKSB8IGM7XG4gICAgICAgICAgICBjID0gKHRoaXNbaV0gJiBibSkgPDwgYnM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGRzIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJbZHNdID0gYztcbiAgICAgICAgci50ID0gdGhpcy50ICsgZHMgKyAxO1xuICAgICAgICByLnMgPSB0aGlzLnM7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnJTaGlmdFRvID0gYm5wUlNoaWZ0VG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJTaGlmdFRvID0gZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgci5zID0gdGhpcy5zO1xuICAgICAgICB2YXIgZHMgPSBNYXRoLmZsb29yKG4gLyB0aGlzLkRCKTtcbiAgICAgICAgaWYgKGRzID49IHRoaXMudCkge1xuICAgICAgICAgICAgci50ID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnMgPSBuICUgdGhpcy5EQjtcbiAgICAgICAgdmFyIGNicyA9IHRoaXMuREIgLSBicztcbiAgICAgICAgdmFyIGJtID0gKDEgPDwgYnMpIC0gMTtcbiAgICAgICAgclswXSA9IHRoaXNbZHNdID4+IGJzO1xuICAgICAgICBmb3IgKHZhciBpID0gZHMgKyAxOyBpIDwgdGhpcy50OyArK2kpIHtcbiAgICAgICAgICAgIHJbaSAtIGRzIC0gMV0gfD0gKHRoaXNbaV0gJiBibSkgPDwgY2JzO1xuICAgICAgICAgICAgcltpIC0gZHNdID0gdGhpc1tpXSA+PiBicztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnMgPiAwKSB7XG4gICAgICAgICAgICByW3RoaXMudCAtIGRzIC0gMV0gfD0gKHRoaXMucyAmIGJtKSA8PCBjYnM7XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gdGhpcy50IC0gZHM7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgLSBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3ViVG8gPSBmdW5jdGlvbiAoYSwgcikge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgdmFyIG0gPSBNYXRoLm1pbihhLnQsIHRoaXMudCk7XG4gICAgICAgIHdoaWxlIChpIDwgbSkge1xuICAgICAgICAgICAgYyArPSB0aGlzW2ldIC0gYVtpXTtcbiAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS50IDwgdGhpcy50KSB7XG4gICAgICAgICAgICBjIC09IGEucztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy50KSB7XG4gICAgICAgICAgICAgICAgYyArPSB0aGlzW2ldO1xuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBhLnQpIHtcbiAgICAgICAgICAgICAgICBjIC09IGFbaV07XG4gICAgICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgLT0gYS5zO1xuICAgICAgICB9XG4gICAgICAgIHIucyA9IChjIDwgMCkgPyAtMSA6IDA7XG4gICAgICAgIGlmIChjIDwgLTEpIHtcbiAgICAgICAgICAgIHJbaSsrXSA9IHRoaXMuRFYgKyBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPiAwKSB7XG4gICAgICAgICAgICByW2krK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIHIudCA9IGk7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VG8gPSBibnBNdWx0aXBseVRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzICogYSwgciAhPSB0aGlzLGEgKEhBQyAxNC4xMilcbiAgICAvLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlUbyA9IGZ1bmN0aW9uIChhLCByKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgICAgICAgdmFyIHkgPSBhLmFicygpO1xuICAgICAgICB2YXIgaSA9IHgudDtcbiAgICAgICAgci50ID0gaSArIHkudDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICByW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeS50OyArK2kpIHtcbiAgICAgICAgICAgIHJbaSArIHgudF0gPSB4LmFtKDAsIHlbaV0sIHIsIGksIDAsIHgudCk7XG4gICAgICAgIH1cbiAgICAgICAgci5zID0gMDtcbiAgICAgICAgci5jbGFtcCgpO1xuICAgICAgICBpZiAodGhpcy5zICE9IGEucykge1xuICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIsIHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmVUbyA9IGJucFNxdWFyZVRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzXjIsIHIgIT0gdGhpcyAoSEFDIDE0LjE2KVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmFicygpO1xuICAgICAgICB2YXIgaSA9IHIudCA9IDIgKiB4LnQ7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgudCAtIDE7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKTtcbiAgICAgICAgICAgIGlmICgocltpICsgeC50XSArPSB4LmFtKGkgKyAxLCAyICogeFtpXSwgciwgMiAqIGkgKyAxLCBjLCB4LnQgLSBpIC0gMSkpID49IHguRFYpIHtcbiAgICAgICAgICAgICAgICByW2kgKyB4LnRdIC09IHguRFY7XG4gICAgICAgICAgICAgICAgcltpICsgeC50ICsgMV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyLnQgPiAwKSB7XG4gICAgICAgICAgICByW3IudCAtIDFdICs9IHguYW0oaSwgeFtpXSwgciwgMiAqIGksIDAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHIucyA9IDA7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdlJlbVRvID0gYm5wRGl2UmVtVG87XG4gICAgLy8gKHByb3RlY3RlZCkgZGl2aWRlIHRoaXMgYnkgbSwgcXVvdGllbnQgYW5kIHJlbWFpbmRlciB0byBxLCByIChIQUMgMTQuMjApXG4gICAgLy8gciAhPSBxLCB0aGlzICE9IG0uICBxIG9yIHIgbWF5IGJlIG51bGwuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2UmVtVG8gPSBmdW5jdGlvbiAobSwgcSwgcikge1xuICAgICAgICB2YXIgcG0gPSBtLmFicygpO1xuICAgICAgICBpZiAocG0udCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHB0ID0gdGhpcy5hYnMoKTtcbiAgICAgICAgaWYgKHB0LnQgPCBwbS50KSB7XG4gICAgICAgICAgICBpZiAocSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcS5mcm9tSW50KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29weVRvKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgICAgICAgIHIgPSBuYmkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeSA9IG5iaSgpO1xuICAgICAgICB2YXIgdHMgPSB0aGlzLnM7XG4gICAgICAgIHZhciBtcyA9IG0ucztcbiAgICAgICAgdmFyIG5zaCA9IHRoaXMuREIgLSBuYml0cyhwbVtwbS50IC0gMV0pOyAvLyBub3JtYWxpemUgbW9kdWx1c1xuICAgICAgICBpZiAobnNoID4gMCkge1xuICAgICAgICAgICAgcG0ubFNoaWZ0VG8obnNoLCB5KTtcbiAgICAgICAgICAgIHB0LmxTaGlmdFRvKG5zaCwgcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbS5jb3B5VG8oeSk7XG4gICAgICAgICAgICBwdC5jb3B5VG8ocik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHlzID0geS50O1xuICAgICAgICB2YXIgeTAgPSB5W3lzIC0gMV07XG4gICAgICAgIGlmICh5MCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHl0ID0geTAgKiAoMSA8PCB0aGlzLkYxKSArICgoeXMgPiAxKSA/IHlbeXMgLSAyXSA+PiB0aGlzLkYyIDogMCk7XG4gICAgICAgIHZhciBkMSA9IHRoaXMuRlYgLyB5dDtcbiAgICAgICAgdmFyIGQyID0gKDEgPDwgdGhpcy5GMSkgLyB5dDtcbiAgICAgICAgdmFyIGUgPSAxIDw8IHRoaXMuRjI7XG4gICAgICAgIHZhciBpID0gci50O1xuICAgICAgICB2YXIgaiA9IGkgLSB5cztcbiAgICAgICAgdmFyIHQgPSAocSA9PSBudWxsKSA/IG5iaSgpIDogcTtcbiAgICAgICAgeS5kbFNoaWZ0VG8oaiwgdCk7XG4gICAgICAgIGlmIChyLmNvbXBhcmVUbyh0KSA+PSAwKSB7XG4gICAgICAgICAgICByW3IudCsrXSA9IDE7XG4gICAgICAgICAgICByLnN1YlRvKHQsIHIpO1xuICAgICAgICB9XG4gICAgICAgIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbyh5cywgdCk7XG4gICAgICAgIHQuc3ViVG8oeSwgeSk7IC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gICAgICAgIHdoaWxlICh5LnQgPCB5cykge1xuICAgICAgICAgICAgeVt5LnQrK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgtLWogPj0gMCkge1xuICAgICAgICAgICAgLy8gRXN0aW1hdGUgcXVvdGllbnQgZGlnaXRcbiAgICAgICAgICAgIHZhciBxZCA9IChyWy0taV0gPT0geTApID8gdGhpcy5ETSA6IE1hdGguZmxvb3IocltpXSAqIGQxICsgKHJbaSAtIDFdICsgZSkgKiBkMik7XG4gICAgICAgICAgICBpZiAoKHJbaV0gKz0geS5hbSgwLCBxZCwgciwgaiwgMCwgeXMpKSA8IHFkKSB7IC8vIFRyeSBpdCBvdXRcbiAgICAgICAgICAgICAgICB5LmRsU2hpZnRUbyhqLCB0KTtcbiAgICAgICAgICAgICAgICByLnN1YlRvKHQsIHIpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyW2ldIDwgLS1xZCkge1xuICAgICAgICAgICAgICAgICAgICByLnN1YlRvKHQsIHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocSAhPSBudWxsKSB7XG4gICAgICAgICAgICByLmRyU2hpZnRUbyh5cywgcSk7XG4gICAgICAgICAgICBpZiAodHMgIT0gbXMpIHtcbiAgICAgICAgICAgICAgICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocSwgcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgci50ID0geXM7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICAgICAgaWYgKG5zaCA+IDApIHtcbiAgICAgICAgICAgIHIuclNoaWZ0VG8obnNoLCByKTtcbiAgICAgICAgfSAvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgICAgICAgaWYgKHRzIDwgMCkge1xuICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIsIHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnZEaWdpdCA9IGJucEludkRpZ2l0O1xuICAgIC8vIChwcm90ZWN0ZWQpIHJldHVybiBcIi0xL3RoaXMgJSAyXkRCXCI7IHVzZWZ1bCBmb3IgTW9udC4gcmVkdWN0aW9uXG4gICAgLy8ganVzdGlmaWNhdGlvbjpcbiAgICAvLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuICAgIC8vICAgICAgICAgeHkgPSAgMStrbVxuICAgIC8vICAgeHkoMi14eSkgPSAoMStrbSkoMS1rbSlcbiAgICAvLyB4W3koMi14eSldID0gMS1rXjJtXjJcbiAgICAvLyB4W3koMi14eSldID09IDEgKG1vZCBtXjIpXG4gICAgLy8gaWYgeSBpcyAxL3ggbW9kIG0sIHRoZW4geSgyLXh5KSBpcyAxL3ggbW9kIG1eMlxuICAgIC8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuICAgIC8vIEpTIG11bHRpcGx5IFwib3ZlcmZsb3dzXCIgZGlmZmVyZW50bHkgZnJvbSBDL0MrKywgc28gY2FyZSBpcyBuZWVkZWQgaGVyZS5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnZEaWdpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gdGhpc1swXTtcbiAgICAgICAgaWYgKCh4ICYgMSkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSB4ICYgMzsgLy8geSA9PSAxL3ggbW9kIDJeMlxuICAgICAgICB5ID0gKHkgKiAoMiAtICh4ICYgMHhmKSAqIHkpKSAmIDB4ZjsgLy8geSA9PSAxL3ggbW9kIDJeNFxuICAgICAgICB5ID0gKHkgKiAoMiAtICh4ICYgMHhmZikgKiB5KSkgJiAweGZmOyAvLyB5ID09IDEveCBtb2QgMl44XG4gICAgICAgIHkgPSAoeSAqICgyIC0gKCgoeCAmIDB4ZmZmZikgKiB5KSAmIDB4ZmZmZikpKSAmIDB4ZmZmZjsgLy8geSA9PSAxL3ggbW9kIDJeMTZcbiAgICAgICAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAgICAgICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgICAgICAgeSA9ICh5ICogKDIgLSB4ICogeSAlIHRoaXMuRFYpKSAlIHRoaXMuRFY7IC8vIHkgPT0gMS94IG1vZCAyXmRiaXRzXG4gICAgICAgIC8vIHdlIHJlYWxseSB3YW50IHRoZSBuZWdhdGl2ZSBpbnZlcnNlLCBhbmQgLURWIDwgeSA8IERWXG4gICAgICAgIHJldHVybiAoeSA+IDApID8gdGhpcy5EViAtIHkgOiAteTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbiAgICAvLyAocHJvdGVjdGVkKSB0cnVlIGlmZiB0aGlzIGlzIGV2ZW5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMudCA+IDApID8gKHRoaXNbMF0gJiAxKSA6IHRoaXMucykgPT0gMDtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzXmUsIGUgPCAyXjMyLCBkb2luZyBzcXIgYW5kIG11bCB3aXRoIFwiclwiIChIQUMgMTQuNzkpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24gKGUsIHopIHtcbiAgICAgICAgaWYgKGUgPiAweGZmZmZmZmZmIHx8IGUgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50ZWdlci5PTkU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdmFyIHIyID0gbmJpKCk7XG4gICAgICAgIHZhciBnID0gei5jb252ZXJ0KHRoaXMpO1xuICAgICAgICB2YXIgaSA9IG5iaXRzKGUpIC0gMTtcbiAgICAgICAgZy5jb3B5VG8ocik7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgei5zcXJUbyhyLCByMik7XG4gICAgICAgICAgICBpZiAoKGUgJiAoMSA8PCBpKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgei5tdWxUbyhyMiwgZywgcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHI7XG4gICAgICAgICAgICAgICAgciA9IHIyO1xuICAgICAgICAgICAgICAgIHIyID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei5yZXZlcnQocik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaHVua1NpemUgPSBibnBDaHVua1NpemU7XG4gICAgLy8gKHByb3RlY3RlZCkgcmV0dXJuIHggcy50LiByXnggPCBEVlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNodW5rU2l6ZSA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yICogdGhpcy5EQiAvIE1hdGgubG9nKHIpKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvUmFkaXggPSBibnBUb1JhZGl4O1xuICAgIC8vIChwcm90ZWN0ZWQpIGNvbnZlcnQgdG8gcmFkaXggc3RyaW5nXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgICAgIGIgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaWdudW0oKSA9PSAwIHx8IGIgPCAyIHx8IGIgPiAzNikge1xuICAgICAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xuICAgICAgICB2YXIgYSA9IE1hdGgucG93KGIsIGNzKTtcbiAgICAgICAgdmFyIGQgPSBuYnYoYSk7XG4gICAgICAgIHZhciB5ID0gbmJpKCk7XG4gICAgICAgIHZhciB6ID0gbmJpKCk7XG4gICAgICAgIHZhciByID0gXCJcIjtcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhkLCB5LCB6KTtcbiAgICAgICAgd2hpbGUgKHkuc2lnbnVtKCkgPiAwKSB7XG4gICAgICAgICAgICByID0gKGEgKyB6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4gICAgICAgICAgICB5LmRpdlJlbVRvKGQsIHksIHopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6LmludFZhbHVlKCkudG9TdHJpbmcoYikgKyByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVJhZGl4ID0gYm5wRnJvbVJhZGl4O1xuICAgIC8vIChwcm90ZWN0ZWQpIGNvbnZlcnQgZnJvbSByYWRpeCBzdHJpbmdcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBmdW5jdGlvbiAocywgYikge1xuICAgICAgICB0aGlzLmZyb21JbnQoMCk7XG4gICAgICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgICAgIGIgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbiAgICAgICAgdmFyIGQgPSBNYXRoLnBvdyhiLCBjcyk7XG4gICAgICAgIHZhciBtaSA9IGZhbHNlO1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGludEF0KHMsIGkpO1xuICAgICAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHRoaXMuc2lnbnVtKCkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdyA9IGIgKiB3ICsgeDtcbiAgICAgICAgICAgIGlmICgrK2ogPj0gY3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRNdWx0aXBseShkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQodywgMCk7XG4gICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgdyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRNdWx0aXBseShNYXRoLnBvdyhiLCBqKSk7XG4gICAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQodywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pKSB7XG4gICAgICAgICAgICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21OdW1iZXIgPSBibnBGcm9tTnVtYmVyO1xuICAgIC8vIChwcm90ZWN0ZWQpIGFsdGVybmF0ZSBjb25zdHJ1Y3RvclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21OdW1iZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgYikge1xuICAgICAgICAgICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gICAgICAgICAgICBpZiAoYSA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21JbnQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21OdW1iZXIoYSwgYyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRlc3RCaXQoYSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgb3Bfb3IsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQoMSwgMCk7XG4gICAgICAgICAgICAgICAgfSAvLyBmb3JjZSBvZGRcbiAgICAgICAgICAgICAgICB3aGlsZSAoIXRoaXMuaXNQcm9iYWJsZVByaW1lKGIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCgyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYml0TGVuZ3RoKCkgPiBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YlRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LFJORylcbiAgICAgICAgICAgIHZhciB4ID0gW107XG4gICAgICAgICAgICB2YXIgdCA9IGEgJiA3O1xuICAgICAgICAgICAgeC5sZW5ndGggPSAoYSA+PiAzKSArIDE7XG4gICAgICAgICAgICBiLm5leHRCeXRlcyh4KTtcbiAgICAgICAgICAgIGlmICh0ID4gMCkge1xuICAgICAgICAgICAgICAgIHhbMF0gJj0gKCgxIDw8IHQpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4WzBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyh4LCAyNTYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXR3aXNlVG8gPSBibnBCaXR3aXNlVG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgb3AgYSAoYml0d2lzZSlcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXR3aXNlVG8gPSBmdW5jdGlvbiAoYSwgb3AsIHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBmO1xuICAgICAgICB2YXIgbSA9IE1hdGgubWluKGEudCwgdGhpcy50KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgICAgICAgcltpXSA9IG9wKHRoaXNbaV0sIGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnQgPCB0aGlzLnQpIHtcbiAgICAgICAgICAgIGYgPSBhLnMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgZm9yIChpID0gbTsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcltpXSA9IG9wKHRoaXNbaV0sIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci50ID0gdGhpcy50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZiA9IHRoaXMucyAmIHRoaXMuRE07XG4gICAgICAgICAgICBmb3IgKGkgPSBtOyBpIDwgYS50OyArK2kpIHtcbiAgICAgICAgICAgICAgICByW2ldID0gb3AoZiwgYVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLnQgPSBhLnQ7XG4gICAgICAgIH1cbiAgICAgICAgci5zID0gb3AodGhpcy5zLCBhLnMpO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaGFuZ2VCaXQgPSBibnBDaGFuZ2VCaXQ7XG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyBvcCAoMTw8bilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaGFuZ2VCaXQgPSBmdW5jdGlvbiAobiwgb3ApIHtcbiAgICAgICAgdmFyIHIgPSBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQobik7XG4gICAgICAgIHRoaXMuYml0d2lzZVRvKHIsIG9wLCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGRUbyA9IGJucEFkZFRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gZnVuY3Rpb24gKGEsIHIpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBtID0gTWF0aC5taW4oYS50LCB0aGlzLnQpO1xuICAgICAgICB3aGlsZSAoaSA8IG0pIHtcbiAgICAgICAgICAgIGMgKz0gdGhpc1tpXSArIGFbaV07XG4gICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudCA8IHRoaXMudCkge1xuICAgICAgICAgICAgYyArPSBhLnM7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMudCkge1xuICAgICAgICAgICAgICAgIGMgKz0gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYS50KSB7XG4gICAgICAgICAgICAgICAgYyArPSBhW2ldO1xuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjICs9IGEucztcbiAgICAgICAgfVxuICAgICAgICByLnMgPSAoYyA8IDApID8gLTEgOiAwO1xuICAgICAgICBpZiAoYyA+IDApIHtcbiAgICAgICAgICAgIHJbaSsrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IC0xKSB7XG4gICAgICAgICAgICByW2krK10gPSB0aGlzLkRWICsgYztcbiAgICAgICAgfVxuICAgICAgICByLnQgPSBpO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyAqPSBuLCB0aGlzID49IDAsIDEgPCBuIDwgRFZcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB0aGlzW3RoaXMudF0gPSB0aGlzLmFtKDAsIG4gLSAxLCB0aGlzLCAwLCAwLCB0aGlzLnQpO1xuICAgICAgICArK3RoaXMudDtcbiAgICAgICAgdGhpcy5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZEFkZE9mZnNldCA9IGJucERBZGRPZmZzZXQ7XG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRBZGRPZmZzZXQgPSBmdW5jdGlvbiAobiwgdykge1xuICAgICAgICBpZiAobiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMudCA8PSB3KSB7XG4gICAgICAgICAgICB0aGlzW3RoaXMudCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1t3XSArPSBuO1xuICAgICAgICB3aGlsZSAodGhpc1t3XSA+PSB0aGlzLkRWKSB7XG4gICAgICAgICAgICB0aGlzW3ddIC09IHRoaXMuRFY7XG4gICAgICAgICAgICBpZiAoKyt3ID49IHRoaXMudCkge1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50KytdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrdGhpc1t3XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlMb3dlclRvID0gYm5wTXVsdGlwbHlMb3dlclRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSBsb3dlciBuIHdvcmRzIG9mIFwidGhpcyAqIGFcIiwgYS50IDw9IG5cbiAgICAvLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlMb3dlclRvID0gZnVuY3Rpb24gKGEsIG4sIHIpIHtcbiAgICAgICAgdmFyIGkgPSBNYXRoLm1pbih0aGlzLnQgKyBhLnQsIG4pO1xuICAgICAgICByLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG4gICAgICAgIHIudCA9IGk7XG4gICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgclstLWldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gci50IC0gdGhpcy50OyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICByW2kgKyB0aGlzLnRdID0gdGhpcy5hbSgwLCBhW2ldLCByLCBpLCAwLCB0aGlzLnQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSBNYXRoLm1pbihhLnQsIG4pOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmFtKDAsIGFbaV0sIHIsIGksIDAsIG4gLSBpKTtcbiAgICAgICAgfVxuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVVwcGVyVG8gPSBibnBNdWx0aXBseVVwcGVyVG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IFwidGhpcyAqIGFcIiB3aXRob3V0IGxvd2VyIG4gd29yZHMsIG4gPiAwXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGZ1bmN0aW9uIChhLCBuLCByKSB7XG4gICAgICAgIC0tbjtcbiAgICAgICAgdmFyIGkgPSByLnQgPSB0aGlzLnQgKyBhLnQgLSBuO1xuICAgICAgICByLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gTWF0aC5tYXgobiAtIHRoaXMudCwgMCk7IGkgPCBhLnQ7ICsraSkge1xuICAgICAgICAgICAgclt0aGlzLnQgKyBpIC0gbl0gPSB0aGlzLmFtKG4gLSBpLCBhW2ldLCByLCAwLCAwLCB0aGlzLnQgKyBpIC0gbik7XG4gICAgICAgIH1cbiAgICAgICAgci5jbGFtcCgpO1xuICAgICAgICByLmRyU2hpZnRUbygxLCByKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICUgbiwgbiA8IDJeMjZcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZCA9IHRoaXMuRFYgJSBuO1xuICAgICAgICB2YXIgciA9ICh0aGlzLnMgPCAwKSA/IG4gLSAxIDogMDtcbiAgICAgICAgaWYgKHRoaXMudCA+IDApIHtcbiAgICAgICAgICAgIGlmIChkID09IDApIHtcbiAgICAgICAgICAgICAgICByID0gdGhpc1swXSAlIG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IChkICogciArIHRoaXNbaV0pICUgbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taWxsZXJSYWJpbiA9IGJucE1pbGxlclJhYmluO1xuICAgIC8vIChwcm90ZWN0ZWQpIHRydWUgaWYgcHJvYmFibHkgcHJpbWUgKEhBQyA0LjI0LCBNaWxsZXItUmFiaW4pXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWlsbGVyUmFiaW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgbjEgPSB0aGlzLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgdmFyIGsgPSBuMS5nZXRMb3dlc3RTZXRCaXQoKTtcbiAgICAgICAgaWYgKGsgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gbjEuc2hpZnRSaWdodChrKTtcbiAgICAgICAgdCA9ICh0ICsgMSkgPj4gMTtcbiAgICAgICAgaWYgKHQgPiBsb3dwcmltZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0ID0gbG93cHJpbWVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IG5iaSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQ7ICsraSkge1xuICAgICAgICAgICAgLy8gUGljayBiYXNlcyBhdCByYW5kb20sIGluc3RlYWQgb2Ygc3RhcnRpbmcgYXQgMlxuICAgICAgICAgICAgYS5mcm9tSW50KGxvd3ByaW1lc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsb3dwcmltZXMubGVuZ3RoKV0pO1xuICAgICAgICAgICAgdmFyIHkgPSBhLm1vZFBvdyhyLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBqID0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaisrIDwgayAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB5ID0geS5tb2RQb3dJbnQoMiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gYm5TcXVhcmU7XG4gICAgLy8gKHB1YmxpYykgdGhpc14yXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLnNxdWFyZVRvKHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vI3JlZ2lvbiBBU1lOQ1xuICAgIC8vIFB1YmxpYyBBUEkgbWV0aG9kXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ2NkYSA9IGZ1bmN0aW9uIChhLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgeCA9ICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhciB5ID0gKGEucyA8IDApID8gYS5uZWdhdGUoKSA6IGEuY2xvbmUoKTtcbiAgICAgICAgaWYgKHguY29tcGFyZVRvKHkpIDwgMCkge1xuICAgICAgICAgICAgdmFyIHQgPSB4O1xuICAgICAgICAgICAgeCA9IHk7XG4gICAgICAgICAgICB5ID0gdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIHZhciBnID0geS5nZXRMb3dlc3RTZXRCaXQoKTtcbiAgICAgICAgaWYgKGcgPCAwKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGcpIHtcbiAgICAgICAgICAgIGcgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnID4gMCkge1xuICAgICAgICAgICAgeC5yU2hpZnRUbyhnLCB4KTtcbiAgICAgICAgICAgIHkuclNoaWZ0VG8oZywgeSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV29ya2hvcnNlIG9mIHRoZSBhbGdvcml0aG0sIGdldHMgY2FsbGVkIDIwMCAtIDgwMCB0aW1lcyBwZXIgNTEyIGJpdCBrZXlnZW4uXG4gICAgICAgIHZhciBnY2RhMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkge1xuICAgICAgICAgICAgICAgIHguclNoaWZ0VG8oaSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgPSB5LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICB5LnJTaGlmdFRvKGksIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHguY29tcGFyZVRvKHkpID49IDApIHtcbiAgICAgICAgICAgICAgICB4LnN1YlRvKHksIHgpO1xuICAgICAgICAgICAgICAgIHguclNoaWZ0VG8oMSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5LnN1YlRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIHkuclNoaWZ0VG8oMSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISh4LnNpZ251bSgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeS5sU2hpZnRUbyhnLCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGNhbGxiYWNrKHkpOyB9LCAwKTsgLy8gZXNjYXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGdjZGExLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChnY2RhMSwgMTApO1xuICAgIH07XG4gICAgLy8gKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbU51bWJlckFzeW5jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gICAgICAgICAgICBpZiAoYSA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21JbnQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21OdW1iZXIoYSwgYyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRlc3RCaXQoYSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIG9wX29yLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KDEsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYm5wXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBibnBmbjFfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgYm5wXzEuZEFkZE9mZnNldCgyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJucF8xLmJpdExlbmd0aCgpID4gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm5wXzEuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgYm5wXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChibnBfMS5pc1Byb2JhYmxlUHJpbWUoYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBjYWxsYmFjaygpOyB9LCAwKTsgLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGJucGZuMV8xLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChibnBmbjFfMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgeCA9IFtdO1xuICAgICAgICAgICAgdmFyIHQgPSBhICYgNztcbiAgICAgICAgICAgIHgubGVuZ3RoID0gKGEgPj4gMykgKyAxO1xuICAgICAgICAgICAgYi5uZXh0Qnl0ZXMoeCk7XG4gICAgICAgICAgICBpZiAodCA+IDApIHtcbiAgICAgICAgICAgICAgICB4WzBdICY9ICgoMSA8PCB0KSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeFswXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcoeCwgMjU2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJpZ0ludGVnZXI7XG59KCkpO1xuLy8jcmVnaW9uIFJFRFVDRVJTXG4vLyNyZWdpb24gTnVsbEV4cFxudmFyIE51bGxFeHAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVsbEV4cCgpIHtcbiAgICB9XG4gICAgLy8gTnVsbEV4cC5wcm90b3R5cGUuY29udmVydCA9IG5Ob3A7XG4gICAgTnVsbEV4cC5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgLy8gTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvO1xuICAgIE51bGxFeHAucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgIH07XG4gICAgLy8gTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG4gICAgTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBmdW5jdGlvbiAoeCwgcikge1xuICAgICAgICB4LnNxdWFyZVRvKHIpO1xuICAgIH07XG4gICAgcmV0dXJuIE51bGxFeHA7XG59KCkpO1xuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG52YXIgQ2xhc3NpYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGFzc2ljKG0pIHtcbiAgICAgICAgdGhpcy5tID0gbTtcbiAgICB9XG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUuY29udmVydCA9IGNDb252ZXJ0O1xuICAgIENsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoeC5zIDwgMCB8fCB4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIENsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuICAgIENsYXNzaWMucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHguZGl2UmVtVG8odGhpcy5tLCBudWxsLCB4KTtcbiAgICB9O1xuICAgIC8vIENsYXNzaWMucHJvdG90eXBlLm11bFRvID0gY011bFRvO1xuICAgIENsYXNzaWMucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIC8vIENsYXNzaWMucHJvdG90eXBlLnNxclRvID0gY1NxclRvO1xuICAgIENsYXNzaWMucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xhc3NpYztcbn0oKSk7XG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBNb250Z29tZXJ5XG4vLyBNb250Z29tZXJ5IHJlZHVjdGlvblxudmFyIE1vbnRnb21lcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9udGdvbWVyeShtKSB7XG4gICAgICAgIHRoaXMubSA9IG07XG4gICAgICAgIHRoaXMubXAgPSBtLmludkRpZ2l0KCk7XG4gICAgICAgIHRoaXMubXBsID0gdGhpcy5tcCAmIDB4N2ZmZjtcbiAgICAgICAgdGhpcy5tcGggPSB0aGlzLm1wID4+IDE1O1xuICAgICAgICB0aGlzLnVtID0gKDEgPDwgKG0uREIgLSAxNSkpIC0gMTtcbiAgICAgICAgdGhpcy5tdDIgPSAyICogbS50O1xuICAgIH1cbiAgICAvLyBNb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnQ7XG4gICAgLy8geFIgbW9kIG1cbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQsIHIpO1xuICAgICAgICByLmRpdlJlbVRvKHRoaXMubSwgbnVsbCwgcik7XG4gICAgICAgIGlmICh4LnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm0uc3ViVG8ociwgcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBNb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuICAgIC8vIHgvUiBtb2QgbVxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHguY29weVRvKHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBNb250Z29tZXJ5LnByb3RvdHlwZS5yZWR1Y2UgPSBtb250UmVkdWNlO1xuICAgIC8vIHggPSB4L1IgbW9kIG0gKEhBQyAxNC4zMilcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB3aGlsZSAoeC50IDw9IHRoaXMubXQyKSB7XG4gICAgICAgICAgICAvLyBwYWQgeCBzbyBhbSBoYXMgZW5vdWdoIHJvb20gbGF0ZXJcbiAgICAgICAgICAgIHhbeC50KytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubS50OyArK2kpIHtcbiAgICAgICAgICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4W2ldKm1wIG1vZCBEVlxuICAgICAgICAgICAgdmFyIGogPSB4W2ldICYgMHg3ZmZmO1xuICAgICAgICAgICAgdmFyIHUwID0gKGogKiB0aGlzLm1wbCArICgoKGogKiB0aGlzLm1waCArICh4W2ldID4+IDE1KSAqIHRoaXMubXBsKSAmIHRoaXMudW0pIDw8IDE1KSkgJiB4LkRNO1xuICAgICAgICAgICAgLy8gdXNlIGFtIHRvIGNvbWJpbmUgdGhlIG11bHRpcGx5LXNoaWZ0LWFkZCBpbnRvIG9uZSBjYWxsXG4gICAgICAgICAgICBqID0gaSArIHRoaXMubS50O1xuICAgICAgICAgICAgeFtqXSArPSB0aGlzLm0uYW0oMCwgdTAsIHgsIGksIDAsIHRoaXMubS50KTtcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBjYXJyeVxuICAgICAgICAgICAgd2hpbGUgKHhbal0gPj0geC5EVikge1xuICAgICAgICAgICAgICAgIHhbal0gLT0geC5EVjtcbiAgICAgICAgICAgICAgICB4Wysral0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4LmNsYW1wKCk7XG4gICAgICAgIHguZHJTaGlmdFRvKHRoaXMubS50LCB4KTtcbiAgICAgICAgaWYgKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkge1xuICAgICAgICAgICAgeC5zdWJUbyh0aGlzLm0sIHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBNb250Z29tZXJ5LnByb3RvdHlwZS5tdWxUbyA9IG1vbnRNdWxUbztcbiAgICAvLyByID0gXCJ4eS9SIG1vZCBtXCI7IHgseSAhPSByXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgICB4Lm11bHRpcGx5VG8oeSwgcik7XG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG4gICAgLy8gciA9IFwieF4yL1IgbW9kIG1cIjsgeCAhPSByXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBmdW5jdGlvbiAoeCwgcikge1xuICAgICAgICB4LnNxdWFyZVRvKHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIHJldHVybiBNb250Z29tZXJ5O1xufSgpKTtcbi8vI2VuZHJlZ2lvbiBNb250Z29tZXJ5XG4vLyNyZWdpb24gQmFycmV0dFxuLy8gQmFycmV0dCBtb2R1bGFyIHJlZHVjdGlvblxudmFyIEJhcnJldHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFycmV0dChtKSB7XG4gICAgICAgIHRoaXMubSA9IG07XG4gICAgICAgIC8vIHNldHVwIEJhcnJldHRcbiAgICAgICAgdGhpcy5yMiA9IG5iaSgpO1xuICAgICAgICB0aGlzLnEzID0gbmJpKCk7XG4gICAgICAgIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyICogbS50LCB0aGlzLnIyKTtcbiAgICAgICAgdGhpcy5tdSA9IHRoaXMucjIuZGl2aWRlKG0pO1xuICAgIH1cbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG4gICAgQmFycmV0dC5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh4LnMgPCAwIHx8IHgudCA+IDIgKiB0aGlzLm0udCkge1xuICAgICAgICAgICAgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5jb21wYXJlVG8odGhpcy5tKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgICAgIHguY29weVRvKHIpO1xuICAgICAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gYmFycmV0dFJldmVydDtcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLnJlZHVjZSA9IGJhcnJldHRSZWR1Y2U7XG4gICAgLy8geCA9IHggbW9kIG0gKEhBQyAxNC40MilcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB4LmRyU2hpZnRUbyh0aGlzLm0udCAtIDEsIHRoaXMucjIpO1xuICAgICAgICBpZiAoeC50ID4gdGhpcy5tLnQgKyAxKSB7XG4gICAgICAgICAgICB4LnQgPSB0aGlzLm0udCArIDE7XG4gICAgICAgICAgICB4LmNsYW1wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMiwgdGhpcy5tLnQgKyAxLCB0aGlzLnEzKTtcbiAgICAgICAgdGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLCB0aGlzLm0udCArIDEsIHRoaXMucjIpO1xuICAgICAgICB3aGlsZSAoeC5jb21wYXJlVG8odGhpcy5yMikgPCAwKSB7XG4gICAgICAgICAgICB4LmRBZGRPZmZzZXQoMSwgdGhpcy5tLnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB4LnN1YlRvKHRoaXMucjIsIHgpO1xuICAgICAgICB3aGlsZSAoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB7XG4gICAgICAgICAgICB4LnN1YlRvKHRoaXMubSwgeCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuICAgIC8vIHIgPSB4KnkgbW9kIG07IHgseSAhPSByXG4gICAgQmFycmV0dC5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgICB4Lm11bHRpcGx5VG8oeSwgcik7XG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH07XG4gICAgLy8gQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG4gICAgLy8gciA9IHheMiBtb2QgbTsgeCAhPSByXG4gICAgQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBmdW5jdGlvbiAoeCwgcikge1xuICAgICAgICB4LnNxdWFyZVRvKHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXJyZXR0O1xufSgpKTtcbi8vI2VuZHJlZ2lvblxuLy8jZW5kcmVnaW9uIFJFRFVDRVJTXG4vLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG5mdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxuZnVuY3Rpb24gcGFyc2VCaWdJbnQoc3RyLCByKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHN0ciwgcik7XG59XG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuLy8gYW0xOiB1c2UgYSBzaW5nbGUgbXVsdCBhbmQgZGl2aWRlIHRvIGdldCB0aGUgaGlnaCBiaXRzLFxuLy8gbWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDI2IGJlY2F1c2Vcbi8vIG1heCBpbnRlcm5hbCB2YWx1ZSA9IDIqZHZhbHVlXjItMipkdmFsdWUgKDwgMl41MylcbmZ1bmN0aW9uIGFtMShpLCB4LCB3LCBqLCBjLCBuKSB7XG4gICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICAgIHZhciB2ID0geCAqIHRoaXNbaSsrXSArIHdbal0gKyBjO1xuICAgICAgICBjID0gTWF0aC5mbG9vcih2IC8gMHg0MDAwMDAwKTtcbiAgICAgICAgd1tqKytdID0gdiAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG4vLyBhbTIgYXZvaWRzIGEgYmlnIG11bHQtYW5kLWV4dHJhY3QgY29tcGxldGVseS5cbi8vIE1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSA8PSAzMCBiZWNhdXNlIHdlIGRvIGJpdHdpc2Ugb3BzXG4vLyBvbiB2YWx1ZXMgdXAgdG8gMipoZHZhbHVlXjItaGR2YWx1ZS0xICg8IDJeMzEpXG5mdW5jdGlvbiBhbTIoaSwgeCwgdywgaiwgYywgbikge1xuICAgIHZhciB4bCA9IHggJiAweDdmZmY7XG4gICAgdmFyIHhoID0geCA+PiAxNTtcbiAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzW2ldICYgMHg3ZmZmO1xuICAgICAgICB2YXIgaCA9IHRoaXNbaSsrXSA+PiAxNTtcbiAgICAgICAgdmFyIG0gPSB4aCAqIGwgKyBoICogeGw7XG4gICAgICAgIGwgPSB4bCAqIGwgKyAoKG0gJiAweDdmZmYpIDw8IDE1KSArIHdbal0gKyAoYyAmIDB4M2ZmZmZmZmYpO1xuICAgICAgICBjID0gKGwgPj4+IDMwKSArIChtID4+PiAxNSkgKyB4aCAqIGggKyAoYyA+Pj4gMzApO1xuICAgICAgICB3W2orK10gPSBsICYgMHgzZmZmZmZmZjtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG4vLyBBbHRlcm5hdGVseSwgc2V0IG1heCBkaWdpdCBiaXRzIHRvIDI4IHNpbmNlIHNvbWVcbi8vIGJyb3dzZXJzIHNsb3cgZG93biB3aGVuIGRlYWxpbmcgd2l0aCAzMi1iaXQgbnVtYmVycy5cbmZ1bmN0aW9uIGFtMyhpLCB4LCB3LCBqLCBjLCBuKSB7XG4gICAgdmFyIHhsID0geCAmIDB4M2ZmZjtcbiAgICB2YXIgeGggPSB4ID4+IDE0O1xuICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgbCA9IHRoaXNbaV0gJiAweDNmZmY7XG4gICAgICAgIHZhciBoID0gdGhpc1tpKytdID4+IDE0O1xuICAgICAgICB2YXIgbSA9IHhoICogbCArIGggKiB4bDtcbiAgICAgICAgbCA9IHhsICogbCArICgobSAmIDB4M2ZmZikgPDwgMTQpICsgd1tqXSArIGM7XG4gICAgICAgIGMgPSAobCA+PiAyOCkgKyAobSA+PiAxNCkgKyB4aCAqIGg7XG4gICAgICAgIHdbaisrXSA9IGwgJiAweGZmZmZmZmY7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuaWYgKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTI7XG4gICAgZGJpdHMgPSAzMDtcbn1cbmVsc2UgaWYgKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMTtcbiAgICBkYml0cyA9IDI2O1xufVxuZWxzZSB7IC8vIE1vemlsbGEvTmV0c2NhcGUgc2VlbXMgdG8gcHJlZmVyIGFtM1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0zO1xuICAgIGRiaXRzID0gMjg7XG59XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5EQiA9IGRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRE0gPSAoKDEgPDwgZGJpdHMpIC0gMSk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5EViA9ICgxIDw8IGRiaXRzKTtcbnZhciBCSV9GUCA9IDUyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRlYgPSBNYXRoLnBvdygyLCBCSV9GUCk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQIC0gZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMiA9IDIgKiBkYml0cyAtIEJJX0ZQO1xuLy8gRGlnaXQgY29udmVyc2lvbnNcbnZhciBCSV9SQyA9IFtdO1xudmFyIHJyO1xudmFyIHZ2O1xucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuZm9yICh2diA9IDA7IHZ2IDw9IDk7ICsrdnYpIHtcbiAgICBCSV9SQ1tycisrXSA9IHZ2O1xufVxucnIgPSBcImFcIi5jaGFyQ29kZUF0KDApO1xuZm9yICh2diA9IDEwOyB2diA8IDM2OyArK3Z2KSB7XG4gICAgQklfUkNbcnIrK10gPSB2djtcbn1cbnJyID0gXCJBXCIuY2hhckNvZGVBdCgwKTtcbmZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikge1xuICAgIEJJX1JDW3JyKytdID0gdnY7XG59XG5mdW5jdGlvbiBpbnRBdChzLCBpKSB7XG4gICAgdmFyIGMgPSBCSV9SQ1tzLmNoYXJDb2RlQXQoaSldO1xuICAgIHJldHVybiAoYyA9PSBudWxsKSA/IC0xIDogYztcbn1cbi8vIHJldHVybiBiaWdpbnQgaW5pdGlhbGl6ZWQgdG8gdmFsdWVcbmZ1bmN0aW9uIG5idihpKSB7XG4gICAgdmFyIHIgPSBuYmkoKTtcbiAgICByLmZyb21JbnQoaSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICAgIHZhciByID0gMTtcbiAgICB2YXIgdDtcbiAgICBpZiAoKHQgPSB4ID4+PiAxNikgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSAxNjtcbiAgICB9XG4gICAgaWYgKCh0ID0geCA+PiA4KSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDg7XG4gICAgfVxuICAgIGlmICgodCA9IHggPj4gNCkgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSA0O1xuICAgIH1cbiAgICBpZiAoKHQgPSB4ID4+IDIpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gMjtcbiAgICB9XG4gICAgaWYgKCh0ID0geCA+PiAxKSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDE7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuLy8gXCJjb25zdGFudHNcIlxuQmlnSW50ZWdlci5aRVJPID0gbmJ2KDApO1xuQmlnSW50ZWdlci5PTkUgPSBuYnYoMSk7XG5cbi8vIHBybmc0LmpzIC0gdXNlcyBBcmNmb3VyIGFzIGEgUFJOR1xudmFyIEFyY2ZvdXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJjZm91cigpIHtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5qID0gMDtcbiAgICAgICAgdGhpcy5TID0gW107XG4gICAgfVxuICAgIC8vIEFyY2ZvdXIucHJvdG90eXBlLmluaXQgPSBBUkM0aW5pdDtcbiAgICAvLyBJbml0aWFsaXplIGFyY2ZvdXIgY29udGV4dCBmcm9tIGtleSwgYW4gYXJyYXkgb2YgaW50cywgZWFjaCBmcm9tIFswLi4yNTVdXG4gICAgQXJjZm91ci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLlNbaV0gPSBpO1xuICAgICAgICB9XG4gICAgICAgIGogPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgICAgIGogPSAoaiArIHRoaXMuU1tpXSArIGtleVtpICUga2V5Lmxlbmd0aF0pICYgMjU1O1xuICAgICAgICAgICAgdCA9IHRoaXMuU1tpXTtcbiAgICAgICAgICAgIHRoaXMuU1tpXSA9IHRoaXMuU1tqXTtcbiAgICAgICAgICAgIHRoaXMuU1tqXSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5qID0gMDtcbiAgICB9O1xuICAgIC8vIEFyY2ZvdXIucHJvdG90eXBlLm5leHQgPSBBUkM0bmV4dDtcbiAgICBBcmNmb3VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgdGhpcy5pID0gKHRoaXMuaSArIDEpICYgMjU1O1xuICAgICAgICB0aGlzLmogPSAodGhpcy5qICsgdGhpcy5TW3RoaXMuaV0pICYgMjU1O1xuICAgICAgICB0ID0gdGhpcy5TW3RoaXMuaV07XG4gICAgICAgIHRoaXMuU1t0aGlzLmldID0gdGhpcy5TW3RoaXMual07XG4gICAgICAgIHRoaXMuU1t0aGlzLmpdID0gdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuU1sodCArIHRoaXMuU1t0aGlzLmldKSAmIDI1NV07XG4gICAgfTtcbiAgICByZXR1cm4gQXJjZm91cjtcbn0oKSk7XG4vLyBQbHVnIGluIHlvdXIgUk5HIGNvbnN0cnVjdG9yIGhlcmVcbmZ1bmN0aW9uIHBybmdfbmV3c3RhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBBcmNmb3VyKCk7XG59XG4vLyBQb29sIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQgYW5kIGdyZWF0ZXIgdGhhbiAzMi5cbi8vIEFuIGFycmF5IG9mIGJ5dGVzIHRoZSBzaXplIG9mIHRoZSBwb29sIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKVxudmFyIHJuZ19wc2l6ZSA9IDI1NjtcblxuLy8gUmFuZG9tIG51bWJlciBnZW5lcmF0b3IgLSByZXF1aXJlcyBhIFBSTkcgYmFja2VuZCwgZS5nLiBwcm5nNC5qc1xudmFyIHJuZ19zdGF0ZTtcbnZhciBybmdfcG9vbCA9IG51bGw7XG52YXIgcm5nX3BwdHI7XG4vLyBJbml0aWFsaXplIHRoZSBwb29sIHdpdGgganVuayBpZiBuZWVkZWQuXG5pZiAocm5nX3Bvb2wgPT0gbnVsbCkge1xuICAgIHJuZ19wb29sID0gW107XG4gICAgcm5nX3BwdHIgPSAwO1xuICAgIHZhciB0ID0gdm9pZCAwO1xuICAgIGlmICh3aW5kb3cuY3J5cHRvICYmIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgZW50cm9weSAoMjA0OCBiaXRzKSBmcm9tIFJORyBpZiBhdmFpbGFibGVcbiAgICAgICAgdmFyIHogPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICAgICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoeik7XG4gICAgICAgIGZvciAodCA9IDA7IHQgPCB6Lmxlbmd0aDsgKyt0KSB7XG4gICAgICAgICAgICBybmdfcG9vbFtybmdfcHB0cisrXSA9IHpbdF0gJiAyNTU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlIG1vdXNlIGV2ZW50cyBmb3IgZW50cm9weSwgaWYgd2UgZG8gbm90IGhhdmUgZW5vdWdoIGVudHJvcHkgYnkgdGhlIHRpbWVcbiAgICAvLyB3ZSBuZWVkIGl0LCBlbnRyb3B5IHdpbGwgYmUgZ2VuZXJhdGVkIGJ5IE1hdGgucmFuZG9tLlxuICAgIHZhciBvbk1vdXNlTW92ZUxpc3RlbmVyXzEgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHRoaXMuY291bnQgfHwgMDtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPj0gMjU2IHx8IHJuZ19wcHRyID49IHJuZ19wc2l6ZSkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmVMaXN0ZW5lcl8xLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuZGV0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGV0YWNoRXZlbnQoXCJvbm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbW91c2VDb29yZGluYXRlcyA9IGV2LnggKyBldi55O1xuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gPSBtb3VzZUNvb3JkaW5hdGVzICYgMjU1O1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgRmlyZWZveCB3aWxsIGRlbnkgcGVybWlzc2lvbiB0byBhY2Nlc3MgZXZlbnQgcHJvcGVydGllcyBmb3Igc29tZSByZWFzb24uIElnbm9yZS5cbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlTGlzdGVuZXJfMSwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KFwib25tb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmVMaXN0ZW5lcl8xKTtcbiAgICB9XG59XG5mdW5jdGlvbiBybmdfZ2V0X2J5dGUoKSB7XG4gICAgaWYgKHJuZ19zdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIHJuZ19zdGF0ZSA9IHBybmdfbmV3c3RhdGUoKTtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbWF5IG5vdCBoYXZlIGNvbGxlY3RlZCBlbm91Z2ggZW50cm9weS4gIElmIG5vdCwgZmFsbCBiYWNrIHRvIE1hdGgucmFuZG9tXG4gICAgICAgIHdoaWxlIChybmdfcHB0ciA8IHJuZ19wc2l6ZSkge1xuICAgICAgICAgICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoNjU1MzYgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgICAgIHJuZ19wb29sW3JuZ19wcHRyKytdID0gcmFuZG9tICYgMjU1O1xuICAgICAgICB9XG4gICAgICAgIHJuZ19zdGF0ZS5pbml0KHJuZ19wb29sKTtcbiAgICAgICAgZm9yIChybmdfcHB0ciA9IDA7IHJuZ19wcHRyIDwgcm5nX3Bvb2wubGVuZ3RoOyArK3JuZ19wcHRyKSB7XG4gICAgICAgICAgICBybmdfcG9vbFtybmdfcHB0cl0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJuZ19wcHRyID0gMDtcbiAgICB9XG4gICAgLy8gVE9ETzogYWxsb3cgcmVzZWVkaW5nIGFmdGVyIGZpcnN0IHJlcXVlc3RcbiAgICByZXR1cm4gcm5nX3N0YXRlLm5leHQoKTtcbn1cbnZhciBTZWN1cmVSYW5kb20gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VjdXJlUmFuZG9tKCkge1xuICAgIH1cbiAgICBTZWN1cmVSYW5kb20ucHJvdG90eXBlLm5leHRCeXRlcyA9IGZ1bmN0aW9uIChiYSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBiYVtpXSA9IHJuZ19nZXRfYnl0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2VjdXJlUmFuZG9tO1xufSgpKTtcblxuLy8gRGVwZW5kcyBvbiBqc2JuLmpzIGFuZCBybmcuanNcbi8vIGZ1bmN0aW9uIGxpbmVicmsocyxuKSB7XG4vLyAgIHZhciByZXQgPSBcIlwiO1xuLy8gICB2YXIgaSA9IDA7XG4vLyAgIHdoaWxlKGkgKyBuIDwgcy5sZW5ndGgpIHtcbi8vICAgICByZXQgKz0gcy5zdWJzdHJpbmcoaSxpK24pICsgXCJcXG5cIjtcbi8vICAgICBpICs9IG47XG4vLyAgIH1cbi8vICAgcmV0dXJuIHJldCArIHMuc3Vic3RyaW5nKGkscy5sZW5ndGgpO1xuLy8gfVxuLy8gZnVuY3Rpb24gYnl0ZTJIZXgoYikge1xuLy8gICBpZihiIDwgMHgxMClcbi8vICAgICByZXR1cm4gXCIwXCIgKyBiLnRvU3RyaW5nKDE2KTtcbi8vICAgZWxzZVxuLy8gICAgIHJldHVybiBiLnRvU3RyaW5nKDE2KTtcbi8vIH1cbmZ1bmN0aW9uIHBrY3MxcGFkMShzLCBuKSB7XG4gICAgaWYgKG4gPCBzLmxlbmd0aCArIDIyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNZXNzYWdlIHRvbyBsb25nIGZvciBSU0FcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbGVuID0gbiAtIHMubGVuZ3RoIC0gNjtcbiAgICB2YXIgZmlsbGVyID0gXCJcIjtcbiAgICBmb3IgKHZhciBmID0gMDsgZiA8IGxlbjsgZiArPSAyKSB7XG4gICAgICAgIGZpbGxlciArPSBcImZmXCI7XG4gICAgfVxuICAgIHZhciBtID0gXCIwMDAxXCIgKyBmaWxsZXIgKyBcIjAwXCIgKyBzO1xuICAgIHJldHVybiBwYXJzZUJpZ0ludChtLCAxNik7XG59XG4vLyBQS0NTIzEgKHR5cGUgMiwgcmFuZG9tKSBwYWQgaW5wdXQgc3RyaW5nIHMgdG8gbiBieXRlcywgYW5kIHJldHVybiBhIGJpZ2ludFxuZnVuY3Rpb24gcGtjczFwYWQyKHMsIG4pIHtcbiAgICBpZiAobiA8IHMubGVuZ3RoICsgMTEpIHsgLy8gVE9ETzogZml4IGZvciB1dGYtOFxuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWVzc2FnZSB0b28gbG9uZyBmb3IgUlNBXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGJhID0gW107XG4gICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBuID4gMCkge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpLS0pO1xuICAgICAgICBpZiAoYyA8IDEyOCkgeyAvLyBlbmNvZGUgdXNpbmcgdXRmLThcbiAgICAgICAgICAgIGJhWy0tbl0gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjID4gMTI3KSAmJiAoYyA8IDIwNDgpKSB7XG4gICAgICAgICAgICBiYVstLW5dID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBiYVstLW5dID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiYVstLW5dID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBiYVstLW5dID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiYVstLW5dID0gMDtcbiAgICB2YXIgcm5nID0gbmV3IFNlY3VyZVJhbmRvbSgpO1xuICAgIHZhciB4ID0gW107XG4gICAgd2hpbGUgKG4gPiAyKSB7IC8vIHJhbmRvbSBub24temVybyBwYWRcbiAgICAgICAgeFswXSA9IDA7XG4gICAgICAgIHdoaWxlICh4WzBdID09IDApIHtcbiAgICAgICAgICAgIHJuZy5uZXh0Qnl0ZXMoeCk7XG4gICAgICAgIH1cbiAgICAgICAgYmFbLS1uXSA9IHhbMF07XG4gICAgfVxuICAgIGJhWy0tbl0gPSAyO1xuICAgIGJhWy0tbl0gPSAwO1xuICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihiYSk7XG59XG4vLyBcImVtcHR5XCIgUlNBIGtleSBjb25zdHJ1Y3RvclxudmFyIFJTQUtleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSU0FLZXkoKSB7XG4gICAgICAgIHRoaXMubiA9IG51bGw7XG4gICAgICAgIHRoaXMuZSA9IDA7XG4gICAgICAgIHRoaXMuZCA9IG51bGw7XG4gICAgICAgIHRoaXMucCA9IG51bGw7XG4gICAgICAgIHRoaXMucSA9IG51bGw7XG4gICAgICAgIHRoaXMuZG1wMSA9IG51bGw7XG4gICAgICAgIHRoaXMuZG1xMSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29lZmYgPSBudWxsO1xuICAgIH1cbiAgICAvLyNyZWdpb24gUFJPVEVDVEVEXG4gICAgLy8gcHJvdGVjdGVkXG4gICAgLy8gUlNBS2V5LnByb3RvdHlwZS5kb1B1YmxpYyA9IFJTQURvUHVibGljO1xuICAgIC8vIFBlcmZvcm0gcmF3IHB1YmxpYyBvcGVyYXRpb24gb24gXCJ4XCI6IHJldHVybiB4XmUgKG1vZCBuKVxuICAgIFJTQUtleS5wcm90b3R5cGUuZG9QdWJsaWMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5tb2RQb3dJbnQodGhpcy5lLCB0aGlzLm4pO1xuICAgIH07XG4gICAgLy8gUlNBS2V5LnByb3RvdHlwZS5kb1ByaXZhdGUgPSBSU0FEb1ByaXZhdGU7XG4gICAgLy8gUGVyZm9ybSByYXcgcHJpdmF0ZSBvcGVyYXRpb24gb24gXCJ4XCI6IHJldHVybiB4XmQgKG1vZCBuKVxuICAgIFJTQUtleS5wcm90b3R5cGUuZG9Qcml2YXRlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHRoaXMucCA9PSBudWxsIHx8IHRoaXMucSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geC5tb2RQb3codGhpcy5kLCB0aGlzLm4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlLWNhbGN1bGF0ZSBhbnkgbWlzc2luZyBDUlQgcGFyYW1zXG4gICAgICAgIHZhciB4cCA9IHgubW9kKHRoaXMucCkubW9kUG93KHRoaXMuZG1wMSwgdGhpcy5wKTtcbiAgICAgICAgdmFyIHhxID0geC5tb2QodGhpcy5xKS5tb2RQb3codGhpcy5kbXExLCB0aGlzLnEpO1xuICAgICAgICB3aGlsZSAoeHAuY29tcGFyZVRvKHhxKSA8IDApIHtcbiAgICAgICAgICAgIHhwID0geHAuYWRkKHRoaXMucCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhwLnN1YnRyYWN0KHhxKS5tdWx0aXBseSh0aGlzLmNvZWZmKS5tb2QodGhpcy5wKS5tdWx0aXBseSh0aGlzLnEpLmFkZCh4cSk7XG4gICAgfTtcbiAgICAvLyNlbmRyZWdpb24gUFJPVEVDVEVEXG4gICAgLy8jcmVnaW9uIFBVQkxJQ1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuc2V0UHVibGljID0gUlNBU2V0UHVibGljO1xuICAgIC8vIFNldCB0aGUgcHVibGljIGtleSBmaWVsZHMgTiBhbmQgZSBmcm9tIGhleCBzdHJpbmdzXG4gICAgUlNBS2V5LnByb3RvdHlwZS5zZXRQdWJsaWMgPSBmdW5jdGlvbiAoTiwgRSkge1xuICAgICAgICBpZiAoTiAhPSBudWxsICYmIEUgIT0gbnVsbCAmJiBOLmxlbmd0aCA+IDAgJiYgRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChOLCAxNik7XG4gICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBSU0EgcHVibGljIGtleVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUlNBS2V5LnByb3RvdHlwZS5lbmNyeXB0ID0gUlNBRW5jcnlwdDtcbiAgICAvLyBSZXR1cm4gdGhlIFBLQ1MjMSBSU0EgZW5jcnlwdGlvbiBvZiBcInRleHRcIiBhcyBhbiBldmVuLWxlbmd0aCBoZXggc3RyaW5nXG4gICAgUlNBS2V5LnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIG0gPSBwa2NzMXBhZDIodGV4dCwgKHRoaXMubi5iaXRMZW5ndGgoKSArIDcpID4+IDMpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHRoaXMuZG9QdWJsaWMobSk7XG4gICAgICAgIGlmIChjID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoID0gYy50b1N0cmluZygxNik7XG4gICAgICAgIGlmICgoaC5sZW5ndGggJiAxKSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIiArIGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZSA9IFJTQVNldFByaXZhdGU7XG4gICAgLy8gU2V0IHRoZSBwcml2YXRlIGtleSBmaWVsZHMgTiwgZSwgYW5kIGQgZnJvbSBoZXggc3RyaW5nc1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZSA9IGZ1bmN0aW9uIChOLCBFLCBEKSB7XG4gICAgICAgIGlmIChOICE9IG51bGwgJiYgRSAhPSBudWxsICYmIE4ubGVuZ3RoID4gMCAmJiBFLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubiA9IHBhcnNlQmlnSW50KE4sIDE2KTtcbiAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KEUsIDE2KTtcbiAgICAgICAgICAgIHRoaXMuZCA9IHBhcnNlQmlnSW50KEQsIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIFJTQSBwcml2YXRlIGtleVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUlNBS2V5LnByb3RvdHlwZS5zZXRQcml2YXRlRXggPSBSU0FTZXRQcml2YXRlRXg7XG4gICAgLy8gU2V0IHRoZSBwcml2YXRlIGtleSBmaWVsZHMgTiwgZSwgZCBhbmQgQ1JUIHBhcmFtcyBmcm9tIGhleCBzdHJpbmdzXG4gICAgUlNBS2V5LnByb3RvdHlwZS5zZXRQcml2YXRlRXggPSBmdW5jdGlvbiAoTiwgRSwgRCwgUCwgUSwgRFAsIERRLCBDKSB7XG4gICAgICAgIGlmIChOICE9IG51bGwgJiYgRSAhPSBudWxsICYmIE4ubGVuZ3RoID4gMCAmJiBFLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubiA9IHBhcnNlQmlnSW50KE4sIDE2KTtcbiAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KEUsIDE2KTtcbiAgICAgICAgICAgIHRoaXMuZCA9IHBhcnNlQmlnSW50KEQsIDE2KTtcbiAgICAgICAgICAgIHRoaXMucCA9IHBhcnNlQmlnSW50KFAsIDE2KTtcbiAgICAgICAgICAgIHRoaXMucSA9IHBhcnNlQmlnSW50KFEsIDE2KTtcbiAgICAgICAgICAgIHRoaXMuZG1wMSA9IHBhcnNlQmlnSW50KERQLCAxNik7XG4gICAgICAgICAgICB0aGlzLmRtcTEgPSBwYXJzZUJpZ0ludChEUSwgMTYpO1xuICAgICAgICAgICAgdGhpcy5jb2VmZiA9IHBhcnNlQmlnSW50KEMsIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIFJTQSBwcml2YXRlIGtleVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUlNBS2V5LnByb3RvdHlwZS5nZW5lcmF0ZSA9IFJTQUdlbmVyYXRlO1xuICAgIC8vIEdlbmVyYXRlIGEgbmV3IHJhbmRvbSBwcml2YXRlIGtleSBCIGJpdHMgbG9uZywgdXNpbmcgcHVibGljIGV4cHQgRVxuICAgIFJTQUtleS5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoQiwgRSkge1xuICAgICAgICB2YXIgcm5nID0gbmV3IFNlY3VyZVJhbmRvbSgpO1xuICAgICAgICB2YXIgcXMgPSBCID4+IDE7XG4gICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KEUsIDE2KTtcbiAgICAgICAgdmFyIGVlID0gbmV3IEJpZ0ludGVnZXIoRSwgMTYpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gbmV3IEJpZ0ludGVnZXIoQiAtIHFzLCAxLCBybmcpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZChlZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwICYmIHRoaXMucC5pc1Byb2JhYmxlUHJpbWUoMTApKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnEgPSBuZXcgQmlnSW50ZWdlcihxcywgMSwgcm5nKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2QoZWUpLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCAmJiB0aGlzLnEuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wLmNvbXBhcmVUbyh0aGlzLnEpIDw9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMucDtcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnE7XG4gICAgICAgICAgICAgICAgdGhpcy5xID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwMSA9IHRoaXMucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgICAgICB2YXIgcTEgPSB0aGlzLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICAgICAgdmFyIHBoaSA9IHAxLm11bHRpcGx5KHExKTtcbiAgICAgICAgICAgIGlmIChwaGkuZ2NkKGVlKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm4gPSB0aGlzLnAubXVsdGlwbHkodGhpcy5xKTtcbiAgICAgICAgICAgICAgICB0aGlzLmQgPSBlZS5tb2RJbnZlcnNlKHBoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kbXAxID0gdGhpcy5kLm1vZChwMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kbXExID0gdGhpcy5kLm1vZChxMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmZiA9IHRoaXMucS5tb2RJbnZlcnNlKHRoaXMucCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZGVjcnlwdCA9IFJTQURlY3J5cHQ7XG4gICAgLy8gUmV0dXJuIHRoZSBQS0NTIzEgUlNBIGRlY3J5cHRpb24gb2YgXCJjdGV4dFwiLlxuICAgIC8vIFwiY3RleHRcIiBpcyBhbiBldmVuLWxlbmd0aCBoZXggc3RyaW5nIGFuZCB0aGUgb3V0cHV0IGlzIGEgcGxhaW4gc3RyaW5nLlxuICAgIFJTQUtleS5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uIChjdGV4dCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlQmlnSW50KGN0ZXh0LCAxNik7XG4gICAgICAgIHZhciBtID0gdGhpcy5kb1ByaXZhdGUoYyk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwa2NzMXVucGFkMihtLCAodGhpcy5uLmJpdExlbmd0aCgpICsgNykgPj4gMyk7XG4gICAgfTtcbiAgICAvLyBHZW5lcmF0ZSBhIG5ldyByYW5kb20gcHJpdmF0ZSBrZXkgQiBiaXRzIGxvbmcsIHVzaW5nIHB1YmxpYyBleHB0IEVcbiAgICBSU0FLZXkucHJvdG90eXBlLmdlbmVyYXRlQXN5bmMgPSBmdW5jdGlvbiAoQiwgRSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJuZyA9IG5ldyBTZWN1cmVSYW5kb20oKTtcbiAgICAgICAgdmFyIHFzID0gQiA+PiAxO1xuICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgIHZhciBlZSA9IG5ldyBCaWdJbnRlZ2VyKEUsIDE2KTtcbiAgICAgICAgdmFyIHJzYSA9IHRoaXM7XG4gICAgICAgIC8vIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIG5vbi1kZXNjcmlwdCBuYW1lcyBiZWNhdXNlIHRoZXkgd2VyZSBvcmlnaW5hbGx5IGZvcig7OykgbG9vcHMuXG4gICAgICAgIC8vIEkgZG9uJ3Qga25vdyBhYm91dCBjcnlwdG9ncmFwaHkgdG8gZ2l2ZSB0aGVtIGJldHRlciBuYW1lcyB0aGFuIGxvb3AxLTQuXG4gICAgICAgIHZhciBsb29wMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsb29wNCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocnNhLnAuY29tcGFyZVRvKHJzYS5xKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gcnNhLnA7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5wID0gcnNhLnE7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5xID0gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHAxID0gcnNhLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICAgICAgICAgIHZhciBxMSA9IHJzYS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgICAgICAgICB2YXIgcGhpID0gcDEubXVsdGlwbHkocTEpO1xuICAgICAgICAgICAgICAgIGlmIChwaGkuZ2NkKGVlKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcnNhLm4gPSByc2EucC5tdWx0aXBseShyc2EucSk7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5kID0gZWUubW9kSW52ZXJzZShwaGkpO1xuICAgICAgICAgICAgICAgICAgICByc2EuZG1wMSA9IHJzYS5kLm1vZChwMSk7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5kbXExID0gcnNhLmQubW9kKHExKTtcbiAgICAgICAgICAgICAgICAgICAgcnNhLmNvZWZmID0gcnNhLnEubW9kSW52ZXJzZShyc2EucCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBjYWxsYmFjaygpOyB9LCAwKTsgLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3AxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGxvb3AzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJzYS5xID0gbmJpKCk7XG4gICAgICAgICAgICAgICAgcnNhLnEuZnJvbU51bWJlckFzeW5jKHFzLCAxLCBybmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcnNhLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZGEoZWUsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDAgJiYgcnNhLnEuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wMywgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBsb29wMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByc2EucCA9IG5iaSgpO1xuICAgICAgICAgICAgICAgIHJzYS5wLmZyb21OdW1iZXJBc3luYyhCIC0gcXMsIDEsIHJuZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByc2EucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkYShlZSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCAmJiByc2EucC5pc1Byb2JhYmxlUHJpbWUoMTApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wMywgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3AyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0VGltZW91dChsb29wMiwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQobG9vcDEsIDApO1xuICAgIH07XG4gICAgUlNBS2V5LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKHRleHQsIGRpZ2VzdE1ldGhvZCwgZGlnZXN0TmFtZSkge1xuICAgICAgICB2YXIgaGVhZGVyID0gZ2V0RGlnZXN0SGVhZGVyKGRpZ2VzdE5hbWUpO1xuICAgICAgICB2YXIgZGlnZXN0ID0gaGVhZGVyICsgZGlnZXN0TWV0aG9kKHRleHQpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBtID0gcGtjczFwYWQxKGRpZ2VzdCwgdGhpcy5uLmJpdExlbmd0aCgpIC8gNCk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjID0gdGhpcy5kb1ByaXZhdGUobSk7XG4gICAgICAgIGlmIChjID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoID0gYy50b1N0cmluZygxNik7XG4gICAgICAgIGlmICgoaC5sZW5ndGggJiAxKSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIiArIGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJTQUtleS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKHRleHQsIHNpZ25hdHVyZSwgZGlnZXN0TWV0aG9kKSB7XG4gICAgICAgIHZhciBjID0gcGFyc2VCaWdJbnQoc2lnbmF0dXJlLCAxNik7XG4gICAgICAgIHZhciBtID0gdGhpcy5kb1B1YmxpYyhjKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVucGFkZGVkID0gbS50b1N0cmluZygxNikucmVwbGFjZSgvXjFmKzAwLywgXCJcIik7XG4gICAgICAgIHZhciBkaWdlc3QgPSByZW1vdmVEaWdlc3RIZWFkZXIodW5wYWRkZWQpO1xuICAgICAgICByZXR1cm4gZGlnZXN0ID09IGRpZ2VzdE1ldGhvZCh0ZXh0KS50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIFJTQUtleTtcbn0oKSk7XG4vLyBVbmRvIFBLQ1MjMSAodHlwZSAyLCByYW5kb20pIHBhZGRpbmcgYW5kLCBpZiB2YWxpZCwgcmV0dXJuIHRoZSBwbGFpbnRleHRcbmZ1bmN0aW9uIHBrY3MxdW5wYWQyKGQsIG4pIHtcbiAgICB2YXIgYiA9IGQudG9CeXRlQXJyYXkoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBiLmxlbmd0aCAmJiBiW2ldID09IDApIHtcbiAgICAgICAgKytpO1xuICAgIH1cbiAgICBpZiAoYi5sZW5ndGggLSBpICE9IG4gLSAxIHx8IGJbaV0gIT0gMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgKytpO1xuICAgIHdoaWxlIChiW2ldICE9IDApIHtcbiAgICAgICAgaWYgKCsraSA+PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgd2hpbGUgKCsraSA8IGIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gYltpXSAmIDI1NTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHsgLy8gdXRmLTggZGVjb2RlXG4gICAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyA+IDE5MSkgJiYgKGMgPCAyMjQpKSB7XG4gICAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAzMSkgPDwgNikgfCAoYltpICsgMV0gJiA2MykpO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMTUpIDw8IDEyKSB8ICgoYltpICsgMV0gJiA2MykgPDwgNikgfCAoYltpICsgMl0gJiA2MykpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ0NyNwYWdlLTQzXG52YXIgRElHRVNUX0hFQURFUlMgPSB7XG4gICAgbWQyOiBcIjMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDIwNTAwMDQxMFwiLFxuICAgIG1kNTogXCIzMDIwMzAwYzA2MDgyYTg2NDg4NmY3MGQwMjA1MDUwMDA0MTBcIixcbiAgICBzaGExOiBcIjMwMjEzMDA5MDYwNTJiMGUwMzAyMWEwNTAwMDQxNFwiLFxuICAgIHNoYTIyNDogXCIzMDJkMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDQwNTAwMDQxY1wiLFxuICAgIHNoYTI1NjogXCIzMDMxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDEwNTAwMDQyMFwiLFxuICAgIHNoYTM4NDogXCIzMDQxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDIwNTAwMDQzMFwiLFxuICAgIHNoYTUxMjogXCIzMDUxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDMwNTAwMDQ0MFwiLFxuICAgIHJpcGVtZDE2MDogXCIzMDIxMzAwOTA2MDUyYjI0MDMwMjAxMDUwMDA0MTRcIixcbn07XG5mdW5jdGlvbiBnZXREaWdlc3RIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiBESUdFU1RfSEVBREVSU1tuYW1lXSB8fCBcIlwiO1xufVxuZnVuY3Rpb24gcmVtb3ZlRGlnZXN0SGVhZGVyKHN0cikge1xuICAgIGZvciAodmFyIG5hbWVfMSBpbiBESUdFU1RfSEVBREVSUykge1xuICAgICAgICBpZiAoRElHRVNUX0hFQURFUlMuaGFzT3duUHJvcGVydHkobmFtZV8xKSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IERJR0VTVF9IRUFERVJTW25hbWVfMV07XG4gICAgICAgICAgICB2YXIgbGVuID0gaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdHIuc3Vic3RyKDAsIGxlbikgPT0gaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLy8gUmV0dXJuIHRoZSBQS0NTIzEgUlNBIGVuY3J5cHRpb24gb2YgXCJ0ZXh0XCIgYXMgYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmdcbi8vIGZ1bmN0aW9uIFJTQUVuY3J5cHRCNjQodGV4dCkge1xuLy8gIHZhciBoID0gdGhpcy5lbmNyeXB0KHRleHQpO1xuLy8gIGlmKGgpIHJldHVybiBoZXgyYjY0KGgpOyBlbHNlIHJldHVybiBudWxsO1xuLy8gfVxuLy8gcHVibGljXG4vLyBSU0FLZXkucHJvdG90eXBlLmVuY3J5cHRfYjY0ID0gUlNBRW5jcnlwdEI2NDtcblxuLyohXG5Db3B5cmlnaHQgKGMpIDIwMTEsIFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5Db2RlIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZTpcbmh0dHA6Ly9kZXZlbG9wZXIueWFob28uY29tL3l1aS9saWNlbnNlLmh0bWxcbnZlcnNpb246IDIuOS4wXG4qL1xudmFyIFlBSE9PID0ge307XG5ZQUhPTy5sYW5nID0ge1xuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gc2V0IHVwIHRoZSBwcm90b3R5cGUsIGNvbnN0cnVjdG9yIGFuZCBzdXBlcmNsYXNzIHByb3BlcnRpZXMgdG9cbiAgICAgKiBzdXBwb3J0IGFuIGluaGVyaXRhbmNlIHN0cmF0ZWd5IHRoYXQgY2FuIGNoYWluIGNvbnN0cnVjdG9ycyBhbmQgbWV0aG9kcy5cbiAgICAgKiBTdGF0aWMgbWVtYmVycyB3aWxsIG5vdCBiZSBpbmhlcml0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGV4dGVuZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjICAgdGhlIG9iamVjdCB0byBtb2RpZnlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlcmMgdGhlIG9iamVjdCB0byBpbmhlcml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyAgYWRkaXRpb25hbCBwcm9wZXJ0aWVzL21ldGhvZHMgdG8gYWRkIHRvIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2xhc3MgcHJvdG90eXBlLiAgVGhlc2Ugd2lsbCBvdmVycmlkZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nIGl0ZW1zIG9idGFpbmVkIGZyb20gdGhlIHN1cGVyY2xhc3NcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHByZXNlbnQuXG4gICAgICovXG4gICAgZXh0ZW5kOiBmdW5jdGlvbihzdWJjLCBzdXBlcmMsIG92ZXJyaWRlcykge1xuICAgICAgICBpZiAoISBzdXBlcmMgfHwgISBzdWJjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZQUhPTy5sYW5nLmV4dGVuZCBmYWlsZWQsIHBsZWFzZSBjaGVjayB0aGF0IFwiICtcbiAgICAgICAgICAgICAgICBcImFsbCBkZXBlbmRlbmNpZXMgYXJlIGluY2x1ZGVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgRi5wcm90b3R5cGUgPSBzdXBlcmMucHJvdG90eXBlO1xuICAgICAgICBzdWJjLnByb3RvdHlwZSA9IG5ldyBGKCk7XG4gICAgICAgIHN1YmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViYztcbiAgICAgICAgc3ViYy5zdXBlcmNsYXNzID0gc3VwZXJjLnByb3RvdHlwZTtcblxuICAgICAgICBpZiAoc3VwZXJjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9PSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBzdXBlcmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3VwZXJjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgc3ViYy5wcm90b3R5cGVbaV0gPSBvdmVycmlkZXNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJRSB3aWxsIG5vdCBlbnVtZXJhdGUgbmF0aXZlIGZ1bmN0aW9ucyBpbiBhIGRlcml2ZWQgb2JqZWN0IGV2ZW4gaWYgdGhlXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiB3YXMgb3ZlcnJpZGRlbi4gIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBzcGVjaWZpYyBmdW5jdGlvbnNcbiAgICAgICAgICAgICAqIHdlIGNhcmUgYWJvdXQgb24gdGhlIE9iamVjdCBwcm90b3R5cGUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgX0lFRW51bUZpeFxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gciAgdGhlIG9iamVjdCB0byByZWNlaXZlIHRoZSBhdWdtZW50YXRpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHMgIHRoZSBvYmplY3QgdGhhdCBzdXBwbGllcyB0aGUgcHJvcGVydGllcyB0byBhdWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX0lFRW51bUZpeCA9IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICAgICAgQUREID0gW1widG9TdHJpbmdcIiwgXCJ2YWx1ZU9mXCJdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoL01TSUUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX0lFRW51bUZpeCA9IGZ1bmN0aW9uKHIsIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBBREQubGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5hbWUgPSBBRERbaV0sIGYgPSBzW2ZuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGYgPT09ICdmdW5jdGlvbicgJiYgZiAhPSBPYmplY3QucHJvdG90eXBlW2ZuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2ZuYW1lXSA9IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7fSAgICAgICAgICAgIF9JRUVudW1GaXgoc3ViYy5wcm90b3R5cGUsIG92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKiBhc24xLTEuMC4xMy5qcyAoYykgMjAxMy0yMDE3IEtlbmppIFVydXNoaW1hIHwga2p1ci5naXRodWIuY29tL2pzcnNhc2lnbi9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3XG4gKiBAbmFtZSBhc24xLTEuMC5qc1xuICogQGF1dGhvciBLZW5qaSBVcnVzaGltYSBrZW5qaS51cnVzaGltYUBnbWFpbC5jb21cbiAqIEB2ZXJzaW9uIGFzbjEgMS4wLjEzICgyMDE3LUp1bi0wMilcbiAqIEBzaW5jZSBqc3JzYXNpZ24gMi4xXG4gKiBAbGljZW5zZSA8YSBocmVmPVwiaHR0cHM6Ly9ranVyLmdpdGh1Yi5pby9qc3JzYXNpZ24vbGljZW5zZS9cIj5NSVQgTGljZW5zZTwvYT5cbiAqL1xuXG4vKipcbiAqIGtqdXIncyBjbGFzcyBsaWJyYXJ5IG5hbWUgc3BhY2VcbiAqIDxwPlxuICogVGhpcyBuYW1lIHNwYWNlIHByb3ZpZGVzIGZvbGxvd2luZyBuYW1lIHNwYWNlczpcbiAqIDx1bD5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xfSAtIEFTTi4xIHByaW1pdGl2ZSBoZXhhZGVjaW1hbCBlbmNvZGVyPC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLng1MDl9IC0gQVNOLjEgc3RydWN0dXJlIGZvciBYLjUwOSBjZXJ0aWZpY2F0ZSBhbmQgQ1JMPC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5jcnlwdG99IC0gSmF2YSBDcnlwdG9ncmFwaGljIEV4dGVuc2lvbihKQ0UpIHN0eWxlIE1lc3NhZ2VEaWdlc3QvU2lnbmF0dXJlXG4gKiBjbGFzcyBhbmQgdXRpbGl0aWVzPC9saT5cbiAqIDwvdWw+XG4gKiA8L3A+XG4gKiBOT1RFOiBQbGVhc2UgaWdub3JlIG1ldGhvZCBzdW1tYXJ5IGFuZCBkb2N1bWVudCBvZiB0aGlzIG5hbWVzcGFjZS4gVGhpcyBjYXVzZWQgYnkgYSBidWcgb2YganNkb2MyLlxuICogQG5hbWUgS0pVUlxuICogQG5hbWVzcGFjZSBranVyJ3MgY2xhc3MgbGlicmFyeSBuYW1lIHNwYWNlXG4gKi9cbnZhciBLSlVSID0ge307XG5cbi8qKlxuICoga2p1cidzIEFTTi4xIGNsYXNzIGxpYnJhcnkgbmFtZSBzcGFjZVxuICogPHA+XG4gKiBUaGlzIGlzIElUVS1UIFguNjkwIEFTTi4xIERFUiBlbmNvZGVyIGNsYXNzIGxpYnJhcnkgYW5kXG4gKiBjbGFzcyBzdHJ1Y3R1cmUgYW5kIG1ldGhvZHMgaXMgdmVyeSBzaW1pbGFyIHRvXG4gKiBvcmcuYm91bmN5Y2FzdGxlLmFzbjEgcGFja2FnZSBvZlxuICogd2VsbCBrbm93biBCb3VuY3lDYXNsdGUgQ3J5cHRvZ3JhcGh5IExpYnJhcnkuXG4gKiA8aDQ+UFJPVklESU5HIEFTTi4xIFBSSU1JVElWRVM8L2g0PlxuICogSGVyZSBhcmUgQVNOLjEgREVSIHByaW1pdGl2ZSBjbGFzc2VzLlxuICogPHVsPlxuICogPGxpPjB4MDEge0BsaW5rIEtKVVIuYXNuMS5ERVJCb29sZWFufTwvbGk+XG4gKiA8bGk+MHgwMiB7QGxpbmsgS0pVUi5hc24xLkRFUkludGVnZXJ9PC9saT5cbiAqIDxsaT4weDAzIHtAbGluayBLSlVSLmFzbjEuREVSQml0U3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgwNCB7QGxpbmsgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgwNSB7QGxpbmsgS0pVUi5hc24xLkRFUk51bGx9PC9saT5cbiAqIDxsaT4weDA2IHtAbGluayBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllcn08L2xpPlxuICogPGxpPjB4MGEge0BsaW5rIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkfTwvbGk+XG4gKiA8bGk+MHgwYyB7QGxpbmsgS0pVUi5hc24xLkRFUlVURjhTdHJpbmd9PC9saT5cbiAqIDxsaT4weDEyIHtAbGluayBLSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZ308L2xpPlxuICogPGxpPjB4MTMge0BsaW5rIEtKVVIuYXNuMS5ERVJQcmludGFibGVTdHJpbmd9PC9saT5cbiAqIDxsaT4weDE0IHtAbGluayBLSlVSLmFzbjEuREVSVGVsZXRleFN0cmluZ308L2xpPlxuICogPGxpPjB4MTYge0BsaW5rIEtKVVIuYXNuMS5ERVJJQTVTdHJpbmd9PC9saT5cbiAqIDxsaT4weDE3IHtAbGluayBLSlVSLmFzbjEuREVSVVRDVGltZX08L2xpPlxuICogPGxpPjB4MTgge0BsaW5rIEtKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWV9PC9saT5cbiAqIDxsaT4weDMwIHtAbGluayBLSlVSLmFzbjEuREVSU2VxdWVuY2V9PC9saT5cbiAqIDxsaT4weDMxIHtAbGluayBLSlVSLmFzbjEuREVSU2V0fTwvbGk+XG4gKiA8L3VsPlxuICogPGg0Pk9USEVSIEFTTi4xIENMQVNTRVM8L2g0PlxuICogPHVsPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuQVNOMU9iamVjdH08L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmd9PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZX08L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkfTwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3R9PC9saT5cbiAqIDwvdWw+XG4gKiA8aDQ+U1VCIE5BTUUgU1BBQ0VTPC9oND5cbiAqIDx1bD5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLmNhZGVzfSAtIENBZEVTIGxvbmcgdGVybSBzaWduYXR1cmUgZm9ybWF0PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLmNtc30gLSBDcnlwdG9ncmFwaGljIE1lc3NhZ2UgU3ludGF4PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLmNzcn0gLSBDZXJ0aWZpY2F0ZSBTaWduaW5nIFJlcXVlc3QgKENTUi9QS0NTIzEwKTwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS50c3B9IC0gUkZDIDMxNjEgVGltZXN0YW1waW5nIFByb3RvY29sIEZvcm1hdDwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS54NTA5fSAtIFJGQyA1MjgwIFguNTA5IGNlcnRpZmljYXRlIGFuZCBDUkw8L2xpPlxuICogPC91bD5cbiAqIDwvcD5cbiAqIE5PVEU6IFBsZWFzZSBpZ25vcmUgbWV0aG9kIHN1bW1hcnkgYW5kIGRvY3VtZW50IG9mIHRoaXMgbmFtZXNwYWNlLlxuICogVGhpcyBjYXVzZWQgYnkgYSBidWcgb2YganNkb2MyLlxuICogQG5hbWUgS0pVUi5hc24xXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmlmICh0eXBlb2YgS0pVUi5hc24xID09IFwidW5kZWZpbmVkXCIgfHwgIUtKVVIuYXNuMSkgS0pVUi5hc24xID0ge307XG5cbi8qKlxuICogQVNOMSB1dGlsaXRpZXMgY2xhc3NcbiAqIEBuYW1lIEtKVVIuYXNuMS5BU04xVXRpbFxuICogQGNsYXNzIEFTTjEgdXRpbGl0aWVzIGNsYXNzXG4gKiBAc2luY2UgYXNuMSAxLjAuMlxuICovXG5LSlVSLmFzbjEuQVNOMVV0aWwgPSBuZXcgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbnRlZ2VyVG9CeXRlSGV4ID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgaCA9IGkudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoKGgubGVuZ3RoICUgMikgPT0gMSkgaCA9ICcwJyArIGg7XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgdGhpcy5iaWdJbnRUb01pblR3b3NDb21wbGVtZW50c0hleCA9IGZ1bmN0aW9uKGJpZ0ludGVnZXJWYWx1ZSkge1xuICAgICAgICB2YXIgaCA9IGJpZ0ludGVnZXJWYWx1ZS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoLnN1YnN0cigwLCAxKSAhPSAnLScpIHtcbiAgICAgICAgICAgIGlmIChoLmxlbmd0aCAlIDIgPT0gMSkge1xuICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISBoLm1hdGNoKC9eWzAtN10vKSkge1xuICAgICAgICAgICAgICAgICAgICBoID0gJzAwJyArIGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhQb3MgPSBoLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHZhciB4b3JMZW4gPSBoUG9zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh4b3JMZW4gJSAyID09IDEpIHtcbiAgICAgICAgICAgICAgICB4b3JMZW4gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEgaC5tYXRjaCgvXlswLTddLykpIHtcbiAgICAgICAgICAgICAgICAgICAgeG9yTGVuICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhNYXNrID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhvckxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaE1hc2sgKz0gJ2YnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJpTWFzayA9IG5ldyBCaWdJbnRlZ2VyKGhNYXNrLCAxNik7XG4gICAgICAgICAgICB2YXIgYmlOZWcgPSBiaU1hc2sueG9yKGJpZ0ludGVnZXJWYWx1ZSkuYWRkKEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgICAgIGggPSBiaU5lZy50b1N0cmluZygxNikucmVwbGFjZSgvXi0vLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXQgUEVNIHN0cmluZyBmcm9tIGhleGFkZWNpbWFsIGRhdGEgYW5kIGhlYWRlciBzdHJpbmdcbiAgICAgKiBAbmFtZSBnZXRQRU1TdHJpbmdGcm9tSGV4XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xVXRpbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhSGV4IGhleGFkZWNpbWFsIHN0cmluZyBvZiBQRU0gYm9keVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwZW1IZWFkZXIgUEVNIGhlYWRlciBzdHJpbmcgKGV4LiAnUlNBIFBSSVZBVEUgS0VZJylcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFBFTSBmb3JtYXR0ZWQgc3RyaW5nIG9mIGlucHV0IGRhdGFcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGlzIG1ldGhvZCBjb252ZXJ0cyBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIFBFTSBzdHJpbmcgd2l0aFxuICAgICAqIGEgc3BlY2lmaWVkIGhlYWRlci4gSXRzIGxpbmUgYnJlYWsgd2lsbCBiZSBDUkxGKFwiXFxyXFxuXCIpLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBlbSAgPSBLSlVSLmFzbjEuQVNOMVV0aWwuZ2V0UEVNU3RyaW5nRnJvbUhleCgnNjE2MTYxJywgJ1JTQSBQUklWQVRFIEtFWScpO1xuICAgICAqIC8vIHZhbHVlIG9mIHBlbSB3aWxsIGJlOlxuICAgICAqIC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxuICAgICAqIFlXRmhcbiAgICAgKiAtLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tXG4gICAgICovXG4gICAgdGhpcy5nZXRQRU1TdHJpbmdGcm9tSGV4ID0gZnVuY3Rpb24oZGF0YUhleCwgcGVtSGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXh0b3BlbShkYXRhSGV4LCBwZW1IZWFkZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBBU04xT2JqZWN0IHNwZWNpZmVkIGJ5IEpTT04gcGFyYW1ldGVyc1xuICAgICAqIEBuYW1lIG5ld09iamVjdFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbSBKU09OIHBhcmFtZXRlciB0byBnZW5lcmF0ZSBBU04xT2JqZWN0XG4gICAgICogQHJldHVybiB7S0pVUi5hc24xLkFTTjFPYmplY3R9IGdlbmVyYXRlZCBvYmplY3RcbiAgICAgKiBAc2luY2UgYXNuMSAxLjAuM1xuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIGdlbmVyYXRlIGFueSBBU04xT2JqZWN0IHNwZWNpZmllZCBieSBKU09OIHBhcmFtXG4gICAgICogaW5jbHVkaW5nIEFTTi4xIHByaW1pdGl2ZSBvciBzdHJ1Y3R1cmVkLlxuICAgICAqIEdlbmVyYWxseSAncGFyYW0nIGNhbiBiZSBkZXNjcmliZWQgYXMgZm9sbG93czpcbiAgICAgKiA8YmxvY2txdW90ZT5cbiAgICAgKiB7VFlQRS1PRi1BU05PQko6IEFTTjFPQkotUEFSQU1FVEVSfVxuICAgICAqIDwvYmxvY2txdW90ZT5cbiAgICAgKiAnVFlQRS1PRi1BU04xT0JKJyBjYW4gYmUgb25lIG9mIGZvbGxvd2luZyBzeW1ib2xzOlxuICAgICAqIDx1bD5cbiAgICAgKiA8bGk+J2Jvb2wnIC0gREVSQm9vbGVhbjwvbGk+XG4gICAgICogPGxpPidpbnQnIC0gREVSSW50ZWdlcjwvbGk+XG4gICAgICogPGxpPidiaXRzdHInIC0gREVSQml0U3RyaW5nPC9saT5cbiAgICAgKiA8bGk+J29jdHN0cicgLSBERVJPY3RldFN0cmluZzwvbGk+XG4gICAgICogPGxpPidudWxsJyAtIERFUk51bGw8L2xpPlxuICAgICAqIDxsaT4nb2lkJyAtIERFUk9iamVjdElkZW50aWZpZXI8L2xpPlxuICAgICAqIDxsaT4nZW51bScgLSBERVJFbnVtZXJhdGVkPC9saT5cbiAgICAgKiA8bGk+J3V0ZjhzdHInIC0gREVSVVRGOFN0cmluZzwvbGk+XG4gICAgICogPGxpPidudW1zdHInIC0gREVSTnVtZXJpY1N0cmluZzwvbGk+XG4gICAgICogPGxpPidwcm5zdHInIC0gREVSUHJpbnRhYmxlU3RyaW5nPC9saT5cbiAgICAgKiA8bGk+J3RlbHN0cicgLSBERVJUZWxldGV4U3RyaW5nPC9saT5cbiAgICAgKiA8bGk+J2lhNXN0cicgLSBERVJJQTVTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4ndXRjdGltZScgLSBERVJVVENUaW1lPC9saT5cbiAgICAgKiA8bGk+J2dlbnRpbWUnIC0gREVSR2VuZXJhbGl6ZWRUaW1lPC9saT5cbiAgICAgKiA8bGk+J3NlcScgLSBERVJTZXF1ZW5jZTwvbGk+XG4gICAgICogPGxpPidzZXQnIC0gREVSU2V0PC9saT5cbiAgICAgKiA8bGk+J3RhZycgLSBERVJUYWdnZWRPYmplY3Q8L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBuZXdPYmplY3Qoeydwcm5zdHInOiAnYWFhJ30pO1xuICAgICAqIG5ld09iamVjdCh7J3NlcSc6IFt7J2ludCc6IDN9LCB7J3BybnN0cic6ICdhYWEnfV19KVxuICAgICAqIC8vIEFTTi4xIFRhZ2dlZCBPYmplY3RcbiAgICAgKiBuZXdPYmplY3Qoeyd0YWcnOiB7J3RhZyc6ICdhMScsXG4gICAgICogICAgICAgICAgICAgICAgICAgICdleHBsaWNpdCc6IHRydWUsXG4gICAgICogICAgICAgICAgICAgICAgICAgICdvYmonOiB7J3NlcSc6IFt7J2ludCc6IDN9LCB7J3BybnN0cic6ICdhYWEnfV19fX0pO1xuICAgICAqIC8vIG1vcmUgc2ltcGxlIHJlcHJlc2VudGF0aW9uIG9mIEFTTi4xIFRhZ2dlZCBPYmplY3RcbiAgICAgKiBuZXdPYmplY3Qoeyd0YWcnOiBbJ2ExJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgeydzZXEnOiBbXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgeydpbnQnOiAzfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICB7J3BybnN0cic6ICdhYWEnfV19XG4gICAgICogICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAqL1xuICAgIHRoaXMubmV3T2JqZWN0ID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgdmFyIF9LSlVSID0gS0pVUixcbiAgICAgICAgICAgIF9LSlVSX2FzbjEgPSBfS0pVUi5hc24xLFxuICAgICAgICAgICAgX0RFUkJvb2xlYW4gPSBfS0pVUl9hc24xLkRFUkJvb2xlYW4sXG4gICAgICAgICAgICBfREVSSW50ZWdlciA9IF9LSlVSX2FzbjEuREVSSW50ZWdlcixcbiAgICAgICAgICAgIF9ERVJCaXRTdHJpbmcgPSBfS0pVUl9hc24xLkRFUkJpdFN0cmluZyxcbiAgICAgICAgICAgIF9ERVJPY3RldFN0cmluZyA9IF9LSlVSX2FzbjEuREVST2N0ZXRTdHJpbmcsXG4gICAgICAgICAgICBfREVSTnVsbCA9IF9LSlVSX2FzbjEuREVSTnVsbCxcbiAgICAgICAgICAgIF9ERVJPYmplY3RJZGVudGlmaWVyID0gX0tKVVJfYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyLFxuICAgICAgICAgICAgX0RFUkVudW1lcmF0ZWQgPSBfS0pVUl9hc24xLkRFUkVudW1lcmF0ZWQsXG4gICAgICAgICAgICBfREVSVVRGOFN0cmluZyA9IF9LSlVSX2FzbjEuREVSVVRGOFN0cmluZyxcbiAgICAgICAgICAgIF9ERVJOdW1lcmljU3RyaW5nID0gX0tKVVJfYXNuMS5ERVJOdW1lcmljU3RyaW5nLFxuICAgICAgICAgICAgX0RFUlByaW50YWJsZVN0cmluZyA9IF9LSlVSX2FzbjEuREVSUHJpbnRhYmxlU3RyaW5nLFxuICAgICAgICAgICAgX0RFUlRlbGV0ZXhTdHJpbmcgPSBfS0pVUl9hc24xLkRFUlRlbGV0ZXhTdHJpbmcsXG4gICAgICAgICAgICBfREVSSUE1U3RyaW5nID0gX0tKVVJfYXNuMS5ERVJJQTVTdHJpbmcsXG4gICAgICAgICAgICBfREVSVVRDVGltZSA9IF9LSlVSX2FzbjEuREVSVVRDVGltZSxcbiAgICAgICAgICAgIF9ERVJHZW5lcmFsaXplZFRpbWUgPSBfS0pVUl9hc24xLkRFUkdlbmVyYWxpemVkVGltZSxcbiAgICAgICAgICAgIF9ERVJTZXF1ZW5jZSA9IF9LSlVSX2FzbjEuREVSU2VxdWVuY2UsXG4gICAgICAgICAgICBfREVSU2V0ID0gX0tKVVJfYXNuMS5ERVJTZXQsXG4gICAgICAgICAgICBfREVSVGFnZ2VkT2JqZWN0ID0gX0tKVVJfYXNuMS5ERVJUYWdnZWRPYmplY3QsXG4gICAgICAgICAgICBfbmV3T2JqZWN0ID0gX0tKVVJfYXNuMS5BU04xVXRpbC5uZXdPYmplY3Q7XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJhbSk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPSAxKVxuICAgICAgICAgICAgdGhyb3cgXCJrZXkgb2YgcGFyYW0gc2hhbGwgYmUgb25seSBvbmUuXCI7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzWzBdO1xuXG4gICAgICAgIGlmIChcIjpib29sOmludDpiaXRzdHI6b2N0c3RyOm51bGw6b2lkOmVudW06dXRmOHN0cjpudW1zdHI6cHJuc3RyOnRlbHN0cjppYTVzdHI6dXRjdGltZTpnZW50aW1lOnNlcTpzZXQ6dGFnOlwiLmluZGV4T2YoXCI6XCIgKyBrZXkgKyBcIjpcIikgPT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBcInVuZGVmaW5lZCBrZXk6IFwiICsga2V5O1xuXG4gICAgICAgIGlmIChrZXkgPT0gXCJib29sXCIpICAgIHJldHVybiBuZXcgX0RFUkJvb2xlYW4ocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJpbnRcIikgICAgIHJldHVybiBuZXcgX0RFUkludGVnZXIocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJiaXRzdHJcIikgIHJldHVybiBuZXcgX0RFUkJpdFN0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcIm9jdHN0clwiKSAgcmV0dXJuIG5ldyBfREVST2N0ZXRTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJudWxsXCIpICAgIHJldHVybiBuZXcgX0RFUk51bGwocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJvaWRcIikgICAgIHJldHVybiBuZXcgX0RFUk9iamVjdElkZW50aWZpZXIocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJlbnVtXCIpICAgIHJldHVybiBuZXcgX0RFUkVudW1lcmF0ZWQocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJ1dGY4c3RyXCIpIHJldHVybiBuZXcgX0RFUlVURjhTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJudW1zdHJcIikgIHJldHVybiBuZXcgX0RFUk51bWVyaWNTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJwcm5zdHJcIikgIHJldHVybiBuZXcgX0RFUlByaW50YWJsZVN0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcInRlbHN0clwiKSAgcmV0dXJuIG5ldyBfREVSVGVsZXRleFN0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcImlhNXN0clwiKSAgcmV0dXJuIG5ldyBfREVSSUE1U3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwidXRjdGltZVwiKSByZXR1cm4gbmV3IF9ERVJVVENUaW1lKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiZ2VudGltZVwiKSByZXR1cm4gbmV3IF9ERVJHZW5lcmFsaXplZFRpbWUocGFyYW1ba2V5XSk7XG5cbiAgICAgICAgaWYgKGtleSA9PSBcInNlcVwiKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1MaXN0ID0gcGFyYW1ba2V5XTtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhc24xT2JqID0gX25ld09iamVjdChwYXJhbUxpc3RbaV0pO1xuICAgICAgICAgICAgICAgIGEucHVzaChhc24xT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgX0RFUlNlcXVlbmNlKHsnYXJyYXknOiBhfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbUxpc3QgPSBwYXJhbVtrZXldO1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFzbjFPYmogPSBfbmV3T2JqZWN0KHBhcmFtTGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGFzbjFPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSU2V0KHsnYXJyYXknOiBhfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ID09IFwidGFnXCIpIHtcbiAgICAgICAgICAgIHZhciB0YWdQYXJhbSA9IHBhcmFtW2tleV07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhZ1BhcmFtKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuICAgICAgICAgICAgICAgIHRhZ1BhcmFtLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IF9uZXdPYmplY3QodGFnUGFyYW1bMl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0RFUlRhZ2dlZE9iamVjdCh7dGFnOiB0YWdQYXJhbVswXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwbGljaXQ6IHRhZ1BhcmFtWzFdLFxuICAgICAgICAgICAgICAgICAgICBvYmo6IG9ian0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGFyYW0gPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAodGFnUGFyYW0uZXhwbGljaXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW0uZXhwbGljaXQgPSB0YWdQYXJhbS5leHBsaWNpdDtcbiAgICAgICAgICAgICAgICBpZiAodGFnUGFyYW0udGFnICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtLnRhZyA9IHRhZ1BhcmFtLnRhZztcbiAgICAgICAgICAgICAgICBpZiAodGFnUGFyYW0ub2JqID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwib2JqIHNoYWxsIGJlIHNwZWNpZmllZCBmb3IgJ3RhZycuXCI7XG4gICAgICAgICAgICAgICAgbmV3UGFyYW0ub2JqID0gX25ld09iamVjdCh0YWdQYXJhbS5vYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0RFUlRhZ2dlZE9iamVjdChuZXdQYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGVuY29kZWQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTjFPYmplY3Qgc3BlY2lmZWQgYnkgSlNPTiBwYXJhbWV0ZXJzXG4gICAgICogQG5hbWUganNvblRvQVNOMUhFWFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbSBKU09OIHBhcmFtZXRlciB0byBnZW5lcmF0ZSBBU04xT2JqZWN0XG4gICAgICogQHJldHVybiBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOMU9iamVjdFxuICAgICAqIEBzaW5jZSBhc24xIDEuMC40XG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQXMgZm9yIEFTTi4xIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBKU09OIG9iamVjdCxcbiAgICAgKiBwbGVhc2Ugc2VlIHtAbGluayBuZXdPYmplY3R9LlxuICAgICAqIEBleGFtcGxlXG4gICAgICoganNvblRvQVNOMUhFWCh7J3BybnN0cic6ICdhYWEnfSk7XG4gICAgICovXG4gICAgdGhpcy5qc29uVG9BU04xSEVYID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgdmFyIGFzbjFPYmogPSB0aGlzLm5ld09iamVjdChwYXJhbSk7XG4gICAgICAgIHJldHVybiBhc24xT2JqLmdldEVuY29kZWRIZXgoKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBnZXQgZG90IG5vdGVkIG9pZCBudW1iZXIgc3RyaW5nIGZyb20gaGV4YWRlY2ltYWwgdmFsdWUgb2YgT0lEXG4gKiBAbmFtZSBvaWRIZXhUb0ludFxuICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xVXRpbFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IGhleGFkZWNpbWFsIHZhbHVlIG9mIG9iamVjdCBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGRvdCBub3RlZCBzdHJpbmcgb2Ygb2JqZWN0IGlkZW50aWZpZXJcbiAqIEBzaW5jZSBqc3JzYXNpZ24gNC44LjMgYXNuMSAxLjAuN1xuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHN0YXRpYyBtZXRob2QgY29udmVydHMgZnJvbSBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2ZcbiAqIEFTTi4xIHZhbHVlIG9mIG9iamVjdCBpZGVudGlmaWVyIHRvIG9pZCBudW1iZXIgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqIEtKVVIuYXNuMS5BU04xVXRpbC5vaWRIZXhUb0ludCgnNTUwNDA2JykgJnJhcnI7IFwiMi41LjQuNlwiXG4gKi9cbktKVVIuYXNuMS5BU04xVXRpbC5vaWRIZXhUb0ludCA9IGZ1bmN0aW9uKGhleCkge1xuICAgIHZhciBzID0gXCJcIjtcbiAgICB2YXIgaTAxID0gcGFyc2VJbnQoaGV4LnN1YnN0cigwLCAyKSwgMTYpO1xuICAgIHZhciBpMCA9IE1hdGguZmxvb3IoaTAxIC8gNDApO1xuICAgIHZhciBpMSA9IGkwMSAlIDQwO1xuICAgIHZhciBzID0gaTAgKyBcIi5cIiArIGkxO1xuXG4gICAgdmFyIGJpbmJ1ZiA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgICAgICB2YXIgYmluID0gKFwiMDAwMDAwMDBcIiArIHZhbHVlLnRvU3RyaW5nKDIpKS5zbGljZSgtIDgpO1xuICAgICAgICBiaW5idWYgPSBiaW5idWYgKyBiaW4uc3Vic3RyKDEsIDcpO1xuICAgICAgICBpZiAoYmluLnN1YnN0cigwLCAxKSA9PSBcIjBcIikge1xuICAgICAgICAgICAgdmFyIGJpID0gbmV3IEJpZ0ludGVnZXIoYmluYnVmLCAyKTtcbiAgICAgICAgICAgIHMgPSBzICsgXCIuXCIgKyBiaS50b1N0cmluZygxMCk7XG4gICAgICAgICAgICBiaW5idWYgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBnZXQgaGV4YWRlY2ltYWwgdmFsdWUgb2Ygb2JqZWN0IGlkZW50aWZpZXIgZnJvbSBkb3Qgbm90ZWQgb2lkIHZhbHVlXG4gKiBAbmFtZSBvaWRJbnRUb0hleFxuICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xVXRpbFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gb2lkU3RyaW5nIGRvdCBub3RlZCBzdHJpbmcgb2Ygb2JqZWN0IGlkZW50aWZpZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gaGV4YWRlY2ltYWwgdmFsdWUgb2Ygb2JqZWN0IGlkZW50aWZpZXJcbiAqIEBzaW5jZSBqc3JzYXNpZ24gNC44LjMgYXNuMSAxLjAuN1xuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHN0YXRpYyBtZXRob2QgY29udmVydHMgZnJvbSBvYmplY3QgaWRlbnRpZmllciB2YWx1ZSBzdHJpbmcuXG4gKiB0byBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaXQuXG4gKiBAZXhhbXBsZVxuICogS0pVUi5hc24xLkFTTjFVdGlsLm9pZEludFRvSGV4KFwiMi41LjQuNlwiKSAmcmFycjsgXCI1NTA0MDZcIlxuICovXG5LSlVSLmFzbjEuQVNOMVV0aWwub2lkSW50VG9IZXggPSBmdW5jdGlvbihvaWRTdHJpbmcpIHtcbiAgICB2YXIgaXRveCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIGggPSBpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGgubGVuZ3RoID09IDEpIGggPSAnMCcgKyBoO1xuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuXG4gICAgdmFyIHJvaWR0b3ggPSBmdW5jdGlvbihyb2lkKSB7XG4gICAgICAgIHZhciBoID0gJyc7XG4gICAgICAgIHZhciBiaSA9IG5ldyBCaWdJbnRlZ2VyKHJvaWQsIDEwKTtcbiAgICAgICAgdmFyIGIgPSBiaS50b1N0cmluZygyKTtcbiAgICAgICAgdmFyIHBhZExlbiA9IDcgLSBiLmxlbmd0aCAlIDc7XG4gICAgICAgIGlmIChwYWRMZW4gPT0gNykgcGFkTGVuID0gMDtcbiAgICAgICAgdmFyIGJQYWQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW47IGkrKykgYlBhZCArPSAnMCc7XG4gICAgICAgIGIgPSBiUGFkICsgYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aCAtIDE7IGkgKz0gNykge1xuICAgICAgICAgICAgdmFyIGI4ID0gYi5zdWJzdHIoaSwgNyk7XG4gICAgICAgICAgICBpZiAoaSAhPSBiLmxlbmd0aCAtIDcpIGI4ID0gJzEnICsgYjg7XG4gICAgICAgICAgICBoICs9IGl0b3gocGFyc2VJbnQoYjgsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuXG4gICAgaWYgKCEgb2lkU3RyaW5nLm1hdGNoKC9eWzAtOS5dKyQvKSkge1xuICAgICAgICB0aHJvdyBcIm1hbGZvcm1lZCBvaWQgc3RyaW5nOiBcIiArIG9pZFN0cmluZztcbiAgICB9XG4gICAgdmFyIGggPSAnJztcbiAgICB2YXIgYSA9IG9pZFN0cmluZy5zcGxpdCgnLicpO1xuICAgIHZhciBpMCA9IHBhcnNlSW50KGFbMF0pICogNDAgKyBwYXJzZUludChhWzFdKTtcbiAgICBoICs9IGl0b3goaTApO1xuICAgIGEuc3BsaWNlKDAsIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoICs9IHJvaWR0b3goYVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBoO1xufTtcblxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gIEFic3RyYWN0IEFTTi4xIENsYXNzZXNcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbi8qKlxuICogYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIGVuY29kZXIgb2JqZWN0XG4gKiBAbmFtZSBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBlbmNvZGVyIG9iamVjdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBpc01vZGlmaWVkIGZsYWcgd2hldGhlciBpbnRlcm5hbCBkYXRhIHdhcyBjaGFuZ2VkXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaFRMViBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaFQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViB0YWcoVClcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBoTCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIGxlbmd0aChMKVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGhWIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgdmFsdWUoVilcbiAqIEBkZXNjcmlwdGlvblxuICovXG5LSlVSLmFzbjEuQVNOMU9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoViA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGhleGFkZWNpbWFsIEFTTi4xIFRMViBsZW5ndGgoTCkgYnl0ZXMgZnJvbSBUTFYgdmFsdWUoVilcbiAgICAgKiBAbmFtZSBnZXRMZW5ndGhIZXhGcm9tVmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFPYmplY3QjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIGxlbmd0aChMKVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TGVuZ3RoSGV4RnJvbVZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5oViA9PSBcInVuZGVmaW5lZFwiIHx8IHRoaXMuaFYgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgXCJ0aGlzLmhWIGlzIG51bGwgb3IgdW5kZWZpbmVkLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhWLmxlbmd0aCAlIDIgPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgXCJ2YWx1ZSBoZXggbXVzdCBiZSBldmVuIGxlbmd0aDogbj1cIiArIGhWLmxlbmd0aCArIFwiLHY9XCIgKyB0aGlzLmhWO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gdGhpcy5oVi5sZW5ndGggLyAyO1xuICAgICAgICB2YXIgaE4gPSBuLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGhOLmxlbmd0aCAlIDIgPT0gMSkge1xuICAgICAgICAgICAgaE4gPSBcIjBcIiArIGhOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDwgMTI4KSB7XG4gICAgICAgICAgICByZXR1cm4gaE47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaE5sZW4gPSBoTi5sZW5ndGggLyAyO1xuICAgICAgICAgICAgaWYgKGhObGVuID4gMTUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkFTTi4xIGxlbmd0aCB0b28gbG9uZyB0byByZXByZXNlbnQgYnkgOHg6IG4gPSBcIiArIG4udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlYWQgPSAxMjggKyBoTmxlbjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkLnRvU3RyaW5nKDE2KSArIGhOO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdldCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIGJ5dGVzXG4gICAgICogQG5hbWUgZ2V0RW5jb2RlZEhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMU9iamVjdCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFZcbiAgICAgKi9cbiAgICB0aGlzLmdldEVuY29kZWRIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaFRMViA9PSBudWxsIHx8IHRoaXMuaXNNb2RpZmllZCkge1xuICAgICAgICAgICAgdGhpcy5oViA9IHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCgpO1xuICAgICAgICAgICAgdGhpcy5oTCA9IHRoaXMuZ2V0TGVuZ3RoSGV4RnJvbVZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLmhUTFYgPSB0aGlzLmhUICsgdGhpcy5oTCArIHRoaXMuaFY7XG4gICAgICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vYWxlcnQoXCJmaXJzdCB0aW1lOiBcIiArIHRoaXMuaFRMVik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaFRMVjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgdmFsdWUoVikgYnl0ZXNcbiAgICAgKiBAbmFtZSBnZXRWYWx1ZUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMU9iamVjdCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgdmFsdWUoVikgYnl0ZXNcbiAgICAgKi9cbiAgICB0aGlzLmdldFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xufTtcblxuLy8gPT0gQkVHSU4gREVSQWJzdHJhY3RTdHJpbmcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKipcbiAqIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBzdHJpbmcgY2xhc3Nlc1xuICogQG5hbWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAY2xhc3MgYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIHN0cmluZyBjbGFzc2VzXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHMgaW50ZXJuYWwgc3RyaW5nIG9mIHZhbHVlXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+c3RyIC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgc3RyaW5nPC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPC91bD5cbiAqIE5PVEU6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5LSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0IHN0cmluZyB2YWx1ZSBvZiB0aGlzIHN0cmluZyBvYmplY3RcbiAgICAgKiBAbmFtZSBnZXRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHZhbHVlIG9mIHRoaXMgc3RyaW5nIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMuZ2V0U3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIHN0cmluZ1xuICAgICAqIEBuYW1lIHNldFN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1MgdmFsdWUgYnkgYSBzdHJpbmcgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRTdHJpbmcgPSBmdW5jdGlvbihuZXdTKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMucyA9IG5ld1M7XG4gICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nXG4gICAgICogQG5hbWUgc2V0U3RyaW5nSGV4XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3SGV4U3RyaW5nIHZhbHVlIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0U3RyaW5nSGV4ID0gZnVuY3Rpb24obmV3SGV4U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMucyA9IG51bGw7XG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmc7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ3N0ciddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtc1snc3RyJ10pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2hleCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nSGV4KHBhcmFtc1snaGV4J10pO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZywgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuLy8gPT0gRU5EICAgREVSQWJzdHJhY3RTdHJpbmcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vID09IEJFR0lOIERFUkFic3RyYWN0VGltZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgR2VuZXJhbGl6ZWQvVVRDVGltZSBjbGFzc1xuICogQG5hbWUgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZVxuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBHZW5lcmFsaXplZC9VVENUaW1lIGNsYXNzXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJzEzMDQzMDIzNTk1OVonfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcblxuICAgIC8vIC0tLSBQUklWQVRFIE1FVEhPRFMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLmxvY2FsRGF0ZVRvVVRDID0gZnVuY3Rpb24oZCkge1xuICAgICAgICB1dGMgPSBkLmdldFRpbWUoKSArIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCk7XG4gICAgICAgIHZhciB1dGNEYXRlID0gbmV3IERhdGUodXRjKTtcbiAgICAgICAgcmV0dXJuIHV0Y0RhdGU7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogZm9ybWF0IGRhdGUgc3RyaW5nIGJ5IERhdGEgb2JqZWN0XG4gICAgICogQG5hbWUgZm9ybWF0RGF0ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQWJzdHJhY3RUaW1lO1xuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZU9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICd1dGMnIG9yICdnZW4nXG4gICAgICogQHBhcmFtIHtib29sZWFufSB3aXRoTWlsbGlzIGZsYWcgZm9yIHdpdGggbWlsbGlzZWN0aW9ucyBvciBub3RcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAnd2l0aE1pbGxpcycgZmxhZyBpcyBzdXBwb3J0ZWQgZnJvbSBhc24xIDEuMC42LlxuICAgICAqL1xuICAgIHRoaXMuZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uKGRhdGVPYmplY3QsIHR5cGUsIHdpdGhNaWxsaXMpIHtcbiAgICAgICAgdmFyIHBhZCA9IHRoaXMuemVyb1BhZGRpbmc7XG4gICAgICAgIHZhciBkID0gdGhpcy5sb2NhbERhdGVUb1VUQyhkYXRlT2JqZWN0KTtcbiAgICAgICAgdmFyIHllYXIgPSBTdHJpbmcoZC5nZXRGdWxsWWVhcigpKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ3V0YycpIHllYXIgPSB5ZWFyLnN1YnN0cigyLCAyKTtcbiAgICAgICAgdmFyIG1vbnRoID0gcGFkKFN0cmluZyhkLmdldE1vbnRoKCkgKyAxKSwgMik7XG4gICAgICAgIHZhciBkYXkgPSBwYWQoU3RyaW5nKGQuZ2V0RGF0ZSgpKSwgMik7XG4gICAgICAgIHZhciBob3VyID0gcGFkKFN0cmluZyhkLmdldEhvdXJzKCkpLCAyKTtcbiAgICAgICAgdmFyIG1pbiA9IHBhZChTdHJpbmcoZC5nZXRNaW51dGVzKCkpLCAyKTtcbiAgICAgICAgdmFyIHNlYyA9IHBhZChTdHJpbmcoZC5nZXRTZWNvbmRzKCkpLCAyKTtcbiAgICAgICAgdmFyIHMgPSB5ZWFyICsgbW9udGggKyBkYXkgKyBob3VyICsgbWluICsgc2VjO1xuICAgICAgICBpZiAod2l0aE1pbGxpcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICBpZiAobWlsbGlzICE9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc01pbGxpcyA9IHBhZChTdHJpbmcobWlsbGlzKSwgMyk7XG4gICAgICAgICAgICAgICAgc01pbGxpcyA9IHNNaWxsaXMucmVwbGFjZSgvWzBdKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBzID0gcyArIFwiLlwiICsgc01pbGxpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcyArIFwiWlwiO1xuICAgIH07XG5cbiAgICB0aGlzLnplcm9QYWRkaW5nID0gZnVuY3Rpb24ocywgbGVuKSB7XG4gICAgICAgIGlmIChzLmxlbmd0aCA+PSBsZW4pIHJldHVybiBzO1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KGxlbiAtIHMubGVuZ3RoICsgMSkuam9pbignMCcpICsgcztcbiAgICB9O1xuXG4gICAgLy8gLS0tIFBVQkxJQyBNRVRIT0RTIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqXG4gICAgICogZ2V0IHN0cmluZyB2YWx1ZSBvZiB0aGlzIHN0cmluZyBvYmplY3RcbiAgICAgKiBAbmFtZSBnZXRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyB2YWx1ZSBvZiB0aGlzIHRpbWUgb2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5nZXRTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgc3RyaW5nXG4gICAgICogQG5hbWUgc2V0U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1MgdmFsdWUgYnkgYSBzdHJpbmcgdG8gc2V0IHN1Y2ggbGlrZSBcIjEzMDQzMDIzNTk1OVpcIlxuICAgICAqL1xuICAgIHRoaXMuc2V0U3RyaW5nID0gZnVuY3Rpb24obmV3Uykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBuZXdTO1xuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KG5ld1MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBEYXRlIG9iamVjdFxuICAgICAqIEBuYW1lIHNldEJ5RGF0ZVZhbHVlXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB5ZWFyIHllYXIgb2YgZGF0ZSAoZXguIDIwMTMpXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBtb250aCBtb250aCBvZiBkYXRlIGJldHdlZW4gMSBhbmQgMTIgKGV4LiAxMilcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGRheSBkYXkgb2YgbW9udGhcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGhvdXIgaG91cnMgb2YgZGF0ZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbWluIG1pbnV0ZXMgb2YgZGF0ZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gc2VjIHNlY29uZHMgb2YgZGF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlEYXRlVmFsdWUgPSBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYykge1xuICAgICAgICB2YXIgZGF0ZU9iamVjdCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyLCBtaW4sIHNlYywgMCkpO1xuICAgICAgICB0aGlzLnNldEJ5RGF0ZShkYXRlT2JqZWN0KTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuLy8gPT0gRU5EICAgREVSQWJzdHJhY3RUaW1lID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vID09IEJFR0lOIERFUkFic3RyYWN0U3RydWN0dXJlZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgc3RydWN0dXJlZCBjbGFzc1xuICogQG5hbWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZFxuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmVkIGNsYXNzXG4gKiBAcHJvcGVydHkge0FycmF5fSBhc24xQXJyYXkgaW50ZXJuYWwgYXJyYXkgb2YgQVNOMU9iamVjdFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuQVNOMU9iamVjdCAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYXJyYXkgb2YgQVNOMU9iamVjdFxuICAgICAqIEBuYW1lIHNldEJ5QVNOMU9iamVjdEFycmF5XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHthcnJheX0gYXNuMU9iamVjdEFycmF5IGFycmF5IG9mIEFTTjFPYmplY3QgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUFTTjFPYmplY3RBcnJheSA9IGZ1bmN0aW9uKGFzbjFPYmplY3RBcnJheSkge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFzbjFBcnJheSA9IGFzbjFPYmplY3RBcnJheTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGFuIEFTTjFPYmplY3QgdG8gaW50ZXJuYWwgYXJyYXlcbiAgICAgKiBAbmFtZSBhcHBlbmRBU04xT2JqZWN0XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBU04xT2JqZWN0fSBhc24xT2JqZWN0IHRvIGFkZFxuICAgICAqL1xuICAgIHRoaXMuYXBwZW5kQVNOMU9iamVjdCA9IGZ1bmN0aW9uKGFzbjFPYmplY3QpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hc24xQXJyYXkucHVzaChhc24xT2JqZWN0KTtcbiAgICB9O1xuXG4gICAgdGhpcy5hc24xQXJyYXkgPSBuZXcgQXJyYXkoKTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydhcnJheSddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXNuMUFycmF5ID0gcGFyYW1zWydhcnJheSddO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcblxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gIEFTTi4xIE9iamVjdCBDbGFzc2VzXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIEJvb2xlYW5cbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJCb29sZWFuXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBCb29sZWFuXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5BU04xT2JqZWN0IC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSQm9vbGVhbiA9IGZ1bmN0aW9uKCkge1xuICAgIEtKVVIuYXNuMS5ERVJCb29sZWFuLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwMVwiO1xuICAgIHRoaXMuaFRMViA9IFwiMDEwMWZmXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkJvb2xlYW4sIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBJbnRlZ2VyXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSSW50ZWdlclxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgSW50ZWdlclxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPmludCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBpbnRlZ2VyIHZhbHVlPC9saT5cbiAqIDxsaT5iaWdpbnQgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgQmlnSW50ZWdlciBvYmplY3Q8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbktKVVIuYXNuMS5ERVJJbnRlZ2VyID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkludGVnZXIuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcIjAyXCI7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgVG9tIFd1J3MgQmlnSW50ZWdlciBvYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeUJpZ0ludGVnZXJcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkludGVnZXIjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCaWdJbnRlZ2VyfSBiaWdJbnRlZ2VyVmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUJpZ0ludGVnZXIgPSBmdW5jdGlvbihiaWdJbnRlZ2VyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oViA9IEtKVVIuYXNuMS5BU04xVXRpbC5iaWdJbnRUb01pblR3b3NDb21wbGVtZW50c0hleChiaWdJbnRlZ2VyVmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBuYW1lIHNldEJ5SW50ZWdlclxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSSW50ZWdlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaW50ZWdlciB2YWx1ZSB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5SW50ZWdlciA9IGZ1bmN0aW9uKGludFZhbHVlKSB7XG4gICAgICAgIHZhciBiaSA9IG5ldyBCaWdJbnRlZ2VyKFN0cmluZyhpbnRWYWx1ZSksIDEwKTtcbiAgICAgICAgdGhpcy5zZXRCeUJpZ0ludGVnZXIoYmkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBuYW1lIHNldFZhbHVlSGV4XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJJbnRlZ2VyI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIDxici8+XG4gICAgICogTk9URTogVmFsdWUgc2hhbGwgYmUgcmVwcmVzZW50ZWQgYnkgbWluaW11bSBvY3RldCBsZW5ndGggb2ZcbiAgICAgKiB0d28ncyBjb21wbGVtZW50IHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKDEyMyk7XG4gICAgICogbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsnaW50JzogMTIzfSk7XG4gICAgICogbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsnaGV4JzogJzFmYWQnfSk7XG4gICAgICovXG4gICAgdGhpcy5zZXRWYWx1ZUhleCA9IGZ1bmN0aW9uKG5ld0hleFN0cmluZykge1xuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ2JpZ2ludCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyKHBhcmFtc1snYmlnaW50J10pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2ludCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlJbnRlZ2VyKHBhcmFtc1snaW50J10pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUludGVnZXIocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydoZXgnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KHBhcmFtc1snaGV4J10pO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJJbnRlZ2VyLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgZW5jb2RlZCBCaXRTdHJpbmcgcHJpbWl0aXZlXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQml0U3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBlbmNvZGVkIEJpdFN0cmluZyBwcmltaXRpdmVcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5iaW4gLSBzcGVjaWZ5IGJpbmFyeSBzdHJpbmcgKGV4LiAnMTAxMTEnKTwvbGk+XG4gKiA8bGk+YXJyYXkgLSBzcGVjaWZ5IGFycmF5IG9mIGJvb2xlYW4gKGV4LiBbdHJ1ZSxmYWxzZSx0cnVlLHRydWVdKTwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgdmFsdWUoVikgaW5jbHVkaW5nIHVudXNlZCBiaXRzPC9saT5cbiAqIDxsaT5vYmogLSBzcGVjaWZ5IHtAbGluayBLSlVSLmFzbjEuQVNOMVV0aWwubmV3T2JqZWN0fVxuICogYXJndW1lbnQgZm9yIFwiQml0U3RyaW5nIGVuY2Fwc3VsYXRlc1wiIHN0cnVjdHVyZS48L2xpPlxuICogPC91bD5cbiAqIE5PVEUxOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC48YnIvPlxuICogTk9URTI6ICdvYmonIHBhcmFtZXRlciBoYXZlIGJlZW4gc3VwcG9ydGVkIHNpbmNlXG4gKiBhc24xIDEuMC4xMSwganNyc2FzaWduIDYuMS4xICgyMDE2LVNlcC0yNSkuPGJyLz5cbiAqIEBleGFtcGxlXG4gKiAvLyBkZWZhdWx0IGNvbnN0cnVjdG9yXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBiaW5hcnkgc3RyaW5nXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoe2JpbjogXCIxMDExXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBib29sZWFuIGFycmF5XG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoe2FycmF5OiBbdHJ1ZSxmYWxzZSx0cnVlLHRydWVdfSk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggaGV4YWRlY2ltYWwgc3RyaW5nICgwNCBpcyB1bnVzZWQgYml0cylcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtoZXg6IFwiMDRiYWMwXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBBU04xVXRpbC5uZXdPYmplY3QgYXJndW1lbnQgZm9yIGVuY2Fwc3VsYXRlZFxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKHtvYmo6IHtzZXE6IFt7aW50OiAzfSwge3BybnN0cjogJ2FhYSd9XX19KTtcbiAqIC8vIGFib3ZlIGdlbmVyYXRlcyBhIEFTTi4xIGRhdGEgbGlrZSB0aGlzOlxuICogLy8gQklUIFNUUklORywgZW5jYXBzdWxhdGVzIHtcbiAqIC8vICAgU0VRVUVOQ0Uge1xuICogLy8gICAgIElOVEVHRVIgM1xuICogLy8gICAgIFByaW50YWJsZVN0cmluZyAnYWFhJ1xuICogLy8gICAgIH1cbiAqIC8vICAgfVxuICovXG5LSlVSLmFzbjEuREVSQml0U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXJhbXMub2JqICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBvID0gS0pVUi5hc24xLkFTTjFVdGlsLm5ld09iamVjdChwYXJhbXMub2JqKTtcbiAgICAgICAgcGFyYW1zLmhleCA9IFwiMDBcIiArIG8uZ2V0RW5jb2RlZEhleCgpO1xuICAgIH1cbiAgICBLSlVSLmFzbjEuREVSQml0U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwM1wiO1xuXG4gICAgLyoqXG4gICAgICogc2V0IEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nIGluY2x1ZGluZyB1bnVzZWQgYml0c1xuICAgICAqIEBuYW1lIHNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0c1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdIZXhTdHJpbmdJbmNsdWRpbmdVbnVzZWRCaXRzXG4gICAgICovXG4gICAgdGhpcy5zZXRIZXhWYWx1ZUluY2x1ZGluZ1VudXNlZEJpdHMgPSBmdW5jdGlvbihuZXdIZXhTdHJpbmdJbmNsdWRpbmdVbnVzZWRCaXRzKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmdJbmNsdWRpbmdVbnVzZWRCaXRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgQVNOLjEgdmFsdWUoVikgYnkgdW51c2VkIGJpdCBhbmQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIHZhbHVlXG4gICAgICogQG5hbWUgc2V0VW51c2VkQml0c0FuZEhleFZhbHVlXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB1bnVzZWRCaXRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhWYWx1ZVxuICAgICAqL1xuICAgIHRoaXMuc2V0VW51c2VkQml0c0FuZEhleFZhbHVlID0gZnVuY3Rpb24odW51c2VkQml0cywgaFZhbHVlKSB7XG4gICAgICAgIGlmICh1bnVzZWRCaXRzIDwgMCB8fCA3IDwgdW51c2VkQml0cykge1xuICAgICAgICAgICAgdGhyb3cgXCJ1bnVzZWQgYml0cyBzaGFsbCBiZSBmcm9tIDAgdG8gNzogdSA9IFwiICsgdW51c2VkQml0cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaFVudXNlZEJpdHMgPSBcIjBcIiArIHVudXNlZEJpdHM7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaFYgPSBoVW51c2VkQml0cyArIGhWYWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IEFTTi4xIERFUiBCaXRTdHJpbmcgYnkgYmluYXJ5IHN0cmluZzxici8+XG4gICAgICogQG5hbWUgc2V0QnlCaW5hcnlTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYmluYXJ5U3RyaW5nIGJpbmFyeSB2YWx1ZSBzdHJpbmcgKGkuZS4gJzEwMTExJylcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJdHMgdW51c2VkIGJpdHMgd2lsbCBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYnkgbGVuZ3RoIG9mXG4gICAgICogJ2JpbmFyeVZhbHVlJy4gPGJyLz5cbiAgICAgKiBOT1RFOiBUcmFpbGluZyB6ZXJvcyAnMCcgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKCk7XG4gICAgICogby5zZXRCeUJvb2xlYW5BcnJheShcIjAxMDExXCIpO1xuICAgICAqL1xuICAgIHRoaXMuc2V0QnlCaW5hcnlTdHJpbmcgPSBmdW5jdGlvbihiaW5hcnlTdHJpbmcpIHtcbiAgICAgICAgYmluYXJ5U3RyaW5nID0gYmluYXJ5U3RyaW5nLnJlcGxhY2UoLzArJC8sICcnKTtcbiAgICAgICAgdmFyIHVudXNlZEJpdHMgPSA4IC0gYmluYXJ5U3RyaW5nLmxlbmd0aCAlIDg7XG4gICAgICAgIGlmICh1bnVzZWRCaXRzID09IDgpIHVudXNlZEJpdHMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB1bnVzZWRCaXRzOyBpKyspIHtcbiAgICAgICAgICAgIGJpbmFyeVN0cmluZyArPSAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGggPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoIC0gMTsgaSArPSA4KSB7XG4gICAgICAgICAgICB2YXIgYiA9IGJpbmFyeVN0cmluZy5zdWJzdHIoaSwgOCk7XG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KGIsIDIpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmICh4Lmxlbmd0aCA9PSAxKSB4ID0gJzAnICsgeDtcbiAgICAgICAgICAgIGggKz0geDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhWID0gJzAnICsgdW51c2VkQml0cyArIGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCBBU04uMSBUTFYgdmFsdWUoVikgYnkgYW4gYXJyYXkgb2YgYm9vbGVhbjxici8+XG4gICAgICogQG5hbWUgc2V0QnlCb29sZWFuQXJyYXlcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBib29sZWFuQXJyYXkgYXJyYXkgb2YgYm9vbGVhbiAoZXguIFt0cnVlLCBmYWxzZSwgdHJ1ZV0pXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTk9URTogVHJhaWxpbmcgZmFsc2VzIHdpbGwgYmUgaWdub3JlZCBpbiB0aGUgQVNOLjEgREVSIE9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZygpO1xuICAgICAqIG8uc2V0QnlCb29sZWFuQXJyYXkoW2ZhbHNlLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZV0pO1xuICAgICAqL1xuICAgIHRoaXMuc2V0QnlCb29sZWFuQXJyYXkgPSBmdW5jdGlvbihib29sZWFuQXJyYXkpIHtcbiAgICAgICAgdmFyIHMgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sZWFuQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChib29sZWFuQXJyYXlbaV0gPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHMgKz0gJzEnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzICs9ICcwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEJ5QmluYXJ5U3RyaW5nKHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBhbiBhcnJheSBvZiBmYWxzZXMgd2l0aCBzcGVjaWZpZWQgbGVuZ3RoPGJyLz5cbiAgICAgKiBAbmFtZSBuZXdGYWxzZUFycmF5XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmdcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG5MZW5ndGggbGVuZ3RoIG9mIGFycmF5IHRvIGdlbmVyYXRlXG4gICAgICogQHJldHVybiB7YXJyYXl9IGFycmF5IG9mIGJvb2xlYW4gZmFsc2VzXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhpcyBzdGF0aWMgbWV0aG9kIG1heSBiZSB1c2VmdWwgdG8gaW5pdGlhbGl6ZSBib29sZWFuIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKCk7XG4gICAgICogby5uZXdGYWxzZUFycmF5KDMpICZyYXJyOyBbZmFsc2UsIGZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICB0aGlzLm5ld0ZhbHNlQXJyYXkgPSBmdW5jdGlvbihuTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhID0gbmV3IEFycmF5KG5MZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5MZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYVtpXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJzdHJpbmdcIiAmJiBwYXJhbXMudG9Mb3dlckNhc2UoKS5tYXRjaCgvXlswLTlhLWZdKyQvKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZXhWYWx1ZUluY2x1ZGluZ1VudXNlZEJpdHMocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydoZXgnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0cyhwYXJhbXNbJ2hleCddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydiaW4nXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5QmluYXJ5U3RyaW5nKHBhcmFtc1snYmluJ10pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2FycmF5J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUJvb2xlYW5BcnJheShwYXJhbXNbJ2FycmF5J10pO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBPY3RldFN0cmluZzxici8+XG4gKiBAbmFtZSBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE9jdGV0U3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgQVNOLjEgT2N0ZXRTdHJpbmcgc2ltcGxlIHR5cGUuPGJyLz5cbiAqIFN1cHBvcnRlZCBcInBhcmFtc1wiIGF0dHJpYnV0ZXMgYXJlOlxuICogPHVsPlxuICogPGxpPnN0ciAtIHRvIHNldCBhIHN0cmluZyBhcyBhIHZhbHVlPC9saT5cbiAqIDxsaT5oZXggLSB0byBzZXQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgYXMgYSB2YWx1ZTwvbGk+XG4gKiA8bGk+b2JqIC0gdG8gc2V0IGEgZW5jYXBzdWxhdGVkIEFTTi4xIHZhbHVlIGJ5IEpTT04gb2JqZWN0XG4gKiB3aGljaCBpcyBkZWZpbmVkIGluIHtAbGluayBLSlVSLmFzbjEuQVNOMVV0aWwubmV3T2JqZWN0fTwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogQSBwYXJhbWV0ZXIgJ29iaicgaGF2ZSBiZWVuIHN1cHBvcnRlZFxuICogZm9yIFwiT0NURVQgU1RSSU5HLCBlbmNhcHN1bGF0ZXNcIiBzdHJ1Y3R1cmUuXG4gKiBzaW5jZSBhc24xIDEuMC4xMSwganNyc2FzaWduIDYuMS4xICgyMDE2LVNlcC0yNSkuXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcbiAqIEBleGFtcGxlXG4gKiAvLyBkZWZhdWx0IGNvbnN0cnVjdG9yXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZygpO1xuICogLy8gaW5pdGlhbGl6ZSB3aXRoIHN0cmluZ1xuICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcoe3N0cjogXCJhYWFcIn0pO1xuICogLy8gaW5pdGlhbGl6ZSB3aXRoIGhleGFkZWNpbWFsIHN0cmluZ1xuICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcoe2hleDogXCI2MTYxNjFcIn0pO1xuICogLy8gaW5pdGlhbGl6ZSB3aXRoIEFTTjFVdGlsLm5ld09iamVjdCBhcmd1bWVudFxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcoe29iajoge3NlcTogW3tpbnQ6IDN9LCB7cHJuc3RyOiAnYWFhJ31dfX0pO1xuICogLy8gYWJvdmUgZ2VuZXJhdGVzIGEgQVNOLjEgZGF0YSBsaWtlIHRoaXM6XG4gKiAvLyBPQ1RFVCBTVFJJTkcsIGVuY2Fwc3VsYXRlcyB7XG4gKiAvLyAgIFNFUVVFTkNFIHtcbiAqIC8vICAgICBJTlRFR0VSIDNcbiAqIC8vICAgICBQcmludGFibGVTdHJpbmcgJ2FhYSdcbiAqIC8vICAgICB9XG4gKiAvLyAgIH1cbiAqL1xuS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXJhbXMub2JqICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBvID0gS0pVUi5hc24xLkFTTjFVdGlsLm5ld09iamVjdChwYXJhbXMub2JqKTtcbiAgICAgICAgcGFyYW1zLmhleCA9IG8uZ2V0RW5jb2RlZEhleCgpO1xuICAgIH1cbiAgICBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMDRcIjtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgTnVsbFxuICogQG5hbWUgS0pVUi5hc24xLkRFUk51bGxcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE51bGxcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJOdWxsID0gZnVuY3Rpb24oKSB7XG4gICAgS0pVUi5hc24xLkRFUk51bGwuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcIjA1XCI7XG4gICAgdGhpcy5oVExWID0gXCIwNTAwXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUk51bGwsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBPYmplY3RJZGVudGlmaWVyXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllclxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgT2JqZWN0SWRlbnRpZmllclxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J29pZCc6ICcyLjUuNC41J30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+b2lkIC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgb2lkIHN0cmluZyAoZXguIDIuNS40LjEzKTwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgaXRveCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIGggPSBpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGgubGVuZ3RoID09IDEpIGggPSAnMCcgKyBoO1xuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuICAgIHZhciByb2lkdG94ID0gZnVuY3Rpb24ocm9pZCkge1xuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihyb2lkLCAxMCk7XG4gICAgICAgIHZhciBiID0gYmkudG9TdHJpbmcoMik7XG4gICAgICAgIHZhciBwYWRMZW4gPSA3IC0gYi5sZW5ndGggJSA3O1xuICAgICAgICBpZiAocGFkTGVuID09IDcpIHBhZExlbiA9IDA7XG4gICAgICAgIHZhciBiUGFkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkTGVuOyBpKyspIGJQYWQgKz0gJzAnO1xuICAgICAgICBiID0gYlBhZCArIGI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGggLSAxOyBpICs9IDcpIHtcbiAgICAgICAgICAgIHZhciBiOCA9IGIuc3Vic3RyKGksIDcpO1xuICAgICAgICAgICAgaWYgKGkgIT0gYi5sZW5ndGggLSA3KSBiOCA9ICcxJyArIGI4O1xuICAgICAgICAgICAgaCArPSBpdG94KHBhcnNlSW50KGI4LCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcblxuICAgIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwNlwiO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nXG4gICAgICogQG5hbWUgc2V0VmFsdWVIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld0hleFN0cmluZyBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBPSUQgYnl0ZXNcbiAgICAgKi9cbiAgICB0aGlzLnNldFZhbHVlSGV4ID0gZnVuY3Rpb24obmV3SGV4U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMucyA9IG51bGw7XG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIE9JRCBzdHJpbmc8YnIvPlxuICAgICAqIEBuYW1lIHNldFZhbHVlT2lkU3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvaWRTdHJpbmcgT0lEIHN0cmluZyAoZXguIDIuNS40LjEzKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllcigpO1xuICAgICAqIG8uc2V0VmFsdWVPaWRTdHJpbmcoXCIyLjUuNC4xM1wiKTtcbiAgICAgKi9cbiAgICB0aGlzLnNldFZhbHVlT2lkU3RyaW5nID0gZnVuY3Rpb24ob2lkU3RyaW5nKSB7XG4gICAgICAgIGlmICghIG9pZFN0cmluZy5tYXRjaCgvXlswLTkuXSskLykpIHtcbiAgICAgICAgICAgIHRocm93IFwibWFsZm9ybWVkIG9pZCBzdHJpbmc6IFwiICsgb2lkU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoID0gJyc7XG4gICAgICAgIHZhciBhID0gb2lkU3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBpMCA9IHBhcnNlSW50KGFbMF0pICogNDAgKyBwYXJzZUludChhWzFdKTtcbiAgICAgICAgaCArPSBpdG94KGkwKTtcbiAgICAgICAgYS5zcGxpY2UoMCwgMik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaCArPSByb2lkdG94KGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMucyA9IG51bGw7XG4gICAgICAgIHRoaXMuaFYgPSBoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBPSUQgbmFtZVxuICAgICAqIEBuYW1lIHNldFZhbHVlTmFtZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2lkTmFtZSBPSUQgbmFtZSAoZXguICdzZXJ2ZXJBdXRoJylcbiAgICAgKiBAc2luY2UgMS4wLjFcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBPSUQgbmFtZSBzaGFsbCBiZSBkZWZpbmVkIGluICdLSlVSLmFzbjEueDUwOS5PSUQubmFtZTJvaWRMaXN0Jy5cbiAgICAgKiBPdGhlcndpc2UgcmFpc2UgZXJyb3IuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyKCk7XG4gICAgICogby5zZXRWYWx1ZU5hbWUoXCJzZXJ2ZXJBdXRoXCIpO1xuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVOYW1lID0gZnVuY3Rpb24ob2lkTmFtZSkge1xuICAgICAgICB2YXIgb2lkID0gS0pVUi5hc24xLng1MDkuT0lELm5hbWUyb2lkKG9pZE5hbWUpO1xuICAgICAgICBpZiAob2lkICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZU9pZFN0cmluZyhvaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJERVJPYmplY3RJZGVudGlmaWVyIG9pZE5hbWUgdW5kZWZpbmVkOiBcIiArIG9pZE5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubWF0Y2goL15bMC0yXS5bMC05Ll0rJC8pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZU9pZFN0cmluZyhwYXJhbXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlTmFtZShwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5vaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZU9pZFN0cmluZyhwYXJhbXMub2lkKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVIZXgocGFyYW1zLmhleCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZU5hbWUocGFyYW1zLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgRW51bWVyYXRlZFxuICogQG5hbWUgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWRcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEVudW1lcmF0ZWRcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5pbnQgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgaW50ZWdlciB2YWx1ZTwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqIEBleGFtcGxlXG4gKiBuZXcgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQoMTIzKTtcbiAqIG5ldyBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCh7aW50OiAxMjN9KTtcbiAqIG5ldyBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCh7aGV4OiAnMWZhZCd9KTtcbiAqL1xuS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSRW51bWVyYXRlZC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMGFcIjtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBUb20gV3UncyBCaWdJbnRlZ2VyIG9iamVjdFxuICAgICAqIEBuYW1lIHNldEJ5QmlnSW50ZWdlclxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0JpZ0ludGVnZXJ9IGJpZ0ludGVnZXJWYWx1ZSB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5QmlnSW50ZWdlciA9IGZ1bmN0aW9uKGJpZ0ludGVnZXJWYWx1ZSkge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhWID0gS0pVUi5hc24xLkFTTjFVdGlsLmJpZ0ludFRvTWluVHdvc0NvbXBsZW1lbnRzSGV4KGJpZ0ludGVnZXJWYWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBpbnRlZ2VyIHZhbHVlXG4gICAgICogQG5hbWUgc2V0QnlJbnRlZ2VyXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaW50ZWdlciB2YWx1ZSB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5SW50ZWdlciA9IGZ1bmN0aW9uKGludFZhbHVlKSB7XG4gICAgICAgIHZhciBiaSA9IG5ldyBCaWdJbnRlZ2VyKFN0cmluZyhpbnRWYWx1ZSksIDEwKTtcbiAgICAgICAgdGhpcy5zZXRCeUJpZ0ludGVnZXIoYmkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBuYW1lIHNldFZhbHVlSGV4XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIDxici8+XG4gICAgICogTk9URTogVmFsdWUgc2hhbGwgYmUgcmVwcmVzZW50ZWQgYnkgbWluaW11bSBvY3RldCBsZW5ndGggb2ZcbiAgICAgKiB0d28ncyBjb21wbGVtZW50IHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVIZXggPSBmdW5jdGlvbihuZXdIZXhTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5oViA9IG5ld0hleFN0cmluZztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydpbnQnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXNbJ2ludCddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlJbnRlZ2VyKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaGV4J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUhleChwYXJhbXNbJ2hleCddKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSRW51bWVyYXRlZCwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFVURjhTdHJpbmdcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBVVEY4U3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSVVRGOFN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjBjXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlVURjhTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgTnVtZXJpY1N0cmluZ1xuICogQG5hbWUgS0pVUi5hc24xLkRFUk51bWVyaWNTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE51bWVyaWNTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUk51bWVyaWNTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMTJcIjtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBQcmludGFibGVTdHJpbmdcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJQcmludGFibGVTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFByaW50YWJsZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJQcmludGFibGVTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMTNcIjtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFRlbGV0ZXhTdHJpbmdcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJUZWxldGV4U3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBUZWxldGV4U3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSVGVsZXRleFN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJUZWxldGV4U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjE0XCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgSUE1U3RyaW5nXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSSUE1U3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBJQTVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJJQTVTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSSUE1U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjE2XCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUklBNVN0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBVVENUaW1lXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSVVRDVGltZVxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVVRDVGltZVxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICcxMzA0MzAyMzU5NTlaJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5zdHIgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBzdHJpbmcgKGV4LicxMzA0MzAyMzU5NTlaJyk8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8bGk+ZGF0ZSAtIHNwZWNpZnkgRGF0ZSBvYmplY3QuPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqIDxoND5FWEFNUExFUzwvaDQ+XG4gKiBAZXhhbXBsZVxuICogZDEgPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoKTtcbiAqIGQxLnNldFN0cmluZygnMTMwNDMwMTI1OTU5WicpO1xuICpcbiAqIGQyID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKHsnc3RyJzogJzEzMDQzMDEyNTk1OVonfSk7XG4gKiBkMyA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSh7J2RhdGUnOiBuZXcgRGF0ZShEYXRlLlVUQygyMDE1LCAwLCAzMSwgMCwgMCwgMCwgMCkpfSk7XG4gKiBkNCA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSgnMTMwNDMwMTI1OTU5WicpO1xuICovXG5LSlVSLmFzbjEuREVSVVRDVGltZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJVVENUaW1lLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjE3XCI7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBEYXRlIG9iamVjdDxici8+XG4gICAgICogQG5hbWUgc2V0QnlEYXRlXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJVVENUaW1lI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZU9iamVjdCBEYXRlIG9iamVjdCB0byBzZXQgQVNOLjEgdmFsdWUoVilcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoKTtcbiAgICAgKiBvLnNldEJ5RGF0ZShuZXcgRGF0ZShcIjIwMTYvMTIvMzFcIikpO1xuICAgICAqL1xuICAgIHRoaXMuc2V0QnlEYXRlID0gZnVuY3Rpb24oZGF0ZU9iamVjdCkge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRhdGUgPSBkYXRlT2JqZWN0O1xuICAgICAgICB0aGlzLnMgPSB0aGlzLmZvcm1hdERhdGUodGhpcy5kYXRlLCAndXRjJyk7XG4gICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRlID09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRoaXMucyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ3V0YycpO1xuICAgICAgICAgICAgdGhpcy5oViA9IHN0b2hleCh0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zdHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zLnN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcInN0cmluZ1wiICYmIHBhcmFtcy5tYXRjaCgvXlswLTldezEyfVokLykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZ0hleChwYXJhbXMuaGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5RGF0ZShwYXJhbXMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlVUQ1RpbWUsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIEdlbmVyYWxpemVkVGltZVxuICogQG5hbWUgS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZVxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgR2VuZXJhbGl6ZWRUaW1lXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJzIwMTMwNDMwMjM1OTU5Wid9KVxuICogQHByb3BlcnR5IHtCb29sZWFufSB3aXRoTWlsbGlzIGZsYWcgdG8gc2hvdyBtaWxsaXNlY29uZHMgb3Igbm90XG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5zdHIgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBzdHJpbmcgKGV4LicyMDEzMDQzMDIzNTk1OVonKTwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nPC9saT5cbiAqIDxsaT5kYXRlIC0gc3BlY2lmeSBEYXRlIG9iamVjdC48L2xpPlxuICogPGxpPm1pbGxpcyAtIHNwZWNpZnkgZmxhZyB0byBzaG93IG1pbGxpc2Vjb25kcyAoZnJvbSAxLjAuNik8L2xpPlxuICogPC91bD5cbiAqIE5PVEUxOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqIE5PVEUyOiAnd2l0aE1pbGxpcycgcHJvcGVydHkgaXMgc3VwcG9ydGVkIGZyb20gYXNuMSAxLjAuNi5cbiAqL1xuS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMThcIjtcbiAgICB0aGlzLndpdGhNaWxsaXMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIERhdGUgb2JqZWN0XG4gICAgICogQG5hbWUgc2V0QnlEYXRlXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWUjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlT2JqZWN0IERhdGUgb2JqZWN0IHRvIHNldCBBU04uMSB2YWx1ZShWKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogV2hlbiB5b3Ugc3BlY2lmeSBVVEMgdGltZSwgdXNlICdEYXRlLlVUQycgbWV0aG9kIGxpa2UgdGhpczo8YnIvPlxuICAgICAqIG8xID0gbmV3IERFUlVUQ1RpbWUoKTtcbiAgICAgKiBvMS5zZXRCeURhdGUoZGF0ZSk7XG4gICAgICpcbiAgICAgKiBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoMjAxNSwgMCwgMzEsIDIzLCA1OSwgNTksIDApKTsgIzIwMTVKQU4zMSAyMzo1OTo1OVxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlEYXRlID0gZnVuY3Rpb24oZGF0ZU9iamVjdCkge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRhdGUgPSBkYXRlT2JqZWN0O1xuICAgICAgICB0aGlzLnMgPSB0aGlzLmZvcm1hdERhdGUodGhpcy5kYXRlLCAnZ2VuJywgdGhpcy53aXRoTWlsbGlzKTtcbiAgICAgICAgdGhpcy5oViA9IHN0b2hleCh0aGlzLnMpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ2dlbicsIHRoaXMud2l0aE1pbGxpcyk7XG4gICAgICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGFyYW1zLnN0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhwYXJhbXMuc3RyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09IFwic3RyaW5nXCIgJiYgcGFyYW1zLm1hdGNoKC9eWzAtOV17MTR9WiQvKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nSGV4KHBhcmFtcy5oZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5kYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlEYXRlKHBhcmFtcy5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1pbGxpcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy53aXRoTWlsbGlzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBTZXF1ZW5jZVxuICogQG5hbWUgS0pVUi5hc24xLkRFUlNlcXVlbmNlXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBTZXF1ZW5jZVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+YXJyYXkgLSBzcGVjaWZ5IGFycmF5IG9mIEFTTjFPYmplY3QgdG8gc2V0IGVsZW1lbnRzIG9mIGNvbnRlbnQ8L2xpPlxuICogPC91bD5cbiAqIE5PVEU6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5LSlVSLmFzbjEuREVSU2VxdWVuY2UgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSU2VxdWVuY2Uuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMzBcIjtcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGggPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFzbjFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFzbjFPYmogPSB0aGlzLmFzbjFBcnJheVtpXTtcbiAgICAgICAgICAgIGggKz0gYXNuMU9iai5nZXRFbmNvZGVkSGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oViA9IGg7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlNlcXVlbmNlLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBTZXRcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJTZXRcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFNldFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+YXJyYXkgLSBzcGVjaWZ5IGFycmF5IG9mIEFTTjFPYmplY3QgdG8gc2V0IGVsZW1lbnRzIG9mIGNvbnRlbnQ8L2xpPlxuICogPGxpPnNvcnRmbGFnIC0gZmxhZyBmb3Igc29ydCAoZGVmYXVsdDogdHJ1ZSkuIEFTTi4xIEJFUiBpcyBub3Qgc29ydGVkIGluICdTRVQgT0YnLjwvbGk+XG4gKiA8L3VsPlxuICogTk9URTE6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLjxici8+XG4gKiBOT1RFMjogc29ydGZsYWcgaXMgc3VwcG9ydGVkIHNpbmNlIDEuMC41LlxuICovXG5LSlVSLmFzbjEuREVSU2V0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlNldC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIzMVwiO1xuICAgIHRoaXMuc29ydEZsYWcgPSB0cnVlOyAvLyBpdGVtIHNoYWxsIGJlIHNvcnRlZCBvbmx5IGluIEFTTi4xIERFUlxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IG5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXNuMUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXNuMU9iaiA9IHRoaXMuYXNuMUFycmF5W2ldO1xuICAgICAgICAgICAgYS5wdXNoKGFzbjFPYmouZ2V0RW5jb2RlZEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zb3J0RmxhZyA9PSB0cnVlKSBhLnNvcnQoKTtcbiAgICAgICAgdGhpcy5oViA9IGEuam9pbignJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLnNvcnRmbGFnICE9IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHBhcmFtcy5zb3J0ZmxhZyA9PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuc29ydEZsYWcgPSBmYWxzZTtcbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlNldCwgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgVGFnZ2VkT2JqZWN0XG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0XG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBUYWdnZWRPYmplY3RcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBQYXJhbWV0ZXIgJ3RhZ05vTmV4JyBpcyBBU04uMSB0YWcoVCkgdmFsdWUgZm9yIHRoaXMgb2JqZWN0LlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBmaW5kICdbMV0nIHRhZyBpbiBhIEFTTi4xIGR1bXAsXG4gKiAndGFnTm9IZXgnIHdpbGwgYmUgJ2ExJy5cbiAqIDxici8+XG4gKiBBcyBmb3Igb3B0aW9uYWwgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgKkFOWSogb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPmV4cGxpY2l0IC0gc3BlY2lmeSB0cnVlIGlmIHRoaXMgaXMgZXhwbGljaXQgdGFnIG90aGVyd2lzZSBmYWxzZVxuICogICAgIChkZWZhdWx0IGlzICd0cnVlJykuPC9saT5cbiAqIDxsaT50YWcgLSBzcGVjaWZ5IHRhZyAoZGVmYXVsdCBpcyAnYTAnIHdoaWNoIG1lYW5zIFswXSk8L2xpPlxuICogPGxpPm9iaiAtIHNwZWNpZnkgQVNOMU9iamVjdCB3aGljaCBpcyB0YWdnZWQ8L2xpPlxuICogPC91bD5cbiAqIEBleGFtcGxlXG4gKiBkMSA9IG5ldyBLSlVSLmFzbjEuREVSVVRGOFN0cmluZyh7J3N0cic6J2EnfSk7XG4gKiBkMiA9IG5ldyBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0KHsnb2JqJzogZDF9KTtcbiAqIGhleCA9IGQyLmdldEVuY29kZWRIZXgoKTtcbiAqL1xuS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3Quc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcImEwXCI7XG4gICAgdGhpcy5oViA9ICcnO1xuICAgIHRoaXMuaXNFeHBsaWNpdCA9IHRydWU7XG4gICAgdGhpcy5hc24xT2JqZWN0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhbiBBU04xT2JqZWN0XG4gICAgICogQG5hbWUgc2V0U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3QjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0V4cGxpY2l0RmxhZyBmbGFnIGZvciBleHBsaWNpdC9pbXBsaWNpdCB0YWdcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHRhZ05vSGV4IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSB0YWdcbiAgICAgKiBAcGFyYW0ge0FTTjFPYmplY3R9IGFzbjFPYmplY3QgQVNOLjEgdG8gZW5jYXBzdWxhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNldEFTTjFPYmplY3QgPSBmdW5jdGlvbihpc0V4cGxpY2l0RmxhZywgdGFnTm9IZXgsIGFzbjFPYmplY3QpIHtcbiAgICAgICAgdGhpcy5oVCA9IHRhZ05vSGV4O1xuICAgICAgICB0aGlzLmlzRXhwbGljaXQgPSBpc0V4cGxpY2l0RmxhZztcbiAgICAgICAgdGhpcy5hc24xT2JqZWN0ID0gYXNuMU9iamVjdDtcbiAgICAgICAgaWYgKHRoaXMuaXNFeHBsaWNpdCkge1xuICAgICAgICAgICAgdGhpcy5oViA9IHRoaXMuYXNuMU9iamVjdC5nZXRFbmNvZGVkSGV4KCk7XG4gICAgICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaFYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oVExWID0gYXNuMU9iamVjdC5nZXRFbmNvZGVkSGV4KCk7XG4gICAgICAgICAgICB0aGlzLmhUTFYgPSB0aGlzLmhUTFYucmVwbGFjZSgvXi4uLywgdGFnTm9IZXgpO1xuICAgICAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWyd0YWcnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmhUID0gcGFyYW1zWyd0YWcnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snZXhwbGljaXQnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmlzRXhwbGljaXQgPSBwYXJhbXNbJ2V4cGxpY2l0J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ29iaiddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXNuMU9iamVjdCA9IHBhcmFtc1snb2JqJ107XG4gICAgICAgICAgICB0aGlzLnNldEFTTjFPYmplY3QodGhpcy5pc0V4cGxpY2l0LCB0aGlzLmhULCB0aGlzLmFzbjFPYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3QsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgSlNFbmNyeXB0UlNBS2V5IHRoYXQgZXh0ZW5kcyBUb20gV3UncyBSU0Ega2V5IG9iamVjdC5cbiAqIFRoaXMgb2JqZWN0IGlzIGp1c3QgYSBkZWNvcmF0b3IgZm9yIHBhcnNpbmcgdGhlIGtleSBwYXJhbWV0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5IC0gVGhlIGtleSBpbiBzdHJpbmcgZm9ybWF0LCBvciBhbiBvYmplY3QgY29udGFpbmluZ1xuICogdGhlIHBhcmFtZXRlcnMgbmVlZGVkIHRvIGJ1aWxkIGEgUlNBS2V5IG9iamVjdC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSlNFbmNyeXB0UlNBS2V5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKU0VuY3J5cHRSU0FLZXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSlNFbmNyeXB0UlNBS2V5KGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBDYWxsIHRoZSBzdXBlciBjb25zdHJ1Y3Rvci5cbiAgICAgICAgLy8gIFJTQUtleS5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBJZiBhIGtleSBrZXkgd2FzIHByb3ZpZGVkLlxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3RyaW5nLi4uXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIF90aGlzLnBhcnNlS2V5KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChKU0VuY3J5cHRSU0FLZXkuaGFzUHJpdmF0ZUtleVByb3BlcnR5KGtleSkgfHxcbiAgICAgICAgICAgICAgICBKU0VuY3J5cHRSU0FLZXkuaGFzUHVibGljS2V5UHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgdmFsdWVzIGZvciB0aGUga2V5LlxuICAgICAgICAgICAgICAgIF90aGlzLnBhcnNlUHJvcGVydGllc0Zyb20oa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBwYXJzZSBhIHBlbSBlbmNvZGVkIHN0cmluZyBjb250YWluaW5nIGJvdGggYSBwdWJsaWMgb3IgcHJpdmF0ZSBrZXkuXG4gICAgICogVGhlIG1ldGhvZCB3aWxsIHRyYW5zbGF0ZSB0aGUgcGVtIGVuY29kZWQgc3RyaW5nIGluIGEgZGVyIGVuY29kZWQgc3RyaW5nIGFuZFxuICAgICAqIHdpbGwgcGFyc2UgcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkgcGFyYW1ldGVycy4gVGhpcyBtZXRob2QgYWNjZXB0cyBwdWJsaWMga2V5XG4gICAgICogaW4gdGhlIHJzYWVuY3J5cHRpb24gcGtjcyAjMSBmb3JtYXQgKG9pZDogMS4yLjg0MC4xMTM1NDkuMS4xLjEpLlxuICAgICAqXG4gICAgICogQHRvZG8gQ2hlY2sgaG93IG1hbnkgcnNhIGZvcm1hdHMgdXNlIHRoZSBzYW1lIGZvcm1hdCBvZiBwa2NzICMxLlxuICAgICAqXG4gICAgICogVGhlIGZvcm1hdCBpcyBkZWZpbmVkIGFzOlxuICAgICAqIFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIGFsZ29yaXRobSAgICAgICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICAgICAqICAgUHVibGljS2V5ICAgICAgIEJJVCBTVFJJTkdcbiAgICAgKiB9XG4gICAgICogV2hlcmUgQWxnb3JpdGhtSWRlbnRpZmllciBpczpcbiAgICAgKiBBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBhbGdvcml0aG0gICAgICAgT0JKRUNUIElERU5USUZJRVIsICAgICB0aGUgT0lEIG9mIHRoZSBlbmMgYWxnb3JpdGhtXG4gICAgICogICBwYXJhbWV0ZXJzICAgICAgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMIChOVUxMIGZvciBQS0NTICMxKVxuICAgICAqIH1cbiAgICAgKiBhbmQgUHVibGljS2V5IGlzIGEgU0VRVUVOQ0UgZW5jYXBzdWxhdGVkIGluIGEgQklUIFNUUklOR1xuICAgICAqIFJTQVB1YmxpY0tleSA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgbW9kdWx1cyAgICAgICAgICAgSU5URUdFUiwgIC0tIG5cbiAgICAgKiAgIHB1YmxpY0V4cG9uZW50ICAgIElOVEVHRVIgICAtLSBlXG4gICAgICogfVxuICAgICAqIGl0J3MgcG9zc2libGUgdG8gZXhhbWluZSB0aGUgc3RydWN0dXJlIG9mIHRoZSBrZXlzIG9idGFpbmVkIGZyb20gb3BlbnNzbCB1c2luZ1xuICAgICAqIGFuIGFzbi4xIGR1bXBlciBhcyB0aGUgb25lIHVzZWQgaGVyZSB0byBwYXJzZSB0aGUgY29tcG9uZW50czogaHR0cDovL2xhcG8uaXQvYXNuMWpzL1xuICAgICAqIEBhcmd1bWVudCB7c3RyaW5nfSBwZW0gdGhlIHBlbSBlbmNvZGVkIHN0cmluZywgY2FuIGluY2x1ZGUgdGhlIEJFR0lOL0VORCBoZWFkZXIvZm9vdGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLnBhcnNlS2V5ID0gZnVuY3Rpb24gKHBlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG1vZHVsdXMgPSAwO1xuICAgICAgICAgICAgdmFyIHB1YmxpY19leHBvbmVudCA9IDA7XG4gICAgICAgICAgICB2YXIgcmVIZXggPSAvXlxccyooPzpbMC05QS1GYS1mXVswLTlBLUZhLWZdXFxzKikrJC87XG4gICAgICAgICAgICB2YXIgZGVyID0gcmVIZXgudGVzdChwZW0pID8gSGV4LmRlY29kZShwZW0pIDogQmFzZTY0LnVuYXJtb3IocGVtKTtcbiAgICAgICAgICAgIHZhciBhc24xID0gQVNOMS5kZWNvZGUoZGVyKTtcbiAgICAgICAgICAgIC8vIEZpeGVzIGEgYnVnIHdpdGggT3BlblNTTCAxLjArIHByaXZhdGUga2V5c1xuICAgICAgICAgICAgaWYgKGFzbjEuc3ViLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIGFzbjEgPSBhc24xLnN1YlsyXS5zdWJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXNuMS5zdWIubGVuZ3RoID09PSA5KSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIHByaXZhdGUga2V5LlxuICAgICAgICAgICAgICAgIG1vZHVsdXMgPSBhc24xLnN1YlsxXS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChtb2R1bHVzLCAxNik7XG4gICAgICAgICAgICAgICAgcHVibGljX2V4cG9uZW50ID0gYXNuMS5zdWJbMl0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gaW50XG4gICAgICAgICAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQocHVibGljX2V4cG9uZW50LCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIHByaXZhdGVfZXhwb25lbnQgPSBhc24xLnN1YlszXS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmQgPSBwYXJzZUJpZ0ludChwcml2YXRlX2V4cG9uZW50LCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIHByaW1lMSA9IGFzbjEuc3ViWzRdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxuICAgICAgICAgICAgICAgIHRoaXMucCA9IHBhcnNlQmlnSW50KHByaW1lMSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBwcmltZTIgPSBhc24xLnN1Yls1XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLnEgPSBwYXJzZUJpZ0ludChwcmltZTIsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQxID0gYXNuMS5zdWJbNl0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5kbXAxID0gcGFyc2VCaWdJbnQoZXhwb25lbnQxLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50MiA9IGFzbjEuc3ViWzddLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxuICAgICAgICAgICAgICAgIHRoaXMuZG1xMSA9IHBhcnNlQmlnSW50KGV4cG9uZW50MiwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBjb2VmZmljaWVudCA9IGFzbjEuc3ViWzhdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxuICAgICAgICAgICAgICAgIHRoaXMuY29lZmYgPSBwYXJzZUJpZ0ludChjb2VmZmljaWVudCwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXNuMS5zdWIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIHB1YmxpYyBrZXkuXG4gICAgICAgICAgICAgICAgdmFyIGJpdF9zdHJpbmcgPSBhc24xLnN1YlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBiaXRfc3RyaW5nLnN1YlswXTtcbiAgICAgICAgICAgICAgICBtb2R1bHVzID0gc2VxdWVuY2Uuc3ViWzBdLmdldEhleFN0cmluZ1ZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uID0gcGFyc2VCaWdJbnQobW9kdWx1cywgMTYpO1xuICAgICAgICAgICAgICAgIHB1YmxpY19leHBvbmVudCA9IHNlcXVlbmNlLnN1YlsxXS5nZXRIZXhTdHJpbmdWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KHB1YmxpY19leHBvbmVudCwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZSByc2EgcGFyYW1ldGVycyBpbiBhIGhleCBlbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJzYSBrZXkuXG4gICAgICpcbiAgICAgKiBUaGUgdHJhbnNsYXRpb24gZm9sbG93IHRoZSBBU04uMSBub3RhdGlvbiA6XG4gICAgICogUlNBUHJpdmF0ZUtleSA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgdmVyc2lvbiAgICAgICAgICAgVmVyc2lvbixcbiAgICAgKiAgIG1vZHVsdXMgICAgICAgICAgIElOVEVHRVIsICAtLSBuXG4gICAgICogICBwdWJsaWNFeHBvbmVudCAgICBJTlRFR0VSLCAgLS0gZVxuICAgICAqICAgcHJpdmF0ZUV4cG9uZW50ICAgSU5URUdFUiwgIC0tIGRcbiAgICAgKiAgIHByaW1lMSAgICAgICAgICAgIElOVEVHRVIsICAtLSBwXG4gICAgICogICBwcmltZTIgICAgICAgICAgICBJTlRFR0VSLCAgLS0gcVxuICAgICAqICAgZXhwb25lbnQxICAgICAgICAgSU5URUdFUiwgIC0tIGQgbW9kIChwMSlcbiAgICAgKiAgIGV4cG9uZW50MiAgICAgICAgIElOVEVHRVIsICAtLSBkIG1vZCAocS0xKVxuICAgICAqICAgY29lZmZpY2llbnQgICAgICAgSU5URUdFUiwgIC0tIChpbnZlcnNlIG9mIHEpIG1vZCBwXG4gICAgICogfVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9ICBERVIgRW5jb2RlZCBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByc2EgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHJpdmF0ZUJhc2VLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgYXJyYXk6IFtcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBpbnQ6IDAgfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgYmlnaW50OiB0aGlzLm4gfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgaW50OiB0aGlzLmUgfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgYmlnaW50OiB0aGlzLmQgfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgYmlnaW50OiB0aGlzLnAgfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgYmlnaW50OiB0aGlzLnEgfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgYmlnaW50OiB0aGlzLmRtcDEgfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgYmlnaW50OiB0aGlzLmRtcTEgfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgYmlnaW50OiB0aGlzLmNvZWZmIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZXEgPSBuZXcgS0pVUi5hc24xLkRFUlNlcXVlbmNlKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gc2VxLmdldEVuY29kZWRIZXgoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGJhc2U2NCAocGVtKSBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIERFUiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFByaXZhdGVCYXNlS2V5QjY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGV4MmI2NCh0aGlzLmdldFByaXZhdGVCYXNlS2V5KCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlIHJzYSBwYXJhbWV0ZXJzIGluIGEgaGV4IGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnNhIHB1YmxpYyBrZXkuXG4gICAgICogVGhlIHJlcHJlc2VudGF0aW9uIGZvbGxvdyB0aGUgQVNOLjEgbm90YXRpb24gOlxuICAgICAqIFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIGFsZ29yaXRobSAgICAgICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICAgICAqICAgUHVibGljS2V5ICAgICAgIEJJVCBTVFJJTkdcbiAgICAgKiB9XG4gICAgICogV2hlcmUgQWxnb3JpdGhtSWRlbnRpZmllciBpczpcbiAgICAgKiBBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBhbGdvcml0aG0gICAgICAgT0JKRUNUIElERU5USUZJRVIsICAgICB0aGUgT0lEIG9mIHRoZSBlbmMgYWxnb3JpdGhtXG4gICAgICogICBwYXJhbWV0ZXJzICAgICAgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMIChOVUxMIGZvciBQS0NTICMxKVxuICAgICAqIH1cbiAgICAgKiBhbmQgUHVibGljS2V5IGlzIGEgU0VRVUVOQ0UgZW5jYXBzdWxhdGVkIGluIGEgQklUIFNUUklOR1xuICAgICAqIFJTQVB1YmxpY0tleSA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgbW9kdWx1cyAgICAgICAgICAgSU5URUdFUiwgIC0tIG5cbiAgICAgKiAgIHB1YmxpY0V4cG9uZW50ICAgIElOVEVHRVIgICAtLSBlXG4gICAgICogfVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IERFUiBFbmNvZGVkIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJzYSBwdWJsaWMga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFB1YmxpY0Jhc2VLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJzdF9zZXF1ZW5jZSA9IG5ldyBLSlVSLmFzbjEuREVSU2VxdWVuY2Uoe1xuICAgICAgICAgICAgYXJyYXk6IFtcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIoeyBvaWQ6IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIiB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUk51bGwoKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlY29uZF9zZXF1ZW5jZSA9IG5ldyBLSlVSLmFzbjEuREVSU2VxdWVuY2Uoe1xuICAgICAgICAgICAgYXJyYXk6IFtcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBiaWdpbnQ6IHRoaXMubiB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBpbnQ6IHRoaXMuZSB9KVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJpdF9zdHJpbmcgPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZyh7XG4gICAgICAgICAgICBoZXg6IFwiMDBcIiArIHNlY29uZF9zZXF1ZW5jZS5nZXRFbmNvZGVkSGV4KClcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZXEgPSBuZXcgS0pVUi5hc24xLkRFUlNlcXVlbmNlKHtcbiAgICAgICAgICAgIGFycmF5OiBbXG4gICAgICAgICAgICAgICAgZmlyc3Rfc2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgYml0X3N0cmluZ1xuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcS5nZXRFbmNvZGVkSGV4KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBiYXNlNjQgKHBlbSkgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBERVIgZW5jb2RlZCByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQdWJsaWNCYXNlS2V5QjY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGV4MmI2NCh0aGlzLmdldFB1YmxpY0Jhc2VLZXkoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB3cmFwIHRoZSBzdHJpbmcgaW4gYmxvY2sgb2Ygd2lkdGggY2hhcnMuIFRoZSBkZWZhdWx0IHZhbHVlIGZvciByc2Ega2V5cyBpcyA2NFxuICAgICAqIGNoYXJhY3RlcnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgcGVtIGVuY29kZWQgc3RyaW5nIHdpdGhvdXQgaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTY0XSAtIHRoZSBsZW5ndGggdGhlIHN0cmluZyBoYXMgdG8gYmUgd3JhcHBlZCBhdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkud29yZHdyYXAgPSBmdW5jdGlvbiAoc3RyLCB3aWR0aCkge1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IDY0O1xuICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVnZXggPSBcIiguezEsXCIgKyB3aWR0aCArIFwifSkoICt8JFxcbj8pfCguezEsXCIgKyB3aWR0aCArIFwifSlcIjtcbiAgICAgICAgcmV0dXJuIHN0ci5tYXRjaChSZWdFeHAocmVnZXgsIFwiZ1wiKSkuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBwZW0gZW5jb2RlZCBwcml2YXRlIGtleVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBwZW0gZW5jb2RlZCBwcml2YXRlIGtleSB3aXRoIGhlYWRlci9mb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5ID0gXCItLS0tLUJFR0lOIFJTQSBQUklWQVRFIEtFWS0tLS0tXFxuXCI7XG4gICAgICAgIGtleSArPSBKU0VuY3J5cHRSU0FLZXkud29yZHdyYXAodGhpcy5nZXRQcml2YXRlQmFzZUtleUI2NCgpKSArIFwiXFxuXCI7XG4gICAgICAgIGtleSArPSBcIi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tXCI7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcGVtIGVuY29kZWQgcHVibGljIGtleVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBwZW0gZW5jb2RlZCBwdWJsaWMga2V5IHdpdGggaGVhZGVyL2Zvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleSA9IFwiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG5cIjtcbiAgICAgICAga2V5ICs9IEpTRW5jcnlwdFJTQUtleS53b3Jkd3JhcCh0aGlzLmdldFB1YmxpY0Jhc2VLZXlCNjQoKSkgKyBcIlxcblwiO1xuICAgICAgICBrZXkgKz0gXCItLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cIjtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzIHRvIHBvcHVsYXRlIHRoZSByc2EgbW9kdWx1c1xuICAgICAqIGFuZCBwdWJsaWMgZXhwb25lbnQgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iaj17fV0gLSBBbiBvYmplY3QgdGhhdCBtYXkgY29udGFpbiB0aGUgdHdvIHB1YmxpYyBrZXlcbiAgICAgKiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBjb250YWlucyBib3RoIHRoZSBtb2R1bHVzIGFuZCB0aGUgcHVibGljIGV4cG9uZW50XG4gICAgICogcHJvcGVydGllcyAobiBhbmQgZSlcbiAgICAgKiBAdG9kbyBjaGVjayBmb3IgdHlwZXMgb2YgbiBhbmQgZS4gTiBzaG91bGQgYmUgYSBwYXJzZWFibGUgYmlnSW50IG9iamVjdCwgRSBzaG91bGRcbiAgICAgKiBiZSBhIHBhcnNlYWJsZSBpbnRlZ2VyIG51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5Lmhhc1B1YmxpY0tleVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBvYmogPSBvYmogfHwge307XG4gICAgICAgIHJldHVybiAob2JqLmhhc093blByb3BlcnR5KFwiblwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiZVwiKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIEFMTCB0aGUgcGFyYW1ldGVycyBvZiBhbiBSU0Ega2V5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqPXt9XSAtIEFuIG9iamVjdCB0aGF0IG1heSBjb250YWluIG5pbmUgcnNhIGtleVxuICAgICAqIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGFsbCB0aGUgcGFyYW1ldGVycyBuZWVkZWRcbiAgICAgKiBAdG9kbyBjaGVjayBmb3IgdHlwZXMgb2YgdGhlIHBhcmFtZXRlcnMgYWxsIHRoZSBwYXJhbWV0ZXJzIGJ1dCB0aGUgcHVibGljIGV4cG9uZW50XG4gICAgICogc2hvdWxkIGJlIHBhcnNlYWJsZSBiaWdpbnQgb2JqZWN0cywgdGhlIHB1YmxpYyBleHBvbmVudCBzaG91bGQgYmUgYSBwYXJzZWFibGUgaW50ZWdlciBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5oYXNQcml2YXRlS2V5UHJvcGVydHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICAgICAgcmV0dXJuIChvYmouaGFzT3duUHJvcGVydHkoXCJuXCIpICYmXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJlXCIpICYmXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJkXCIpICYmXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJwXCIpICYmXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJxXCIpICYmXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJkbXAxXCIpICYmXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJkbXExXCIpICYmXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJjb2VmZlwiKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgcHJvcGVydGllcyBvZiBvYmogaW4gdGhlIGN1cnJlbnQgcnNhIG9iamVjdC4gT2JqIHNob3VsZCBBVCBMRUFTVFxuICAgICAqIGluY2x1ZGUgdGhlIG1vZHVsdXMgYW5kIHB1YmxpYyBleHBvbmVudCAobiwgZSkgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCBjb250YWluaW5nIHJzYSBwYXJhbWV0ZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLnBhcnNlUHJvcGVydGllc0Zyb20gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRoaXMubiA9IG9iai5uO1xuICAgICAgICB0aGlzLmUgPSBvYmouZTtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShcImRcIikpIHtcbiAgICAgICAgICAgIHRoaXMuZCA9IG9iai5kO1xuICAgICAgICAgICAgdGhpcy5wID0gb2JqLnA7XG4gICAgICAgICAgICB0aGlzLnEgPSBvYmoucTtcbiAgICAgICAgICAgIHRoaXMuZG1wMSA9IG9iai5kbXAxO1xuICAgICAgICAgICAgdGhpcy5kbXExID0gb2JqLmRtcTE7XG4gICAgICAgICAgICB0aGlzLmNvZWZmID0gb2JqLmNvZWZmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSlNFbmNyeXB0UlNBS2V5O1xufShSU0FLZXkpKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zID0ge31dIC0gQW4gb2JqZWN0IHRvIGN1c3RvbWl6ZSBKU0VuY3J5cHQgYmVoYXZpb3VyXG4gKiBwb3NzaWJsZSBwYXJhbWV0ZXJzIGFyZTpcbiAqIC0gZGVmYXVsdF9rZXlfc2l6ZSAgICAgICAge251bWJlcn0gIGRlZmF1bHQ6IDEwMjQgdGhlIGtleSBzaXplIGluIGJpdFxuICogLSBkZWZhdWx0X3B1YmxpY19leHBvbmVudCB7c3RyaW5nfSAgZGVmYXVsdDogJzAxMDAwMScgdGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMgZXhwb25lbnRcbiAqIC0gbG9nICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IGRlZmF1bHQ6IGZhbHNlIHdoZXRoZXIgbG9nIHdhcm4vZXJyb3Igb3Igbm90XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpTRW5jcnlwdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU0VuY3J5cHQob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5kZWZhdWx0X2tleV9zaXplID0gcGFyc2VJbnQob3B0aW9ucy5kZWZhdWx0X2tleV9zaXplLCAxMCkgfHwgMTAyNDtcbiAgICAgICAgdGhpcy5kZWZhdWx0X3B1YmxpY19leHBvbmVudCA9IG9wdGlvbnMuZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQgfHwgXCIwMTAwMDFcIjsgLy8gNjU1MzcgZGVmYXVsdCBvcGVuc3NsIHB1YmxpYyBleHBvbmVudCBmb3IgcnNhIGtleSB0eXBlXG4gICAgICAgIHRoaXMubG9nID0gb3B0aW9ucy5sb2cgfHwgZmFsc2U7XG4gICAgICAgIC8vIFRoZSBwcml2YXRlIGFuZCBwdWJsaWMga2V5LlxuICAgICAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBzZXQgdGhlIHJzYSBrZXkgcGFyYW1ldGVyIChvbmUgbWV0aG9kIGlzIGVub3VnaCB0byBzZXQgYm90aCB0aGUgcHVibGljXG4gICAgICogYW5kIHRoZSBwcml2YXRlIGtleSwgc2luY2UgdGhlIHByaXZhdGUga2V5IGNvbnRhaW5zIHRoZSBwdWJsaWMga2V5IHBhcmFtZW50ZXJzKVxuICAgICAqIExvZyBhIHdhcm5pbmcgaWYgbG9ncyBhcmUgZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5IHRoZSBwZW0gZW5jb2RlZCBzdHJpbmcgb3IgYW4gb2JqZWN0ICh3aXRoIG9yIHdpdGhvdXQgaGVhZGVyL2Zvb3RlcilcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5zZXRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmxvZyAmJiB0aGlzLmtleSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSBrZXkgd2FzIGFscmVhZHkgc2V0LCBvdmVycmlkaW5nIGV4aXN0aW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtleSA9IG5ldyBKU0VuY3J5cHRSU0FLZXkoa2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3h5IG1ldGhvZCBmb3Igc2V0S2V5LCBmb3IgYXBpIGNvbXBhdGliaWxpdHlcbiAgICAgKiBAc2VlIHNldEtleVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLnNldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAocHJpdmtleSkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGtleS5cbiAgICAgICAgdGhpcy5zZXRLZXkocHJpdmtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIHNldEtleSwgZm9yIGFwaSBjb21wYXRpYmlsaXR5XG4gICAgICogQHNlZSBzZXRLZXlcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAocHVia2V5KSB7XG4gICAgICAgIC8vIFNldHMgdGhlIHB1YmxpYyBrZXkuXG4gICAgICAgIHRoaXMuc2V0S2V5KHB1YmtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIFJTQUtleSBvYmplY3QncyBkZWNyeXB0LCBkZWNyeXB0IHRoZSBzdHJpbmcgdXNpbmcgdGhlIHByaXZhdGVcbiAgICAgKiBjb21wb25lbnRzIG9mIHRoZSByc2Ega2V5IG9iamVjdC4gTm90ZSB0aGF0IGlmIHRoZSBvYmplY3Qgd2FzIG5vdCBzZXQgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogb24gdGhlIGZseSAoYnkgdGhlIGdldEtleSBtZXRob2QpIHVzaW5nIHRoZSBwYXJhbWV0ZXJzIHBhc3NlZCBpbiB0aGUgSlNFbmNyeXB0IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBiYXNlNjQgZW5jb2RlZCBjcnlwdGVkIHN0cmluZyB0byBkZWNyeXB0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZGVjcnlwdGVkIHN0cmluZ1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZGVjcnlwdGVkIHN0cmluZy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmRlY3J5cHQoYjY0dG9oZXgoc3RyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3h5IG1ldGhvZCBmb3IgUlNBS2V5IG9iamVjdCdzIGVuY3J5cHQsIGVuY3J5cHQgdGhlIHN0cmluZyB1c2luZyB0aGUgcHVibGljXG4gICAgICogY29tcG9uZW50cyBvZiB0aGUgcnNhIGtleSBvYmplY3QuIE5vdGUgdGhhdCBpZiB0aGUgb2JqZWN0IHdhcyBub3Qgc2V0IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIG9uIHRoZSBmbHkgKGJ5IHRoZSBnZXRLZXkgbWV0aG9kKSB1c2luZyB0aGUgcGFyYW1ldGVycyBwYXNzZWQgaW4gdGhlIEpTRW5jcnlwdCBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNyeXB0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZW5jcnlwdGVkIHN0cmluZyBlbmNvZGVkIGluIGJhc2U2NFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZW5jcnlwdGVkIHN0cmluZy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoZXgyYjY0KHRoaXMuZ2V0S2V5KCkuZW5jcnlwdChzdHIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3Mgc2lnbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gc2lnblxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpZ2VzdE1ldGhvZCBoYXNoIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaWdlc3ROYW1lIHRoZSBuYW1lIG9mIHRoZSBoYXNoIGFsZ29yaXRobVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHNpZ25hdHVyZSBlbmNvZGVkIGluIGJhc2U2NFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoc3RyLCBkaWdlc3RNZXRob2QsIGRpZ2VzdE5hbWUpIHtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBSU0Egc2lnbmF0dXJlIG9mICdzdHInIGluICdoZXgnIGZvcm1hdC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoZXgyYjY0KHRoaXMuZ2V0S2V5KCkuc2lnbihzdHIsIGRpZ2VzdE1ldGhvZCwgZGlnZXN0TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIFJTQUtleSBvYmplY3QncyB2ZXJpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHZlcmlmeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgdGhlIHNpZ25hdHVyZSBlbmNvZGVkIGluIGJhc2U2NCB0byBjb21wYXJlIHRoZSBzdHJpbmcgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaWdlc3RNZXRob2QgaGFzaCBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBkYXRhIGFuZCBzaWduYXR1cmUgbWF0Y2hcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAoc3RyLCBzaWduYXR1cmUsIGRpZ2VzdE1ldGhvZCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGRlY3J5cHRlZCAnZGlnZXN0JyBvZiB0aGUgc2lnbmF0dXJlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkudmVyaWZ5KHN0ciwgYjY0dG9oZXgoc2lnbmF0dXJlKSwgZGlnZXN0TWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0dGVyIGZvciB0aGUgY3VycmVudCBKU0VuY3J5cHRSU0FLZXkgb2JqZWN0LiBJZiBpdCBkb2Vzbid0IGV4aXN0cyBhIG5ldyBvYmplY3RcbiAgICAgKiB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkXG4gICAgICogQHBhcmFtIHtjYWxsYmFja30gW2NiXSB0aGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGlmIHdlIHdhbnQgdGhlIGtleSB0byBiZSBnZW5lcmF0ZWRcbiAgICAgKiBpbiBhbiBhc3luYyBmYXNoaW9uXG4gICAgICogQHJldHVybnMge0pTRW5jcnlwdFJTQUtleX0gdGhlIEpTRW5jcnlwdFJTQUtleSBvYmplY3RcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgbmV3IGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgICAgICBpZiAoIXRoaXMua2V5KSB7XG4gICAgICAgICAgICAvLyBHZXQgYSBuZXcgcHJpdmF0ZSBrZXkuXG4gICAgICAgICAgICB0aGlzLmtleSA9IG5ldyBKU0VuY3J5cHRSU0FLZXkoKTtcbiAgICAgICAgICAgIGlmIChjYiAmJiB7fS50b1N0cmluZy5jYWxsKGNiKSA9PT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXkuZ2VuZXJhdGVBc3luYyh0aGlzLmRlZmF1bHRfa2V5X3NpemUsIHRoaXMuZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQsIGNiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUga2V5LlxuICAgICAgICAgICAgdGhpcy5rZXkuZ2VuZXJhdGUodGhpcy5kZWZhdWx0X2tleV9zaXplLCB0aGlzLmRlZmF1bHRfcHVibGljX2V4cG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IGtleSB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXkgV0lUSCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcHJpdmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGtleS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZ2V0UHJpdmF0ZUtleSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5XG4gICAgICogSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0cyBhIG5ldyBrZXkgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5IFdJVEhPVVQgaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5QjY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmdldFByaXZhdGVCYXNlS2V5QjY0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgICAqIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdHMgYSBuZXcga2V5IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IFdJVEggaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcHJpdmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGtleS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZ2V0UHVibGljS2V5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgICAqIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdHMgYSBuZXcga2V5IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IFdJVEhPVVQgaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXlCNjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcHJpdmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGtleS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZ2V0UHVibGljQmFzZUtleUI2NCgpO1xuICAgIH07XG4gICAgSlNFbmNyeXB0LnZlcnNpb24gPSBcIjMuMC4wLXJjLjFcIjtcbiAgICByZXR1cm4gSlNFbmNyeXB0O1xufSgpKTtcblxud2luZG93LkpTRW5jcnlwdCA9IEpTRW5jcnlwdDtcblxuZXhwb3J0cy5KU0VuY3J5cHQgPSBKU0VuY3J5cHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBKU0VuY3J5cHQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuXG4vLyBUaGlzIHdpbGwgYmUgYSBwcm9wZXIgaXRlcmFibGUgJ01hcCcgaW4gZW5naW5lcyB0aGF0IHN1cHBvcnQgaXQsXG4vLyBvciBhIGZha2V5LWZha2UgUHNldWRvTWFwIGluIG9sZGVyIHZlcnNpb25zLlxudmFyIE1hcCA9IHJlcXVpcmUoJ3BzZXVkb21hcCcpXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG4vLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG52YXIgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuXG4vLyB1c2Ugc3ltYm9scyBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGp1c3QgX3Byb3BzXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9jZXNzLmVudi5fbm9kZUxSVUNhY2hlRm9yY2VOb1N5bWJvbCAhPT0gJzEnXG52YXIgbWFrZVN5bWJvbFxuaWYgKGhhc1N5bWJvbCkge1xuICBtYWtlU3ltYm9sID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBTeW1ib2woa2V5KVxuICB9XG59IGVsc2Uge1xuICBtYWtlU3ltYm9sID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAnXycgKyBrZXlcbiAgfVxufVxuXG52YXIgTUFYID0gbWFrZVN5bWJvbCgnbWF4JylcbnZhciBMRU5HVEggPSBtYWtlU3ltYm9sKCdsZW5ndGgnKVxudmFyIExFTkdUSF9DQUxDVUxBVE9SID0gbWFrZVN5bWJvbCgnbGVuZ3RoQ2FsY3VsYXRvcicpXG52YXIgQUxMT1dfU1RBTEUgPSBtYWtlU3ltYm9sKCdhbGxvd1N0YWxlJylcbnZhciBNQVhfQUdFID0gbWFrZVN5bWJvbCgnbWF4QWdlJylcbnZhciBESVNQT1NFID0gbWFrZVN5bWJvbCgnZGlzcG9zZScpXG52YXIgTk9fRElTUE9TRV9PTl9TRVQgPSBtYWtlU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpXG52YXIgTFJVX0xJU1QgPSBtYWtlU3ltYm9sKCdscnVMaXN0JylcbnZhciBDQUNIRSA9IG1ha2VTeW1ib2woJ2NhY2hlJylcblxuZnVuY3Rpb24gbmFpdmVMZW5ndGggKCkgeyByZXR1cm4gMSB9XG5cbi8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuZnVuY3Rpb24gTFJVQ2FjaGUgKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExSVUNhY2hlKSkge1xuICAgIHJldHVybiBuZXcgTFJVQ2FjaGUob3B0aW9ucylcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICB2YXIgbWF4ID0gdGhpc1tNQVhdID0gb3B0aW9ucy5tYXhcbiAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICBpZiAoIW1heCB8fFxuICAgICAgISh0eXBlb2YgbWF4ID09PSAnbnVtYmVyJykgfHxcbiAgICAgIG1heCA8PSAwKSB7XG4gICAgdGhpc1tNQVhdID0gSW5maW5pdHlcbiAgfVxuXG4gIHZhciBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gIGlmICh0eXBlb2YgbGMgIT09ICdmdW5jdGlvbicpIHtcbiAgICBsYyA9IG5haXZlTGVuZ3RoXG4gIH1cbiAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsY1xuXG4gIHRoaXNbQUxMT1dfU1RBTEVdID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZVxuICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMFxuICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlXG4gIHRoaXNbTk9fRElTUE9TRV9PTl9TRVRdID0gb3B0aW9ucy5ub0Rpc3Bvc2VPblNldCB8fCBmYWxzZVxuICB0aGlzLnJlc2V0KClcbn1cblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBtYXggY2hhbmdlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdtYXgnLCB7XG4gIHNldDogZnVuY3Rpb24gKG1MKSB7XG4gICAgaWYgKCFtTCB8fCAhKHR5cGVvZiBtTCA9PT0gJ251bWJlcicpIHx8IG1MIDw9IDApIHtcbiAgICAgIG1MID0gSW5maW5pdHlcbiAgICB9XG4gICAgdGhpc1tNQVhdID0gbUxcbiAgICB0cmltKHRoaXMpXG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzW01BWF1cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ2FsbG93U3RhbGUnLCB7XG4gIHNldDogZnVuY3Rpb24gKGFsbG93U3RhbGUpIHtcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9ICEhYWxsb3dTdGFsZVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV1cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ21heEFnZScsIHtcbiAgc2V0OiBmdW5jdGlvbiAobUEpIHtcbiAgICBpZiAoIW1BIHx8ICEodHlwZW9mIG1BID09PSAnbnVtYmVyJykgfHwgbUEgPCAwKSB7XG4gICAgICBtQSA9IDBcbiAgICB9XG4gICAgdGhpc1tNQVhfQUdFXSA9IG1BXG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhfQUdFXVxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG4vLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIGxlbmd0aENhbGN1bGF0b3IgY2hhbmdlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdsZW5ndGhDYWxjdWxhdG9yJywge1xuICBzZXQ6IGZ1bmN0aW9uIChsQykge1xuICAgIGlmICh0eXBlb2YgbEMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxDID0gbmFpdmVMZW5ndGhcbiAgICB9XG4gICAgaWYgKGxDICE9PSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSkge1xuICAgICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsQ1xuICAgICAgdGhpc1tMRU5HVEhdID0gMFxuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChmdW5jdGlvbiAoaGl0KSB7XG4gICAgICAgIGhpdC5sZW5ndGggPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpXG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgICB9LCB0aGlzKVxuICAgIH1cbiAgICB0cmltKHRoaXMpXG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF0gfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ2l0ZW1Db3VudCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGggfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuTFJVQ2FjaGUucHJvdG90eXBlLnJmb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0udGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHZhciBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICB3YWxrZXIgPSBwcmV2XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaFN0ZXAgKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkge1xuICB2YXIgaGl0ID0gbm9kZS52YWx1ZVxuICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSkge1xuICAgICAgaGl0ID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG4gIGlmIChoaXQpIHtcbiAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHNlbGYpXG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgdmFyIG5leHQgPSB3YWxrZXIubmV4dFxuICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgIHdhbGtlciA9IG5leHRcbiAgfVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gay5rZXlcbiAgfSwgdGhpcylcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gay52YWx1ZVxuICB9LCB0aGlzKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzW0RJU1BPU0VdICYmXG4gICAgICB0aGlzW0xSVV9MSVNUXSAmJlxuICAgICAgdGhpc1tMUlVfTElTVF0ubGVuZ3RoKSB7XG4gICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChmdW5jdGlvbiAoaGl0KSB7XG4gICAgICB0aGlzW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgdGhpc1tDQUNIRV0gPSBuZXcgTWFwKCkgLy8gaGFzaCBvZiBpdGVtcyBieSBrZXlcbiAgdGhpc1tMUlVfTElTVF0gPSBuZXcgWWFsbGlzdCgpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgdGhpc1tMRU5HVEhdID0gMCAvLyBsZW5ndGggb2YgaXRlbXMgaW4gdGhlIGxpc3Rcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS5tYXAoZnVuY3Rpb24gKGhpdCkge1xuICAgIGlmICghaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfVxuICAgIH1cbiAgfSwgdGhpcykudG9BcnJheSgpLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgIHJldHVybiBoXG4gIH0pXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wTHJ1ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKG4sIG9wdHMpIHtcbiAgdmFyIHN0ciA9ICdMUlVDYWNoZSB7J1xuICB2YXIgZXh0cmFzID0gZmFsc2VcblxuICB2YXIgYXMgPSB0aGlzW0FMTE9XX1NUQUxFXVxuICBpZiAoYXMpIHtcbiAgICBzdHIgKz0gJ1xcbiAgYWxsb3dTdGFsZTogdHJ1ZSdcbiAgICBleHRyYXMgPSB0cnVlXG4gIH1cblxuICB2YXIgbWF4ID0gdGhpc1tNQVhdXG4gIGlmIChtYXggJiYgbWF4ICE9PSBJbmZpbml0eSkge1xuICAgIGlmIChleHRyYXMpIHtcbiAgICAgIHN0ciArPSAnLCdcbiAgICB9XG4gICAgc3RyICs9ICdcXG4gIG1heDogJyArIHV0aWwuaW5zcGVjdChtYXgsIG9wdHMpXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIG1heEFnZSA9IHRoaXNbTUFYX0FHRV1cbiAgaWYgKG1heEFnZSkge1xuICAgIGlmIChleHRyYXMpIHtcbiAgICAgIHN0ciArPSAnLCdcbiAgICB9XG4gICAgc3RyICs9ICdcXG4gIG1heEFnZTogJyArIHV0aWwuaW5zcGVjdChtYXhBZ2UsIG9wdHMpXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGxjID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl1cbiAgaWYgKGxjICYmIGxjICE9PSBuYWl2ZUxlbmd0aCkge1xuICAgIGlmIChleHRyYXMpIHtcbiAgICAgIHN0ciArPSAnLCdcbiAgICB9XG4gICAgc3RyICs9ICdcXG4gIGxlbmd0aDogJyArIHV0aWwuaW5zcGVjdCh0aGlzW0xFTkdUSF0sIG9wdHMpXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGRpZEZpcnN0ID0gZmFsc2VcbiAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChkaWRGaXJzdCkge1xuICAgICAgc3RyICs9ICcsXFxuICAnXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChleHRyYXMpIHtcbiAgICAgICAgc3RyICs9ICcsXFxuJ1xuICAgICAgfVxuICAgICAgZGlkRmlyc3QgPSB0cnVlXG4gICAgICBzdHIgKz0gJ1xcbiAgJ1xuICAgIH1cbiAgICB2YXIga2V5ID0gdXRpbC5pbnNwZWN0KGl0ZW0ua2V5KS5zcGxpdCgnXFxuJykuam9pbignXFxuICAnKVxuICAgIHZhciB2YWwgPSB7IHZhbHVlOiBpdGVtLnZhbHVlIH1cbiAgICBpZiAoaXRlbS5tYXhBZ2UgIT09IG1heEFnZSkge1xuICAgICAgdmFsLm1heEFnZSA9IGl0ZW0ubWF4QWdlXG4gICAgfVxuICAgIGlmIChsYyAhPT0gbmFpdmVMZW5ndGgpIHtcbiAgICAgIHZhbC5sZW5ndGggPSBpdGVtLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoaXNTdGFsZSh0aGlzLCBpdGVtKSkge1xuICAgICAgdmFsLnN0YWxlID0gdHJ1ZVxuICAgIH1cblxuICAgIHZhbCA9IHV0aWwuaW5zcGVjdCh2YWwsIG9wdHMpLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4gICcpXG4gICAgc3RyICs9IGtleSArICcgPT4gJyArIHZhbFxuICB9KVxuXG4gIGlmIChkaWRGaXJzdCB8fCBleHRyYXMpIHtcbiAgICBzdHIgKz0gJ1xcbidcbiAgfVxuICBzdHIgKz0gJ30nXG5cbiAgcmV0dXJuIHN0clxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICBtYXhBZ2UgPSBtYXhBZ2UgfHwgdGhpc1tNQVhfQUdFXVxuXG4gIHZhciBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICB2YXIgbGVuID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0odmFsdWUsIGtleSlcblxuICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICBpZiAobGVuID4gdGhpc1tNQVhdKSB7XG4gICAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpXG4gICAgdmFyIGl0ZW0gPSBub2RlLnZhbHVlXG5cbiAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgIC8vIHNwbGl0IG91dCBpbnRvIDIgaWZzIGZvciBiZXR0ZXIgY292ZXJhZ2UgdHJhY2tpbmdcbiAgICBpZiAodGhpc1tESVNQT1NFXSkge1xuICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSkge1xuICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpdGVtLm5vdyA9IG5vd1xuICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlXG4gICAgaXRlbS52YWx1ZSA9IHZhbHVlXG4gICAgdGhpc1tMRU5HVEhdICs9IGxlbiAtIGl0ZW0ubGVuZ3RoXG4gICAgaXRlbS5sZW5ndGggPSBsZW5cbiAgICB0aGlzLmdldChrZXkpXG4gICAgdHJpbSh0aGlzKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgaWYgKGhpdC5sZW5ndGggPiB0aGlzW01BWF0pIHtcbiAgICBpZiAodGhpc1tESVNQT1NFXSkge1xuICAgICAgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KVxuICB0aGlzW0NBQ0hFXS5zZXQoa2V5LCB0aGlzW0xSVV9MSVNUXS5oZWFkKVxuICB0cmltKHRoaXMpXG4gIHJldHVybiB0cnVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZVxuICB2YXIgaGl0ID0gdGhpc1tDQUNIRV0uZ2V0KGtleSkudmFsdWVcbiAgaWYgKGlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXNbTFJVX0xJU1RdLnRhaWxcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbFxuICBkZWwodGhpcywgbm9kZSlcbiAgcmV0dXJuIG5vZGUudmFsdWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgLy8gcmVzZXQgdGhlIGNhY2hlXG4gIHRoaXMucmVzZXQoKVxuXG4gIHZhciBub3cgPSBEYXRlLm5vdygpXG4gIC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gIGZvciAodmFyIGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICB2YXIgaGl0ID0gYXJyW2xdXG4gICAgdmFyIGV4cGlyZXNBdCA9IGhpdC5lIHx8IDBcbiAgICBpZiAoZXhwaXJlc0F0ID09PSAwKSB7XG4gICAgICAvLyB0aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAvLyBkb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucHJ1bmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzW0NBQ0hFXS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgZ2V0KHNlbGYsIGtleSwgZmFsc2UpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldCAoc2VsZiwga2V5LCBkb1VzZSkge1xuICB2YXIgbm9kZSA9IHNlbGZbQ0FDSEVdLmdldChrZXkpXG4gIGlmIChub2RlKSB7XG4gICAgdmFyIGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pIGhpdCA9IHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgc2VsZltMUlVfTElTVF0udW5zaGlmdE5vZGUobm9kZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhpdCkgaGl0ID0gaGl0LnZhbHVlXG4gIH1cbiAgcmV0dXJuIGhpdFxufVxuXG5mdW5jdGlvbiBpc1N0YWxlIChzZWxmLCBoaXQpIHtcbiAgaWYgKCFoaXQgfHwgKCFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBzdGFsZSA9IGZhbHNlXG4gIHZhciBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3dcbiAgaWYgKGhpdC5tYXhBZ2UpIHtcbiAgICBzdGFsZSA9IGRpZmYgPiBoaXQubWF4QWdlXG4gIH0gZWxzZSB7XG4gICAgc3RhbGUgPSBzZWxmW01BWF9BR0VdICYmIChkaWZmID4gc2VsZltNQVhfQUdFXSlcbiAgfVxuICByZXR1cm4gc3RhbGVcbn1cblxuZnVuY3Rpb24gdHJpbSAoc2VsZikge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yICh2YXIgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDtcbiAgICAgIHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIHZhciBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGRlbChzZWxmLCB3YWxrZXIpXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlbCAoc2VsZiwgbm9kZSkge1xuICBpZiAobm9kZSkge1xuICAgIHZhciBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKHNlbGZbRElTUE9TRV0pIHtcbiAgICAgIHNlbGZbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKVxuICAgIH1cbiAgICBzZWxmW0xFTkdUSF0gLT0gaGl0Lmxlbmd0aFxuICAgIHNlbGZbQ0FDSEVdLmRlbGV0ZShoaXQua2V5KVxuICAgIHNlbGZbTFJVX0xJU1RdLnJlbW92ZU5vZGUobm9kZSlcbiAgfVxufVxuXG4vLyBjbGFzc3ksIHNpbmNlIFY4IHByZWZlcnMgcHJlZGljdGFibGUgb2JqZWN0cy5cbmZ1bmN0aW9uIEVudHJ5IChrZXksIHZhbHVlLCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gIHRoaXMua2V5ID0ga2V5XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICB0aGlzLm5vdyA9IG5vd1xuICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwXG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBQcm9taXNlV2luZG93XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYW1lcmNpZXIvcHJvbWlzZS13aW5kb3dcbiAqIEBpZ25vcmVcbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHJvb3QgPSB3aW5kb3csXG4gICAgICBwcm90b3R5cGUsXG4gICAgICBodG1sID0gcm9vdC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIE1lcmdlIHRoZSBjb250ZW50cyBvZiB0d28gb3IgbW9yZSBvYmplY3RzIHRvZ2V0aGVyIGludG8gdGhlIGZpcnN0IG9iamVjdC5cbiAgICpcbiAgICogICAgIG1lcmdlKCB0YXJnZXQgWywgb2JqZWN0MSBdIFssIG9iamVjdE4gXSApXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgIEFuIG9iamVjdCB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgbmV3IHByb3BlcnRpZXMgaWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbCBvYmplY3RzIGFyZSBwYXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QxIEFuIG9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBtZXJnZSBpbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdE4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIG1lcmdlIGluLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGZpcnN0IG9iamVjdC5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciBleHRlbmRlZCA9IGFyZ3VtZW50c1swXSwga2V5LCBpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzW2ldLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBleHRlbmRlZFtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHBzZXVkby11bmlxdWUgU3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgYSBwc2V1ZG8tdW5pcXVlIHN0cmluZyBwcmVmaXhlZCB3aXRoIHRoZSBnaXZlbiBwcmVmaXgsIGlmIGFueS5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGVVbmlxdWVTdHJpbmcocHJlZml4KSB7XG4gICAgcmV0dXJuIHByZWZpeCArIG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgXCItXCIgKyBNYXRoLmZsb29yKDEwZTEyICogTWF0aC5yYW5kb20oKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFByb21pc2VXaW5kb3cgb2JqZWN0XG4gICAqXG4gICAqIER1cmluZyB0aGUgbGlmZWN5Y2xlIG9mIHRoaXMgb2JqZWN0LCBwb3B1cCB3aW5kb3dzIGNhbiBiZSBvcGVuZWQsIGNsb3NlZCxcbiAgICogYW5kIHJlb3BlbmVkIGFnYWluLiBIb3dldmVyLCBpdCdcbiAgICpcbiAgICogSW5zdGFuY2lhdGluZyB0aGlzIHByb3RvdHlwZSBkb2VzIG5vdCBpbW1lZGlhdGVseSBvcGVucyBhIG5ldyBwb3B1cCB3aW5kb3cuXG4gICAqIFRvIG9wZW4gdGhlIHdpbmRvdywgdXNlIGBvcGVuKClgIG9uIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9ICAgdXJpICAgICAgICAgICAgICAgICAgICBEZXN0aW5hdGlvbiBVUklcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgY29uZmlnICAgICAgICAgICAgICAgICBDb25maWd1cmF0aW9uIG9iamVjdC4gU2VlIGRlc2NyaXB0aW9uIGJlbG93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gICBjb25maWcud2lkdGggICAgICAgICAgIFdpZHRoIG9mIHRoZSBwb3B1cCB3aW5kb3cuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50IHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gICBjb25maWcuaGVpZ2h0ICAgICAgICAgIEhlaWdodCBvZiB0aGUgcG9wdXAgd2luZG93LiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBkb2N1bWVudCBoZWlnaHQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5wcm9taXNlUHJvdmlkZXIgUHJvbWlzZSBwcm92aWRlci4gU2hvdWxkIHJldHVybiBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIDMgZmllbGRzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYHByb21pc2VgIHtQcm9taXNlfSAgYSBuZXcgUHJvbWlzZSBvYmplY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGByZXNvbHZlYCB7RnVuY3Rpb259IHRoZSBtZXRob2QgdG8gcmVzb2x2ZSB0aGUgZ2l2ZW4gUHJvbWlzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYHJlamVjdGAgIHtGdW5jdGlvbn0gdGhlIG1ldGhvZCB0byByZWplY3QgdGhlIGdpdmVuIFByb21pc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLm9uUG9zdE1lc3NhZ2UgICBIYW5kbGVyIGZvciByZWNlaXZpbmcgYSBwb3N0TWVzc2FnZSBmcm9tIHRoZSBvcGVuZWQgd2luZG93LiBEZWZhdWx0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gcmVzb2x2ZXMgdGhlIHByb21pc2Ugd2l0aCB0aGUgZGF0YSBwYXNzZWQgaW4gdGhlIHBvc3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLCBleGNlcHQgaWYgdGhpcyBkYXRhIGNvbnRhaW5zIGFuIGBlcnJvcmAgZmllbGQuIEluIHRoaXMgY2FzZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCByZWplY3RzIHRoZSBQcm9taXNlIHdpdGggdGhlIHZhbHVlIG9mIHRoYXQgZmllbGQuIEluIGFsbCBjYXNlcywgY2xvc2VzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHBvcHVwIHdpbmRvdy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLm9uUG9zdE1lc3NhZ2UuZXZlbnQgRXZlbnQgVGhlIHBvc3RNZXNzYWdlIGV2ZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgIGNvbmZpZy53YXRjaGVyRGVsYXkgICAgVGhlcmUgaXMgbm8gcHJvZ3JhbW1hdGljIHdheSBvZiBrbm93aW5nIHdoZW4gYSBwb3B1cCB3aW5kb3cgaXMgY2xvc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVpdGhlciBtYW51YWxseSBvciBwcm9ncmFtYXRpY2FsbHkpLiBGb3IgdGhpcyByZWFzb24sIGV2ZXJ5IHRpbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlV2luZG93IG9wZW5zIGEgcG9wdXAsIGEgbmV3IHdhdGNoZXIgaXMgY3JlYXRlZC4gVGhlIHdhdGNoZXIgY2hlY2tzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVndWxhcmx5IGlmIHRoZSB3aW5kb3cgaXMgc3RpbGwgb3Blbi4gVGhpcyB2YWx1ZSBkZWZpbmVzIGF0IHdoaWNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgdGhpcyBjaGVjayBpcyBkb25lLiBEZWZhdWx0cyB0byAxMDBtcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9ICAgY29uZmlnLndpbmRvd05hbWUgICAgICBOYW1lIHRvIGJlIGdpbnZlbiB0byB0aGUgcG9wdXAgd2luZG93LiBTZWUgYHdpbmRvdy5vcGVuYCByZWZlcmVuY2VzIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMuIElmIGBudWxsYCwgYSByYW5kb20gbmFtZSBpcyBnZW5lcmF0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgIGNvbmZpZy53aW5kb3cgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgd2luZG93IGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MuIFNjcm9sbGJhcnMgYXJlIGVuYWJsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSBkZWZhdWx0LiBBbGwgYHdpbmRvdy5vcGVuYCBwdGlvbnMgYXJlIGFjY2VwdGVkLCBidXQgcGxlYXNlIG5vdGUgdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbnkgb2YgdGhlbSBoYXZlIG5vIGVmZmVjdCBpbiBtb3N0IG1vZGVybiBicm93c2Vycy4gU2VlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9vcGVuIGZvciBtb3JlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLm9uQ2xvc2UgICAgICAgICBGdW5jdGlvbiBiZWluZyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHBvcHVwIGlzIGJlaW5nIGNsb3NlZCAoZWl0aGVyIGFmdGVyIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0IG1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQsIG9yIHdpbmRvdyBoYXMgYmVlbiBjbG9zZWQgYnkgdXNlciwgb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLmNsb3NlKClgIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQuIERlZmF1bHQgaW1wbGVtZW50YXRpb24gY2xvc2VzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwIHdpbmRvdyBieSBjYWxsaW5nIGB0aGlzLl93aW5kb3cuY2xvc2UoKWApLlxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gY29uZmlnLm9yaWdpblJlZ2V4cCAgICAgIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgdGhlIG9yaWdpbiBwYXJ0IG9mIGFuIFVSSS4gRGVmYXVsdHMgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgbmV3IFJlZ0V4cCgnXlteOi8/XSs6Ly9bXi9dKicpYC4gSWYgZG9lc24ndCBtYXRjaCAoZXg6IHJlbGF0aXZlIFVSSXMpLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZSBgbG9jYXRpb24ub3JpZ2luYC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBQcm9taXNlV2luZG93KHVyaSwgY29uZmlnKSB7XG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgdGhpcy5jb25maWcgPSBleHRlbmQoe30sIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdENvbmZpZywgY29uZmlnKTtcbiAgICB0aGlzLmNvbmZpZy53aW5kb3dOYW1lID0gdGhpcy5jb25maWcud2luZG93TmFtZSB8fCBnZW5lcmF0ZVVuaXF1ZVN0cmluZygncHJvbWlzZS13aW5kb3ctJyk7XG4gICAgdGhpcy5fb25Qb3N0TWVzc2FnZSA9IHRoaXMuX29uUG9zdE1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBQcm9taXNlIHByb3ZpZGVyIGZyb20gYSBQcm9taXNlL0ErIGNvbnN0cnVjdG9yIHRvIGJlIHVzZWQgd2l0aFxuICAgKiBgY29uZmlnLnByb21pc2VQcm92aWRlcmAuXG4gICAqXG4gICAqICAgICBuZXcgUHJvbWlzZVdpbmRvdyguLi4sIHtcbiAgICogICAgICAgLi4uLFxuICAgKiAgICAgICBwcm9taXNlUHJvdmlkZXI6IFByb21pc2VXaW5kb3cuZ2V0QVBsdXNQcm9taXNlUHJvdmlkZXIoTXlDdXN0b21Qcm9taXNlKVxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBDdXN0b21Qcm9taXNlIFByb21pc2UvQSsgY29udHJ1Y3RvclxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyBhIHByb21pc2UgcHJvdmlkZXJcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgUHJvbWlzZVdpbmRvdy5nZXRBUGx1c1Byb21pc2VQcm92aWRlciA9IGZ1bmN0aW9uIGdldEFQbHVzUHJvbWlzZVByb3ZpZGVyKEN1c3RvbVByb21pc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvbWlzZVByb3ZpZGVyKCkge1xuICAgICAgdmFyIG1vZHVsZSA9IHt9O1xuICAgICAgbW9kdWxlLnByb21pc2UgPSBuZXcgQ3VzdG9tUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbW9kdWxlLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBtb2R1bGUucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3I6XG4gICAqXG4gICAqICAgICBuZXcgUHJvbWlzZVdpbmRvdyh1cmksIGNvbmZpZykub3BlbigpXG4gICAqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCBvbmx5IGlmIHlvdSBuZXZlciBuZWVkIHRvIGNsb3NlIHRoZSB3aW5kb3cgcHJvZ3JhbWF0aWNhbGx5LlxuICAgKiBJZiB5b3UgZG8sIHBsZWFzZSBjb25zaWRlciB1c2luZyB0aGUgY2xhc3NpYyB3YXk6XG4gICAqXG4gICAqICAgICB2YXIgdyA9IG5ldyBQcm9taXNlV2luZG93KHVyaSwgY29uZmlnKVxuICAgKiAgICAgdy5vcGVuKCk7XG4gICAqICAgICAvLyAuLi5cbiAgICogICAgIHcuY2xvc2UoKTtcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIFByb21pc2UgZXF1aXZhbGVudCB0byB0aGUgb25lIHJldHVybmVkIGJ5IGBvcGVuKClgXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIFByb21pc2VXaW5kb3cub3BlbiA9IGZ1bmN0aW9uIG9wZW4odXJpLCBjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VXaW5kb3codXJpLCBjb25maWcpLm9wZW4oKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcgPSB7XG4gICAgd2lkdGg6IGh0bWwuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBodG1sLmNsaWVudEhlaWdodCxcbiAgICB3aW5kb3c6IHtcbiAgICAgIHNjcm9sbGJhcnM6IHRydWVcbiAgICB9LFxuICAgIHdhdGNoZXJEZWxheTogMTAwLFxuICAgIHByb21pc2VQcm92aWRlcjogbnVsbCxcbiAgICBvblBvc3RNZXNzYWdlOiBmdW5jdGlvbiBvblBvc3RNZXNzYWdlKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGF0YS5lcnJvcikge1xuICAgICAgICB0aGlzLl9yZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKGV2ZW50LmRhdGEpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0sXG4gICAgd2luZG93TmFtZTogbnVsbCxcbiAgICBvbkNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3dpbmRvdy5jbG9zZSgpO1xuICAgIH0sXG4gICAgb3JpZ2luUmVnZXhwOiBuZXcgUmVnRXhwKCdeW146Lz9dKzovL1teL10qJylcbiAgfTtcblxuICAvLyBDb25maWd1cmUgZGVmYXVsdCBQcm9taXNlIHByb3ZpZGVyIGZyb20gY3VycmVudCBpbnZpcm9ubWVudFxuICBpZiAocm9vdC5Qcm9taXNlKSB7XG4gICAgUHJvbWlzZVdpbmRvdy5kZWZhdWx0Q29uZmlnLnByb21pc2VQcm92aWRlciA9IFByb21pc2VXaW5kb3cuZ2V0QVBsdXNQcm9taXNlUHJvdmlkZXIocm9vdC5Qcm9taXNlKTtcbiAgfVxuICBlbHNlIGlmIChyb290LlJTVlApIHtcbiAgICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcucHJvbWlzZVByb3ZpZGVyID0gUHJvbWlzZVdpbmRvdy5nZXRBUGx1c1Byb21pc2VQcm92aWRlcihyb290LlJTVlAuUHJvbWlzZSk7XG4gIH1cbiAgZWxzZSBpZiAocm9vdC5RKSB7XG4gICAgUHJvbWlzZVdpbmRvdy5kZWZhdWx0Q29uZmlnLnByb21pc2VQcm92aWRlciA9IFByb21pc2VXaW5kb3cuZ2V0QVBsdXNQcm9taXNlUHJvdmlkZXIocm9vdC5RLlByb21pc2UpO1xuICB9XG4gIGVsc2UgaWYgKHJvb3QualF1ZXJ5KSB7XG4gICAgUHJvbWlzZVdpbmRvdy5kZWZhdWx0Q29uZmlnLnByb21pc2VQcm92aWRlciA9IGZ1bmN0aW9uIHByb21pc2VQcm92aWRlcigpIHtcbiAgICAgIHZhciBkZWZlcnJlZCA9IHJvb3QualF1ZXJ5LkRlZmVycmVkKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBkZWZlcnJlZC5wcm9taXNlKCksXG4gICAgICAgIHJlc29sdmU6IGRlZmVycmVkLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogZGVmZXJyZWQucmVqZWN0XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgUHJvbWlzZVdpbmRvdy5kZWZhdWx0Q29uZmlnLnByb21pc2VQcm92aWRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByb21pc2VQcm92aWRlciBpbiBQcm9taXNlV2luZG93IGNvbmZpZ3VyYXRpb24nKTtcbiAgICB9O1xuICB9XG5cbiAgcHJvdG90eXBlID0gUHJvbWlzZVdpbmRvdy5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgYSBib29sZWFuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB2YWx1ZSBpcyBhIGJvb2xlYW4sIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5faXNCb29sZWFuID0gZnVuY3Rpb24gX2lzQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgY29uZmlnIHZhbHVlIGludG8gYSB2YWx1ZSBjb21wYXRpYmxlIHdpdGggYHdpbmRvdy5vcGVuYC5cbiAgICogSWYgdmFsdWUgaXMgYSBib29sZWFuLCBjb252ZXJ0IGl0IHRvICd5ZXMnIG9yICdubycsIG90aGVyd2lzZSBzaW1wbHlcbiAgICogY2FzdHMgaXQgaW50byBhIHN0cmluZy5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb252ZXJ0ZWQgdmFsdWVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9zZXJpYWxpemVGZWF0dXJlVmFsdWUgPSBmdW5jdGlvbiBfc2VyaWFsaXplRmVhdHVyZVZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5faXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gJ3llcycgOiAnbm8nO1xuICAgIH1cbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBsZWZ0IGFuZCB0b3AgcG9zaXRpb24gaW4gdGhlIHNjcmVlbiBmb3IgYSByZWN0YW5nbGUsIHRha2luZ1xuICAgKiBkdWFsLXNjcmVlbiBwb3NpdGlvbiBpbnRvIGFjY291bnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHBvc2l0aW9uIEEgbmV3IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSByZWN0YW5nbGUsIGNlbnRlcmVkXG4gICAqIEByZXR1cm4ge051bWJlcn0gcG9zaXRpb24ubGVmdCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXJlZCByZWN0YW5nbGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBwb3NpdGlvbi50b3AgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyZWQgcmVjdGFuZ2xlXG4gICAqIEByZXR1cm4ge051bWJlcn0gcG9zaXRpb24ud2lkdGggVGhlIHdpZHRoIG9mIHRoZSBjZW50ZXJlZCByZWN0YW5nbGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBwb3NpdGlvbi5oZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgY2VudGVyZWQgcmVjdGFuZ2xlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fZ2V0Q2VudGVyZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIF9nZXRDZW50ZXJlZFBvc2l0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZHVhbFNjcmVlbkxlZnQgPSByb290LnNjcmVlbkxlZnQgIT09IHVuZGVmaW5lZCA/IHJvb3Quc2NyZWVuTGVmdCA6IHNjcmVlbi5sZWZ0LFxuICAgICAgICBkdWFsU2NyZWVuVG9wID0gcm9vdC5zY3JlZW5Ub3AgIT09IHVuZGVmaW5lZCA/IHJvb3Quc2NyZWVuVG9wIDogc2NyZWVuLnRvcCxcbiAgICAgICAgdyA9IHJvb3QuaW5uZXJXaWR0aCB8fCBodG1sLmNsaWVudFdpZHRoIHx8IHNjcmVlbi53aWR0aCxcbiAgICAgICAgaCA9IHJvb3QuaW5uZXJIZWlnaHQgfHwgaHRtbC5jbGllbnRIZWlnaHQgfHwgc2NyZWVuLmhlaWdodDtcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAodyAvIDIpIC0gKHdpZHRoIC8gMikgKyBkdWFsU2NyZWVuTGVmdCxcbiAgICAgIHRvcDogIChoIC8gMikgLSAoaGVpZ2h0IC8gMikgKyBkdWFsU2NyZWVuVG9wLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgd2luZG93IGZlYXR1cmVzIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIHdpbmRvdyBmZWF0dXJlcyBjb21wYXRpYmxlIHdpdGggYHdpbmRvdy5vcGVuYFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX2dldEZlYXR1cmVzID0gZnVuY3Rpb24gX2dldEZlYXR1cmVzKCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLl9nZXRDZW50ZXJlZFBvc2l0aW9uKHRoaXMuY29uZmlnLndpZHRoLCB0aGlzLmNvbmZpZy5oZWlnaHQpO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbmZpZy53aW5kb3cpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy53aW5kb3cuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuY29uZmlnLndpbmRvd1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25maWcpXG4gICAgICAubWFwKGZ1bmN0aW9uKGtleSkgeyByZXR1cm4ga2V5ICsgJz0nICsgdGhpcy5fc2VyaWFsaXplRmVhdHVyZVZhbHVlKGtleSwgY29uZmlnW2tleV0pOyB9LmJpbmQodGhpcykpXG4gICAgICAuam9pbignLCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFByb21pc2UsIHVzaW5nIGBjb25maWcucHJvbWlzZVByb3ZpZGVyYCwgYW5kIHNhdmUgcmVqZWN0IGFuZFxuICAgKiByZXNvbHZlIG1ldGhvZHMgZm9yIGxhdGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIHRoZSBuZXcgUHJvbWlzZSBvYmplY3QgY3JlYXRlZCBieSB0aGUgY29uZmlndXJlZFxuICAgKiAgICAgICAgICAgICAgICAgICBQcm9taXNlIFByb3ZpZGVyLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX2NyZWF0ZVByb21pc2UgPSBmdW5jdGlvbiBfY3JlYXRlUHJvbWlzZSgpIHtcbiAgICB2YXIgbW9kdWxlID0gdGhpcy5jb25maWcucHJvbWlzZVByb3ZpZGVyKCk7XG4gICAgdGhpcy5fcmVzb2x2ZSA9IG1vZHVsZS5yZXNvbHZlO1xuICAgIHRoaXMuX3JlamVjdCA9IG1vZHVsZS5yZWplY3Q7XG4gICAgcmV0dXJuIG1vZHVsZS5wcm9taXNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgd2luZG93IGlzIGFsaXZlIG9yIG5vdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgd2luZG93IGlzIGFsaXZlLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX2lzV2luZG93QWxpdmUgPSBmdW5jdGlvbiBfaXNXaW5kb3dBbGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2luZG93ICYmICF0aGlzLl93aW5kb3cuY2xvc2VkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBvcHVwIHdpbmRvdyB3YXRjaGVyLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX3N0YXJ0V2F0Y2hlciA9IGZ1bmN0aW9uIF9zdGFydFdhdGNoZXIoKSB7XG4gICAgaWYgKHRoaXMuX3dhdGNoZXJSdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhdGNoZXIgaXMgYWxyZWFkeSBzdGFydGVkJyk7XG4gICAgfVxuICAgIHRoaXMuX3dhdGNoZXIgPSByb290LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl93YXRjaGVyUnVubmluZyAmJiAhdGhpcy5faXNXaW5kb3dBbGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyksIHRoaXMuY29uZmlnLndhdGNoZXJEZWxheSk7XG4gICAgdGhpcy5fd2F0Y2hlclJ1bm5pbmcgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgcG9wdXAgd2luZG93IHdhdGNoZXIuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fc3RvcFdhdGNoZXIgPSBmdW5jdGlvbiBfc3RvcFdhdGNoZXIoKSB7XG4gICAgaWYgKCF0aGlzLl93YXRjaGVyUnVubmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYXRjaGVyIGlzIGFscmVhZHkgc3RvcHBlZCcpO1xuICAgIH1cbiAgICB0aGlzLl93YXRjaGVyUnVubmluZyA9IGZhbHNlO1xuICAgIHJvb3QuY2xlYXJJbnRlcnZhbCh0aGlzLl93YXRjaGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIHBvc3QgbWVzc2FnZSBldmVudHMuIElmIGFuZCBvbmx5IG9mIHRoZSBldmVudCBoYXMgYmVlblxuICAgKiBnZW5lcmF0ZWQgZnJvbSB0aGUgb3BlbmVkIHBvcHVwIHdpbmRvdywgaXQgcHJvcGFnYXRlcyBpdCB0byB0aGUgY29uZmlndXJlZFxuICAgKiBwb3N0IG1lc3NhZ2UgaGFuZGxlciAoYGNvbmZpZy5vblBvc3RNZXNzYWdlYCkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBwb3N0TWVzc2FnZSBldmVudFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX29uUG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiBfb25Qb3N0TWVzc2FnZShldmVudCkge1xuICAgIHZhciBleHBlY3RlZE9yaWdpbk1hdGNoZXMgPSB0aGlzLmNvbmZpZy5vcmlnaW5SZWdleHAuZXhlYyh0aGlzLnVyaSk7XG4gICAgdmFyIGV4cGVjdGVkT3JpZ2luID0gZXhwZWN0ZWRPcmlnaW5NYXRjaGVzICYmIGV4cGVjdGVkT3JpZ2luTWF0Y2hlc1swXSB8fCBsb2NhdGlvbi5vcmlnaW47XG4gICAgaWYgKHRoaXMuX3dpbmRvdyA9PT0gZXZlbnQuc291cmNlICYmIGV2ZW50Lm9yaWdpbiA9PT0gZXhwZWN0ZWRPcmlnaW4pIHtcbiAgICAgIHRoaXMuY29uZmlnLm9uUG9zdE1lc3NhZ2UuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBVUklcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVyaSBUaGUgbmV3IFVSSVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHdpbmRvdyBpcyBvcGVuXG4gICAqIEByZXR1cm4ge1Byb21pc2VXaW5kb3d9IFJldHVybnMgdGhpcyBvYmplY3QgdG8gYWxsb3cgY2hhaW5pbmdcbiAgICovXG4gIHByb3RvdHlwZS5zZXRVUkkgPSBmdW5jdGlvbiBzZXRVUkkodXJpKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNoYW5nZSB0aGUgVVJJIHdoaWxlIHRoZSB3aW5kb3cgaXMgb3BlbicpO1xuICAgIH1cbiAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogT3BlbnMgYSBuZXcgcG9wdXAgd2luZG93LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgbmV3IGBQcm9taXNlYCBvYmplY3QuIFRoaXMgcHJvbWlzZSB3aWxsIGJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHJlamVjdGVkIHdpdGggYFwiYmxvY2tlZFwiYCBtZXNzYWdlIGlmIHRoZSBwb3B1cCB3aW5kb3dcbiAgICogICAgICAgICAgICAgICAgICAgICBkb2VzIG5vdCBvcGVuIGZvciBhbnkgcmVhc29uIChwb3B1cCBibG9ja2VyLCBldGMuLi4pXG4gICAqICAgICAgICAgICAgICAgICAgIC0gcmVqZWN0ZWQgd2l0aCBgXCJjbG9zZWRcImAgaWYgY2xvc2VkIGVpdGhlciBtYW51YWxseSBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSB1c2VyLCBvciBwcm9ncmFtYXRpY2FsbHlcbiAgICogICAgICAgICAgICAgICAgICAgLSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBlcnJvciBpZiB0aGUgd2ViIHBhZ2Ugb3BlbmVkIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgdGhlIHBvcHVwIHNlbmRzIGEgcG9zdCBtZXNzYWdlIHdpdGggYSBgZXJyb3JgIGRhdGEgZmllbGQuXG4gICAqICAgICAgICAgICAgICAgICAgIC0gcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBpZiB0aGUgd2ViIHBhZ2Ugb3BlbmVkIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgdGhlIHBvcHVwIHNlbmRzIGEgcG9zdCBtZXNzYWdlIHdpdGhvdXQgYSBgZXJyb3JgIGRhdGFcbiAgICogICAgICAgICAgICAgICAgICAgICBmaWVsZC5cbiAgICovXG4gIHByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gb3BlbigpIHtcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaW5kb3cgaXMgYWxyZWFkeSBvcGVuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2luZG93T3BlbiA9IHRydWU7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9jcmVhdGVQcm9taXNlKCk7XG4gICAgdGhpcy5fd2luZG93ID0gcm9vdC5vcGVuKFxuICAgICAgdGhpcy51cmksXG4gICAgICB0aGlzLmNvbmZpZy53aW5kb3dOYW1lLFxuICAgICAgdGhpcy5fZ2V0RmVhdHVyZXMoKVxuICAgICk7XG4gICAgaWYgKCF0aGlzLl93aW5kb3cpIHtcbiAgICAgIHRoaXMuX3JlamVjdChcImJsb2NrZWRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vblBvc3RNZXNzYWdlLCB0cnVlKTtcbiAgICAgIHRoaXMuX3N0YXJ0V2F0Y2hlcigpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBwb3B1cCB3aW5kb3cuXG4gICAqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBwcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2luZG93IGlzIGFscmVhZHkgY2xvc2VkJyk7XG4gICAgfVxuICAgIHRoaXMuX3N0b3BXYXRjaGVyKCk7XG4gICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vblBvc3RNZXNzYWdlKTtcbiAgICBpZiAodGhpcy5faXNXaW5kb3dBbGl2ZSgpKSB7XG4gICAgICB0aGlzLmNvbmZpZy5vbkNsb3NlLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX3JlamVjdChcImNsb3NlZFwiKTtcbiAgICB0aGlzLl93aW5kb3cgPSBudWxsO1xuICAgIHRoaXMuX3dpbmRvd09wZW4gPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHdpbmRvdyBpcyBvcGVuIG9yIG5vdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgd2luZG93IGlzIG9wZW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBwcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl93aW5kb3dPcGVuO1xuICB9O1xuXG4gIC8vIEV4cG9ydHMgUHJvbWlzZVdpbmRvdyB0byB0aGUgZ2xvYmFsIHNjb3BlXG4gIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgncHJvbWlzZS13aW5kb3cnLCBbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBQcm9taXNlV2luZG93IH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gUHJvbWlzZVdpbmRvdztcbiAgfSBlbHNlIHtcbiAgICByb290LlByb21pc2VXaW5kb3cgPSBQcm9taXNlV2luZG93O1xuICB9XG4gIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbn0pKCk7XG4iLCJpZiAocHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfbmFtZSA9PT0gJ3BzZXVkb21hcCcgJiZcbiAgICBwcm9jZXNzLmVudi5ucG1fbGlmZWN5Y2xlX3NjcmlwdCA9PT0gJ3Rlc3QnKVxuICBwcm9jZXNzLmVudi5URVNUX1BTRVVET01BUCA9ICd0cnVlJ1xuXG5pZiAodHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAhcHJvY2Vzcy5lbnYuVEVTVF9QU0VVRE9NQVApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBNYXBcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wc2V1ZG9tYXAnKVxufVxuIiwidmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBzZXVkb01hcFxuXG5mdW5jdGlvbiBQc2V1ZG9NYXAgKHNldCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHNldWRvTWFwKSkgLy8gd2h5eXl5eXl5XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIFBzZXVkb01hcCByZXF1aXJlcyAnbmV3J1wiKVxuXG4gIHRoaXMuY2xlYXIoKVxuXG4gIGlmIChzZXQpIHtcbiAgICBpZiAoKHNldCBpbnN0YW5jZW9mIFBzZXVkb01hcCkgfHxcbiAgICAgICAgKHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgc2V0IGluc3RhbmNlb2YgTWFwKSlcbiAgICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2V0KSlcbiAgICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uIChrdikge1xuICAgICAgICB0aGlzLnNldChrdlswXSwga3ZbMV0pXG4gICAgICB9LCB0aGlzKVxuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKVxuICB9XG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIE9iamVjdC5rZXlzKHRoaXMuX2RhdGEpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayAhPT0gJ3NpemUnKVxuICAgICAgZm4uY2FsbCh0aGlzcCwgdGhpcy5fZGF0YVtrXS52YWx1ZSwgdGhpcy5fZGF0YVtrXS5rZXkpXG4gIH0sIHRoaXMpXG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGspIHtcbiAgcmV0dXJuICEhZmluZCh0aGlzLl9kYXRhLCBrKVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrKSB7XG4gIHZhciByZXMgPSBmaW5kKHRoaXMuX2RhdGEsIGspXG4gIHJldHVybiByZXMgJiYgcmVzLnZhbHVlXG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGssIHYpIHtcbiAgc2V0KHRoaXMuX2RhdGEsIGssIHYpXG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGspIHtcbiAgdmFyIHJlcyA9IGZpbmQodGhpcy5fZGF0YSwgaylcbiAgaWYgKHJlcykge1xuICAgIGRlbGV0ZSB0aGlzLl9kYXRhW3Jlcy5faW5kZXhdXG4gICAgdGhpcy5fZGF0YS5zaXplLS1cbiAgfVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgZGF0YS5zaXplID0gMFxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2RhdGEnLCB7XG4gICAgdmFsdWU6IGRhdGEsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHNldWRvTWFwLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnNpemVcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAobikge30sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSlcblxuUHNldWRvTWFwLnByb3RvdHlwZS52YWx1ZXMgPVxuUHNldWRvTWFwLnByb3RvdHlwZS5rZXlzID1cblBzZXVkb01hcC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYXRvcnMgYXJlIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIHZlcnNpb24nKVxufVxuXG4vLyBFaXRoZXIgaWRlbnRpY2FsLCBvciBib3RoIE5hTlxuZnVuY3Rpb24gc2FtZSAoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYiB8fCBhICE9PSBhICYmIGIgIT09IGJcbn1cblxuZnVuY3Rpb24gRW50cnkgKGssIHYsIGkpIHtcbiAgdGhpcy5rZXkgPSBrXG4gIHRoaXMudmFsdWUgPSB2XG4gIHRoaXMuX2luZGV4ID0gaVxufVxuXG5mdW5jdGlvbiBmaW5kIChkYXRhLCBrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBzID0gJ18nICsgaywga2V5ID0gcztcbiAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgICAga2V5ID0gcyArIGkrKykge1xuICAgIGlmIChzYW1lKGRhdGFba2V5XS5rZXksIGspKVxuICAgICAgcmV0dXJuIGRhdGFba2V5XVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCAoZGF0YSwgaywgdikge1xuICBmb3IgKHZhciBpID0gMCwgcyA9ICdfJyArIGssIGtleSA9IHM7XG4gICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgICAgIGtleSA9IHMgKyBpKyspIHtcbiAgICBpZiAoc2FtZShkYXRhW2tleV0ua2V5LCBrKSkge1xuICAgICAgZGF0YVtrZXldLnZhbHVlID0gdlxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGRhdGEuc2l6ZSsrXG4gIGRhdGFba2V5XSA9IG5ldyBFbnRyeShrLCB2LCBrZXkpXG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbCwgcmV0KSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLCByZWosIGNiKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcHVzaCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0IChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZilcbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWRcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIE5vZGUgKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdClcbiAgfVxuXG4gIHRoaXMubGlzdCA9IGxpc3RcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzXG4gICAgdGhpcy5wcmV2ID0gcHJldlxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGxcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpc1xuICAgIHRoaXMubmV4dCA9IG5leHRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0Q3VycmVudFVzZXI6ICgpID0+IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2N1cnJlbnRVc2VyJykpLFxuICBzZXRDdXJyZW50VXNlcjogKHVzZXIpID0+IGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50VXNlcicsIEpTT04uc3RyaW5naWZ5KHVzZXIpKSxcbiAgZ2V0VXNlckFwaUtleTogKCkgPT4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJBcGlLZXknKSxcbiAgc2V0VXNlckFwaUtleTogKGFwaUtleSkgPT4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXJBcGlLZXknLCBhcGlLZXkpLFxuICBoYXNVc2VyQXBpS2V5OiAoKSA9PiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlckFwaUtleScpICE9PSBudWxsLFxuICBnZXRBcHBQcm9wOiAoYXBwSWQsIG5hbWUpID0+IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGFwcElkICsgJ18nICsgbmFtZSksXG4gIHNldEFwcFByb3A6IChhcHBJZCwgbmFtZSwgc3RvcmVkUHJvcCkgPT4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oYXBwSWQgKyAnXycgKyBuYW1lLCBzdG9yZWRQcm9wKSxcbiAgcmVtb3ZlQXBwUHJvcDogKGFwcElkLCBuYW1lKSA9PiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShhcHBJZCArICdfJyArIG5hbWUpLFxuICBjbGVhckF1dGhEYXRhOiAoYXBwSWQpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlckFwaUtleScpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdjdXJyZW50VXNlcicpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGFwcElkICsgJ19jbGllbnRJZCcpO1xuICB9XG59O1xuIiwiaW1wb3J0IERpc2NvdXJzZUF1dGggZnJvbSAnLi9kaXNjb3Vyc2VBdXRoJztcbmltcG9ydCBEaXNjb3Vyc2VDbGllbnQgZnJvbSAnLi9kaXNjb3Vyc2VDbGllbnQnO1xuaW1wb3J0IGF1dGhNYW5hZ2VyIGZyb20gJy4vYXV0aE1hbmFnZXInO1xuaW1wb3J0IFByb21pc2VXaW5kb3cgZnJvbSAncHJvbWlzZS13aW5kb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXNjb3Vyc2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5fcmVxdWlyZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5fZm9ybWF0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmF1dGggPSBuZXcgRGlzY291cnNlQXV0aCh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IERpc2NvdXJzZUNsaWVudCh0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5hdXRoLmluaXQoKSwgdGhpcy5jbGllbnQuaW5pdCgpXSk7XG4gIH1cblxuICBfcmVxdWlyZU9wdGlvbnMob3B0aW9ucykge1xuICAgIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgfHxcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICh0eXBlb2Ygb3B0aW9ucy5hcHBOYW1lID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmFwcE5hbWUubGVuZ3RoID4gMCkgfHxcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5hcHBOYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgKHR5cGVvZiBvcHRpb25zLmFwaUJhc2VVcmwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuYXBpQmFzZVVybC5sZW5ndGggPiAwKSB8fFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zLmFwaUJhc2VVcmwgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAob3B0aW9ucy5zY29wZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBvcHRpb25zLnNjb3Blcy5sZW5ndGggPiAwKSB8fFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zLnNjb3BlcyBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5Jyk7XG4gIH1cblxuICBfZm9ybWF0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgZm9ybWF0dGVkT3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gICAgZm9ybWF0dGVkT3B0aW9ucy5hcHBJZCA9IHRoaXMuX3NsdWdpZnkob3B0aW9ucy5hcHBOYW1lKTtcbiAgICBmb3JtYXR0ZWRPcHRpb25zLmFwaUJhc2VVcmwgPSBvcHRpb25zLmFwaUJhc2VVcmwucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICBmb3JtYXR0ZWRPcHRpb25zLnNjb3BlcyA9IG9wdGlvbnMuc2NvcGVzLmpvaW4oJywnKTtcbiAgICByZXR1cm4gZm9ybWF0dGVkT3B0aW9ucztcbiAgfVxuXG4gIF9zbHVnaWZ5KHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC50b1N0cmluZygpLnRvTG93ZXJDYXNlKClcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICctJylcbiAgICAgIC5yZXBsYWNlKC9bXlxcd1xcLV0rL2csICcnKVxuICAgICAgLnJlcGxhY2UoL1xcLVxcLSsvZywgJy0nKVxuICAgICAgLnJlcGxhY2UoL14tKy8sICcnKVxuICAgICAgLnJlcGxhY2UoLy0rJC8sICcnKTtcbiAgfVxuXG4gIGdldEFwaUJhc2VVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hcGlCYXNlVXJsO1xuICB9XG5cbiAgYXN5bmMgbG9naW4oKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMuaXNMb2dnZWRJbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZVdpbmRvdy5vcGVuKGF3YWl0IHRoaXMuYXV0aC5fZ2V0TG9naW5VcmwoKSwge1xuICAgICAgd2lkdGg6IDcwMCxcbiAgICAgIGhlaWdodDogNjUwLFxuICAgICAgb3JpZ2luUmVnZXhwOiBuZXcgUmVnRXhwKCdeJyArIGxvY2F0aW9uLm9yaWdpbilcbiAgICB9KS50aGVuKGFzeW5jIGRhdGEgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQuX3NldFVzZXJBcGlLZXkoZGF0YS5yZXN1bHQua2V5KTtcbiAgICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hDdXJyZW50VXNlcigpO1xuICAgIH0sXG5cbiAgICAvLyBFcnJvclxuICAgIChlcnJvcikgPT4ge1xuICAgICAgc3dpdGNoIChlcnJvcikge1xuICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdkaXNjb3Vyc2VMb2dpbkNhbmNlbGVkJykpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gcG9wdXAgd2luZG93IGNsb3NlZCBieSB0aGUgdXNlcicpO1xuICAgICAgICBjYXNlICdibG9ja2VkJzpcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZGlzY291cnNlTG9naW5CbG9ja2VkJykpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gcG9wdXAgd2luZG93IGJsb2NrZWQgYnkgdGhlIGJyb3dzZXInKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHBvcHVwIHdpbmRvdyByZXR1cm5lZCBhbiBlcnJvcjogJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKCkgPT4gZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Rpc2NvdXJzZUxvZ2dlZEluJykpKTtcbiAgfVxuXG4gIGFzeW5jIGxvZ291dCgpIHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5fZG9Mb2dvdXQodGhpcy5nZXRDdXJyZW50VXNlck5hbWUoKSk7XG4gICAgYXV0aE1hbmFnZXIuY2xlYXJBdXRoRGF0YSh0aGlzLm9wdGlvbnMuYXBwSWQpO1xuICAgIGRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdkaXNjb3Vyc2VMb2dnZWRPdXQnKSk7XG4gIH1cblxuICBhc3luYyBnZXRDdXJyZW50U2Vzc2lvblVzZXIoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50Ll9nZXRDYWxsUmVzdWx0KCcvc2Vzc2lvbi9jdXJyZW50Lmpzb24nLCAnY3VycmVudF91c2VyJywgdHJ1ZSk7XG4gIH1cblxuICBhc3luYyBpc0xvZ2dlZEluKCkge1xuICAgIGlmICghYXV0aE1hbmFnZXIuaGFzVXNlckFwaUtleSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hDdXJyZW50VXNlcigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBnZXRDdXJyZW50VXNlcigpIHtcbiAgICByZXR1cm4gYXV0aE1hbmFnZXIuZ2V0Q3VycmVudFVzZXIoKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VyTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VXNlcigpICYmIHRoaXMuZ2V0Q3VycmVudFVzZXIoKVsndXNlcm5hbWUnXTtcbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VySWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFVzZXIoKSAmJiB0aGlzLmdldEN1cnJlbnRVc2VyKClbJ2lkJ107XG4gIH1cblxuICBnZXRDdXJyZW50VXNlckRpc3BsYXlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRVc2VyKCkgJiYgdGhpcy5nZXRDdXJyZW50VXNlcigpWyduYW1lJ107XG4gIH1cblxuICBpc0N1cnJlbnRVc2VyU2lsZW5jZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFVzZXIoKSAmJiAhdGhpcy5nZXRDdXJyZW50VXNlcigpWydjYW5fY3JlYXRlX3RvcGljJ107XG4gIH1cblxuICBnZXRDdXJyZW50VXNlckF2YXRhclVybChzaXplKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFVzZXIoKSAmJiBbXG4gICAgICB0aGlzLm9wdGlvbnMuYXBpQmFzZVVybCxcbiAgICAgIHRoaXMuZ2V0Q3VycmVudFVzZXIoKVsnYXZhdGFyX3RlbXBsYXRlJ10ucmVwbGFjZSgne3NpemV9JywgKHNpemUgfHwgMTEwKSlcbiAgICBdLmpvaW4oJy8nKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VyTm90aWZpY2F0aW9uc1VybCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VXNlcigpICYmIFtcbiAgICAgIHRoaXMub3B0aW9ucy5hcGlCYXNlVXJsLFxuICAgICAgJ3UnLFxuICAgICAgdGhpcy5nZXRDdXJyZW50VXNlck5hbWUoKSxcbiAgICAgICdub3RpZmljYXRpb25zJ1xuICAgIF0uam9pbignLycpO1xuICB9XG5cbiAgYXN5bmMgX3JlZnJlc2hDdXJyZW50VXNlcigpIHtcbiAgICB0cnkge1xuICAgICAgYXV0aE1hbmFnZXIuc2V0Q3VycmVudFVzZXIoYXdhaXQgdGhpcy5nZXRDdXJyZW50U2Vzc2lvblVzZXIoKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nb3V0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBsb2dnZWQgaW4uJyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0TGF0ZXN0UG9zdHMoZGVzY2VuZGluZykge1xuICAgIGxldCBwb3N0cztcblxuICAgIHRyeSB7XG4gICAgICBwb3N0cyA9IGF3YWl0IHRoaXMuY2xpZW50Ll9nZXRDYWxsUmVzdWx0KCcvcG9zdHMuanNvbicsICdsYXRlc3RfcG9zdHMnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoZGVzY2VuZGluZykge1xuICAgICAgcG9zdHMgPSBwb3N0cy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc3RzLmZpbHRlcihwb3N0ID0+IHBvc3QucG9zdF90eXBlID09PSAxKTtcbiAgfVxuXG4gIGFzeW5jIGdldFBvc3RzSW5Ub3BpYyh0b3BpY0lkLCBkZXNjZW5kaW5nLCBub2NhY2hlID0gZmFsc2UpIHtcbiAgICBsZXQgcG9zdHMgPSBhd2FpdCB0aGlzLmNsaWVudC5fZ2V0Q2FsbFJlc3VsdCgnL3QvJyArIHRvcGljSWQgKyAnL3Bvc3RzLmpzb24/aW5jbHVkZV9yYXc9dHJ1ZScsXG4gICAgICAncG9zdF9zdHJlYW0ucG9zdHMnLCBub2NhY2hlKTtcblxuICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICBwb3N0cyA9IHBvc3RzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zdHMuZmlsdGVyKHBvc3QgPT4gcG9zdC5wb3N0X3R5cGUgPT09IDEpO1xuICB9XG5cbiAgYXN5bmMgZ2V0VG9waWModG9waWNJZCwgZGVzY2VuZGluZywgbm9jYWNoZSA9IGZhbHNlKSB7XG4gICAgbGV0IHRvcGljID0gYXdhaXQgdGhpcy5jbGllbnQuX2dldENhbGxSZXN1bHQoJy90LycgKyB0b3BpY0lkICsgJy5qc29uP2luY2x1ZGVfcmF3PXRydWUnLCBmYWxzZSwgbm9jYWNoZSk7XG5cbiAgICB0b3BpYy5wb3N0X3N0cmVhbS5wb3N0cyA9IHRvcGljLnBvc3Rfc3RyZWFtLnBvc3RzLmZpbHRlcihwb3N0ID0+IHBvc3QucG9zdF90eXBlID09PSAxKTtcblxuICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICB0b3BpYy5wb3N0X3N0cmVhbS5wb3N0cyA9IHRvcGljLnBvc3Rfc3RyZWFtLnBvc3RzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9waWM7XG4gIH1cblxuICBhc3luYyBnZXRQdWJsaWNVc2VyRmllbGRzKHVzZXJuYW1lKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50Ll9nZXRDYWxsUmVzdWx0KCcvdS8nICsgdXNlcm5hbWUgKyAnLmpzb24/c3RhdHM9ZmFsc2UnLCAndXNlci51c2VyX2ZpZWxkcycpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHVibGljVXNlckZpZWxkKHVzZXJuYW1lLCBmaWVsZCkge1xuICAgIGNvbnN0IHVzZXJGaWVsZHMgPSBhd2FpdCB0aGlzLmdldFB1YmxpY1VzZXJGaWVsZHModXNlcm5hbWUpO1xuXG4gICAgcmV0dXJuIHVzZXJGaWVsZHMgJiYgdXNlckZpZWxkc1tmaWVsZF07XG4gIH1cblxuICBhc3luYyBwb3N0TWVzc2FnZSh0b3BpY0lkLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5jbGllbnQuX2NoZWNrVXNlckFwaUtleSgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5fcG9zdENhbGxSZXN1bHQoJy9wb3N0cy5qc29uJywge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICB0b3BpY19pZDogdG9waWNJZCxcbiAgICAgIHJhdzogbWVzc2FnZVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIHJlc3BvbnNlLmhpZGRlbiAmJiBQcm9taXNlLnJlamVjdChyZXNwb25zZS5oaWRkZW5fcmVhc29uX2lkKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiBQcm9taXNlLnJlamVjdChlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycykpO1xuICB9XG5cbiAgYXN5bmMgbGlrZVBvc3QocG9zdElkKSB7XG4gICAgdGhpcy5jbGllbnQuX2NoZWNrVXNlckFwaUtleSgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5fcG9zdENhbGxSZXN1bHQoJy9wb3N0X2FjdGlvbnMnLCB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgIGlkOiBwb3N0SWQsXG4gICAgICBwb3N0X2FjdGlvbl90eXBlX2lkOiAyXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIH0pLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UpLmNhdGNoKGVycm9yID0+IFByb21pc2UucmVqZWN0KGVycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3JzKSk7XG4gIH1cblxuICBhc3luYyB1bmRvTGlrZVBvc3QocG9zdElkKSB7XG4gICAgdGhpcy5jbGllbnQuX2NoZWNrVXNlckFwaUtleSgpO1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5jbGllbnQuaW5zdGFuY2UuZGVsZXRlKCcvcG9zdF9hY3Rpb25zLycgKyBwb3N0SWQsIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICAgIHBvc3RfYWN0aW9uX3R5cGVfaWQ6ICcyJ1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgfVxuICAgIH0pKS5kYXRhO1xuICB9XG59XG5cbndpbmRvdy5EaXNjb3Vyc2UgPSBEaXNjb3Vyc2U7XG4iLCJpbXBvcnQgS2V5TWFuYWdlciBmcm9tICcuL2tleU1hbmFnZXInO1xuaW1wb3J0IGF1dGhNYW5hZ2VyIGZyb20gJy4vYXV0aE1hbmFnZXInO1xuaW1wb3J0IFVSTFNlYXJjaFBhcmFtcyBmcm9tICdAdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXMnOyAvLyBwb2x5ZmlsbFxuLy8gaW1wb3J0IE1vYmlsZURldGVjdCBmcm9tICdtb2JpbGUtZGV0ZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlzY291cnNlQXV0aCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmttID0gbmV3IEtleU1hbmFnZXIob3B0aW9ucy5hcHBJZCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGFzeW5jIGluaXQoKSB7XG4gICAgYXdhaXQgdGhpcy5rbS5nZXRLZXlzKCk7XG4gICAgYXV0aE1hbmFnZXIuaGFzVXNlckFwaUtleSgpIHx8IHRoaXMuX21hbmFnZVBheWxvYWQoKTtcbiAgfVxuXG4gIGFzeW5jIF9nZXRMb2dpblVybCgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgIGFwcGxpY2F0aW9uX25hbWU6IHRoaXMub3B0aW9ucy5hcHBOYW1lLFxuICAgICAgcHVibGljX2tleTogYXdhaXQgdGhpcy5rbS5nZXRQdWJsaWNLZXkoKSxcbiAgICAgIG5vbmNlOiB0aGlzLl9nZW5lcmF0ZVN0b3JlZFJhbmRvbSgnbm9uY2UnKSxcbiAgICAgIGNsaWVudF9pZDogYXV0aE1hbmFnZXIuZ2V0QXBwUHJvcCh0aGlzLm9wdGlvbnMuYXBwSWQsICdjbGllbnRJZCcpIHx8IHRoaXMuX2dlbmVyYXRlU3RvcmVkUmFuZG9tKCdjbGllbnRJZCcpLFxuICAgICAgYXV0aF9yZWRpcmVjdDogbG9jYXRpb24uaHJlZixcbiAgICAgIHNjb3BlczogdGhpcy5vcHRpb25zLnNjb3Blc1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hcGlCYXNlVXJsICsgJy91c2VyLWFwaS1rZXkvbmV3PycgKyB0aGlzLl9zZXJpYWxpemVQYXJhbXMocGFyYW1zKTtcbiAgfVxuXG4gIF9zZXJpYWxpemVQYXJhbXMocGFyYW1zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgIC5tYXAoKGspID0+IGVuY29kZVVSSUNvbXBvbmVudChrKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba10pKVxuICAgICAgLmpvaW4oJyYnKTtcbiAgfTtcblxuICBfZ2VuZXJhdGVTdG9yZWRSYW5kb20obmFtZSkge1xuICAgIGNvbnN0IHN0b3JlZFJhbmRvbSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnN1YnN0cigyKTtcblxuICAgIGF1dGhNYW5hZ2VyLnNldEFwcFByb3AodGhpcy5vcHRpb25zLmFwcElkLCBuYW1lLCBzdG9yZWRSYW5kb20pO1xuICAgIHJldHVybiBzdG9yZWRSYW5kb207XG4gIH1cblxuICBfbWFuYWdlUGF5bG9hZCgpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgd2luZG93LmxvY2F0aW9uLmhhc2guc3BsaXQoJz8nKVsxXSk7XG5cbiAgICBpZiAodXJsLmhhcygncGF5bG9hZCcpICYmIG9wZW5lcikge1xuICAgICAgdGhpcy5rbS5kZWNyeXB0UGF5bG9hZCh1cmwuZ2V0KCdwYXlsb2FkJykpLnRoZW4ocGF5bG9hZE9iamVjdCA9PiB7XG4gICAgICAgIHBheWxvYWRPYmplY3Qubm9uY2UgPT09IGF1dGhNYW5hZ2VyLmdldEFwcFByb3AodGhpcy5vcHRpb25zLmFwcElkLCAnbm9uY2UnKSB8fFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJldHVybmVkIHBheWxvYWQgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgcGF5bG9hZE9iamVjdC5hcGkgPT09IDQgfHxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIEFQSSB2ZXJzaW9uOiAnICsgcGF5bG9hZE9iamVjdC5hcGkgKyAnLiBEaXNjb3Vyc2UtanMgd29ya3Mgd2l0aCBBUEkgdmVyc2lvbiAzLicpO1xuICAgICAgICBhdXRoTWFuYWdlci5zZXRVc2VyQXBpS2V5KHBheWxvYWRPYmplY3Qua2V5KTtcbiAgICAgICAgYXV0aE1hbmFnZXIucmVtb3ZlQXBwUHJvcCh0aGlzLm9wdGlvbnMuYXBwSWQsICdub25jZScpO1xuICAgICAgICBvcGVuZXIucG9zdE1lc3NhZ2UoeyByZXN1bHQ6IHBheWxvYWRPYmplY3QgfSwgbG9jYXRpb24ub3JpZ2luKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB2YXIgbWQgPSBuZXcgTW9iaWxlRGV0ZWN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxufVxuIiwiaW1wb3J0IGF1dGhNYW5hZ2VyIGZyb20gJy4vYXV0aE1hbmFnZXInO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IGNhY2hlQWRhcHRlckVuaGFuY2VyLCB0aHJvdHRsZUFkYXB0ZXJFbmhhbmNlciB9IGZyb20gJ2F4aW9zLWV4dGVuc2lvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXNjb3Vyc2VDbGllbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmluc3RhbmNlID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgIGJhc2VVUkw6IG9wdGlvbnMuYXBpQmFzZVVybCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBhZGFwdGVyOiB0aHJvdHRsZUFkYXB0ZXJFbmhhbmNlcihcbiAgICAgICAgY2FjaGVBZGFwdGVyRW5oYW5jZXIoYXhpb3MuZGVmYXVsdHMuYWRhcHRlciksXG4gICAgICAgIHsgdGhyZXNob2xkOiA1MDAgfSAvLyAxMjAgcmVxcy9taW5cbiAgICAgIClcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGluaXQoKSB7XG4gICAgYXdhaXQgdGhpcy5fc2V0VXNlckFwaUtleShhdXRoTWFuYWdlci5nZXRVc2VyQXBpS2V5KCkpO1xuICB9XG5cbiAgYXN5bmMgX2dldENhbGxSZXN1bHQoZW5kcG9pbnQsIHByb3AsIG5vY2FjaGUgPSBmYWxzZSkge1xuICAgIGxldCByZXNwb25zZTtcblxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IChhd2FpdCB0aGlzLmluc3RhbmNlLmdldChlbmRwb2ludCwgeyBmb3JjZVVwZGF0ZTogbm9jYWNoZSB9KSkuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcCkge1xuICAgICAgcmVzcG9uc2UgPSBwcm9wLnNwbGl0KCcuJykucmVkdWNlKChyZXR1cm5lZFJlc3BvbnNlLCBjdXJyZW50UHJvcCkgPT5cbiAgICAgICAgcmV0dXJuZWRSZXNwb25zZVtjdXJyZW50UHJvcF0sIHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBhc3luYyBfcG9zdENhbGxSZXN1bHQoZW5kcG9pbnQsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuaW5zdGFuY2UucG9zdChlbmRwb2ludCwgcGF5bG9hZCkpLmRhdGE7XG4gIH1cblxuICBhc3luYyBfc2V0VXNlckFwaUtleSh1c2VyQXBpS2V5KSB7XG4gICAgaWYgKCF1c2VyQXBpS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaW5zdGFuY2UuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1VzZXItQXBpLUtleSddID0gdXNlckFwaUtleTtcbiAgICAgIGF3YWl0IHRoaXMuX3NldENzcmZUb2tlbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhdXRoTWFuYWdlci5jbGVhckF1dGhEYXRhKHRoaXMub3B0aW9ucy5hcHBJZCk7XG4gICAgICBkZWxldGUgdGhpcy5pbnN0YW5jZS5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnVXNlci1BcGktS2V5J107XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3NldENzcmZUb2tlbigpIHtcbiAgICB0aGlzLmluc3RhbmNlLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydYLUNTUkYtVG9rZW4nXSA9IGF3YWl0IHRoaXMuX2dldENhbGxSZXN1bHQoJy9zZXNzaW9uL2NzcmYuanNvbicsICdjc3JmJyk7XG4gIH1cblxuICBfY2hlY2tVc2VyQXBpS2V5KCkge1xuICAgIHRoaXMuaW5zdGFuY2UuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1VzZXItQXBpLUtleSddIHx8IHRocm93IG5ldyBFcnJvcignVXNlciBBUEkga2V5IG5vdCBzZXQnKTtcbiAgfVxuXG4gIGFzeW5jIF9kb0xvZ291dCh1c2VybmFtZSkge1xuICAgIHRoaXMuX2NoZWNrVXNlckFwaUtleSgpO1xuICAgIGF3YWl0IHRoaXMuaW5zdGFuY2UuZGVsZXRlKCcvc2Vzc2lvbi8nICsgdXNlcm5hbWUpO1xuICAgIGF3YWl0IHRoaXMuaW5zdGFuY2UucG9zdCgnL3VzZXItYXBpLWtleS9yZXZva2UnKTtcbiAgICBkZWxldGUgdGhpcy5pbnN0YW5jZS5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnVXNlci1BcGktS2V5J107XG4gICAgZGVsZXRlIHRoaXMuaW5zdGFuY2UuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtQ1NSRi1Ub2tlbiddO1xuICB9XG59XG4iLCJpbXBvcnQgYXV0aE1hbmFnZXIgZnJvbSAnLi9hdXRoTWFuYWdlcic7XG5sZXQgZm9yZ2UgPSByZXF1aXJlKCcuL3ZlbmRvci9mb3JnZS1wa2knKTtcblxuZXhwb3J0IGRlZmF1bHQgKCgpID0+IHtcbiAgY29uc3QgZ2VuZXJhdGUgPSAoYXBwSWQpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZm9yZ2UucnNhLmdlbmVyYXRlS2V5UGFpcih7XG4gICAgICAgIHdvcmtlclNjcmlwdDogJy9wcmltZS13b3JrZXIubWluLmpzJ1xuICAgICAgfSxcbiAgICAgIChlcnJvciwgZ2VuZXJhdGVkS2V5cGFpcikgPT4ge1xuICAgICAgICBnZW5lcmF0ZWRLZXlwYWlyID8gKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBrZXlwYWlyID0ge1xuICAgICAgICAgICAgcHVibGljOiBmb3JnZS5wa2kucHVibGljS2V5VG9QZW0oZ2VuZXJhdGVkS2V5cGFpci5wdWJsaWNLZXksIDcyKS5yZXBsYWNlKC9cXHIvZywgJycpLFxuICAgICAgICAgICAgcHJpdmF0ZTogZm9yZ2UucGtpLnByaXZhdGVLZXlUb1BlbShnZW5lcmF0ZWRLZXlwYWlyLnByaXZhdGVLZXksIDcyKS5yZXBsYWNlKC9cXHIvZywgJycpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGF1dGhNYW5hZ2VyLnNldEFwcFByb3AoYXBwSWQsICdwdWJsaWNLZXknLCBrZXlwYWlyLnB1YmxpYyk7XG4gICAgICAgICAgYXV0aE1hbmFnZXIuc2V0QXBwUHJvcChhcHBJZCwgJ3ByaXZhdGVLZXknLCBrZXlwYWlyLnByaXZhdGUpO1xuICAgICAgICAgIHJlc29sdmUoa2V5cGFpcik7XG4gICAgICAgIH0pKCkgOiByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHsgZ2VuZXJhdGUgfTtcbn0pKCk7XG4iLCJpbXBvcnQgYXV0aE1hbmFnZXIgZnJvbSAnLi9hdXRoTWFuYWdlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihhcHBJZCkge1xuICAgIHRoaXMuYXBwSWQgPSBhcHBJZDtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlTmV3S2V5cGFpcigpIHtcbiAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgLypcbiAgICAgICAgd2VicGFja0NodW5rTmFtZTogXCJrZXlHZW5lcmF0b3JcIixcbiAgICAgICAgd2VicGFja1ByZWxvYWQ6IHRydWVcbiAgICAgICovXG4gICAgICAnLi9rZXlHZW5lcmF0b3InKS50aGVuKCh7IGRlZmF1bHQ6IGtleUdlbmVyYXRvciB9KSA9PiB7XG4gICAgICByZXR1cm4ga2V5R2VuZXJhdG9yLmdlbmVyYXRlKHRoaXMuYXBwSWQpLnRoZW4oKGtleXBhaXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGtleXBhaXI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEtleXNGcm9tU3RvcmFnZSgpIHx8IGF3YWl0IHRoaXMuZ2VuZXJhdGVOZXdLZXlwYWlyKCk7XG4gIH1cblxuICByZWFkS2V5c0Zyb21TdG9yYWdlKCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGF1dGhNYW5hZ2VyLmdldEFwcFByb3AodGhpcy5hcHBJZCwgJ3B1YmxpY0tleScpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBhdXRoTWFuYWdlci5nZXRBcHBQcm9wKHRoaXMuYXBwSWQsICdwcml2YXRlS2V5Jyk7XG5cbiAgICByZXR1cm4gKHB1YmxpY0tleSAmJiBwcml2YXRlS2V5KSA/XG4gICAgICB7XG4gICAgICAgIHB1YmxpYzogcHVibGljS2V5LFxuICAgICAgICBwcml2YXRlOiBwcml2YXRlS2V5XG4gICAgICB9IDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldFB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0S2V5cygpKVsncHVibGljJ107XG4gIH1cblxuICBhc3luYyBnZXRQcml2YXRlS2V5KCkge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRLZXlzKCkpWydwcml2YXRlJ107XG4gIH1cblxuICBhc3luYyBkZWNyeXB0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJpdmF0ZUtleSgpLnRoZW4ocHJpdmF0ZUtleSA9PiB7XG4gICAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgICAvKlxuICAgICAgICAgIHdlYnBhY2tDaHVua05hbWU6IFwianNlbmNyeXB0XCIsXG4gICAgICAgICAgd2VicGFja1ByZWxvYWQ6IHRydWVcbiAgICAgICAgKi9cbiAgICAgICAgJ2pzZW5jcnlwdCcpLnRoZW4oKHsgZGVmYXVsdDogSnNlbmNyeXB0IH0pID0+IHtcbiAgICAgICAgY29uc3QganNlbmNyeXB0ID0gbmV3IEpzZW5jcnlwdCgpO1xuXG4gICAgICAgIGpzZW5jcnlwdC5zZXRQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc2VuY3J5cHQuZGVjcnlwdChwYXlsb2FkKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZvcmdlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImZvcmdlXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnM6IHtcbiAgICB1c2VQdXJlSmF2YVNjcmlwdDogZmFsc2VcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE4IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgYmFzZU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxuLyogVXRpbGl0aWVzIEFQSSAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnV0aWwgPSBmb3JnZS51dGlsIHx8IHt9O1xuXG4vLyBkZWZpbmUgc2V0SW1tZWRpYXRlIGFuZCBuZXh0VGlja1xuKGZ1bmN0aW9uKCkge1xuICAvLyB1c2UgbmF0aXZlIG5leHRUaWNrICh1bmxlc3Mgd2UncmUgaW4gd2VicGFjaylcbiAgLy8gd2VicGFjayAob3IgYmV0dGVyIG5vZGUtbGlicy1icm93c2VyIHBvbHlmaWxsKSBzZXRzIHByb2Nlc3MuYnJvd3Nlci5cbiAgLy8gdGhpcyB3YXkgd2UgY2FuIGRldGVjdCB3ZWJwYWNrIHByb3Blcmx5XG4gIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrICYmICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB1dGlsLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggbmV4dFRpY2ssIG9sZGVyIHZlcnNpb25zIG9mIG5vZGVcbiAgICAgIC8vICh0aG9zZSB3L28gc2V0SW1tZWRpYXRlKSB3b24ndCB0b3RhbGx5IHN0YXJ2ZSBJT1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSB1dGlsLm5leHRUaWNrO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwb2x5ZmlsbCBuZXh0VGljayB3aXRoIG5hdGl2ZSBzZXRJbW1lZGlhdGVcbiAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbW1lZGlhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpOyB9O1xuICAgIHV0aWwubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBOb3RlOiBBIHBvbHlmaWxsIHVwZ3JhZGUgcGF0dGVybiBpcyB1c2VkIGhlcmUgdG8gYWxsb3cgY29tYmluaW5nXG4gIHBvbHlmaWxscy4gRm9yIGV4YW1wbGUsIE11dGF0aW9uT2JzZXJ2ZXIgaXMgZmFzdCwgYnV0IGJsb2NrcyBVSSB1cGRhdGVzLFxuICBzbyBpdCBuZWVkcyB0byBhbGxvdyBVSSB1cGRhdGVzIHBlcmlvZGljYWxseSwgc28gaXQgZmFsbHMgYmFjayBvblxuICBwb3N0TWVzc2FnZSBvciBzZXRUaW1lb3V0LiAqL1xuXG4gIC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dFxuICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH07XG5cbiAgLy8gdXBncmFkZSBwb2x5ZmlsbCB0byB1c2UgcG9zdE1lc3NhZ2VcbiAgaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG1zZyA9ICdmb3JnZS5zZXRJbW1lZGlhdGUnO1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAvLyBvbmx5IHNlbmQgbWVzc2FnZSB3aGVuIG9uZSBoYXNuJ3QgYmVlbiBzZW50IGluXG4gICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICBpZihjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBpZihldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhID09PSBtc2cpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfVxuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgaWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gcG9seWZpbGwgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGF0dHIgPSB0cnVlO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0pLm9ic2VydmUoZGl2LCB7YXR0cmlidXRlczogdHJ1ZX0pO1xuICAgIHZhciBvbGRTZXRJbW1lZGlhdGUgPSB1dGlsLnNldEltbWVkaWF0ZTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZihEYXRlLm5vdygpIC0gbm93ID4gMTUpIHtcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgb2xkU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG9ic2VydmVyIHdoZW4gaXQgaGFzbid0IGJlZW4gdHJpZ2dlcmVkIGluXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHR1cm4gb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2EnLCBhdHRyID0gIWF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHV0aWwubmV4dFRpY2sgPSB1dGlsLnNldEltbWVkaWF0ZTtcbn0pKCk7XG5cbi8vIGNoZWNrIGlmIHJ1bm5pbmcgdW5kZXIgTm9kZS5qc1xudXRpbC5pc05vZGVqcyA9XG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcblxuLy8gZGVmaW5lIGlzQXJyYXlcbnV0aWwuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJcbnV0aWwuaXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJWaWV3XG51dGlsLmlzQXJyYXlCdWZmZXJWaWV3ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAmJiB1dGlsLmlzQXJyYXlCdWZmZXIoeC5idWZmZXIpICYmIHguYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgYSBiaXRzIHBhcmFtIGlzIDgsIDE2LCAyNCwgb3IgMzIuIFVzZWQgdG8gdmFsaWRhdGUgaW5wdXQgZm9yXG4gKiBhbGdvcml0aG1zIHdoZXJlIGJpdCBtYW5pcHVsYXRpb24sIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIGFuZC9vciBhbGdvcml0aG1cbiAqIGRlc2lnbiBvbmx5IGFsbG93IGZvciBieXRlIG9wZXJhdGlvbnMgb2YgYSBsaW1pdGVkIHNpemUuXG4gKlxuICogQHBhcmFtIG4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogVGhyb3cgRXJyb3IgaWYgbiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCaXRzUGFyYW0obikge1xuICBpZighKG4gPT09IDggfHwgbiA9PT0gMTYgfHwgbiA9PT0gMjQgfHwgbiA9PT0gMzIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IDgsIDE2LCAyNCwgb3IgMzIgYml0cyBzdXBwb3J0ZWQ6ICcgKyBuKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBzZXQgQnl0ZUJ1ZmZlciB0byBiZXN0IGF2YWlsYWJsZSBiYWNraW5nXG51dGlsLkJ5dGVCdWZmZXIgPSBCeXRlU3RyaW5nQnVmZmVyO1xuXG4vKiogQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBmb3IgYSBiaW5hcnkgc3RyaW5nIGJhY2tlZCBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gW2JdIHRoZSBieXRlcyB0byB3cmFwIChlaXRoZXIgZW5jb2RlZCBhcyBzdHJpbmcsIG9uZSBieXRlIHBlclxuICogICAgICAgICAgY2hhcmFjdGVyLCBvciBhcyBhbiBBcnJheUJ1ZmZlciBvciBUeXBlZCBBcnJheSkuXG4gKi9cbmZ1bmN0aW9uIEJ5dGVTdHJpbmdCdWZmZXIoYikge1xuICAvLyBUT0RPOiB1cGRhdGUgdG8gbWF0Y2ggRGF0YUJ1ZmZlciBBUElcblxuICAvLyB0aGUgZGF0YSBpbiB0aGlzIGJ1ZmZlclxuICB0aGlzLmRhdGEgPSAnJztcbiAgLy8gdGhlIHBvaW50ZXIgZm9yIHJlYWRpbmcgZnJvbSB0aGlzIGJ1ZmZlclxuICB0aGlzLnJlYWQgPSAwO1xuXG4gIGlmKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuZGF0YSA9IGI7XG4gIH0gZWxzZSBpZih1dGlsLmlzQXJyYXlCdWZmZXIoYikgfHwgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhiKSkge1xuICAgIGlmKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGIgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb252ZXJ0IG5hdGl2ZSBidWZmZXIgdG8gZm9yZ2UgYnVmZmVyXG4gICAgICAvLyBGSVhNRTogc3VwcG9ydCBuYXRpdmUgYnVmZmVycyBpbnRlcm5hbGx5IGluc3RlYWRcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhpcy5wdXRCeXRlKGFycltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihiIGluc3RhbmNlb2YgQnl0ZVN0cmluZ0J1ZmZlciB8fFxuICAgICh0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIuZGF0YSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgYi5yZWFkID09PSAnbnVtYmVyJykpIHtcbiAgICAvLyBjb3B5IGV4aXN0aW5nIGJ1ZmZlclxuICAgIHRoaXMuZGF0YSA9IGIuZGF0YTtcbiAgICB0aGlzLnJlYWQgPSBiLnJlYWQ7XG4gIH1cblxuICAvLyB1c2VkIGZvciB2OCBvcHRpbWl6YXRpb25cbiAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xufVxudXRpbC5CeXRlU3RyaW5nQnVmZmVyID0gQnl0ZVN0cmluZ0J1ZmZlcjtcblxuLyogTm90ZTogVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gZm9yIFY4LWJhc2VkIGJyb3dzZXJzLiBXaGVuIFY4IGNvbmNhdGVuYXRlc1xuICBhIHN0cmluZywgdGhlIHN0cmluZ3MgYXJlIG9ubHkgam9pbmVkIGxvZ2ljYWxseSB1c2luZyBhIFwiY29ucyBzdHJpbmdcIiBvclxuICBcImNvbnN0cnVjdGVkL2NvbmNhdGVuYXRlZCBzdHJpbmdcIi4gVGhlc2UgY29udGFpbmVycyBrZWVwIHJlZmVyZW5jZXMgdG8gb25lXG4gIGFub3RoZXIgYW5kIGNhbiByZXN1bHQgaW4gdmVyeSBsYXJnZSBtZW1vcnkgdXNhZ2UuIEZvciBleGFtcGxlLCBpZiBhIDJNQlxuICBzdHJpbmcgaXMgY29uc3RydWN0ZWQgYnkgY29uY2F0ZW5hdGluZyA0IGJ5dGVzIHRvZ2V0aGVyIGF0IGEgdGltZSwgdGhlXG4gIG1lbW9yeSB1c2FnZSB3aWxsIGJlIH40NE1COyBzbyB+MjJ4IGluY3JlYXNlLiBUaGUgc3RyaW5ncyBhcmUgb25seSBqb2luZWRcbiAgdG9nZXRoZXIgd2hlbiBhbiBvcGVyYXRpb24gcmVxdWlyaW5nIHRoZWlyIGpvaW5pbmcgdGFrZXMgcGxhY2UsIHN1Y2ggYXNcbiAgc3Vic3RyKCkuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYWRkaW5nIGRhdGEgdG8gdGhpcyBidWZmZXIgdG8gZW5zdXJlXG4gIHRoZXNlIHR5cGVzIG9mIHN0cmluZ3MgYXJlIHBlcmlvZGljYWxseSBqb2luZWQgdG8gcmVkdWNlIHRoZSBtZW1vcnlcbiAgZm9vdHByaW50LiAqL1xudmFyIF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCA9IDQwOTY7XG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nID0gZnVuY3Rpb24oeCkge1xuICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCArPSB4O1xuICBpZih0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCA+IF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCkge1xuICAgIC8vIHRoaXMgc3Vic3RyKCkgc2hvdWxkIGNhdXNlIHRoZSBjb25zdHJ1Y3RlZCBzdHJpbmcgdG8gam9pblxuICAgIHRoaXMuZGF0YS5zdWJzdHIoMCwgMSk7XG4gICAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShiKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyIE4gdGltZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyBvZiB2YWx1ZSBiIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgYiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gIHZhciBkID0gdGhpcy5kYXRhO1xuICB3aGlsZShuID4gMCkge1xuICAgIGlmKG4gJiAxKSB7XG4gICAgICBkICs9IGI7XG4gICAgfVxuICAgIG4gPj4+PSAxO1xuICAgIGlmKG4gPiAwKSB7XG4gICAgICBiICs9IGI7XG4gICAgfVxuICB9XG4gIHRoaXMuZGF0YSA9IGQ7XG4gIHRoaXMuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcobik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgKGFzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcpIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdGhpcy5kYXRhICs9IGJ5dGVzO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKGJ5dGVzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgVVRGLTE2IGVuY29kZWQgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyh1dGlsLmVuY29kZVV0Zjgoc3RyKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYW4gbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgYnl0ZXMgPSAnJztcbiAgZG8ge1xuICAgIG4gLT0gODtcbiAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IG4pICYgMHhGRik7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhieXRlcyk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgLy8gcHV0SW50IGNoZWNrcyBuXG4gIGlmKGkgPCAwKSB7XG4gICAgaSArPSAyIDw8IChuIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBnaXZlbiBidWZmZXIgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gcHV0IGludG8gdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnVmZmVyLmdldEJ5dGVzKCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBmcm9tIHRoaXMgYnVmZmVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IDEuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAyNCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNik7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAzKSA8PCAyNCk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlXG4gKiByZWFkIHBvaW50ZXIgYnkgY2VpbChuLzgpLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIHJ2YWwgPSAwO1xuICBkbyB7XG4gICAgLy8gVE9ETzogVXNlIChydmFsICogMHgxMDApIGlmIGFkZGluZyBzdXBwb3J0IGZvciAzMyB0byA1MyBiaXRzLlxuICAgIHJ2YWwgPSAocnZhbCA8PCA4KSArIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbiAgICBuIC09IDg7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciwgdXNpbmdcbiAqIHR3bydzIGNvbXBsZW1lbnQsIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0U2lnbmVkSW50ID0gZnVuY3Rpb24obikge1xuICAvLyBnZXRJbnQgY2hlY2tzIG5cbiAgdmFyIHggPSB0aGlzLmdldEludChuKTtcbiAgdmFyIG1heCA9IDIgPDwgKG4gLSAyKTtcbiAgaWYoeCA+PSBtYXgpIHtcbiAgICB4IC09IG1heCA8PCAxO1xuICB9XG4gIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlcyBvdXQgaW50byBhIFVURi04IHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIFVURi04IHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZihjb3VudCkge1xuICAgIC8vIHJlYWQgY291bnQgYnl0ZXNcbiAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpO1xuICAgIHRoaXMucmVhZCArPSBjb3VudDtcbiAgfSBlbHNlIGlmKGNvdW50ID09PSAwKSB7XG4gICAgcnZhbCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgYWxsIGJ5dGVzLCBvcHRpbWl6ZSB0byBvbmx5IGNvcHkgd2hlbiBuZWVkZWRcbiAgICBydmFsID0gKHRoaXMucmVhZCA9PT0gMCkgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYnl0ZXMgZnJvbSB0aGlzIGJ1ZmZlciB3aXRob3V0IG1vZGlmeWluZ1xuICogdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZXQsIG9taXQgdG8gZ2V0IGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgc3RyaW5nIGZ1bGwgb2YgVVRGLTggZW5jb2RlZCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgcmV0dXJuICh0eXBlb2YoY291bnQpID09PSAndW5kZWZpbmVkJyA/XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCkgOlxuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyBpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cigwLCB0aGlzLnJlYWQgKyBpKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShiKSArXG4gICAgdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQgKyBpICsgMSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5kYXRhLmxlbmd0aCAtIDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjb3B5LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGMgPSB1dGlsLmNyZWF0ZUJ1ZmZlcih0aGlzLmRhdGEpO1xuICBjLnJlYWQgPSB0aGlzLnJlYWQ7XG4gIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9ICcnO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hvcnRlbnMgdGhpcyBidWZmZXIgYnkgdHJpbWluZyBieXRlcyBvZmYgb2YgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byB0cmltIG9mZi5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoKCkgLSBjb3VudCk7XG4gIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHIodGhpcy5yZWFkLCBsZW4pO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYiA9IHRoaXMuZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmKGIgPCAxNikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgVVRGLTE2IHN0cmluZyAoc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICpcbiAqIEByZXR1cm4gYSBVVEYtMTYgc3RyaW5nLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgodGhpcy5ieXRlcygpKTtcbn07XG5cbi8qKiBFbmQgQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqIEJ1ZmZlciB3L1VJbnQ4QXJyYXkgYmFja2luZyAqL1xuXG4vKipcbiAqIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxuICpcbiAqIENvbnN0cnVjdG9yIGZvciBhbiBBcnJheUJ1ZmZlci1iYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogVGhlIGJ1ZmZlciBtYXkgYmUgY29uc3RydWN0ZWQgZnJvbSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBhXG4gKiBUeXBlZEFycmF5LlxuICpcbiAqIElmIGEgc3RyaW5nIGlzIGdpdmVuLCBpdHMgZW5jb2Rpbmcgc2hvdWxkIGJlIHByb3ZpZGVkIGFzIGFuIG9wdGlvbixcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGRlZmF1bHQgdG8gJ2JpbmFyeScuIEEgJ2JpbmFyeScgc3RyaW5nIGlzIGVuY29kZWQgc3VjaFxuICogdGhhdCBlYWNoIGNoYXJhY3RlciBpcyBvbmUgYnl0ZSBpbiBsZW5ndGggYW5kIHNpemUuXG4gKlxuICogSWYgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBUeXBlZEFycmF5IGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWRcbiAqICpkaXJlY3RseSogd2l0aG91dCBhbnkgY29weWluZy4gTm90ZSB0aGF0LCBpZiBhIHdyaXRlIHRvIHRoZSBidWZmZXIgcmVxdWlyZXNcbiAqIG1vcmUgc3BhY2UsIHRoZSBidWZmZXIgd2lsbCBhbGxvY2F0ZSBhIG5ldyBiYWNraW5nIEFycmF5QnVmZmVyIHRvXG4gKiBhY2NvbW1vZGF0ZS4gVGhlIHN0YXJ0aW5nIHJlYWQgYW5kIHdyaXRlIG9mZnNldHMgZm9yIHRoZSBidWZmZXIgbWF5IGJlXG4gKiBnaXZlbiBhcyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBbYl0gdGhlIGluaXRpYWwgYnl0ZXMgZm9yIHRoaXMgYnVmZmVyLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW3JlYWRPZmZzZXRdIHRoZSBzdGFydGluZyByZWFkIG9mZnNldCB0byB1c2UgKGRlZmF1bHQ6IDApLlxuICogICAgICAgICAgW3dyaXRlT2Zmc2V0XSB0aGUgc3RhcnRpbmcgd3JpdGUgb2Zmc2V0IHRvIHVzZSAoZGVmYXVsdDogdGhlXG4gKiAgICAgICAgICAgIGxlbmd0aCBvZiB0aGUgZmlyc3QgcGFyYW1ldGVyKS5cbiAqICAgICAgICAgIFtncm93U2l6ZV0gdGhlIG1pbmltdW0gYW1vdW50LCBpbiBieXRlcywgdG8gZ3JvdyB0aGUgYnVmZmVyIGJ5IHRvXG4gKiAgICAgICAgICAgIGFjY29tbW9kYXRlIHdyaXRlcyAoZGVmYXVsdDogMTAyNCkuXG4gKiAgICAgICAgICBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyAoJ2JpbmFyeScsICd1dGY4JywgJ3V0ZjE2JywgJ2hleCcpIGZvciB0aGVcbiAqICAgICAgICAgICAgZmlyc3QgcGFyYW1ldGVyLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICovXG5mdW5jdGlvbiBEYXRhQnVmZmVyKGIsIG9wdGlvbnMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvaW50ZXJzIGZvciByZWFkIGZyb20vd3JpdGUgdG8gYnVmZmVyXG4gIHRoaXMucmVhZCA9IG9wdGlvbnMucmVhZE9mZnNldCB8fCAwO1xuICB0aGlzLmdyb3dTaXplID0gb3B0aW9ucy5ncm93U2l6ZSB8fCAxMDI0O1xuXG4gIHZhciBpc0FycmF5QnVmZmVyID0gdXRpbC5pc0FycmF5QnVmZmVyKGIpO1xuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGIpO1xuICBpZihpc0FycmF5QnVmZmVyIHx8IGlzQXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgLy8gdXNlIEFycmF5QnVmZmVyIGRpcmVjdGx5XG4gICAgaWYoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGp1c3QgcmVhZC93cml0ZSBvZmZzZXQgYmFzZWQgb24gdGhlIHR5cGUgb2Ygdmlld1xuICAgICAgLy8gb3Igc3BlY2lmeSB0aGF0IHRoaXMgbXVzdCBiZSBkb25lIGluIHRoZSBvcHRpb25zIC4uLiB0aGF0IHRoZVxuICAgICAgLy8gb2Zmc2V0cyBhcmUgYnl0ZS1iYXNlZFxuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMud3JpdGUgPSAoJ3dyaXRlT2Zmc2V0JyBpbiBvcHRpb25zID9cbiAgICAgIG9wdGlvbnMud3JpdGVPZmZzZXQgOiB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB0byBlbXB0eSBhcnJheSBidWZmZXIgYW5kIGFkZCBhbnkgZ2l2ZW4gYnl0ZXMgdXNpbmcgcHV0Qnl0ZXNcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIHRoaXMud3JpdGUgPSAwO1xuXG4gIGlmKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wdXRCeXRlcyhiKTtcbiAgfVxuXG4gIGlmKCd3cml0ZU9mZnNldCcgaW4gb3B0aW9ucykge1xuICAgIHRoaXMud3JpdGUgPSBvcHRpb25zLndyaXRlT2Zmc2V0O1xuICB9XG59XG51dGlsLkRhdGFCdWZmZXIgPSBEYXRhQnVmZmVyO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndyaXRlIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogRW5zdXJlcyB0aGlzIGJ1ZmZlciBoYXMgZW5vdWdoIGVtcHR5IHNwYWNlIHRvIGFjY29tbW9kYXRlIHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGJ5dGVzLiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgbWF5IGJlIGdpdmVuIHRoYXQgaW5kaWNhdGVzIGEgbWluaW11bVxuICogYW1vdW50IHRvIGdyb3cgdGhlIGJ1ZmZlciBpZiBuZWNlc3NhcnkuIElmIHRoZSBwYXJhbWV0ZXIgaXMgbm90IGdpdmVuLFxuICogdGhlIGJ1ZmZlciB3aWxsIGJlIGdyb3duIGJ5IHNvbWUgcHJldmlvdXNseS1zcGVjaWZpZWQgZGVmYXVsdCBhbW91bnRcbiAqIG9yIGhldXJpc3RpYy5cbiAqXG4gKiBAcGFyYW0gYW1vdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gYWNjb21tb2RhdGUuXG4gKiBAcGFyYW0gW2dyb3dTaXplXSB0aGUgbWluaW11bSBhbW91bnQsIGluIGJ5dGVzLCB0byBncm93IHRoZSBidWZmZXIgYnkgaWZcbiAqICAgICAgICAgIG5lY2Vzc2FyeS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5hY2NvbW1vZGF0ZSA9IGZ1bmN0aW9uKGFtb3VudCwgZ3Jvd1NpemUpIHtcbiAgaWYodGhpcy5sZW5ndGgoKSA+PSBhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm93U2l6ZSA9IE1hdGgubWF4KGdyb3dTaXplIHx8IHRoaXMuZ3Jvd1NpemUsIGFtb3VudCk7XG5cbiAgLy8gZ3JvdyBidWZmZXJcbiAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KFxuICAgIHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5ieXRlT2Zmc2V0LCB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICsgZ3Jvd1NpemUpO1xuICBkc3Quc2V0KHNyYyk7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QuYnVmZmVyKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgxKTtcbiAgdGhpcy5kYXRhLnNldFVpbnQ4KHRoaXMud3JpdGUrKywgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUobik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB0aGlzLmRhdGEuc2V0VWludDgoYik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYnl0ZXMgaW4gdGhpcyBidWZmZXIuIFRoZSBieXRlcyBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcsIGFuXG4gKiBBcnJheUJ1ZmZlciwgYSBEYXRhVmlldywgb3IgYSBUeXBlZEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gcHV0LlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyICgnYmluYXJ5JywgJ3V0ZjgnLFxuICogICAgICAgICAgJ3V0ZjE2JywgJ2hleCcpLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcywgZW5jb2RpbmcpIHtcbiAgaWYodXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gc3JjLmJ5dGVMZW5ndGggLSBzcmMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmFjY29tbW9kYXRlKGxlbik7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLndyaXRlICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmKHV0aWwuaXNBcnJheUJ1ZmZlcihieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIHRoaXMuYWNjb21tb2RhdGUoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyKTtcbiAgICBkc3Quc2V0KHNyYywgdGhpcy53cml0ZSk7XG4gICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGJ5dGVzIGlzIGEgdXRpbC5EYXRhQnVmZmVyIG9yIGVxdWl2YWxlbnRcbiAgaWYoYnl0ZXMgaW5zdGFuY2VvZiB1dGlsLkRhdGFCdWZmZXIgfHxcbiAgICAodHlwZW9mIGJ5dGVzID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBieXRlcy5yZWFkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYnl0ZXMud3JpdGUgPT09ICdudW1iZXInICYmXG4gICAgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcy5kYXRhKSkpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuZGF0YS5ieXRlTGVuZ3RoLCBieXRlcy5yZWFkLCBieXRlcy5sZW5ndGgoKSk7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmRhdGEuYnl0ZUxlbmd0aCwgdGhpcy53cml0ZSk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMud3JpdGUgKz0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZihieXRlcyBpbnN0YW5jZW9mIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlcikge1xuICAgIC8vIGNvcHkgYmluYXJ5IHN0cmluZyBhbmQgcHJvY2VzcyBhcyB0aGUgc2FtZSBhcyBhIHN0cmluZyBwYXJhbWV0ZXIgYmVsb3dcbiAgICBieXRlcyA9IGJ5dGVzLmRhdGE7XG4gICAgZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgfVxuXG4gIC8vIHN0cmluZyBjb252ZXJzaW9uXG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ2JpbmFyeSc7XG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmlldztcblxuICAgIC8vIGRlY29kZSBmcm9tIHN0cmluZ1xuICAgIGlmKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gMikpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5oZXguZGVjb2RlKGJ5dGVzLCB2aWV3LCB0aGlzLndyaXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZihlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJ5dGVzLmxlbmd0aCAvIDQpICogMyk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTggYnl0ZXNcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAvLyBlbmNvZGUgYXMgVVRGLTggdGhlbiBkZWNvZGUgc3RyaW5nIGFzIHJhdyBiaW5hcnlcbiAgICAgIGJ5dGVzID0gdXRpbC5lbmNvZGVVdGY4KGJ5dGVzKTtcbiAgICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIHN0cmluZyBhcyByYXcgYmluYXJ5XG4gICAgaWYoZW5jb2RpbmcgPT09ICdiaW5hcnknIHx8IGVuY29kaW5nID09PSAncmF3Jykge1xuICAgICAgLy8gb25lIGJ5dGUgcGVyIGNoYXJhY3RlclxuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShieXRlcy5sZW5ndGgpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5yYXcuZGVjb2RlKHZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTE2IGJ5dGVzXG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGYxNicpIHtcbiAgICAgIC8vIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCAqIDIpO1xuICAgICAgdmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC50ZXh0LnV0ZjE2LmVuY29kZSh2aWV3KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxuXG4gIHRocm93IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogJyArIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogUHV0cyB0aGUgZ2l2ZW4gYnVmZmVyIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHB1dCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHRoaXMucHV0Qnl0ZXMoYnVmZmVyKTtcbiAgYnVmZmVyLmNsZWFyKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyBmb3IgdGhlIHN0cmluZyAoZGVmYXVsdDogJ3V0ZjE2JykuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoc3RyLCAndXRmMTYnKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpID4+IDggJiAweEZGRkYpO1xuICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlLCBpID4+IDE2ICYgMHhGRik7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGEuc2V0SW50MzIodGhpcy53cml0ZSwgaSk7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDB4RkYpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgMHhGRkZGLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGksIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGFuIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuIC8gOCk7XG4gIGRvIHtcbiAgICBuIC09IDg7XG4gICAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSsrLCAoaSA+PiBuKSAmIDB4RkYpO1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHRoaXMuYWNjb21tb2RhdGUobiAvIDgpO1xuICBpZihpIDwgMCkge1xuICAgIGkgKz0gMiA8PCAobiAtIDEpO1xuICB9XG4gIHJldHVybiB0aGlzLnB1dEludChpLCBuKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgZnJvbSB0aGlzIGJ1ZmZlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSAxLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQsIHRydWUpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQgKyAxLCB0cnVlKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkLCB0cnVlKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGVcbiAqIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICAvLyBUT0RPOiBVc2UgKHJ2YWwgKiAweDEwMCkgaWYgYWRkaW5nIHN1cHBvcnQgZm9yIDMzIHRvIDUzIGJpdHMuXG4gICAgcnZhbCA9IChydmFsIDw8IDgpICsgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xuICAgIG4gLT0gODtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLCB1c2luZ1xuICogdHdvJ3MgY29tcGxlbWVudCwgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIC8vIGdldEludCBjaGVja3MgblxuICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICB2YXIgbWF4ID0gMiA8PCAobiAtIDIpO1xuICBpZih4ID49IG1heCkge1xuICAgIHggLT0gbWF4IDw8IDE7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIFJlYWRzIGJ5dGVzIG91dCBpbnRvIGEgVVRGLTggc3RyaW5nIGFuZCBjbGVhcnMgdGhlbSBmcm9tIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZCwgdW5kZWZpbmVkIG9yIG51bGwgZm9yIGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgVVRGLTggc3RyaW5nIG9mIGJ5dGVzLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlIHRoaXMgbWV0aG9kLCBpdCBpcyBwb29ybHkgbmFtZWQgYW5kXG4gIC8vIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScpIHJlcGxhY2VzIGl0XG4gIC8vIGFkZCBhIHRvVHlwZWRBcnJheSgpL3RvQXJyYXlCdWZmZXIoKSBmdW5jdGlvblxuICB2YXIgcnZhbDtcbiAgaWYoY291bnQpIHtcbiAgICAvLyByZWFkIGNvdW50IGJ5dGVzXG4gICAgY291bnQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBjb3VudCk7XG4gICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB0aGlzLnJlYWQgKz0gY291bnQ7XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMCkge1xuICAgIHJ2YWwgPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGFsbCBieXRlcywgb3B0aW1pemUgdG8gb25seSBjb3B5IHdoZW4gbmVlZGVkXG4gICAgcnZhbCA9ICh0aGlzLnJlYWQgPT09IDApID8gdGhpcy5kYXRhIDogdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dCBtb2RpZnlpbmdcbiAqIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIFVURi04IGVuY29kZWQgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkLCBhZGQgXCJnZXRTdHJpbmcoKVwiXG4gIHJldHVybiAodHlwZW9mKGNvdW50KSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpIDpcbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEuc2V0VWludDgoaSwgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMud3JpdGUgLSAxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY29weS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgdXRpbC5EYXRhQnVmZmVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLnJlYWQpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QpO1xuICAgIHRoaXMud3JpdGUgLT0gdGhpcy5yZWFkO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0ZW5zIHRoaXMgYnVmZmVyIGJ5IHRyaW1pbmcgYnl0ZXMgb2ZmIG9mIHRoZSBlbmQgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gdHJpbSBvZmYuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHRoaXMud3JpdGUgPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEuYnl0ZUxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGIgPSB0aGlzLmRhdGEuZ2V0VWludDgoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBzdHJpbmcsIHVzaW5nIHRoZSBnaXZlbiBlbmNvZGluZy4gSWYgbm9cbiAqIGVuY29kaW5nIGlzIGdpdmVuLCAndXRmOCcgKFVURi04KSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyB0byB1c2U6ICdiaW5hcnknLCAndXRmOCcsICd1dGYxNicsICdoZXgnLFxuICogICAgICAgICAgJ2Jhc2U2NCcgKGRlZmF1bHQ6ICd1dGY4JykuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgdGhpcy5yZWFkLCB0aGlzLmxlbmd0aCgpKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gZW5jb2RlIHRvIHN0cmluZ1xuICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LnJhdy5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmhleC5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUodmlldyk7XG4gIH1cblxuICAvLyBkZWNvZGUgdG8gdGV4dFxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgcmV0dXJuIHV0aWwudGV4dC51dGY4LmRlY29kZSh2aWV3KTtcbiAgfVxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmMTYuZGVjb2RlKHZpZXcpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9VSW50OEFycmF5IGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYnVmZmVyIHRoYXQgc3RvcmVzIGJ5dGVzLiBBIHZhbHVlIG1heSBiZSBnaXZlbiB0byBwdXQgaW50byB0aGVcbiAqIGJ1ZmZlciB0aGF0IGlzIGVpdGhlciBhIHN0cmluZyBvZiBieXRlcyBvciBhIFVURi0xNiBzdHJpbmcgdGhhdCB3aWxsXG4gKiBiZSBlbmNvZGVkIHVzaW5nIFVURi04ICh0byBkbyB0aGUgbGF0dGVyLCBzcGVjaWZ5ICd1dGY4JyBhcyB0aGUgZW5jb2RpbmcpLlxuICpcbiAqIEBwYXJhbSBbaW5wdXRdIHRoZSBieXRlcyB0byB3cmFwIChhcyBhIHN0cmluZykgb3IgYSBVVEYtMTYgc3RyaW5nIHRvIGVuY29kZVxuICogICAgICAgICAgYXMgVVRGLTguXG4gKiBAcGFyYW0gW2VuY29kaW5nXSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICovXG51dGlsLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGlucHV0LCBlbmNvZGluZykge1xuICAvLyBUT0RPOiBkZXByZWNhdGUsIHVzZSBuZXcgQnl0ZUJ1ZmZlcigpIGluc3RlYWRcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAncmF3JztcbiAgaWYoaW5wdXQgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgaW5wdXQgPSB1dGlsLmVuY29kZVV0ZjgoaW5wdXQpO1xuICB9XG4gIHJldHVybiBuZXcgdXRpbC5CeXRlQnVmZmVyKGlucHV0KTtcbn07XG5cbi8qKlxuICogRmlsbHMgYSBzdHJpbmcgd2l0aCBhIHBhcnRpY3VsYXIgdmFsdWUuIElmIHlvdSB3YW50IHRoZSBzdHJpbmcgdG8gYmUgYSBieXRlXG4gKiBzdHJpbmcsIHBhc3MgaW4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGVCeXRlKS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY2hhcmFjdGVyIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoLCB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICogICAgICAgICAgdG8gZmlsbCB0aGUgc3RyaW5nIHdpdGggYSBieXRlIHZhbHVlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHZhbHVlIGMgdG8gZmlsbCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbGxlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZmlsbFN0cmluZyA9IGZ1bmN0aW9uKGMsIG4pIHtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgcyArPSBjO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYyArPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBwZXIgYnl0ZSBYT1IgYmV0d2VlbiB0d28gYnl0ZSBzdHJpbmdzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYVxuICogc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzMSBmaXJzdCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gczIgc2Vjb25kIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gWE9SLlxuICpcbiAqIEByZXR1cm4gdGhlIFhPUidkIHJlc3VsdC5cbiAqL1xudXRpbC54b3JCeXRlcyA9IGZ1bmN0aW9uKHMxLCBzMiwgbikge1xuICB2YXIgczMgPSAnJztcbiAgdmFyIGIgPSAnJztcbiAgdmFyIHQgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB2YXIgYyA9IDA7XG4gIGZvcig7IG4gPiAwOyAtLW4sICsraSkge1xuICAgIGIgPSBzMS5jaGFyQ29kZUF0KGkpIF4gczIuY2hhckNvZGVBdChpKTtcbiAgICBpZihjID49IDEwKSB7XG4gICAgICBzMyArPSB0O1xuICAgICAgdCA9ICcnO1xuICAgICAgYyA9IDA7XG4gICAgfVxuICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICArK2M7XG4gIH1cbiAgczMgKz0gdDtcbiAgcmV0dXJuIHMzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5oZXhUb0J5dGVzID0gZnVuY3Rpb24oaGV4KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmRlY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBydmFsID0gJyc7XG4gIHZhciBpID0gMDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEgPT0gMSkge1xuICAgIC8vIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgY29udmVydCBmaXJzdCBjaGFyYWN0ZXIgYWxvbmVcbiAgICBpID0gMTtcbiAgICBydmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4WzBdLCAxNikpO1xuICB9XG4gIC8vIGNvbnZlcnQgMiBjaGFyYWN0ZXJzICgxIGJ5dGUpIGF0IGEgdGltZVxuICBmb3IoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gaGV4LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5ieXRlc1RvSGV4ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5oZXguZW5jb2RlIGluc3RlYWQuXCJcbiAgcmV0dXJuIHV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKS50b0hleCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiAzMi1iaXQgaW50ZWdlciB0byA0LWJpZy1lbmRpYW4gYnl0ZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGkgdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBzdHJpbmcuXG4gKi9cbnV0aWwuaW50MzJUb0J5dGVzID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLy8gYmFzZTY0IGNoYXJhY3RlcnMsIHJldmVyc2UgbWFwcGluZ1xudmFyIF9iYXNlNjQgPVxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xudmFyIF9iYXNlNjRJZHggPSBbXG4vKjQzIC00MyA9IDAqL1xuLyonKycsICAxLCAgMiwgIDMsJy8nICovXG4gICA2MiwgLTEsIC0xLCAtMSwgNjMsXG5cbi8qJzAnLCcxJywnMicsJzMnLCc0JywnNScsJzYnLCc3JywnOCcsJzknICovXG4gICA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksIDYwLCA2MSxcblxuLyoxNSwgMTYsIDE3LCc9JywgMTksIDIwLCAyMSAqL1xuICAtMSwgLTEsIC0xLCA2NCwgLTEsIC0xLCAtMSxcblxuLyo2NSAtIDQzID0gMjIqL1xuLyonQScsJ0InLCdDJywnRCcsJ0UnLCdGJywnRycsJ0gnLCdJJywnSicsJ0snLCdMJywnTScsICovXG4gICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLFxuXG4vKidOJywnTycsJ1AnLCdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJyAqL1xuICAgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsXG5cbi8qOTEgLSA0MyA9IDQ4ICovXG4vKjQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMgKi9cbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcblxuLyo5NyAtIDQzID0gNTQqL1xuLyonYScsJ2InLCdjJywnZCcsJ2UnLCdmJywnZycsJ2gnLCdpJywnaicsJ2snLCdsJywnbScgKi9cbiAgIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LFxuXG4vKiduJywnbycsJ3AnLCdxJywncicsJ3MnLCd0JywndScsJ3YnLCd3JywneCcsJ3knLCd6JyAqL1xuICAgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTFcbl07XG5cbi8vIGJhc2U1OCBjaGFyYWN0ZXJzIChCaXRjb2luIGFscGhhYmV0KVxudmFyIF9iYXNlNTggPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG5cbi8qKlxuICogQmFzZTY0IGVuY29kZXMgYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcyB0byBiYXNlNjQtZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dC5cbiAqL1xudXRpbC5lbmNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQgZGVjb2RlcyBhIHN0cmluZyBpbnRvIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlNjQtZW5jb2RlZCBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZGVjb2RlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgaW5zdGVhZC5cIlxuXG4gIC8vIHJlbW92ZSBhbGwgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcblxuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCkpO1xuICAgIGlmKGVuYzMgIT09IDY0KSB7XG4gICAgICAvLyBkZWNvZGVkIGF0IGxlYXN0IDIgYnl0ZXNcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFVURi04IGVuY29kZXMgdGhlIGdpdmVuIFVURi0xNiBlbmNvZGVkIHN0cmluZyAoYSBzdGFuZGFyZCBKYXZhU2NyaXB0XG4gKiBzdHJpbmcpLiBOb24tQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlIGVuY29kZWQgYXMgbXVsdGlwbGUgYnl0ZXMgYWNjb3JkaW5nXG4gKiB0byBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmVuY29kZVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIFVURi04IGVuY29kZWQgc3RyaW5nIGludG8gYSBVVEYtMTYgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgVVRGLTE2IGVuY29kZWQgc3RyaW5nIChzdGFuZGFyZCBKYXZhU2NyaXB0IHN0cmluZykuXG4gKi9cbnV0aWwuZGVjb2RlVXRmOCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn07XG5cbi8vIGJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyB0b29sc1xuLy8gRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG51dGlsLmJpbmFyeSA9IHtcbiAgcmF3OiB7fSxcbiAgaGV4OiB7fSxcbiAgYmFzZTY0OiB7fSxcbiAgYmFzZTU4OiB7fSxcbiAgYmFzZU4gOiB7XG4gICAgZW5jb2RlOiBiYXNlTi5lbmNvZGUsXG4gICAgZGVjb2RlOiBiYXNlTi5kZWNvZGVcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgVWludDhBcnJheSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy4gVGhpcyBlbmNvZGluZyB1c2VzXG4gKiBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1IGZvciBlYWNoIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5iaW5hcnkucmF3LmVuY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuIFRoaXMgZW5jb2RpbmcgdXNlc1xuICogYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgYmluYXJ5LWVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LnJhdy5kZWNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSAnYmluYXJ5JyBzdHJpbmcsIEFycmF5QnVmZmVyLCBEYXRhVmlldywgVHlwZWRBcnJheSwgb3JcbiAqIEJ5dGVCdWZmZXIgYXMgYSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuYmluYXJ5LmhleC5lbmNvZGUgPSB1dGlsLmJ5dGVzVG9IZXg7XG5cbi8qKlxuICogRGVjb2RlcyBhIGhleC1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGhleCB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5oZXguZGVjb2RlID0gZnVuY3Rpb24oaGV4LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBpID0gMCwgaiA9IG9mZnNldDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEpIHtcbiAgICAvLyBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGNvbnZlcnQgZmlyc3QgY2hhcmFjdGVyIGFsb25lXG4gICAgaSA9IDE7XG4gICAgb3V0W2orK10gPSBwYXJzZUludChoZXhbMF0sIDE2KTtcbiAgfVxuICAvLyBjb252ZXJ0IDIgY2hhcmFjdGVycyAoMSBieXRlKSBhdCBhIHRpbWVcbiAgZm9yKDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgIG91dFtqKytdID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEJhc2U2NC1lbmNvZGVzIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dCBzdHJpbmcuXG4gKi9cbnV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCBpbnB1dC5ieXRlTGVuZ3RoKSB7XG4gICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgY2hyMyA9IGlucHV0W2krK107XG5cbiAgICAvLyBlbmNvZGUgNCBjaGFyYWN0ZXIgZ3JvdXBcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KGNocjEgPj4gMik7XG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpKTtcbiAgICBpZihpc05hTihjaHIyKSkge1xuICAgICAgbGluZSArPSAnPT0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKTtcbiAgICAgIGxpbmUgKz0gaXNOYU4oY2hyMykgPyAnPScgOiBfYmFzZTY0LmNoYXJBdChjaHIzICYgNjMpO1xuICAgIH1cblxuICAgIGlmKG1heGxpbmUgJiYgbGluZS5sZW5ndGggPiBtYXhsaW5lKSB7XG4gICAgICBvdXRwdXQgKz0gbGluZS5zdWJzdHIoMCwgbWF4bGluZSkgKyAnXFxyXFxuJztcbiAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cihtYXhsaW5lKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0ICs9IGxpbmU7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZTY0LWVuY29kZWQgaW5wdXQgc3RyaW5nLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDQpICogMyk7XG4gIH1cblxuICAvLyByZW1vdmUgYWxsIG5vbi1iYXNlNjQgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dFtqKytdID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICBpZihlbmMzICE9PSA2NCkge1xuICAgICAgLy8gZGVjb2RlZCBhdCBsZWFzdCAyIGJ5dGVzXG4gICAgICBvdXRbaisrXSA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xuICAgICAgaWYoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgLy8gZGVjb2RlZCAzIGJ5dGVzXG4gICAgICAgIG91dFtqKytdID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSByZXN1bHQgaXMgdGhlIGV4YWN0IGRlY29kZWQgbGVuZ3RoXG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQuc3ViYXJyYXkoMCwgaik7XG59O1xuXG4vLyBhZGQgc3VwcG9ydCBmb3IgYmFzZTU4IGVuY29kaW5nL2RlY29kaW5nIHdpdGggQml0Y29pbiBhbHBoYWJldFxudXRpbC5iaW5hcnkuYmFzZTU4LmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlTi5lbmNvZGUoaW5wdXQsIF9iYXNlNTgsIG1heGxpbmUpO1xufTtcbnV0aWwuYmluYXJ5LmJhc2U1OC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZU4uZGVjb2RlKGlucHV0LCBfYmFzZTU4LCBtYXhsaW5lKTtcbn07XG5cbi8vIHRleHQgZW5jb2RpbmcvZGVjb2RpbmcgdG9vbHNcbi8vIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxudXRpbC50ZXh0ID0ge1xuICB1dGY4OiB7fSxcbiAgdXRmMTY6IHt9XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtOCBpbiBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwudGV4dC51dGY4LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgc3RyID0gdXRpbC5lbmNvZGVVdGY4KHN0cik7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi04IGNvbnRlbnRzIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgVWludDhBcnJheSB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAqL1xudXRpbC50ZXh0LnV0ZjguZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWwuZGVjb2RlVXRmOChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKSk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtMTYgaW4gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLnRleHQudXRmMTYuZW5jb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCAqIDIpO1xuICB9XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KG91dC5idWZmZXIpO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIHZhciBrID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgdmlld1trKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaiArPSAyO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi0xNiBjb250ZW50cyBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gKi9cbnV0aWwudGV4dC51dGYxNi5kZWNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnl0ZXMuYnVmZmVyKSk7XG59O1xuXG4vKipcbiAqIERlZmxhdGVzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIGEgZmxhc2ggaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBieXRlcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSByYXcgdHJ1ZSB0byByZXR1cm4gb25seSByYXcgZGVmbGF0ZSBkYXRhLCBmYWxzZSB0byBpbmNsdWRlIHpsaWJcbiAqICAgICAgICAgIGhlYWRlciBhbmQgdHJhaWxlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLlxuICovXG51dGlsLmRlZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgYnl0ZXMgPSB1dGlsLmRlY29kZTY0KGFwaS5kZWZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsKTtcblxuICAvLyBzdHJpcCB6bGliIGhlYWRlciBhbmQgdHJhaWxlciBpZiBuZWNlc3NhcnlcbiAgaWYocmF3KSB7XG4gICAgLy8gemxpYiBoZWFkZXIgaXMgMiBieXRlcyAoQ01GLEZMRykgd2hlcmUgRkxHIGluZGljYXRlcyB0aGF0XG4gICAgLy8gdGhlcmUgaXMgYSA0LWJ5dGUgRElDVCAoYWxkZXItMzIpIGJsb2NrIGJlZm9yZSB0aGUgZGF0YSBpZlxuICAgIC8vIGl0cyA1dGggYml0IGlzIHNldFxuICAgIHZhciBzdGFydCA9IDI7XG4gICAgdmFyIGZsZyA9IGJ5dGVzLmNoYXJDb2RlQXQoMSk7XG4gICAgaWYoZmxnICYgMHgyMCkge1xuICAgICAgc3RhcnQgPSA2O1xuICAgIH1cbiAgICAvLyB6bGliIHRyYWlsZXIgaXMgNCBieXRlcyBvZiBhZGxlci0zMlxuICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKHN0YXJ0LCBieXRlcy5sZW5ndGggLSA0KTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn07XG5cbi8qKlxuICogSW5mbGF0ZXMgdGhlIGdpdmVuIGRhdGEgdXNpbmcgYSBmbGFzaCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBkYXRhLlxuICogQHBhcmFtIHJhdyB0cnVlIGlmIHRoZSBpbmNvbWluZyBkYXRhIGhhcyBubyB6bGliIGhlYWRlciBvciB0cmFpbGVyIGFuZCBpc1xuICogICAgICAgICAgcmF3IERFRkxBVEUgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbmZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLCBudWxsIG9uIGVycm9yLlxuICovXG51dGlsLmluZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgLy8gVE9ETzogYWRkIHpsaWIgaGVhZGVyIGFuZCB0cmFpbGVyIGlmIG5lY2Vzc2FyeS9wb3NzaWJsZVxuICB2YXIgcnZhbCA9IGFwaS5pbmZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsO1xuICByZXR1cm4gKHJ2YWwgPT09IG51bGwpID8gbnVsbCA6IHV0aWwuZGVjb2RlNjQocnZhbCk7XG59O1xuXG4vKipcbiAqIFNldHMgYSBzdG9yYWdlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0gb2JqIHRoZSBzdG9yYWdlIG9iamVjdCwgbnVsbCB0byByZW1vdmUuXG4gKi9cbnZhciBfc2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQsIG9iaikge1xuICBpZighYXBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gIH1cblxuICB2YXIgcnZhbDtcbiAgaWYob2JqID09PSBudWxsKSB7XG4gICAgcnZhbCA9IGFwaS5yZW1vdmVJdGVtKGlkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBqc29uLWVuY29kZSBhbmQgYmFzZTY0LWVuY29kZSBvYmplY3RcbiAgICBvYmogPSB1dGlsLmVuY29kZTY0KEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIHJ2YWwgPSBhcGkuc2V0SXRlbShpZCwgb2JqKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBwb3RlbnRpYWwgZmxhc2ggZXJyb3JcbiAgaWYodHlwZW9mKHJ2YWwpICE9PSAndW5kZWZpbmVkJyAmJiBydmFsLnJ2YWwgIT09IHRydWUpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocnZhbC5lcnJvci5tZXNzYWdlKTtcbiAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgZXJyb3IubmFtZSA9IHJ2YWwuZXJyb3IubmFtZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIGEgc3RvcmFnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIHN0b3JhZ2Ugb2JqZWN0IGVudHJ5IG9yIG51bGwgaWYgbm9uZSBleGlzdHMuXG4gKi9cbnZhciBfZ2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQpIHtcbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBleGlzdGluZyBlbnRyeVxuICB2YXIgcnZhbCA9IGFwaS5nZXRJdGVtKGlkKTtcblxuICAvKiBOb3RlOiBXZSBjaGVjayBhcGkuaW5pdCBiZWNhdXNlIHdlIGNhbid0IGRvIChhcGkgPT0gbG9jYWxTdG9yYWdlKVxuICAgIG9uIElFIGJlY2F1c2Ugb2YgXCJDbGFzcyBkb2Vzbid0IHN1cHBvcnQgQXV0b21hdGlvblwiIGV4Y2VwdGlvbi4gT25seVxuICAgIHRoZSBmbGFzaCBhcGkgaGFzIGFuIGluaXQgbWV0aG9kIHNvIHRoaXMgd29ya3MgdG9vLCBidXQgd2UgbmVlZCBhXG4gICAgYmV0dGVyIHNvbHV0aW9uIGluIHRoZSBmdXR1cmUuICovXG5cbiAgLy8gZmxhc2ggcmV0dXJucyBpdGVtIHdyYXBwZWQgaW4gYW4gb2JqZWN0LCBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gIGlmKGFwaS5pbml0KSB7XG4gICAgaWYocnZhbC5ydmFsID09PSBudWxsKSB7XG4gICAgICBpZihydmFsLmVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihydmFsLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gbm8gZXJyb3IsIGJ1dCBhbHNvIG5vIGl0ZW1cbiAgICAgIHJ2YWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsID0gcnZhbC5ydmFsO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSBkZWNvZGluZ1xuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgLy8gYmFzZTY0LWRlY29kZSBhbmQganNvbi1kZWNvZGUgZGF0YVxuICAgIHJ2YWwgPSBKU09OLnBhcnNlKHV0aWwuZGVjb2RlNjQocnZhbCkpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFN0b3JlcyBhbiBpdGVtIGluIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKi9cbnZhciBfc2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgZGF0YSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogPT09IG51bGwpIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc3RvcmFnZSBvYmplY3RcbiAgICBvYmogPSB7fTtcbiAgfVxuICAvLyB1cGRhdGUga2V5XG4gIG9ialtrZXldID0gZGF0YTtcblxuICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgb2JqKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnZhciBfZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIHJ2YWwgPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIC8vIHJldHVybiBkYXRhIGF0IGtleVxuICAgIHJ2YWwgPSAoa2V5IGluIHJ2YWwpID8gcnZhbFtrZXldIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKi9cbnZhciBfcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogIT09IG51bGwgJiYga2V5IGluIG9iaikge1xuICAgIC8vIHJlbW92ZSBrZXlcbiAgICBkZWxldGUgb2JqW2tleV07XG5cbiAgICAvLyBzZWUgaWYgZW50cnkgaGFzIG5vIGtleXMgcmVtYWluaW5nXG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKGVtcHR5KSB7XG4gICAgICAvLyByZW1vdmUgZW50cnkgZW50aXJlbHkgaWYgbm8ga2V5cyBhcmUgbGVmdFxuICAgICAgb2JqID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqL1xudmFyIF9jbGVhckl0ZW1zID0gZnVuY3Rpb24oYXBpLCBpZCkge1xuICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBudWxsKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBzdG9yYWdlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBmdW5jIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICogQHBhcmFtIGFyZ3MgdGhlIGFyZ3VtZW50cyBmb3IgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIGxvY2F0aW9uIHRoZSBsb2NhdGlvbiBhcmd1bWVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXG4gKi9cbnZhciBfY2FsbFN0b3JhZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIGxvY2F0aW9uKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBkZWZhdWx0IHN0b3JhZ2UgdHlwZXNcbiAgaWYodHlwZW9mKGxvY2F0aW9uKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhdGlvbiA9IFsnd2ViJywgJ2ZsYXNoJ107XG4gIH1cblxuICAvLyBhcHBseSBzdG9yYWdlIHR5cGVzIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcbiAgdmFyIHR5cGU7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciBleGNlcHRpb24gPSBudWxsO1xuICBmb3IodmFyIGlkeCBpbiBsb2NhdGlvbikge1xuICAgIHR5cGUgPSBsb2NhdGlvbltpZHhdO1xuICAgIHRyeSB7XG4gICAgICBpZih0eXBlID09PSAnZmxhc2gnIHx8IHR5cGUgPT09ICdib3RoJykge1xuICAgICAgICBpZihhcmdzWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGFzaCBsb2NhbCBzdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSAodHlwZSA9PT0gJ2ZsYXNoJyk7XG4gICAgICB9XG4gICAgICBpZih0eXBlID09PSAnd2ViJyB8fCB0eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgYXJnc1swXSA9IGxvY2FsU3RvcmFnZTtcbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgIGV4Y2VwdGlvbiA9IGV4O1xuICAgIH1cbiAgICBpZihkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZighZG9uZSkge1xuICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTdG9yZXMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFRoZSBhdmFpbGFibGUgdHlwZXMgb2YgbG9jYWwgc3RvcmFnZSBpbmNsdWRlICdmbGFzaCcsICd3ZWInLCBhbmQgJ2JvdGgnLlxuICpcbiAqIFRoZSB0eXBlICdmbGFzaCcgcmVmZXJzIHRvIGZsYXNoIGxvY2FsIHN0b3JhZ2UgKFNoYXJlZE9iamVjdCkuIEluIG9yZGVyXG4gKiB0byB1c2UgZmxhc2ggbG9jYWwgc3RvcmFnZSwgdGhlICdhcGknIHBhcmFtZXRlciBtdXN0IGJlIHZhbGlkLiBUaGUgdHlwZVxuICogJ3dlYicgcmVmZXJzIHRvIFdlYlN0b3JhZ2UsIGlmIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci4gVGhlIHR5cGUgJ2JvdGgnXG4gKiByZWZlcnMgdG8gc3RvcmluZyB1c2luZyBib3RoICdmbGFzaCcgYW5kICd3ZWInLCBub3QganVzdCBvbmUgb3IgdGhlXG4gKiBvdGhlci5cbiAqXG4gKiBUaGUgbG9jYXRpb24gYXJyYXkgc2hvdWxkIGxpc3QgdGhlIHN0b3JhZ2UgdHlwZXMgdG8gdXNlIGluIG9yZGVyIG9mXG4gKiBwcmVmZXJlbmNlOlxuICpcbiAqIFsnZmxhc2gnXTogZmxhc2ggb25seSBzdG9yYWdlXG4gKiBbJ3dlYiddOiB3ZWIgb25seSBzdG9yYWdlXG4gKiBbJ2JvdGgnXTogdHJ5IHRvIHN0b3JlIGluIGJvdGhcbiAqIFsnZmxhc2gnLCd3ZWInXTogc3RvcmUgaW4gZmxhc2ggZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnd2ViJ1xuICogWyd3ZWInLCdmbGFzaCddOiBzdG9yZSBpbiB3ZWIgZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnZmxhc2gnXG4gKlxuICogVGhlIGxvY2F0aW9uIGFycmF5IGRlZmF1bHRzIHRvOiBbJ3dlYicsICdmbGFzaCddXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLCBudWxsIHRvIHVzZSBvbmx5IFdlYlN0b3JhZ2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLnNldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9zZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSwgbnVsbCB0byB1c2Ugb25seSBXZWJTdG9yYWdlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnV0aWwuZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9nZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5yZW1vdmVJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfcmVtb3ZlSXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UgaWYgZmxhc2ggaXMgYXZhaWxhYmxlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwuY2xlYXJJdGVtcyA9IGZ1bmN0aW9uKGFwaSwgaWQsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9jbGVhckl0ZW1zLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBzY2hlbWUsIGhvc3QsIGFuZCBwb3J0IGZyb20gYW4gaHR0cChzKSB1cmwuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgdXJsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgdXJsIG9iamVjdCBvciBudWxsIGlmIHRoZSB1cmwgaXMgaW52YWxpZC5cbiAqL1xudXRpbC5wYXJzZVVybCA9IGZ1bmN0aW9uKHN0cikge1xuICAvLyBGSVhNRTogdGhpcyByZWdleCBsb29rcyBhIGJpdCBicm9rZW5cbiAgdmFyIHJlZ2V4ID0gL14oaHR0cHM/KTpcXC9cXC8oW146Jl5cXC9dKik6PyhcXGQqKSguKikkL2c7XG4gIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gIHZhciBtID0gcmVnZXguZXhlYyhzdHIpO1xuICB2YXIgdXJsID0gKG0gPT09IG51bGwpID8gbnVsbCA6IHtcbiAgICBmdWxsOiBzdHIsXG4gICAgc2NoZW1lOiBtWzFdLFxuICAgIGhvc3Q6IG1bMl0sXG4gICAgcG9ydDogbVszXSxcbiAgICBwYXRoOiBtWzRdXG4gIH07XG4gIGlmKHVybCkge1xuICAgIHVybC5mdWxsSG9zdCA9IHVybC5ob3N0O1xuICAgIGlmKHVybC5wb3J0KSB7XG4gICAgICBpZih1cmwucG9ydCAhPT0gODAgJiYgdXJsLnNjaGVtZSA9PT0gJ2h0dHAnKSB7XG4gICAgICAgIHVybC5mdWxsSG9zdCArPSAnOicgKyB1cmwucG9ydDtcbiAgICAgIH0gZWxzZSBpZih1cmwucG9ydCAhPT0gNDQzICYmIHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgICAgdXJsLmZ1bGxIb3N0ICs9ICc6JyArIHVybC5wb3J0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih1cmwuc2NoZW1lID09PSAnaHR0cCcpIHtcbiAgICAgIHVybC5wb3J0ID0gODA7XG4gICAgfSBlbHNlIGlmKHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgIHVybC5wb3J0ID0gNDQzO1xuICAgIH1cbiAgICB1cmwuZnVsbCA9IHVybC5zY2hlbWUgKyAnOi8vJyArIHVybC5mdWxsSG9zdDtcbiAgfVxuICByZXR1cm4gdXJsO1xufTtcblxuLyogU3RvcmFnZSBmb3IgcXVlcnkgdmFyaWFibGVzICovXG52YXIgX3F1ZXJ5VmFyaWFibGVzID0gbnVsbDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB3aW5kb3cgbG9jYXRpb24gcXVlcnkgdmFyaWFibGVzLiBRdWVyeSBpcyBwYXJzZWQgb24gdGhlIGZpcnN0XG4gKiBjYWxsIGFuZCB0aGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgb24gc3Vic2VxdWVudCBjYWxscy4gVGhlIG1hcHBpbmdcbiAqIGlzIGZyb20ga2V5cyB0byBhbiBhcnJheSBvZiB2YWx1ZXMuIFBhcmFtZXRlcnMgd2l0aG91dCB2YWx1ZXMgd2lsbCBoYXZlXG4gKiBhbiBvYmplY3Qga2V5IHNldCBidXQgbm8gdmFsdWUgYWRkZWQgdG8gdGhlIHZhbHVlIGFycmF5LiBWYWx1ZXMgYXJlXG4gKiB1bmVzY2FwZWQuXG4gKlxuICogLi4uP2sxPXYxJmsyPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCJdLFxuICogICBcImsyXCI6IFtcInYyXCJdXG4gKiB9XG4gKlxuICogLi4uP2sxPXYxJmsxPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCIsIFwidjJcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazI6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl0sXG4gKiAgIFwiazJcIjogW11cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW11cbiAqIH1cbiAqXG4gKiBAcGFyYW0gcXVlcnkgdGhlIHF1ZXJ5IHN0cmluZyB0byBwYXJzZSAob3B0aW9uYWwsIGRlZmF1bHQgdG8gY2FjaGVkXG4gKiAgICAgICAgICByZXN1bHRzIGZyb20gcGFyc2luZyB3aW5kb3cgbG9jYXRpb24gc2VhcmNoIHF1ZXJ5KS5cbiAqXG4gKiBAcmV0dXJuIG9iamVjdCBtYXBwaW5nIGtleXMgdG8gdmFyaWFibGVzLlxuICovXG51dGlsLmdldFF1ZXJ5VmFyaWFibGVzID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24ocSkge1xuICAgIHZhciBydmFsID0ge307XG4gICAgdmFyIGt2cGFpcnMgPSBxLnNwbGl0KCcmJyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGt2cGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb3MgPSBrdnBhaXJzW2ldLmluZGV4T2YoJz0nKTtcbiAgICAgIHZhciBrZXk7XG4gICAgICB2YXIgdmFsO1xuICAgICAgaWYocG9zID4gMCkge1xuICAgICAgICBrZXkgPSBrdnBhaXJzW2ldLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICB2YWwgPSBrdnBhaXJzW2ldLnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGt2cGFpcnNbaV07XG4gICAgICAgIHZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZighKGtleSBpbiBydmFsKSkge1xuICAgICAgICBydmFsW2tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIC8vIGRpc2FsbG93IG92ZXJyaWRpbmcgb2JqZWN0IHByb3RvdHlwZSBrZXlzXG4gICAgICBpZighKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgcnZhbFtrZXldLnB1c2godW5lc2NhcGUodmFsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gICB2YXIgcnZhbDtcbiAgIGlmKHR5cGVvZihxdWVyeSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgIC8vIHNldCBjYWNoZWQgdmFyaWFibGVzIGlmIG5lZWRlZFxuICAgICBpZihfcXVlcnlWYXJpYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICBpZih0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgICAgICAvLyBwYXJzZSB3aW5kb3cgc2VhcmNoIHF1ZXJ5XG4gICAgICAgICAgX3F1ZXJ5VmFyaWFibGVzID0gcGFyc2Uod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gcXVlcnkgdmFyaWFibGVzIGF2YWlsYWJsZVxuICAgICAgICAgIF9xdWVyeVZhcmlhYmxlcyA9IHt9O1xuICAgICAgIH1cbiAgICAgfVxuICAgICBydmFsID0gX3F1ZXJ5VmFyaWFibGVzO1xuICAgfSBlbHNlIHtcbiAgICAgLy8gcGFyc2UgZ2l2ZW4gcXVlcnlcbiAgICAgcnZhbCA9IHBhcnNlKHF1ZXJ5KTtcbiAgIH1cbiAgIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBmcmFnbWVudCBpbnRvIGEgcGF0aCBhbmQgcXVlcnkuIFRoaXMgbWV0aG9kIHdpbGwgdGFrZSBhIFVSSVxuICogZnJhZ21lbnQgYW5kIGJyZWFrIGl0IHVwIGFzIGlmIGl0IHdlcmUgdGhlIG1haW4gVVJJLiBGb3IgZXhhbXBsZTpcbiAqICAgIC9iYXIvYmF6P2E9MSZiPTJcbiAqIHJlc3VsdHMgaW46XG4gKiAgICB7XG4gKiAgICAgICBwYXRoOiBbXCJiYXJcIiwgXCJiYXpcIl0sXG4gKiAgICAgICBxdWVyeToge1wiazFcIjogW1widjFcIl0sIFwiazJcIjogW1widjJcIl19XG4gKiAgICB9XG4gKlxuICogQHJldHVybiBvYmplY3Qgd2l0aCBhIHBhdGggYXJyYXkgYW5kIHF1ZXJ5IG9iamVjdC5cbiAqL1xudXRpbC5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgLy8gZGVmYXVsdCB0byB3aG9sZSBmcmFnbWVudFxuICB2YXIgZnAgPSBmcmFnbWVudDtcbiAgdmFyIGZxID0gJyc7XG4gIC8vIHNwbGl0IGludG8gcGF0aCBhbmQgcXVlcnkgaWYgcG9zc2libGUgYXQgdGhlIGZpcnN0ICc/J1xuICB2YXIgcG9zID0gZnJhZ21lbnQuaW5kZXhPZignPycpO1xuICBpZihwb3MgPiAwKSB7XG4gICAgZnAgPSBmcmFnbWVudC5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICBmcSA9IGZyYWdtZW50LnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgfVxuICAvLyBzcGxpdCBwYXRoIGJhc2VkIG9uICcvJyBhbmQgaWdub3JlIGZpcnN0IGVsZW1lbnQgaWYgZW1wdHlcbiAgdmFyIHBhdGggPSBmcC5zcGxpdCgnLycpO1xuICBpZihwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aFswXSA9PT0gJycpIHtcbiAgICBwYXRoLnNoaWZ0KCk7XG4gIH1cbiAgLy8gY29udmVydCBxdWVyeSBpbnRvIG9iamVjdFxuICB2YXIgcXVlcnkgPSAoZnEgPT09ICcnKSA/IHt9IDogdXRpbC5nZXRRdWVyeVZhcmlhYmxlcyhmcSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoU3RyaW5nOiBmcCxcbiAgICBxdWVyeVN0cmluZzogZnEsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnlcbiAgfTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSByZXF1ZXN0IG91dCBvZiBhIFVSSS1saWtlIHJlcXVlc3Qgc3RyaW5nLiBUaGlzIGlzIGludGVuZGVkIHRvXG4gKiBiZSB1c2VkIHdoZXJlIGEgZnJhZ21lbnQgaWQgKGFmdGVyIGEgVVJJICcjJykgaXMgcGFyc2VkIGFzIGEgVVJJIHdpdGhcbiAqIHBhdGggYW5kIHF1ZXJ5IHBhcnRzLiBUaGUgc3RyaW5nIHNob3VsZCBoYXZlIGEgcGF0aCBiZWdpbm5pbmcgYW5kXG4gKiBkZWxpbWl0ZWQgYnkgJy8nIGFuZCBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzIGZvbGxvd2luZyBhICc/Jy4gVGhlXG4gKiBxdWVyeSBzaG91bGQgYmUgYSBzdGFuZGFyZCBVUkwgc2V0IG9mIGtleSB2YWx1ZSBwYWlycyBkZWxpbWl0ZWQgYnlcbiAqICcmJy4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRoZSBpbml0aWFsICcvJyBvbiB0aGUgcGF0aCBpcyBub3RcbiAqIHJlcXVpcmVkLiBUaGUgcmVxdWVzdCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgQVBJLCAoZnVsbHkgZGVzY3JpYmVkXG4gKiBpbiB0aGUgbWV0aG9kIGNvZGUpOlxuICogICAge1xuICogICAgICAgcGF0aDogPHRoZSBwYXRoIHN0cmluZyBwYXJ0Pi5cbiAqICAgICAgIHF1ZXJ5OiA8dGhlIHF1ZXJ5IHN0cmluZyBwYXJ0PixcbiAqICAgICAgIGdldFBhdGgoaSk6IGdldCBwYXJ0IG9yIGFsbCBvZiB0aGUgc3BsaXQgcGF0aCBhcnJheSxcbiAqICAgICAgIGdldFF1ZXJ5KGssIGkpOiBnZXQgcGFydCBvciBhbGwgb2YgYSBxdWVyeSBrZXkgYXJyYXksXG4gKiAgICAgICBnZXRRdWVyeUxhc3QoaywgX2RlZmF1bHQpOiBnZXQgbGFzdCBlbGVtZW50IG9mIGEgcXVlcnkga2V5IGFycmF5LlxuICogICAgfVxuICpcbiAqIEByZXR1cm4gb2JqZWN0IHdpdGggcmVxdWVzdCBwYXJhbWV0ZXJzLlxuICovXG51dGlsLm1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxU3RyaW5nKSB7XG4gIHZhciBmcmFnID0gdXRpbC5wYXJzZUZyYWdtZW50KHJlcVN0cmluZyk7XG4gIHZhciByZXEgPSB7XG4gICAgLy8gZnVsbCBwYXRoIHN0cmluZ1xuICAgIHBhdGg6IGZyYWcucGF0aFN0cmluZyxcbiAgICAvLyBmdWxsIHF1ZXJ5IHN0cmluZ1xuICAgIHF1ZXJ5OiBmcmFnLnF1ZXJ5U3RyaW5nLFxuICAgIC8qKlxuICAgICAqIEdldCBwYXRoIG9yIGVsZW1lbnQgaW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHBhdGggaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHBhdGggb3IgcGFydCBvZiBwYXRoIGlmIGkgcHJvdmlkZWQuXG4gICAgICovXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuICh0eXBlb2YoaSkgPT09ICd1bmRlZmluZWQnKSA/IGZyYWcucGF0aCA6IGZyYWcucGF0aFtpXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBxdWVyeSwgdmFsdWVzIGZvciBhIGtleSwgb3IgdmFsdWUgZm9yIGEga2V5IGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGsgb3B0aW9uYWwgcXVlcnkga2V5LlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHF1ZXJ5IGtleSBpbmRleC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gcXVlcnksIHZhbHVlcyBmb3IgYSBrZXksIG9yIHZhbHVlIGZvciBhIGtleSBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRRdWVyeTogZnVuY3Rpb24oaywgaSkge1xuICAgICAgdmFyIHJ2YWw7XG4gICAgICBpZih0eXBlb2YoaykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJ2YWwgPSBmcmFnLnF1ZXJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IGZyYWcucXVlcnlba107XG4gICAgICAgIGlmKHJ2YWwgJiYgdHlwZW9mKGkpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICBydmFsID0gcnZhbFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcbiAgICBnZXRRdWVyeUxhc3Q6IGZ1bmN0aW9uKGssIF9kZWZhdWx0KSB7XG4gICAgICB2YXIgcnZhbDtcbiAgICAgIHZhciB2YWxzID0gcmVxLmdldFF1ZXJ5KGspO1xuICAgICAgaWYodmFscykge1xuICAgICAgICBydmFsID0gdmFsc1t2YWxzLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IF9kZWZhdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIFVSSSBvdXQgb2YgYSBwYXRoLCBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzLCBhbmQgYVxuICogZnJhZ21lbnQuIFVzZXMgalF1ZXJ5LnBhcmFtKCkgaW50ZXJuYWxseSBmb3IgcXVlcnkgc3RyaW5nIGNyZWF0aW9uLlxuICogSWYgdGhlIHBhdGggaXMgYW4gYXJyYXksIGl0IHdpbGwgYmUgam9pbmVkIHdpdGggJy8nLlxuICpcbiAqIEBwYXJhbSBwYXRoIHN0cmluZyBwYXRoIG9yIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gcXVlcnkgb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycy4gKG9wdGlvbmFsKVxuICogQHBhcmFtIGZyYWdtZW50IGZyYWdtZW50IHN0cmluZy4gKG9wdGlvbmFsKVxuICpcbiAqIEByZXR1cm4gc3RyaW5nIG9iamVjdCB3aXRoIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAqL1xudXRpbC5tYWtlTGluayA9IGZ1bmN0aW9uKHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCkge1xuICAvLyBqb2luIHBhdGggcGFydHMgaWYgbmVlZGVkXG4gIHBhdGggPSBqUXVlcnkuaXNBcnJheShwYXRoKSA/IHBhdGguam9pbignLycpIDogcGF0aDtcblxuICB2YXIgcXN0ciA9IGpRdWVyeS5wYXJhbShxdWVyeSB8fCB7fSk7XG4gIGZyYWdtZW50ID0gZnJhZ21lbnQgfHwgJyc7XG4gIHJldHVybiBwYXRoICtcbiAgICAoKHFzdHIubGVuZ3RoID4gMCkgPyAoJz8nICsgcXN0cikgOiAnJykgK1xuICAgICgoZnJhZ21lbnQubGVuZ3RoID4gMCkgPyAoJyMnICsgZnJhZ21lbnQpIDogJycpO1xufTtcblxuLyoqXG4gKiBGb2xsb3dzIGEgcGF0aCBvZiBrZXlzIGRlZXAgaW50byBhbiBvYmplY3QgaGllcmFyY2h5IGFuZCBzZXQgYSB2YWx1ZS5cbiAqIElmIGEga2V5IGRvZXMgbm90IGV4aXN0IG9yIGl0J3MgdmFsdWUgaXMgbm90IGFuIG9iamVjdCwgY3JlYXRlIGFuXG4gKiBvYmplY3QgaW4gaXQncyBwbGFjZS4gVGhpcyBjYW4gYmUgZGVzdHJ1Y3RpdmUgdG8gYSBvYmplY3QgdHJlZSBpZlxuICogbGVhZiBub2RlcyBhcmUgZ2l2ZW4gYXMgbm9uLWZpbmFsIHBhdGgga2V5cy5cbiAqIFVzZWQgdG8gYXZvaWQgZXhjZXB0aW9ucyBmcm9tIG1pc3NpbmcgcGFydHMgb2YgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtIG9iamVjdCB0aGUgc3RhcnRpbmcgb2JqZWN0LlxuICogQHBhcmFtIGtleXMgYW4gYXJyYXkgb2Ygc3RyaW5nIGtleXMuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHNldC5cbiAqL1xudXRpbC5zZXRQYXRoID0gZnVuY3Rpb24ob2JqZWN0LCBrZXlzLCB2YWx1ZSkge1xuICAvLyBuZWVkIHRvIHN0YXJ0IGF0IGFuIG9iamVjdFxuICBpZih0eXBlb2Yob2JqZWN0KSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICB2YXIgbmV4dCA9IGtleXNbaSsrXTtcbiAgICAgIGlmKGkgPT0gbGVuKSB7XG4gICAgICAgIC8vIGxhc3RcbiAgICAgICAgb2JqZWN0W25leHRdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3JlXG4gICAgICAgIHZhciBoYXNOZXh0ID0gKG5leHQgaW4gb2JqZWN0KTtcbiAgICAgICAgaWYoIWhhc05leHQgfHxcbiAgICAgICAgICAoaGFzTmV4dCAmJiB0eXBlb2Yob2JqZWN0W25leHRdKSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgKGhhc05leHQgJiYgb2JqZWN0W25leHRdID09PSBudWxsKSkge1xuICAgICAgICAgIG9iamVjdFtuZXh0XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtuZXh0XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9sbG93cyBhIHBhdGggb2Yga2V5cyBkZWVwIGludG8gYW4gb2JqZWN0IGhpZXJhcmNoeSBhbmQgcmV0dXJuIGEgdmFsdWUuXG4gKiBJZiBhIGtleSBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGFuIG9iamVjdCBpbiBpdCdzIHBsYWNlLlxuICogVXNlZCB0byBhdm9pZCBleGNlcHRpb25zIGZyb20gbWlzc2luZyBwYXJ0cyBvZiB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBzdGFydGluZyBvYmplY3QuXG4gKiBAcGFyYW0ga2V5cyBhbiBhcnJheSBvZiBzdHJpbmcga2V5cy5cbiAqIEBwYXJhbSBfZGVmYXVsdCB2YWx1ZSB0byByZXR1cm4gaWYgcGF0aCBub3QgZm91bmQuXG4gKlxuICogQHJldHVybiB0aGUgdmFsdWUgYXQgdGhlIHBhdGggaWYgZm91bmQsIGVsc2UgZGVmYXVsdCBpZiBnaXZlbiwgZWxzZVxuICogICAgICAgICB1bmRlZmluZWQuXG4gKi9cbnV0aWwuZ2V0UGF0aCA9IGZ1bmN0aW9uKG9iamVjdCwga2V5cywgX2RlZmF1bHQpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHZhciBoYXNOZXh0ID0gdHJ1ZTtcbiAgd2hpbGUoaGFzTmV4dCAmJiBpIDwgbGVuICYmXG4gICAgdHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0ID0ga2V5c1tpKytdO1xuICAgIGhhc05leHQgPSBuZXh0IGluIG9iamVjdDtcbiAgICBpZihoYXNOZXh0KSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbbmV4dF07XG4gICAgfVxuICB9XG4gIHJldHVybiAoaGFzTmV4dCA/IG9iamVjdCA6IF9kZWZhdWx0KTtcbn07XG5cbi8qKlxuICogRm9sbG93IGEgcGF0aCBvZiBrZXlzIGRlZXAgaW50byBhbiBvYmplY3QgaGllcmFyY2h5IGFuZCBkZWxldGUgdGhlXG4gKiBsYXN0IG9uZS4gSWYgYSBrZXkgZG9lcyBub3QgZXhpc3QsIGRvIG5vdGhpbmcuXG4gKiBVc2VkIHRvIGF2b2lkIGV4Y2VwdGlvbnMgZnJvbSBtaXNzaW5nIHBhcnRzIG9mIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgdGhlIHN0YXJ0aW5nIG9iamVjdC5cbiAqIEBwYXJhbSBrZXlzIGFuIGFycmF5IG9mIHN0cmluZyBrZXlzLlxuICovXG51dGlsLmRlbGV0ZVBhdGggPSBmdW5jdGlvbihvYmplY3QsIGtleXMpIHtcbiAgLy8gbmVlZCB0byBzdGFydCBhdCBhbiBvYmplY3RcbiAgaWYodHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgdmFyIG5leHQgPSBrZXlzW2krK107XG4gICAgICBpZihpID09IGxlbikge1xuICAgICAgICAvLyBsYXN0XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbmV4dF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3JlXG4gICAgICAgIGlmKCEobmV4dCBpbiBvYmplY3QpIHx8XG4gICAgICAgICAgKHR5cGVvZihvYmplY3RbbmV4dF0pICE9PSAnb2JqZWN0JykgfHxcbiAgICAgICAgICAob2JqZWN0W25leHRdID09PSBudWxsKSkge1xuICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3RbbmV4dF07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBlbXB0eS5cbiAqXG4gKiBUYWtlbiBmcm9tOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QtZnJvbS1qc29uLzY3OTkzNyM2Nzk5MzdcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY2hlY2suXG4gKi9cbnV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgd2l0aCBzaW1wbGUgcHJpbnRmLXN0eWxlIGludGVycG9sYXRpb24uXG4gKlxuICogJSU6IGxpdGVyYWwgJyUnXG4gKiAlcywlbzogY29udmVydCBuZXh0IGFyZ3VtZW50IGludG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGZvcm1hdCB0aGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSAuLi4gYXJndW1lbnRzIHRvIGludGVycG9sYXRlIGludG8gdGhlIGZvcm1hdCBzdHJpbmcuXG4gKi9cbnV0aWwuZm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gIHZhciByZSA9IC8lLi9nO1xuICAvLyBjdXJyZW50IG1hdGNoXG4gIHZhciBtYXRjaDtcbiAgLy8gY3VycmVudCBwYXJ0XG4gIHZhciBwYXJ0O1xuICAvLyBjdXJyZW50IGFyZyBpbmRleFxuICB2YXIgYXJnaSA9IDA7XG4gIC8vIGNvbGxlY3RlZCBwYXJ0cyB0byByZWNvbWJpbmUgbGF0ZXJcbiAgdmFyIHBhcnRzID0gW107XG4gIC8vIGxhc3QgaW5kZXggZm91bmRcbiAgdmFyIGxhc3QgPSAwO1xuICAvLyBsb29wIHdoaWxlIG1hdGNoZXMgcmVtYWluXG4gIHdoaWxlKChtYXRjaCA9IHJlLmV4ZWMoZm9ybWF0KSkpIHtcbiAgICBwYXJ0ID0gZm9ybWF0LnN1YnN0cmluZyhsYXN0LCByZS5sYXN0SW5kZXggLSAyKTtcbiAgICAvLyBkb24ndCBhZGQgZW1wdHkgc3RyaW5ncyAoaWUsIHBhcnRzIGJldHdlZW4gJXMlcylcbiAgICBpZihwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGxhc3QgPSByZS5sYXN0SW5kZXg7XG4gICAgLy8gc3dpdGNoIG9uICUgY29kZVxuICAgIHZhciBjb2RlID0gbWF0Y2hbMF1bMV07XG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICBjYXNlICdzJzpcbiAgICBjYXNlICdvJzpcbiAgICAgIC8vIGNoZWNrIGlmIGVub3VnaCBhcmd1bWVudHMgd2VyZSBnaXZlblxuICAgICAgaWYoYXJnaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChhcmd1bWVudHNbYXJnaSsrICsgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaCgnPD8+Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBGSVhNRTogZG8gcHJvcGVyIGZvcm1hdGluZyBmb3IgbnVtYmVycywgZXRjXG4gICAgLy9jYXNlICdmJzpcbiAgICAvL2Nhc2UgJ2QnOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcGFydHMucHVzaCgnJScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhcnRzLnB1c2goJzwlJyArIGNvZGUgKyAnPz4nKTtcbiAgICB9XG4gIH1cbiAgLy8gYWRkIHRyYWlsaW5nIHBhcnQgb2YgZm9ybWF0IHN0cmluZ1xuICBwYXJ0cy5wdXNoKGZvcm1hdC5zdWJzdHJpbmcobGFzdCkpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0NS9qYXZhc2NyaXB0LW51bWJlcmZvcm1hdC0tcG9ydGVkLWZyb20tcGhwL1xuICovXG51dGlsLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCkge1xuICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vY3Jlc3RpZGcuY29tKVxuICAvLyArICAgICBidWdmaXggYnk6IEJlbmphbWluIEx1cHRvblxuICAvLyArICAgICBidWdmaXggYnk6IEFsbGFuIEplbnNlbiAoaHR0cDovL3d3dy53aW50ZXJuZXQubm8pXG4gIC8vICsgICAgcmV2aXNlZCBieTogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuICAvLyAqICAgICBleGFtcGxlIDE6IG51bWJlcl9mb3JtYXQoMTIzNC41Njc4LCAyLCAnLicsICcnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjM0LjU3XG5cbiAgdmFyIG4gPSBudW1iZXIsIGMgPSBpc05hTihkZWNpbWFscyA9IE1hdGguYWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHM7XG4gIHZhciBkID0gZGVjX3BvaW50ID09PSB1bmRlZmluZWQgPyAnLCcgOiBkZWNfcG9pbnQ7XG4gIHZhciB0ID0gdGhvdXNhbmRzX3NlcCA9PT0gdW5kZWZpbmVkID9cbiAgICcuJyA6IHRob3VzYW5kc19zZXAsIHMgPSBuIDwgMCA/ICctJyA6ICcnO1xuICB2YXIgaSA9IHBhcnNlSW50KChuID0gTWF0aC5hYnMoK24gfHwgMCkudG9GaXhlZChjKSksIDEwKSArICcnO1xuICB2YXIgaiA9IChpLmxlbmd0aCA+IDMpID8gaS5sZW5ndGggJSAzIDogMDtcbiAgcmV0dXJuIHMgKyAoaiA/IGkuc3Vic3RyKDAsIGopICsgdCA6ICcnKSArXG4gICAgaS5zdWJzdHIoaikucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csICckMScgKyB0KSArXG4gICAgKGMgPyBkICsgTWF0aC5hYnMobiAtIGkpLnRvRml4ZWQoYykuc2xpY2UoMikgOiAnJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBieXRlIHNpemUuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0OS9mb3JtYXQtaHVtYW5pemUtZmlsZS1ieXRlLXNpemUtcHJlc2VudGF0aW9uLWluLWphdmFzY3JpcHQvXG4gKi9cbnV0aWwuZm9ybWF0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYoc2l6ZSA+PSAxMDczNzQxODI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDczNzQxODI0LCAyLCAnLicsICcnKSArICcgR2lCJztcbiAgfSBlbHNlIGlmKHNpemUgPj0gMTA0ODU3Nikge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA0ODU3NiwgMiwgJy4nLCAnJykgKyAnIE1pQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwMjQpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwMjQsIDApICsgJyBLaUInO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplLCAwKSArICcgYnl0ZXMnO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IG9yIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBvciBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSA0LWJ5dGUgSVB2NiBvciAxNi1ieXRlIElQdjYgYWRkcmVzcyBvciBudWxsIGlmIHRoZSBhZGRyZXNzIGNhbid0XG4gKiAgICAgICAgIGJlIHBhcnNlZC5cbiAqL1xudXRpbC5ieXRlc0Zyb21JUCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlmKGlwLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc0Zyb21JUHY0KGlwKTtcbiAgfVxuICBpZihpcC5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NihpcCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlwID0gaXAuc3BsaXQoJy4nKTtcbiAgaWYoaXAubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaXAubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbnVtID0gcGFyc2VJbnQoaXBbaV0sIDEwKTtcbiAgICBpZihpc05hTihudW0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYi5wdXRCeXRlKG51bSk7XG4gIH1cbiAgcmV0dXJuIGIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW50byBieXRlcyAoaW4gbmV0d29yayBvcmRlcikuXG4gKlxuICogQHBhcmFtIGlwIHRoZSBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSAxNi1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NiA9IGZ1bmN0aW9uKGlwKSB7XG4gIHZhciBibGFua3MgPSAwO1xuICBpcCA9IGlwLnNwbGl0KCc6JykuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICBpZihlLmxlbmd0aCA9PT0gMCkgKytibGFua3M7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICB2YXIgemVyb3MgPSAoOCAtIGlwLmxlbmd0aCArIGJsYW5rcykgKiAyO1xuICB2YXIgYiA9IHV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICBpZighaXBbaV0gfHwgaXBbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBiLmZpbGxXaXRoQnl0ZSgwLCB6ZXJvcyk7XG4gICAgICB6ZXJvcyA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGJ5dGVzID0gdXRpbC5oZXhUb0J5dGVzKGlwW2ldKTtcbiAgICBpZihieXRlcy5sZW5ndGggPCAyKSB7XG4gICAgICBiLnB1dEJ5dGUoMCk7XG4gICAgfVxuICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciAxNi1ieXRlcyBpbnRvXG4gKiBhbiBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmUgaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiA0IG9yIDE2IGJ5dGVzLFxuICogICAgICAgICByZXNwZWN0aXZlbHksIGFyZSBnaXZlbiwgb3RoZXJ3aXNlIG51bGwuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYoYnl0ZXMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjQoYnl0ZXMpO1xuICB9XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gMTYpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc1RvSVB2NihieXRlcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpcCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpcC5wdXNoKGJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICB9XG4gIHJldHVybiBpcC5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDE2LWJ5dGVzIGludG8gYW4gSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZXMgbXVzdCBiZVxuICogaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NiA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgdmFyIHplcm9Hcm91cHMgPSBbXTtcbiAgdmFyIHplcm9NYXhHcm91cCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBoZXggPSB1dGlsLmJ5dGVzVG9IZXgoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0pO1xuICAgIC8vIGNhbm9uaWNhbGl6ZSB6ZXJvIHJlcHJlc2VudGF0aW9uXG4gICAgd2hpbGUoaGV4WzBdID09PSAnMCcgJiYgaGV4ICE9PSAnMCcpIHtcbiAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGlmKGhleCA9PT0gJzAnKSB7XG4gICAgICB2YXIgbGFzdCA9IHplcm9Hcm91cHNbemVyb0dyb3Vwcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBpZHggPSBpcC5sZW5ndGg7XG4gICAgICBpZighbGFzdCB8fCBpZHggIT09IGxhc3QuZW5kICsgMSkge1xuICAgICAgICB6ZXJvR3JvdXBzLnB1c2goe3N0YXJ0OiBpZHgsIGVuZDogaWR4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0LmVuZCA9IGlkeDtcbiAgICAgICAgaWYoKGxhc3QuZW5kIC0gbGFzdC5zdGFydCkgPlxuICAgICAgICAgICh6ZXJvR3JvdXBzW3plcm9NYXhHcm91cF0uZW5kIC0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLnN0YXJ0KSkge1xuICAgICAgICAgIHplcm9NYXhHcm91cCA9IHplcm9Hcm91cHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpcC5wdXNoKGhleCk7XG4gIH1cbiAgaWYoemVyb0dyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGdyb3VwID0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdO1xuICAgIC8vIG9ubHkgc2hvcnRlbiBncm91cCBvZiBsZW5ndGggPiAwXG4gICAgaWYoZ3JvdXAuZW5kIC0gZ3JvdXAuc3RhcnQgPiAwKSB7XG4gICAgICBpcC5zcGxpY2UoZ3JvdXAuc3RhcnQsIGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ICsgMSwgJycpO1xuICAgICAgaWYoZ3JvdXAuc3RhcnQgPT09IDApIHtcbiAgICAgICAgaXAudW5zaGlmdCgnJyk7XG4gICAgICB9XG4gICAgICBpZihncm91cC5lbmQgPT09IDcpIHtcbiAgICAgICAgaXAucHVzaCgnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpcC5qb2luKCc6Jyk7XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHByb2Nlc3NlcyB0aGF0IGNhbiBiZSBydW4gY29uY3VycmVudGx5LiBJZlxuICogY3JlYXRpbmcgV2ViIFdvcmtlcnMsIGtlZXAgaW4gbWluZCB0aGF0IHRoZSBtYWluIEphdmFTY3JpcHQgcHJvY2VzcyBuZWVkc1xuICogaXRzIG93biBjb3JlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIHVwZGF0ZSB0cnVlIHRvIGZvcmNlIGFuIHVwZGF0ZSAobm90IHVzZSB0aGUgY2FjaGVkIHZhbHVlKS5cbiAqIEBwYXJhbSBjYWxsYmFjayhlcnIsIG1heCkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnV0aWwuZXN0aW1hdGVDb3JlcyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoJ2NvcmVzJyBpbiB1dGlsICYmICFvcHRpb25zLnVwZGF0ZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICdoYXJkd2FyZUNvbmN1cnJlbmN5JyBpbiBuYXZpZ2F0b3IgJiZcbiAgICBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSA+IDApIHtcbiAgICB1dGlsLmNvcmVzID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gd29ya2VycyBub3QgYXZhaWxhYmxlXG4gICAgdXRpbC5jb3JlcyA9IDE7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNhbid0IGVzdGltYXRlLCBkZWZhdWx0IHRvIDJcbiAgICB1dGlsLmNvcmVzID0gMjtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cblxuICAvLyBjcmVhdGUgd29ya2VyIGNvbmN1cnJlbmN5IGVzdGltYXRpb24gY29kZSBhcyBibG9iXG4gIHZhciBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnLFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBydW4gd29ya2VyIGZvciA0IG1zXG4gICAgICAgIHZhciBzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBldCA9IHN0ICsgNDtcbiAgICAgICAgd2hpbGUoRGF0ZS5ub3coKSA8IGV0KTtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7c3Q6IHN0LCBldDogZXR9KTtcbiAgICAgIH0pO1xuICAgIH0udG9TdHJpbmcoKSxcbiAgJykoKSddLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSkpO1xuXG4gIC8vIHRha2UgNSBzYW1wbGVzIHVzaW5nIDE2IHdvcmtlcnNcbiAgc2FtcGxlKFtdLCA1LCAxNik7XG5cbiAgZnVuY3Rpb24gc2FtcGxlKG1heCwgc2FtcGxlcywgbnVtV29ya2Vycykge1xuICAgIGlmKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIGdldCBvdmVybGFwIGF2ZXJhZ2VcbiAgICAgIHZhciBhdmcgPSBNYXRoLmZsb29yKG1heC5yZWR1Y2UoZnVuY3Rpb24oYXZnLCB4KSB7XG4gICAgICAgIHJldHVybiBhdmcgKyB4O1xuICAgICAgfSwgMCkgLyBtYXgubGVuZ3RoKTtcbiAgICAgIHV0aWwuY29yZXMgPSBNYXRoLm1heCgxLCBhdmcpO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgICB9XG4gICAgbWFwKG51bVdvcmtlcnMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgbWF4LnB1c2gocmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpKTtcbiAgICAgIHNhbXBsZShtYXgsIHNhbXBsZXMgLSAxLCBudW1Xb3JrZXJzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcChudW1Xb3JrZXJzLCBjYWxsYmFjaykge1xuICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZS5kYXRhKTtcbiAgICAgICAgaWYocmVzdWx0cy5sZW5ndGggPT09IG51bVdvcmtlcnMpIHtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgICB3b3JrZXJzW2ldLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3b3JrZXJzLnB1c2god29ya2VyKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5wb3N0TWVzc2FnZShpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWR1Y2UobnVtV29ya2VycywgcmVzdWx0cykge1xuICAgIC8vIGZpbmQgb3ZlcmxhcHBpbmcgdGltZSB3aW5kb3dzXG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IG51bVdvcmtlcnM7ICsrbikge1xuICAgICAgdmFyIHIxID0gcmVzdWx0c1tuXTtcbiAgICAgIHZhciBvdmVybGFwID0gb3ZlcmxhcHNbbl0gPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgICAgaWYobiA9PT0gaSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByMiA9IHJlc3VsdHNbaV07XG4gICAgICAgIGlmKChyMS5zdCA+IHIyLnN0ICYmIHIxLnN0IDwgcjIuZXQpIHx8XG4gICAgICAgICAgKHIyLnN0ID4gcjEuc3QgJiYgcjIuc3QgPCByMS5ldCkpIHtcbiAgICAgICAgICBvdmVybGFwLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZ2V0IG1heGltdW0gb3ZlcmxhcHMgLi4uIGRvbid0IGluY2x1ZGUgb3ZlcmxhcHBpbmcgd29ya2VyIGl0c2VsZlxuICAgIC8vIGFzIHRoZSBtYWluIEpTIHByb2Nlc3Mgd2FzIGFsc28gYmVpbmcgc2NoZWR1bGVkIGR1cmluZyB0aGUgd29yayBhbmRcbiAgICAvLyB3b3VsZCBoYXZlIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgZXN0aW1hdGUgYW55d2F5XG4gICAgcmV0dXJuIG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbihtYXgsIG92ZXJsYXApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIG92ZXJsYXAubGVuZ3RoKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBOdW1iZXIgT25lLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBbiBBUEkgZm9yIHN0b3JpbmcgZGF0YSB1c2luZyB0aGUgQWJzdHJhY3QgU3ludGF4IE5vdGF0aW9uIE51bWJlciBPbmVcbiAqIGZvcm1hdCB1c2luZyBERVIgKERpc3Rpbmd1aXNoZWQgRW5jb2RpbmcgUnVsZXMpIGVuY29kaW5nLiBUaGlzIGVuY29kaW5nIGlzXG4gKiBjb21tb25seSB1c2VkIHRvIHN0b3JlIGRhdGEgZm9yIFBLSSwgaS5lLiBYLjUwOSBDZXJ0aWZpY2F0ZXMsIGFuZCB0aGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBleGlzdHMgZm9yIHRoYXQgcHVycG9zZS5cbiAqXG4gKiBBYnN0cmFjdCBTeW50YXggTm90YXRpb24gTnVtYmVyIE9uZSAoQVNOLjEpIGlzIHVzZWQgdG8gZGVmaW5lIHRoZSBhYnN0cmFjdFxuICogc3ludGF4IG9mIGluZm9ybWF0aW9uIHdpdGhvdXQgcmVzdHJpY3RpbmcgdGhlIHdheSB0aGUgaW5mb3JtYXRpb24gaXMgZW5jb2RlZFxuICogZm9yIHRyYW5zbWlzc2lvbi4gSXQgcHJvdmlkZXMgYSBzdGFuZGFyZCB0aGF0IGFsbG93cyBmb3Igb3BlbiBzeXN0ZW1zXG4gKiBjb21tdW5pY2F0aW9uLiBBU04uMSBkZWZpbmVzIHRoZSBzeW50YXggb2YgaW5mb3JtYXRpb24gZGF0YSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNpbXBsZSBkYXRhIHR5cGVzIGFzIHdlbGwgYXMgYSBub3RhdGlvbiBmb3IgZGVzY3JpYmluZyB0aGVtIGFuZCBzcGVjaWZ5aW5nXG4gKiB2YWx1ZXMgZm9yIHRoZW0uXG4gKlxuICogVGhlIFJTQSBhbGdvcml0aG0gY3JlYXRlcyBwdWJsaWMgYW5kIHByaXZhdGUga2V5cyB0aGF0IGFyZSBvZnRlbiBzdG9yZWQgaW5cbiAqIFguNTA5IG9yIFBLQ1MjWCBmb3JtYXRzIC0tIHdoaWNoIHVzZSBBU04uMSAoZW5jb2RlZCBpbiBERVIgZm9ybWF0KS4gVGhpc1xuICogY2xhc3MgcHJvdmlkZXMgdGhlIG1vc3QgYmFzaWMgZnVuY3Rpb25hbGl0eSByZXF1aXJlZCB0byBzdG9yZSBhbmQgbG9hZCBEU0FcbiAqIGtleXMgdGhhdCBhcmUgZW5jb2RlZCBhY2NvcmRpbmcgdG8gQVNOLjEuXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIGJpbmFyeSBlbmNvZGluZ3MgZm9yIEFTTi4xIGFyZSBCRVIgKEJhc2ljIEVuY29kaW5nIFJ1bGVzKVxuICogYW5kIERFUiAoRGlzdGluZ3Vpc2hlZCBFbmNvZGluZyBSdWxlcykuIERFUiBpcyBqdXN0IGEgc3Vic2V0IG9mIEJFUiB0aGF0XG4gKiBoYXMgc3RyaWN0ZXIgcmVxdWlyZW1lbnRzIGZvciBob3cgZGF0YSBtdXN0IGJlIGVuY29kZWQuXG4gKlxuICogRWFjaCBBU04uMSBzdHJ1Y3R1cmUgaGFzIGEgdGFnIChhIGJ5dGUgaWRlbnRpZnlpbmcgdGhlIEFTTi4xIHN0cnVjdHVyZSB0eXBlKVxuICogYW5kIGEgYnl0ZSBhcnJheSBmb3IgdGhlIHZhbHVlIG9mIHRoaXMgQVNOMSBzdHJ1Y3R1cmUgd2hpY2ggbWF5IGJlIGRhdGEgb3IgYVxuICogbGlzdCBvZiBBU04uMSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEVhY2ggQVNOLjEgc3RydWN0dXJlIHVzaW5nIEJFUiBpcyAoVGFnLUxlbmd0aC1WYWx1ZSk6XG4gKlxuICogfCBieXRlIDAgfCBieXRlcyBYIHwgYnl0ZXMgWSB8XG4gKiB8LS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS1cbiAqIHwgIHRhZyAgIHwgbGVuZ3RoICB8ICB2YWx1ZSAgfFxuICpcbiAqIEFTTi4xIGFsbG93cyBmb3IgdGFncyB0byBiZSBvZiBcIkhpZ2gtdGFnLW51bWJlciBmb3JtXCIgd2hpY2ggYWxsb3dzIGEgdGFnIHRvXG4gKiBiZSB0d28gb3IgbW9yZSBvY3RldHMsIGJ1dCB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBjbGFzcy4gQSB0YWcgaXNcbiAqIG9ubHkgMSBieXRlLiBCaXRzIDEtNSBnaXZlIHRoZSB0YWcgbnVtYmVyIChpZSB0aGUgZGF0YSB0eXBlIHdpdGhpbiBhXG4gKiBwYXJ0aWN1bGFyICdjbGFzcycpLCA2IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgQVNOLjEgdmFsdWUgaXNcbiAqIGNvbnN0cnVjdGVkIGZyb20gb3RoZXIgQVNOLjEgdmFsdWVzLCBhbmQgYml0cyA3IGFuZCA4IGdpdmUgdGhlICdjbGFzcycuIElmXG4gKiBiaXRzIDcgYW5kIDggYXJlIGJvdGggemVybywgdGhlIGNsYXNzIGlzIFVOSVZFUlNBTC4gSWYgb25seSBiaXQgNyBpcyBzZXQsXG4gKiB0aGVuIHRoZSBjbGFzcyBpcyBBUFBMSUNBVElPTi4gSWYgb25seSBiaXQgOCBpcyBzZXQsIHRoZW4gdGhlIGNsYXNzIGlzXG4gKiBDT05URVhUX1NQRUNJRklDLiBJZiBib3RoIGJpdHMgNyBhbmQgOCBhcmUgc2V0LCB0aGVuIHRoZSBjbGFzcyBpcyBQUklWQVRFLlxuICogVGhlIHRhZyBudW1iZXJzIGZvciB0aGUgZGF0YSB0eXBlcyBmb3IgdGhlIGNsYXNzIFVOSVZFUlNBTCBhcmUgbGlzdGVkIGJlbG93OlxuICpcbiAqIFVOSVZFUlNBTCAwIFJlc2VydmVkIGZvciB1c2UgYnkgdGhlIGVuY29kaW5nIHJ1bGVzXG4gKiBVTklWRVJTQUwgMSBCb29sZWFuIHR5cGVcbiAqIFVOSVZFUlNBTCAyIEludGVnZXIgdHlwZVxuICogVU5JVkVSU0FMIDMgQml0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA0IE9jdGV0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA1IE51bGwgdHlwZVxuICogVU5JVkVSU0FMIDYgT2JqZWN0IGlkZW50aWZpZXIgdHlwZVxuICogVU5JVkVSU0FMIDcgT2JqZWN0IGRlc2NyaXB0b3IgdHlwZVxuICogVU5JVkVSU0FMIDggRXh0ZXJuYWwgdHlwZSBhbmQgSW5zdGFuY2Utb2YgdHlwZVxuICogVU5JVkVSU0FMIDkgUmVhbCB0eXBlXG4gKiBVTklWRVJTQUwgMTAgRW51bWVyYXRlZCB0eXBlXG4gKiBVTklWRVJTQUwgMTEgRW1iZWRkZWQtcGR2IHR5cGVcbiAqIFVOSVZFUlNBTCAxMiBVVEY4U3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCAxMyBSZWxhdGl2ZSBvYmplY3QgaWRlbnRpZmllciB0eXBlXG4gKiBVTklWRVJTQUwgMTQtMTUgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSBlZGl0aW9uc1xuICogVU5JVkVSU0FMIDE2IFNlcXVlbmNlIGFuZCBTZXF1ZW5jZS1vZiB0eXBlc1xuICogVU5JVkVSU0FMIDE3IFNldCBhbmQgU2V0LW9mIHR5cGVzXG4gKiBVTklWRVJTQUwgMTgtMjIsIDI1LTMwIENoYXJhY3RlciBzdHJpbmcgdHlwZXNcbiAqIFVOSVZFUlNBTCAyMy0yNCBUaW1lIHR5cGVzXG4gKlxuICogVGhlIGxlbmd0aCBvZiBhbiBBU04uMSBzdHJ1Y3R1cmUgaXMgc3BlY2lmaWVkIGFmdGVyIHRoZSB0YWcgaWRlbnRpZmllci5cbiAqIFRoZXJlIGlzIGEgZGVmaW5pdGUgZm9ybSBhbmQgYW4gaW5kZWZpbml0ZSBmb3JtLiBUaGUgaW5kZWZpbml0ZSBmb3JtIG1heVxuICogYmUgdXNlZCBpZiB0aGUgZW5jb2RpbmcgaXMgY29uc3RydWN0ZWQgYW5kIG5vdCBhbGwgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICogVGhlIGluZGVmaW5pdGUgZm9ybSBpcyBlbmNvZGVkIHVzaW5nIGEgbGVuZ3RoIGJ5dGUgd2l0aCBvbmx5IHRoZSA4dGggYml0XG4gKiBzZXQuIFRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdGVkIG9iamVjdCBpcyBtYXJrZWQgdXNpbmcgZW5kLW9mLWNvbnRlbnRzXG4gKiBvY3RldHMgKHR3byB6ZXJvIGJ5dGVzKS5cbiAqXG4gKiBUaGUgZGVmaW5pdGUgZm9ybSBsb29rcyBsaWtlIHRoaXM6XG4gKlxuICogVGhlIGxlbmd0aCBtYXkgdGFrZSB1cCAxIG9yIG1vcmUgYnl0ZXMsIGl0IGRlcGVuZHMgb24gdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHZhbHVlIG9mIHRoZSBBU04uMSBzdHJ1Y3R1cmUuIERFUiBlbmNvZGluZyByZXF1aXJlcyB0aGF0IGlmIHRoZSBBU04uMVxuICogc3RydWN0dXJlIGhhcyBhIHZhbHVlIHRoYXQgaGFzIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxMjcsIG1vcmUgdGhhbiAxIGJ5dGVcbiAqIHdpbGwgYmUgdXNlZCB0byBzdG9yZSBpdHMgbGVuZ3RoLCBvdGhlcndpc2UganVzdCBvbmUgYnl0ZSB3aWxsIGJlIHVzZWQuXG4gKiBUaGlzIGlzIHN0cmljdC5cbiAqXG4gKiBJbiB0aGUgY2FzZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIEFTTi4xIHZhbHVlIGlzIGxlc3MgdGhhbiAxMjcsIDEgb2N0ZXRcbiAqIChieXRlKSBpcyB1c2VkIHRvIHN0b3JlIHRoZSBcInNob3J0IGZvcm1cIiBsZW5ndGguIFRoZSA4dGggYml0IGhhcyBhIHZhbHVlIG9mXG4gKiAwIGluZGljYXRpbmcgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBhbmQgbm90IFwibG9uZyBmb3JtXCIgYW5kIGJpdHMgNy0xXG4gKiBnaXZlIHRoZSBsZW5ndGggb2YgdGhlIGRhdGEuIChUaGUgOHRoIGJpdCBpcyB0aGUgbGVmdC1tb3N0LCBtb3N0IHNpZ25pZmljYW50XG4gKiBiaXQ6IGFsc28ga25vd24gYXMgYmlnIGVuZGlhbiBvciBuZXR3b3JrIGZvcm1hdCkuXG4gKlxuICogSW4gdGhlIGNhc2UgdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZSBBU04uMSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMTI3LCAyIHRvXG4gKiAxMjcgb2N0ZXRzIChieXRlcykgYXJlIHVzZWQgdG8gc3RvcmUgdGhlIFwibG9uZyBmb3JtXCIgbGVuZ3RoLiBUaGUgZmlyc3RcbiAqIGJ5dGUncyA4dGggYml0IGlzIHNldCB0byAxIHRvIGluZGljYXRlIHRoZSBsZW5ndGggaXMgXCJsb25nIGZvcm0uXCIgQml0cyA3LTFcbiAqIGdpdmUgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG9jdGV0cy4gQWxsIGZvbGxvd2luZyBvY3RldHMgYXJlIGluIGJhc2UgMjU2XG4gKiB3aXRoIHRoZSBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0ICh0eXBpY2FsIGJpZy1lbmRpYW4gYmluYXJ5IHVuc2lnbmVkXG4gKiBpbnRlZ2VyIHN0b3JhZ2UpLiBTbywgZm9yIGluc3RhbmNlLCBpZiB0aGUgbGVuZ3RoIG9mIGEgdmFsdWUgd2FzIDI1NywgdGhlXG4gKiBmaXJzdCBieXRlIHdvdWxkIGJlIHNldCB0bzpcbiAqXG4gKiAxMDAwMDAxMCA9IDEzMCA9IDB4ODIuXG4gKlxuICogVGhpcyBpbmRpY2F0ZXMgdGhlcmUgYXJlIDIgb2N0ZXRzIChiYXNlIDI1NikgZm9yIHRoZSBsZW5ndGguIFRoZSBzZWNvbmQgYW5kXG4gKiB0aGlyZCBieXRlcyAodGhlIG9jdGV0cyBqdXN0IG1lbnRpb25lZCkgd291bGQgc3RvcmUgdGhlIGxlbmd0aCBpbiBiYXNlIDI1NjpcbiAqXG4gKiBvY3RldCAyOiAwMDAwMDAwMSA9IDEgKiAyNTZeMSA9IDI1NlxuICogb2N0ZXQgMzogMDAwMDAwMDEgPSAxICogMjU2XjAgPSAxXG4gKiB0b3RhbCA9IDI1N1xuICpcbiAqIFRoZSBhbGdvcml0aG0gZm9yIGNvbnZlcnRpbmcgYSBqcyBpbnRlZ2VyIHZhbHVlIG9mIDI1NyB0byBiYXNlLTI1NiBpczpcbiAqXG4gKiB2YXIgdmFsdWUgPSAyNTc7XG4gKiB2YXIgYnl0ZXMgPSBbXTtcbiAqIGJ5dGVzWzBdID0gKHZhbHVlID4+PiA4KSAmIDB4RkY7IC8vIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdFxuICogYnl0ZXNbMV0gPSB2YWx1ZSAmIDB4RkY7ICAgICAgICAvLyBsZWFzdCBzaWduaWZpY2FudCBieXRlIGxhc3RcbiAqXG4gKiBPbiB0aGUgQVNOLjEgVU5JVkVSU0FMIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIHR5cGU6XG4gKlxuICogQW4gT0lEIGNhbiBiZSB3cml0dGVuIGxpa2U6IFwidmFsdWUxLnZhbHVlMi52YWx1ZTMuLi52YWx1ZU5cIlxuICpcbiAqIFRoZSBERVIgZW5jb2RpbmcgcnVsZXM6XG4gKlxuICogVGhlIGZpcnN0IGJ5dGUgaGFzIHRoZSB2YWx1ZSA0MCAqIHZhbHVlMSArIHZhbHVlMi5cbiAqIFRoZSBmb2xsb3dpbmcgYnl0ZXMsIGlmIGFueSwgZW5jb2RlIHRoZSByZW1haW5pbmcgdmFsdWVzLiBFYWNoIHZhbHVlIGlzXG4gKiBlbmNvZGVkIGluIGJhc2UgMTI4LCBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0IChiaWcgZW5kaWFuKSwgd2l0aCBhc1xuICogZmV3IGRpZ2l0cyBhcyBwb3NzaWJsZSwgYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiBlYWNoIGJ5dGUgc2V0XG4gKiB0byAxIGV4Y2VwdCB0aGUgbGFzdCBpbiBlYWNoIHZhbHVlJ3MgZW5jb2RpbmcuIEZvciBleGFtcGxlOiBHaXZlbiB0aGVcbiAqIE9JRCBcIjEuMi44NDAuMTEzNTQ5XCIsIGl0cyBERVIgZW5jb2RpbmcgaXMgKHJlbWVtYmVyIGVhY2ggYnl0ZSBleGNlcHQgdGhlXG4gKiBsYXN0IG9uZSBpbiBlYWNoIGVuY29kaW5nIGlzIE9SJ2Qgd2l0aCAweDgwKTpcbiAqXG4gKiBieXRlIDE6IDQwICogMSArIDIgPSA0MiA9IDB4MkEuXG4gKiBieXRlcyAyLTM6IDEyOCAqIDYgKyA3MiA9IDg0MCA9IDYgNzIgPSA2IDcyID0gMHgwNjQ4ID0gMHg4NjQ4XG4gKiBieXRlcyA0LTY6IDE2Mzg0ICogNiArIDEyOCAqIDExOSArIDEzID0gNiAxMTkgMTMgPSAweDA2NzcwRCA9IDB4ODZGNzBEXG4gKlxuICogVGhlIGZpbmFsIHZhbHVlIGlzOiAweDJBODY0ODg2RjcwRC5cbiAqIFRoZSBmdWxsIE9JRCAoaW5jbHVkaW5nIEFTTi4xIHRhZyBhbmQgbGVuZ3RoIG9mIDYgYnl0ZXMpIGlzOlxuICogMHgwNjA2MkE4NjQ4ODZGNzBEXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLyogQVNOLjEgQVBJICovXG52YXIgYXNuMSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYXNuMSA9IGZvcmdlLmFzbjEgfHwge307XG5cbi8qKlxuICogQVNOLjEgY2xhc3Nlcy5cbiAqL1xuYXNuMS5DbGFzcyA9IHtcbiAgVU5JVkVSU0FMOiAgICAgICAgMHgwMCxcbiAgQVBQTElDQVRJT046ICAgICAgMHg0MCxcbiAgQ09OVEVYVF9TUEVDSUZJQzogMHg4MCxcbiAgUFJJVkFURTogICAgICAgICAgMHhDMFxufTtcblxuLyoqXG4gKiBBU04uMSB0eXBlcy4gTm90IGFsbCB0eXBlcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb24sIG9ubHlcbiAqIHRob3NlIG5lY2Vzc2FyeSB0byBpbXBsZW1lbnQgYSBzaW1wbGUgUEtJIGFyZSBpbXBsZW1lbnRlZC5cbiAqL1xuYXNuMS5UeXBlID0ge1xuICBOT05FOiAgICAgICAgICAgICAwLFxuICBCT09MRUFOOiAgICAgICAgICAxLFxuICBJTlRFR0VSOiAgICAgICAgICAyLFxuICBCSVRTVFJJTkc6ICAgICAgICAzLFxuICBPQ1RFVFNUUklORzogICAgICA0LFxuICBOVUxMOiAgICAgICAgICAgICA1LFxuICBPSUQ6ICAgICAgICAgICAgICA2LFxuICBPREVTQzogICAgICAgICAgICA3LFxuICBFWFRFUk5BTDogICAgICAgICA4LFxuICBSRUFMOiAgICAgICAgICAgICA5LFxuICBFTlVNRVJBVEVEOiAgICAgIDEwLFxuICBFTUJFRERFRDogICAgICAgIDExLFxuICBVVEY4OiAgICAgICAgICAgIDEyLFxuICBST0lEOiAgICAgICAgICAgIDEzLFxuICBTRVFVRU5DRTogICAgICAgIDE2LFxuICBTRVQ6ICAgICAgICAgICAgIDE3LFxuICBQUklOVEFCTEVTVFJJTkc6IDE5LFxuICBJQTVTVFJJTkc6ICAgICAgIDIyLFxuICBVVENUSU1FOiAgICAgICAgIDIzLFxuICBHRU5FUkFMSVpFRFRJTUU6IDI0LFxuICBCTVBTVFJJTkc6ICAgICAgIDMwXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRhZ0NsYXNzIHRoZSB0YWcgY2xhc3MgZm9yIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0gdHlwZSB0aGUgZGF0YSB0eXBlICh0YWcgbnVtYmVyKSBmb3IgdGhlIG9iamVjdC5cbiAqIEBwYXJhbSBjb25zdHJ1Y3RlZCB0cnVlIGlmIHRoZSBhc24xIG9iamVjdCBpcyBpbiBjb25zdHJ1Y3RlZCBmb3JtLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBmb3IgdGhlIG9iamVjdCwgaWYgaXQgaXMgbm90IGNvbnN0cnVjdGVkLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYml0U3RyaW5nQ29udGVudHNdIHRoZSBwbGFpbiBCSVQgU1RSSU5HIGNvbnRlbnQgaW5jbHVkaW5nIHBhZGRpbmdcbiAqICAgICAgICAgICAgYnl0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5jcmVhdGUgPSBmdW5jdGlvbih0YWdDbGFzcywgdHlwZSwgY29uc3RydWN0ZWQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIC8qIEFuIGFzbjEgb2JqZWN0IGhhcyBhIHRhZ0NsYXNzLCBhIHR5cGUsIGEgY29uc3RydWN0ZWQgZmxhZywgYW5kIGFcbiAgICB2YWx1ZS4gVGhlIHZhbHVlJ3MgdHlwZSBkZXBlbmRzIG9uIHRoZSBjb25zdHJ1Y3RlZCBmbGFnLiBJZlxuICAgIGNvbnN0cnVjdGVkLCBpdCB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIG90aGVyIGFzbjEgb2JqZWN0cy4gSWYgbm90LFxuICAgIGl0IHdpbGwgY29udGFpbiB0aGUgQVNOLjEgdmFsdWUgYXMgYW4gYXJyYXkgb2YgYnl0ZXMgZm9ybWF0dGVkXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBBU04uMSBkYXRhIHR5cGUuICovXG5cbiAgLy8gcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXNcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKHZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdG1wLnB1c2godmFsdWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHRtcDtcbiAgfVxuXG4gIHZhciBvYmogPSB7XG4gICAgdGFnQ2xhc3M6IHRhZ0NsYXNzLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29uc3RydWN0ZWQ6IGNvbnN0cnVjdGVkLFxuICAgIGNvbXBvc2VkOiBjb25zdHJ1Y3RlZCB8fCBmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xuICBpZihvcHRpb25zICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb3B0aW9ucykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICBvYmouYml0U3RyaW5nQ29udGVudHMgPSBvcHRpb25zLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgIC8vIFRPRE86IGFkZCByZWFkb25seSBmbGFnIHRvIGF2b2lkIHRoaXMgb3ZlcmhlYWRcbiAgICAvLyBzYXZlIGNvcHkgdG8gZGV0ZWN0IGNoYW5nZXNcbiAgICBvYmoub3JpZ2luYWwgPSBhc24xLmNvcHkob2JqKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgYW4gYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSBvYmplY3QuXG4gKiBAcGFyYW0gW29wdGlvbnNdIGNvcHkgb3B0aW9uczpcbiAqICAgICAgICAgIFtleGNsdWRlQml0U3RyaW5nQ29udGVudHNdIHRydWUgdG8gbm90IGNvcHkgYml0U3RyaW5nQ29udGVudHNcbiAqXG4gKiBAcmV0dXJuIHRoZSBhIGNvcHkgb2YgdGhlIGFzbjEgb2JqZWN0LlxuICovXG5hc24xLmNvcHkgPSBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGNvcHk7XG5cbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICBjb3B5ID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgY29weS5wdXNoKGFzbjEuY29weShvYmpbaV0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICBpZih0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgY29weSA9IHtcbiAgICB0YWdDbGFzczogb2JqLnRhZ0NsYXNzLFxuICAgIHR5cGU6IG9iai50eXBlLFxuICAgIGNvbnN0cnVjdGVkOiBvYmouY29uc3RydWN0ZWQsXG4gICAgY29tcG9zZWQ6IG9iai5jb21wb3NlZCxcbiAgICB2YWx1ZTogYXNuMS5jb3B5KG9iai52YWx1ZSwgb3B0aW9ucylcbiAgfTtcbiAgaWYob3B0aW9ucyAmJiAhb3B0aW9ucy5leGNsdWRlQml0U3RyaW5nQ29udGVudHMpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgY29weS5iaXRTdHJpbmdDb250ZW50cyA9IG9iai5iaXRTdHJpbmdDb250ZW50cztcbiAgfVxuICByZXR1cm4gY29weTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgYXNuMSBvYmplY3RzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBOb3RlIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcnVuIGluIGNvbnN0YW50IHRpbWUuXG4gKlxuICogQHBhcmFtIG9iajEgdGhlIGZpcnN0IGFzbjEgb2JqZWN0LlxuICogQHBhcmFtIG9iajIgdGhlIHNlY29uZCBhc24xIG9iamVjdC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gY29tcGFyZSBvcHRpb25zOlxuICogICAgICAgICAgW2luY2x1ZGVCaXRTdHJpbmdDb250ZW50c10gdHJ1ZSB0byBjb21wYXJlIGJpdFN0cmluZ0NvbnRlbnRzXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBhc24xIG9iamVjdHMgYXJlIGVxdWFsLlxuICovXG5hc24xLmVxdWFscyA9IGZ1bmN0aW9uKG9iajEsIG9iajIsIG9wdGlvbnMpIHtcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iajEpKSB7XG4gICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShvYmoyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZihvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iajEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKCFhc24xLmVxdWFscyhvYmoxW2ldLCBvYmoyW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgIT09IHR5cGVvZiBvYmoyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIH1cblxuICB2YXIgZXF1YWwgPSBvYmoxLnRhZ0NsYXNzID09PSBvYmoyLnRhZ0NsYXNzICYmXG4gICAgb2JqMS50eXBlID09PSBvYmoyLnR5cGUgJiZcbiAgICBvYmoxLmNvbnN0cnVjdGVkID09PSBvYmoyLmNvbnN0cnVjdGVkICYmXG4gICAgb2JqMS5jb21wb3NlZCA9PT0gb2JqMi5jb21wb3NlZCAmJlxuICAgIGFzbjEuZXF1YWxzKG9iajEudmFsdWUsIG9iajIudmFsdWUpO1xuICBpZihvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgZXF1YWwgPSBlcXVhbCAmJiAob2JqMS5iaXRTdHJpbmdDb250ZW50cyA9PT0gb2JqMi5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH1cblxuICByZXR1cm4gZXF1YWw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGIgdGhlIEJFUi1lbmNvZGVkIEFTTi4xIGJ5dGUgYnVmZmVyLCBzdGFydGluZyB3aXRoIHRoZSBmaXJzdFxuICogICAgICAgICAgbGVuZ3RoIGJ5dGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbmFzbjEuZ2V0QmVyVmFsdWVMZW5ndGggPSBmdW5jdGlvbihiKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIHZhciBiMiA9IGIuZ2V0Qnl0ZSgpO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgbGVuZ3RoID0gYi5nZXRJbnQoKGIyICYgMHg3RikgPDwgMyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJ5dGUgYnVmZmVyIGhhcyBlbm91Z2ggYnl0ZXMuIFRocm93cyBhbiBFcnJvciBpZiBub3QuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgbXVzdCBoYXZlLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgbikge1xuICBpZihuID4gcmVtYWluaW5nKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHBhcnNlIERFUi4nKTtcbiAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICBlcnJvci5yZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgZXJyb3IucmVxdWVzdGVkID0gbjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbnZhciBfZ2V0VmFsdWVMZW5ndGggPSBmdW5jdGlvbihieXRlcywgcmVtYWluaW5nKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIC8vIGZyb21EZXIgYWxyZWFkeSBjaGVja2VkIHRoYXQgdGhpcyBieXRlIGV4aXN0c1xuICB2YXIgYjIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIHJlbWFpbmluZy0tO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgdmFyIGxvbmdGb3JtQnl0ZXMgPSBiMiAmIDB4N0Y7XG4gICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIGxvbmdGb3JtQnl0ZXMpO1xuICAgIGxlbmd0aCA9IGJ5dGVzLmdldEludChsb25nRm9ybUJ5dGVzIDw8IDMpO1xuICB9XG4gIC8vIEZJWE1FOiB0aGlzIHdpbGwgb25seSBoYXBwZW4gZm9yIDMyIGJpdCBnZXRJbnQgd2l0aCBoaWdoIGJpdCBzZXRcbiAgaWYobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgbGVuZ3RoOiAnICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gYXNuMSBvYmplY3QgZnJvbSBhIGJ5dGUgYnVmZmVyIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICogQHBhcmFtIFtvcHRpb25zXSBvYmplY3Qgd2l0aCBvcHRpb25zIG9yIGJvb2xlYW4gc3RyaWN0IGZsYWdcbiAqICAgICAgICAgIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbZGVjb2RlQml0U3RyaW5nc10gdHJ1ZSB0byBhdHRlbXB0IHRvIGRlY29kZSB0aGUgY29udGVudCBvZlxuICogICAgICAgICAgICBCSVQgU1RSSU5HcyAobm90IE9DVEVUIFNUUklOR3MpIHVzaW5nIHN0cmljdCBtb2RlLiBOb3RlIHRoYXRcbiAqICAgICAgICAgICAgd2l0aG91dCBzY2hlbWEgc3VwcG9ydCB0byB1bmRlcnN0YW5kIHRoZSBkYXRhIGNvbnRleHQgdGhpcyBjYW5cbiAqICAgICAgICAgICAgZXJyb25lb3VzbHkgZGVjb2RlIHZhbHVlcyB0aGF0IGhhcHBlbiB0byBiZSB2YWxpZCBBU04uMS4gVGhpc1xuICogICAgICAgICAgICBmbGFnIHdpbGwgYmUgZGVwcmVjYXRlZCBvciByZW1vdmVkIGFzIHNvb24gYXMgc2NoZW1hIHN1cHBvcnQgaXNcbiAqICAgICAgICAgICAgYXZhaWxhYmxlLiAoZGVmYXVsdDogdHJ1ZSlcbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuZnJvbURlciA9IGZ1bmN0aW9uKGJ5dGVzLCBvcHRpb25zKSB7XG4gIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdDogb3B0aW9ucyxcbiAgICAgIGRlY29kZUJpdFN0cmluZ3M6IHRydWVcbiAgICB9O1xuICB9XG4gIGlmKCEoJ3N0cmljdCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnN0cmljdCA9IHRydWU7XG4gIH1cbiAgaWYoISgnZGVjb2RlQml0U3RyaW5ncycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmRlY29kZUJpdFN0cmluZ3MgPSB0cnVlO1xuICB9XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIHJldHVybiBfZnJvbURlcihieXRlcywgYnl0ZXMubGVuZ3RoKCksIDAsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBhbiBhc24xIG9iamVjdCBmcm9tIGEgYnl0ZSBidWZmZXIgaW4gREVSIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gcmVtYWluaW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGZvciB0aGlzIGNodW5rLlxuICogQHBhcmFtIGRlcHRoIHRoZSBjdXJyZW50IHBhcnNpbmcgZGVwdGguXG4gKiBAcGFyYW0gb3B0aW9ucyBvYmplY3Qgd2l0aCBzYW1lIG9wdGlvbnMgYXMgZnJvbURlcigpLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBhc24xIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGgsIG9wdGlvbnMpIHtcbiAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvbnN1bXB0aW9uIGNhbGN1bGF0aW9uc1xuICB2YXIgc3RhcnQ7XG5cbiAgLy8gbWluaW11bSBsZW5ndGggZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmUgaXMgMlxuICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG5cbiAgLy8gZ2V0IHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgLy8gY29uc3VtZWQgb25lIGJ5dGVcbiAgcmVtYWluaW5nLS07XG5cbiAgLy8gZ2V0IHRoZSB0YWcgY2xhc3NcbiAgdmFyIHRhZ0NsYXNzID0gKGIxICYgMHhDMCk7XG5cbiAgLy8gZ2V0IHRoZSB0eXBlIChiaXRzIDEtNSlcbiAgdmFyIHR5cGUgPSBiMSAmIDB4MUY7XG5cbiAgLy8gZ2V0IHRoZSB2YXJpYWJsZSB2YWx1ZSBsZW5ndGggYW5kIGFkanVzdCByZW1haW5pbmcgYnl0ZXNcbiAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgdmFyIGxlbmd0aCA9IF9nZXRWYWx1ZUxlbmd0aChieXRlcywgcmVtYWluaW5nKTtcbiAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG5cbiAgLy8gZW5zdXJlIHRoZXJlIGFyZSBlbm91Z2ggYnl0ZXMgdG8gZ2V0IHRoZSB2YWx1ZVxuICBpZihsZW5ndGggIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICBpZihvcHRpb25zLnN0cmljdCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHJlYWQgQVNOLjEgdmFsdWUuJyk7XG4gICAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIGVycm9yLnJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICAgIGVycm9yLnJlcXVlc3RlZCA9IGxlbmd0aDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBOb3RlOiBiZSBsZW5pZW50IHdpdGggdHJ1bmNhdGVkIHZhbHVlcyBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIC8vIHZhbHVlIHN0b3JhZ2VcbiAgdmFyIHZhbHVlO1xuICAvLyBwb3NzaWJsZSBCSVQgU1RSSU5HIGNvbnRlbnRzIHN0b3JhZ2VcbiAgdmFyIGJpdFN0cmluZ0NvbnRlbnRzO1xuXG4gIC8vIGNvbnN0cnVjdGVkIGZsYWcgaXMgYml0IDYgKDMyID0gMHgyMCkgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGNvbnN0cnVjdGVkID0gKChiMSAmIDB4MjApID09PSAweDIwKTtcbiAgaWYoY29uc3RydWN0ZWQpIHtcbiAgICAvLyBwYXJzZSBjaGlsZCBhc24xIG9iamVjdHMgZnJvbSB0aGUgdmFsdWVcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGlmKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhc24xIG9iamVjdCBvZiBpbmRlZmluaXRlIGxlbmd0aCwgcmVhZCB1bnRpbCBlbmQgdGFnXG4gICAgICBmb3IoOzspIHtcbiAgICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuICAgICAgICBpZihieXRlcy5ieXRlcygyKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAwKSkge1xuICAgICAgICAgIGJ5dGVzLmdldEJ5dGVzKDIpO1xuICAgICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIHZhbHVlLnB1c2goX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBvcHRpb25zKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJzaW5nIGFzbjEgb2JqZWN0IG9mIGRlZmluaXRlIGxlbmd0aFxuICAgICAgd2hpbGUobGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCBsZW5ndGgsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgbGVuZ3RoIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYSBCSVQgU1RSSU5HLCBzYXZlIHRoZSBjb250ZW50cyBpbmNsdWRpbmcgcGFkZGluZ1xuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRhZ0NsYXNzID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCAmJlxuICAgIHR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICBiaXRTdHJpbmdDb250ZW50cyA9IGJ5dGVzLmJ5dGVzKGxlbmd0aCk7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgaWYgYSBub24tY29uc3RydWN0ZWQgdmFsdWUgc2hvdWxkIGJlIGRlY29kZWQgYXMgYSBjb21wb3NlZFxuICAvLyB2YWx1ZSB0aGF0IGNvbnRhaW5zIG90aGVyIEFTTi4xIG9iamVjdHMuIEJJVCBTVFJJTkdzIChhbmQgT0NURVQgU1RSSU5HcylcbiAgLy8gY2FuIGJlIHVzZWQgdGhpcyB3YXkuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5kZWNvZGVCaXRTdHJpbmdzICYmXG4gICAgdGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMICYmXG4gICAgLy8gRklYTUU6IE9DVEVUIFNUUklOR3Mgbm90IHlldCBzdXBwb3J0ZWQgaGVyZVxuICAgIC8vIC4uIG90aGVyIHBhcnRzIG9mIGZvcmdlIGV4cGVjdCB0byBkZWNvZGUgT0NURVQgU1RSSU5HcyBtYW51YWxseVxuICAgICh0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HIC8qfHwgdHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKi8pICYmXG4gICAgbGVuZ3RoID4gMSkge1xuICAgIC8vIHNhdmUgcmVhZCBwb3NpdGlvblxuICAgIHZhciBzYXZlZFJlYWQgPSBieXRlcy5yZWFkO1xuICAgIHZhciBzYXZlZFJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICBpZih0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgICAvKiBUaGUgZmlyc3Qgb2N0ZXQgZ2l2ZXMgdGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgIGJpdCBzdHJpbmcgaXMgbGVzcyB0aGFuIHRoZSBuZXh0IG11bHRpcGxlIG9mIGVpZ2h0ICh0aGlzIGlzIGNhbGxlZFxuICAgICAgICB0aGUgXCJudW1iZXIgb2YgdW51c2VkIGJpdHNcIikuXG5cbiAgICAgICAgVGhlIHNlY29uZCBhbmQgZm9sbG93aW5nIG9jdGV0cyBnaXZlIHRoZSB2YWx1ZSBvZiB0aGUgYml0IHN0cmluZ1xuICAgICAgICBjb252ZXJ0ZWQgdG8gYW4gb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDEpO1xuICAgICAgdW51c2VkID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICAgICAgcmVtYWluaW5nLS07XG4gICAgfVxuICAgIC8vIGlmIGFsbCBiaXRzIGFyZSB1c2VkLCBtYXliZSB0aGUgQklUL09DVEVUIFNUUklORyBob2xkcyBBU04uMSBvYmpzXG4gICAgaWYodW51c2VkID09PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhdHRlbXB0IHRvIHBhcnNlIGNoaWxkIGFzbjEgb2JqZWN0IGZyb20gdGhlIHZhbHVlXG4gICAgICAgIC8vIChzdG9yZWQgaW4gYXJyYXkgdG8gc2lnbmFsIGNvbXBvc2VkIHZhbHVlKVxuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3ViT3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBlbmZvcmNlIHN0cmljdCBtb2RlIHRvIGF2b2lkIHBhcnNpbmcgQVNOLjEgZnJvbSBwbGFpbiBkYXRhXG4gICAgICAgICAgdmVyYm9zZTogb3B0aW9ucy52ZXJib3NlLFxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wb3NlZCA9IF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoICsgMSwgc3ViT3B0aW9ucyk7XG4gICAgICAgIHZhciB1c2VkID0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHVzZWQ7XG4gICAgICAgIGlmKHR5cGUgPT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgICAgIHVzZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBkYXRhIGFsbCBkZWNvZGVkIGFuZCB0aGUgY2xhc3MgaW5kaWNhdGVzIFVOSVZFUlNBTCBvclxuICAgICAgICAvLyBDT05URVhUX1NQRUNJRklDIHRoZW4gYXNzdW1lIHdlJ3ZlIGdvdCBhbiBlbmNhcHN1bGF0ZWQgQVNOLjEgb2JqZWN0XG4gICAgICAgIHZhciB0YyA9IGNvbXBvc2VkLnRhZ0NsYXNzO1xuICAgICAgICBpZih1c2VkID09PSBsZW5ndGggJiZcbiAgICAgICAgICAodGMgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8IHRjID09PSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMpKSB7XG4gICAgICAgICAgdmFsdWUgPSBbY29tcG9zZWRdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJlc3RvcmUgcmVhZCBwb3NpdGlvblxuICAgICAgYnl0ZXMucmVhZCA9IHNhdmVkUmVhZDtcbiAgICAgIHJlbWFpbmluZyA9IHNhdmVkUmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBhc24xIG5vdCBjb25zdHJ1Y3RlZCBvciBjb21wb3NlZCwgZ2V0IHJhdyB2YWx1ZVxuICAgIC8vIFRPRE86IGRvIERFUiB0byBPSUQgY29udmVyc2lvbiBhbmQgdmljZS12ZXJzYSBpbiAudG9EZXI/XG5cbiAgICBpZihsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tY29uc3RydWN0ZWQgQVNOLjEgb2JqZWN0IG9mIGluZGVmaW5pdGUgbGVuZ3RoLicpO1xuICAgICAgfVxuICAgICAgLy8gYmUgbGVuaWVudCBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cblxuICAgIGlmKHR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgICBmb3IoOyBsZW5ndGggPiAwOyBsZW5ndGggLT0gMikge1xuICAgICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG4gICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXMuZ2V0SW50MTYoKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGJ5dGVzLmdldEJ5dGVzKGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlXG4gIHZhciBhc24xT3B0aW9ucyA9IGJpdFN0cmluZ0NvbnRlbnRzID09PSB1bmRlZmluZWQgPyAgbnVsbCA6IHtcbiAgICBiaXRTdHJpbmdDb250ZW50czogYml0U3RyaW5nQ29udGVudHNcbiAgfTtcblxuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhc24xIG9iamVjdFxuICByZXR1cm4gYXNuMS5jcmVhdGUodGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgYXNuMU9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhc24xIG9iamVjdCB0byBhIGJ1ZmZlciBvZiBieXRlcyBpbiBERVIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBhc24xIHRoZSBhc24xIG9iamVjdCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ1ZmZlciBvZiBieXRlcy5cbiAqL1xuYXNuMS50b0RlciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGJ1aWxkIHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IG9iai50YWdDbGFzcyB8IG9iai50eXBlO1xuXG4gIC8vIGZvciBzdG9yaW5nIHRoZSBBU04uMSB2YWx1ZVxuICB2YXIgdmFsdWUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZSBCSVQgU1RSSU5HIGNvbnRlbnRzIGlmIGF2YWlsYWJsZSBhbmQgZGF0YSBub3QgY2hhbmdlZFxuICB2YXIgdXNlQml0U3RyaW5nQ29udGVudHMgPSBmYWxzZTtcbiAgaWYoJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvYmopIHtcbiAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IHRydWU7XG4gICAgaWYob2JqLm9yaWdpbmFsKSB7XG4gICAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGFzbjEuZXF1YWxzKG9iaiwgb2JqLm9yaWdpbmFsKTtcbiAgICB9XG4gIH1cblxuICBpZih1c2VCaXRTdHJpbmdDb250ZW50cykge1xuICAgIHZhbHVlLnB1dEJ5dGVzKG9iai5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH0gZWxzZSBpZihvYmouY29tcG9zZWQpIHtcbiAgICAvLyBpZiBjb21wb3NlZCwgdXNlIGVhY2ggY2hpbGQgYXNuMSBvYmplY3QncyBERVIgYnl0ZXMgYXMgdmFsdWVcbiAgICAvLyB0dXJuIG9uIDZ0aCBiaXQgKDB4MjAgPSAzMikgdG8gaW5kaWNhdGUgYXNuMSBpcyBjb25zdHJ1Y3RlZFxuICAgIC8vIGZyb20gb3RoZXIgYXNuMSBvYmplY3RzXG4gICAgaWYob2JqLmNvbnN0cnVjdGVkKSB7XG4gICAgICBiMSB8PSAweDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0eXBlIGlzIGEgYml0IHN0cmluZywgYWRkIHVudXNlZCBiaXRzIG9mIDB4MDBcbiAgICAgIHZhbHVlLnB1dEJ5dGUoMHgwMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGFsbCBvZiB0aGUgY2hpbGQgREVSIGJ5dGVzIHRvZ2V0aGVyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYob2JqLnZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUucHV0QnVmZmVyKGFzbjEudG9EZXIob2JqLnZhbHVlW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBhc24xLnZhbHVlIGRpcmVjdGx5XG4gICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUucHV0SW50MTYob2JqLnZhbHVlLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgaW50ZWdlciBpcyBtaW5pbWFsbHktZW5jb2RlZFxuICAgICAgLy8gVE9ETzogc2hvdWxkIGFsbCBsZWFkaW5nIGJ5dGVzIGJlIHN0cmlwcGVkIHZzIGp1c3Qgb25lP1xuICAgICAgLy8gLi4gZXggJzAwIDAwIDAxJyA9PiAnMDEnP1xuICAgICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSICYmXG4gICAgICAgIG9iai52YWx1ZS5sZW5ndGggPiAxICYmXG4gICAgICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAoKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAwICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAwKSB8fFxuICAgICAgICAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAweEZGICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICAgICAgdmFsdWUucHV0Qnl0ZXMob2JqLnZhbHVlLnN1YnN0cigxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5wdXRCeXRlcyhvYmoudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCB0YWcgYnl0ZVxuICBieXRlcy5wdXRCeXRlKGIxKTtcblxuICAvLyB1c2UgXCJzaG9ydCBmb3JtXCIgZW5jb2RpbmdcbiAgaWYodmFsdWUubGVuZ3RoKCkgPD0gMTI3KSB7XG4gICAgLy8gb25lIGJ5dGUgZGVzY3JpYmVzIHRoZSBsZW5ndGhcbiAgICAvLyBiaXQgOCA9IDAgYW5kIGJpdHMgNy0xID0gbGVuZ3RoXG4gICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZS5sZW5ndGgoKSAmIDB4N0YpO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBcImxvbmcgZm9ybVwiIGVuY29kaW5nXG4gICAgLy8gMiB0byAxMjcgYnl0ZXMgZGVzY3JpYmUgdGhlIGxlbmd0aFxuICAgIC8vIGZpcnN0IGJ5dGU6IGJpdCA4ID0gMSBhbmQgYml0cyA3LTEgPSAjIG9mIGFkZGl0aW9uYWwgYnl0ZXNcbiAgICAvLyBvdGhlciBieXRlczogbGVuZ3RoIGluIGJhc2UgMjU2LCBiaWctZW5kaWFuXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCgpO1xuICAgIHZhciBsZW5CeXRlcyA9ICcnO1xuICAgIGRvIHtcbiAgICAgIGxlbkJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuICYgMHhGRik7XG4gICAgICBsZW4gPSBsZW4gPj4+IDg7XG4gICAgfSB3aGlsZShsZW4gPiAwKTtcblxuICAgIC8vIHNldCBmaXJzdCBieXRlIHRvICMgYnl0ZXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIGFuZCB0dXJuIG9uXG4gICAgLy8gYml0IDggdG8gaW5kaWNhdGUgbG9uZy1mb3JtIGxlbmd0aCBpcyB1c2VkXG4gICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5sZW5ndGggfCAweDgwKTtcblxuICAgIC8vIGNvbmNhdGVuYXRlIGxlbmd0aCBieXRlcyBpbiByZXZlcnNlIHNpbmNlIHRoZXkgd2VyZSBnZW5lcmF0ZWRcbiAgICAvLyBsaXR0bGUgZW5kaWFuIGFuZCB3ZSBuZWVkIGJpZyBlbmRpYW5cbiAgICBmb3IodmFyIGkgPSBsZW5CeXRlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb25jYXRlbmF0ZSB2YWx1ZSBieXRlc1xuICBieXRlcy5wdXRCdWZmZXIodmFsdWUpO1xuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZyB0byBhIGJ5dGUgYnVmZmVyLiBUaGUgYnl0ZSBidWZmZXJcbiAqIGNvbnRhaW5zIG9ubHkgdGhlIERFUi1lbmNvZGVkIHZhbHVlLCBub3QgYW55IHRhZyBvciBsZW5ndGggYnl0ZXMuXG4gKlxuICogQHBhcmFtIG9pZCB0aGUgT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUgYnVmZmVyLlxuICovXG5hc24xLm9pZFRvRGVyID0gZnVuY3Rpb24ob2lkKSB7XG4gIC8vIHNwbGl0IE9JRCBpbnRvIGluZGl2aWR1YWwgdmFsdWVzXG4gIHZhciB2YWx1ZXMgPSBvaWQuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyBmaXJzdCBieXRlIGlzIDQwICogdmFsdWUxICsgdmFsdWUyXG4gIGJ5dGVzLnB1dEJ5dGUoNDAgKiBwYXJzZUludCh2YWx1ZXNbMF0sIDEwKSArIHBhcnNlSW50KHZhbHVlc1sxXSwgMTApKTtcbiAgLy8gb3RoZXIgYnl0ZXMgYXJlIGVhY2ggdmFsdWUgaW4gYmFzZSAxMjggd2l0aCA4dGggYml0IHNldCBleGNlcHQgZm9yXG4gIC8vIHRoZSBsYXN0IGJ5dGUgZm9yIGVhY2ggdmFsdWVcbiAgdmFyIGxhc3QsIHZhbHVlQnl0ZXMsIHZhbHVlLCBiO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gcHJvZHVjZSB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBob3cgbWFueVxuICAgIC8vIGJ5dGVzIGl0IHdpbGwgdGFrZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICBsYXN0ID0gdHJ1ZTtcbiAgICB2YWx1ZUJ5dGVzID0gW107XG4gICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZXNbaV0sIDEwKTtcbiAgICBkbyB7XG4gICAgICBiID0gdmFsdWUgJiAweDdGO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBsYXN0LCB0aGVuIHR1cm4gb24gOHRoIGJpdFxuICAgICAgaWYoIWxhc3QpIHtcbiAgICAgICAgYiB8PSAweDgwO1xuICAgICAgfVxuICAgICAgdmFsdWVCeXRlcy5wdXNoKGIpO1xuICAgICAgbGFzdCA9IGZhbHNlO1xuICAgIH0gd2hpbGUodmFsdWUgPiAwKTtcblxuICAgIC8vIGFkZCB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIChuZWVkcyB0byBiZSBpbiBiaWcgZW5kaWFuKVxuICAgIGZvcih2YXIgbiA9IHZhbHVlQnl0ZXMubGVuZ3RoIC0gMTsgbiA+PSAwOyAtLW4pIHtcbiAgICAgIGJ5dGVzLnB1dEJ5dGUodmFsdWVCeXRlc1tuXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIGJ5dGUgYnVmZmVyIHRvIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy4gVGhlXG4gKiBieXRlIGJ1ZmZlciBzaG91bGQgY29udGFpbiBvbmx5IHRoZSBERVItZW5jb2RlZCB2YWx1ZSwgbm90IGFueSB0YWcgb3JcbiAqIGxlbmd0aCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy5cbiAqL1xuYXNuMS5kZXJUb09pZCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhciBvaWQ7XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIC8vIGZpcnN0IGJ5dGUgaXMgNDAgKiB2YWx1ZTEgKyB2YWx1ZTJcbiAgdmFyIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIG9pZCA9IE1hdGguZmxvb3IoYiAvIDQwKSArICcuJyArIChiICUgNDApO1xuXG4gIC8vIG90aGVyIGJ5dGVzIGFyZSBlYWNoIHZhbHVlIGluIGJhc2UgMTI4IHdpdGggOHRoIGJpdCBzZXQgZXhjZXB0IGZvclxuICAvLyB0aGUgbGFzdCBieXRlIGZvciBlYWNoIHZhbHVlXG4gIHZhciB2YWx1ZSA9IDA7XG4gIHdoaWxlKGJ5dGVzLmxlbmd0aCgpID4gMCkge1xuICAgIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gICAgdmFsdWUgPSB2YWx1ZSA8PCA3O1xuICAgIC8vIG5vdCB0aGUgbGFzdCBieXRlIGZvciB0aGUgdmFsdWVcbiAgICBpZihiICYgMHg4MCkge1xuICAgICAgdmFsdWUgKz0gYiAmIDB4N0Y7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxhc3QgYnl0ZVxuICAgICAgb2lkICs9ICcuJyArICh2YWx1ZSArIGIpO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvaWQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVVRDVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogTm90ZTogR2VuZXJhbGl6ZWRUaW1lIGhhcyA0IGRpZ2l0cyBmb3IgdGhlIHllYXIgYW5kIGlzIHVzZWQgZm9yIFguNTA5XG4gKiBkYXRlcyBwYXN0IDIwNDkuIFBhcnNpbmcgdGhhdCBzdHJ1Y3R1cmUgaGFzbid0IGJlZW4gaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSB1dGMgdGhlIFVUQ1RpbWUgdmFsdWUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkYXRlLlxuICovXG5hc24xLnV0Y1RpbWVUb0RhdGUgPSBmdW5jdGlvbih1dGMpIHtcbiAgLyogVGhlIGZvbGxvd2luZyBmb3JtYXRzIGNhbiBiZSB1c2VkOlxuXG4gICAgWVlNTUREaGhtbVpcbiAgICBZWU1NRERoaG1tK2hoJ21tJ1xuICAgIFlZTU1ERGhobW0taGgnbW0nXG4gICAgWVlNTUREaGhtbXNzWlxuICAgIFlZTU1ERGhobW1zcytoaCdtbSdcbiAgICBZWU1NRERoaG1tc3MtaGgnbW0nXG5cbiAgICBXaGVyZTpcblxuICAgIFlZIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gZGlnaXRzIG9mIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIFogaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBHTVQsICsgaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpc1xuICAgIGxhdGVyIHRoYW4gR01ULCBhbmQgLSBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIGVhcmxpZXIgdGhhbiBHTVRcbiAgICBoaCcgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gaG91cnNcbiAgICBtbScgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gbWludXRlcyAqL1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgLy8gaWYgWVkgPj0gNTAgdXNlIDE5eHgsIGlmIFlZIDwgNTAgdXNlIDIweHhcbiAgdmFyIHllYXIgPSBwYXJzZUludCh1dGMuc3Vic3RyKDAsIDIpLCAxMCk7XG4gIHllYXIgPSAoeWVhciA+PSA1MCkgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xuICB2YXIgTU0gPSBwYXJzZUludCh1dGMuc3Vic3RyKDIsIDIpLCAxMCkgLSAxOyAvLyB1c2UgMC0xMSBmb3IgbW9udGhcbiAgdmFyIEREID0gcGFyc2VJbnQodXRjLnN1YnN0cig0LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludCh1dGMuc3Vic3RyKDYsIDIpLCAxMCk7XG4gIHZhciBtbSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoOCwgMiksIDEwKTtcbiAgdmFyIHNzID0gMDtcblxuICAvLyBub3QganVzdCBZWU1NRERoaG1tWlxuICBpZih1dGMubGVuZ3RoID4gMTEpIHtcbiAgICAvLyBnZXQgY2hhcmFjdGVyIGFmdGVyIG1pbnV0ZXNcbiAgICB2YXIgYyA9IHV0Yy5jaGFyQXQoMTApO1xuICAgIHZhciBlbmQgPSAxMDtcblxuICAgIC8vIHNlZSBpZiBzZWNvbmRzIGFyZSBwcmVzZW50XG4gICAgaWYoYyAhPT0gJysnICYmIGMgIT09ICctJykge1xuICAgICAgLy8gZ2V0IHNlY29uZHNcbiAgICAgIHNzID0gcGFyc2VJbnQodXRjLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgICAgIGVuZCArPSAyO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBkYXRlXG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgTU0sIEREKTtcbiAgZGF0ZS5zZXRVVENIb3VycyhoaCwgbW0sIHNzLCAwKTtcblxuICBpZihlbmQpIHtcbiAgICAvLyBnZXQgKy8tIGFmdGVyIGVuZCBvZiB0aW1lXG4gICAgYyA9IHV0Yy5jaGFyQXQoZW5kKTtcbiAgICBpZihjID09PSAnKycgfHwgYyA9PT0gJy0nKSB7XG4gICAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgMSwgMiksIDEwKTtcbiAgICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgNCwgMiksIDEwKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIG9mZnNldCBpbiBtaWxsaXNlY29uZHNcbiAgICAgIHZhciBvZmZzZXQgPSBoaG9mZnNldCAqIDYwICsgbW1vZmZzZXQ7XG4gICAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAgIC8vIGFwcGx5IG9mZnNldFxuICAgICAgaWYoYyA9PT0gJysnKSB7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSAtIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogQHBhcmFtIGdlbnRpbWUgdGhlIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUuXG4gKi9cbmFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlID0gZnVuY3Rpb24oZ2VudGltZSkge1xuICAvKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgY2FuIGJlIHVzZWQ6XG5cbiAgICBZWVlZTU1EREhITU1TU1xuICAgIFlZWVlNTURESEhNTVNTLmZmZlxuICAgIFlZWVlNTURESEhNTVNTWlxuICAgIFlZWVlNTURESEhNTVNTLmZmZlpcbiAgICBZWVlZTU1EREhITU1TUytoaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy5mZmYraGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MtaGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MuZmZmLWhoJ21tJ1xuXG4gICAgV2hlcmU6XG5cbiAgICBZWVlZIGlzIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIC5mZmYgaXMgdGhlIHNlY29uZCBmcmFjdGlvbiwgYWNjdXJhdGUgdG8gdGhyZWUgZGVjaW1hbCBwbGFjZXNcbiAgICBaIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXMgR01ULCArIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXNcbiAgICBsYXRlciB0aGFuIEdNVCwgYW5kIC0gaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBlYXJsaWVyIHRoYW4gR01UXG4gICAgaGgnIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIGhvdXJzXG4gICAgbW0nIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIG1pbnV0ZXMgKi9cbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gIHZhciBZWVlZID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMCwgNCksIDEwKTtcbiAgdmFyIE1NID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoNCwgMiksIDEwKSAtIDE7IC8vIHVzZSAwLTExIGZvciBtb250aFxuICB2YXIgREQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig2LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig4LCAyKSwgMTApO1xuICB2YXIgbW0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgdmFyIHNzID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMTIsIDIpLCAxMCk7XG4gIHZhciBmZmYgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGlzVVRDID0gZmFsc2U7XG5cbiAgaWYoZ2VudGltZS5jaGFyQXQoZ2VudGltZS5sZW5ndGggLSAxKSA9PT0gJ1onKSB7XG4gICAgaXNVVEMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGVuZCA9IGdlbnRpbWUubGVuZ3RoIC0gNSwgYyA9IGdlbnRpbWUuY2hhckF0KGVuZCk7XG4gIGlmKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcbiAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICB2YXIgaGhvZmZzZXQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cihlbmQgKyAxLCAyKSwgMTApO1xuICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDQsIDIpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBpZihjID09PSAnKycpIHtcbiAgICAgIG9mZnNldCAqPSAtMTtcbiAgICB9XG5cbiAgICBpc1VUQyA9IHRydWU7XG4gIH1cblxuICAvLyBjaGVjayBmb3Igc2Vjb25kIGZyYWN0aW9uXG4gIGlmKGdlbnRpbWUuY2hhckF0KDE0KSA9PT0gJy4nKSB7XG4gICAgZmZmID0gcGFyc2VGbG9hdChnZW50aW1lLnN1YnN0cigxNCksIDEwKSAqIDEwMDA7XG4gIH1cblxuICBpZihpc1VUQykge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldEhvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkYXRlIHRvIGEgVVRDVGltZSB2YWx1ZS5cbiAqXG4gKiBOb3RlOiBHZW5lcmFsaXplZFRpbWUgaGFzIDQgZGlnaXRzIGZvciB0aGUgeWVhciBhbmQgaXMgdXNlZCBmb3IgWC41MDlcbiAqIGRhdGVzIHBhc3QgMjA0OS4gQ29udmVydGluZyB0byBhIEdlbmVyYWxpemVkVGltZSBoYXNuJ3QgYmVlblxuICogaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgVVRDVGltZSB2YWx1ZS5cbiAqL1xuYXNuMS5kYXRlVG9VdGNUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWU1NRERoaG1tc3NaXG4gIHZhciBmb3JtYXQgPSBbXTtcbiAgZm9ybWF0LnB1c2goKCcnICsgZGF0ZS5nZXRVVENGdWxsWWVhcigpKS5zdWJzdHIoMikpO1xuICBmb3JtYXQucHVzaCgnJyArIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDSG91cnMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENNaW51dGVzKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDU2Vjb25kcygpKTtcblxuICAvLyBlbnN1cmUgMiBkaWdpdHMgYXJlIHVzZWQgZm9yIGVhY2ggZm9ybWF0IGVudHJ5XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBmb3JtYXQubGVuZ3RoOyArK2kpIHtcbiAgICBpZihmb3JtYXRbaV0ubGVuZ3RoIDwgMikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gZm9ybWF0W2ldO1xuICB9XG4gIHJ2YWwgKz0gJ1onO1xuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gYSBHZW5lcmFsaXplZFRpbWUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBHZW5lcmFsaXplZFRpbWUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKi9cbmFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWVlZTU1EREhITU1TU1pcbiAgdmFyIGZvcm1hdCA9IFtdO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuXG4gIC8vIGVuc3VyZSAyIGRpZ2l0cyBhcmUgdXNlZCBmb3IgZWFjaCBmb3JtYXQgZW50cnlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBmb3JtYXRbaV07XG4gIH1cbiAgcnZhbCArPSAnWic7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgamF2YXNjcmlwdCBpbnRlZ2VyIHRvIGEgREVSLWVuY29kZWQgYnl0ZSBidWZmZXIgdG8gYmUgdXNlZFxuICogYXMgdGhlIHZhbHVlIGZvciBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIHggdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBidWZmZXIuXG4gKi9cbmFzbjEuaW50ZWdlclRvRGVyID0gZnVuY3Rpb24oeCkge1xuICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGlmKHggPj0gLTB4ODAgJiYgeCA8IDB4ODApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgOCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwICYmIHggPCAweDgwMDApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgMTYpO1xuICB9XG4gIGlmKHggPj0gLTB4ODAwMDAwICYmIHggPCAweDgwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAyNCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwMDAwMCAmJiB4IDwgMHg4MDAwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAzMik7XG4gIH1cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIGVycm9yLmludGVnZXIgPSB4O1xuICB0aHJvdyBlcnJvcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBieXRlIGJ1ZmZlciB0byBhIGphdmFzY3JpcHQgaW50ZWdlci4gVGhpcyBpc1xuICogdHlwaWNhbGx5IHVzZWQgdG8gZGVjb2RlIHRoZSB2YWx1ZSBvZiBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG5hc24xLmRlclRvSW50ZWdlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8vIHdyYXAgaW4gYnVmZmVyIGlmIG5lZWRlZFxuICBpZih0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gIH1cblxuICB2YXIgbiA9IGJ5dGVzLmxlbmd0aCgpICogODtcbiAgaWYobiA+IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLmdldFNpZ25lZEludChuKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGdpdmVuIEFTTi4xIG9iamVjdCBpcyBhdCBsZWFzdCBhIHN1cGVyIHNldCBvZiB0aGVcbiAqIGdpdmVuIEFTTi4xIHN0cnVjdHVyZS4gT25seSB0YWcgY2xhc3NlcyBhbmQgdHlwZXMgYXJlIGNoZWNrZWQuIEFuXG4gKiBvcHRpb25hbCBtYXAgbWF5IGFsc28gYmUgcHJvdmlkZWQgdG8gY2FwdHVyZSBBU04uMSB2YWx1ZXMgd2hpbGUgdGhlXG4gKiBzdHJ1Y3R1cmUgaXMgY2hlY2tlZC5cbiAqXG4gKiBUbyBjYXB0dXJlIGFuIEFTTi4xIHZhbHVlLCBzZXQgYW4gb2JqZWN0IGluIHRoZSB2YWxpZGF0b3IncyAnY2FwdHVyZSdcbiAqIHBhcmFtZXRlciB0byB0aGUga2V5IHRvIHVzZSBpbiB0aGUgY2FwdHVyZSBtYXAuIFRvIGNhcHR1cmUgdGhlIGZ1bGxcbiAqIEFTTi4xIG9iamVjdCwgc3BlY2lmeSAnY2FwdHVyZUFzbjEnLiBUbyBjYXB0dXJlIEJJVCBTVFJJTkcgYnl0ZXMsIGluY2x1ZGluZ1xuICogdGhlIGxlYWRpbmcgdW51c2VkIGJpdHMgY291bnRlciBieXRlLCBzcGVjaWZ5ICdjYXB0dXJlQml0U3RyaW5nQ29udGVudHMnLlxuICogVG8gY2FwdHVyZSBCSVQgU1RSSU5HIGJ5dGVzLCB3aXRob3V0IHRoZSBsZWFkaW5nIHVudXNlZCBiaXRzIGNvdW50ZXIgYnl0ZSxcbiAqIHNwZWNpZnkgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZScuXG4gKlxuICogT2JqZWN0cyBpbiB0aGUgdmFsaWRhdG9yIG1heSBzZXQgYSBmaWVsZCAnb3B0aW9uYWwnIHRvIHRydWUgdG8gaW5kaWNhdGVcbiAqIHRoYXQgaXQgaXNuJ3QgbmVjZXNzYXJ5IHRvIHBhc3MgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gdiB0aGUgQVNOLjEgc3RydWN0dXJlIHZhbGlkYXRvci5cbiAqIEBwYXJhbSBjYXB0dXJlIGFuIG9wdGlvbmFsIG1hcCB0byBjYXB0dXJlIHZhbHVlcyBpbi5cbiAqIEBwYXJhbSBlcnJvcnMgYW4gb3B0aW9uYWwgYXJyYXkgZm9yIHN0b3JpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gKi9cbmFzbjEudmFsaWRhdGUgPSBmdW5jdGlvbihvYmosIHYsIGNhcHR1cmUsIGVycm9ycykge1xuICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gIC8vIGVuc3VyZSB0YWcgY2xhc3MgYW5kIHR5cGUgYXJlIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICBpZigob2JqLnRhZ0NsYXNzID09PSB2LnRhZ0NsYXNzIHx8IHR5cGVvZih2LnRhZ0NsYXNzKSA9PT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgKG9iai50eXBlID09PSB2LnR5cGUgfHwgdHlwZW9mKHYudHlwZSkgPT09ICd1bmRlZmluZWQnKSkge1xuICAgIC8vIGVuc3VyZSBjb25zdHJ1Y3RlZCBmbGFnIGlzIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICAgIGlmKG9iai5jb25zdHJ1Y3RlZCA9PT0gdi5jb25zdHJ1Y3RlZCB8fFxuICAgICAgdHlwZW9mKHYuY29uc3RydWN0ZWQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcnZhbCA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBzdWIgdmFsdWVzXG4gICAgICBpZih2LnZhbHVlICYmIGZvcmdlLnV0aWwuaXNBcnJheSh2LnZhbHVlKSkge1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgJiYgaSA8IHYudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBydmFsID0gdi52YWx1ZVtpXS5vcHRpb25hbCB8fCBmYWxzZTtcbiAgICAgICAgICBpZihvYmoudmFsdWVbal0pIHtcbiAgICAgICAgICAgIHJ2YWwgPSBhc24xLnZhbGlkYXRlKG9iai52YWx1ZVtqXSwgdi52YWx1ZVtpXSwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHYudmFsdWVbaV0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgcnZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCFydmFsICYmIGVycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAgICAgICAnVGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIHR5cGUgXCInICtcbiAgICAgICAgICAgICAgdi50eXBlICsgJ1wiIGV4cGVjdGVkIHZhbHVlIGxlbmd0aCBcIicgK1xuICAgICAgICAgICAgICB2LnZhbHVlLmxlbmd0aCArICdcIiwgZ290IFwiJyArXG4gICAgICAgICAgICAgIG9iai52YWx1ZS5sZW5ndGggKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocnZhbCAmJiBjYXB0dXJlKSB7XG4gICAgICAgIGlmKHYuY2FwdHVyZSkge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlXSA9IG9iai52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVBc24xKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVBc24xXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50cyAmJiAnYml0U3RyaW5nQ29udGVudHMnIGluIG9iaikge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nQ29udGVudHNdID0gb2JqLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb2JqKSB7XG4gICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgIGlmKG9iai5iaXRTdHJpbmdDb250ZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCB1bnVzZWQgYml0cyB3aXRoIGRhdGEgc2hpZnRpbmdcbiAgICAgICAgICAgIHZhciB1bnVzZWQgPSBvYmouYml0U3RyaW5nQ29udGVudHMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmKHVudXNlZCAhPT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZSBvbmx5IHN1cHBvcnRlZCBmb3IgemVybyB1bnVzZWQgYml0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdWYWx1ZV0gPSBvYmouYml0U3RyaW5nQ29udGVudHMuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgY29uc3RydWN0ZWQgXCInICsgdi5jb25zdHJ1Y3RlZCArICdcIiwgZ290IFwiJyArXG4gICAgICAgIG9iai5jb25zdHJ1Y3RlZCArICdcIicpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgIGlmKG9iai50YWdDbGFzcyAhPT0gdi50YWdDbGFzcykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIGdvdCBcIicgK1xuICAgICAgICBvYmoudGFnQ2xhc3MgKyAnXCInKTtcbiAgICB9XG4gICAgaWYob2JqLnR5cGUgIT09IHYudHlwZSkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdHlwZSBcIicgKyB2LnR5cGUgKyAnXCIsIGdvdCBcIicgKyBvYmoudHlwZSArICdcIicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8vIHJlZ2V4IGZvciB0ZXN0aW5nIGZvciBub24tbGF0aW4gY2hhcmFjdGVyc1xudmFyIF9ub25MYXRpblJlZ2V4ID0gL1teXFxcXHUwMDAwLVxcXFx1MDBmZl0vO1xuXG4vKipcbiAqIFByZXR0eSBwcmludHMgYW4gQVNOLjEgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIG9iamVjdCB0byB3cml0ZSBvdXQuXG4gKiBAcGFyYW0gbGV2ZWwgdGhlIGxldmVsIGluIHRoZSB0cmVlLlxuICogQHBhcmFtIGluZGVudGF0aW9uIHRoZSBpbmRlbnRhdGlvbiB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nLlxuICovXG5hc24xLnByZXR0eVByaW50ID0gZnVuY3Rpb24ob2JqLCBsZXZlbCwgaW5kZW50YXRpb24pIHtcbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBzZXQgZGVmYXVsdCBsZXZlbCBhbmQgaW5kZW50YXRpb25cbiAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuICBpbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uIHx8IDI7XG5cbiAgLy8gc3RhcnQgbmV3IGxpbmUgZm9yIGRlZXAgbGV2ZWxzXG4gIGlmKGxldmVsID4gMCkge1xuICAgIHJ2YWwgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBjcmVhdGUgaW5kZW50XG4gIHZhciBpbmRlbnQgPSAnJztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxldmVsICogaW5kZW50YXRpb247ICsraSkge1xuICAgIGluZGVudCArPSAnICc7XG4gIH1cblxuICAvLyBwcmludCBjbGFzczp0eXBlXG4gIHJ2YWwgKz0gaW5kZW50ICsgJ1RhZzogJztcbiAgc3dpdGNoKG9iai50YWdDbGFzcykge1xuICBjYXNlIGFzbjEuQ2xhc3MuVU5JVkVSU0FMOlxuICAgIHJ2YWwgKz0gJ1VuaXZlcnNhbDonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuQVBQTElDQVRJT046XG4gICAgcnZhbCArPSAnQXBwbGljYXRpb246JztcbiAgICBicmVhaztcbiAgY2FzZSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUM6XG4gICAgcnZhbCArPSAnQ29udGV4dC1TcGVjaWZpYzonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuUFJJVkFURTpcbiAgICBydmFsICs9ICdQcml2YXRlOic7XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZihvYmoudGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMKSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcblxuICAgIC8vIGtub3duIHR5cGVzXG4gICAgc3dpdGNoKG9iai50eXBlKSB7XG4gICAgY2FzZSBhc24xLlR5cGUuTk9ORTpcbiAgICAgIHJ2YWwgKz0gJyAoTm9uZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk9PTEVBTjpcbiAgICAgIHJ2YWwgKz0gJyAoQm9vbGVhbiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSU5URUdFUjpcbiAgICAgIHJ2YWwgKz0gJyAoSW50ZWdlciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQklUU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCaXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PQ1RFVFNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoT2N0ZXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5OVUxMOlxuICAgICAgcnZhbCArPSAnIChOdWxsKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PSUQ6XG4gICAgICBydmFsICs9ICcgKE9iamVjdCBJZGVudGlmaWVyKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PREVTQzpcbiAgICAgIHJ2YWwgKz0gJyAoT2JqZWN0IERlc2NyaXB0b3IpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkVYVEVSTkFMOlxuICAgICAgcnZhbCArPSAnIChFeHRlcm5hbCBvciBJbnN0YW5jZSBvZiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUkVBTDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVhbCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU5VTUVSQVRFRDpcbiAgICAgIHJ2YWwgKz0gJyAoRW51bWVyYXRlZCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU1CRURERUQ6XG4gICAgICBydmFsICs9ICcgKEVtYmVkZGVkIFBEViknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRGODpcbiAgICAgIHJ2YWwgKz0gJyAoVVRGOCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUk9JRDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVsYXRpdmUgT2JqZWN0IElkZW50aWZpZXIpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlNFUVVFTkNFOlxuICAgICAgcnZhbCArPSAnIChTZXF1ZW5jZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuU0VUOlxuICAgICAgcnZhbCArPSAnIChTZXQpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoUHJpbnRhYmxlIFN0cmluZyknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSUE1U3RyaW5nOlxuICAgICAgcnZhbCArPSAnIChJQTVTdHJpbmcgKEFTQ0lJKSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRDVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoVVRDIHRpbWUpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoR2VuZXJhbGl6ZWQgdGltZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk1QU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCTVAgU3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcbiAgfVxuXG4gIHJ2YWwgKz0gJ1xcbic7XG4gIHJ2YWwgKz0gaW5kZW50ICsgJ0NvbnN0cnVjdGVkOiAnICsgb2JqLmNvbnN0cnVjdGVkICsgJ1xcbic7XG5cbiAgaWYob2JqLmNvbXBvc2VkKSB7XG4gICAgdmFyIHN1YnZhbHVlcyA9IDA7XG4gICAgdmFyIHN1YiA9ICcnO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKG9iai52YWx1ZVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YnZhbHVlcyArPSAxO1xuICAgICAgICBzdWIgKz0gYXNuMS5wcmV0dHlQcmludChvYmoudmFsdWVbaV0sIGxldmVsICsgMSwgaW5kZW50YXRpb24pO1xuICAgICAgICBpZigoaSArIDEpIDwgb2JqLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHN1YiArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcnZhbCArPSBpbmRlbnQgKyAnU3ViIHZhbHVlczogJyArIHN1YnZhbHVlcyArIHN1YjtcbiAgfSBlbHNlIHtcbiAgICBydmFsICs9IGluZGVudCArICdWYWx1ZTogJztcbiAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLk9JRCkge1xuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQob2JqLnZhbHVlKTtcbiAgICAgIHJ2YWwgKz0gb2lkO1xuICAgICAgaWYoZm9yZ2UucGtpICYmIGZvcmdlLnBraS5vaWRzKSB7XG4gICAgICAgIGlmKG9pZCBpbiBmb3JnZS5wa2kub2lkcykge1xuICAgICAgICAgIHJ2YWwgKz0gJyAoJyArIGZvcmdlLnBraS5vaWRzW29pZF0gKyAnKSAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuSU5URUdFUikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnZhbCArPSBhc24xLmRlclRvSW50ZWdlcihvYmoudmFsdWUpO1xuICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICAgIC8vIFRPRE86IHNoaWZ0IGJpdHMgYXMgbmVlZGVkIHRvIGRpc3BsYXkgd2l0aG91dCBwYWRkaW5nXG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyByZW1vdmUgdW51c2VkIGJpdHMgZmllbGRcbiAgICAgICAgcnZhbCArPSAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZS5zbGljZSgxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsICs9ICcobm9uZSknO1xuICAgICAgfVxuICAgICAgLy8gc2hvdyB1bnVzZWQgYml0IGNvdW50XG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdW51c2VkID0gb2JqLnZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmKHVudXNlZCA9PSAxKSB7XG4gICAgICAgICAgcnZhbCArPSAnICgxIHVudXNlZCBiaXQgc2hvd24pJztcbiAgICAgICAgfSBlbHNlIGlmKHVudXNlZCA+IDEpIHtcbiAgICAgICAgICBydmFsICs9ICcgKCcgKyB1bnVzZWQgKyAnIHVudXNlZCBiaXRzIHNob3duKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgaWYoIV9ub25MYXRpblJlZ2V4LnRlc3Qob2JqLnZhbHVlKSkge1xuICAgICAgICBydmFsICs9ICcoJyArIG9iai52YWx1ZSArICcpICc7XG4gICAgICB9XG4gICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICBydmFsICs9IGZvcmdlLnV0aWwuZGVjb2RlVXRmOChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORyB8fFxuICAgICAgb2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JQTVTdHJpbmcpIHtcbiAgICAgIHJ2YWwgKz0gb2JqLnZhbHVlO1xuICAgIH0gZWxzZSBpZihfbm9uTGF0aW5SZWdleC50ZXN0KG9iai52YWx1ZSkpIHtcbiAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBydmFsICs9ICdbbnVsbF0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsICs9IG9iai52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogT2JqZWN0IElEcyBmb3IgQVNOLjEuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG52YXIgb2lkcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLm9pZHMgPSBmb3JnZS5vaWRzID0gZm9yZ2Uub2lkcyB8fCB7fTtcblxuLy8gc2V0IGlkIHRvIG5hbWUgbWFwcGluZyBhbmQgbmFtZSB0byBpZCBtYXBwaW5nXG5mdW5jdGlvbiBfSU4oaWQsIG5hbWUpIHtcbiAgb2lkc1tpZF0gPSBuYW1lO1xuICBvaWRzW25hbWVdID0gaWQ7XG59XG4vLyBzZXQgaWQgdG8gbmFtZSBtYXBwaW5nIG9ubHlcbmZ1bmN0aW9uIF9JXyhpZCwgbmFtZSkge1xuICBvaWRzW2lkXSA9IG5hbWU7XG59XG5cbi8vIGFsZ29yaXRobSBPSURzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xJywgJ3JzYUVuY3J5cHRpb24nKTtcbi8vIE5vdGU6IG1kMiAmIG1kNCBub3QgaW1wbGVtZW50ZWRcbi8vX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMicsICdtZDJXaXRoUlNBRW5jcnlwdGlvbicpO1xuLy9fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4zJywgJ21kNFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS40JywgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS41JywgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuNycsICdSU0FFUy1PQUVQJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS44JywgJ21nZjEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjknLCAncFNwZWNpZmllZCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTAnLCAnUlNBU1NBLVBTUycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTEnLCAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEyJywgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMycsICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbicpO1xuXG5fSU4oJzEuMi44NDAuMTAwNDAuNC4zJywgJ2RzYS13aXRoLXNoYTEnKTtcblxuX0lOKCcxLjMuMTQuMy4yLjcnLCAnZGVzQ0JDJyk7XG5cbl9JTignMS4zLjE0LjMuMi4yNicsICdzaGExJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjEnLCAnc2hhMjU2Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjInLCAnc2hhMzg0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjMnLCAnc2hhNTEyJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuNScsICdtZDUnKTtcblxuLy8gcGtjcyM3IGNvbnRlbnQgdHlwZXNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjEnLCAnZGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuMicsICdzaWduZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy4zJywgJ2VudmVsb3BlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjQnLCAnc2lnbmVkQW5kRW52ZWxvcGVkRGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuNScsICdkaWdlc3RlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjYnLCAnZW5jcnlwdGVkRGF0YScpO1xuXG4vLyBwa2NzIzkgb2lkc1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMScsICdlbWFpbEFkZHJlc3MnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjInLCAndW5zdHJ1Y3R1cmVkTmFtZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMycsICdjb250ZW50VHlwZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNCcsICdtZXNzYWdlRGlnZXN0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS41JywgJ3NpZ25pbmdUaW1lJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS42JywgJ2NvdW50ZXJTaWduYXR1cmUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjcnLCAnY2hhbGxlbmdlUGFzc3dvcmQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjgnLCAndW5zdHJ1Y3R1cmVkQWRkcmVzcycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMTQnLCAnZXh0ZW5zaW9uUmVxdWVzdCcpO1xuXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMCcsICdmcmllbmRseU5hbWUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIxJywgJ2xvY2FsS2V5SWQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIyLjEnLCAneDUwOUNlcnRpZmljYXRlJyk7XG5cbi8vIHBrY3MjMTIgc2FmZSBiYWdzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4xJywgJ2tleUJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMicsICdwa2NzOFNocm91ZGVkS2V5QmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4zJywgJ2NlcnRCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjQnLCAnY3JsQmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS41JywgJ3NlY3JldEJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuNicsICdzYWZlQ29udGVudHNCYWcnKTtcblxuLy8gcGFzc3dvcmQtYmFzZWQtZW5jcnlwdGlvbiBmb3IgcGtjcyMxMlxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTMnLCAncGtjczVQQkVTMicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTInLCAncGtjczVQQktERjInKTtcblxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMScsICdwYmVXaXRoU0hBQW5kMTI4Qml0UkM0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS4yJywgJ3BiZVdpdGhTSEFBbmQ0MEJpdFJDNCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMycsICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS40JywgJ3BiZVdpdGhTSEFBbmQyLUtleVRyaXBsZURFUy1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjUnLCAncGJlV2l0aFNIQUFuZDEyOEJpdFJDMi1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjYnLCAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQycpO1xuXG4vLyBobWFjIE9JRHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMi43JywgJ2htYWNXaXRoU0hBMScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjgnLCAnaG1hY1dpdGhTSEEyMjQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi45JywgJ2htYWNXaXRoU0hBMjU2Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuMTAnLCAnaG1hY1dpdGhTSEEzODQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi4xMScsICdobWFjV2l0aFNIQTUxMicpO1xuXG4vLyBzeW1tZXRyaWMga2V5IGFsZ29yaXRobSBvaWRzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjMuNycsICdkZXMtRURFMy1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuMicsICdhZXMxMjgtQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjIyJywgJ2FlczE5Mi1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuNDInLCAnYWVzMjU2LUNCQycpO1xuXG4vLyBjZXJ0aWZpY2F0ZSBpc3N1ZXIvc3ViamVjdCBPSURzXG5fSU4oJzIuNS40LjMnLCAnY29tbW9uTmFtZScpO1xuX0lOKCcyLjUuNC41JywgJ3NlcmlhbE5hbWUnKTtcbl9JTignMi41LjQuNicsICdjb3VudHJ5TmFtZScpO1xuX0lOKCcyLjUuNC43JywgJ2xvY2FsaXR5TmFtZScpO1xuX0lOKCcyLjUuNC44JywgJ3N0YXRlT3JQcm92aW5jZU5hbWUnKTtcbl9JTignMi41LjQuMTAnLCAnb3JnYW5pemF0aW9uTmFtZScpO1xuX0lOKCcyLjUuNC4xMScsICdvcmdhbml6YXRpb25hbFVuaXROYW1lJyk7XG5fSU4oJzIuNS40LjEzJywgJ2Rlc2NyaXB0aW9uJyk7XG5cbi8vIFguNTA5IGV4dGVuc2lvbiBPSURzXG5fSU4oJzIuMTYuODQwLjEuMTEzNzMwLjEuMScsICduc0NlcnRUeXBlJyk7XG5fSV8oJzIuNS4yOS4xJywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zNVxuX0lfKCcyLjUuMjkuMicsICdrZXlBdHRyaWJ1dGVzJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS4zJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zMlxuX0lfKCcyLjUuMjkuNCcsICdrZXlVc2FnZVJlc3RyaWN0aW9uJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS41JywgJ3BvbGljeU1hcHBpbmcnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMzXG5fSV8oJzIuNS4yOS42JywgJ3N1YnRyZWVzQ29uc3RyYWludCcpOyAvLyBvYnNvbGV0ZSB1c2UgLjMwXG5fSV8oJzIuNS4yOS43JywgJ3N1YmplY3RBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xN1xuX0lfKCcyLjUuMjkuOCcsICdpc3N1ZXJBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xOFxuX0lfKCcyLjUuMjkuOScsICdzdWJqZWN0RGlyZWN0b3J5QXR0cmlidXRlcycpO1xuX0lfKCcyLjUuMjkuMTAnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JXygnMi41LjI5LjExJywgJ25hbWVDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzBcbl9JXygnMi41LjI5LjEyJywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zNlxuX0lfKCcyLjUuMjkuMTMnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JTignMi41LjI5LjE0JywgJ3N1YmplY3RLZXlJZGVudGlmaWVyJyk7XG5fSU4oJzIuNS4yOS4xNScsICdrZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuMTYnLCAncHJpdmF0ZUtleVVzYWdlUGVyaW9kJyk7XG5fSU4oJzIuNS4yOS4xNycsICdzdWJqZWN0QWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTgnLCAnaXNzdWVyQWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTknLCAnYmFzaWNDb25zdHJhaW50cycpO1xuX0lfKCcyLjUuMjkuMjAnLCAnY1JMTnVtYmVyJyk7XG5fSV8oJzIuNS4yOS4yMScsICdjUkxSZWFzb24nKTtcbl9JXygnMi41LjI5LjIyJywgJ2V4cGlyYXRpb25EYXRlJyk7XG5fSV8oJzIuNS4yOS4yMycsICdpbnN0cnVjdGlvbkNvZGUnKTtcbl9JXygnMi41LjI5LjI0JywgJ2ludmFsaWRpdHlEYXRlJyk7XG5fSV8oJzIuNS4yOS4yNScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMxXG5fSV8oJzIuNS4yOS4yNicsICdpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnQnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjI4XG5fSV8oJzIuNS4yOS4yNycsICdkZWx0YUNSTEluZGljYXRvcicpO1xuX0lfKCcyLjUuMjkuMjgnLCAnaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50Jyk7XG5fSV8oJzIuNS4yOS4yOScsICdjZXJ0aWZpY2F0ZUlzc3VlcicpO1xuX0lfKCcyLjUuMjkuMzAnLCAnbmFtZUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zMScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTtcbl9JTignMi41LjI5LjMyJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTtcbl9JXygnMi41LjI5LjMzJywgJ3BvbGljeU1hcHBpbmdzJyk7XG5fSV8oJzIuNS4yOS4zNCcsICdwb2xpY3lDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzZcbl9JTignMi41LjI5LjM1JywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTtcbl9JXygnMi41LjI5LjM2JywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zNycsICdleHRLZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuNDYnLCAnZnJlc2hlc3RDUkwnKTtcbl9JXygnMi41LjI5LjU0JywgJ2luaGliaXRBbnlQb2xpY3knKTtcblxuLy8gZXh0S2V5VXNhZ2UgcHVycG9zZXNcbl9JTignMS4zLjYuMS40LjEuMTExMjkuMi40LjInLCAndGltZXN0YW1wTGlzdCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjEuMScsICdhdXRob3JpdHlJbmZvQWNjZXNzJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy4xJywgJ3NlcnZlckF1dGgnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjInLCAnY2xpZW50QXV0aCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuMycsICdjb2RlU2lnbmluZycpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuNCcsICdlbWFpbFByb3RlY3Rpb24nKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjgnLCAndGltZVN0YW1waW5nJyk7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlIG1lc3NhZ2UgZGlnZXN0cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAyMDExLTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZCA9IGZvcmdlLm1kIHx8IHt9O1xuZm9yZ2UubWQuYWxnb3JpdGhtcyA9IGZvcmdlLm1kLmFsZ29yaXRobXMgfHwge307XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQW4gQVBJIGZvciBnZXR0aW5nIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gYnl0ZXMuIFRoZSBieXRlcyBhcmVcbiAqIGdlbmVyYXRlZCB1c2luZyB0aGUgRm9ydHVuYSBhbGdvcml0aG0gZGV2aXNlZCBieSBCcnVjZSBTY2huZWllciBhbmRcbiAqIE5pZWxzIEZlcmd1c29uLlxuICpcbiAqIEdldHRpbmcgc3Ryb25nIHJhbmRvbSBieXRlcyBpcyBub3QgeWV0IGVhc3kgdG8gZG8gaW4gamF2YXNjcmlwdC4gVGhlIG9ubHlcbiAqIHRydWlzaCByYW5kb20gZW50cm9weSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgaXMgZnJvbSB0aGUgbW91c2UsIGtleWJvYXJkLCBvclxuICogZnJvbSB0aW1pbmcgd2l0aCByZXNwZWN0IHRvIHBhZ2UgbG9hZHMsIGV0Yy4gVGhpcyBnZW5lcmF0b3IgbWFrZXMgYSBwb29yXG4gKiBhdHRlbXB0IGF0IHByb3ZpZGluZyByYW5kb20gYnl0ZXMgd2hlbiB0aG9zZSBzb3VyY2VzIGhhdmVuJ3QgeWV0IHByb3ZpZGVkXG4gKiBlbm91Z2ggZW50cm9weSB0byBpbml0aWFsbHkgc2VlZCBvciB0byByZXNlZWQgdGhlIFBSTkcuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnJhbmRvbSBhbHJlYWR5IGRlZmluZWRcbmlmKGZvcmdlLnJhbmRvbSAmJiBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG4gIHJldHVybjtcbn1cblxuKGZ1bmN0aW9uKGpRdWVyeSkge1xuXG4vLyB0aGUgZGVmYXVsdCBwcm5nIHBsdWdpbiwgdXNlcyBBRVMtMTI4XG52YXIgcHJuZ19hZXMgPSB7fTtcbnZhciBfcHJuZ19hZXNfb3V0cHV0ID0gbmV3IEFycmF5KDQpO1xudmFyIF9wcm5nX2Flc19idWZmZXIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xucHJuZ19hZXMuZm9ybWF0S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIGNvbnZlcnQgdGhlIGtleSBpbnRvIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgdG1wID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoa2V5KTtcbiAga2V5ID0gbmV3IEFycmF5KDQpO1xuICBrZXlbMF0gPSB0bXAuZ2V0SW50MzIoKTtcbiAga2V5WzFdID0gdG1wLmdldEludDMyKCk7XG4gIGtleVsyXSA9IHRtcC5nZXRJbnQzMigpO1xuICBrZXlbM10gPSB0bXAuZ2V0SW50MzIoKTtcblxuICAvLyByZXR1cm4gdGhlIGV4cGFuZGVkIGtleVxuICByZXR1cm4gZm9yZ2UuYWVzLl9leHBhbmRLZXkoa2V5LCBmYWxzZSk7XG59O1xucHJuZ19hZXMuZm9ybWF0U2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgLy8gY29udmVydCBzZWVkIGludG8gMzItYml0IGludGVnZXJzXG4gIHZhciB0bXAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzZWVkKTtcbiAgc2VlZCA9IG5ldyBBcnJheSg0KTtcbiAgc2VlZFswXSA9IHRtcC5nZXRJbnQzMigpO1xuICBzZWVkWzFdID0gdG1wLmdldEludDMyKCk7XG4gIHNlZWRbMl0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgc2VlZFszXSA9IHRtcC5nZXRJbnQzMigpO1xuICByZXR1cm4gc2VlZDtcbn07XG5wcm5nX2Flcy5jaXBoZXIgPSBmdW5jdGlvbihrZXksIHNlZWQpIHtcbiAgZm9yZ2UuYWVzLl91cGRhdGVCbG9jayhrZXksIHNlZWQsIF9wcm5nX2Flc19vdXRwdXQsIGZhbHNlKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzBdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzFdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzJdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzNdKTtcbiAgcmV0dXJuIF9wcm5nX2Flc19idWZmZXIuZ2V0Qnl0ZXMoKTtcbn07XG5wcm5nX2Flcy5pbmNyZW1lbnQgPSBmdW5jdGlvbihzZWVkKSB7XG4gIC8vIEZJWE1FOiBkbyB3ZSBjYXJlIGFib3V0IGNhcnJ5IG9yIHNpZ25lZCBpc3N1ZXM/XG4gICsrc2VlZFszXTtcbiAgcmV0dXJuIHNlZWQ7XG59O1xucHJuZ19hZXMubWQgPSBmb3JnZS5tZC5zaGEyNTY7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HLlxuICovXG5mdW5jdGlvbiBzcGF3blBybmcoKSB7XG4gIHZhciBjdHggPSBmb3JnZS5wcm5nLmNyZWF0ZShwcm5nX2Flcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgcmFuZG9tIGJ5dGVzLiBJZiBhIG5hdGl2ZSBzZWN1cmUgY3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZSwgdGhpc1xuICAgKiBtZXRob2QgdHJpZXMgdG8gbWFrZSB0aGUgYnl0ZXMgbW9yZSB1bnByZWRpY3RhYmxlIGJ5IGRyYXdpbmcgZnJvbSBkYXRhIHRoYXRcbiAgICogY2FuIGJlIGNvbGxlY3RlZCBmcm9tIHRoZSB1c2VyIG9mIHRoZSBicm93c2VyLCBlZzogbW91c2UgbW92ZW1lbnQuXG4gICAqXG4gICAqIElmIGEgY2FsbGJhY2sgaXMgZ2l2ZW4sIHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwgYnl0ZXMpXSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgcmFuZG9tIGJ5dGVzIGluIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGN0eC5nZW5lcmF0ZShjb3VudCwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHJhbmRvbSBieXRlcyBhc3luY2hyb25vdXNseS4gSWYgYSBuYXRpdmUgc2VjdXJlIGNyeXB0byBBUEkgaXNcbiAgICogdW5hdmFpbGFibGUsIHRoaXMgbWV0aG9kIHRyaWVzIHRvIG1ha2UgdGhlIGJ5dGVzIG1vcmUgdW5wcmVkaWN0YWJsZSBieVxuICAgKiBkcmF3aW5nIGZyb20gZGF0YSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgZnJvbSB0aGUgdXNlciBvZiB0aGUgYnJvd3NlcixcbiAgICogZWc6IG1vdXNlIG1vdmVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMgaW4gYSBzdHJpbmcuXG4gICAqL1xuICBjdHguZ2V0Qnl0ZXNTeW5jID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICByZXR1cm4gY3R4LmdlbmVyYXRlKGNvdW50KTtcbiAgfTtcblxuICByZXR1cm4gY3R4O1xufVxuXG4vLyBjcmVhdGUgZGVmYXVsdCBwcm5nIGNvbnRleHRcbnZhciBfY3R4ID0gc3Bhd25Qcm5nKCk7XG5cbi8vIGFkZCBvdGhlciBzb3VyY2VzIG9mIGVudHJvcHkgb25seSBpZiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpcyBub3Rcbi8vIGF2YWlsYWJsZSAtLSBvdGhlcndpc2UgdGhpcyBzb3VyY2Ugd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVzZWQgYnkgdGhlIHBybmdcbnZhciBnZXRSYW5kb21WYWx1ZXMgPSBudWxsO1xuaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIF9jcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcbiAgaWYoX2NyeXB0byAmJiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIGdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgfTtcbiAgfVxufVxuaWYoZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCB8fFxuICAoIWZvcmdlLnV0aWwuaXNOb2RlanMgJiYgIWdldFJhbmRvbVZhbHVlcykpIHtcbiAgLy8gaWYgdGhpcyBpcyBhIHdlYiB3b3JrZXIsIGRvIG5vdCB1c2Ugd2VhayBlbnRyb3B5LCBpbnN0ZWFkIHJlZ2lzdGVyIHRvXG4gIC8vIHJlY2VpdmUgc3Ryb25nIGVudHJvcHkgYXN5bmNocm9ub3VzbHkgZnJvbSB0aGUgbWFpbiB0aHJlYWRcbiAgaWYodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgd2luZG93LmRvY3VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBGSVhNRTpcbiAgfVxuXG4gIC8vIGdldCBsb2FkIHRpbWUgZW50cm9weVxuICBfY3R4LmNvbGxlY3RJbnQoK25ldyBEYXRlKCksIDMyKTtcblxuICAvLyBhZGQgc29tZSBlbnRyb3B5IGZyb20gbmF2aWdhdG9yIG9iamVjdFxuICBpZih0eXBlb2YobmF2aWdhdG9yKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgX25hdkJ5dGVzID0gJyc7XG4gICAgZm9yKHZhciBrZXkgaW4gbmF2aWdhdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZih0eXBlb2YobmF2aWdhdG9yW2tleV0pID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgX25hdkJ5dGVzICs9IG5hdmlnYXRvcltrZXldO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLyogU29tZSBuYXZpZ2F0b3Iga2V5cyBtaWdodCBub3QgYmUgYWNjZXNzaWJsZSwgZS5nLiB0aGUgZ2VvbG9jYXRpb25cbiAgICAgICAgICBhdHRyaWJ1dGUgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0b3VjaGVkIGluIE1vemlsbGEgY2hyb21lOi8vXG4gICAgICAgICAgY29udGV4dC5cblxuICAgICAgICAgIFNpbGVudGx5IGlnbm9yZSB0aGlzIGFuZCBqdXN0IGRvbid0IHVzZSB0aGlzIGFzIGEgc291cmNlIG9mXG4gICAgICAgICAgZW50cm9weS4gKi9cbiAgICAgIH1cbiAgICB9XG4gICAgX2N0eC5jb2xsZWN0KF9uYXZCeXRlcyk7XG4gICAgX25hdkJ5dGVzID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFkZCBtb3VzZSBhbmQga2V5Ym9hcmQgY29sbGVjdG9ycyBpZiBqcXVlcnkgaXMgYXZhaWxhYmxlXG4gIGlmKGpRdWVyeSkge1xuICAgIC8vIHNldCB1cCBtb3VzZSBlbnRyb3B5IGNhcHR1cmVcbiAgICBqUXVlcnkoKS5tb3VzZW1vdmUoZnVuY3Rpb24oZSkge1xuICAgICAgLy8gYWRkIG1vdXNlIGNvb3Jkc1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WCwgMTYpO1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WSwgMTYpO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IHVwIGtleWJvYXJkIGVudHJvcHkgY2FwdHVyZVxuICAgIGpRdWVyeSgpLmtleXByZXNzKGZ1bmN0aW9uKGUpIHtcbiAgICAgIF9jdHguY29sbGVjdEludChlLmNoYXJDb2RlLCA4KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiBSYW5kb20gQVBJICovXG5pZighZm9yZ2UucmFuZG9tKSB7XG4gIGZvcmdlLnJhbmRvbSA9IF9jdHg7XG59IGVsc2Uge1xuICAvLyBleHRlbmQgZm9yZ2UucmFuZG9tIHdpdGggX2N0eFxuICBmb3IodmFyIGtleSBpbiBfY3R4KSB7XG4gICAgZm9yZ2UucmFuZG9tW2tleV0gPSBfY3R4W2tleV07XG4gIH1cbn1cblxuLy8gZXhwb3NlIHNwYXduIFBSTkdcbmZvcmdlLnJhbmRvbS5jcmVhdGVJbnN0YW5jZSA9IHNwYXduUHJuZztcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG5cbn0pKHR5cGVvZihqUXVlcnkpICE9PSAndW5kZWZpbmVkJyA/IGpRdWVyeSA6IG51bGwpO1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgUlNBIGFsZ29yaXRobXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBvbmx5IGFsZ29yaXRobSBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBQS0kgaXMgUlNBLlxuICpcbiAqIEFuIFJTQSBrZXkgaXMgb2Z0ZW4gc3RvcmVkIGluIEFTTi4xIERFUiBmb3JtYXQuIFRoZSBTdWJqZWN0UHVibGljS2V5SW5mb1xuICogQVNOLjEgc3RydWN0dXJlIGlzIGNvbXBvc2VkIG9mIGFuIGFsZ29yaXRobSBvZiB0eXBlIEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIGFuZCBhIHN1YmplY3RQdWJsaWNLZXkgb2YgdHlwZSBiaXQgc3RyaW5nLlxuICpcbiAqIFRoZSBBbGdvcml0aG1JZGVudGlmaWVyIGNvbnRhaW5zIGFuIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIGFuZCBwYXJhbWV0ZXJzXG4gKiBmb3IgdGhlIGFsZ29yaXRobSwgaWYgYW55LiBJbiB0aGUgY2FzZSBvZiBSU0EsIHRoZXJlIGFyZW4ndCBhbnkuXG4gKlxuICogU3ViamVjdFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgYWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgQklUIFNUUklOR1xuICogfVxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRm9yIGFuIFJTQSBwdWJsaWMga2V5LCB0aGUgc3ViamVjdFB1YmxpY0tleSBpczpcbiAqXG4gKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAqICAgbW9kdWx1cyAgICAgICAgICAgIElOVEVHRVIsICAgIC0tIG5cbiAqICAgcHVibGljRXhwb25lbnQgICAgIElOVEVHRVIgICAgIC0tIGVcbiAqIH1cbiAqXG4gKiBQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIHByaXZhdGVLZXlBbGdvcml0aG0gICAgICAgUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHByaXZhdGVLZXkgICAgICAgICAgICAgICAgUHJpdmF0ZUtleSxcbiAqICAgYXR0cmlidXRlcyAgICAgICAgICAgWzBdICBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICogUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIFByaXZhdGVLZXkgOjo9IE9DVEVUIFNUUklOR1xuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEFuIFJTQSBwcml2YXRlIGtleSBhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiBSU0FQcml2YXRlS2V5IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gVmVyc2lvbixcbiAqICAgbW9kdWx1cyBJTlRFR0VSLCAtLSBuXG4gKiAgIHB1YmxpY0V4cG9uZW50IElOVEVHRVIsIC0tIGVcbiAqICAgcHJpdmF0ZUV4cG9uZW50IElOVEVHRVIsIC0tIGRcbiAqICAgcHJpbWUxIElOVEVHRVIsIC0tIHBcbiAqICAgcHJpbWUyIElOVEVHRVIsIC0tIHFcbiAqICAgZXhwb25lbnQxIElOVEVHRVIsIC0tIGQgbW9kIChwLTEpXG4gKiAgIGV4cG9uZW50MiBJTlRFR0VSLCAtLSBkIG1vZCAocS0xKVxuICogICBjb2VmZmljaWVudCBJTlRFR0VSIC0tIChpbnZlcnNlIG9mIHEpIG1vZCBwXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICpcbiAqIFRoZSBPSUQgZm9yIHRoZSBSU0Ega2V5IGFsZ29yaXRobSBpczogMS4yLjg0MC4xMTM1NDkuMS4xLjFcbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmlmKHR5cGVvZiBCaWdJbnRlZ2VyID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcjtcbn1cblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKlxuICogUlNBIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24sIHNlZSBSRkMgMjMxMy5cbiAqL1xuZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2kucnNhID0gZm9yZ2UucnNhID0gZm9yZ2UucnNhIHx8IHt9O1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gZm9yIGZpbmRpbmcgcHJpbWVzLCB3aGljaCBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgUHJpdmF0ZUtleUluZm8gc3RydWN0dXJlXG52YXIgcHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdQcml2YXRlS2V5SW5mby52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5VmVyc2lvbidcbiAgfSwge1xuICAgIC8vIHByaXZhdGVLZXlBbGdvcml0aG1cbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlPaWQnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIFByaXZhdGVLZXlcbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5J1xuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBSU0EgcHJpdmF0ZSBrZXlcbnZhciByc2FQcml2YXRlS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQcml2YXRlS2V5XG4gIG5hbWU6ICdSU0FQcml2YXRlS2V5JyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlWZXJzaW9uJ1xuICB9LCB7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5tb2R1bHVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5TW9kdWx1cydcbiAgfSwge1xuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnB1YmxpY0V4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHVibGljRXhwb25lbnQnXG4gIH0sIHtcbiAgICAvLyBwcml2YXRlRXhwb25lbnQgKGQpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHJpdmF0ZUV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHJpdmF0ZUV4cG9uZW50J1xuICB9LCB7XG4gICAgLy8gcHJpbWUxIChwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnByaW1lMScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVByaW1lMSdcbiAgfSwge1xuICAgIC8vIHByaW1lMiAocSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wcmltZTInLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQcmltZTInXG4gIH0sIHtcbiAgICAvLyBleHBvbmVudDEgKGQgbW9kIChwLTEpKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmV4cG9uZW50MScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUV4cG9uZW50MSdcbiAgfSwge1xuICAgIC8vIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkuZXhwb25lbnQyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5RXhwb25lbnQyJ1xuICB9LCB7XG4gICAgLy8gY29lZmZpY2llbnQgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmNvZWZmaWNpZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5Q29lZmZpY2llbnQnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcnNhUHVibGljS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgbmFtZTogJ1JTQVB1YmxpY0tleScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5Lm1vZHVsdXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3B1YmxpY0tleU1vZHVsdXMnXG4gIH0sIHtcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5LmV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwdWJsaWNLZXlFeHBvbmVudCdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gU3ViamVjdFB1YmxpY0tleUluZm8gc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcHVibGljS2V5VmFsaWRhdG9yID0gZm9yZ2UucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdzdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAncHVibGljS2V5T2lkJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXknLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIFJTQVB1YmxpY0tleVxuICAgICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXkuUlNBUHVibGljS2V5JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ3JzYVB1YmxpY0tleSdcbiAgICB9XVxuICB9XVxufTtcblxuLyoqXG4gKiBXcmFwIGRpZ2VzdCBpbiBEaWdlc3RJbmZvIG9iamVjdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgRU1TQS1QS0NTMS12MV81LUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcuXG4gKlxuICogRGlnZXN0SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBkaWdlc3RBbGdvcml0aG0gRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZGlnZXN0IERpZ2VzdFxuICogfVxuICpcbiAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSAocmVhZHkgZm9yIFJTQSBlbmNyeXRpb24pXG4gKi9cbnZhciBlbXNhUGtjczF2MTVlbmNvZGUgPSBmdW5jdGlvbihtZCkge1xuICAvLyBnZXQgdGhlIG9pZCBmb3IgdGhlIGFsZ29yaXRobVxuICB2YXIgb2lkO1xuICBpZihtZC5hbGdvcml0aG0gaW4gcGtpLm9pZHMpIHtcbiAgICBvaWQgPSBwa2kub2lkc1ttZC5hbGdvcml0aG1dO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gbWQuYWxnb3JpdGhtO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHZhciBvaWRCeXRlcyA9IGFzbjEub2lkVG9EZXIob2lkKS5nZXRCeXRlcygpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgZGlnZXN0IGluZm9cbiAgdmFyIGRpZ2VzdEluZm8gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHZhciBkaWdlc3RBbGdvcml0aG0gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIGRpZ2VzdEFsZ29yaXRobS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSwgb2lkQnl0ZXMpKTtcbiAgZGlnZXN0QWxnb3JpdGhtLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpKTtcbiAgdmFyIGRpZ2VzdCA9IGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgZmFsc2UsIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICBkaWdlc3RJbmZvLnZhbHVlLnB1c2goZGlnZXN0QWxnb3JpdGhtKTtcbiAgZGlnZXN0SW5mby52YWx1ZS5wdXNoKGRpZ2VzdCk7XG5cbiAgLy8gZW5jb2RlIGRpZ2VzdCBpbmZvXG4gIHJldHVybiBhc24xLnRvRGVyKGRpZ2VzdEluZm8pLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHheYyBtb2QgbiAoUlNBIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBvcGVyYXRpb24pLlxuICpcbiAqIEBwYXJhbSB4IHRoZSBudW1iZXIgdG8gcmFpc2UgYW5kIG1vZC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBwdWJsaWMsIGZhbHNlIGlmIHByaXZhdGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0IG9mIHheYyBtb2Qgbi5cbiAqL1xudmFyIF9tb2RQb3cgPSBmdW5jdGlvbih4LCBrZXksIHB1Yikge1xuICBpZihwdWIpIHtcbiAgICByZXR1cm4geC5tb2RQb3coa2V5LmUsIGtleS5uKTtcbiAgfVxuXG4gIGlmKCFrZXkucCB8fCAha2V5LnEpIHtcbiAgICAvLyBhbGxvdyBjYWxjdWxhdGlvbiB3aXRob3V0IENSVCBwYXJhbXMgKHNsb3cpXG4gICAgcmV0dXJuIHgubW9kUG93KGtleS5kLCBrZXkubik7XG4gIH1cblxuICAvLyBwcmUtY29tcHV0ZSBkUCwgZFEsIGFuZCBxSW52IGlmIG5lY2Vzc2FyeVxuICBpZigha2V5LmRQKSB7XG4gICAga2V5LmRQID0ga2V5LmQubW9kKGtleS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKSk7XG4gIH1cbiAgaWYoIWtleS5kUSkge1xuICAgIGtleS5kUSA9IGtleS5kLm1vZChrZXkucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpO1xuICB9XG4gIGlmKCFrZXkucUludikge1xuICAgIGtleS5xSW52ID0ga2V5LnEubW9kSW52ZXJzZShrZXkucCk7XG4gIH1cblxuICAvKiBDaGluZXNlIHJlbWFpbmRlciB0aGVvcmVtIChDUlQpIHN0YXRlczpcblxuICAgIFN1cHBvc2UgbjEsIG4yLCAuLi4sIG5rIGFyZSBwb3NpdGl2ZSBpbnRlZ2VycyB3aGljaCBhcmUgcGFpcndpc2VcbiAgICBjb3ByaW1lIChuMSBhbmQgbjIgaGF2ZSBubyBjb21tb24gZmFjdG9ycyBvdGhlciB0aGFuIDEpLiBGb3IgYW55XG4gICAgaW50ZWdlcnMgeDEsIHgyLCAuLi4sIHhrIHRoZXJlIGV4aXN0cyBhbiBpbnRlZ2VyIHggc29sdmluZyB0aGVcbiAgICBzeXN0ZW0gb2Ygc2ltdWx0YW5lb3VzIGNvbmdydWVuY2VzICh3aGVyZSB+PSBtZWFucyBtb2R1bGFybHlcbiAgICBjb25ncnVlbnQgc28gYSB+PSBiIG1vZCBuIG1lYW5zIGEgbW9kIG4gPSBiIG1vZCBuKTpcblxuICAgIHggfj0geDEgbW9kIG4xXG4gICAgeCB+PSB4MiBtb2QgbjJcbiAgICAuLi5cbiAgICB4IH49IHhrIG1vZCBua1xuXG4gICAgVGhpcyBzeXN0ZW0gb2YgY29uZ3J1ZW5jZXMgaGFzIGEgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4XG4gICAgYmV0d2VlbiAwIGFuZCBuIC0gMS4gRnVydGhlcm1vcmUsIGVhY2ggeGsgc29sdXRpb24gYW5kIHggaXRzZWxmXG4gICAgaXMgY29uZ3J1ZW50IG1vZHVsbyB0aGUgcHJvZHVjdCBuID0gbjEqbjIqLi4uKm5rLlxuICAgIFNvIHgxIG1vZCBuID0geDIgbW9kIG4gPSB4ayBtb2QgbiA9IHggbW9kIG4uXG5cbiAgICBUaGUgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4IGNhbiBiZSBzb2x2ZWQgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgZXF1YXRpb246XG5cbiAgICB4ID0gc3VtKHhpKnJpKnNpKSBtb2QgbiB3aGVyZSByaSA9IG4vbmkgYW5kIHNpID0gcmleLTEgbW9kIG5pLlxuXG4gICAgV2hlcmUgeCBpcyBsZXNzIHRoYW4gbiwgeGkgPSB4IG1vZCBuaS5cblxuICAgIEZvciBSU0Egd2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggayA9IDIuIFRoZSBtb2R1bHVzIG4gPSBwcSwgd2hlcmVcbiAgICBwIGFuZCBxIGFyZSBjb3ByaW1lLiBUaGUgUlNBIGRlY3J5cHRpb24gYWxnb3JpdGhtIGlzOlxuXG4gICAgeSA9IHheZCBtb2QgblxuXG4gICAgR2l2ZW4gdGhlIGFib3ZlOlxuXG4gICAgeDEgPSB4XmQgbW9kIHBcbiAgICByMSA9IG4vcCA9IHFcbiAgICBzMSA9IHFeLTEgbW9kIHBcbiAgICB4MiA9IHheZCBtb2QgcVxuICAgIHIyID0gbi9xID0gcFxuICAgIHMyID0gcF4tMSBtb2QgcVxuXG4gICAgU28geSA9ICh4MXIxczEgKyB4MnIyczIpIG1vZCBuXG4gICAgICAgICA9ICgoeF5kIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kIG1vZCBxKXAocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBBY2NvcmRpbmcgdG8gRmVybWF0J3MgTGl0dGxlIFRoZW9yZW0sIGlmIHRoZSBtb2R1bHVzIFAgaXMgcHJpbWUsXG4gICAgZm9yIGFueSBpbnRlZ2VyIEEgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgUCwgQV4oUC0xKSB+PSAxIG1vZCBQLlxuICAgIFNpbmNlIEEgaXMgbm90IGRpdmlzaWJsZSBieSBQIGl0IGZvbGxvd3MgdGhhdCBpZjpcbiAgICBOIH49IE0gbW9kIChQIC0gMSksIHRoZW4gQV5OIG1vZCBQID0gQV5NIG1vZCBQLiBUaGVyZWZvcmU6XG5cbiAgICBBXk4gbW9kIFAgPSBBXihNIG1vZCAoUCAtIDEpKSBtb2QgUC4gKFRoZSBsYXR0ZXIgdGFrZXMgbGVzcyBlZmZvcnRcbiAgICB0byBjYWxjdWxhdGUpLiBJbiBvcmRlciB0byBjYWxjdWxhdGUgeF5kIG1vZCBwIG1vcmUgcXVpY2tseSB0aGVcbiAgICBleHBvbmVudCBkIG1vZCAocCAtIDEpIGlzIHN0b3JlZCBpbiB0aGUgUlNBIHByaXZhdGUga2V5ICh0aGUgc2FtZVxuICAgIGlzIGRvbmUgZm9yIHheZCBtb2QgcSkuIFRoZXNlIHZhbHVlcyBhcmUgcmVmZXJyZWQgdG8gYXMgZFAgYW5kIGRRXG4gICAgcmVzcGVjdGl2ZWx5LiBUaGVyZWZvcmUgd2Ugbm93IGhhdmU6XG5cbiAgICB5ID0gKCh4XmRQIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kUSBtb2QgcSlwKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgU2luY2Ugd2UnbGwgYmUgcmVkdWNpbmcgeF5kUCBieSBtb2R1bG8gcCAoc2FtZSBmb3IgcSkgd2UgY2FuIGFsc29cbiAgICByZWR1Y2UgeCBieSBwIChhbmQgcSByZXNwZWN0aXZlbHkpIGJlZm9yZSBoYW5kLiBUaGVyZWZvcmUsIGxldFxuXG4gICAgeHAgPSAoKHggbW9kIHApXmRQIG1vZCBwKSwgYW5kXG4gICAgeHEgPSAoKHggbW9kIHEpXmRRIG1vZCBxKSwgeWllbGRpbmc6XG5cbiAgICB5ID0gKHhwKnEqKHFeLTEgbW9kIHApICsgeHEqcCoocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBUaGlzIGNhbiBiZSBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW1wbGUgYWxnb3JpdGhtIHRoYXQgb25seVxuICAgIHJlcXVpcmVzIDEgaW52ZXJzZSAodGhlIHEgaW52ZXJzZSBpcyB1c2VkKSB0byBiZSB1c2VkIGFuZCBzdG9yZWQuXG4gICAgVGhlIGFsZ29yaXRobSBpcyBjYWxsZWQgR2FybmVyJ3MgYWxnb3JpdGhtLiBJZiBxSW52IGlzIHRoZVxuICAgIGludmVyc2Ugb2YgcSwgd2Ugc2ltcGx5IGNhbGN1bGF0ZTpcblxuICAgIHkgPSAocUludiooeHAgLSB4cSkgbW9kIHApICogcSArIHhxXG5cbiAgICBIb3dldmVyLCB0aGVyZSBhcmUgdHdvIGZ1cnRoZXIgY29tcGxpY2F0aW9ucy4gRmlyc3QsIHdlIG5lZWQgdG9cbiAgICBlbnN1cmUgdGhhdCB4cCA+IHhxIHRvIHByZXZlbnQgc2lnbmVkIEJpZ0ludGVnZXJzIGZyb20gYmVpbmcgdXNlZFxuICAgIHNvIHdlIGFkZCBwIHVudGlsIHRoaXMgaXMgdHJ1ZSAoc2luY2Ugd2Ugd2lsbCBiZSBtb2QnaW5nIHdpdGhcbiAgICBwIGFueXdheSkuIFRoZW4sIHRoZXJlIGlzIGEga25vd24gdGltaW5nIGF0dGFjayBvbiBhbGdvcml0aG1zXG4gICAgdXNpbmcgdGhlIENSVC4gVG8gbWl0aWdhdGUgdGhpcyByaXNrLCBcImNyeXB0b2dyYXBoaWMgYmxpbmRpbmdcIlxuICAgIHNob3VsZCBiZSB1c2VkLiBUaGlzIHJlcXVpcmVzIHNpbXBseSBnZW5lcmF0aW5nIGEgcmFuZG9tIG51bWJlciByXG4gICAgYmV0d2VlbiAwIGFuZCBuLTEgYW5kIGl0cyBpbnZlcnNlIGFuZCBtdWx0aXBseWluZyB4IGJ5IHJeZSBiZWZvcmVcbiAgICBjYWxjdWxhdGluZyB5IGFuZCB0aGVuIG11bHRpcGx5aW5nIHkgYnkgcl4tMSBhZnRlcndhcmRzLiBOb3RlIHRoYXRcbiAgICByIG11c3QgYmUgY29wcmltZSB3aXRoIG4gKGdjZChyLCBuKSA9PT0gMSkgaW4gb3JkZXIgdG8gaGF2ZSBhblxuICAgIGludmVyc2UuXG4gICovXG5cbiAgLy8gY3J5cHRvZ3JhcGhpYyBibGluZGluZ1xuICB2YXIgcjtcbiAgZG8ge1xuICAgIHIgPSBuZXcgQmlnSW50ZWdlcihcbiAgICAgIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KSksXG4gICAgICAxNik7XG4gIH0gd2hpbGUoci5jb21wYXJlVG8oa2V5Lm4pID49IDAgfHwgIXIuZ2NkKGtleS5uKS5lcXVhbHMoQmlnSW50ZWdlci5PTkUpKTtcbiAgeCA9IHgubXVsdGlwbHkoci5tb2RQb3coa2V5LmUsIGtleS5uKSkubW9kKGtleS5uKTtcblxuICAvLyBjYWxjdWxhdGUgeHAgYW5kIHhxXG4gIHZhciB4cCA9IHgubW9kKGtleS5wKS5tb2RQb3coa2V5LmRQLCBrZXkucCk7XG4gIHZhciB4cSA9IHgubW9kKGtleS5xKS5tb2RQb3coa2V5LmRRLCBrZXkucSk7XG5cbiAgLy8geHAgbXVzdCBiZSBsYXJnZXIgdGhhbiB4cSB0byBhdm9pZCBzaWduZWQgYml0IHVzYWdlXG4gIHdoaWxlKHhwLmNvbXBhcmVUbyh4cSkgPCAwKSB7XG4gICAgeHAgPSB4cC5hZGQoa2V5LnApO1xuICB9XG5cbiAgLy8gZG8gbGFzdCBzdGVwXG4gIHZhciB5ID0geHAuc3VidHJhY3QoeHEpXG4gICAgLm11bHRpcGx5KGtleS5xSW52KS5tb2Qoa2V5LnApXG4gICAgLm11bHRpcGx5KGtleS5xKS5hZGQoeHEpO1xuXG4gIC8vIHJlbW92ZSBlZmZlY3Qgb2YgcmFuZG9tIGZvciBjcnlwdG9ncmFwaGljIGJsaW5kaW5nXG4gIHkgPSB5Lm11bHRpcGx5KHIubW9kSW52ZXJzZShrZXkubikpLm1vZChrZXkubik7XG5cbiAgcmV0dXJuIHk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnc2lnbicgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICdlbmNyeXB0JyBvbiBhIHB1YmxpYyBrZXkgb2JqZWN0IGluc3RlYWQuXG4gKlxuICogUGVyZm9ybXMgUlNBIGVuY3J5cHRpb24uXG4gKlxuICogVGhlIHBhcmFtZXRlciBidCBjb250cm9scyB3aGV0aGVyIHRvIHB1dCBwYWRkaW5nIGJ5dGVzIGJlZm9yZSB0aGVcbiAqIG1lc3NhZ2UgcGFzc2VkIGluLiBTZXQgYnQgdG8gZWl0aGVyIHRydWUgb3IgZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nXG4gKiBjb21wbGV0ZWx5IChpbiBvcmRlciB0byBoYW5kbGUgZS5nLiBFTVNBLVBTUyBlbmNvZGluZyBzZXBlcmF0ZWx5IGJlZm9yZSksXG4gKiBzaWduYWxpbmcgd2hldGhlciB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYSBwdWJsaWMga2V5IG9wZXJhdGlvblxuICogKGkuZS4gZW5jcnlwdGluZyBkYXRhKSBvciBub3QsIGkuZS4gcHJpdmF0ZSBrZXkgb3BlcmF0aW9uIChkYXRhIHNpZ25pbmcpLlxuICpcbiAqIEZvciBQS0NTIzEgdjEuNSBwYWRkaW5nIHBhc3MgaW4gdGhlIGJsb2NrIHR5cGUgdG8gdXNlLCBpLmUuIGVpdGhlciAweDAxXG4gKiAoZm9yIHNpZ25pbmcpIG9yIDB4MDIgKGZvciBlbmNyeXB0aW9uKS4gVGhlIGtleSBvcGVyYXRpb24gbW9kZSAocHJpdmF0ZVxuICogb3IgcHVibGljKSBpcyBkZXJpdmVkIGZyb20gdGhpcyBmbGFnIGluIHRoYXQgY2FzZSkuXG4gKlxuICogQHBhcmFtIG0gdGhlIG1lc3NhZ2UgdG8gZW5jcnlwdCBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gYnQgZm9yIFBLQ1MjMSB2MS41IHBhZGRpbmcsIHRoZSBibG9jayB0eXBlIHRvIHVzZVxuICogICAoMHgwMSBmb3IgcHJpdmF0ZSBrZXksIDB4MDIgZm9yIHB1YmxpYyksXG4gKiAgIHRvIGRpc2FibGUgcGFkZGluZzogdHJ1ZSA9IHB1YmxpYyBrZXksIGZhbHNlID0gcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgZW5jcnlwdGVkIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICovXG5wa2kucnNhLmVuY3J5cHQgPSBmdW5jdGlvbihtLCBrZXksIGJ0KSB7XG4gIHZhciBwdWIgPSBidDtcbiAgdmFyIGViO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgaWYoYnQgIT09IGZhbHNlICYmIGJ0ICE9PSB0cnVlKSB7XG4gICAgLy8gbGVnYWN5LCBkZWZhdWx0IHRvIFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAgICBwdWIgPSAoYnQgPT09IDB4MDIpO1xuICAgIGViID0gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCk7XG4gIH0gZWxzZSB7XG4gICAgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGViLnB1dEJ5dGVzKG0pO1xuICB9XG5cbiAgLy8gbG9hZCBlbmNyeXB0aW9uIGJsb2NrIGFzIGJpZyBpbnRlZ2VyICd4J1xuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB4ID0gbmV3IEJpZ0ludGVnZXIoZWIudG9IZXgoKSwgMTYpO1xuXG4gIC8vIGRvIFJTQSBlbmNyeXB0aW9uXG4gIHZhciB5ID0gX21vZFBvdyh4LCBrZXksIHB1Yik7XG5cbiAgLy8gY29udmVydCB5IGludG8gdGhlIGVuY3J5cHRlZCBkYXRhIGJ5dGUgc3RyaW5nLCBpZiB5IGlzIHNob3J0ZXIgaW5cbiAgLy8gYnl0ZXMgdGhhbiBrLCB0aGVuIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGVkXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHloZXggPSB5LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh5aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlZC5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWQucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHloZXgpKTtcbiAgcmV0dXJuIGVkLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnZGVjcnlwdCcgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICd2ZXJpZnknIG9uIGEgcHVibGljIGtleSBvYmplY3QgaW5zdGVhZC5cbiAqXG4gKiBQZXJmb3JtcyBSU0EgZGVjcnlwdGlvbi5cbiAqXG4gKiBUaGUgcGFyYW1ldGVyIG1sIGNvbnRyb2xzIHdoZXRoZXIgdG8gYXBwbHkgUEtDUyMxIHYxLjUgcGFkZGluZ1xuICogb3Igbm90LiAgU2V0IG1sID0gZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nIHJlbW92YWwgY29tcGxldGVseVxuICogKGluIG9yZGVyIHRvIGhhbmRsZSBlLmcuIEVNU0EtUFNTIGxhdGVyIG9uKSBhbmQgc2ltcGx5IHBhc3MgYmFja1xuICogdGhlIFJTQSBlbmNyeXB0aW9uIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBlZCB0aGUgZW5jcnlwdGVkIGRhdGEgdG8gZGVjcnlwdCBpbiBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgZm9yIGEgcHVibGljIGtleSBvcGVyYXRpb24sIGZhbHNlIGZvciBwcml2YXRlLlxuICogQHBhcmFtIG1sIHRoZSBtZXNzYWdlIGxlbmd0aCwgaWYga25vd24sIGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNyeXB0ZWQgbWVzc2FnZSBhcyBhIGJ5dGUgc3RyaW5nLlxuICovXG5wa2kucnNhLmRlY3J5cHQgPSBmdW5jdGlvbihlZCwga2V5LCBwdWIsIG1sKSB7XG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLy8gZXJyb3IgaWYgdGhlIGxlbmd0aCBvZiB0aGUgZW5jcnlwdGVkIGRhdGEgRUQgaXMgbm90IGtcbiAgaWYoZWQubGVuZ3RoICE9PSBrKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlZC5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWQgPSBrO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY29udmVydCBlbmNyeXB0ZWQgZGF0YSBpbnRvIGEgYmlnIGludGVnZXJcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeSA9IG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVkKS50b0hleCgpLCAxNik7XG5cbiAgLy8geSBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgbW9kdWx1cyBvciBpdCB3YXNuJ3QgdGhlIHJlc3VsdCBvZlxuICAvLyBhIHByZXZpb3VzIG1vZCBvcGVyYXRpb24gKGVuY3J5cHRpb24pIHVzaW5nIHRoYXQgbW9kdWx1c1xuICBpZih5LmNvbXBhcmVUbyhrZXkubikgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIC8vIGRvIFJTQSBkZWNyeXB0aW9uXG4gIHZhciB4ID0gX21vZFBvdyh5LCBrZXksIHB1Yik7XG5cbiAgLy8gY3JlYXRlIHRoZSBlbmNyeXB0aW9uIGJsb2NrLCBpZiB4IGlzIHNob3J0ZXIgaW4gYnl0ZXMgdGhhbiBrLCB0aGVuXG4gIC8vIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGViXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHhoZXggPSB4LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh4aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlYi5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWIucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHhoZXgpKTtcblxuICBpZihtbCAhPT0gZmFsc2UpIHtcbiAgICAvLyBsZWdhY3ksIGRlZmF1bHQgdG8gUEtDUyMxIHYxLjUgcGFkZGluZ1xuICAgIHJldHVybiBfZGVjb2RlUGtjczFfdjFfNShlYi5nZXRCeXRlcygpLCBrZXksIHB1Yik7XG4gIH1cblxuICAvLyByZXR1cm4gbWVzc2FnZVxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSU0Ega2V5LXBhaXIgZ2VuZXJhdGlvbiBzdGF0ZSBvYmplY3QuIEl0IGlzIHVzZWQgdG8gYWxsb3dcbiAqIGtleS1nZW5lcmF0aW9uIHRvIGJlIHBlcmZvcm1lZCBpbiBzdGVwcy4gSXQgYWxzbyBhbGxvd3MgZm9yIGEgVUkgdG9cbiAqIGRpc3BsYXkgcHJvZ3Jlc3MgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgc2l6ZSBmb3IgdGhlIHByaXZhdGUga2V5IGluIGJpdHMsIGRlZmF1bHRzIHRvIDIwNDguXG4gKiBAcGFyYW0gZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcgKDB4MTAwMDEpLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdGF0ZSBvYmplY3QgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBrZXktcGFpci5cbiAqL1xucGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlID0gZnVuY3Rpb24oYml0cywgZSwgb3B0aW9ucykge1xuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG5cbiAgLy8gc2V0IGRlZmF1bHQgYml0c1xuICBpZih0eXBlb2YoYml0cykgPT09ICdzdHJpbmcnKSB7XG4gICAgYml0cyA9IHBhcnNlSW50KGJpdHMsIDEwKTtcbiAgfVxuICBiaXRzID0gYml0cyB8fCAyMDQ4O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBwcm5nID0gb3B0aW9ucy5wcm5nIHx8IGZvcmdlLnJhbmRvbTtcbiAgdmFyIHJuZyA9IHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGIgPSBwcm5nLmdldEJ5dGVzU3luYyh4Lmxlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4W2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcblxuICAvLyBjcmVhdGUgUFJJTUVJTkMgYWxnb3JpdGhtIHN0YXRlXG4gIHZhciBydmFsO1xuICBpZihhbGdvcml0aG0gPT09ICdQUklNRUlOQycpIHtcbiAgICBydmFsID0ge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBzdGF0ZTogMCxcbiAgICAgIGJpdHM6IGJpdHMsXG4gICAgICBybmc6IHJuZyxcbiAgICAgIGVJbnQ6IGUgfHwgNjU1MzcsXG4gICAgICBlOiBuZXcgQmlnSW50ZWdlcihudWxsKSxcbiAgICAgIHA6IG51bGwsXG4gICAgICBxOiBudWxsLFxuICAgICAgcUJpdHM6IGJpdHMgPj4gMSxcbiAgICAgIHBCaXRzOiBiaXRzIC0gKGJpdHMgPj4gMSksXG4gICAgICBwcVN0YXRlOiAwLFxuICAgICAgbnVtOiBudWxsLFxuICAgICAga2V5czogbnVsbFxuICAgIH07XG4gICAgcnZhbC5lLmZyb21JbnQocnZhbC5lSW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IGdlbmVyYXRpb24gYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBydW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gZm9yIGF0IG1vc3QgbiBzZWNvbmRzXG4gKiAoYXBwcm94aW1hdGVseSkgdXNpbmcgdGhlIGdpdmVuIHN0YXRlLiBXaGVuIGtleS1nZW5lcmF0aW9uIGhhcyBjb21wbGV0ZWQsXG4gKiB0aGUga2V5cyB3aWxsIGJlIHN0b3JlZCBpbiBzdGF0ZS5rZXlzLlxuICpcbiAqIFRvIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIHVwZGF0ZSBhIFVJIHdoaWxlIGdlbmVyYXRpbmcgYSBrZXkgb3IgdG8gcHJldmVudFxuICogY2F1c2luZyBicm93c2VyIGxvY2t1cHMvd2FybmluZ3MsIHNldCBcIm5cIiB0byBhIHZhbHVlIG90aGVyIHRoYW4gMC4gQVxuICogc2ltcGxlIHBhdHRlcm4gZm9yIGdlbmVyYXRpbmcgYSBrZXkgYW5kIHNob3dpbmcgYSBwcm9ncmVzcyBpbmRpY2F0b3IgaXM6XG4gKlxuICogdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKDIwNDgpO1xuICogdmFyIHN0ZXAgPSBmdW5jdGlvbigpIHtcbiAqICAgLy8gc3RlcCBrZXktZ2VuZXJhdGlvbiwgcnVuIGFsZ29yaXRobSBmb3IgMTAwIG1zLCByZXBlYXRcbiAqICAgaWYoIWZvcmdlLnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUoc3RhdGUsIDEwMCkpIHtcbiAqICAgICBzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuICogICB9IGVsc2Uge1xuICogICAgIC8vIGtleS1nZW5lcmF0aW9uIGNvbXBsZXRlXG4gKiAgICAgLy8gVE9ETzogdHVybiBvZmYgcHJvZ3Jlc3MgaW5kaWNhdG9yIGhlcmVcbiAqICAgICAvLyBUT0RPOiB1c2UgdGhlIGdlbmVyYXRlZCBrZXktcGFpciBpbiBcInN0YXRlLmtleXNcIlxuICogICB9XG4gKiB9O1xuICogLy8gVE9ETzogdHVybiBvbiBwcm9ncmVzcyBpbmRpY2F0b3IgaGVyZVxuICogc2V0VGltZW91dChzdGVwLCAwKTtcbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIHVzZS5cbiAqIEBwYXJhbSBuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gcnVuIHRoZSBhbGdvcml0aG0gZm9yLCAwXG4gKiAgICAgICAgICB0byBydW4gdGhlIGFsZ29yaXRobSB0byBjb21wbGV0aW9uLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUga2V5LWdlbmVyYXRpb24gY29tcGxldGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbikge1xuICAvLyBzZXQgZGVmYXVsdCBhbGdvcml0aG0gaWYgbm90IHNldFxuICBpZighKCdhbGdvcml0aG0nIGluIHN0YXRlKSkge1xuICAgIHN0YXRlLmFsZ29yaXRobSA9ICdQUklNRUlOQyc7XG4gIH1cblxuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG4gIC8vIFRPRE86IGFic3RyYWN0IGFzIFBSSU1FSU5DIGFsZ29yaXRobVxuXG4gIC8vIGRvIGtleSBnZW5lcmF0aW9uIChiYXNlZCBvbiBUb20gV3UncyByc2EuanMsIHNlZSBqc2JuLmpzIGxpY2Vuc2UpXG4gIC8vIHdpdGggc29tZSBtaW5vciBvcHRpbWl6YXRpb25zIGFuZCBkZXNpZ25lZCB0byBydW4gaW4gc3RlcHNcblxuICAvLyBsb2NhbCBzdGF0ZSB2YXJzXG4gIHZhciBUSElSVFkgPSBuZXcgQmlnSW50ZWdlcihudWxsKTtcbiAgVEhJUlRZLmZyb21JbnQoMzApO1xuICB2YXIgZGVsdGFJZHggPSAwO1xuICB2YXIgb3Bfb3IgPSBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4fHk7IH07XG5cbiAgLy8ga2VlcCBzdGVwcGluZyB1bnRpbCB0aW1lIGxpbWl0IGlzIHJlYWNoZWQgb3IgZG9uZVxuICB2YXIgdDEgPSArbmV3IERhdGUoKTtcbiAgdmFyIHQyO1xuICB2YXIgdG90YWwgPSAwO1xuICB3aGlsZShzdGF0ZS5rZXlzID09PSBudWxsICYmIChuIDw9IDAgfHwgdG90YWwgPCBuKSkge1xuICAgIC8vIGdlbmVyYXRlIHAgb3IgcVxuICAgIGlmKHN0YXRlLnN0YXRlID09PSAwKSB7XG4gICAgICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybTpcblxuICAgICAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xLCB3aGVyZSB0aGVyZSBhcmUgOCB2YWx1ZXMgZm9yIGlcblxuICAgICAgICBXaGVuIHdlIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciwgd2UgYWx3YXlzIGFsaWduIGl0IGF0IDMwayArIDEuIEVhY2hcbiAgICAgICAgdGltZSB0aGUgbnVtYmVyIGlzIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlXG4gICAgICAgIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlciB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgICAgIHZhciBiaXRzID0gKHN0YXRlLnAgPT09IG51bGwpID8gc3RhdGUucEJpdHMgOiBzdGF0ZS5xQml0cztcbiAgICAgIHZhciBiaXRzMSA9IGJpdHMgLSAxO1xuXG4gICAgICAvLyBnZXQgYSByYW5kb20gbnVtYmVyXG4gICAgICBpZihzdGF0ZS5wcVN0YXRlID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHN0YXRlLnJuZyk7XG4gICAgICAgIC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgaWYoIXN0YXRlLm51bS50ZXN0Qml0KGJpdHMxKSkge1xuICAgICAgICAgIHN0YXRlLm51bS5iaXR3aXNlVG8oXG4gICAgICAgICAgICBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYml0czEpLCBvcF9vciwgc3RhdGUubnVtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGlnbiBudW1iZXIgb24gMzBrKzEgYm91bmRhcnlcbiAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoMzEgLSBzdGF0ZS5udW0ubW9kKFRISVJUWSkuYnl0ZVZhbHVlKCksIDApO1xuICAgICAgICBkZWx0YUlkeCA9IDA7XG5cbiAgICAgICAgKytzdGF0ZS5wcVN0YXRlO1xuICAgICAgfSBlbHNlIGlmKHN0YXRlLnBxU3RhdGUgPT09IDEpIHtcbiAgICAgICAgLy8gdHJ5IHRvIG1ha2UgdGhlIG51bWJlciBhIHByaW1lXG4gICAgICAgIGlmKHN0YXRlLm51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgICAgICAvLyBvdmVyZmxvdywgdHJ5IGFnYWluXG4gICAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgICAgLy8gZG8gcHJpbWFsaXR5IHRlc3RcbiAgICAgICAgfSBlbHNlIGlmKHN0YXRlLm51bS5pc1Byb2JhYmxlUHJpbWUoXG4gICAgICAgICAgX2dldE1pbGxlclJhYmluVGVzdHMoc3RhdGUubnVtLmJpdExlbmd0aCgpKSkpIHtcbiAgICAgICAgICArK3N0YXRlLnBxU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0IG5leHQgcG90ZW50aWFsIHByaW1lXG4gICAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoR0NEXzMwX0RFTFRBW2RlbHRhSWR4KysgJSA4XSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5wcVN0YXRlID09PSAyKSB7XG4gICAgICAgIC8vIGVuc3VyZSBudW1iZXIgaXMgY29wcmltZSB3aXRoIGVcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9XG4gICAgICAgICAgKHN0YXRlLm51bS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAgICAgLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT09IDApID8gMyA6IDA7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMykge1xuICAgICAgICAvLyBzdG9yZSBwIG9yIHFcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgIGlmKHN0YXRlLnAgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5wID0gc3RhdGUubnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIHN0YXRlIGlmIGJvdGggcCBhbmQgcSBhcmUgcmVhZHlcbiAgICAgICAgaWYoc3RhdGUucCAhPT0gbnVsbCAmJiBzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5udW0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gMSkge1xuICAgICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBzdGF0ZS5wO1xuICAgICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgICAgc3RhdGUucSA9IHN0YXRlLm51bTtcbiAgICAgIH1cbiAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSAyKSB7XG4gICAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICBzdGF0ZS5xMSA9IHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIGVuc3VyZSBlIGFuZCBwaGkgYXJlIGNvcHJpbWVcbiAgICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PT0gMCkge1xuICAgICAgICAvLyBwaGkgYW5kIGUgYXJlIGNvcHJpbWUsIGFkdmFuY2VcbiAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBoaSBhbmQgZSBhcmVuJ3QgY29wcmltZSwgc28gZ2VuZXJhdGUgYSBuZXcgcCBhbmQgcVxuICAgICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDQpIHtcbiAgICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcblxuICAgICAgLy8gZW5zdXJlIG4gaXMgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICAgIGlmKHN0YXRlLm4uYml0TGVuZ3RoKCkgPT09IHN0YXRlLmJpdHMpIHtcbiAgICAgICAgLy8gc3VjY2VzcywgYWR2YW5jZVxuICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDUpIHtcbiAgICAgIC8vIHNldCBrZXlzXG4gICAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgICAgc3RhdGUua2V5cyA9IHtcbiAgICAgICAgcHJpdmF0ZUtleTogcGtpLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgICAgc3RhdGUucS5tb2RJbnZlcnNlKHN0YXRlLnApKSxcbiAgICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGltaW5nXG4gICAgdDIgPSArbmV3IERhdGUoKTtcbiAgICB0b3RhbCArPSB0MiAtIHQxO1xuICAgIHQxID0gdDI7XG4gIH1cblxuICByZXR1cm4gc3RhdGUua2V5cyAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIFJTQSBwdWJsaWMtcHJpdmF0ZSBrZXkgcGFpciBpbiBhIHNpbmdsZSBjYWxsLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgaW4gc3RlcHMgKHRvIGFsbG93IGZvciBwcm9ncmVzcyB1cGRhdGVzIGFuZCB0b1xuICogcHJldmVudCBibG9ja2luZyBvciB3YXJuaW5ncyBpbiBzbG93IGJyb3dzZXJzKSB0aGVuIHVzZSB0aGUga2V5LXBhaXJcbiAqIGdlbmVyYXRpb24gc3RhdGUgZnVuY3Rpb25zLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgYXN5bmNocm9ub3VzbHkgKGVpdGhlciB0aHJvdWdoIHdlYi13b3JrZXJzLCBpZlxuICogYXZhaWxhYmxlLCBvciBieSBicmVha2luZyB1cCB0aGUgd29yayBvbiB0aGUgbWFpbiB0aHJlYWQpLCBwYXNzIGFcbiAqIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBbYml0c10gdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIFtlXSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb24sIGlmIGdpdmVuIHRoZW4gJ2JpdHMnXG4gKiAgICAgICAgICBhbmQgJ2UnIG11c3QgKm5vdCogYmUgZ2l2ZW46XG4gKiAgICAgICAgICBiaXRzIHRoZSBzaXplIGZvciB0aGUgcHJpdmF0ZSBrZXkgaW4gYml0cywgKGRlZmF1bHQ6IDIwNDgpLlxuICogICAgICAgICAgZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgKGRlZmF1bHQ6IDY1NTM3ICgweDEwMDAxKSkuXG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIpLlxuICogICAgICAgICAgd29ya0xvYWQgdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgICAgICBudW1iZXJzIGZvciBlYWNoIHdlYiB3b3JrZXIgdG8gY2hlY2sgcGVyIHdvcmsgYXNzaWdubWVudCxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXlwYWlyKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKlxuICogQHJldHVybiBhbiBvYmplY3Qgd2l0aCBwcml2YXRlS2V5IGFuZCBwdWJsaWNLZXkgcHJvcGVydGllcy5cbiAqL1xucGtpLnJzYS5nZW5lcmF0ZUtleVBhaXIgPSBmdW5jdGlvbihiaXRzLCBlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyAoYml0cyksIChvcHRpb25zKSwgKGNhbGxiYWNrKVxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYodHlwZW9mIGJpdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0gYml0cztcbiAgICAgIGJpdHMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBiaXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGJpdHM7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyAoYml0cywgZSksIChiaXRzLCBvcHRpb25zKSwgKGJpdHMsIGNhbGxiYWNrKSwgKG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIGlmKHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgaWYodHlwZW9mIGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBlO1xuICAgICAgICBlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmKHR5cGVvZiBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICBvcHRpb25zID0gZTtcbiAgICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGJpdHM7XG4gICAgICBjYWxsYmFjayA9IGU7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgLy8gKGJpdHMsIGUsIG9wdGlvbnMpLCAoYml0cywgZSwgY2FsbGJhY2spLCAoYml0cywgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgaWYodHlwZW9mIGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBlO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKGJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGJpdHMgPSBvcHRpb25zLmJpdHMgfHwgMjA0ODtcbiAgfVxuICBpZihlID09PSB1bmRlZmluZWQpIHtcbiAgICBlID0gb3B0aW9ucy5lIHx8IDB4MTAwMDE7XG4gIH1cblxuICAvLyBpZiBuYXRpdmUgY29kZSBpcyBwZXJtaXR0ZWQgYW5kIGEgY2FsbGJhY2sgaXMgZ2l2ZW4sIHVzZSBuYXRpdmVcbiAgLy8ga2V5IGdlbmVyYXRpb24gY29kZSBpZiBhdmFpbGFibGUgYW5kIGlmIHBhcmFtZXRlcnMgYXJlIGFjY2VwdGFibGVcbiAgaWYoIWZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQgJiYgY2FsbGJhY2sgJiZcbiAgICBiaXRzID49IDI1NiAmJiBiaXRzIDw9IDE2Mzg0ICYmIChlID09PSAweDEwMDAxIHx8IGUgPT09IDMpKSB7XG4gICAgaWYoX2RldGVjdFN1YnRsZUNyeXB0bygnZ2VuZXJhdGVLZXknKSAmJiBfZGV0ZWN0U3VidGxlQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgLy8gdXNlIHN0YW5kYXJkIG5hdGl2ZSBnZW5lcmF0ZUtleVxuICAgICAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgcHVibGljRXhwb25lbnQ6IF9pbnRUb1VpbnQ4QXJyYXkoZSksXG4gICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9XG4gICAgICB9LCB0cnVlIC8qIGtleSBjYW4gYmUgZXhwb3J0ZWQqLywgWydzaWduJywgJ3ZlcmlmeSddKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocGFpcikge1xuICAgICAgICByZXR1cm4gd2luZG93LmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdwa2NzOCcsIHBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAvLyBhdm9pZGluZyBjYXRjaChmdW5jdGlvbihlcnIpIHsuLi59KSB0byBzdXBwb3J0IElFIDw9IDhcbiAgICAgIH0pLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocGtjczgpIHtcbiAgICAgICAgaWYocGtjczgpIHtcbiAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoXG4gICAgICAgICAgICBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGtjczgpKSk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGtpLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmKF9kZXRlY3RTdWJ0bGVNc0NyeXB0bygnZ2VuZXJhdGVLZXknKSAmJlxuICAgICAgX2RldGVjdFN1YnRsZU1zQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgdmFyIGdlbk9wID0gd2luZG93Lm1zQ3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgIHB1YmxpY0V4cG9uZW50OiBfaW50VG9VaW50OEFycmF5KGUpLFxuICAgICAgICBoYXNoOiB7bmFtZTogJ1NIQS0yNTYnfVxuICAgICAgfSwgdHJ1ZSAvKiBrZXkgY2FuIGJlIGV4cG9ydGVkKi8sIFsnc2lnbicsICd2ZXJpZnknXSk7XG4gICAgICBnZW5PcC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgcGFpciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgdmFyIGV4cG9ydE9wID0gd2luZG93Lm1zQ3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXG4gICAgICAgICAgJ3BrY3M4JywgcGFpci5wcml2YXRlS2V5KTtcbiAgICAgICAgZXhwb3J0T3Aub25jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgcGtjczggPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKFxuICAgICAgICAgICAgYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHBrY3M4KSkpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBraS5zZXRSc2FQdWJsaWNLZXkocHJpdmF0ZUtleS5uLCBwcml2YXRlS2V5LmUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGV4cG9ydE9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGdlbk9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25cbiAgdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKGJpdHMsIGUsIG9wdGlvbnMpO1xuICBpZighY2FsbGJhY2spIHtcbiAgICBwa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlKHN0YXRlLCAwKTtcbiAgICByZXR1cm4gc3RhdGUua2V5cztcbiAgfVxuICBfZ2VuZXJhdGVLZXlQYWlyKHN0YXRlLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gUlNBIHB1YmxpYyBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzIGFuZCBleHBvbmVudC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbW9kdWx1cy5cbiAqIEBwYXJhbSBlIHRoZSBleHBvbmVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kuc2V0UnNhUHVibGljS2V5ID0gcGtpLnJzYS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbihuLCBlKSB7XG4gIHZhciBrZXkgPSB7XG4gICAgbjogbixcbiAgICBlOiBlXG4gIH07XG5cbiAgLyoqXG4gICAqIEVuY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwdWJsaWMga2V5LiBOZXdlciBhcHBsaWNhdGlvbnNcbiAgICogc2hvdWxkIHVzZSB0aGUgJ1JTQS1PQUVQJyBkZWNyeXB0aW9uIHNjaGVtZSwgJ1JTQUVTLVBLQ1MxLVYxXzUnIGlzIGZvclxuICAgKiBsZWdhY3kgYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgYnl0ZSBzdHJpbmcgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgZW5jcnlwdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBRVMtUEtDUzEtVjFfNScgKGRlZmF1bHQpLFxuICAgKiAgICAgICAgICAnUlNBLU9BRVAnLFxuICAgKiAgICAgICAgICAnUkFXJywgJ05PTkUnLCBvciBudWxsIHRvIHBlcmZvcm0gcmF3IFJTQSBlbmNyeXB0aW9uLFxuICAgKiAgICAgICAgICBhbiBvYmplY3Qgd2l0aCBhbiAnZW5jb2RlJyBwcm9wZXJ0eSBzZXQgdG8gYSBmdW5jdGlvblxuICAgKiAgICAgICAgICB3aXRoIHRoZSBzaWduYXR1cmUgJ2Z1bmN0aW9uKGRhdGEsIGtleSknIHRoYXQgcmV0dXJuc1xuICAgKiAgICAgICAgICBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVuY29kZWQgZGF0YS5cbiAgICogQHBhcmFtIHNjaGVtZU9wdGlvbnMgYW55IHNjaGVtZS1zcGVjaWZpYyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBlbmNyeXB0ZWQgYnl0ZSBzdHJpbmcuXG4gICAqL1xuICBrZXkuZW5jcnlwdCA9IGZ1bmN0aW9uKGRhdGEsIHNjaGVtZSwgc2NoZW1lT3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjaGVtZSA9ICdSU0FFUy1QS0NTMS1WMV81JztcbiAgICB9XG5cbiAgICBpZihzY2hlbWUgPT09ICdSU0FFUy1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uKG0sIGtleSwgcHViKSB7XG4gICAgICAgICAgcmV0dXJuIF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgMHgwMikuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24obSwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmVuY29kZV9yc2Ffb2FlcChrZXksIG0sIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7IGVuY29kZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gZTsgfSB9O1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRvIHNjaGVtZS1iYXNlZCBlbmNvZGluZyB0aGVuIHJzYSBlbmNyeXB0aW9uXG4gICAgdmFyIGUgPSBzY2hlbWUuZW5jb2RlKGRhdGEsIGtleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChlLCBrZXksIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFnYWluc3QgdGhlIGdpdmVuIGRpZ2VzdC5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSwgaW4gd2hpY2ggY2FzZSBvbmNlIFJTQS1kZWNyeXB0ZWQsIHRoZVxuICAgKiBzaWduYXR1cmUgaXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaG9sZHMgYSBEaWdlc3RJbmZvLlxuICAgKlxuICAgKiBEaWdlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gICAqICAgZGlnZXN0IERpZ2VzdFxuICAgKiB9XG4gICAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAgICpcbiAgICogVG8gcGVyZm9ybSBQU1Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiwgcHJvdmlkZSBhbiBpbnN0YW5jZVxuICAgKiBvZiBGb3JnZSBQU1Mgb2JqZWN0IGFzIHRoZSBzY2hlbWUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gZGlnZXN0IHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLFxuICAgKiAgICAgICAgICBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBzY2hlbWUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBU1NBLVBLQ1MxLVYxXzUnIG9yIHVuZGVmaW5lZCBmb3IgUlNBU1NBIFBLQ1MjMSB2MS41LFxuICAgKiAgICAgICAgICBhIEZvcmdlIFBTUyBvYmplY3QgZm9yIFJTQVNTQS1QU1MsXG4gICAqICAgICAgICAgICdOT05FJyBvciBudWxsIGZvciBub25lLCBEaWdlc3RJbmZvIHdpbGwgbm90IGJlIGV4cGVjdGVkLCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICAga2V5LnZlcmlmeSA9IGZ1bmN0aW9uKGRpZ2VzdCwgc2lnbmF0dXJlLCBzY2hlbWUpIHtcbiAgICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgc2NoZW1lID0gJ1JTQVNTQS1QS0NTMS1WMV81JztcbiAgICAgfVxuXG4gICAgIGlmKHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgIC8vIHJlbW92ZSBwYWRkaW5nXG4gICAgICAgICAgIGQgPSBfZGVjb2RlUGtjczFfdjFfNShkLCBrZXksIHRydWUpO1xuICAgICAgICAgICAvLyBkIGlzIEFTTi4xIEJFUi1lbmNvZGVkIERpZ2VzdEluZm9cbiAgICAgICAgICAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihkKTtcbiAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgZ2l2ZW4gZGlnZXN0IHRvIHRoZSBkZWNyeXB0ZWQgb25lXG4gICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IG9iai52YWx1ZVsxXS52YWx1ZTtcbiAgICAgICAgIH1cbiAgICAgICB9O1xuICAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnTk9ORScgfHwgc2NoZW1lID09PSAnTlVMTCcgfHwgc2NoZW1lID09PSBudWxsKSB7XG4gICAgICAgc2NoZW1lID0ge1xuICAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbihkaWdlc3QsIGQpIHtcbiAgICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICAgZCA9IF9kZWNvZGVQa2NzMV92MV81KGQsIGtleSwgdHJ1ZSk7XG4gICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IGQ7XG4gICAgICAgICB9XG4gICAgICAgfTtcbiAgICAgfVxuXG4gICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmcsIHRoZW4gdmVyaWZ5IC0tIHdoaWNoIGRvZXMgZGVjb2RpbmdcbiAgICAgdmFyIGQgPSBwa2kucnNhLmRlY3J5cHQoc2lnbmF0dXJlLCBrZXksIHRydWUsIGZhbHNlKTtcbiAgICAgcmV0dXJuIHNjaGVtZS52ZXJpZnkoZGlnZXN0LCBkLCBrZXkubi5iaXRMZW5ndGgoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBSU0EgcHJpdmF0ZSBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzLCBleHBvbmVudCwgcHJpbWVzLFxuICogcHJpbWUgZXhwb25lbnRzLCBhbmQgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBtb2R1bHVzLlxuICogQHBhcmFtIGUgdGhlIHB1YmxpYyBleHBvbmVudC5cbiAqIEBwYXJhbSBkIHRoZSBwcml2YXRlIGV4cG9uZW50ICgoaW52ZXJzZSBvZiBlKSBtb2QgbikuXG4gKiBAcGFyYW0gcCB0aGUgZmlyc3QgcHJpbWUuXG4gKiBAcGFyYW0gcSB0aGUgc2Vjb25kIHByaW1lLlxuICogQHBhcmFtIGRQIGV4cG9uZW50MSAoZCBtb2QgKHAtMSkpLlxuICogQHBhcmFtIGRRIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpLlxuICogQHBhcmFtIHFJbnYgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kuc2V0UnNhUHJpdmF0ZUtleSA9IHBraS5yc2Euc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uKFxuICBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnYpIHtcbiAgdmFyIGtleSA9IHtcbiAgICBuOiBuLFxuICAgIGU6IGUsXG4gICAgZDogZCxcbiAgICBwOiBwLFxuICAgIHE6IHEsXG4gICAgZFA6IGRQLFxuICAgIGRROiBkUSxcbiAgICBxSW52OiBxSW52XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwcml2YXRlIGtleS4gVGhlIGRlY3J5cHRpb24gc2NoZW1lXG4gICAqIG11c3QgbWF0Y2ggdGhlIG9uZSB1c2VkIHRvIGVuY3J5cHQgdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBieXRlIHN0cmluZyB0byBkZWNyeXB0LlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBkZWNyeXB0aW9uIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FFUy1QS0NTMS1WMV81JyAoZGVmYXVsdCksXG4gICAqICAgICAgICAgICdSU0EtT0FFUCcsXG4gICAqICAgICAgICAgICdSQVcnLCAnTk9ORScsIG9yIG51bGwgdG8gcGVyZm9ybSByYXcgUlNBIGRlY3J5cHRpb24uXG4gICAqIEBwYXJhbSBzY2hlbWVPcHRpb25zIGFueSBzY2hlbWUtc3BlY2lmaWMgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZGVjcnlwdGVkIGJ5dGUgc3RyaW5nLlxuICAgKi9cbiAga2V5LmRlY3J5cHQgPSBmdW5jdGlvbihkYXRhLCBzY2hlbWUsIHNjaGVtZU9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2hlbWUgPSAnUlNBRVMtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgLy8gZG8gcnNhIGRlY3J5cHRpb24gdy9vIGFueSBkZWNvZGluZ1xuICAgIHZhciBkID0gcGtpLnJzYS5kZWNyeXB0KGRhdGEsIGtleSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIGlmKHNjaGVtZSA9PT0gJ1JTQUVTLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7IGRlY29kZTogX2RlY29kZVBrY3MxX3YxXzUgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24oZCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmRlY29kZV9yc2Ffb2FlcChrZXksIGQsIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7IGRlY29kZTogZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lOiBcIicgKyBzY2hlbWUgKyAnXCIuJyk7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIGFjY29yZGluZyB0byBzY2hlbWVcbiAgICByZXR1cm4gc2NoZW1lLmRlY29kZShkLCBrZXksIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhlIGdpdmVuIGRpZ2VzdCwgcHJvZHVjaW5nIGEgc2lnbmF0dXJlLlxuICAgKlxuICAgKiBQS0NTIzEgc3VwcG9ydHMgbXVsdGlwbGUgKGN1cnJlbnRseSB0d28pIHNpZ25hdHVyZSBzY2hlbWVzOlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSBhbmQgUlNBU1NBLVBTUy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIFwib2xkIHNjaGVtZVwiLCBpLmUuXG4gICAqIFJTQVNTQS1QS0NTMS1WMV81LiBJbiBvcmRlciB0byBnZW5lcmF0ZSBhIFBTUyBzaWduYXR1cmUsIHByb3ZpZGVcbiAgICogYW4gaW5zdGFuY2Ugb2YgRm9yZ2UgUFNTIG9iamVjdCBhcyB0aGUgc2NoZW1lIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBzaWduYXR1cmUgc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQVNTQS1QS0NTMS1WMV81JyBvciB1bmRlZmluZWQgZm9yIFJTQVNTQSBQS0NTIzEgdjEuNSxcbiAgICogICAgICAgICAgYSBGb3JnZSBQU1Mgb2JqZWN0IGZvciBSU0FTU0EtUFNTLFxuICAgKiAgICAgICAgICAnTk9ORScgb3IgbnVsbCBmb3Igbm9uZSwgRGlnZXN0SW5mbyB3aWxsIG5vdCBiZSB1c2VkIGJ1dFxuICAgKiAgICAgICAgICAgIFBLQ1MjMSB2MS41IHBhZGRpbmcgd2lsbCBzdGlsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBzaWduYXR1cmUgYXMgYSBieXRlIHN0cmluZy5cbiAgICovXG4gIGtleS5zaWduID0gZnVuY3Rpb24obWQsIHNjaGVtZSkge1xuICAgIC8qIE5vdGU6IFRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBSU0Egb3BlcmF0aW9ucyBpcyBiZWluZ1xuICAgICAgdHJhbnNpdGlvbmVkIGF3YXkgZnJvbSBhIFBLQ1MjMSB2MS41IGhhcmQtY29kZWQgc2NoZW1lLiBTb21lIGxlZ2FjeVxuICAgICAgY29kZSBsaWtlIHRoZSB1c2Ugb2YgYW4gZW5jb2RpbmcgYmxvY2sgaWRlbnRpZmllciAnYnQnIHdpbGwgZXZlbnR1YWxseVxuICAgICAgYmUgcmVtb3ZlZC4gKi9cblxuICAgIC8vIHByaXZhdGUga2V5IG9wZXJhdGlvblxuICAgIHZhciBidCA9IGZhbHNlO1xuXG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkIHx8IHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0geyBlbmNvZGU6IGVtc2FQa2NzMXYxNWVuY29kZSB9O1xuICAgICAgYnQgPSAweDAxO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdOT05FJyB8fCBzY2hlbWUgPT09ICdOVUxMJyB8fCBzY2hlbWUgPT09IG51bGwpIHtcbiAgICAgIHNjaGVtZSA9IHsgZW5jb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIG1kOyB9IH07XG4gICAgICBidCA9IDB4MDE7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIGFuZCB0aGVuIGVuY3J5cHRcbiAgICB2YXIgZCA9IHNjaGVtZS5lbmNvZGUobWQsIGtleS5uLmJpdExlbmd0aCgpKTtcbiAgICByZXR1cm4gcGtpLnJzYS5lbmNyeXB0KGQsIGtleSwgYnQpO1xuICB9O1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFdyYXBzIGFuIFJTQVByaXZhdGVLZXkgQVNOLjEgb2JqZWN0IGluIGFuIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kud3JhcFJzYVByaXZhdGVLZXkgPSBmdW5jdGlvbihyc2FLZXkpIHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uICgwKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcigwKS5nZXRCeXRlcygpKSxcbiAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgIF0pLFxuICAgIC8vIFByaXZhdGVLZXlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgIGFzbjEudG9EZXIocnNhS2V5KS5nZXRCeXRlcygpKVxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByaXZhdGUga2V5IGZyb20gYW4gQVNOLjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGEgUHJpdmF0ZUtleUluZm8gY29udGFpbmluZyBhblxuICogICAgICAgICAgUlNBUHJpdmF0ZUtleSBvciBhbiBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUZyb21Bc24xID0gZnVuY3Rpb24ob2JqKSB7XG4gIC8vIGdldCBQcml2YXRlS2V5SW5mb1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKGFzbjEudmFsaWRhdGUob2JqLCBwcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgb2JqID0gYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleSkpO1xuICB9XG5cbiAgLy8gZ2V0IFJTQVByaXZhdGVLZXlcbiAgY2FwdHVyZSA9IHt9O1xuICBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2FQcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYW4gUlNBUHJpdmF0ZUtleS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBOb3RlOiBWZXJzaW9uIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuICAvLyBjYXB0dXJlLnByaXZhdGVLZXlWZXJzaW9uXG4gIC8vIEZJWE1FOiBpbmVmZmljaWVudCwgZ2V0IGEgQmlnSW50ZWdlciB0aGF0IHVzZXMgYnl0ZSBzdHJpbmdzXG4gIHZhciBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnY7XG4gIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlNb2R1bHVzKS50b0hleCgpO1xuICBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5UHVibGljRXhwb25lbnQpLnRvSGV4KCk7XG4gIGQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcml2YXRlRXhwb25lbnQpLnRvSGV4KCk7XG4gIHAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTEpLnRvSGV4KCk7XG4gIHEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTIpLnRvSGV4KCk7XG4gIGRQID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5RXhwb25lbnQxKS50b0hleCgpO1xuICBkUSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUV4cG9uZW50MikudG9IZXgoKTtcbiAgcUludiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUNvZWZmaWNpZW50KS50b0hleCgpO1xuXG4gIC8vIHNldCBwcml2YXRlIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVByaXZhdGVLZXkoXG4gICAgbmV3IEJpZ0ludGVnZXIobiwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGUsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKHEsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkUCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGRRLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocUludiwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwcml2YXRlIGtleSB0byBhbiBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGFuIFJTQVByaXZhdGVLZXkuXG4gKi9cbnBraS5wcml2YXRlS2V5VG9Bc24xID0gcGtpLnByaXZhdGVLZXlUb1JTQVByaXZhdGVLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gUlNBUHJpdmF0ZUtleVxuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIHZlcnNpb24gKDAgPSBvbmx5IDIgcHJpbWVzLCAxIG11bHRpcGxlIHByaW1lcylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkubikpLFxuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5lKSksXG4gICAgLy8gcHJpdmF0ZUV4cG9uZW50IChkKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kKSksXG4gICAgLy8gcHJpdmF0ZUtleVByaW1lMSAocClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucCkpLFxuICAgIC8vIHByaXZhdGVLZXlQcmltZTIgKHEpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LnEpKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQxIChkUClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFApKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQyIChkUSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFEpKSxcbiAgICAvLyBjb2VmZmljaWVudCAocUludilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucUludikpXG4gIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgZnJvbSBhbiBBU04uMSBTdWJqZWN0UHVibGljS2V5SW5mbyBvciBSU0FQdWJsaWNLZXkuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvIG9yIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgLy8gZ2V0IFN1YmplY3RQdWJsaWNLZXlJbmZvXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoYXNuMS52YWxpZGF0ZShvYmosIHB1YmxpY0tleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIC8vIGdldCBvaWRcbiAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gICAgaWYob2lkICE9PSBwa2kub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIFVua25vd24gT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIG9iaiA9IGNhcHR1cmUucnNhUHVibGljS2V5O1xuICB9XG5cbiAgLy8gZ2V0IFJTQSBwYXJhbXNcbiAgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgcnNhUHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQdWJsaWNLZXkuJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gRklYTUU6IGluZWZmaWNpZW50LCBnZXQgYSBCaWdJbnRlZ2VyIHRoYXQgdXNlcyBieXRlIHN0cmluZ3NcbiAgdmFyIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnB1YmxpY0tleU1vZHVsdXMpLnRvSGV4KCk7XG4gIHZhciBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wdWJsaWNLZXlFeHBvbmVudCkudG9IZXgoKTtcblxuICAvLyBzZXQgcHVibGljIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVB1YmxpY0tleShcbiAgICBuZXcgQmlnSW50ZWdlcihuLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZSwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICovXG5wa2kucHVibGljS2V5VG9Bc24xID0gcGtpLnB1YmxpY0tleVRvU3ViamVjdFB1YmxpY0tleUluZm8gPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMucnNhRW5jcnlwdGlvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgXSksXG4gICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgW1xuICAgICAgcGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSlcbiAgICBdKVxuICBdKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBSU0FQdWJsaWNLZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1JTQVB1YmxpY0tleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5uKSksXG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmUpKVxuICBdKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gbSB0aGUgbWVzc2FnZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBidCB0aGUgYmxvY2sgdHlwZSB0byB1c2UsIGkuZS4gZWl0aGVyIDB4MDEgKGZvciBzaWduaW5nKSBvciAweDAyXG4gKiAgICAgICAgICAoZm9yIGVuY3J5cHRpb24pLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhZGRlZCBieXRlIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCkge1xuICB2YXIgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgKi9cbiAgaWYobS5sZW5ndGggPiAoayAtIDExKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyBmb3IgUEtDUyMxIHYxLjUgcGFkZGluZy4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBtLmxlbmd0aDtcbiAgICBlcnJvci5tYXggPSBrIC0gMTE7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvKiBBIGJsb2NrIHR5cGUgQlQsIGEgcGFkZGluZyBzdHJpbmcgUFMsIGFuZCB0aGUgZGF0YSBEIHNoYWxsIGJlXG4gICAgZm9ybWF0dGVkIGludG8gYW4gb2N0ZXQgc3RyaW5nIEVCLCB0aGUgZW5jcnlwdGlvbiBibG9jazpcblxuICAgIEVCID0gMDAgfHwgQlQgfHwgUFMgfHwgMDAgfHwgRFxuXG4gICAgVGhlIGJsb2NrIHR5cGUgQlQgc2hhbGwgYmUgYSBzaW5nbGUgb2N0ZXQgaW5kaWNhdGluZyB0aGUgc3RydWN0dXJlIG9mXG4gICAgdGhlIGVuY3J5cHRpb24gYmxvY2suIEZvciB0aGlzIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50IGl0IHNoYWxsIGhhdmVcbiAgICB2YWx1ZSAwMCwgMDEsIG9yIDAyLiBGb3IgYSBwcml2YXRlLWtleSBvcGVyYXRpb24sIHRoZSBibG9jayB0eXBlXG4gICAgc2hhbGwgYmUgMDAgb3IgMDEuIEZvciBhIHB1YmxpYy1rZXkgb3BlcmF0aW9uLCBpdCBzaGFsbCBiZSAwMi5cblxuICAgIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBzaGFsbCBjb25zaXN0IG9mIGstMy18fER8fCBvY3RldHMuIEZvciBibG9ja1xuICAgIHR5cGUgMDAsIHRoZSBvY3RldHMgc2hhbGwgaGF2ZSB2YWx1ZSAwMDsgZm9yIGJsb2NrIHR5cGUgMDEsIHRoZXlcbiAgICBzaGFsbCBoYXZlIHZhbHVlIEZGOyBhbmQgZm9yIGJsb2NrIHR5cGUgMDIsIHRoZXkgc2hhbGwgYmVcbiAgICBwc2V1ZG9yYW5kb21seSBnZW5lcmF0ZWQgYW5kIG5vbnplcm8uIFRoaXMgbWFrZXMgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBlbmNyeXB0aW9uIGJsb2NrIEVCIGVxdWFsIHRvIGsuICovXG5cbiAgLy8gYnVpbGQgdGhlIGVuY3J5cHRpb24gYmxvY2tcbiAgZWIucHV0Qnl0ZSgweDAwKTtcbiAgZWIucHV0Qnl0ZShidCk7XG5cbiAgLy8gY3JlYXRlIHRoZSBwYWRkaW5nXG4gIHZhciBwYWROdW0gPSBrIC0gMyAtIG0ubGVuZ3RoO1xuICB2YXIgcGFkQnl0ZTtcbiAgLy8gcHJpdmF0ZSBrZXkgb3BcbiAgaWYoYnQgPT09IDB4MDAgfHwgYnQgPT09IDB4MDEpIHtcbiAgICBwYWRCeXRlID0gKGJ0ID09PSAweDAwKSA/IDB4MDAgOiAweEZGO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgZWIucHV0Qnl0ZShwYWRCeXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcHVibGljIGtleSBvcFxuICAgIC8vIHBhZCB3aXRoIHJhbmRvbSBub24temVybyB2YWx1ZXNcbiAgICB3aGlsZShwYWROdW0gPiAwKSB7XG4gICAgICB2YXIgbnVtWmVyb3MgPSAwO1xuICAgICAgdmFyIHBhZEJ5dGVzID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKHBhZE51bSk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFkTnVtOyArK2kpIHtcbiAgICAgICAgcGFkQnl0ZSA9IHBhZEJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmKHBhZEJ5dGUgPT09IDApIHtcbiAgICAgICAgICArK251bVplcm9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGViLnB1dEJ5dGUocGFkQnl0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhZE51bSA9IG51bVplcm9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIHplcm8gZm9sbG93ZWQgYnkgbWVzc2FnZVxuICBlYi5wdXRCeXRlKDB4MDApO1xuICBlYi5wdXRCeXRlcyhtKTtcblxuICByZXR1cm4gZWI7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gZW0gdGhlIG1lc3NhZ2UgdG8gZGVjb2RlLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBhIHB1YmxpYyBrZXksIGZhbHNlIGlmIGl0IGlzIHByaXZhdGUuXG4gKiBAcGFyYW0gbWwgdGhlIG1lc3NhZ2UgbGVuZ3RoLCBpZiBzcGVjaWZpZWQuXG4gKlxuICogQHJldHVybiB0aGUgZGVjb2RlZCBieXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZVBrY3MxX3YxXzUoZW0sIGtleSwgcHViLCBtbCkge1xuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIC8qIEl0IGlzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgb2NjdXJzOlxuXG4gICAgMS4gVGhlIGVuY3J5cHRpb24gYmxvY2sgRUIgY2Fubm90IGJlIHBhcnNlZCB1bmFtYmlndW91c2x5LlxuICAgIDIuIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBjb25zaXN0cyBvZiBmZXdlciB0aGFuIGVpZ2h0IG9jdGV0c1xuICAgICAgb3IgaXMgaW5jb25zaXNlbnQgd2l0aCB0aGUgYmxvY2sgdHlwZSBCVC5cbiAgICAzLiBUaGUgZGVjcnlwdGlvbiBwcm9jZXNzIGlzIGEgcHVibGljLWtleSBvcGVyYXRpb24gYW5kIHRoZSBibG9ja1xuICAgICAgdHlwZSBCVCBpcyBub3QgMDAgb3IgMDEsIG9yIHRoZSBkZWNyeXB0aW9uIHByb2Nlc3MgaXMgYVxuICAgICAgcHJpdmF0ZS1rZXkgb3BlcmF0aW9uIGFuZCB0aGUgYmxvY2sgdHlwZSBpcyBub3QgMDIuXG4gICAqL1xuXG4gIC8vIHBhcnNlIHRoZSBlbmNyeXB0aW9uIGJsb2NrXG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVtKTtcbiAgdmFyIGZpcnN0ID0gZWIuZ2V0Qnl0ZSgpO1xuICB2YXIgYnQgPSBlYi5nZXRCeXRlKCk7XG4gIGlmKGZpcnN0ICE9PSAweDAwIHx8XG4gICAgKHB1YiAmJiBidCAhPT0gMHgwMCAmJiBidCAhPT0gMHgwMSkgfHxcbiAgICAoIXB1YiAmJiBidCAhPSAweDAyKSB8fFxuICAgIChwdWIgJiYgYnQgPT09IDB4MDAgJiYgdHlwZW9mKG1sKSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICB2YXIgcGFkTnVtID0gMDtcbiAgaWYoYnQgPT09IDB4MDApIHtcbiAgICAvLyBjaGVjayBhbGwgcGFkZGluZyBieXRlcyBmb3IgMHgwMFxuICAgIHBhZE51bSA9IGsgLSAzIC0gbWw7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICBpZihlYi5nZXRCeXRlKCkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDEpIHtcbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBieXRlIHRoYXQgaXNuJ3QgMHhGRiwgc2hvdWxkIGJlIGFmdGVyIGFsbCBwYWRkaW5nXG4gICAgcGFkTnVtID0gMDtcbiAgICB3aGlsZShlYi5sZW5ndGgoKSA+IDEpIHtcbiAgICAgIGlmKGViLmdldEJ5dGUoKSAhPT0gMHhGRikge1xuICAgICAgICAtLWViLnJlYWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgKytwYWROdW07XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDIpIHtcbiAgICAvLyBsb29rIGZvciAweDAwIGJ5dGVcbiAgICBwYWROdW0gPSAwO1xuICAgIHdoaWxlKGViLmxlbmd0aCgpID4gMSkge1xuICAgICAgaWYoZWIuZ2V0Qnl0ZSgpID09PSAweDAwKSB7XG4gICAgICAgIC0tZWIucmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BhZE51bTtcbiAgICB9XG4gIH1cblxuICAvLyB6ZXJvIG11c3QgYmUgMHgwMCBhbmQgcGFkTnVtIG11c3QgYmUgKGsgLSAzIC0gbWVzc2FnZSBsZW5ndGgpXG4gIHZhciB6ZXJvID0gZWIuZ2V0Qnl0ZSgpO1xuICBpZih6ZXJvICE9PSAweDAwIHx8IHBhZE51bSAhPT0gKGsgLSAzIC0gZWIubGVuZ3RoKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gYXN5bmNocm9ub3VzbHksIGVpdGhlciBpbiB0aGUgYmFja2dyb3VuZFxuICogdmlhIFdlYiBXb3JrZXJzLCBvciB1c2luZyB0aGUgbWFpbiB0aHJlYWQgYW5kIHNldEltbWVkaWF0ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGtleS1wYWlyIGdlbmVyYXRpb24gc3RhdGUuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb246XG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIsIC0xIHRvIHVzZSBlc3RpbWF0ZWQgY29yZXMgbWludXMgb25lKS5cbiAqICAgICAgICAgIHdvcmtMb2FkIHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgICAgICAgbnVtYmVycyBmb3IgZWFjaCB3ZWIgd29ya2VyIHRvIGNoZWNrIHBlciB3b3JrIGFzc2lnbm1lbnQsXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiAxMDApLlxuICogQHBhcmFtIGNhbGxiYWNrKGVyciwga2V5cGFpcikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9nZW5lcmF0ZUtleVBhaXIoc3RhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgb3B0cyA9IHtcbiAgICBhbGdvcml0aG06IHtcbiAgICAgIG5hbWU6IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdQUklNRUlOQycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHdvcmtlcnM6IG9wdGlvbnMud29ya2VycyB8fCAyLFxuICAgICAgICB3b3JrTG9hZDogb3B0aW9ucy53b3JrTG9hZCB8fCAxMDAsXG4gICAgICAgIHdvcmtlclNjcmlwdDogb3B0aW9ucy53b3JrZXJTY3JpcHRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmKCdwcm5nJyBpbiBvcHRpb25zKSB7XG4gICAgb3B0cy5wcm5nID0gb3B0aW9ucy5wcm5nO1xuICB9XG5cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyBmaW5kIHAgYW5kIHRoZW4gcSAoZG9uZSBpbiBzZXJpZXMgdG8gc2ltcGxpZnkpXG4gICAgZ2V0UHJpbWUoc3RhdGUucEJpdHMsIGZ1bmN0aW9uKGVyciwgbnVtKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wID0gbnVtO1xuICAgICAgaWYoc3RhdGUucSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmluaXNoKGVyciwgc3RhdGUucSk7XG4gICAgICB9XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByaW1lKGJpdHMsIGNhbGxiYWNrKSB7XG4gICAgZm9yZ2UucHJpbWUuZ2VuZXJhdGVQcm9iYWJsZVByaW1lKGJpdHMsIG9wdHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaChlcnIsIG51bSkge1xuICAgIGlmKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgLy8gc2V0IHFcbiAgICBzdGF0ZS5xID0gbnVtO1xuXG4gICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICBpZihzdGF0ZS5wLmNvbXBhcmVUbyhzdGF0ZS5xKSA8IDApIHtcbiAgICAgIHZhciB0bXAgPSBzdGF0ZS5wO1xuICAgICAgc3RhdGUucCA9IHN0YXRlLnE7XG4gICAgICBzdGF0ZS5xID0gdG1wO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBwIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucCA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBxIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICBzdGF0ZS5wMSA9IHN0YXRlLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgIHN0YXRlLnExID0gc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuXG4gICAgLy8gZW5zdXJlIGUgYW5kIHBoaSBhcmUgY29wcmltZVxuICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgLy8gcGhpIGFuZCBlIGFyZW4ndCBjb3ByaW1lLCBzbyBnZW5lcmF0ZSBhIG5ldyBwIGFuZCBxXG4gICAgICBzdGF0ZS5wID0gc3RhdGUucSA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgc3RhdGUubiA9IHN0YXRlLnAubXVsdGlwbHkoc3RhdGUucSk7XG4gICAgaWYoc3RhdGUubi5iaXRMZW5ndGgoKSAhPT0gc3RhdGUuYml0cykge1xuICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgIHN0YXRlLnEgPSBudWxsO1xuICAgICAgZ2V0UHJpbWUoc3RhdGUucUJpdHMsIGZpbmlzaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGtleXNcbiAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgIHN0YXRlLmtleXMgPSB7XG4gICAgICBwcml2YXRlS2V5OiBwa2kucnNhLnNldFByaXZhdGVLZXkoXG4gICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgIGQubW9kKHN0YXRlLnAxKSwgZC5tb2Qoc3RhdGUucTEpLFxuICAgICAgICBzdGF0ZS5xLm1vZEludmVyc2Uoc3RhdGUucCkpLFxuICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgIH07XG5cbiAgICBjYWxsYmFjayhudWxsLCBzdGF0ZS5rZXlzKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcG9zaXRpdmUgQmlnSW50ZWdlciBpbnRvIDIncy1jb21wbGVtZW50IGJpZy1lbmRpYW4gYnl0ZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJpZyBpbnRlZ2VyIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9iblRvQnl0ZXMoYikge1xuICAvLyBwcmVwZW5kIDB4MDAgaWYgZmlyc3QgYnl0ZSA+PSAweDgwXG4gIHZhciBoZXggPSBiLnRvU3RyaW5nKDE2KTtcbiAgaWYoaGV4WzBdID49ICc4Jykge1xuICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gIH1cbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGhleCk7XG5cbiAgLy8gZW5zdXJlIGludGVnZXIgaXMgbWluaW1hbGx5LWVuY29kZWRcbiAgaWYoYnl0ZXMubGVuZ3RoID4gMSAmJlxuICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICgoYnl0ZXMuY2hhckNvZGVBdCgwKSA9PT0gMCAmJlxuICAgIChieXRlcy5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDApIHx8XG4gICAgLy8gbGVhZGluZyAweEZGIGZvciBuZWdhdGl2ZSBpbnRlZ2VyXG4gICAgKGJ5dGVzLmNoYXJDb2RlQXQoMCkgPT09IDB4RkYgJiZcbiAgICAoYnl0ZXMuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICByZXR1cm4gYnl0ZXMuc3Vic3RyKDEpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgTWlsbGVyLVJhYmluIHRlc3RzIHRvIGdlbmVyYXRlIGFcbiAqIHByaW1lIHdpdGggYW4gZXJyb3IgcHJvYmFiaWxpdHkgb2YgKDEvMileODAuXG4gKlxuICogU2VlIEhhbmRib29rIG9mIEFwcGxpZWQgQ3J5cHRvZ3JhcGh5IENoYXB0ZXIgNCwgVGFibGUgNC40LlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gX2dldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgU3VidGxlQ3J5cHRvIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gZm4gdGhlIGZlYXR1cmUgKGZ1bmN0aW9uKSB0byBkZXRlY3QuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGRldGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9kZXRlY3RTdWJ0bGVDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvLnN1YnRsZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LmNyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgZGVwcmVjYXRlZCBNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIG91dGRhdGVkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgdXNlZCBhZnRlclxuICogY2hlY2tpbmcgZm9yIHRoZSBtb2Rlcm4sIHN0YW5kYXJkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8gPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gX2ludFRvVWludDhBcnJheSh4KSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4LnRvU3RyaW5nKDE2KSk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIF9wcml2YXRlS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGFsZ29yaXRobSBcIicgKyBqd2sua3R5ICsgJ1wiOyBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLm4pLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLnApLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2sucSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcCksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5xaSkpO1xufVxuXG5mdW5jdGlvbiBfcHVibGljS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2subiksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5lKSk7XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRUb0JpZ0ludChiNjQpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS51dGlsLmRlY29kZTY0KGI2NCkpLCAxNik7XG59XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQWR2YW5jZWQgRW5jcnlwdGlvbiBTdGFuZGFyZCAoQUVTKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBwdWJsaWMgZG9tYWluIGxpYnJhcnkgJ2pzY3J5cHRvJyB3aGljaFxuICogd2FzIHdyaXR0ZW4gYnk6XG4gKlxuICogRW1pbHkgU3RhcmsgKGVzdGFya0BzdGFuZm9yZC5lZHUpXG4gKiBNaWtlIEhhbWJ1cmcgKG1oYW1idXJnQHN0YW5mb3JkLmVkdSlcbiAqIERhbiBCb25laCAoZGFib0Bjcy5zdGFuZm9yZC5lZHUpXG4gKlxuICogUGFydHMgb2YgdGhpcyBjb2RlIGFyZSBiYXNlZCBvbiB0aGUgT3BlblNTTCBpbXBsZW1lbnRhdGlvbiBvZiBBRVM6XG4gKiBodHRwOi8vd3d3Lm9wZW5zc2wub3JnXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIEFFUyBBUEkgKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYWVzID0gZm9yZ2UuYWVzIHx8IHt9O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKiBjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZGVjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBRVMgY2lwaGVyIGFsZ29yaXRobSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBtb2RlIGZhY3RvcnkgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybiB0aGUgQUVTIGFsZ29yaXRobSBvYmplY3QuXG4gKi9cbmZvcmdlLmFlcy5BbGdvcml0aG0gPSBmdW5jdGlvbihuYW1lLCBtb2RlKSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5uYW1lID0gbmFtZTtcbiAgc2VsZi5tb2RlID0gbmV3IG1vZGUoe1xuICAgIGJsb2NrU2l6ZTogMTYsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX3csIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl93LCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIEFFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5hZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdG1wO1xuXG4gIC8qIE5vdGU6IFRoZSBrZXkgbWF5IGJlIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYSBieXRlXG4gICAgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMuIElmIHRoZSBrZXkgaXMgaW4gYnl0ZXMsIHRoZW5cbiAgICBpdCBtdXN0IGJlIDE2LCAyNCwgb3IgMzIgYnl0ZXMgaW4gbGVuZ3RoLiBJZiBpdCBpcyBpbiAzMi1iaXRcbiAgICBpbnRlZ2VycywgaXQgbXVzdCBiZSA0LCA2LCBvciA4IGludGVnZXJzIGxvbmcuICovXG5cbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgaW50ZWdlciBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdG1wID0ga2V5O1xuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAga2V5LnB1dEJ5dGUodG1wW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb252ZXJ0IGtleSBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSkge1xuICAgIHRtcCA9IGtleTtcbiAgICBrZXkgPSBbXTtcblxuICAgIC8vIGtleSBsZW5ndGhzIG9mIDE2LCAyNCwgMzIgYnl0ZXMgYWxsb3dlZFxuICAgIHZhciBsZW4gPSB0bXAubGVuZ3RoKCk7XG4gICAgaWYobGVuID09PSAxNiB8fCBsZW4gPT09IDI0IHx8IGxlbiA9PT0gMzIpIHtcbiAgICAgIGxlbiA9IGxlbiA+Pj4gMjtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBrZXkucHVzaCh0bXAuZ2V0SW50MzIoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2V5IG11c3QgYmUgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzIGJ5IG5vd1xuICBpZighZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgfHxcbiAgICAhKGtleS5sZW5ndGggPT09IDQgfHwga2V5Lmxlbmd0aCA9PT0gNiB8fCBrZXkubGVuZ3RoID09PSA4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgcGFyYW1ldGVyLicpO1xuICB9XG5cbiAgLy8gZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYWx3YXlzIHVzZWQgZm9yIHRoZXNlIG1vZGVzXG4gIHZhciBtb2RlID0gdGhpcy5tb2RlLm5hbWU7XG4gIHZhciBlbmNyeXB0T3AgPSAoWydDRkInLCAnT0ZCJywgJ0NUUicsICdHQ00nXS5pbmRleE9mKG1vZGUpICE9PSAtMSk7XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvblxuICB0aGlzLl93ID0gX2V4cGFuZEtleShrZXksIG9wdGlvbnMuZGVjcnlwdCAmJiAhZW5jcnlwdE9wKTtcbiAgdGhpcy5faW5pdCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEV4cGFuZHMgYSBrZXkuIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byBleHBhbmQsIGFzIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZXhwYW5kIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXkuXG4gKi9cbmZvcmdlLmFlcy5fZXhwYW5kS2V5ID0gZnVuY3Rpb24oa2V5LCBkZWNyeXB0KSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJldHVybiBfZXhwYW5kS2V5KGtleSwgZGVjcnlwdCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2suIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIHcgdGhlIGV4cGFuZGVkIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaW5wdXQgYW4gYXJyYXkgb2YgYmxvY2stc2l6ZSAzMi1iaXQgd29yZHMuXG4gKiBAcGFyYW0gb3V0cHV0IGFuIGFycmF5IG9mIGJsb2NrLXNpemUgMzItYml0IHdvcmRzLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0LCBmYWxzZSB0byBlbmNyeXB0LlxuICovXG5mb3JnZS5hZXMuX3VwZGF0ZUJsb2NrID0gX3VwZGF0ZUJsb2NrO1xuXG4vKiogUmVnaXN0ZXIgQUVTIGFsZ29yaXRobXMgKiovXG5cbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNCQycsIGZvcmdlLmNpcGhlci5tb2Rlcy5jYmMpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1DRkInLCBmb3JnZS5jaXBoZXIubW9kZXMuY2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNUUicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jdHIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1HQ00nLCBmb3JnZS5jaXBoZXIubW9kZXMuZ2NtKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuYWVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogQUVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgaW5pdCA9IGZhbHNlOyAvLyBub3QgeWV0IGluaXRpYWxpemVkXG52YXIgTmIgPSA0OyAgICAgICAvLyBudW1iZXIgb2Ygd29yZHMgY29tcHJpc2luZyB0aGUgc3RhdGUgKEFFUyA9IDQpXG52YXIgc2JveDsgICAgICAgICAvLyBub24tbGluZWFyIHN1YnN0aXR1dGlvbiB0YWJsZSB1c2VkIGluIGtleSBleHBhbnNpb25cbnZhciBpc2JveDsgICAgICAgIC8vIGludmVyc2lvbiBvZiBzYm94XG52YXIgcmNvbjsgICAgICAgICAvLyByb3VuZCBjb25zdGFudCB3b3JkIGFycmF5XG52YXIgbWl4OyAgICAgICAgICAvLyBtaXgtY29sdW1ucyB0YWJsZVxudmFyIGltaXg7ICAgICAgICAgLy8gaW52ZXJzZSBtaXgtY29sdW1ucyB0YWJsZVxuXG4vKipcbiAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uLCBpZTogcHJlY29tcHV0ZXMgdGFibGVzIHRvIG9wdGltaXplIGZvciBzcGVlZC5cbiAqXG4gKiBPbmUgd2F5IHRvIHVuZGVyc3RhbmQgaG93IEFFUyB3b3JrcyBpcyB0byBpbWFnaW5lIHRoYXQgJ2FkZGl0aW9uJyBhbmRcbiAqICdtdWx0aXBsaWNhdGlvbicgYXJlIGludGVyZmFjZXMgdGhhdCByZXF1aXJlIGNlcnRhaW4gbWF0aGVtYXRpY2FsXG4gKiBwcm9wZXJ0aWVzIHRvIGhvbGQgdHJ1ZSAoaWU6IHRoZXkgYXJlIGFzc29jaWF0aXZlKSBidXQgdGhleSBtaWdodCBoYXZlXG4gKiBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIGFuZCBwcm9kdWNlIGRpZmZlcmVudCBraW5kcyBvZiByZXN1bHRzIC4uLlxuICogcHJvdmlkZWQgdGhhdCB0aGVpciBtYXRoZW1hdGljYWwgcHJvcGVydGllcyByZW1haW4gdHJ1ZS4gQUVTIGRlZmluZXNcbiAqIGl0cyBvd24gbWV0aG9kcyBvZiBhZGRpdGlvbiBhbmQgbXVsdGlwbGljYXRpb24gYnV0IGtlZXBzIHNvbWUgaW1wb3J0YW50XG4gKiBwcm9wZXJ0aWVzIHRoZSBzYW1lLCBpZTogYXNzb2NpYXRpdml0eSBhbmQgZGlzdHJpYnV0aXZpdHkuIFRoZVxuICogZXhwbGFuYXRpb24gYmVsb3cgdHJpZXMgdG8gc2hlZCBzb21lIGxpZ2h0IG9uIGhvdyBBRVMgZGVmaW5lcyBhZGRpdGlvblxuICogYW5kIG11bHRpcGxpY2F0aW9uIG9mIGJ5dGVzIGFuZCAzMi1iaXQgd29yZHMgaW4gb3JkZXIgdG8gcGVyZm9ybSBpdHNcbiAqIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24gYWxnb3JpdGhtcy5cbiAqXG4gKiBUaGUgYmFzaWNzOlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHZpZXdzIGJ5dGVzIGFzIGJpbmFyeSByZXByZXNlbnRhdGlvbnMgb2YgcG9seW5vbWlhbHNcbiAqIHRoYXQgaGF2ZSBlaXRoZXIgMSBvciAwIGFzIHRoZSBjb2VmZmljaWVudHMuIEl0IGRlZmluZXMgdGhlIGFkZGl0aW9uXG4gKiBvciBzdWJ0cmFjdGlvbiBvZiB0d28gYnl0ZXMgYXMgdGhlIFhPUiBvcGVyYXRpb24uIEl0IGFsc28gZGVmaW5lcyB0aGVcbiAqIG11bHRpcGxpY2F0aW9uIG9mIHR3byBieXRlcyBhcyBhIGZpbml0ZSBmaWVsZCByZWZlcnJlZCB0byBhcyBHRigyXjgpXG4gKiAoTm90ZTogJ0dGJyBtZWFucyBcIkdhbG9pcyBGaWVsZFwiIHdoaWNoIGlzIGEgZmllbGQgdGhhdCBjb250YWlucyBhIGZpbml0ZVxuICogbnVtYmVyIG9mIGVsZW1lbnRzIHNvIEdGKDJeOCkgaGFzIDI1NiBlbGVtZW50cykuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IGFueSB0d28gYnl0ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGJpbmFyeSBwb2x5bm9taWFscztcbiAqIHdoZW4gdGhleSBtdWx0aXBsaWVkIHRvZ2V0aGVyIGFuZCBtb2R1bGFybHkgcmVkdWNlZCBieSBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiB0aGUgOHRoIGRlZ3JlZSwgdGhlIHJlc3VsdHMgYXJlIHRoZSBmaWVsZCBHRigyXjgpLiBUaGVcbiAqIHNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgdGhhdCBBRVMgdXNlcyBpbiBoZXhhZGVjaW1hbCBpcyAweDExYi5cbiAqIFRoaXMgbXVsdGlwbGljYXRpb24gaXMgYXNzb2NpYXRpdmUgd2l0aCAweDAxIGFzIHRoZSBpZGVudGl0eTpcbiAqXG4gKiAoYiAqIDB4MDEgPSBHRihiLCAweDAxKSA9IGIpLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gR0YoYiwgMHgwMikgY2FuIGJlIHBlcmZvcm1lZCBhdCB0aGUgYnl0ZSBsZXZlbCBieSBsZWZ0XG4gKiBzaGlmdGluZyBiIG9uY2UgYW5kIHRoZW4gWE9SJ2luZyBpdCAodG8gcGVyZm9ybSB0aGUgbW9kdWxhciByZWR1Y3Rpb24pXG4gKiB3aXRoIDB4MTFiIGlmIGIgaXMgPj0gMTI4LiBSZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB0aGUgbXVsdGlwbGljYXRpb25cbiAqIG9mIDB4MDIgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IHRoZSBtdWx0aXBsaWNhdGlvbiBvZiBhbnkgdHdvIGJ5dGVzLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgbXVsdGlwbHlpbmcgMHg1NyBhbmQgMHgxMywgZGVub3RlZCBhcyBHRigweDU3LCAweDEzKSwgY2FuXG4gKiBiZSBwZXJmb3JtZWQgYnkgZmFjdG9yaW5nIDB4MTMgaW50byAweDAxLCAweDAyLCBhbmQgMHgxMC4gVGhlbiB0aGVzZVxuICogZmFjdG9ycyBjYW4gZWFjaCBiZSBtdWx0aXBsaWVkIGJ5IDB4NTcgYW5kIHRoZW4gYWRkZWQgdG9nZXRoZXIuIFRvIGRvXG4gKiB0aGUgbXVsdGlwbGljYXRpb24sIHZhbHVlcyBmb3IgMHg1NyBtdWx0aXBsaWVkIGJ5IGVhY2ggb2YgdGhlc2UgMyBmYWN0b3JzXG4gKiBjYW4gYmUgcHJlY29tcHV0ZWQgYW5kIHN0b3JlZCBpbiBhIHRhYmxlLiBUbyBhZGQgdGhlbSwgdGhlIHZhbHVlcyBmcm9tXG4gKiB0aGUgdGFibGUgYXJlIFhPUidkIHRvZ2V0aGVyLlxuICpcbiAqIEFFUyBhbHNvIGRlZmluZXMgYWRkaXRpb24gYW5kIG11bHRpcGxpY2F0aW9uIG9mIHdvcmRzLCB0aGF0IGlzIDQtYnl0ZVxuICogbnVtYmVycyByZXByZXNlbnRlZCBhcyBwb2x5bm9taWFscyBvZiAzIGRlZ3JlZXMgd2hlcmUgdGhlIGNvZWZmaWNpZW50c1xuICogYXJlIHRoZSB2YWx1ZXMgb2YgdGhlIGJ5dGVzLlxuICpcbiAqIFRoZSB3b3JkIFthMCwgYTEsIGEyLCBhM10gaXMgYSBwb2x5bm9taWFsIGEzeF4zICsgYTJ4XjIgKyBhMXggKyBhMC5cbiAqXG4gKiBBZGRpdGlvbiBpcyBwZXJmb3JtZWQgYnkgWE9SJ2luZyBsaWtlIHBvd2VycyBvZiB4LiBNdWx0aXBsaWNhdGlvblxuICogaXMgcGVyZm9ybWVkIGluIHR3byBzdGVwcywgdGhlIGZpcnN0IGlzIGFuIGFsZ2VicmlhYyBleHBhbnNpb24gYXNcbiAqIHlvdSB3b3VsZCBkbyBub3JtYWxseSAod2hlcmUgYWRkaXRpb24gaXMgWE9SKS4gQnV0IHRoZSByZXN1bHQgaXNcbiAqIGEgcG9seW5vbWlhbCBsYXJnZXIgdGhhbiAzIGRlZ3JlZXMgYW5kIHRodXMgaXQgY2Fubm90IGZpdCBpbiBhIHdvcmQuIFNvXG4gKiBuZXh0IHRoZSByZXN1bHQgaXMgbW9kdWxhcmx5IHJlZHVjZWQgYnkgYW4gQUVTLXNwZWNpZmljIHBvbHlub21pYWwgb2ZcbiAqIGRlZ3JlZSA0IHdoaWNoIHdpbGwgYWx3YXlzIHByb2R1Y2UgYSBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiA0IGRlZ3JlZXNcbiAqIHN1Y2ggdGhhdCBpdCB3aWxsIGZpdCBpbiBhIHdvcmQuIEluIEFFUywgdGhpcyBwb2x5bm9taWFsIGlzIHheNCArIDEuXG4gKlxuICogVGhlIG1vZHVsYXIgcHJvZHVjdCBvZiB0d28gcG9seW5vbWlhbHMgJ2EnIGFuZCAnYicgaXMgdGh1czpcbiAqXG4gKiBkKHgpID0gZDN4XjMgKyBkMnheMiArIGQxeCArIGQwXG4gKiB3aXRoXG4gKiBkMCA9IEdGKGEwLCBiMCkgXiBHRihhMywgYjEpIF4gR0YoYTIsIGIyKSBeIEdGKGExLCBiMylcbiAqIGQxID0gR0YoYTEsIGIwKSBeIEdGKGEwLCBiMSkgXiBHRihhMywgYjIpIF4gR0YoYTIsIGIzKVxuICogZDIgPSBHRihhMiwgYjApIF4gR0YoYTEsIGIxKSBeIEdGKGEwLCBiMikgXiBHRihhMywgYjMpXG4gKiBkMyA9IEdGKGEzLCBiMCkgXiBHRihhMiwgYjEpIF4gR0YoYTEsIGIyKSBeIEdGKGEwLCBiMylcbiAqXG4gKiBBcyBhIG1hdHJpeDpcbiAqXG4gKiBbZDBdID0gW2EwIGEzIGEyIGExXVtiMF1cbiAqIFtkMV0gICBbYTEgYTAgYTMgYTJdW2IxXVxuICogW2QyXSAgIFthMiBhMSBhMCBhM11bYjJdXG4gKiBbZDNdICAgW2EzIGEyIGExIGEwXVtiM11cbiAqXG4gKiBTcGVjaWFsIHBvbHlub21pYWxzIGRlZmluZWQgYnkgQUVTICgweDAyID09IHswMn0pOlxuICogYSh4KSAgICA9IHswM314XjMgKyB7MDF9eF4yICsgezAxfXggKyB7MDJ9XG4gKiBhXi0xKHgpID0gezBifXheMyArIHswZH14XjIgKyB7MDl9eCArIHswZX0uXG4gKlxuICogVGhlc2UgcG9seW5vbWlhbHMgYXJlIHVzZWQgaW4gdGhlIE1peENvbHVtbnMoKSBhbmQgSW52ZXJzZU1peENvbHVtbnMoKVxuICogb3BlcmF0aW9ucywgcmVzcGVjdGl2ZWx5LCB0byBjYXVzZSBlYWNoIGVsZW1lbnQgaW4gdGhlIHN0YXRlIHRvIGFmZmVjdFxuICogdGhlIG91dHB1dCAocmVmZXJyZWQgdG8gYXMgZGlmZnVzaW5nKS5cbiAqXG4gKiBSb3RXb3JkKCkgdXNlczogYTAgPSBhMSA9IGEyID0gezAwfSBhbmQgYTMgPSB7MDF9LCB3aGljaCBpcyB0aGVcbiAqIHBvbHlub21pYWwgeDMuXG4gKlxuICogVGhlIFNoaWZ0Um93cygpIG1ldGhvZCBtb2RpZmllcyB0aGUgbGFzdCAzIHJvd3MgaW4gdGhlIHN0YXRlICh3aGVyZVxuICogdGhlIHN0YXRlIGlzIDQgd29yZHMgd2l0aCA0IGJ5dGVzIHBlciB3b3JkKSBieSBzaGlmdGluZyBieXRlcyBjeWNsaWNhbGx5LlxuICogVGhlIDFzdCBieXRlIGluIHRoZSBzZWNvbmQgcm93IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHJvdy4gVGhlIDFzdFxuICogYW5kIDJuZCBieXRlcyBpbiB0aGUgdGhpcmQgcm93IGFyZSBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoZSByb3cuIFRoZSAxc3QsXG4gKiAybmQsIGFuZCAzcmQgYnl0ZXMgYXJlIG1vdmVkIGluIHRoZSBmb3VydGggcm93LlxuICpcbiAqIE1vcmUgZGV0YWlscyBvbiBob3cgQUVTIGFyaXRobWV0aWMgd29ya3M6XG4gKlxuICogSW4gdGhlIHBvbHlub21pYWwgcmVwcmVzZW50YXRpb24gb2YgYmluYXJ5IG51bWJlcnMsIFhPUiBwZXJmb3JtcyBhZGRpdGlvblxuICogYW5kIHN1YnRyYWN0aW9uIGFuZCBtdWx0aXBsaWNhdGlvbiBpbiBHRigyXjgpIGRlbm90ZWQgYXMgR0YoYSwgYilcbiAqIGNvcnJlc3BvbmRzIHdpdGggdGhlIG11bHRpcGxpY2F0aW9uIG9mIHBvbHlub21pYWxzIG1vZHVsbyBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiBkZWdyZWUgOC4gSW4gb3RoZXIgd29yZHMsIGZvciBBRVMsIEdGKGEsIGIpIHdpbGwgbXVsdGlwbHlcbiAqIHBvbHlub21pYWwgJ2EnIHdpdGggcG9seW5vbWlhbCAnYicgYW5kIHRoZW4gZG8gYSBtb2R1bGFyIHJlZHVjdGlvbiBieVxuICogYW4gQUVTLXNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgb2YgZGVncmVlIDguXG4gKlxuICogQSBwb2x5bm9taWFsIGlzIGlycmVkdWNpYmxlIGlmIGl0cyBvbmx5IGRpdmlzb3JzIGFyZSBvbmUgYW5kIGl0c2VsZi4gRm9yXG4gKiB0aGUgQUVTIGFsZ29yaXRobSwgdGhpcyBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIGlzOlxuICpcbiAqIG0oeCkgPSB4XjggKyB4XjQgKyB4XjMgKyB4ICsgMSxcbiAqXG4gKiBvciB7MDF9ezFifSBpbiBoZXhhZGVjaW1hbCBub3RhdGlvbiwgd2hlcmUgZWFjaCBjb2VmZmljaWVudCBpcyBhIGJpdDpcbiAqIDEwMDAxMTAxMSA9IDI4MyA9IDB4MTFiLlxuICpcbiAqIEZvciBleGFtcGxlLCBHRigweDU3LCAweDgzKSA9IDB4YzEgYmVjYXVzZVxuICpcbiAqIDB4NTcgPSA4NyAgPSAwMTAxMDExMSA9IHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiAweDg1ID0gMTMxID0gMTAwMDAxMDEgPSB4XjcgKyB4ICsgMVxuICpcbiAqICh4XjYgKyB4XjQgKyB4XjIgKyB4ICsgMSkgKiAoeF43ICsgeCArIDEpXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNyArXG4gKiAgICB4XjcgKyB4XjUgKyB4XjMgKyB4XjIgKyB4ICtcbiAqICAgIHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNiArIHheNSArIHheNCArIHheMyArIDEgPSB5XG4gKiAgICB5IG1vZHVsbyAoeF44ICsgeF40ICsgeF4zICsgeCArIDEpXG4gKiA9ICB4XjcgKyB4XjYgKyAxLlxuICpcbiAqIFRoZSBtb2R1bGFyIHJlZHVjdGlvbiBieSBtKHgpIGd1YXJhbnRlZXMgdGhlIHJlc3VsdCB3aWxsIGJlIGEgYmluYXJ5XG4gKiBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiBkZWdyZWUgOCwgc28gdGhhdCBpdCBjYW4gZml0IGluIGEgYnl0ZS5cbiAqXG4gKiBUaGUgb3BlcmF0aW9uIHRvIG11bHRpcGx5IGEgYmluYXJ5IHBvbHlub21pYWwgYiB3aXRoIHggKHRoZSBwb2x5bm9taWFsXG4gKiB4IGluIGJpbmFyeSByZXByZXNlbnRhdGlvbiBpcyAwMDAwMDAxMCkgaXM6XG4gKlxuICogYl83eF44ICsgYl82eF43ICsgYl81eF42ICsgYl80eF41ICsgYl8zeF40ICsgYl8yeF4zICsgYl8xeF4yICsgYl8weF4xXG4gKlxuICogVG8gZ2V0IEdGKGIsIHgpIHdlIG11c3QgcmVkdWNlIHRoYXQgYnkgbSh4KS4gSWYgYl83IGlzIDAgKHRoYXQgaXMgdGhlXG4gKiBtb3N0IHNpZ25pZmljYW50IGJpdCBpcyAwIGluIGIpIHRoZW4gdGhlIHJlc3VsdCBpcyBhbHJlYWR5IHJlZHVjZWQuIElmXG4gKiBpdCBpcyAxLCB0aGVuIHdlIGNhbiByZWR1Y2UgaXQgYnkgc3VidHJhY3RpbmcgbSh4KSB2aWEgYW4gWE9SLlxuICpcbiAqIEl0IGZvbGxvd3MgdGhhdCBtdWx0aXBsaWNhdGlvbiBieSB4ICgwMDAwMDAxMCBvciAweDAyKSBjYW4gYmUgaW1wbGVtZW50ZWRcbiAqIGJ5IHBlcmZvcm1pbmcgYSBsZWZ0IHNoaWZ0IGZvbGxvd2VkIGJ5IGEgY29uZGl0aW9uYWwgYml0d2lzZSBYT1Igd2l0aFxuICogMHgxYi4gVGhpcyBvcGVyYXRpb24gb24gYnl0ZXMgaXMgZGVub3RlZCBieSB4dGltZSgpLiBNdWx0aXBsaWNhdGlvbiBieVxuICogaGlnaGVyIHBvd2VycyBvZiB4IGNhbiBiZSBpbXBsZW1lbnRlZCBieSByZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB4dGltZSgpLlxuICpcbiAqIEJ5IGFkZGluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cywgbXVsdGlwbGljYXRpb24gYnkgYW55IGNvbnN0YW50IGNhbiBiZVxuICogaW1wbGVtZW50ZWQuIEZvciBpbnN0YW5jZTpcbiAqXG4gKiBHRigweDU3LCAweDEzKSA9IDB4ZmUgYmVjYXVzZTpcbiAqXG4gKiB4dGltZShiKSA9IChiICYgMTI4KSA/IChiIDw8IDEgXiAweDExYikgOiAoYiA8PCAxKVxuICpcbiAqIE5vdGU6IFdlIFhPUiB3aXRoIDB4MTFiIGluc3RlYWQgb2YgMHgxYiBiZWNhdXNlIGluIGphdmFzY3JpcHQgb3VyXG4gKiBkYXRhdHlwZSBmb3IgYiBjYW4gYmUgbGFyZ2VyIHRoYW4gMSBieXRlLCBzbyBhIGxlZnQgc2hpZnQgd2lsbCBub3RcbiAqIGF1dG9tYXRpY2FsbHkgZWxpbWluYXRlIGJpdHMgdGhhdCBvdmVyZmxvdyBhIGJ5dGUgLi4uIGJ5IFhPUidpbmcgdGhlXG4gKiBvdmVyZmxvdyBiaXQgd2l0aCAxICh0aGUgZXh0cmEgb25lIGZyb20gMHgxMWIpIHdlIHplcm8gaXQgb3V0LlxuICpcbiAqIEdGKDB4NTcsIDB4MDIpID0geHRpbWUoMHg1NykgPSAweGFlXG4gKiBHRigweDU3LCAweDA0KSA9IHh0aW1lKDB4YWUpID0gMHg0N1xuICogR0YoMHg1NywgMHgwOCkgPSB4dGltZSgweDQ3KSA9IDB4OGVcbiAqIEdGKDB4NTcsIDB4MTApID0geHRpbWUoMHg4ZSkgPSAweDA3XG4gKlxuICogR0YoMHg1NywgMHgxMykgPSBHRigweDU3LCAoMHgwMSBeIDB4MDIgXiAweDEwKSlcbiAqXG4gKiBBbmQgYnkgdGhlIGRpc3RyaWJ1dGl2ZSBwcm9wZXJ0eSAoc2luY2UgWE9SIGlzIGFkZGl0aW9uIGFuZCBHRigpIGlzXG4gKiBtdWx0aXBsaWNhdGlvbik6XG4gKlxuICogPSBHRigweDU3LCAweDAxKSBeIEdGKDB4NTcsIDB4MDIpIF4gR0YoMHg1NywgMHgxMClcbiAqID0gMHg1NyBeIDB4YWUgXiAweDA3XG4gKiA9IDB4ZmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gIGluaXQgPSB0cnVlO1xuXG4gIC8qIFBvcHVsYXRlIHRoZSBSY29uIHRhYmxlLiBUaGVzZSBhcmUgdGhlIHZhbHVlcyBnaXZlbiBieVxuICAgIFt4XihpLTEpLHswMH0sezAwfSx7MDB9XSB3aGVyZSB4XihpLTEpIGFyZSBwb3dlcnMgb2YgeCAoYW5kIHggPSAweDAyKVxuICAgIGluIHRoZSBmaWVsZCBvZiBHRigyXjgpLCB3aGVyZSBpIHN0YXJ0cyBhdCAxLlxuXG4gICAgcmNvblswXSA9IFsweDAwLCAweDAwLCAweDAwLCAweDAwXVxuICAgIHJjb25bMV0gPSBbMHgwMSwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMS0xKSA9IDJeMCA9IDFcbiAgICByY29uWzJdID0gWzB4MDIsIDB4MDAsIDB4MDAsIDB4MDBdIDJeKDItMSkgPSAyXjEgPSAyXG4gICAgLi4uXG4gICAgcmNvbls5XSAgPSBbMHgxQiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oOS0xKSAgPSAyXjggPSAweDFCXG4gICAgcmNvblsxMF0gPSBbMHgzNiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMTAtMSkgPSAyXjkgPSAweDM2XG5cbiAgICBXZSBvbmx5IHN0b3JlIHRoZSBmaXJzdCBieXRlIGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgb25lIHVzZWQuXG4gICovXG4gIHJjb24gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxQiwgMHgzNl07XG5cbiAgLy8gY29tcHV0ZSB4dGltZSB0YWJsZSB3aGljaCBtYXBzIGkgb250byBHRihpLCAweDAyKVxuICB2YXIgeHRpbWUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgeHRpbWVbaV0gPSBpIDw8IDE7XG4gICAgeHRpbWVbaSArIDEyOF0gPSAoaSArIDEyOCkgPDwgMSBeIDB4MTFCO1xuICB9XG5cbiAgLy8gY29tcHV0ZSBhbGwgb3RoZXIgdGFibGVzXG4gIHNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgaXNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgbWl4ID0gbmV3IEFycmF5KDQpO1xuICBpbWl4ID0gbmV3IEFycmF5KDQpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgbWl4W2ldID0gbmV3IEFycmF5KDI1Nik7XG4gICAgaW1peFtpXSA9IG5ldyBBcnJheSgyNTYpO1xuICB9XG4gIHZhciBlID0gMCwgZWkgPSAwLCBlMiwgZTQsIGU4LCBzeCwgc3gyLCBtZSwgaW1lO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAvKiBXZSBuZWVkIHRvIGdlbmVyYXRlIHRoZSBTdWJCeXRlcygpIHNib3ggYW5kIGlzYm94IHRhYmxlcyBzbyB0aGF0XG4gICAgICB3ZSBjYW4gcGVyZm9ybSBieXRlIHN1YnN0aXR1dGlvbnMuIFRoaXMgcmVxdWlyZXMgdXMgdG8gdHJhdmVyc2VcbiAgICAgIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gR0YsIGZpbmQgdGhlaXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZXMsXG4gICAgICBhbmQgYXBwbHkgdG8gZWFjaCB0aGUgZm9sbG93aW5nIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjpcblxuICAgICAgYmknID0gYmkgXiBiKGkgKyA0KSBtb2QgOCBeIGIoaSArIDUpIG1vZCA4IF4gYihpICsgNikgbW9kIDggXlxuICAgICAgICAgICAgYihpICsgNykgbW9kIDggXiBjaVxuICAgICAgZm9yIDAgPD0gaSA8IDgsIHdoZXJlIGJpIGlzIHRoZSBpdGggYml0IG9mIHRoZSBieXRlLCBhbmQgY2kgaXMgdGhlXG4gICAgICBpdGggYml0IG9mIGEgYnl0ZSBjIHdpdGggdGhlIHZhbHVlIHs2M30gb3IgezAxMTAwMDExfS5cblxuICAgICAgSXQgaXMgcG9zc2libGUgdG8gdHJhdmVyc2UgZXZlcnkgcG9zc2libGUgdmFsdWUgaW4gYSBHYWxvaXMgZmllbGRcbiAgICAgIHVzaW5nIHdoYXQgaXMgcmVmZXJyZWQgdG8gYXMgYSAnZ2VuZXJhdG9yJy4gVGhlcmUgYXJlIG1hbnlcbiAgICAgIGdlbmVyYXRvcnMgKDEyOCBvdXQgb2YgMjU2KTogMyw1LDYsOSwxMSw4MiB0byBuYW1lIGEgZmV3LiBUbyBmdWxseVxuICAgICAgdHJhdmVyc2UgR0Ygd2UgaXRlcmF0ZSAyNTUgdGltZXMsIG11bHRpcGx5aW5nIGJ5IG91ciBnZW5lcmF0b3JcbiAgICAgIGVhY2ggdGltZS5cblxuICAgICAgT24gZWFjaCBpdGVyYXRpb24gd2UgY2FuIGRldGVybWluZSB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBmb3JcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQuXG5cbiAgICAgIFN1cHBvc2UgdGhlcmUgaXMgYW4gZWxlbWVudCBpbiBHRiAnZScuIEZvciBhIGdpdmVuIGdlbmVyYXRvciAnZycsXG4gICAgICBlID0gZ154LiBUaGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiBlIGlzIGdeKDI1NSAtIHgpLiBJdCB0dXJuc1xuICAgICAgb3V0IHRoYXQgaWYgdXNlIHRoZSBpbnZlcnNlIG9mIGEgZ2VuZXJhdG9yIGFzIGFub3RoZXIgZ2VuZXJhdG9yXG4gICAgICBpdCB3aWxsIHByb2R1Y2UgYWxsIG9mIHRoZSBjb3JyZXNwb25kaW5nIG11bHRpcGxpY2F0aXZlIGludmVyc2VzXG4gICAgICBhdCB0aGUgc2FtZSB0aW1lLiBGb3IgdGhpcyByZWFzb24sIHdlIGNob29zZSA1IGFzIG91ciBpbnZlcnNlXG4gICAgICBnZW5lcmF0b3IgYmVjYXVzZSBpdCBvbmx5IHJlcXVpcmVzIDIgbXVsdGlwbGllcyBhbmQgMSBhZGQgYW5kIGl0c1xuICAgICAgaW52ZXJzZSwgODIsIHJlcXVpcmVzIHJlbGF0aXZlbHkgZmV3IG9wZXJhdGlvbnMgYXMgd2VsbC5cblxuICAgICAgSW4gb3JkZXIgdG8gYXBwbHkgdGhlIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiwgdGhlIG11bHRpcGxpY2F0aXZlXG4gICAgICBpbnZlcnNlICdlaScgb2YgJ2UnIGNhbiBiZSByZXBlYXRlZGx5IFhPUidkICg0IHRpbWVzKSB3aXRoIGFcbiAgICAgIGJpdC1jeWNsaW5nIG9mICdlaScuIFRvIGRvIHRoaXMgJ2VpJyBpcyBmaXJzdCBzdG9yZWQgaW4gJ3MnIGFuZFxuICAgICAgJ3gnLiBUaGVuICdzJyBpcyBsZWZ0IHNoaWZ0ZWQgYW5kIHRoZSBoaWdoIGJpdCBvZiAncycgaXMgbWFkZSB0aGVcbiAgICAgIGxvdyBiaXQuIFRoZSByZXN1bHRpbmcgdmFsdWUgaXMgc3RvcmVkIGluICdzJy4gVGhlbiAneCcgaXMgWE9SJ2RcbiAgICAgIHdpdGggJ3MnIGFuZCBzdG9yZWQgaW4gJ3gnLiBPbiBlYWNoIHN1YnNlcXVlbnQgaXRlcmF0aW9uIHRoZSBzYW1lXG4gICAgICBvcGVyYXRpb24gaXMgcGVyZm9ybWVkLiBXaGVuIDQgaXRlcmF0aW9ucyBhcmUgY29tcGxldGUsICd4JyBpc1xuICAgICAgWE9SJ2Qgd2l0aCAnYycgKDB4NjMpIGFuZCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgaXMgc3RvcmVkIGluICd4Jy5cbiAgICAgIEZvciBleGFtcGxlOlxuXG4gICAgICBzID0gMDEwMDAwMDFcbiAgICAgIHggPSAwMTAwMDAwMVxuXG4gICAgICBpdGVyYXRpb24gMTogcyA9IDEwMDAwMDEwLCB4IF49IHNcbiAgICAgIGl0ZXJhdGlvbiAyOiBzID0gMDAwMDAxMDEsIHggXj0gc1xuICAgICAgaXRlcmF0aW9uIDM6IHMgPSAwMDAwMTAxMCwgeCBePSBzXG4gICAgICBpdGVyYXRpb24gNDogcyA9IDAwMDEwMTAwLCB4IF49IHNcbiAgICAgIHggXj0gMHg2M1xuXG4gICAgICBUaGlzIGNhbiBiZSBkb25lIHdpdGggYSBsb29wIHdoZXJlIHMgPSAocyA8PCAxKSB8IChzID4+IDcpLiBIb3dldmVyLFxuICAgICAgaXQgY2FuIGFsc28gYmUgZG9uZSBieSB1c2luZyBhIHNpbmdsZSAxNi1iaXQgKGluIHRoaXMgY2FzZSAzMi1iaXQpXG4gICAgICBudW1iZXIgJ3N4Jy4gU2luY2UgWE9SIGlzIGFuIGFzc29jaWF0aXZlIG9wZXJhdGlvbiwgd2UgY2FuIHNldCAnc3gnXG4gICAgICB0byAnZWknIGFuZCB0aGVuIFhPUiBpdCB3aXRoICdzeCcgbGVmdC1zaGlmdGVkIDEsMiwzLCBhbmQgNCB0aW1lcy5cbiAgICAgIFRoZSBtb3N0IHNpZ25pZmljYW50IGJpdHMgd2lsbCBmbG93IGludG8gdGhlIGhpZ2ggOCBiaXQgcG9zaXRpb25zXG4gICAgICBhbmQgYmUgY29ycmVjdGx5IFhPUidkIHdpdGggb25lIGFub3RoZXIuIEFsbCB0aGF0IHJlbWFpbnMgd2lsbCBiZVxuICAgICAgdG8gY3ljbGUgdGhlIGhpZ2ggOCBiaXRzIGJ5IFhPUidpbmcgdGhlbSBhbGwgd2l0aCB0aGUgbG93ZXIgOCBiaXRzXG4gICAgICBhZnRlcndhcmRzLlxuXG4gICAgICBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIHBvcHVsYXRpbmcgc2JveCBhbmQgaXNib3ggd2UgY2FuIHByZWNvbXB1dGVcbiAgICAgIHRoZSBtdWx0aXBsaWNhdGlvbiB3ZSdsbCBuZWVkIHRvIGRvIHRvIGRvIE1peENvbHVtbnMoKSBsYXRlci5cbiAgICAqL1xuXG4gICAgLy8gYXBwbHkgYWZmaW5lIHRyYW5zZm9ybWF0aW9uXG4gICAgc3ggPSBlaSBeIChlaSA8PCAxKSBeIChlaSA8PCAyKSBeIChlaSA8PCAzKSBeIChlaSA8PCA0KTtcbiAgICBzeCA9IChzeCA+PiA4KSBeIChzeCAmIDI1NSkgXiAweDYzO1xuXG4gICAgLy8gdXBkYXRlIHRhYmxlc1xuICAgIHNib3hbZV0gPSBzeDtcbiAgICBpc2JveFtzeF0gPSBlO1xuXG4gICAgLyogTWl4aW5nIGNvbHVtbnMgaXMgZG9uZSB1c2luZyBtYXRyaXggbXVsdGlwbGljYXRpb24uIFRoZSBjb2x1bW5zXG4gICAgICB0aGF0IGFyZSB0byBiZSBtaXhlZCBhcmUgZWFjaCBhIHNpbmdsZSB3b3JkIGluIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgVGhlIHN0YXRlIGhhcyBOYiBjb2x1bW5zICg0IGNvbHVtbnMpLiBUaGVyZWZvcmUgZWFjaCBjb2x1bW4gaXMgYVxuICAgICAgNCBieXRlIHdvcmQuIFNvIHRvIG1peCB0aGUgY29sdW1ucyBpbiBhIHNpbmdsZSBjb2x1bW4gJ2MnIHdoZXJlXG4gICAgICBpdHMgcm93cyBhcmUgcjAsIHIxLCByMiwgYW5kIHIzLCB3ZSB1c2UgdGhlIGZvbGxvd2luZyBtYXRyaXhcbiAgICAgIG11bHRpcGxpY2F0aW9uOlxuXG4gICAgICBbMiAzIDEgMV0qW3IwLGNdPVtyJzAsY11cbiAgICAgIFsxIDIgMyAxXSBbcjEsY10gW3InMSxjXVxuICAgICAgWzEgMSAyIDNdIFtyMixjXSBbcicyLGNdXG4gICAgICBbMyAxIDEgMl0gW3IzLGNdIFtyJzMsY11cblxuICAgICAgcjAsIHIxLCByMiwgYW5kIHIzIGFyZSBlYWNoIDEgYnl0ZSBvZiBvbmUgb2YgdGhlIHdvcmRzIGluIHRoZVxuICAgICAgc3RhdGUgKGEgY29sdW1uKS4gVG8gZG8gbWF0cml4IG11bHRpcGxpY2F0aW9uIGZvciBlYWNoIG1peGVkXG4gICAgICBjb2x1bW4gYycgd2UgbXVsdGlwbHkgdGhlIGNvcnJlc3BvbmRpbmcgcm93IGZyb20gdGhlIGxlZnQgbWF0cml4XG4gICAgICB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBmcm9tIHRoZSByaWdodCBtYXRyaXguIEluIHRvdGFsLCB3ZVxuICAgICAgZ2V0IDQgZXF1YXRpb25zOlxuXG4gICAgICByMCxjJyA9IDIqcjAsYyArIDMqcjEsYyArIDEqcjIsYyArIDEqcjMsY1xuICAgICAgcjEsYycgPSAxKnIwLGMgKyAyKnIxLGMgKyAzKnIyLGMgKyAxKnIzLGNcbiAgICAgIHIyLGMnID0gMSpyMCxjICsgMSpyMSxjICsgMipyMixjICsgMypyMyxjXG4gICAgICByMyxjJyA9IDMqcjAsYyArIDEqcjEsYyArIDEqcjIsYyArIDIqcjMsY1xuXG4gICAgICBBcyB1c3VhbCwgdGhlIG11bHRpcGxpY2F0aW9uIGlzIGFzIHByZXZpb3VzbHkgZGVmaW5lZCBhbmQgdGhlXG4gICAgICBhZGRpdGlvbiBpcyBYT1IuIEluIG9yZGVyIHRvIG9wdGltaXplIG1peGluZyBjb2x1bW5zIHdlIGNhbiBzdG9yZVxuICAgICAgdGhlIG11bHRpcGxpY2F0aW9uIHJlc3VsdHMgaW4gdGFibGVzLiBJZiB5b3UgdGhpbmsgb2YgdGhlIHdob2xlXG4gICAgICBjb2x1bW4gYXMgYSB3b3JkIChpdCBtaWdodCBoZWxwIHRvIHZpc3VhbGl6ZSBieSBtZW50YWxseSByb3RhdGluZ1xuICAgICAgdGhlIGVxdWF0aW9ucyBhYm92ZSBieSBjb3VudGVyY2xvY2t3aXNlIDkwIGRlZ3JlZXMpIHRoZW4geW91IGNhblxuICAgICAgc2VlIHRoYXQgaXQgd291bGQgYmUgdXNlZnVsIHRvIG1hcCB0aGUgbXVsdGlwbGljYXRpb25zIHBlcmZvcm1lZCBvblxuICAgICAgZWFjaCBieXRlIChyMCwgcjEsIHIyLCByMykgb250byBhIHdvcmQgYXMgd2VsbC4gRm9yIGluc3RhbmNlLCB3ZVxuICAgICAgY291bGQgbWFwIDIqcjAsMSpyMCwxKnIwLDMqcjAgb250byBhIHdvcmQgYnkgc3RvcmluZyAyKnIwIGluIHRoZVxuICAgICAgaGlnaGVzdCA4IGJpdHMgYW5kIDMqcjAgaW4gdGhlIGxvd2VzdCA4IGJpdHMgKHdpdGggdGhlIG90aGVyIHR3b1xuICAgICAgcmVzcGVjdGl2ZWx5IGluIHRoZSBtaWRkbGUpLiBUaGlzIG1lYW5zIHRoYXQgYSB0YWJsZSBjYW4gYmVcbiAgICAgIGNvbnN0cnVjdGVkIHRoYXQgdXNlcyByMCBhcyBhbiBpbmRleCB0byB0aGUgd29yZC4gV2UgY2FuIGRvIHRoZVxuICAgICAgc2FtZSB3aXRoIHIxLCByMiwgYW5kIHIzLCBjcmVhdGluZyBhIHRvdGFsIG9mIDQgdGFibGVzLlxuXG4gICAgICBUbyBjb25zdHJ1Y3QgYSBmdWxsIGMnLCB3ZSBjYW4ganVzdCBsb29rIHVwIGVhY2ggYnl0ZSBvZiBjIGluXG4gICAgICB0aGVpciByZXNwZWN0aXZlIHRhYmxlcyBhbmQgWE9SIHRoZSByZXN1bHRzIHRvZ2V0aGVyLlxuXG4gICAgICBBbHNvLCB0byBidWlsZCBlYWNoIHRhYmxlIHdlIG9ubHkgaGF2ZSB0byBjYWxjdWxhdGUgdGhlIHdvcmRcbiAgICAgIGZvciAyLDEsMSwzIGZvciBldmVyeSBieXRlIC4uLiB3aGljaCB3ZSBjYW4gZG8gb24gZWFjaCBpdGVyYXRpb25cbiAgICAgIG9mIHRoaXMgbG9vcCBzaW5jZSB3ZSB3aWxsIGl0ZXJhdGUgb3ZlciBldmVyeSBieXRlLiBBZnRlciB3ZSBoYXZlXG4gICAgICBjYWxjdWxhdGVkIDIsMSwxLDMgd2UgY2FuIGdldCB0aGUgcmVzdWx0cyBmb3IgdGhlIG90aGVyIHRhYmxlc1xuICAgICAgYnkgY3ljbGluZyB0aGUgYnl0ZSBhdCB0aGUgZW5kIHRvIHRoZSBiZWdpbm5pbmcuIEZvciBpbnN0YW5jZVxuICAgICAgd2UgY2FuIHRha2UgdGhlIHJlc3VsdCBvZiB0YWJsZSAyLDEsMSwzIGFuZCBwcm9kdWNlIHRhYmxlIDMsMiwxLDFcbiAgICAgIGJ5IG1vdmluZyB0aGUgcmlnaHQgbW9zdCBieXRlIHRvIHRoZSBsZWZ0IG1vc3QgcG9zaXRpb24ganVzdCBsaWtlXG4gICAgICBob3cgeW91IGNhbiBpbWFnaW5lIHRoZSAzIG1vdmVkIG91dCBvZiAyLDEsMSwzIGFuZCB0byB0aGUgZnJvbnRcbiAgICAgIHRvIHByb2R1Y2UgMywyLDEsMS5cblxuICAgICAgVGhlcmUgaXMgYW5vdGhlciBvcHRpbWl6YXRpb24gaW4gdGhhdCB0aGUgc2FtZSBtdWx0aXBsZXMgb2ZcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQgd2UgbmVlZCBpbiBvcmRlciB0byBhZHZhbmNlIG91ciBnZW5lcmF0b3JcbiAgICAgIHRvIHRoZSBuZXh0IGl0ZXJhdGlvbiBjYW4gYmUgcmV1c2VkIGluIHBlcmZvcm1pbmcgdGhlIDIsMSwxLDNcbiAgICAgIGNhbGN1bGF0aW9uLiBXZSBhbHNvIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZSBtaXggY29sdW1uIHRhYmxlcyxcbiAgICAgIHdpdGggZSw5LGQsYiBiZWluZyB0aGUgaW52ZXJzZSBvZiAyLDEsMSwzLlxuXG4gICAgICBXaGVuIHdlJ3JlIGRvbmUsIGFuZCB3ZSBuZWVkIHRvIGFjdHVhbGx5IG1peCBjb2x1bW5zLCB0aGUgZmlyc3RcbiAgICAgIGJ5dGUgb2YgZWFjaCBzdGF0ZSB3b3JkIHNob3VsZCBiZSBwdXQgdGhyb3VnaCBtaXhbMF0gKDIsMSwxLDMpLFxuICAgICAgdGhlIHNlY29uZCB0aHJvdWdoIG1peFsxXSAoMywyLDEsMSkgYW5kIHNvIGZvcnRoLiBUaGVuIHRoZXkgc2hvdWxkXG4gICAgICBiZSBYT1InZCB0b2dldGhlciB0byBwcm9kdWNlIHRoZSBmdWxseSBtaXhlZCBjb2x1bW4uXG4gICAgKi9cblxuICAgIC8vIGNhbGN1bGF0ZSBtaXggYW5kIGltaXggdGFibGUgdmFsdWVzXG4gICAgc3gyID0geHRpbWVbc3hdO1xuICAgIGUyID0geHRpbWVbZV07XG4gICAgZTQgPSB4dGltZVtlMl07XG4gICAgZTggPSB4dGltZVtlNF07XG4gICAgbWUgPVxuICAgICAgKHN4MiA8PCAyNCkgXiAgLy8gMlxuICAgICAgKHN4IDw8IDE2KSBeICAgLy8gMVxuICAgICAgKHN4IDw8IDgpIF4gICAgLy8gMVxuICAgICAgKHN4IF4gc3gyKTsgICAgLy8gM1xuICAgIGltZSA9XG4gICAgICAoZTIgXiBlNCBeIGU4KSA8PCAyNCBeICAvLyBFICgxNClcbiAgICAgIChlIF4gZTgpIDw8IDE2IF4gICAgICAgIC8vIDlcbiAgICAgIChlIF4gZTQgXiBlOCkgPDwgOCBeICAgIC8vIEQgKDEzKVxuICAgICAgKGUgXiBlMiBeIGU4KTsgICAgICAgICAgLy8gQiAoMTEpXG4gICAgLy8gcHJvZHVjZSBlYWNoIG9mIHRoZSBtaXggdGFibGVzIGJ5IHJvdGF0aW5nIHRoZSAyLDEsMSwzIHZhbHVlXG4gICAgZm9yKHZhciBuID0gMDsgbiA8IDQ7ICsrbikge1xuICAgICAgbWl4W25dW2VdID0gbWU7XG4gICAgICBpbWl4W25dW3N4XSA9IGltZTtcbiAgICAgIC8vIGN5Y2xlIHRoZSByaWdodCBtb3N0IGJ5dGUgdG8gdGhlIGxlZnQgbW9zdCBwb3NpdGlvblxuICAgICAgLy8gaWU6IDIsMSwxLDMgYmVjb21lcyAzLDIsMSwxXG4gICAgICBtZSA9IG1lIDw8IDI0IHwgbWUgPj4+IDg7XG4gICAgICBpbWUgPSBpbWUgPDwgMjQgfCBpbWUgPj4+IDg7XG4gICAgfVxuXG4gICAgLy8gZ2V0IG5leHQgZWxlbWVudCBhbmQgaW52ZXJzZVxuICAgIGlmKGUgPT09IDApIHtcbiAgICAgIC8vIDEgaXMgdGhlIGludmVyc2Ugb2YgMVxuICAgICAgZSA9IGVpID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZSA9IDJlICsgMioyKjIqKDEwZSkpID0gbXVsdGlwbHkgZSBieSA4MiAoY2hvc2VuIGdlbmVyYXRvcilcbiAgICAgIC8vIGVpID0gZWkgKyAyKjIqZWkgPSBtdWx0aXBseSBlaSBieSA1IChpbnZlcnNlIGdlbmVyYXRvcilcbiAgICAgIGUgPSBlMiBeIHh0aW1lW3h0aW1lW3h0aW1lW2UyIF4gZThdXV07XG4gICAgICBlaSBePSB4dGltZVt4dGltZVtlaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleSBzY2hlZHVsZSB1c2luZyB0aGUgQUVTIGtleSBleHBhbnNpb24gYWxnb3JpdGhtLlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHRha2VzIHRoZSBDaXBoZXIgS2V5LCBLLCBhbmQgcGVyZm9ybXMgYSBLZXkgRXhwYW5zaW9uXG4gKiByb3V0aW5lIHRvIGdlbmVyYXRlIGEga2V5IHNjaGVkdWxlLiBUaGUgS2V5IEV4cGFuc2lvbiBnZW5lcmF0ZXMgYSB0b3RhbFxuICogb2YgTmIqKE5yICsgMSkgd29yZHM6IHRoZSBhbGdvcml0aG0gcmVxdWlyZXMgYW4gaW5pdGlhbCBzZXQgb2YgTmIgd29yZHMsXG4gKiBhbmQgZWFjaCBvZiB0aGUgTnIgcm91bmRzIHJlcXVpcmVzIE5iIHdvcmRzIG9mIGtleSBkYXRhLiBUaGUgcmVzdWx0aW5nXG4gKiBrZXkgc2NoZWR1bGUgY29uc2lzdHMgb2YgYSBsaW5lYXIgYXJyYXkgb2YgNC1ieXRlIHdvcmRzLCBkZW5vdGVkIFt3aSBdLFxuICogd2l0aCBpIGluIHRoZSByYW5nZSAwIOKJpCBpIDwgTmIoTnIgKyAxKS5cbiAqXG4gKiBLZXlFeHBhbnNpb24oYnl0ZSBrZXlbNCpOa10sIHdvcmQgd1tOYiooTnIrMSldLCBOaylcbiAqIEFFUy0xMjggKE5iPTQsIE5rPTQsIE5yPTEwKVxuICogQUVTLTE5MiAoTmI9NCwgTms9NiwgTnI9MTIpXG4gKiBBRVMtMjU2IChOYj00LCBOaz04LCBOcj0xNClcbiAqIE5vdGU6IE5yPU5rKzYuXG4gKlxuICogTmIgaXMgdGhlIG51bWJlciBvZiBjb2x1bW5zICgzMi1iaXQgd29yZHMpIGNvbXByaXNpbmcgdGhlIFN0YXRlIChvclxuICogbnVtYmVyIG9mIGJ5dGVzIGluIGEgYmxvY2spLiBGb3IgQUVTLCBOYj00LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBzY2hlZHVsZSAoYXMgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gbW9kaWZ5IHRoZSBrZXkgc2NoZWR1bGUgdG8gZGVjcnlwdCwgZmFsc2Ugbm90IHRvLlxuICpcbiAqIEByZXR1cm4gdGhlIGdlbmVyYXRlZCBrZXkgc2NoZWR1bGUuXG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRLZXkoa2V5LCBkZWNyeXB0KSB7XG4gIC8vIGNvcHkgdGhlIGtleSdzIHdvcmRzIHRvIGluaXRpYWxpemUgdGhlIGtleSBzY2hlZHVsZVxuICB2YXIgdyA9IGtleS5zbGljZSgwKTtcblxuICAvKiBSb3RXb3JkKCkgd2lsbCByb3RhdGUgYSB3b3JkLCBtb3ZpbmcgdGhlIGZpcnN0IGJ5dGUgdG8gdGhlIGxhc3RcbiAgICBieXRlJ3MgcG9zaXRpb24gKHNoaWZ0aW5nIHRoZSBvdGhlciBieXRlcyBsZWZ0KS5cblxuICAgIFdlIHdpbGwgYmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgUmNvbiBhdCBpIC8gTmsuICdpJyB3aWxsIGl0ZXJhdGVcbiAgICBmcm9tIE5rIHRvIChOYiAqIE5yKzEpLiBOayA9IDQgKDQgYnl0ZSBrZXkpLCBOYiA9IDQgKDQgd29yZHMgaW5cbiAgICBhIGJsb2NrKSwgTnIgPSBOayArIDYgKDEwKS4gVGhlcmVmb3JlICdpJyB3aWxsIGl0ZXJhdGUgZnJvbVxuICAgIDQgdG8gNDQgKGV4Y2x1c2l2ZSkuIEVhY2ggdGltZSB3ZSBpdGVyYXRlIDQgdGltZXMsIGkgLyBOayB3aWxsXG4gICAgaW5jcmVhc2UgYnkgMS4gV2UgdXNlIGEgY291bnRlciBpTmsgdG8ga2VlcCB0cmFjayBvZiB0aGlzLlxuICAgKi9cblxuICAvLyBnbyB0aHJvdWdoIHRoZSByb3VuZHMgZXhwYW5kaW5nIHRoZSBrZXlcbiAgdmFyIHRlbXAsIGlOayA9IDE7XG4gIHZhciBOayA9IHcubGVuZ3RoO1xuICB2YXIgTnIxID0gTmsgKyA2ICsgMTtcbiAgdmFyIGVuZCA9IE5iICogTnIxO1xuICBmb3IodmFyIGkgPSBOazsgaSA8IGVuZDsgKytpKSB7XG4gICAgdGVtcCA9IHdbaSAtIDFdO1xuICAgIGlmKGkgJSBOayA9PT0gMCkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQoUm90V29yZCh0ZW1wKSkgXiBSY29uW2kgLyBOa11cbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDE2ICYgMjU1XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gOCAmIDI1NV0gPDwgMTYgXlxuICAgICAgICBzYm94W3RlbXAgJiAyNTVdIDw8IDggXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSBeIChyY29uW2lOa10gPDwgMjQpO1xuICAgICAgaU5rKys7XG4gICAgfSBlbHNlIGlmKE5rID4gNiAmJiAoaSAlIE5rID09PSA0KSkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQodGVtcClcbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gMTYgJiAyNTVdIDw8IDE2IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiA4ICYgMjU1XSA8PCA4IF5cbiAgICAgICAgc2JveFt0ZW1wICYgMjU1XTtcbiAgICB9XG4gICAgd1tpXSA9IHdbaSAtIE5rXSBeIHRlbXA7XG4gIH1cblxuICAgLyogV2hlbiB3ZSBhcmUgdXBkYXRpbmcgYSBjaXBoZXIgYmxvY2sgd2UgYWx3YXlzIHVzZSB0aGUgY29kZSBwYXRoIGZvclxuICAgICBlbmNyeXB0aW9uIHdoZXRoZXIgd2UgYXJlIGRlY3J5cHRpbmcgb3Igbm90ICh0byBzaG9ydGVuIGNvZGUgYW5kXG4gICAgIHNpbXBsaWZ5IHRoZSBnZW5lcmF0aW9uIG9mIGxvb2sgdXAgdGFibGVzKS4gSG93ZXZlciwgYmVjYXVzZSB0aGVyZVxuICAgICBhcmUgZGlmZmVyZW5jZXMgaW4gdGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtLCBvdGhlciB0aGFuIGp1c3Qgc3dhcHBpbmdcbiAgICAgaW4gZGlmZmVyZW50IGxvb2sgdXAgdGFibGVzLCB3ZSBtdXN0IHRyYW5zZm9ybSBvdXIga2V5IHNjaGVkdWxlIHRvXG4gICAgIGFjY291bnQgZm9yIHRoZXNlIGNoYW5nZXM6XG5cbiAgICAgMS4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGdldHMgaXRzIGtleSByb3VuZHMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgMi4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGFkZHMgdGhlIHJvdW5kIGtleSBiZWZvcmUgbWl4aW5nIGNvbHVtbnNcbiAgICAgICBpbnN0ZWFkIG9mIGFmdGVyd2FyZHMuXG5cbiAgICAgV2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgb3VyIGtleSBzY2hlZHVsZSB0byBoYW5kbGUgdGhlIGZpcnN0IGNhc2UsXG4gICAgIHdlIGNhbiBqdXN0IHRyYXZlcnNlIHRoZSBrZXkgc2NoZWR1bGUgaW4gcmV2ZXJzZSBvcmRlciB3aGVuIGRlY3J5cHRpbmcuXG5cbiAgICAgVGhlIHNlY29uZCBjYXNlIHJlcXVpcmVzIGEgbGl0dGxlIHdvcmsuXG5cbiAgICAgVGhlIHRhYmxlcyB3ZSBidWlsdCBmb3IgcGVyZm9ybWluZyByb3VuZHMgd2lsbCB0YWtlIGFuIGlucHV0IGFuZCB0aGVuXG4gICAgIHBlcmZvcm0gU3ViQnl0ZXMoKSBhbmQgTWl4Q29sdW1ucygpIG9yLCBmb3IgdGhlIGRlY3J5cHQgdmVyc2lvbixcbiAgICAgSW52U3ViQnl0ZXMoKSBhbmQgSW52TWl4Q29sdW1ucygpLiBCdXQgdGhlIGRlY3J5cHQgYWxnb3JpdGhtIHJlcXVpcmVzXG4gICAgIHVzIHRvIEFkZFJvdW5kS2V5KCkgYmVmb3JlIEludk1peENvbHVtbnMoKS4gVGhpcyBtZWFucyB3ZSdsbCBuZWVkIHRvXG4gICAgIGFwcGx5IHNvbWUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByb3VuZCBrZXkgdG8gaW52ZXJzZS1taXggaXRzIGNvbHVtbnNcbiAgICAgc28gdGhleSdsbCBiZSBjb3JyZWN0IGZvciBtb3ZpbmcgQWRkUm91bmRLZXkoKSB0byBhZnRlciB0aGUgc3RhdGUgaGFzXG4gICAgIGhhZCBpdHMgY29sdW1ucyBpbnZlcnNlLW1peGVkLlxuXG4gICAgIFRvIGludmVyc2UtbWl4IHRoZSBjb2x1bW5zIG9mIHRoZSBzdGF0ZSB3aGVuIHdlJ3JlIGRlY3J5cHRpbmcgd2UgdXNlIGFcbiAgICAgbG9va3VwIHRhYmxlIHRoYXQgd2lsbCBhcHBseSBJbnZTdWJCeXRlcygpIGFuZCBJbnZNaXhDb2x1bW5zKCkgYXQgdGhlXG4gICAgIHNhbWUgdGltZS4gSG93ZXZlciwgdGhlIHJvdW5kIGtleSdzIGJ5dGVzIGFyZSBub3QgaW52ZXJzZS1zdWJzdGl0dXRlZFxuICAgICBpbiB0aGUgZGVjcnlwdGlvbiBhbGdvcml0aG0uIFRvIGdldCBhcm91bmQgdGhpcyBwcm9ibGVtLCB3ZSBjYW4gZmlyc3RcbiAgICAgc3Vic3RpdHV0ZSB0aGUgYnl0ZXMgaW4gdGhlIHJvdW5kIGtleSBzbyB0aGF0IHdoZW4gd2UgYXBwbHkgdGhlXG4gICAgIHRyYW5zZm9ybWF0aW9uIHZpYSB0aGUgSW52U3ViQnl0ZXMoKStJbnZNaXhDb2x1bW5zKCkgdGFibGUsIGl0IHdpbGxcbiAgICAgdW5kbyBvdXIgc3Vic3RpdHV0aW9uIGxlYXZpbmcgdXMgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUgdGhhdCB3ZVxuICAgICB3YW50IC0tIGFuZCB0aGVuIGludmVyc2UtbWl4IHRoYXQgdmFsdWUuXG5cbiAgICAgVGhpcyBjaGFuZ2Ugd2lsbCBjb3JyZWN0bHkgYWx0ZXIgb3VyIGtleSBzY2hlZHVsZSBzbyB0aGF0IHdlIGNhbiBYT1JcbiAgICAgZWFjaCByb3VuZCBrZXkgd2l0aCBvdXIgYWxyZWFkeSB0cmFuc2Zvcm1lZCBkZWNyeXB0aW9uIHN0YXRlLiBUaGlzXG4gICAgIGFsbG93cyB1cyB0byB1c2UgdGhlIHNhbWUgY29kZSBwYXRoIGFzIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobS5cblxuICAgICBXZSBtYWtlIG9uZSBtb3JlIGNoYW5nZSB0byB0aGUgZGVjcnlwdGlvbiBrZXkuIFNpbmNlIHRoZSBkZWNyeXB0aW9uXG4gICAgIGFsZ29yaXRobSBydW5zIGluIHJldmVyc2UgZnJvbSB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0sIHdlIHJldmVyc2VcbiAgICAgdGhlIG9yZGVyIG9mIHRoZSByb3VuZCBrZXlzIHRvIGF2b2lkIGhhdmluZyB0byBpdGVyYXRlIG92ZXIgdGhlIGtleVxuICAgICBzY2hlZHVsZSBiYWNrd2FyZHMgd2hlbiBydW5uaW5nIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBsYXRlciBpblxuICAgICBkZWNyeXB0aW9uIG1vZGUuIEluIGFkZGl0aW9uIHRvIHJldmVyc2luZyB0aGUgb3JkZXIgb2YgdGhlIHJvdW5kIGtleXMsXG4gICAgIHdlIGFsc28gc3dhcCBlYWNoIHJvdW5kIGtleSdzIDJuZCBhbmQgNHRoIHJvd3MuIFNlZSB0aGUgY29tbWVudHNcbiAgICAgc2VjdGlvbiB3aGVyZSByb3VuZHMgYXJlIHBlcmZvcm1lZCBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoeSB0aGlzIGlzXG4gICAgIGRvbmUuIFRoZXNlIGNoYW5nZXMgYXJlIGRvbmUgaW5saW5lIHdpdGggdGhlIG90aGVyIHN1YnN0aXR1dGlvblxuICAgICBkZXNjcmliZWQgYWJvdmUuXG4gICovXG4gIGlmKGRlY3J5cHQpIHtcbiAgICB2YXIgdG1wO1xuICAgIHZhciBtMCA9IGltaXhbMF07XG4gICAgdmFyIG0xID0gaW1peFsxXTtcbiAgICB2YXIgbTIgPSBpbWl4WzJdO1xuICAgIHZhciBtMyA9IGltaXhbM107XG4gICAgdmFyIHduZXcgPSB3LnNsaWNlKDApO1xuICAgIGVuZCA9IHcubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIHdpID0gZW5kIC0gTmI7IGkgPCBlbmQ7IGkgKz0gTmIsIHdpIC09IE5iKSB7XG4gICAgICAvLyBkbyBub3Qgc3ViIHRoZSBmaXJzdCBvciBsYXN0IHJvdW5kIGtleSAocm91bmQga2V5cyBhcmUgTmJcbiAgICAgIC8vIHdvcmRzKSBhcyBubyBjb2x1bW4gbWl4aW5nIGlzIHBlcmZvcm1lZCBiZWZvcmUgdGhleSBhcmUgYWRkZWQsXG4gICAgICAvLyBidXQgZG8gY2hhbmdlIHRoZSBrZXkgb3JkZXJcbiAgICAgIGlmKGkgPT09IDAgfHwgaSA9PT0gKGVuZCAtIE5iKSkge1xuICAgICAgICB3bmV3W2ldID0gd1t3aV07XG4gICAgICAgIHduZXdbaSArIDFdID0gd1t3aSArIDNdO1xuICAgICAgICB3bmV3W2kgKyAyXSA9IHdbd2kgKyAyXTtcbiAgICAgICAgd25ld1tpICsgM10gPSB3W3dpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWJzdGl0dXRlIGVhY2ggcm91bmQga2V5IGJ5dGUgYmVjYXVzZSB0aGUgaW52ZXJzZS1taXhcbiAgICAgICAgLy8gdGFibGUgd2lsbCBpbnZlcnNlLXN1YnN0aXR1dGUgaXQgKGVmZmVjdGl2ZWx5IGNhbmNlbCB0aGVcbiAgICAgICAgLy8gc3Vic3RpdHV0aW9uIGJlY2F1c2Ugcm91bmQga2V5IGJ5dGVzIGFyZW4ndCBzdWInZCBpblxuICAgICAgICAvLyBkZWNyeXB0aW9uIG1vZGUpIGFuZCBzd2FwIGluZGV4ZXMgMyBhbmQgMVxuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgTmI7ICsrbikge1xuICAgICAgICAgIHRtcCA9IHdbd2kgKyBuXTtcbiAgICAgICAgICB3bmV3W2kgKyAoMyYtbildID1cbiAgICAgICAgICAgIG0wW3Nib3hbdG1wID4+PiAyNF1dIF5cbiAgICAgICAgICAgIG0xW3Nib3hbdG1wID4+PiAxNiAmIDI1NV1dIF5cbiAgICAgICAgICAgIG0yW3Nib3hbdG1wID4+PiA4ICYgMjU1XV0gXlxuICAgICAgICAgICAgbTNbc2JveFt0bXAgJiAyNTVdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3ID0gd25ldztcbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDE2IGJ5dGVzKSB1c2luZyBBRVMuIFRoZSB1cGRhdGUgd2lsbCBlaXRoZXJcbiAqIGVuY3J5cHQgb3IgZGVjcnlwdCB0aGUgYmxvY2suXG4gKlxuICogQHBhcmFtIHcgdGhlIGtleSBzY2hlZHVsZS5cbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgYmxvY2sgKGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSB1cGRhdGVkIG91dHB1dCBibG9jay5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZGVjcnlwdCB0aGUgYmxvY2ssIGZhbHNlIHRvIGVuY3J5cHQgaXQuXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayh3LCBpbnB1dCwgb3V0cHV0LCBkZWNyeXB0KSB7XG4gIC8qXG4gIENpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBmb3Igcm91bmQgPSAxIHN0ZXAgMSB0byBOcuKAkzFcbiAgICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgICAgTWl4Q29sdW1ucyhzdGF0ZSlcbiAgICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W3JvdW5kKk5iLCAocm91bmQrMSkqTmItMV0pXG4gICAgZW5kIGZvclxuICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuXG4gIEludkNpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIGZvciByb3VuZCA9IE5yLTEgc3RlcCAtMSBkb3dudG8gMVxuICAgICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgICAgSW52U3ViQnl0ZXMoc3RhdGUpXG4gICAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tyb3VuZCpOYiwgKHJvdW5kKzEpKk5iLTFdKVxuICAgICAgSW52TWl4Q29sdW1ucyhzdGF0ZSlcbiAgICBlbmQgZm9yXG4gICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgIEludlN1YkJ5dGVzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuICAqL1xuXG4gIC8vIEVuY3J5cHQ6IEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAvLyBEZWNyeXB0OiBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICB2YXIgTnIgPSB3Lmxlbmd0aCAvIDQgLSAxO1xuICB2YXIgbTAsIG0xLCBtMiwgbTMsIHN1YjtcbiAgaWYoZGVjcnlwdCkge1xuICAgIG0wID0gaW1peFswXTtcbiAgICBtMSA9IGltaXhbMV07XG4gICAgbTIgPSBpbWl4WzJdO1xuICAgIG0zID0gaW1peFszXTtcbiAgICBzdWIgPSBpc2JveDtcbiAgfSBlbHNlIHtcbiAgICBtMCA9IG1peFswXTtcbiAgICBtMSA9IG1peFsxXTtcbiAgICBtMiA9IG1peFsyXTtcbiAgICBtMyA9IG1peFszXTtcbiAgICBzdWIgPSBzYm94O1xuICB9XG4gIHZhciBhLCBiLCBjLCBkLCBhMiwgYjIsIGMyO1xuICBhID0gaW5wdXRbMF0gXiB3WzBdO1xuICBiID0gaW5wdXRbZGVjcnlwdCA/IDMgOiAxXSBeIHdbMV07XG4gIGMgPSBpbnB1dFsyXSBeIHdbMl07XG4gIGQgPSBpbnB1dFtkZWNyeXB0ID8gMSA6IDNdIF4gd1szXTtcbiAgdmFyIGkgPSAzO1xuXG4gIC8qIEluIG9yZGVyIHRvIHNoYXJlIGNvZGUgd2UgZm9sbG93IHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB3aGVuIGJvdGhcbiAgICBlbmNyeXB0aW5nIGFuZCBkZWNyeXB0aW5nLiBUbyBhY2NvdW50IGZvciB0aGUgY2hhbmdlcyByZXF1aXJlZCBpbiB0aGVcbiAgICBkZWNyeXB0aW9uIGFsZ29yaXRobSwgd2UgdXNlIGRpZmZlcmVudCBsb29rdXAgdGFibGVzIHdoZW4gZGVjcnlwdGluZ1xuICAgIGFuZCB1c2UgYSBtb2RpZmllZCBrZXkgc2NoZWR1bGUgdG8gYWNjb3VudCBmb3IgdGhlIGRpZmZlcmVuY2UgaW4gdGhlXG4gICAgb3JkZXIgb2YgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHJvdW5kcy4gV2UgYWxzbyBnZXRcbiAgICBrZXkgcm91bmRzIGluIHJldmVyc2Ugb3JkZXIgKHJlbGF0aXZlIHRvIGVuY3J5cHRpb24pLiAqL1xuICBmb3IodmFyIHJvdW5kID0gMTsgcm91bmQgPCBOcjsgKytyb3VuZCkge1xuICAgIC8qIEFzIGRlc2NyaWJlZCBhYm92ZSwgd2UnbGwgYmUgdXNpbmcgdGFibGUgbG9va3VwcyB0byBwZXJmb3JtIHRoZVxuICAgICAgY29sdW1uIG1peGluZy4gRWFjaCBjb2x1bW4gaXMgc3RvcmVkIGFzIGEgd29yZCBpbiB0aGUgc3RhdGUgKHRoZVxuICAgICAgYXJyYXkgJ2lucHV0JyBoYXMgb25lIGNvbHVtbiBhcyBhIHdvcmQgYXQgZWFjaCBpbmRleCkuIEluIG9yZGVyIHRvXG4gICAgICBtaXggYSBjb2x1bW4sIHdlIHBlcmZvcm0gdGhlc2UgdHJhbnNmb3JtYXRpb25zIG9uIGVhY2ggcm93IGluIGMsXG4gICAgICB3aGljaCBpcyAxIGJ5dGUgaW4gZWFjaCB3b3JkLiBUaGUgbmV3IGNvbHVtbiBmb3IgYzAgaXMgYycwOlxuXG4gICAgICAgICAgICAgICBtMCAgICAgIG0xICAgICAgbTIgICAgICBtM1xuICAgICAgcjAsYycwID0gMipyMCxjMCArIDMqcjEsYzAgKyAxKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjEsYycwID0gMSpyMCxjMCArIDIqcjEsYzAgKyAzKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjIsYycwID0gMSpyMCxjMCArIDEqcjEsYzAgKyAyKnIyLGMwICsgMypyMyxjMFxuICAgICAgcjMsYycwID0gMypyMCxjMCArIDEqcjEsYzAgKyAxKnIyLGMwICsgMipyMyxjMFxuXG4gICAgICBTbyB1c2luZyBtaXggdGFibGVzIHdoZXJlIGMwIGlzIGEgd29yZCB3aXRoIHIwIGJlaW5nIGl0cyB1cHBlclxuICAgICAgOCBiaXRzIGFuZCByMyBiZWluZyBpdHMgbG93ZXIgOCBiaXRzOlxuXG4gICAgICBtMFtjMCA+PiAyNF0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsyKnIwLDEqcjAsMSpyMCwzKnIwXVxuICAgICAgLi4uXG4gICAgICBtM1tjMCAmIDI1NV0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsxKnIzLDEqcjMsMypyMywyKnIzXVxuXG4gICAgICBUaGVyZWZvcmUgdG8gbWl4IHRoZSBjb2x1bW5zIGluIGVhY2ggd29yZCBpbiB0aGUgc3RhdGUgd2VcbiAgICAgIGRvIHRoZSBmb2xsb3dpbmcgKCYgMjU1IG9taXR0ZWQgZm9yIGJyZXZpdHkpOlxuICAgICAgYycwLHIwID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cbiAgICAgIGMnMCxyMSA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG4gICAgICBjJzAscjIgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuICAgICAgYycwLHIzID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cblxuICAgICAgSG93ZXZlciwgYmVmb3JlIG1peGluZywgdGhlIGFsZ29yaXRobSByZXF1aXJlcyB1cyB0byBwZXJmb3JtXG4gICAgICBTaGlmdFJvd3MoKS4gVGhlIFNoaWZ0Um93cygpIHRyYW5zZm9ybWF0aW9uIGN5Y2xpY2FsbHkgc2hpZnRzIHRoZVxuICAgICAgbGFzdCAzIHJvd3Mgb2YgdGhlIHN0YXRlIG92ZXIgZGlmZmVyZW50IG9mZnNldHMuIFRoZSBmaXJzdCByb3dcbiAgICAgIChyID0gMCkgaXMgbm90IHNoaWZ0ZWQuXG5cbiAgICAgIHMnX3IsYyA9IHNfciwoYyArIHNoaWZ0KHIsIE5iKSBtb2QgTmJcbiAgICAgIGZvciAwIDwgciA8IDQgYW5kIDAgPD0gYyA8IE5iIGFuZFxuICAgICAgc2hpZnQoMSwgNCkgPSAxXG4gICAgICBzaGlmdCgyLCA0KSA9IDJcbiAgICAgIHNoaWZ0KDMsIDQpID0gMy5cblxuICAgICAgVGhpcyBjYXVzZXMgdGhlIGZpcnN0IGJ5dGUgaW4gciA9IDEgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDIgYnl0ZXMgaW4gciA9IDIgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDMgYnl0ZXMgaW4gciA9IDMgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdzpcblxuICAgICAgcjE6IFtjMCBjMSBjMiBjM10gPT4gW2MxIGMyIGMzIGMwXVxuICAgICAgcjI6IFtjMCBjMSBjMiBjM10gICAgW2MyIGMzIGMwIGMxXVxuICAgICAgcjM6IFtjMCBjMSBjMiBjM10gICAgW2MzIGMwIGMxIGMyXVxuXG4gICAgICBXZSBjYW4gbWFrZSB0aGVzZSBzdWJzdGl0dXRpb25zIGlubGluZSB3aXRoIG91ciBjb2x1bW4gbWl4aW5nIHRvXG4gICAgICBnZW5lcmF0ZSBhbiB1cGRhdGVkIHNldCBvZiBlcXVhdGlvbnMgdG8gcHJvZHVjZSBlYWNoIHdvcmQgaW4gdGhlXG4gICAgICBzdGF0ZSAobm90ZSB0aGUgY29sdW1ucyBoYXZlIGNoYW5nZWQgcG9zaXRpb25zKTpcblxuICAgICAgYzAgYzEgYzIgYzMgPT4gYzAgYzEgYzIgYzNcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMxIGMyIGMzIGMwICAoY3ljbGVkIDEgYnl0ZSlcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMyIGMzIGMwIGMxICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMyBjMCBjMSBjMiAgKGN5Y2xlZCAzIGJ5dGVzKVxuXG4gICAgICBUaGVyZWZvcmU6XG5cbiAgICAgIGMnMCA9IDIqcjAsYzAgKyAzKnIxLGMxICsgMSpyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAyKnIxLGMxICsgMypyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAxKnIxLGMxICsgMipyMixjMiArIDMqcjMsYzNcbiAgICAgIGMnMCA9IDMqcjAsYzAgKyAxKnIxLGMxICsgMSpyMixjMiArIDIqcjMsYzNcblxuICAgICAgYycxID0gMipyMCxjMSArIDMqcjEsYzIgKyAxKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDIqcjEsYzIgKyAzKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDEqcjEsYzIgKyAyKnIyLGMzICsgMypyMyxjMFxuICAgICAgYycxID0gMypyMCxjMSArIDEqcjEsYzIgKyAxKnIyLGMzICsgMipyMyxjMFxuXG4gICAgICAuLi4gYW5kIHNvIGZvcnRoIGZvciBjJzIgYW5kIGMnMy4gVGhlIGltcG9ydGFudCBkaXN0aW5jdGlvbiBpc1xuICAgICAgdGhhdCB0aGUgY29sdW1ucyBhcmUgY3ljbGluZywgd2l0aCBjMCBiZWluZyB1c2VkIHdpdGggdGhlIG0wXG4gICAgICBtYXAgd2hlbiBjYWxjdWxhdGluZyBjMCwgYnV0IGMxIGJlaW5nIHVzZWQgd2l0aCB0aGUgbTAgbWFwIHdoZW5cbiAgICAgIGNhbGN1bGF0aW5nIGMxIC4uLiBhbmQgc28gZm9ydGguXG5cbiAgICAgIFdoZW4gcGVyZm9ybWluZyB0aGUgaW52ZXJzZSB3ZSB0cmFuc2Zvcm0gdGhlIG1pcnJvciBpbWFnZSBhbmRcbiAgICAgIHNraXAgdGhlIGJvdHRvbSByb3csIGluc3RlYWQgb2YgdGhlIHRvcCBvbmUsIGFuZCBtb3ZlIHVwd2FyZHM6XG5cbiAgICAgIGMzIGMyIGMxIGMwID0+IGMwIGMzIGMyIGMxICAoY3ljbGVkIDMgYnl0ZXMpICpzYW1lIGFzIGVuY3J5cHRpb25cbiAgICAgIGMzIGMyIGMxIGMwICAgIGMxIGMwIGMzIGMyICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMiBjMSBjMCBjMyAgKGN5Y2xlZCAxIGJ5dGUpICAqc2FtZSBhcyBlbmNyeXB0aW9uXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMyBjMiBjMSBjMFxuXG4gICAgICBJZiB5b3UgY29tcGFyZSB0aGUgcmVzdWx0aW5nIG1hdHJpY2VzIGZvciBTaGlmdFJvd3MoKStNaXhDb2x1bW5zKClcbiAgICAgIGFuZCBmb3IgSW52U2hpZnRSb3dzKCkrSW52TWl4Q29sdW1ucygpIHRoZSAybmQgYW5kIDR0aCBjb2x1bW5zIGFyZVxuICAgICAgZGlmZmVyZW50IChpbiBlbmNyeXB0IG1vZGUgdnMuIGRlY3J5cHQgbW9kZSkuIFNvIGluIG9yZGVyIHRvIHVzZVxuICAgICAgdGhlIHNhbWUgY29kZSB0byBoYW5kbGUgYm90aCBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLCB3ZSB3aWxsXG4gICAgICBuZWVkIHRvIGRvIHNvbWUgbWFwcGluZy5cblxuICAgICAgSWYgaW4gZW5jcnlwdGlvbiBtb2RlIHdlIGxldCBhPWMwLCBiPWMxLCBjPWMyLCBkPWMzLCBhbmQgcjxOPiBiZVxuICAgICAgYSByb3cgbnVtYmVyIGluIHRoZSBzdGF0ZSwgdGhlbiB0aGUgcmVzdWx0aW5nIG1hdHJpeCBpbiBlbmNyeXB0aW9uXG4gICAgICBtb2RlIGZvciBhcHBseWluZyB0aGUgYWJvdmUgdHJhbnNmb3JtYXRpb25zIHdvdWxkIGJlOlxuXG4gICAgICByMTogYSBiIGMgZFxuICAgICAgcjI6IGIgYyBkIGFcbiAgICAgIHIzOiBjIGQgYSBiXG4gICAgICByNDogZCBhIGIgY1xuXG4gICAgICBJZiB3ZSBkaWQgdGhlIHNhbWUgaW4gZGVjcnlwdGlvbiBtb2RlIHdlIHdvdWxkIGdldDpcblxuICAgICAgcjE6IGEgZCBjIGJcbiAgICAgIHIyOiBiIGEgZCBjXG4gICAgICByMzogYyBiIGEgZFxuICAgICAgcjQ6IGQgYyBiIGFcblxuICAgICAgSWYgaW5zdGVhZCB3ZSBzd2FwIGQgYW5kIGIgKHNldCBiPWMzIGFuZCBkPWMxKSwgdGhlbiB3ZSBnZXQ6XG5cbiAgICAgIHIxOiBhIGIgYyBkXG4gICAgICByMjogZCBhIGIgY1xuICAgICAgcjM6IGMgZCBhIGJcbiAgICAgIHI0OiBiIGMgZCBhXG5cbiAgICAgIE5vdyB0aGUgMXN0IGFuZCAzcmQgcm93cyBhcmUgdGhlIHNhbWUgYXMgdGhlIGVuY3J5cHRpb24gbWF0cml4LiBBbGxcbiAgICAgIHdlIG5lZWQgdG8gZG8gdGhlbiB0byBtYWtlIHRoZSBtYXBwaW5nIGV4YWN0bHkgdGhlIHNhbWUgaXMgdG8gc3dhcFxuICAgICAgdGhlIDJuZCBhbmQgNHRoIHJvd3Mgd2hlbiBpbiBkZWNyeXB0aW9uIG1vZGUuIFRvIGRvIHRoaXMgd2l0aG91dFxuICAgICAgaGF2aW5nIHRvIGRvIGl0IG9uIGVhY2ggaXRlcmF0aW9uLCB3ZSBzd2FwcGVkIHRoZSAybmQgYW5kIDR0aCByb3dzXG4gICAgICBpbiB0aGUgZGVjcnlwdGlvbiBrZXkgc2NoZWR1bGUuIFdlIGFsc28gaGF2ZSB0byBkbyB0aGUgc3dhcCBhYm92ZVxuICAgICAgd2hlbiB3ZSBmaXJzdCBwdWxsIGluIHRoZSBpbnB1dCBhbmQgd2hlbiB3ZSBzZXQgdGhlIGZpbmFsIG91dHB1dC4gKi9cbiAgICBhMiA9XG4gICAgICBtMFthID4+PiAyNF0gXlxuICAgICAgbTFbYiA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2MgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2QgJiAyNTVdIF4gd1srK2ldO1xuICAgIGIyID1cbiAgICAgIG0wW2IgPj4+IDI0XSBeXG4gICAgICBtMVtjID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbZCA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYSAmIDI1NV0gXiB3WysraV07XG4gICAgYzIgPVxuICAgICAgbTBbYyA+Pj4gMjRdIF5cbiAgICAgIG0xW2QgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMlthID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1tiICYgMjU1XSBeIHdbKytpXTtcbiAgICBkID1cbiAgICAgIG0wW2QgPj4+IDI0XSBeXG4gICAgICBtMVthID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbYiA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYyAmIDI1NV0gXiB3WysraV07XG4gICAgYSA9IGEyO1xuICAgIGIgPSBiMjtcbiAgICBjID0gYzI7XG4gIH1cblxuICAvKlxuICAgIEVuY3J5cHQ6XG4gICAgU3ViQnl0ZXMoc3RhdGUpXG4gICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W05yKk5iLCAoTnIrMSkqTmItMV0pXG5cbiAgICBEZWNyeXB0OlxuICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICBJbnZTdWJCeXRlcyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICovXG4gICAvLyBOb3RlOiByb3dzIGFyZSBzaGlmdGVkIGlubGluZVxuICBvdXRwdXRbMF0gPVxuICAgIChzdWJbYSA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltiID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2MgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2QgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0W2RlY3J5cHQgPyAzIDogMV0gPVxuICAgIChzdWJbYiA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltjID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2QgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2EgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0WzJdID1cbiAgICAoc3ViW2MgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbZCA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YlthID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltiICYgMjU1XSkgXiB3WysraV07XG4gIG91dHB1dFtkZWNyeXB0ID8gMSA6IDNdID1cbiAgICAoc3ViW2QgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbYSA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YltiID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltjICYgMjU1XSkgXiB3WysraV07XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBBRVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqICAgICAgICAgIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbW9kZSA9IChvcHRpb25zLm1vZGUgfHwgJ0NCQycpLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBhbGdvcml0aG0gPSAnQUVTLScgKyBtb2RlO1xuXG4gIHZhciBjaXBoZXI7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGlibGUgc3RhcnQgQVBJXG4gIHZhciBzdGFydCA9IGNpcGhlci5zdGFydDtcbiAgY2lwaGVyLnN0YXJ0ID0gZnVuY3Rpb24oaXYsIG9wdGlvbnMpIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogc3VwcG9ydCBzZWNvbmQgYXJnIGFzIG91dHB1dCBidWZmZXJcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZihvcHRpb25zIGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKSB7XG4gICAgICBvdXRwdXQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm91dHB1dCA9IG91dHB1dDtcbiAgICBvcHRpb25zLml2ID0gaXY7XG4gICAgc3RhcnQuY2FsbChjaXBoZXIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBiYXNpYyBQRU0gKFByaXZhY3kgRW5oYW5jZWQgTWFpbCkgYWxnb3JpdGhtcy5cbiAqXG4gKiBTZWU6IFJGQyAxNDIxLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBIEZvcmdlIFBFTSBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqIHR5cGU6IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgbWVzc2FnZSAoZWc6IFwiUlNBIFBSSVZBVEUgS0VZXCIpLlxuICpcbiAqIHByb2NUeXBlOiBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIHByb2Nlc3NpbmcgcGVyZm9ybWVkIG9uIHRoZSBtZXNzYWdlLFxuICogICBpdCBoYXMgdHdvIHN1YmZpZWxkczogdmVyc2lvbiBhbmQgdHlwZSwgZWc6IDQsRU5DUllQVEVELlxuICpcbiAqIGNvbnRlbnREb21haW46IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgY29udGVudCBpbiB0aGUgbWVzc2FnZSwgdHlwaWNhbGx5XG4gKiAgIG9ubHkgdXNlcyB0aGUgdmFsdWU6IFwiUkZDODIyXCIuXG4gKlxuICogZGVrSW5mbzogaWRlbnRpZmllcyB0aGUgbWVzc2FnZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBhbmQgbW9kZSBhbmQgaW5jbHVkZXNcbiAqICAgYW55IHBhcmFtZXRlcnMgZm9yIHRoZSBhbGdvcml0aG0sIGl0IGhhcyB0d28gc3ViZmllbGRzOiBhbGdvcml0aG0gYW5kXG4gKiAgIHBhcmFtZXRlcnMsIGVnOiBERVMtQ0JDLEY4MTQzRURFNTk2MEM1OTcuXG4gKlxuICogaGVhZGVyczogY29udGFpbnMgYWxsIG90aGVyIFBFTSBlbmNhcHN1bGF0ZWQgaGVhZGVycyAtLSB3aGVyZSBvcmRlciBpc1xuICogICBzaWduaWZpY2FudCAoZm9yIHBhaXJpbmcgZGF0YSBsaWtlIHJlY2lwaWVudCBJRCArIGtleSBpbmZvKS5cbiAqXG4gKiBib2R5OiB0aGUgYmluYXJ5LWVuY29kZWQgYm9keS5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIHNob3J0Y3V0IGZvciBwZW0gQVBJXG52YXIgcGVtID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wZW0gPSBmb3JnZS5wZW0gfHwge307XG5cbi8qKlxuICogRW5jb2RlcyAoc2VyaWFsaXplcykgdGhlIGdpdmVuIFBFTSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1zZyB0aGUgUEVNIG1lc3NhZ2Ugb2JqZWN0IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSBmb3IgdGhlIGJvZHksIChkZWZhdWx0OiA2NCkuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbnBlbS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBydmFsID0gJy0tLS0tQkVHSU4gJyArIG1zZy50eXBlICsgJy0tLS0tXFxyXFxuJztcblxuICAvLyBlbmNvZGUgc3BlY2lhbCBoZWFkZXJzXG4gIHZhciBoZWFkZXI7XG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIGhlYWRlciA9IHtcbiAgICAgIG5hbWU6ICdQcm9jLVR5cGUnLFxuICAgICAgdmFsdWVzOiBbU3RyaW5nKG1zZy5wcm9jVHlwZS52ZXJzaW9uKSwgbXNnLnByb2NUeXBlLnR5cGVdXG4gICAgfTtcbiAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgfVxuICBpZihtc2cuY29udGVudERvbWFpbikge1xuICAgIGhlYWRlciA9IHtuYW1lOiAnQ29udGVudC1Eb21haW4nLCB2YWx1ZXM6IFttc2cuY29udGVudERvbWFpbl19O1xuICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICB9XG4gIGlmKG1zZy5kZWtJbmZvKSB7XG4gICAgaGVhZGVyID0ge25hbWU6ICdERUstSW5mbycsIHZhbHVlczogW21zZy5kZWtJbmZvLmFsZ29yaXRobV19O1xuICAgIGlmKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpIHtcbiAgICAgIGhlYWRlci52YWx1ZXMucHVzaChtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgcnZhbCArPSBmb2xkSGVhZGVyKGhlYWRlcik7XG4gIH1cblxuICBpZihtc2cuaGVhZGVycykge1xuICAgIC8vIGVuY29kZSBhbGwgb3RoZXIgaGVhZGVyc1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cuaGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgcnZhbCArPSBmb2xkSGVhZGVyKG1zZy5oZWFkZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyB0ZXJtaW5hdGUgaGVhZGVyXG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIHJ2YWwgKz0gJ1xcclxcbic7XG4gIH1cblxuICAvLyBhZGQgYm9keVxuICBydmFsICs9IGZvcmdlLnV0aWwuZW5jb2RlNjQobXNnLmJvZHksIG9wdGlvbnMubWF4bGluZSB8fCA2NCkgKyAnXFxyXFxuJztcblxuICBydmFsICs9ICctLS0tLUVORCAnICsgbXNnLnR5cGUgKyAnLS0tLS1cXHJcXG4nO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyAoZGVzZXJpYWxpemVzKSBhbGwgUEVNIG1lc3NhZ2VzIGZvdW5kIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTSBtZXNzYWdlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gKi9cbnBlbS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBzcGxpdCBzdHJpbmcgaW50byBQRU0gbWVzc2FnZXMgKGJlIGxlbmllbnQgdy9FT0Ygb24gQkVHSU4gbGluZSlcbiAgdmFyIHJNZXNzYWdlID0gL1xccyotLS0tLUJFR0lOIChbQS1aMC05LSBdKyktLS0tLVxccj9cXG4/KFtcXHgyMS1cXHg3ZVxcc10rPyg/Olxccj9cXG5cXHI/XFxuKSk/KFs6QS1aYS16MC05K1xcLz1cXHNdKz8pLS0tLS1FTkQgXFwxLS0tLS0vZztcbiAgdmFyIHJIZWFkZXIgPSAvKFtcXHgyMS1cXHg3ZV0rKTpcXHMqKFtcXHgyMS1cXHg3ZVxcc146XSspLztcbiAgdmFyIHJDUkxGID0gL1xccj9cXG4vO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlKHRydWUpIHtcbiAgICBtYXRjaCA9IHJNZXNzYWdlLmV4ZWMoc3RyKTtcbiAgICBpZighbWF0Y2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtc2cgPSB7XG4gICAgICB0eXBlOiBtYXRjaFsxXSxcbiAgICAgIHByb2NUeXBlOiBudWxsLFxuICAgICAgY29udGVudERvbWFpbjogbnVsbCxcbiAgICAgIGRla0luZm86IG51bGwsXG4gICAgICBoZWFkZXJzOiBbXSxcbiAgICAgIGJvZHk6IGZvcmdlLnV0aWwuZGVjb2RlNjQobWF0Y2hbM10pXG4gICAgfTtcbiAgICBydmFsLnB1c2gobXNnKTtcblxuICAgIC8vIG5vIGhlYWRlcnNcbiAgICBpZighbWF0Y2hbMl0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGhlYWRlcnNcbiAgICB2YXIgbGluZXMgPSBtYXRjaFsyXS5zcGxpdChyQ1JMRik7XG4gICAgdmFyIGxpID0gMDtcbiAgICB3aGlsZShtYXRjaCAmJiBsaSA8IGxpbmVzLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0IGxpbmUsIHRyaW0gYW55IHJocyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xpXS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcblxuICAgICAgLy8gUkZDMjgyMiB1bmZvbGQgYW55IGZvbGxvd2luZyBmb2xkZWQgbGluZXNcbiAgICAgIGZvcih2YXIgbmwgPSBsaSArIDE7IG5sIDwgbGluZXMubGVuZ3RoOyArK25sKSB7XG4gICAgICAgIHZhciBuZXh0ID0gbGluZXNbbmxdO1xuICAgICAgICBpZighL1xccy8udGVzdChuZXh0WzBdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gbmV4dDtcbiAgICAgICAgbGkgPSBubDtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgaGVhZGVyXG4gICAgICBtYXRjaCA9IGxpbmUubWF0Y2gockhlYWRlcik7XG4gICAgICBpZihtYXRjaCkge1xuICAgICAgICB2YXIgaGVhZGVyID0ge25hbWU6IG1hdGNoWzFdLCB2YWx1ZXM6IFtdfTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG1hdGNoWzJdLnNwbGl0KCcsJyk7XG4gICAgICAgIGZvcih2YXIgdmkgPSAwOyB2aSA8IHZhbHVlcy5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsdWVzLnB1c2gobHRyaW0odmFsdWVzW3ZpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvYy1UeXBlIG11c3QgYmUgdGhlIGZpcnN0IGhlYWRlclxuICAgICAgICBpZighbXNnLnByb2NUeXBlKSB7XG4gICAgICAgICAgaWYoaGVhZGVyLm5hbWUgIT09ICdQcm9jLVR5cGUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICdlbmNhcHN1bGF0ZWQgaGVhZGVyIG11c3QgYmUgXCJQcm9jLVR5cGVcIi4nKTtcbiAgICAgICAgICB9IGVsc2UgaWYoaGVhZGVyLnZhbHVlcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIlByb2MtVHlwZVwiICcgK1xuICAgICAgICAgICAgICAnaGVhZGVyIG11c3QgaGF2ZSB0d28gc3ViZmllbGRzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cucHJvY1R5cGUgPSB7dmVyc2lvbjogdmFsdWVzWzBdLCB0eXBlOiB2YWx1ZXNbMV19O1xuICAgICAgICB9IGVsc2UgaWYoIW1zZy5jb250ZW50RG9tYWluICYmIGhlYWRlci5uYW1lID09PSAnQ29udGVudC1Eb21haW4nKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbC1jYXNlIENvbnRlbnQtRG9tYWluXG4gICAgICAgICAgbXNnLmNvbnRlbnREb21haW4gPSB2YWx1ZXNbMF0gfHwgJyc7XG4gICAgICAgIH0gZWxzZSBpZighbXNnLmRla0luZm8gJiYgaGVhZGVyLm5hbWUgPT09ICdERUstSW5mbycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsLWNhc2UgREVLLUluZm9cbiAgICAgICAgICBpZihoZWFkZXIudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiREVLLUluZm9cIiAnICtcbiAgICAgICAgICAgICAgJ2hlYWRlciBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHN1YmZpZWxkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cuZGVrSW5mbyA9IHthbGdvcml0aG06IHZhbHVlc1swXSwgcGFyYW1ldGVyczogdmFsdWVzWzFdIHx8IG51bGx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zZy5oZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICArK2xpO1xuICAgIH1cblxuICAgIGlmKG1zZy5wcm9jVHlwZSA9PT0gJ0VOQ1JZUFRFRCcgJiYgIW1zZy5kZWtJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgXCJERUstSW5mb1wiICcgK1xuICAgICAgICAnaGVhZGVyIG11c3QgYmUgcHJlc2VudCBpZiBcIlByb2MtVHlwZVwiIGlzIFwiRU5DUllQVEVEXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYocnZhbC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLicpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG5mdW5jdGlvbiBmb2xkSGVhZGVyKGhlYWRlcikge1xuICB2YXIgcnZhbCA9IGhlYWRlci5uYW1lICsgJzogJztcblxuICAvLyBlbnN1cmUgdmFsdWVzIHdpdGggQ1JMRiBhcmUgZm9sZGVkXG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGluc2VydFNwYWNlID0gZnVuY3Rpb24obWF0Y2gsICQxKSB7XG4gICAgcmV0dXJuICcgJyArICQxO1xuICB9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaGVhZGVyLnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhbHVlcy5wdXNoKGhlYWRlci52YWx1ZXNbaV0ucmVwbGFjZSgvXihcXFMrXFxyXFxuKS8sIGluc2VydFNwYWNlKSk7XG4gIH1cbiAgcnZhbCArPSB2YWx1ZXMuam9pbignLCcpICsgJ1xcclxcbic7XG5cbiAgLy8gZG8gZm9sZGluZ1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIGNhbmRpZGF0ZSA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgcnZhbC5sZW5ndGg7ICsraSwgKytsZW5ndGgpIHtcbiAgICBpZihsZW5ndGggPiA2NSAmJiBjYW5kaWRhdGUgIT09IC0xKSB7XG4gICAgICB2YXIgaW5zZXJ0ID0gcnZhbFtjYW5kaWRhdGVdO1xuICAgICAgaWYoaW5zZXJ0ID09PSAnLCcpIHtcbiAgICAgICAgKytjYW5kaWRhdGU7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICsgJ1xcclxcbiAnICsgcnZhbC5zdWJzdHIoY2FuZGlkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICtcbiAgICAgICAgICAnXFxyXFxuJyArIGluc2VydCArIHJ2YWwuc3Vic3RyKGNhbmRpZGF0ZSArIDEpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gKGkgLSBjYW5kaWRhdGUgLSAxKTtcbiAgICAgIGNhbmRpZGF0ZSA9IC0xO1xuICAgICAgKytpO1xuICAgIH0gZWxzZSBpZihydmFsW2ldID09PSAnICcgfHwgcnZhbFtpXSA9PT0gJ1xcdCcgfHwgcnZhbFtpXSA9PT0gJywnKSB7XG4gICAgICBjYW5kaWRhdGUgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuXG5mdW5jdGlvbiBsdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBQYXNzd29yZC1iYXNlZCBlbmNyeXB0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICogQGF1dGhvciBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBBbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbzpcbiAqXG4gKiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBlbmNyeXB0aW9uQWxnb3JpdGhtICBFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGF0YSAgICAgICAgRW5jcnlwdGVkRGF0YSB9XG4gKlxuICogRW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBPQ1RFVCBTVFJJTkdcbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbl9fd2VicGFja19yZXF1aXJlX18oNSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbl9fd2VicGFja19yZXF1aXJlX18oNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5pZih0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG59XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLyogUGFzc3dvcmQtYmFzZWQgZW5jcnlwdGlvbiBpbXBsZW1lbnRhdGlvbi4gKi9cbnZhciBwa2kgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG5tb2R1bGUuZXhwb3J0cyA9IHBraS5wYmUgPSBmb3JnZS5wYmUgPSBmb3JnZS5wYmUgfHwge307XG52YXIgb2lkcyA9IHBraS5vaWRzO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgdy9hbGdvcml0aG0gcGFyYW1zXG52YXIgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uZW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2VuY3J5cHRpb25PaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIucGFyYW1ldGVycycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGlvblBhcmFtcydcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gZW5jcnlwdGVkRGF0YVxuICAgIG5hbWU6ICdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5lbmNyeXB0ZWREYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnZW5jcnlwdGVkRGF0YSdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBQQkVTMkFsZ29yaXRobXMgc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3L1BCS0RGMiArIEFFUyBlbmNyeXB0aW9uIHNjaGVtZXNcbnZhciBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMua2V5RGVyaXZhdGlvbkZ1bmMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jLm9pZCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2tkZk9pZCdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5zYWx0JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2tkZlNhbHQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLml0ZXJhdGlvbkNvdW50JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAna2RmSXRlcmF0aW9uQ291bnQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLmtleUxlbmd0aCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdrZXlMZW5ndGgnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHByZlxuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYuYWxnb3JpdGhtJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogJ3ByZk9pZCdcbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZS5vaWQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5lbmNyeXB0aW9uU2NoZW1lLml2JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNJdidcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zLnNhbHQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzYWx0J1xuICB9LCB7XG4gICAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMuaXRlcmF0aW9ucycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnaXRlcmF0aW9ucydcbiAgfV1cbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QsIHByb2R1Y2luZyBhbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqXG4gKiBQQkVTMkFsZ29yaXRobXMgQUxHT1JJVEhNLUlERU5USUZJRVIgOjo9XG4gKiAgIHsge1BCRVMyLXBhcmFtcyBJREVOVElGSUVEIEJZIGlkLVBCRVMyfSwgLi4ufVxuICpcbiAqIGlkLVBCRVMyIE9CSkVDVCBJREVOVElGSUVSIDo6PSB7cGtjcy01IDEzfVxuICpcbiAqIFBCRVMyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBrZXlEZXJpdmF0aW9uRnVuYyBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJFUzItS0RGc319LFxuICogICBlbmNyeXB0aW9uU2NoZW1lIEFsZ29yaXRobUlkZW50aWZpZXIge3tQQkVTMi1FbmNzfX1cbiAqIH1cbiAqXG4gKiBQQkVTMi1LREZzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PVxuICogICB7IHtQQktERjItcGFyYW1zIElERU5USUZJRUQgQlkgaWQtUEJLREYyfSwgLi4uIH1cbiAqXG4gKiBQQkVTMi1FbmNzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PSB7IC4uLiB9XG4gKlxuICogUEJLREYyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBzYWx0IENIT0lDRSB7XG4gKiAgICAgc3BlY2lmaWVkIE9DVEVUIFNUUklORyxcbiAqICAgICBvdGhlclNvdXJjZSBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVNhbHRTb3VyY2VzfX1cbiAqICAgfSxcbiAqICAgaXRlcmF0aW9uQ291bnQgSU5URUdFUiAoMS4uTUFYKSxcbiAqICAga2V5TGVuZ3RoIElOVEVHRVIgKDEuLk1BWCkgT1BUSU9OQUwsXG4gKiAgIHByZiBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVBSRnN9fSBERUZBVUxUIGFsZ2lkLWhtYWNXaXRoU0hBMVxuICogfVxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZW5jcnlwdCB3aXRoLlxuICogQHBhcmFtIG9wdGlvbnM6XG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ2FlczEyOCcsICdhZXMxOTInLCAnYWVzMjU2JywgJzNkZXMnKSwgZGVmYXVsdHMgdG8gJ2FlczEyOCcuXG4gKiAgICAgICAgICBjb3VudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplIHRoZSBzYWx0IHNpemUgdG8gdXNlLlxuICogICAgICAgICAgcHJmQWxnb3JpdGhtIHRoZSBQUkYgbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJylcbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyA9IGZ1bmN0aW9uKG9iaiwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5zYWx0U2l6ZSA9IG9wdGlvbnMuc2FsdFNpemUgfHwgODtcbiAgb3B0aW9ucy5jb3VudCA9IG9wdGlvbnMuY291bnQgfHwgMjA0ODtcbiAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCAnYWVzMTI4JztcbiAgb3B0aW9ucy5wcmZBbGdvcml0aG0gPSBvcHRpb25zLnByZkFsZ29yaXRobSB8fCAnc2hhMSc7XG5cbiAgLy8gZ2VuZXJhdGUgUEJFIHBhcmFtc1xuICB2YXIgc2FsdCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMob3B0aW9ucy5zYWx0U2l6ZSk7XG4gIHZhciBjb3VudCA9IG9wdGlvbnMuY291bnQ7XG4gIHZhciBjb3VudEJ5dGVzID0gYXNuMS5pbnRlZ2VyVG9EZXIoY291bnQpO1xuICB2YXIgZGtMZW47XG4gIHZhciBlbmNyeXB0aW9uQWxnb3JpdGhtO1xuICB2YXIgZW5jcnlwdGVkRGF0YTtcbiAgaWYob3B0aW9ucy5hbGdvcml0aG0uaW5kZXhPZignYWVzJykgPT09IDAgfHwgb3B0aW9ucy5hbGdvcml0aG0gPT09ICdkZXMnKSB7XG4gICAgLy8gZG8gUEJFUzJcbiAgICB2YXIgaXZMZW4sIGVuY09pZCwgY2lwaGVyRm47XG4gICAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnYWVzMTI4JzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBpdkxlbiA9IDE2O1xuICAgICAgZW5jT2lkID0gb2lkc1snYWVzMTI4LUNCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FlczE5Mic6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgaXZMZW4gPSAxNjtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2FlczE5Mi1DQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZXMyNTYnOlxuICAgICAgZGtMZW4gPSAzMjtcbiAgICAgIGl2TGVuID0gMTY7XG4gICAgICBlbmNPaWQgPSBvaWRzWydhZXMyNTYtQ0JDJ107XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVzJzpcbiAgICAgIGRrTGVuID0gODtcbiAgICAgIGl2TGVuID0gODtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2Rlc0NCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHByaXZhdGUga2V5LiBVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gICAgdmFyIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aCcgKyBvcHRpb25zLnByZkFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBtZCA9IHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xuXG4gICAgLy8gZW5jcnlwdCBwcml2YXRlIGtleSB1c2luZyBwYmUgU0hBLTEgYW5kIEFFUy9ERVNcbiAgICB2YXIgZGsgPSBmb3JnZS5wa2NzNS5wYmtkZjIocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgbWQpO1xuICAgIHZhciBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoaXZMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIob2JqKSk7XG4gICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgIGVuY3J5cHRlZERhdGEgPSBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKCk7XG5cbiAgICAvLyBnZXQgUEJLREYyLXBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBjcmVhdGVQYmtkZjJQYXJhbXMoc2FsdCwgY291bnRCeXRlcywgZGtMZW4sIHByZkFsZ29yaXRobSk7XG5cbiAgICBlbmNyeXB0aW9uQWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQkVTMiddKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8ga2V5RGVyaXZhdGlvbkZ1bmNcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQktERjInXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gUEJLREYyLXBhcmFtc1xuICAgICAgICAgIHBhcmFtc1xuICAgICAgICBdKSxcbiAgICAgICAgLy8gZW5jcnlwdGlvblNjaGVtZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihlbmNPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgIC8vIGl2XG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgaXYpXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2UgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICczZGVzJykge1xuICAgIC8vIERvIFBLQ1MxMiBQQkVcbiAgICBka0xlbiA9IDI0O1xuXG4gICAgdmFyIHNhbHRCeXRlcyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoc2FsdCk7XG4gICAgdmFyIGRrID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdEJ5dGVzLCAxLCBjb3VudCwgZGtMZW4pO1xuICAgIHZhciBpdiA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHRCeXRlcywgMiwgY291bnQsIGRrTGVuKTtcbiAgICB2YXIgY2lwaGVyID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIoZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShhc24xLnRvRGVyKG9iaikpO1xuICAgIGNpcGhlci5maW5pc2goKTtcbiAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwa2NzLTEyUGJlUGFyYW1zXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIHNhbHRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNhbHQpLFxuICAgICAgICAvLyBpdGVyYXRpb24gY291bnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKCkpXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgcHJpdmF0ZSBrZXkuIFVua25vd24gZW5jcnlwdGlvbiBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBlbmNyeXB0aW9uQWxnb3JpdGhtXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSxcbiAgICAvLyBlbmNyeXB0ZWREYXRhXG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgZW5jcnlwdGVkRGF0YSlcbiAgXSk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mbyBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8gPSBmdW5jdGlvbihvYmosIHBhc3N3b3JkKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBjaXBoZXJcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNyeXB0aW9uT2lkKTtcbiAgdmFyIGNpcGhlciA9IHBraS5wYmUuZ2V0Q2lwaGVyKG9pZCwgY2FwdHVyZS5lbmNyeXB0aW9uUGFyYW1zLCBwYXNzd29yZCk7XG5cbiAgLy8gZ2V0IGVuY3J5cHRlZCBkYXRhXG4gIHZhciBlbmNyeXB0ZWQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmVuY3J5cHRlZERhdGEpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgcnZhbCA9IGFzbjEuZnJvbURlcihjaXBoZXIub3V0cHV0KTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGVwa2kgdGhlIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0gPSBmdW5jdGlvbihlcGtpLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKGVwa2kpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBFTS1lbmNvZGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIEFTTi4xIGZvcm1hdC4gRGVjcnlwdGlvblxuICogaXMgbm90IHBlcmZvcm1lZC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBpbiBQRU0tZm9ybWF0LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kuZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICByZXR1cm4gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYW4gUlNBIHByaXZhdGUga2V5LiBCeSBkZWZhdWx0LCB0aGUga2V5IHdpbGwgYmUgd3JhcHBlZCBpblxuICogYSBQcml2YXRlS2V5SW5mbyBhbmQgZW5jcnlwdGVkIHRvIHByb2R1Y2UgYSBQS0NTIzggRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKiBUaGlzIGlzIHRoZSBzdGFuZGFyZCwgcHJlZmVycmVkIHdheSB0byBlbmNyeXB0IGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogVG8gcHJvZHVjZSBhIG5vbi1zdGFuZGFyZCBQRU0tZW5jcnlwdGVkIHByaXZhdGUga2V5IHRoYXQgdXNlcyBlbmNhcHN1bGF0ZWRcbiAqIGhlYWRlcnMgdG8gaW5kaWNhdGUgdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIChvbGQtc3R5bGUgbm9uLVBLQ1MjOCBPcGVuU1NMXG4gKiBwcml2YXRlIGtleSBlbmNyeXB0aW9uKSwgc2V0IHRoZSAnbGVnYWN5JyBvcHRpb24gdG8gdHJ1ZS4gTm90ZTogVXNpbmcgdGhpc1xuICogb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byBiZSBmb3JjZWQgdG8gMS5cbiAqXG4gKiBOb3RlOiBUaGUgJ2RlcycgYWxnb3JpdGhtIGlzIHN1cHBvcnRlZCwgYnV0IGl0IGlzIG5vdCBjb25zaWRlcmVkIHRvIGJlXG4gKiBzZWN1cmUgYmVjYXVzZSBpdCBvbmx5IHVzZXMgYSBzaW5nbGUgNTYtYml0IGtleS4gSWYgcG9zc2libGUsIGl0IGlzIGhpZ2hseVxuICogcmVjb21tZW5kZWQgdGhhdCBhIGRpZmZlcmVudCBhbGdvcml0aG0gYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBSU0Ega2V5IHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtOiB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gdG8gdXNlXG4gKiAgICAgICAgICAgICgnYWVzMTI4JywgJ2FlczE5MicsICdhZXMyNTYnLCAnM2RlcycsICdkZXMnKS5cbiAqICAgICAgICAgIGNvdW50OiB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplOiB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIGxlZ2FjeTogb3V0cHV0IGFuIG9sZCBub24tUEtDUyM4IFBFTS1lbmNyeXB0ZWQrZW5jYXBzdWxhdGVkXG4gKiAgICAgICAgICAgIGhlYWRlcnMgKERFSy1JbmZvKSBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZW5jb2RlZCBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAvLyBzdGFuZGFyZCBQS0NTIzhcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCFvcHRpb25zLmxlZ2FjeSkge1xuICAgIC8vIGVuY3J5cHQgUHJpdmF0ZUtleUluZm9cbiAgICB2YXIgcnZhbCA9IHBraS53cmFwUnNhUHJpdmF0ZUtleShwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKTtcbiAgICBydmFsID0gcGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhydmFsLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0ocnZhbCk7XG4gIH1cblxuICAvLyBsZWdhY3kgbm9uLVBLQ1MjOFxuICB2YXIgYWxnb3JpdGhtO1xuICB2YXIgaXY7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgY2FzZSAnYWVzMTI4JzpcbiAgICBhbGdvcml0aG0gPSAnQUVTLTEyOC1DQkMnO1xuICAgIGRrTGVuID0gMTY7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMxOTInOlxuICAgIGFsZ29yaXRobSA9ICdBRVMtMTkyLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczI1Nic6XG4gICAgYWxnb3JpdGhtID0gJ0FFUy0yNTYtQ0JDJztcbiAgICBka0xlbiA9IDMyO1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYygxNik7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnM2Rlcyc6XG4gICAgYWxnb3JpdGhtID0gJ0RFUy1FREUzLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCk7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzJzpcbiAgICBhbGdvcml0aG0gPSAnREVTLUNCQyc7XG4gICAgZGtMZW4gPSA4O1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYyg4KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGVuY3J5cHQgUlNBIHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCAnICtcbiAgICAgICdlbmNyeXB0aW9uIGFsZ29yaXRobSBcIicgKyBvcHRpb25zLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgT3BlblNTTCBsZWdhY3kga2V5IGRlcml2YXRpb25cbiAgdmFyIGRrID0gZm9yZ2UucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyhwYXNzd29yZCwgaXYuc3Vic3RyKDAsIDgpLCBka0xlbik7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIGNpcGhlci51cGRhdGUoYXNuMS50b0Rlcihwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKSk7XG4gIGNpcGhlci5maW5pc2goKTtcblxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFJJVkFURSBLRVknLFxuICAgIHByb2NUeXBlOiB7XG4gICAgICB2ZXJzaW9uOiAnNCcsXG4gICAgICB0eXBlOiAnRU5DUllQVEVEJ1xuICAgIH0sXG4gICAgZGVrSW5mbzoge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBwYXJhbWV0ZXJzOiBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoaXYpLnRvVXBwZXJDYXNlKClcbiAgICB9LFxuICAgIGJvZHk6IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2cpO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhbiBSU0EgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBkZWNyeXB0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgUlNBIGtleSBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHBlbSwgcGFzc3dvcmQpIHtcbiAgdmFyIHJ2YWwgPSBudWxsO1xuXG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknICYmXG4gICAgbXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1JTQSBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgJyArXG4gICAgICAnaXMgbm90IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIsIFwiUFJJVkFURSBLRVlcIiwgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gZXJyb3I7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdmFyIGRrTGVuO1xuICAgIHZhciBjaXBoZXJGbjtcbiAgICBzd2l0Y2gobXNnLmRla0luZm8uYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnREVTLUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnREVTLUVERTMtQ0JDJzpcbiAgICAgIGRrTGVuID0gMjQ7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQUVTLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBRVMtMTkyLUNCQyc6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FFUy0yNTYtQ0JDJzpcbiAgICAgIGRrTGVuID0gMzI7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTQwLUNCQyc6XG4gICAgICBka0xlbiA9IDU7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTY0LUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA2NCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBmb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGRlY3J5cHQgcHJpdmF0ZSBrZXk7IHVuc3VwcG9ydGVkICcgK1xuICAgICAgICAnZW5jcnlwdGlvbiBhbGdvcml0aG0gXCInICsgbXNnLmRla0luZm8uYWxnb3JpdGhtICsgJ1wiLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gbXNnLmRla0luZm8uYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gdXNlIE9wZW5TU0wgbGVnYWN5IGtleSBkZXJpdmF0aW9uXG4gICAgdmFyIGl2ID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpO1xuICAgIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG1zZy5ib2R5KSk7XG4gICAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICBydmFsID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCA9IG1zZy5ib2R5O1xuICB9XG5cbiAgaWYobXNnLnR5cGUgPT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknKSB7XG4gICAgcnZhbCA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYXNuMS5mcm9tRGVyKHJ2YWwpLCBwYXNzd29yZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVjcnlwdGlvbiBhbHJlYWR5IHBlcmZvcm1lZCBhYm92ZVxuICAgIHJ2YWwgPSBhc24xLmZyb21EZXIocnZhbCk7XG4gIH1cblxuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgcnZhbCA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEocnZhbCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleSA9IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBpZCwgaXRlciwgbiwgbWQpIHtcbiAgdmFyIGosIGw7XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIGlmKCEoJ3NoYTEnIGluIGZvcmdlLm1kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNoYTFcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9XG5cbiAgdmFyIHUgPSBtZC5kaWdlc3RMZW5ndGg7XG4gIHZhciB2ID0gbWQuYmxvY2tMZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgLyogQ29udmVydCBwYXNzd29yZCB0byBVbmljb2RlIGJ5dGUgYnVmZmVyICsgdHJhaWxpbmcgMC1ieXRlLiAqL1xuICB2YXIgcGFzc0J1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgaWYocGFzc3dvcmQgIT09IG51bGwgJiYgcGFzc3dvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvcihsID0gMDsgbCA8IHBhc3N3b3JkLmxlbmd0aDsgbCsrKSB7XG4gICAgICBwYXNzQnVmLnB1dEludDE2KHBhc3N3b3JkLmNoYXJDb2RlQXQobCkpO1xuICAgIH1cbiAgICBwYXNzQnVmLnB1dEludDE2KDApO1xuICB9XG5cbiAgLyogTGVuZ3RoIG9mIHNhbHQgYW5kIHBhc3N3b3JkIGluIEJZVEVTLiAqL1xuICB2YXIgcCA9IHBhc3NCdWYubGVuZ3RoKCk7XG4gIHZhciBzID0gc2FsdC5sZW5ndGgoKTtcblxuICAvKiAxLiBDb25zdHJ1Y3QgYSBzdHJpbmcsIEQgKHRoZSBcImRpdmVyc2lmaWVyXCIpLCBieSBjb25jYXRlbmF0aW5nXG4gICAgICAgIHYgY29waWVzIG9mIElELiAqL1xuICB2YXIgRCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgRC5maWxsV2l0aEJ5dGUoaWQsIHYpO1xuXG4gIC8qIDIuIENvbmNhdGVuYXRlIGNvcGllcyBvZiB0aGUgc2FsdCB0b2dldGhlciB0byBjcmVhdGUgYSBzdHJpbmcgUyBvZiBsZW5ndGhcbiAgICAgICAgdiAqIGNlaWwocyAvIHYpIGJ5dGVzICh0aGUgZmluYWwgY29weSBvZiB0aGUgc2FsdCBtYXkgYmUgdHJ1bmFjdGVkXG4gICAgICAgIHRvIGNyZWF0ZSBTKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBzYWx0IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc28gaXMgUy4gKi9cbiAgdmFyIFNsZW4gPSB2ICogTWF0aC5jZWlsKHMgLyB2KTtcbiAgdmFyIFMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIGZvcihsID0gMDsgbCA8IFNsZW47IGwrKykge1xuICAgIFMucHV0Qnl0ZShzYWx0LmF0KGwgJSBzKSk7XG4gIH1cblxuICAvKiAzLiBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgdGhlIHBhc3N3b3JkIHRvZ2V0aGVyIHRvIGNyZWF0ZSBhIHN0cmluZyBQIG9mXG4gICAgICAgIGxlbmd0aCB2ICogY2VpbChwIC8gdikgYnl0ZXMgKHRoZSBmaW5hbCBjb3B5IG9mIHRoZSBwYXNzd29yZCBtYXkgYmVcbiAgICAgICAgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBQKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBwYXNzd29yZCBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNvIGlzIFAuICovXG4gIHZhciBQbGVuID0gdiAqIE1hdGguY2VpbChwIC8gdik7XG4gIHZhciBQID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICBmb3IobCA9IDA7IGwgPCBQbGVuOyBsKyspIHtcbiAgICBQLnB1dEJ5dGUocGFzc0J1Zi5hdChsICUgcCkpO1xuICB9XG5cbiAgLyogNC4gU2V0IEk9U3x8UCB0byBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBTIGFuZCBQLiAqL1xuICB2YXIgSSA9IFM7XG4gIEkucHV0QnVmZmVyKFApO1xuXG4gIC8qIDUuIFNldCBjPWNlaWwobiAvIHUpLiAqL1xuICB2YXIgYyA9IE1hdGguY2VpbChuIC8gdSk7XG5cbiAgLyogNi4gRm9yIGk9MSwgMiwgLi4uLCBjLCBkbyB0aGUgZm9sbG93aW5nOiAqL1xuICBmb3IodmFyIGkgPSAxOyBpIDw9IGM7IGkrKykge1xuICAgIC8qIGEpIFNldCBBaT1IXnIoRHx8SSkuIChsLmUuIHRoZSBydGggaGFzaCBvZiBEfHxJLCBIKEgoSCguLi5IKER8fEkpKSkpICovXG4gICAgdmFyIGJ1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBidWYucHV0Qnl0ZXMoRC5ieXRlcygpKTtcbiAgICBidWYucHV0Qnl0ZXMoSS5ieXRlcygpKTtcbiAgICBmb3IodmFyIHJvdW5kID0gMDsgcm91bmQgPCBpdGVyOyByb3VuZCsrKSB7XG4gICAgICBtZC5zdGFydCgpO1xuICAgICAgbWQudXBkYXRlKGJ1Zi5nZXRCeXRlcygpKTtcbiAgICAgIGJ1ZiA9IG1kLmRpZ2VzdCgpO1xuICAgIH1cblxuICAgIC8qIGIpIENvbmNhdGVuYXRlIGNvcGllcyBvZiBBaSB0byBjcmVhdGUgYSBzdHJpbmcgQiBvZiBsZW5ndGggdiBieXRlcyAodGhlXG4gICAgICAgICAgZmluYWwgY29weSBvZiBBaSBtYXkgYmUgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBCKS4gKi9cbiAgICB2YXIgQiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBmb3IobCA9IDA7IGwgPCB2OyBsKyspIHtcbiAgICAgIEIucHV0Qnl0ZShidWYuYXQobCAlIHUpKTtcbiAgICB9XG5cbiAgICAvKiBjKSBUcmVhdGluZyBJIGFzIGEgY29uY2F0ZW5hdGlvbiBJMCwgSTEsIC4uLiwgSWstMSBvZiB2LWJ5dGUgYmxvY2tzLFxuICAgICAgICAgIHdoZXJlIGs9Y2VpbChzIC8gdikgKyBjZWlsKHAgLyB2KSwgbW9kaWZ5IEkgYnkgc2V0dGluZ1xuICAgICAgICAgIElqPShJaitCKzEpIG1vZCAydiBmb3IgZWFjaCBqLiAgKi9cbiAgICB2YXIgayA9IE1hdGguY2VpbChzIC8gdikgKyBNYXRoLmNlaWwocCAvIHYpO1xuICAgIHZhciBJbmV3ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIGZvcihqID0gMDsgaiA8IGs7IGorKykge1xuICAgICAgdmFyIGNodW5rID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihJLmdldEJ5dGVzKHYpKTtcbiAgICAgIHZhciB4ID0gMHgxZmY7XG4gICAgICBmb3IobCA9IEIubGVuZ3RoKCkgLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICB4ID0geCA+PiA4O1xuICAgICAgICB4ICs9IEIuYXQobCkgKyBjaHVuay5hdChsKTtcbiAgICAgICAgY2h1bmsuc2V0QXQobCwgeCAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgSW5ldy5wdXRCdWZmZXIoY2h1bmspO1xuICAgIH1cbiAgICBJID0gSW5ldztcblxuICAgIC8qIEFkZCBBaSB0byBBLiAqL1xuICAgIHJlc3VsdC5wdXRCdWZmZXIoYnVmKTtcbiAgfVxuXG4gIHJlc3VsdC50cnVuY2F0ZShyZXN1bHQubGVuZ3RoKCkgLSBuKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvaWQgdGhlIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIHBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlciA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICBzd2l0Y2gob2lkKSB7XG4gIGNhc2UgcGtpLm9pZHNbJ3BrY3M1UEJFUzInXTpcbiAgICByZXR1cm4gcGtpLnBiZS5nZXRDaXBoZXJGb3JQQkVTMihvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGNhc2UgcGtpLm9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXTpcbiAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgIHJldHVybiBwa2kucGJlLmdldENpcGhlckZvclBLQ1MxMlBCRShvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGRlZmF1bHQ6XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgUEJFIGRhdGEgYmxvY2suIFVuc3VwcG9ydGVkIE9JRC4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcbiAgICAgICdwa2NzNVBCRVMyJyxcbiAgICAgICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyxcbiAgICAgICdwYmV3aXRoU0hBQW5kNDBCaXRSQzItQ0JDJ1xuICAgIF07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlIGFjY29yZGluZyB0byBQQkVTMiBwYXJhbXMgYmxvY2suXG4gKlxuICogVGhlIHJldHVybmVkIGNpcGhlciBpbnN0YW5jZSBpcyBhbHJlYWR5IHN0YXJ0ZWQgdXNpbmcgdGhlIElWXG4gKiBmcm9tIFBCRVMyIHBhcmFtZXRlciBibG9jay5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBQS0NTIzUgUEJLREYyIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIFBCRVMyLXBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlckZvclBCRVMyID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY2hlY2sgb2lkc1xuICBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUua2RmT2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkc1sncGtjczVQQktERjInXSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBPSUQuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIGVycm9yLnN1cHBvcnRlZE9pZHMgPSBbJ3BrY3M1UEJLREYyJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmVuY09pZCk7XG4gIGlmKG9pZCAhPT0gcGtpLm9pZHNbJ2FlczEyOC1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczE5Mi1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczI1Ni1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2Rlcy1FREUzLUNCQyddICYmXG4gICAgb2lkICE9PSBwa2kub2lkc1snZGVzQ0JDJ10pIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBzY2hlbWUgT0lELicpO1xuICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gW1xuICAgICAgJ2FlczEyOC1DQkMnLCAnYWVzMTkyLUNCQycsICdhZXMyNTYtQ0JDJywgJ2Rlcy1FREUzLUNCQycsICdkZXNDQkMnXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIHNldCBQQkUgcGFyYW1zXG4gIHZhciBzYWx0ID0gY2FwdHVyZS5rZGZTYWx0O1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmtkZkl0ZXJhdGlvbkNvdW50KTtcbiAgY291bnQgPSBjb3VudC5nZXRJbnQoY291bnQubGVuZ3RoKCkgPDwgMyk7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gocGtpLm9pZHNbb2lkXSkge1xuICBjYXNlICdhZXMxMjgtQ0JDJzpcbiAgICBka0xlbiA9IDE2O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczE5Mi1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnYWVzMjU2LUNCQyc6XG4gICAgZGtMZW4gPSAzMjtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdkZXMtRURFMy1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzQ0JDJzpcbiAgICBka0xlbiA9IDg7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGdldCBQUkYgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIG1kID0gcHJmT2lkVG9NZXNzYWdlRGlnZXN0KGNhcHR1cmUucHJmT2lkKTtcblxuICAvLyBkZWNyeXB0IHByaXZhdGUga2V5IHVzaW5nIHBiZSB3aXRoIGNob3NlbiBQUkYgYW5kIEFFUy9ERVNcbiAgdmFyIGRrID0gZm9yZ2UucGtjczUucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgdmFyIGl2ID0gY2FwdHVyZS5lbmNJdjtcbiAgdmFyIGNpcGhlciA9IGNpcGhlckZuKGRrKTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBHZXQgbmV3IEZvcmdlIGNpcGhlciBvYmplY3QgaW5zdGFuY2UgZm9yIFBLQ1MjMTIgUEJFLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjaXBoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBzdGFydGVkIHVzaW5nIHRoZSBrZXkgJiBJVlxuICogZGVyaXZlZCBmcm9tIHRoZSBwcm92aWRlZCBwYXNzd29yZCBhbmQgUEtDUyMxMiBQQkUgc2FsdC5cbiAqXG4gKiBAcGFyYW0gb2lkIFRoZSBQS0NTIzEyIFBCRSBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBBU04uMSBQS0NTIzEyIFBCRS1wYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgbmV3IGNpcGhlciBvYmplY3QgaW5zdGFuY2UuXG4gKi9cbnBraS5wYmUuZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHNhbHQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnNhbHQpO1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLml0ZXJhdGlvbnMpO1xuICBjb3VudCA9IGNvdW50LmdldEludChjb3VudC5sZW5ndGgoKSA8PCAzKTtcblxuICB2YXIgZGtMZW4sIGRJdkxlbiwgY2lwaGVyRm47XG4gIHN3aXRjaChvaWQpIHtcbiAgICBjYXNlIHBraS5vaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ106XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLnN0YXJ0RGVjcnlwdGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgICAgZGtMZW4gPSA1O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5LCBpdikge1xuICAgICAgICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICAgIGNpcGhlci5zdGFydChpdiwgbnVsbCk7XG4gICAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTICMxMiBQQkUgZGF0YSBibG9jay4gVW5zdXBwb3J0ZWQgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG4gIHZhciBrZXkgPSBwa2kucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0LCAxLCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgbWQuc3RhcnQoKTtcbiAgdmFyIGl2ID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdCwgMiwgY291bnQsIGRJdkxlbiwgbWQpO1xuXG4gIHJldHVybiBjaXBoZXJGbihrZXksIGl2KTtcbn07XG5cbi8qKlxuICogT3BlblNTTCdzIGxlZ2FjeSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBTZWU6IGh0dHA6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgZnJvbS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0IHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBka0xlbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGRlcml2ZWQga2V5LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbbWRdIGFuIG9wdGlvbmFsIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UuXG4gKi9cbnBraS5wYmUub3BlbnNzbERlcml2ZUJ5dGVzID0gZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIGRrTGVuLCBtZCkge1xuICBpZih0eXBlb2YgbWQgPT09ICd1bmRlZmluZWQnIHx8IG1kID09PSBudWxsKSB7XG4gICAgaWYoISgnbWQ1JyBpbiBmb3JnZS5tZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZDVcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gIH1cbiAgaWYoc2FsdCA9PT0gbnVsbCkge1xuICAgIHNhbHQgPSAnJztcbiAgfVxuICB2YXIgZGlnZXN0cyA9IFtoYXNoKG1kLCBwYXNzd29yZCArIHNhbHQpXTtcbiAgZm9yKHZhciBsZW5ndGggPSAxNiwgaSA9IDE7IGxlbmd0aCA8IGRrTGVuOyArK2ksIGxlbmd0aCArPSAxNikge1xuICAgIGRpZ2VzdHMucHVzaChoYXNoKG1kLCBkaWdlc3RzW2kgLSAxXSArIHBhc3N3b3JkICsgc2FsdCkpO1xuICB9XG4gIHJldHVybiBkaWdlc3RzLmpvaW4oJycpLnN1YnN0cigwLCBka0xlbik7XG59O1xuXG5mdW5jdGlvbiBoYXNoKG1kLCBieXRlcykge1xuICByZXR1cm4gbWQuc3RhcnQoKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG59XG5cbmZ1bmN0aW9uIHByZk9pZFRvTWVzc2FnZURpZ2VzdChwcmZPaWQpIHtcbiAgLy8gZ2V0IFBSRiBhbGdvcml0aG0sIGRlZmF1bHQgdG8gU0hBLTFcbiAgdmFyIHByZkFsZ29yaXRobTtcbiAgaWYoIXByZk9pZCkge1xuICAgIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aFNIQTEnO1xuICB9IGVsc2Uge1xuICAgIHByZkFsZ29yaXRobSA9IHBraS5vaWRzW2FzbjEuZGVyVG9PaWQocHJmT2lkKV07XG4gICAgaWYoIXByZkFsZ29yaXRobSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQUkYgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gcHJmT2lkO1xuICAgICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgICAnaG1hY1dpdGhTSEExJywgJ2htYWNXaXRoU0hBMjI0JywgJ2htYWNXaXRoU0hBMjU2JywgJ2htYWNXaXRoU0hBMzg0JyxcbiAgICAgICAgJ2htYWNXaXRoU0hBNTEyJ107XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xufVxuXG5mdW5jdGlvbiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKSB7XG4gIHZhciBmYWN0b3J5ID0gZm9yZ2UubWQ7XG4gIHN3aXRjaChwcmZBbGdvcml0aG0pIHtcbiAgY2FzZSAnaG1hY1dpdGhTSEEyMjQnOlxuICAgIGZhY3RvcnkgPSBmb3JnZS5tZC5zaGE1MTI7XG4gIGNhc2UgJ2htYWNXaXRoU0hBMSc6XG4gIGNhc2UgJ2htYWNXaXRoU0hBMjU2JzpcbiAgY2FzZSAnaG1hY1dpdGhTSEEzODQnOlxuICBjYXNlICdobWFjV2l0aFNIQTUxMic6XG4gICAgcHJmQWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFJGIGFsZ29yaXRobS4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBwcmZBbGdvcml0aG07XG4gICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgJ2htYWNXaXRoU0hBMScsICdobWFjV2l0aFNIQTIyNCcsICdobWFjV2l0aFNIQTI1NicsICdobWFjV2l0aFNIQTM4NCcsXG4gICAgICAnaG1hY1dpdGhTSEE1MTInXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZighZmFjdG9yeSB8fCAhKHByZkFsZ29yaXRobSBpbiBmYWN0b3J5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIHByZkFsZ29yaXRobSk7XG4gIH1cbiAgcmV0dXJuIGZhY3RvcnlbcHJmQWxnb3JpdGhtXS5jcmVhdGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGJrZGYyUGFyYW1zKHNhbHQsIGNvdW50Qnl0ZXMsIGRrTGVuLCBwcmZBbGdvcml0aG0pIHtcbiAgdmFyIHBhcmFtcyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBzYWx0XG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2FsdCksXG4gICAgLy8gaXRlcmF0aW9uIGNvdW50XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGNvdW50Qnl0ZXMuZ2V0Qnl0ZXMoKSlcbiAgXSk7XG4gIC8vIHdoZW4gUFJGIGFsZ29yaXRobSBpcyBub3QgU0hBLTEgZGVmYXVsdCwgYWRkIGtleSBsZW5ndGggYW5kIFBSRiBhbGdvcml0aG1cbiAgaWYocHJmQWxnb3JpdGhtICE9PSAnaG1hY1dpdGhTSEExJykge1xuICAgIHBhcmFtcy52YWx1ZS5wdXNoKFxuICAgICAgLy8ga2V5IGxlbmd0aFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGRrTGVuLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllclxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHNbcHJmQWxnb3JpdGhtXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgXSkpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENpcGhlciBiYXNlIEFQSS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlciA9IGZvcmdlLmNpcGhlciB8fCB7fTtcblxuLy8gcmVnaXN0ZXJlZCBhbGdvcml0aG1zXG5mb3JnZS5jaXBoZXIuYWxnb3JpdGhtcyA9IGZvcmdlLmNpcGhlci5hbGdvcml0aG1zIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjaXBoZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlblxuICogYWxnb3JpdGhtIGFuZCBrZXkuIFRoZSBhbGdvcml0aG0gbWF5IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHZhbHVlIGZvciBhXG4gKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWxnb3JpdGhtIG9yIGl0IG1heSBiZSBnaXZlbiBhcyBhIGNpcGhlciBhbGdvcml0aG1cbiAqIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSwgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFsZ29yaXRobSBBUElcbiAqICAgICAgICAgIG9iamVjdC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGFcbiAqICAgICAgICAgIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiBmYWxzZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlY2lwaGVyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW5cbiAqIGFsZ29yaXRobSBhbmQga2V5LiBUaGUgYWxnb3JpdGhtIG1heSBiZSBwcm92aWRlZCBhcyBhIHN0cmluZyB2YWx1ZSBmb3IgYVxuICogcHJldmlvdXNseSByZWdpc3RlcmVkIGFsZ29yaXRobSBvciBpdCBtYXkgYmUgZ2l2ZW4gYXMgYSBjaXBoZXIgYWxnb3JpdGhtXG4gKiBBUEkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UsIGVpdGhlciBhIHN0cmluZyBvciBhbiBhbGdvcml0aG0gQVBJXG4gKiAgICAgICAgICBvYmplY3QuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlLCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvciBhXG4gKiAgICAgICAgICBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gYWxnb3JpdGhtIGJ5IG5hbWUuIElmIHRoZSBuYW1lIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIHRoZVxuICogYWxnb3JpdGhtIEFQSSBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIEFQSSBvYmplY3QuXG4gKi9cbmZvcmdlLmNpcGhlci5yZWdpc3RlckFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIGFsZ29yaXRobSkge1xuICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXSA9IGFsZ29yaXRobTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHJlZ2lzdGVyZWQgYWxnb3JpdGhtIGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhbGdvcml0aG0sIGlmIGZvdW5kLCBudWxsIGlmIG5vdC5cbiAqL1xuZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgaWYobmFtZSBpbiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtcykge1xuICAgIHJldHVybiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBCbG9ja0NpcGhlciA9IGZvcmdlLmNpcGhlci5CbG9ja0NpcGhlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgdGhpcy5tb2RlID0gdGhpcy5hbGdvcml0aG0ubW9kZTtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLm1vZGUuYmxvY2tTaXplO1xuICB0aGlzLl9maW5pc2ggPSBmYWxzZTtcbiAgdGhpcy5faW5wdXQgPSBudWxsO1xuICB0aGlzLm91dHB1dCA9IG51bGw7XG4gIHRoaXMuX29wID0gb3B0aW9ucy5kZWNyeXB0ID8gdGhpcy5tb2RlLmRlY3J5cHQgOiB0aGlzLm1vZGUuZW5jcnlwdDtcbiAgdGhpcy5fZGVjcnlwdCA9IG9wdGlvbnMuZGVjcnlwdDtcbiAgdGhpcy5hbGdvcml0aG0uaW5pdGlhbGl6ZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIG9yIHJlc3RhcnRzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcywgd2hpY2hldmVyXG4gKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICpcbiAqIEZvciBub24tR0NNIG1vZGUsIHRoZSBJViBtYXkgYmUgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5XG4gKiBvZiBieXRlcywgYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzLiBJZiB0aGUgSVYgaXMgaW5cbiAqIGJ5dGVzLCB0aGVuIGl0IG11c3QgYmUgTmIgKDE2KSBieXRlcyBpbiBsZW5ndGguIElmIHRoZSBJViBpcyBnaXZlbiBpbiBhc1xuICogMzItYml0IGludGVnZXJzLCB0aGVuIGl0IG11c3QgYmUgNCBpbnRlZ2VycyBsb25nLlxuICpcbiAqIE5vdGU6IGFuIElWIGlzIG5vdCByZXF1aXJlZCBvciB1c2VkIGluIEVDQiBtb2RlLlxuICpcbiAqIEZvciBHQ00tbW9kZSwgdGhlIElWIG11c3QgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3JcbiAqIGEgYnl0ZSBidWZmZXIuIFRoZSBudW1iZXIgb2YgYnl0ZXMgc2hvdWxkIGJlIDEyICg5NiBiaXRzKSBhcyByZWNvbW1lbmRlZFxuICogYnkgTklTVCBTUC04MDAtMzhEIGJ1dCBhbm90aGVyIGxlbmd0aCBtYXkgYmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2ZcbiAqICAgICAgICAgICAgYnl0ZXMsIG51bGwgdG8gcmV1c2UgdGhlIGxhc3QgY2lwaGVyZWQgYmxvY2sgZnJvbSBhIHByZXZpb3VzXG4gKiAgICAgICAgICAgIHVwZGF0ZSgpICh0aGlzIFwicmVzaWR1ZVwiIG1ldGhvZCBpcyBmb3IgbGVnYWN5IHN1cHBvcnQgb25seSkuXG4gKiAgICAgICAgICBhZGRpdGlvbmFsRGF0YSBhZGRpdGlvbmFsIGF1dGhlbnRpY2F0aW9uIGRhdGEgYXMgYSBiaW5hcnktZW5jb2RlZFxuICogICAgICAgICAgICBzdHJpbmcgb2YgYnl0ZXMsIGZvciAnR0NNJyBtb2RlLCAoZGVmYXVsdDogbm9uZSkuXG4gKiAgICAgICAgICB0YWdMZW5ndGggZGVzaXJlZCBsZW5ndGggb2YgYXV0aGVudGljYXRpb24gdGFnLCBpbiBiaXRzLCBmb3JcbiAqICAgICAgICAgICAgJ0dDTScgbW9kZSAoMC0xMjgsIGRlZmF1bHQ6IDEyOCkuXG4gKiAgICAgICAgICB0YWcgdGhlIGF1dGhlbnRpY2F0aW9uIHRhZyB0byBjaGVjayBpZiBkZWNyeXB0aW5nLCBhcyBhXG4gKiAgICAgICAgICAgICBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiAgICAgICAgICBvdXRwdXQgdGhlIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBvcHRzID0ge307XG4gIGZvcih2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICBvcHRzW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgb3B0cy5kZWNyeXB0ID0gdGhpcy5fZGVjcnlwdDtcbiAgdGhpcy5fZmluaXNoID0gZmFsc2U7XG4gIHRoaXMuX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5vdXRwdXQgPSBvcHRpb25zLm91dHB1dCB8fCBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLm1vZGUuc3RhcnQob3B0cyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBjaXBoZXIgbW9kZS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZihpbnB1dCkge1xuICAgIC8vIGlucHV0IGdpdmVuLCBzbyBlbXB0eSBpdCBpbnRvIHRoZSBpbnB1dCBidWZmZXJcbiAgICB0aGlzLl9pbnB1dC5wdXRCdWZmZXIoaW5wdXQpO1xuICB9XG5cbiAgLy8gZG8gY2lwaGVyIG9wZXJhdGlvbiB1bnRpbCBpdCBuZWVkcyBtb3JlIGlucHV0IGFuZCBub3QgZmluaXNoZWRcbiAgd2hpbGUoIXRoaXMuX29wLmNhbGwodGhpcy5tb2RlLCB0aGlzLl9pbnB1dCwgdGhpcy5vdXRwdXQsIHRoaXMuX2ZpbmlzaCkgJiZcbiAgICAhdGhpcy5fZmluaXNoKSB7fVxuXG4gIC8vIGZyZWUgY29uc3VtZWQgbWVtb3J5IGZyb20gaW5wdXQgYnVmZmVyXG4gIHRoaXMuX2lucHV0LmNvbXBhY3QoKTtcbn07XG5cbi8qKlxuICogRmluaXNoZXMgZW5jcnlwdGluZyBvciBkZWNyeXB0aW5nLlxuICpcbiAqIEBwYXJhbSBwYWQgYSBwYWRkaW5nIGZ1bmN0aW9uIHRvIHVzZSBpbiBDQkMgbW9kZSwgbnVsbCBmb3IgZGVmYXVsdCxcbiAqICAgICAgICAgIHNpZ25hdHVyZShibG9ja1NpemUsIGJ1ZmZlciwgZGVjcnlwdCkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICovXG5CbG9ja0NpcGhlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24ocGFkKSB7XG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHcvZGVwcmVjYXRlZCBwYWRkaW5nIEFQSVxuICAvLyBOb3RlOiB3aWxsIG92ZXJ3cml0ZSBwYWRkaW5nIGZ1bmN0aW9ucyBldmVuIGFmdGVyIGFub3RoZXIgc3RhcnQoKSBjYWxsXG4gIGlmKHBhZCAmJiAodGhpcy5tb2RlLm5hbWUgPT09ICdFQ0InIHx8IHRoaXMubW9kZS5uYW1lID09PSAnQ0JDJykpIHtcbiAgICB0aGlzLm1vZGUucGFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIGlucHV0LCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLm1vZGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIG91dHB1dCwgdHJ1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGJ1aWxkIG9wdGlvbnMgZm9yIHBhZGRpbmcgYW5kIGFmdGVyRmluaXNoIGZ1bmN0aW9uc1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICBvcHRpb25zLmRlY3J5cHQgPSB0aGlzLl9kZWNyeXB0O1xuXG4gIC8vIGdldCAjIG9mIGJ5dGVzIHRoYXQgd29uJ3QgZmlsbCBhIGJsb2NrXG4gIG9wdGlvbnMub3ZlcmZsb3cgPSB0aGlzLl9pbnB1dC5sZW5ndGgoKSAlIHRoaXMuYmxvY2tTaXplO1xuXG4gIGlmKCF0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS5wYWQpIHtcbiAgICBpZighdGhpcy5tb2RlLnBhZCh0aGlzLl9pbnB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBkbyBmaW5hbCB1cGRhdGVcbiAgdGhpcy5fZmluaXNoID0gdHJ1ZTtcbiAgdGhpcy51cGRhdGUoKTtcblxuICBpZih0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS51bnBhZCkge1xuICAgIGlmKCF0aGlzLm1vZGUudW5wYWQodGhpcy5vdXRwdXQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYodGhpcy5tb2RlLmFmdGVyRmluaXNoKSB7XG4gICAgaWYoIXRoaXMubW9kZS5hZnRlckZpbmlzaCh0aGlzLm91dHB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIFN1cHBvcnRlZCBjaXBoZXIgbW9kZXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyBzdXBwb3J0ZWQgY2lwaGVyIG1vZGVzXG52YXIgbW9kZXMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlci5tb2RlcyA9IGZvcmdlLmNpcGhlci5tb2RlcyB8fCB7fTtcblxuLyoqIEVsZWN0cm9uaWMgY29kZWJvb2sgKEVDQikgKERvbid0IHVzZSB0aGlzOyBpdCdzIG5vdCBzZWN1cmUpICoqL1xuXG5tb2Rlcy5lY2IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnRUNCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge307XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGRlY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gIHZhciBwYWRkaW5nID0gKGlucHV0Lmxlbmd0aCgpID09PSB0aGlzLmJsb2NrU2l6ZSA/XG4gICAgdGhpcy5ibG9ja1NpemUgOiAodGhpcy5ibG9ja1NpemUgLSBpbnB1dC5sZW5ndGgoKSkpO1xuICBpbnB1dC5maWxsV2l0aEJ5dGUocGFkZGluZywgcGFkZGluZyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCwgb3B0aW9ucykge1xuICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2tTaXplXG4gIGlmKG9wdGlvbnMub3ZlcmZsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZW5zdXJlIHBhZGRpbmcgYnl0ZSBjb3VudCBpcyB2YWxpZFxuICB2YXIgbGVuID0gb3V0cHV0Lmxlbmd0aCgpO1xuICB2YXIgY291bnQgPSBvdXRwdXQuYXQobGVuIC0gMSk7XG4gIGlmKGNvdW50ID4gKHRoaXMuYmxvY2tTaXplIDw8IDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICBvdXRwdXQudHJ1bmNhdGUoY291bnQpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKiBDaXBoZXItYmxvY2sgQ2hhaW5pbmcgKENCQykgKiovXG5cbm1vZGVzLmNiYyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDQkMnO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIE5vdGU6IGxlZ2FjeSBzdXBwb3J0IGZvciB1c2luZyBJViByZXNpZHVlIChoYXMgc2VjdXJpdHkgZmxhd3MpXG4gIC8vIGlmIElWIGlzIG51bGwsIHJldXNlIGJsb2NrIGZyb20gcHJldmlvdXMgcHJvY2Vzc2luZ1xuICBpZihvcHRpb25zLml2ID09PSBudWxsKSB7XG4gICAgLy8gbXVzdCBoYXZlIGEgcHJldmlvdXMgYmxvY2tcbiAgICBpZighdGhpcy5fcHJldikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5faXYgPSB0aGlzLl9wcmV2LnNsaWNlKDApO1xuICB9IGVsc2UgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzYXZlIElWIGFzIFwicHJldmlvdXNcIiBibG9ja1xuICAgIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdik7XG4gICAgdGhpcy5fcHJldiA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB9XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgLy8gQ0JDIFhPUidzIElWIChvciBwcmV2aW91cyBibG9jaykgd2l0aCBwbGFpbnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wcmV2W2ldIF4gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0LCBzYXZlIHByZXZpb3VzIGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9vdXRCbG9jaztcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBkZWNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dCwgc2F2ZSBwcmV2aW91cyBjaXBoZXJlZCBibG9ja1xuICAvLyBDQkMgWE9SJ3MgSVYgKG9yIHByZXZpb3VzIGJsb2NrKSB3aXRoIGNpcGhlcnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9wcmV2W2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9pbkJsb2NrLnNsaWNlKDApO1xufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gIC8vIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcGFkIGJ5dGVzKVxuICB2YXIgcGFkZGluZyA9IChpbnB1dC5sZW5ndGgoKSA9PT0gdGhpcy5ibG9ja1NpemUgP1xuICAgIHRoaXMuYmxvY2tTaXplIDogKHRoaXMuYmxvY2tTaXplIC0gaW5wdXQubGVuZ3RoKCkpKTtcbiAgaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yOiBpbnB1dCBkYXRhIG5vdCBhIG11bHRpcGxlIG9mIGJsb2NrU2l6ZVxuICBpZihvcHRpb25zLm92ZXJmbG93ID4gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgdmFyIGNvdW50ID0gb3V0cHV0LmF0KGxlbiAtIDEpO1xuICBpZihjb3VudCA+ICh0aGlzLmJsb2NrU2l6ZSA8PCAyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiogQ2lwaGVyIGZlZWRiYWNrIChDRkIpICoqL1xuXG5tb2Rlcy5jZmIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnQ0ZCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX2luQmxvY2tbaV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgfVxuXG4gIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgcGFydGlhbCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIodGhpcy5fcGFydGlhbEJsb2NrW2ldKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmxvY2sgY29tcGxldGUsIHVwZGF0ZSBpbnB1dCBibG9ja1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wYXJ0aWFsQmxvY2tbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENGQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5faW5CbG9ja1tpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIHBhcnRpYWwgb3V0cHV0XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX3BhcnRpYWxCbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXJcbiAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIC8vIGJsb2NrIGNvbXBsZXRlLCB1cGRhdGUgaW5wdXQgYmxvY2tcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcGFydGlhbEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbi8qKiBPdXRwdXQgZmVlZGJhY2sgKE9GQikgKiovXG5cbm1vZGVzLm9mYiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdPRkInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKE9GQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCBhbmQgdXBkYXRlIG5leHQgaW5wdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX291dEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLm9mYi5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLm9mYi5wcm90b3R5cGUuZW5jcnlwdDtcblxuLyoqIENvdW50ZXIgKENUUikgKiovXG5cbm1vZGVzLmN0ciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDVFInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENUUiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIG91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgIH1cblxuICAgIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIGJsb2NrIGNvbXBsZXRlLCBpbmNyZW1lbnQgY291bnRlciAoaW5wdXQgYmxvY2spXG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5kZWNyeXB0ID0gbW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0O1xuXG4vKiogR2Fsb2lzL0NvdW50ZXIgTW9kZSAoR0NNKSAqKi9cblxubW9kZXMuZ2NtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0dDTSc7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcblxuICAvLyBSIGlzIGFjdHVhbGx5IHRoaXMgdmFsdWUgY29uY2F0ZW5hdGVkIHdpdGggMTIwIG1vcmUgemVybyBiaXRzLCBidXRcbiAgLy8gd2Ugb25seSBYT1IgYWdhaW5zdCBSIHNvIHRoZSBvdGhlciB6ZXJvcyBoYXZlIG5vIGVmZmVjdCAtLSB3ZSBqdXN0XG4gIC8vIGFwcGx5IHRoaXMgdmFsdWUgdG8gdGhlIGZpcnN0IGludGVnZXIgaW4gYSBibG9ja1xuICB0aGlzLl9SID0gMHhFMTAwMDAwMDtcbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gZW5zdXJlIElWIGlzIGEgYnl0ZSBidWZmZXJcbiAgdmFyIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5pdik7XG5cbiAgLy8gbm8gY2lwaGVyZWQgZGF0YSBwcm9jZXNzZWQgeWV0XG4gIHRoaXMuX2NpcGhlckxlbmd0aCA9IDA7XG5cbiAgLy8gZGVmYXVsdCBhZGRpdGlvbmFsIGRhdGEgaXMgbm9uZVxuICB2YXIgYWRkaXRpb25hbERhdGE7XG4gIGlmKCdhZGRpdGlvbmFsRGF0YScgaW4gb3B0aW9ucykge1xuICAgIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5hZGRpdGlvbmFsRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkaXRpb25hbERhdGEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0YWcgbGVuZ3RoIGlzIDEyOCBiaXRzXG4gIGlmKCd0YWdMZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSBvcHRpb25zLnRhZ0xlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSAxMjg7XG4gIH1cblxuICAvLyBpZiB0YWcgaXMgZ2l2ZW4sIGVuc3VyZSB0YWcgbWF0Y2hlcyB0YWcgbGVuZ3RoXG4gIHRoaXMuX3RhZyA9IG51bGw7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIC8vIHNhdmUgdGFnIHRvIGNoZWNrIGxhdGVyXG4gICAgdGhpcy5fdGFnID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy50YWcpLmdldEJ5dGVzKCk7XG4gICAgaWYodGhpcy5fdGFnLmxlbmd0aCAhPT0gKHRoaXMuX3RhZ0xlbmd0aCAvIDgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHRhZyBkb2VzIG5vdCBtYXRjaCB0YWcgbGVuZ3RoLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSB0bXAgc3RvcmFnZSBmb3IgaGFzaCBjYWxjdWxhdGlvblxuICB0aGlzLl9oYXNoQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG5cbiAgLy8gbm8gdGFnIGdlbmVyYXRlZCB5ZXRcbiAgdGhpcy50YWcgPSBudWxsO1xuXG4gIC8vIGdlbmVyYXRlIGhhc2ggc3Via2V5XG4gIC8vIChhcHBseSBibG9jayBjaXBoZXIgdG8gXCJ6ZXJvXCIgYmxvY2spXG4gIHRoaXMuX2hhc2hTdWJrZXkgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQoWzAsIDAsIDAsIDBdLCB0aGlzLl9oYXNoU3Via2V5KTtcblxuICAvLyBnZW5lcmF0ZSB0YWJsZSBNXG4gIC8vIHVzZSA0LWJpdCB0YWJsZXMgKDMyIGNvbXBvbmVudCBkZWNvbXBvc2l0aW9uIG9mIGEgMTYgYnl0ZSB2YWx1ZSlcbiAgLy8gOC1iaXQgdGFibGVzIHRha2UgbW9yZSBzcGFjZSBhbmQgYXJlIGtub3duIHRvIGhhdmUgc2VjdXJpdHlcbiAgLy8gdnVsbmVyYWJpbGl0aWVzIChpbiBuYXRpdmUgaW1wbGVtZW50YXRpb25zKVxuICB0aGlzLmNvbXBvbmVudEJpdHMgPSA0O1xuICB0aGlzLl9tID0gdGhpcy5nZW5lcmF0ZUhhc2hUYWJsZSh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLmNvbXBvbmVudEJpdHMpO1xuXG4gIC8vIE5vdGU6IHN1cHBvcnQgSVYgbGVuZ3RoIGRpZmZlcmVudCBmcm9tIDk2IGJpdHM/IChvbmx5IHN1cHBvcnRpbmdcbiAgLy8gOTYgYml0cyBpcyByZWNvbW1lbmRlZCBieSBOSVNUIFNQLTgwMC0zOEQpXG4gIC8vIGdlbmVyYXRlIEpfMFxuICB2YXIgaXZMZW5ndGggPSBpdi5sZW5ndGgoKTtcbiAgaWYoaXZMZW5ndGggPT09IDEyKSB7XG4gICAgLy8gOTYtYml0IElWXG4gICAgdGhpcy5fajAgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgMV07XG4gIH0gZWxzZSB7XG4gICAgLy8gSVYgaXMgTk9UIDk2LWJpdHNcbiAgICB0aGlzLl9qMCA9IFswLCAwLCAwLCAwXTtcbiAgICB3aGlsZShpdi5sZW5ndGgoKSA+IDApIHtcbiAgICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgICAgdGhpcy5faGFzaFN1YmtleSwgdGhpcy5fajAsXG4gICAgICAgIFtpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpXSk7XG4gICAgfVxuICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgIHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX2owLCBbMCwgMF0uY29uY2F0KGZyb202NFRvMzIoaXZMZW5ndGggKiA4KSkpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgSUNCIChpbml0aWFsIGNvdW50ZXIgYmxvY2spXG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9qMC5zbGljZSgwKTtcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG5cbiAgLy8gY29uc3VtZSBhdXRoZW50aWNhdGlvbiBkYXRhXG4gIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYWRkaXRpb25hbERhdGEpO1xuICAvLyBzYXZlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggYXMgYSBCRSA2NC1iaXQgbnVtYmVyXG4gIHRoaXMuX2FEYXRhTGVuZ3RoID0gZnJvbTY0VG8zMihhZGRpdGlvbmFsRGF0YS5sZW5ndGgoKSAqIDgpO1xuICAvLyBwYWQgYWRkaXRpb25hbCBkYXRhIHRvIDEyOCBiaXQgKDE2IGJ5dGUpIGJsb2NrIHNpemVcbiAgdmFyIG92ZXJmbG93ID0gYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYob3ZlcmZsb3cpIHtcbiAgICBhZGRpdGlvbmFsRGF0YS5maWxsV2l0aEJ5dGUoMCwgdGhpcy5ibG9ja1NpemUgLSBvdmVyZmxvdyk7XG4gIH1cbiAgdGhpcy5fcyA9IFswLCAwLCAwLCAwXTtcbiAgd2hpbGUoYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgPiAwKSB7XG4gICAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgW1xuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKVxuICAgIF0pO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXj0gaW5wdXQuZ2V0SW50MzIoKSk7XG4gICAgfVxuICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA9PT0gMCB8fCBmaW5pc2gpIHtcbiAgICAgIC8vIGhhbmRsZSBvdmVyZmxvdyBwcmlvciB0byBoYXNoaW5nXG4gICAgICBpZihmaW5pc2gpIHtcbiAgICAgICAgLy8gZ2V0IGJsb2NrIG92ZXJmbG93XG4gICAgICAgIHZhciBvdmVyZmxvdyA9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSBvdmVyZmxvdztcbiAgICAgICAgLy8gdHJ1bmNhdGUgZm9yIGhhc2ggZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZSAtIG92ZXJmbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IG91dHB1dCBibG9jayBmb3IgaGFzaGluZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICB0aGlzLl9vdXRCbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0SW50MzIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gICAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXIsIGdldCBwYXJ0aWFsIG91dHB1dCxcbiAgICAgIC8vIGFuZCByZXR1cm4gZWFybHlcbiAgICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBoYXNoIGJsb2NrIFNcbiAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0TGVuZ3RoID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKEdDTSBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG5cbiAgLy8gdXBkYXRlIGhhc2ggYmxvY2sgU1xuICB0aGlzLl9oYXNoQmxvY2tbMF0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMl0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbM10gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCB0aGlzLl9oYXNoQmxvY2spO1xuXG4gIC8vIFhPUiBoYXNoIGlucHV0IHdpdGggb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXiB0aGlzLl9oYXNoQmxvY2tbaV0pO1xuICB9XG5cbiAgLy8gaW5jcmVtZW50IGNpcGhlciBkYXRhIGxlbmd0aFxuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmFmdGVyRmluaXNoID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gIHZhciBydmFsID0gdHJ1ZTtcblxuICAvLyBoYW5kbGUgb3ZlcmZsb3dcbiAgaWYob3B0aW9ucy5kZWNyeXB0ICYmIG9wdGlvbnMub3ZlcmZsb3cpIHtcbiAgICBvdXRwdXQudHJ1bmNhdGUodGhpcy5ibG9ja1NpemUgLSBvcHRpb25zLm92ZXJmbG93KTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBhdXRoZW50aWNhdGlvbiB0YWdcbiAgdGhpcy50YWcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGNvbmNhdGVuYXRlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggd2l0aCBjaXBoZXIgbGVuZ3RoXG4gIHZhciBsZW5ndGhzID0gdGhpcy5fYURhdGFMZW5ndGguY29uY2F0KGZyb202NFRvMzIodGhpcy5fY2lwaGVyTGVuZ3RoICogOCkpO1xuXG4gIC8vIGluY2x1ZGUgbGVuZ3RocyBpbiBoYXNoXG4gIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIGxlbmd0aHMpO1xuXG4gIC8vIGRvIEdDVFIoSl8wLCBTKVxuICB2YXIgdGFnID0gW107XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5fajAsIHRhZyk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLnRhZy5wdXRJbnQzMih0aGlzLl9zW2ldIF4gdGFnW2ldKTtcbiAgfVxuXG4gIC8vIHRyaW0gdGFnIHRvIGxlbmd0aFxuICB0aGlzLnRhZy50cnVuY2F0ZSh0aGlzLnRhZy5sZW5ndGgoKSAlICh0aGlzLl90YWdMZW5ndGggLyA4KSk7XG5cbiAgLy8gY2hlY2sgYXV0aGVudGljYXRpb24gdGFnXG4gIGlmKG9wdGlvbnMuZGVjcnlwdCAmJiB0aGlzLnRhZy5ieXRlcygpICE9PSB0aGlzLl90YWcpIHtcbiAgICBydmFsID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU2VlIE5JU1QgU1AtODAwLTM4RCA2LjMgKEFsZ29yaXRobSAxKS4gVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBHYWxvaXNcbiAqIGZpZWxkIG11bHRpcGxpY2F0aW9uLiBUaGUgZmllbGQsIEdGKDJeMTI4KSwgaXMgZGVmaW5lZCBieSB0aGUgcG9seW5vbWlhbDpcbiAqXG4gKiB4XjEyOCArIHheNyArIHheMiArIHggKyAxXG4gKlxuICogV2hpY2ggaXMgcmVwcmVzZW50ZWQgaW4gbGl0dGxlLWVuZGlhbiBiaW5hcnkgZm9ybSBhczogMTExMDAwMDEgKDB4ZTEpLiBXaGVuXG4gKiB0aGUgdmFsdWUgb2YgYSBjb2VmZmljaWVudCBpcyAxLCBhIGJpdCBpcyBzZXQuIFRoZSB2YWx1ZSBSLCBpcyB0aGVcbiAqIGNvbmNhdGVuYXRpb24gb2YgdGhpcyB2YWx1ZSBhbmQgMTIwIHplcm8gYml0cywgeWllbGRpbmcgYSAxMjgtYml0IHZhbHVlXG4gKiB3aGljaCBtYXRjaGVzIHRoZSBibG9jayBzaXplLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtdWx0aXBseSB0d28gZWxlbWVudHMgKHZlY3RvcnMgb2YgYnl0ZXMpLCBYIGFuZCBZLCBpblxuICogdGhlIGZpZWxkIEdGKDJeMTI4KS4gVGhlIHJlc3VsdCBpcyBpbml0aWFsaXplZCB0byB6ZXJvLiBGb3IgZWFjaCBiaXQgb2ZcbiAqIFggKG91dCBvZiAxMjgpLCB4X2ksIGlmIHhfaSBpcyBzZXQsIHRoZW4gdGhlIHJlc3VsdCBpcyBtdWx0aXBsaWVkIChYT1InZClcbiAqIGJ5IHRoZSBjdXJyZW50IHZhbHVlIG9mIFkuIEZvciBlYWNoIGJpdCwgdGhlIHZhbHVlIG9mIFkgd2lsbCBiZSByYWlzZWQgYnlcbiAqIGEgcG93ZXIgb2YgeCAobXVsdGlwbGllZCBieSB0aGUgcG9seW5vbWlhbCB4KS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnlcbiAqIHNoaWZ0aW5nIFkgb25jZSB0byB0aGUgcmlnaHQuIElmIHRoZSBjdXJyZW50IHZhbHVlIG9mIFksIHByaW9yIHRvIGJlaW5nXG4gKiBtdWx0aXBsaWVkIGJ5IHgsIGhhcyAwIGFzIGl0cyBMU0IsIHRoZW4gaXQgaXMgYSAxMjd0aCBkZWdyZWUgcG9seW5vbWlhbC5cbiAqIE90aGVyd2lzZSwgd2UgbXVzdCBkaXZpZGUgYnkgUiBhZnRlciBzaGlmdGluZyB0byBmaW5kIHRoZSByZW1haW5kZXIuXG4gKlxuICogQHBhcmFtIHggdGhlIGZpcnN0IGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBzZWNvbmQuXG4gKiBAcGFyYW0geSB0aGUgc2Vjb25kIGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBmaXJzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBibG9jayByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgel9pID0gWzAsIDAsIDAsIDBdO1xuICB2YXIgdl9pID0geS5zbGljZSgwKTtcblxuICAvLyBjYWxjdWxhdGUgWl8xMjggKGJsb2NrIGhhcyAxMjggYml0cylcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgLy8gaWYgeF9pIGlzIDAsIFpfe2krMX0gPSBaX2kgKHVuY2hhbmdlZClcbiAgICAvLyBlbHNlIFpfe2krMX0gPSBaX2kgXiBWX2lcbiAgICAvLyBnZXQgeF9pIGJ5IGZpbmRpbmcgMzItYml0IGludCBwb3NpdGlvbiwgdGhlbiBsZWZ0IHNoaWZ0IDEgYnkgcmVtYWluZGVyXG4gICAgdmFyIHhfaSA9IHhbKGkgLyAzMikgfCAwXSAmICgxIDw8ICgzMSAtIGkgJSAzMikpO1xuICAgIGlmKHhfaSkge1xuICAgICAgel9pWzBdIF49IHZfaVswXTtcbiAgICAgIHpfaVsxXSBePSB2X2lbMV07XG4gICAgICB6X2lbMl0gXj0gdl9pWzJdO1xuICAgICAgel9pWzNdIF49IHZfaVszXTtcbiAgICB9XG5cbiAgICAvLyBpZiBMU0IoVl9pKSBpcyAxLCBWX2kgPSBWX2kgPj4gMVxuICAgIC8vIGVsc2UgVl9pID0gKFZfaSA+PiAxKSBeIFJcbiAgICB0aGlzLnBvdyh2X2ksIHZfaSk7XG4gIH1cblxuICByZXR1cm4gel9pO1xufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbih4LCBvdXQpIHtcbiAgLy8gaWYgTFNCKHgpIGlzIDEsIHggPSB4ID4+PiAxXG4gIC8vIGVsc2UgeCA9ICh4ID4+PiAxKSBeIFJcbiAgdmFyIGxzYiA9IHhbM10gJiAxO1xuXG4gIC8vIGFsd2F5cyBkbyB4ID4+PiAxOlxuICAvLyBzdGFydGluZyB3aXRoIHRoZSByaWdodG1vc3QgaW50ZWdlciwgc2hpZnQgZWFjaCBpbnRlZ2VyIHRvIHRoZSByaWdodFxuICAvLyBvbmUgYml0LCBwdWxsaW5nIGluIHRoZSBiaXQgZnJvbSB0aGUgaW50ZWdlciB0byB0aGUgbGVmdCBhcyBpdHMgdG9wXG4gIC8vIG1vc3QgYml0IChkbyB0aGlzIGZvciB0aGUgbGFzdCAzIGludGVnZXJzKVxuICBmb3IodmFyIGkgPSAzOyBpID4gMDsgLS1pKSB7XG4gICAgb3V0W2ldID0gKHhbaV0gPj4+IDEpIHwgKCh4W2kgLSAxXSAmIDEpIDw8IDMxKTtcbiAgfVxuICAvLyBzaGlmdCB0aGUgZmlyc3QgaW50ZWdlciBub3JtYWxseVxuICBvdXRbMF0gPSB4WzBdID4+PiAxO1xuXG4gIC8vIGlmIGxzYiB3YXMgbm90IHNldCwgdGhlbiBwb2x5bm9taWFsIGhhZCBhIGRlZ3JlZSBvZiAxMjcgYW5kIGRvZXNuJ3RcbiAgLy8gbmVlZCB0byBkaXZpZGVkOyBvdGhlcndpc2UsIFhPUiB3aXRoIFIgdG8gZmluZCB0aGUgcmVtYWluZGVyOyB3ZSBvbmx5XG4gIC8vIG5lZWQgdG8gWE9SIHRoZSBmaXJzdCBpbnRlZ2VyIHNpbmNlIFIgdGVjaG5pY2FsbHkgZW5kcyB3LzEyMCB6ZXJvIGJpdHNcbiAgaWYobHNiKSB7XG4gICAgb3V0WzBdIF49IHRoaXMuX1I7XG4gIH1cbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUudGFibGVNdWx0aXBseSA9IGZ1bmN0aW9uKHgpIHtcbiAgLy8gYXNzdW1lcyA0LWJpdCB0YWJsZXMgYXJlIHVzZWRcbiAgdmFyIHogPSBbMCwgMCwgMCwgMF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChpIC8gOCkgfCAwO1xuICAgIHZhciB4X2kgPSAoeFtpZHhdID4+PiAoKDcgLSAoaSAlIDgpKSAqIDQpKSAmIDB4RjtcbiAgICB2YXIgYWggPSB0aGlzLl9tW2ldW3hfaV07XG4gICAgelswXSBePSBhaFswXTtcbiAgICB6WzFdIF49IGFoWzFdO1xuICAgIHpbMl0gXj0gYWhbMl07XG4gICAgelszXSBePSBhaFszXTtcbiAgfVxuICByZXR1cm4gejtcbn07XG5cbi8qKlxuICogQSBjb250aW51aW5nIHZlcnNpb24gb2YgdGhlIEdIQVNIIGFsZ29yaXRobSB0aGF0IG9wZXJhdGVzIG9uIGEgc2luZ2xlXG4gKiBibG9jay4gVGhlIGhhc2ggYmxvY2ssIGxhc3QgaGFzaCB2YWx1ZSAoWW0pIGFuZCB0aGUgbmV3IGJsb2NrIHRvIGhhc2hcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBibG9jay5cbiAqIEBwYXJhbSB5IHRoZSBwcmV2aW91cyB2YWx1ZSBmb3IgWW0sIHVzZSBbMCwgMCwgMCwgMF0gZm9yIGEgbmV3IGhhc2guXG4gKiBAcGFyYW0geCB0aGUgYmxvY2sgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBoYXNoZWQgdmFsdWUgKFltKS5cbiAqL1xubW9kZXMuZ2NtLnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uKGgsIHksIHgpIHtcbiAgeVswXSBePSB4WzBdO1xuICB5WzFdIF49IHhbMV07XG4gIHlbMl0gXj0geFsyXTtcbiAgeVszXSBePSB4WzNdO1xuICByZXR1cm4gdGhpcy50YWJsZU11bHRpcGx5KHkpO1xuICAvL3JldHVybiB0aGlzLm11bHRpcGx5KHksIGgpO1xufTtcblxuLyoqXG4gKiBQcmVjb21wdXRlcyBhIHRhYmxlIGZvciBtdWx0aXBseWluZyBhZ2FpbnN0IHRoZSBoYXNoIHN1YmtleS4gVGhpc1xuICogbWVjaGFuaXNtIHByb3ZpZGVzIGEgc3Vic3RhbnRpYWwgc3BlZWQgaW5jcmVhc2Ugb3ZlciBtdWx0aXBsaWNhdGlvblxuICogcGVyZm9ybWVkIHdpdGhvdXQgYSB0YWJsZS4gVGhlIHRhYmxlLWJhc2VkIG11bHRpcGxpY2F0aW9uIHRoaXMgdGFibGUgaXNcbiAqIGZvciBzb2x2ZXMgWCAqIEggYnkgbXVsdGlwbHlpbmcgZWFjaCBjb21wb25lbnQgb2YgWCBieSBIIGFuZCB0aGVuXG4gKiBjb21wb3NpbmcgdGhlIHJlc3VsdHMgdG9nZXRoZXIgdXNpbmcgWE9SLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGFibGVzIHdpdGggZGlmZmVyZW50IGJpdCBzaXplc1xuICogZm9yIHRoZSBjb21wb25lbnRzLCBob3dldmVyLCB0aGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhlcmUgYXJlXG4gKiAzMiBjb21wb25lbnRzIG9mIFggKHdoaWNoIGlzIGEgMTYgYnl0ZSB2ZWN0b3IpLCB0aGVyZWZvcmUgZWFjaCBjb21wb25lbnRcbiAqIHRha2VzIDQtYml0cyAoc28gdGhlIHRhYmxlIGlzIGNvbnN0cnVjdGVkIHdpdGggYml0cz00KS5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBzdWJrZXkuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlSGFzaFRhYmxlID0gZnVuY3Rpb24oaCwgYml0cykge1xuICAvLyBUT0RPOiBUaGVyZSBhcmUgZnVydGhlciBvcHRpbWl6YXRpb25zIHRoYXQgd291bGQgdXNlIG9ubHkgdGhlXG4gIC8vIGZpcnN0IHRhYmxlIE1fMCAob3Igc29tZSB2YXJpYW50KSBhbG9uZyB3aXRoIGEgcmVtYWluZGVyIHRhYmxlO1xuICAvLyB0aGlzIGNhbiBiZSBleHBsb3JlZCBpbiB0aGUgZnV0dXJlXG4gIHZhciBtdWx0aXBsaWVyID0gOCAvIGJpdHM7XG4gIHZhciBwZXJJbnQgPSA0ICogbXVsdGlwbGllcjtcbiAgdmFyIHNpemUgPSAxNiAqIG11bHRpcGxpZXI7XG4gIHZhciBtID0gbmV3IEFycmF5KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgdmFyIHRtcCA9IFswLCAwLCAwLCAwXTtcbiAgICB2YXIgaWR4ID0gKGkgLyBwZXJJbnQpIHwgMDtcbiAgICB2YXIgc2hmdCA9ICgocGVySW50IC0gMSAtIChpICUgcGVySW50KSkgKiBiaXRzKTtcbiAgICB0bXBbaWR4XSA9ICgxIDw8IChiaXRzIC0gMSkpIDw8IHNoZnQ7XG4gICAgbVtpXSA9IHRoaXMuZ2VuZXJhdGVTdWJIYXNoVGFibGUodGhpcy5tdWx0aXBseSh0bXAsIGgpLCBiaXRzKTtcbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdGFibGUgZm9yIG11bHRpcGx5aW5nIGFnYWluc3QgdGhlIGhhc2ggc3Via2V5IGZvciBvbmVcbiAqIHBhcnRpY3VsYXIgY29tcG9uZW50IChvdXQgb2YgYWxsIHBvc3NpYmxlIGNvbXBvbmVudCB2YWx1ZXMpLlxuICpcbiAqIEBwYXJhbSBtaWQgdGhlIHByZS1tdWx0aXBsaWVkIHZhbHVlIGZvciB0aGUgbWlkZGxlIGtleSBvZiB0aGUgdGFibGUuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlU3ViSGFzaFRhYmxlID0gZnVuY3Rpb24obWlkLCBiaXRzKSB7XG4gIC8vIGNvbXB1dGUgdGhlIHRhYmxlIHF1aWNrbHkgYnkgbWluaW1pemluZyB0aGUgbnVtYmVyIG9mXG4gIC8vIFBPVyBvcGVyYXRpb25zIC0tIHRoZXkgb25seSBuZWVkIHRvIGJlIHBlcmZvcm1lZCBmb3IgcG93ZXJzIG9mIDIsXG4gIC8vIGFsbCBvdGhlciBlbnRyaWVzIGNhbiBiZSBjb21wb3NlZCBmcm9tIHRob3NlIHBvd2VycyB1c2luZyBYT1JcbiAgdmFyIHNpemUgPSAxIDw8IGJpdHM7XG4gIHZhciBoYWxmID0gc2l6ZSA+Pj4gMTtcbiAgdmFyIG0gPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIG1baGFsZl0gPSBtaWQuc2xpY2UoMCk7XG4gIHZhciBpID0gaGFsZiA+Pj4gMTtcbiAgd2hpbGUoaSA+IDApIHtcbiAgICAvLyByYWlzZSBtMFsyICogaV0gYW5kIHN0b3JlIGluIG0wW2ldXG4gICAgdGhpcy5wb3cobVsyICogaV0sIG1baV0gPSBbXSk7XG4gICAgaSA+Pj0gMTtcbiAgfVxuICBpID0gMjtcbiAgd2hpbGUoaSA8IGhhbGYpIHtcbiAgICBmb3IodmFyIGogPSAxOyBqIDwgaTsgKytqKSB7XG4gICAgICB2YXIgbV9pID0gbVtpXTtcbiAgICAgIHZhciBtX2ogPSBtW2pdO1xuICAgICAgbVtpICsgal0gPSBbXG4gICAgICAgIG1faVswXSBeIG1falswXSxcbiAgICAgICAgbV9pWzFdIF4gbV9qWzFdLFxuICAgICAgICBtX2lbMl0gXiBtX2pbMl0sXG4gICAgICAgIG1faVszXSBeIG1falszXVxuICAgICAgXTtcbiAgICB9XG4gICAgaSAqPSAyO1xuICB9XG4gIG1bMF0gPSBbMCwgMCwgMCwgMF07XG4gIC8qIE5vdGU6IFdlIGNvdWxkIGF2b2lkIHN0b3JpbmcgdGhlc2UgYnkgZG9pbmcgY29tcG9zaXRpb24gZHVyaW5nIG11bHRpcGx5XG4gIGNhbGN1bGF0ZSB0b3AgaGFsZiB1c2luZyBjb21wb3NpdGlvbiBieSBzcGVlZCBpcyBwcmVmZXJyZWQuICovXG4gIGZvcihpID0gaGFsZiArIDE7IGkgPCBzaXplOyArK2kpIHtcbiAgICB2YXIgYyA9IG1baSBeIGhhbGZdO1xuICAgIG1baV0gPSBbbWlkWzBdIF4gY1swXSwgbWlkWzFdIF4gY1sxXSwgbWlkWzJdIF4gY1syXSwgbWlkWzNdIF4gY1szXV07XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtSVYoaXYpIHtcbiAgaWYodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGNvbnZlcnQgaXYgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgfVxuXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShpdikgJiYgaXYubGVuZ3RoID4gNCkge1xuICAgIC8vIGNvbnZlcnQgaXYgYnl0ZSBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdmFyIHRtcCA9IGl2O1xuICAgIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICBpdi5wdXRCeXRlKHRtcFtpXSk7XG4gICAgfVxuICB9XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoaXYpKSB7XG4gICAgLy8gY29udmVydCBpdiBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gICAgaXYgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKV07XG4gIH1cblxuICByZXR1cm4gaXY7XG59XG5cbmZ1bmN0aW9uIGluYzMyKGJsb2NrKSB7XG4gIC8vIGluY3JlbWVudCBsYXN0IDMyIGJpdHMgb2YgYmxvY2sgb25seVxuICBibG9ja1tibG9jay5sZW5ndGggLSAxXSA9IChibG9ja1tibG9jay5sZW5ndGggLSAxXSArIDEpICYgMHhGRkZGRkZGRjtcbn1cblxuZnVuY3Rpb24gZnJvbTY0VG8zMihudW0pIHtcbiAgLy8gY29udmVydCA2NC1iaXQgbnVtYmVyIHRvIHR3byBCRSBJbnQzMnNcbiAgcmV0dXJuIFsobnVtIC8gMHgxMDAwMDAwMDApIHwgMCwgbnVtICYgMHhGRkZGRkZGRl07XG59XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIERFUyAoRGF0YSBFbmNyeXB0aW9uIFN0YW5kYXJkKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIHN1cHBvcnRzIERFUyBhcyB3ZWxsIGFzIDNERVMtRURFIGluIEVDQiBhbmQgQ0JDIG1vZGUuXG4gKiBJdCBpcyBiYXNlZCBvbiB0aGUgQlNELWxpY2Vuc2VkIGltcGxlbWVudGF0aW9uIGJ5IFBhdWwgVGVybzpcbiAqXG4gKiBQYXVsIFRlcm8sIEp1bHkgMjAwMVxuICogaHR0cDovL3d3dy50ZXJvLmNvLnVrL2Rlcy9cbiAqXG4gKiBPcHRpbWlzZWQgZm9yIHBlcmZvcm1hbmNlIHdpdGggbGFyZ2UgYmxvY2tzIGJ5IE1pY2hhZWwgSGF5d29ydGgsIE5vdmVtYmVyIDIwMDFcbiAqIGh0dHA6Ly93d3cubmV0ZGVhbGluZy5jb21cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICogSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1RcbiAqIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVlcbiAqIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAqIFNVQ0ggREFNQUdFLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBERVMgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmRlcyA9IGZvcmdlLmRlcyB8fCB7fTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gJ0VDQicgOiAnQ0JDJylcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqIGRlY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZSB8fCAoaXYgPT09IG51bGwgPyAnRUNCJyA6ICdDQkMnKVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgREVTIGNpcGhlciBhbGdvcml0aG0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gbW9kZSB0aGUgbW9kZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIERFUyBhbGdvcml0aG0gb2JqZWN0LlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYubmFtZSA9IG5hbWU7XG4gIHNlbGYubW9kZSA9IG5ldyBtb2RlKHtcbiAgICBibG9ja1NpemU6IDgsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX2tleXMsIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl9rZXlzLCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIERFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMua2V5KTtcbiAgaWYodGhpcy5uYW1lLmluZGV4T2YoJzNERVMnKSA9PT0gMCkge1xuICAgIGlmKGtleS5sZW5ndGgoKSAhPT0gMjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBUcmlwbGUtREVTIGtleSBzaXplOiAnICsga2V5Lmxlbmd0aCgpICogOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvbiB0byAxNiBvciA0OCBzdWJrZXlzIChzaW5nbGUgb3IgdHJpcGxlIERFUylcbiAgdGhpcy5fa2V5cyA9IF9jcmVhdGVLZXlzKGtleSk7XG4gIHRoaXMuX2luaXQgPSB0cnVlO1xufTtcblxuLyoqIFJlZ2lzdGVyIERFUyBhbGdvcml0aG1zICoqL1xuXG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUVDQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtQ0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLU9GQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuZGVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogREVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgc3BmdW5jdGlvbjEgPSBbMHgxMDEwNDAwLDAsMHgxMDAwMCwweDEwMTA0MDQsMHgxMDEwMDA0LDB4MTA0MDQsMHg0LDB4MTAwMDAsMHg0MDAsMHgxMDEwNDAwLDB4MTAxMDQwNCwweDQwMCwweDEwMDA0MDQsMHgxMDEwMDA0LDB4MTAwMDAwMCwweDQsMHg0MDQsMHgxMDAwNDAwLDB4MTAwMDQwMCwweDEwNDAwLDB4MTA0MDAsMHgxMDEwMDAwLDB4MTAxMDAwMCwweDEwMDA0MDQsMHgxMDAwNCwweDEwMDAwMDQsMHgxMDAwMDA0LDB4MTAwMDQsMCwweDQwNCwweDEwNDA0LDB4MTAwMDAwMCwweDEwMDAwLDB4MTAxMDQwNCwweDQsMHgxMDEwMDAwLDB4MTAxMDQwMCwweDEwMDAwMDAsMHgxMDAwMDAwLDB4NDAwLDB4MTAxMDAwNCwweDEwMDAwLDB4MTA0MDAsMHgxMDAwMDA0LDB4NDAwLDB4NCwweDEwMDA0MDQsMHgxMDQwNCwweDEwMTA0MDQsMHgxMDAwNCwweDEwMTAwMDAsMHgxMDAwNDA0LDB4MTAwMDAwNCwweDQwNCwweDEwNDA0LDB4MTAxMDQwMCwweDQwNCwweDEwMDA0MDAsMHgxMDAwNDAwLDAsMHgxMDAwNCwweDEwNDAwLDAsMHgxMDEwMDA0XTtcbnZhciBzcGZ1bmN0aW9uMiA9IFstMHg3ZmVmN2ZlMCwtMHg3ZmZmODAwMCwweDgwMDAsMHgxMDgwMjAsMHgxMDAwMDAsMHgyMCwtMHg3ZmVmZmZlMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwtMHg3ZmVmN2ZlMCwtMHg3ZmVmODAwMCwtMHg4MDAwMDAwMCwtMHg3ZmZmODAwMCwweDEwMDAwMCwweDIwLC0weDdmZWZmZmUwLDB4MTA4MDAwLDB4MTAwMDIwLC0weDdmZmY3ZmUwLDAsLTB4ODAwMDAwMDAsMHg4MDAwLDB4MTA4MDIwLC0weDdmZjAwMDAwLDB4MTAwMDIwLC0weDdmZmZmZmUwLDAsMHgxMDgwMDAsMHg4MDIwLC0weDdmZWY4MDAwLC0weDdmZjAwMDAwLDB4ODAyMCwwLDB4MTA4MDIwLC0weDdmZWZmZmUwLDB4MTAwMDAwLC0weDdmZmY3ZmUwLC0weDdmZjAwMDAwLC0weDdmZWY4MDAwLDB4ODAwMCwtMHg3ZmYwMDAwMCwtMHg3ZmZmODAwMCwweDIwLC0weDdmZWY3ZmUwLDB4MTA4MDIwLDB4MjAsMHg4MDAwLC0weDgwMDAwMDAwLDB4ODAyMCwtMHg3ZmVmODAwMCwweDEwMDAwMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwweDEwODAwMCwwLC0weDdmZmY4MDAwLDB4ODAyMCwtMHg4MDAwMDAwMCwtMHg3ZmVmZmZlMCwtMHg3ZmVmN2ZlMCwweDEwODAwMF07XG52YXIgc3BmdW5jdGlvbjMgPSBbMHgyMDgsMHg4MDIwMjAwLDAsMHg4MDIwMDA4LDB4ODAwMDIwMCwwLDB4MjAyMDgsMHg4MDAwMjAwLDB4MjAwMDgsMHg4MDAwMDA4LDB4ODAwMDAwOCwweDIwMDAwLDB4ODAyMDIwOCwweDIwMDA4LDB4ODAyMDAwMCwweDIwOCwweDgwMDAwMDAsMHg4LDB4ODAyMDIwMCwweDIwMCwweDIwMjAwLDB4ODAyMDAwMCwweDgwMjAwMDgsMHgyMDIwOCwweDgwMDAyMDgsMHgyMDIwMCwweDIwMDAwLDB4ODAwMDIwOCwweDgsMHg4MDIwMjA4LDB4MjAwLDB4ODAwMDAwMCwweDgwMjAyMDAsMHg4MDAwMDAwLDB4MjAwMDgsMHgyMDgsMHgyMDAwMCwweDgwMjAyMDAsMHg4MDAwMjAwLDAsMHgyMDAsMHgyMDAwOCwweDgwMjAyMDgsMHg4MDAwMjAwLDB4ODAwMDAwOCwweDIwMCwwLDB4ODAyMDAwOCwweDgwMDAyMDgsMHgyMDAwMCwweDgwMDAwMDAsMHg4MDIwMjA4LDB4OCwweDIwMjA4LDB4MjAyMDAsMHg4MDAwMDA4LDB4ODAyMDAwMCwweDgwMDAyMDgsMHgyMDgsMHg4MDIwMDAwLDB4MjAyMDgsMHg4LDB4ODAyMDAwOCwweDIwMjAwXTtcbnZhciBzcGZ1bmN0aW9uNCA9IFsweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODAsMHg4MDAwODEsMHg4MDAwMDEsMHgyMDAxLDAsMHg4MDIwMDAsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDB4ODAwMDgwLDB4ODAwMDAxLDB4MSwweDIwMDAsMHg4MDAwMDAsMHg4MDIwMDEsMHg4MCwweDgwMDAwMCwweDIwMDEsMHgyMDgwLDB4ODAwMDgxLDB4MSwweDIwODAsMHg4MDAwODAsMHgyMDAwLDB4ODAyMDgwLDB4ODAyMDgxLDB4ODEsMHg4MDAwODAsMHg4MDAwMDEsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDAsMHg4MDIwMDAsMHgyMDgwLDB4ODAwMDgwLDB4ODAwMDgxLDB4MSwweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODEsMHg4MSwweDEsMHgyMDAwLDB4ODAwMDAxLDB4MjAwMSwweDgwMjA4MCwweDgwMDA4MSwweDIwMDEsMHgyMDgwLDB4ODAwMDAwLDB4ODAyMDAxLDB4ODAsMHg4MDAwMDAsMHgyMDAwLDB4ODAyMDgwXTtcbnZhciBzcGZ1bmN0aW9uNSA9IFsweDEwMCwweDIwODAxMDAsMHgyMDgwMDAwLDB4NDIwMDAxMDAsMHg4MDAwMCwweDEwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQwMDgwMTAwLDB4ODAwMDAsMHgyMDAwMTAwLDB4NDAwODAxMDAsMHg0MjAwMDEwMCwweDQyMDgwMDAwLDB4ODAxMDAsMHg0MDAwMDAwMCwweDIwMDAwMDAsMHg0MDA4MDAwMCwweDQwMDgwMDAwLDAsMHg0MDAwMDEwMCwweDQyMDgwMTAwLDB4NDIwODAxMDAsMHgyMDAwMTAwLDB4NDIwODAwMDAsMHg0MDAwMDEwMCwwLDB4NDIwMDAwMDAsMHgyMDgwMTAwLDB4MjAwMDAwMCwweDQyMDAwMDAwLDB4ODAxMDAsMHg4MDAwMCwweDQyMDAwMTAwLDB4MTAwLDB4MjAwMDAwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQyMDAwMTAwLDB4NDAwODAxMDAsMHgyMDAwMTAwLDB4NDAwMDAwMDAsMHg0MjA4MDAwMCwweDIwODAxMDAsMHg0MDA4MDEwMCwweDEwMCwweDIwMDAwMDAsMHg0MjA4MDAwMCwweDQyMDgwMTAwLDB4ODAxMDAsMHg0MjAwMDAwMCwweDQyMDgwMTAwLDB4MjA4MDAwMCwwLDB4NDAwODAwMDAsMHg0MjAwMDAwMCwweDgwMTAwLDB4MjAwMDEwMCwweDQwMDAwMTAwLDB4ODAwMDAsMCwweDQwMDgwMDAwLDB4MjA4MDEwMCwweDQwMDAwMTAwXTtcbnZhciBzcGZ1bmN0aW9uNiA9IFsweDIwMDAwMDEwLDB4MjA0MDAwMDAsMHg0MDAwLDB4MjA0MDQwMTAsMHgyMDQwMDAwMCwweDEwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDQwNDAxMCwweDQwMDAwMCwweDIwMDAwMDEwLDB4NDAwMDEwLDB4MjAwMDQwMDAsMHgyMDAwMDAwMCwweDQwMTAsMCwweDQwMDAxMCwweDIwMDA0MDEwLDB4NDAwMCwweDQwNDAwMCwweDIwMDA0MDEwLDB4MTAsMHgyMDQwMDAxMCwweDIwNDAwMDEwLDAsMHg0MDQwMTAsMHgyMDQwNDAwMCwweDQwMTAsMHg0MDQwMDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4MjAwMDQwMDAsMHgxMCwweDIwNDAwMDEwLDB4NDA0MDAwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHg0MDEwLDB4MjAwMDAwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDIwMDAwMDAwLDB4NDAxMCwweDIwMDAwMDEwLDB4MjA0MDQwMTAsMHg0MDQwMDAsMHgyMDQwMDAwMCwweDQwNDAxMCwweDIwNDA0MDAwLDAsMHgyMDQwMDAxMCwweDEwLDB4NDAwMCwweDIwNDAwMDAwLDB4NDA0MDEwLDB4NDAwMCwweDQwMDAxMCwweDIwMDA0MDEwLDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4NDAwMDEwLDB4MjAwMDQwMTBdO1xudmFyIHNwZnVuY3Rpb243ID0gWzB4MjAwMDAwLDB4NDIwMDAwMiwweDQwMDA4MDIsMCwweDgwMCwweDQwMDA4MDIsMHgyMDA4MDIsMHg0MjAwODAwLDB4NDIwMDgwMiwweDIwMDAwMCwwLDB4NDAwMDAwMiwweDIsMHg0MDAwMDAwLDB4NDIwMDAwMiwweDgwMiwweDQwMDA4MDAsMHgyMDA4MDIsMHgyMDAwMDIsMHg0MDAwODAwLDB4NDAwMDAwMiwweDQyMDAwMDAsMHg0MjAwODAwLDB4MjAwMDAyLDB4NDIwMDAwMCwweDgwMCwweDgwMiwweDQyMDA4MDIsMHgyMDA4MDAsMHgyLDB4NDAwMDAwMCwweDIwMDgwMCwweDQwMDAwMDAsMHgyMDA4MDAsMHgyMDAwMDAsMHg0MDAwODAyLDB4NDAwMDgwMiwweDQyMDAwMDIsMHg0MjAwMDAyLDB4MiwweDIwMDAwMiwweDQwMDAwMDAsMHg0MDAwODAwLDB4MjAwMDAwLDB4NDIwMDgwMCwweDgwMiwweDIwMDgwMiwweDQyMDA4MDAsMHg4MDIsMHg0MDAwMDAyLDB4NDIwMDgwMiwweDQyMDAwMDAsMHgyMDA4MDAsMCwweDIsMHg0MjAwODAyLDAsMHgyMDA4MDIsMHg0MjAwMDAwLDB4ODAwLDB4NDAwMDAwMiwweDQwMDA4MDAsMHg4MDAsMHgyMDAwMDJdO1xudmFyIHNwZnVuY3Rpb244ID0gWzB4MTAwMDEwNDAsMHgxMDAwLDB4NDAwMDAsMHgxMDA0MTA0MCwweDEwMDAwMDAwLDB4MTAwMDEwNDAsMHg0MCwweDEwMDAwMDAwLDB4NDAwNDAsMHgxMDA0MDAwMCwweDEwMDQxMDQwLDB4NDEwMDAsMHgxMDA0MTAwMCwweDQxMDQwLDB4MTAwMCwweDQwLDB4MTAwNDAwMDAsMHgxMDAwMDA0MCwweDEwMDAxMDAwLDB4MTA0MCwweDQxMDAwLDB4NDAwNDAsMHgxMDA0MDA0MCwweDEwMDQxMDAwLDB4MTA0MCwwLDAsMHgxMDA0MDA0MCwweDEwMDAwMDQwLDB4MTAwMDEwMDAsMHg0MTA0MCwweDQwMDAwLDB4NDEwNDAsMHg0MDAwMCwweDEwMDQxMDAwLDB4MTAwMCwweDQwLDB4MTAwNDAwNDAsMHgxMDAwLDB4NDEwNDAsMHgxMDAwMTAwMCwweDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDQwMDQwLDB4MTAwMDAwMDAsMHg0MDAwMCwweDEwMDAxMDQwLDAsMHgxMDA0MTA0MCwweDQwMDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDAxMDAwLDB4MTAwMDEwNDAsMCwweDEwMDQxMDQwLDB4NDEwMDAsMHg0MTAwMCwweDEwNDAsMHgxMDQwLDB4NDAwNDAsMHgxMDAwMDAwMCwweDEwMDQxMDAwXTtcblxuLyoqXG4gKiBDcmVhdGUgbmVjZXNzYXJ5IHN1YiBrZXlzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIDY0LWJpdCBvciAxOTItYml0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXlzLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlS2V5cyhrZXkpIHtcbiAgdmFyIHBjMmJ5dGVzMCAgPSBbMCwweDQsMHgyMDAwMDAwMCwweDIwMDAwMDA0LDB4MTAwMDAsMHgxMDAwNCwweDIwMDEwMDAwLDB4MjAwMTAwMDQsMHgyMDAsMHgyMDQsMHgyMDAwMDIwMCwweDIwMDAwMjA0LDB4MTAyMDAsMHgxMDIwNCwweDIwMDEwMjAwLDB4MjAwMTAyMDRdLFxuICAgICAgcGMyYnl0ZXMxICA9IFswLDB4MSwweDEwMDAwMCwweDEwMDAwMSwweDQwMDAwMDAsMHg0MDAwMDAxLDB4NDEwMDAwMCwweDQxMDAwMDEsMHgxMDAsMHgxMDEsMHgxMDAxMDAsMHgxMDAxMDEsMHg0MDAwMTAwLDB4NDAwMDEwMSwweDQxMDAxMDAsMHg0MTAwMTAxXSxcbiAgICAgIHBjMmJ5dGVzMiAgPSBbMCwweDgsMHg4MDAsMHg4MDgsMHgxMDAwMDAwLDB4MTAwMDAwOCwweDEwMDA4MDAsMHgxMDAwODA4LDAsMHg4LDB4ODAwLDB4ODA4LDB4MTAwMDAwMCwweDEwMDAwMDgsMHgxMDAwODAwLDB4MTAwMDgwOF0sXG4gICAgICBwYzJieXRlczMgID0gWzAsMHgyMDAwMDAsMHg4MDAwMDAwLDB4ODIwMDAwMCwweDIwMDAsMHgyMDIwMDAsMHg4MDAyMDAwLDB4ODIwMjAwMCwweDIwMDAwLDB4MjIwMDAwLDB4ODAyMDAwMCwweDgyMjAwMDAsMHgyMjAwMCwweDIyMjAwMCwweDgwMjIwMDAsMHg4MjIyMDAwXSxcbiAgICAgIHBjMmJ5dGVzNCAgPSBbMCwweDQwMDAwLDB4MTAsMHg0MDAxMCwwLDB4NDAwMDAsMHgxMCwweDQwMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwXSxcbiAgICAgIHBjMmJ5dGVzNSAgPSBbMCwweDQwMCwweDIwLDB4NDIwLDAsMHg0MDAsMHgyMCwweDQyMCwweDIwMDAwMDAsMHgyMDAwNDAwLDB4MjAwMDAyMCwweDIwMDA0MjAsMHgyMDAwMDAwLDB4MjAwMDQwMCwweDIwMDAwMjAsMHgyMDAwNDIwXSxcbiAgICAgIHBjMmJ5dGVzNiAgPSBbMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDIsMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDJdLFxuICAgICAgcGMyYnl0ZXM3ICA9IFswLDB4MTAwMDAsMHg4MDAsMHgxMDgwMCwweDIwMDAwMDAwLDB4MjAwMTAwMDAsMHgyMDAwMDgwMCwweDIwMDEwODAwLDB4MjAwMDAsMHgzMDAwMCwweDIwODAwLDB4MzA4MDAsMHgyMDAyMDAwMCwweDIwMDMwMDAwLDB4MjAwMjA4MDAsMHgyMDAzMDgwMF0sXG4gICAgICBwYzJieXRlczggID0gWzAsMHg0MDAwMCwwLDB4NDAwMDAsMHgyLDB4NDAwMDIsMHgyLDB4NDAwMDIsMHgyMDAwMDAwLDB4MjA0MDAwMCwweDIwMDAwMDAsMHgyMDQwMDAwLDB4MjAwMDAwMiwweDIwNDAwMDIsMHgyMDAwMDAyLDB4MjA0MDAwMl0sXG4gICAgICBwYzJieXRlczkgID0gWzAsMHgxMDAwMDAwMCwweDgsMHgxMDAwMDAwOCwwLDB4MTAwMDAwMDAsMHg4LDB4MTAwMDAwMDgsMHg0MDAsMHgxMDAwMDQwMCwweDQwOCwweDEwMDAwNDA4LDB4NDAwLDB4MTAwMDA0MDAsMHg0MDgsMHgxMDAwMDQwOF0sXG4gICAgICBwYzJieXRlczEwID0gWzAsMHgyMCwwLDB4MjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgyMDAwLDB4MjAyMCwweDIwMDAsMHgyMDIwLDB4MTAyMDAwLDB4MTAyMDIwLDB4MTAyMDAwLDB4MTAyMDIwXSxcbiAgICAgIHBjMmJ5dGVzMTEgPSBbMCwweDEwMDAwMDAsMHgyMDAsMHgxMDAwMjAwLDB4MjAwMDAwLDB4MTIwMDAwMCwweDIwMDIwMCwweDEyMDAyMDAsMHg0MDAwMDAwLDB4NTAwMDAwMCwweDQwMDAyMDAsMHg1MDAwMjAwLDB4NDIwMDAwMCwweDUyMDAwMDAsMHg0MjAwMjAwLDB4NTIwMDIwMF0sXG4gICAgICBwYzJieXRlczEyID0gWzAsMHgxMDAwLDB4ODAwMDAwMCwweDgwMDEwMDAsMHg4MDAwMCwweDgxMDAwLDB4ODA4MDAwMCwweDgwODEwMDAsMHgxMCwweDEwMTAsMHg4MDAwMDEwLDB4ODAwMTAxMCwweDgwMDEwLDB4ODEwMTAsMHg4MDgwMDEwLDB4ODA4MTAxMF0sXG4gICAgICBwYzJieXRlczEzID0gWzAsMHg0LDB4MTAwLDB4MTA0LDAsMHg0LDB4MTAwLDB4MTA0LDB4MSwweDUsMHgxMDEsMHgxMDUsMHgxLDB4NSwweDEwMSwweDEwNV07XG5cbiAgLy8gaG93IG1hbnkgaXRlcmF0aW9ucyAoMSBmb3IgZGVzLCAzIGZvciB0cmlwbGUgZGVzKVxuICAvLyBjaGFuZ2VkIGJ5IFBhdWwgMTYvNi8yMDA3IHRvIHVzZSBUcmlwbGUgREVTIGZvciA5KyBieXRlIGtleXNcbiAgdmFyIGl0ZXJhdGlvbnMgPSBrZXkubGVuZ3RoKCkgPiA4ID8gMyA6IDE7XG5cbiAgLy8gc3RvcmVzIHRoZSByZXR1cm4ga2V5c1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIC8vIG5vdyBkZWZpbmUgdGhlIGxlZnQgc2hpZnRzIHdoaWNoIG5lZWQgdG8gYmUgZG9uZVxuICB2YXIgc2hpZnRzID0gWzAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDBdO1xuXG4gIHZhciBuID0gMCwgdG1wO1xuICBmb3IodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgdmFyIGxlZnQgPSBrZXkuZ2V0SW50MzIoKTtcbiAgICB2YXIgcmlnaHQgPSBrZXkuZ2V0SW50MzIoKTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gNCkgXiByaWdodCkgJiAweDBmMGYwZjBmO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMikgXiByaWdodCkgJiAweDMzMzMzMzMzO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMik7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgICBsZWZ0IF49IHRtcDtcbiAgICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICAgIC8vIHJpZ2h0IG5lZWRzIHRvIGJlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBsYXN0IGZvdXIgYml0cyBvZiBsZWZ0XG4gICAgdG1wID0gKGxlZnQgPDwgOCkgfCAoKHJpZ2h0ID4+PiAyMCkgJiAweDAwMDAwMGYwKTtcblxuICAgIC8vIGxlZnQgbmVlZHMgdG8gYmUgcHV0IHVwc2lkZSBkb3duXG4gICAgbGVmdCA9ICgocmlnaHQgPDwgMjQpIHwgKChyaWdodCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAoKHJpZ2h0ID4+PiA4KSAmIDB4ZmYwMCkgfCAoKHJpZ2h0ID4+PiAyNCkgJiAweGYwKSk7XG4gICAgcmlnaHQgPSB0bXA7XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGVzZSBzaGlmdHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IGtleXNcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2hpZnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvL3NoaWZ0IHRoZSBrZXlzIGVpdGhlciBvbmUgb3IgdHdvIGJpdHMgdG8gdGhlIGxlZnRcbiAgICAgIGlmKHNoaWZ0c1tpXSkge1xuICAgICAgICBsZWZ0ID0gKGxlZnQgPDwgMikgfCAobGVmdCA+Pj4gMjYpO1xuICAgICAgICByaWdodCA9IChyaWdodCA8PCAyKSB8IChyaWdodCA+Pj4gMjYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IChsZWZ0IDw8IDEpIHwgKGxlZnQgPj4+IDI3KTtcbiAgICAgICAgcmlnaHQgPSAocmlnaHQgPDwgMSkgfCAocmlnaHQgPj4+IDI3KTtcbiAgICAgIH1cbiAgICAgIGxlZnQgJj0gLTB4ZjtcbiAgICAgIHJpZ2h0ICY9IC0weGY7XG5cbiAgICAgIC8vIG5vdyBhcHBseSBQQy0yLCBpbiBzdWNoIGEgd2F5IHRoYXQgRSBpcyBlYXNpZXIgd2hlbiBlbmNyeXB0aW5nIG9yXG4gICAgICAvLyBkZWNyeXB0aW5nIHRoaXMgY29udmVyc2lvbiB3aWxsIGxvb2sgbGlrZSBQQy0yIGV4Y2VwdCBvbmx5IHRoZSBsYXN0IDZcbiAgICAgIC8vIGJpdHMgb2YgZWFjaCBieXRlIGFyZSB1c2VkIHJhdGhlciB0aGFuIDQ4IGNvbnNlY3V0aXZlIGJpdHMgYW5kIHRoZVxuICAgICAgLy8gb3JkZXIgb2YgbGluZXMgd2lsbCBiZSBhY2NvcmRpbmcgdG8gaG93IHRoZSBTIHNlbGVjdGlvbiBmdW5jdGlvbnMgd2lsbFxuICAgICAgLy8gYmUgYXBwbGllZDogUzIsIFM0LCBTNiwgUzgsIFMxLCBTMywgUzUsIFM3XG4gICAgICB2YXIgbGVmdHRtcCA9IChcbiAgICAgICAgcGMyYnl0ZXMwW2xlZnQgPj4+IDI4XSB8IHBjMmJ5dGVzMVsobGVmdCA+Pj4gMjQpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzMlsobGVmdCA+Pj4gMjApICYgMHhmXSB8IHBjMmJ5dGVzM1sobGVmdCA+Pj4gMTYpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzNFsobGVmdCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzNVsobGVmdCA+Pj4gOCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXM2WyhsZWZ0ID4+PiA0KSAmIDB4Zl0pO1xuICAgICAgdmFyIHJpZ2h0dG1wID0gKFxuICAgICAgICBwYzJieXRlczdbcmlnaHQgPj4+IDI4XSB8IHBjMmJ5dGVzOFsocmlnaHQgPj4+IDI0KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczlbKHJpZ2h0ID4+PiAyMCkgJiAweGZdIHwgcGMyYnl0ZXMxMFsocmlnaHQgPj4+IDE2KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczExWyhyaWdodCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzMTJbKHJpZ2h0ID4+PiA4KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczEzWyhyaWdodCA+Pj4gNCkgJiAweGZdKTtcbiAgICAgIHRtcCA9ICgocmlnaHR0bXAgPj4+IDE2KSBeIGxlZnR0bXApICYgMHgwMDAwZmZmZjtcbiAgICAgIGtleXNbbisrXSA9IGxlZnR0bXAgXiB0bXA7XG4gICAgICBrZXlzW24rK10gPSByaWdodHRtcCBeICh0bXAgPDwgMTYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDEgYnl0ZSkgdXNpbmcgREVTLiBUaGUgdXBkYXRlIHdpbGwgZWl0aGVyXG4gKiBlbmNyeXB0IG9yIGRlY3J5cHQgdGhlIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBrZXlzIHRoZSBleHBhbmRlZCBrZXlzLlxuICogQHBhcmFtIGlucHV0IHRoZSBpbnB1dCBibG9jayAoYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIHVwZGF0ZWQgb3V0cHV0IGJsb2NrLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0IHRoZSBibG9jaywgZmFsc2UgdG8gZW5jcnlwdCBpdC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKGtleXMsIGlucHV0LCBvdXRwdXQsIGRlY3J5cHQpIHtcbiAgLy8gc2V0IHVwIGxvb3BzIGZvciBzaW5nbGUgb3IgdHJpcGxlIERFU1xuICB2YXIgaXRlcmF0aW9ucyA9IGtleXMubGVuZ3RoID09PSAzMiA/IDMgOiA5O1xuICB2YXIgbG9vcGluZztcbiAgaWYoaXRlcmF0aW9ucyA9PT0gMykge1xuICAgIGxvb3BpbmcgPSBkZWNyeXB0ID8gWzMwLCAtMiwgLTJdIDogWzAsIDMyLCAyXTtcbiAgfSBlbHNlIHtcbiAgICBsb29waW5nID0gKGRlY3J5cHQgP1xuICAgICAgWzk0LCA2MiwgLTIsIDMyLCA2NCwgMiwgMzAsIC0yLCAtMl0gOlxuICAgICAgWzAsIDMyLCAyLCA2MiwgMzAsIC0yLCA2NCwgOTYsIDJdKTtcbiAgfVxuXG4gIHZhciB0bXA7XG5cbiAgdmFyIGxlZnQgPSBpbnB1dFswXTtcbiAgdmFyIHJpZ2h0ID0gaW5wdXRbMV07XG5cbiAgLy8gZmlyc3QgZWFjaCA2NCBiaXQgY2h1bmsgb2YgdGhlIG1lc3NhZ2UgbXVzdCBiZSBwZXJtdXRlZCBhY2NvcmRpbmcgdG8gSVBcbiAgdG1wID0gKChsZWZ0ID4+PiA0KSBeIHJpZ2h0KSAmIDB4MGYwZjBmMGY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDQpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gMTYpIF4gcmlnaHQpICYgMHgwMDAwZmZmZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMTYpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgOCk7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gIC8vIHJvdGF0ZSBsZWZ0IDEgYml0XG4gIGxlZnQgPSAoKGxlZnQgPDwgMSkgfCAobGVmdCA+Pj4gMzEpKTtcbiAgcmlnaHQgPSAoKHJpZ2h0IDw8IDEpIHwgKHJpZ2h0ID4+PiAzMSkpO1xuXG4gIGZvcih2YXIgaiA9IDA7IGogPCBpdGVyYXRpb25zOyBqICs9IDMpIHtcbiAgICB2YXIgZW5kbG9vcCA9IGxvb3BpbmdbaiArIDFdO1xuICAgIHZhciBsb29waW5jID0gbG9vcGluZ1tqICsgMl07XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uXG4gICAgZm9yKHZhciBpID0gbG9vcGluZ1tqXTsgaSAhPSBlbmRsb29wOyBpICs9IGxvb3BpbmMpIHtcbiAgICAgIHZhciByaWdodDEgPSByaWdodCBeIGtleXNbaV07XG4gICAgICB2YXIgcmlnaHQyID0gKChyaWdodCA+Pj4gNCkgfCAocmlnaHQgPDwgMjgpKSBeIGtleXNbaSArIDFdO1xuXG4gICAgICAvLyBwYXNzaW5nIHRoZXNlIGJ5dGVzIHRocm91Z2ggdGhlIFMgc2VsZWN0aW9uIGZ1bmN0aW9uc1xuICAgICAgdG1wID0gbGVmdDtcbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gdG1wIF4gKFxuICAgICAgICBzcGZ1bmN0aW9uMlsocmlnaHQxID4+PiAyNCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb240WyhyaWdodDEgPj4+IDE2KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjZbKHJpZ2h0MSA+Pj4gIDgpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uOFtyaWdodDEgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb24xWyhyaWdodDIgPj4+IDI0KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjNbKHJpZ2h0MiA+Pj4gMTYpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uNVsocmlnaHQyID4+PiAgOCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb243W3JpZ2h0MiAmIDB4M2ZdKTtcbiAgICB9XG4gICAgLy8gdW5yZXZlcnNlIGxlZnQgYW5kIHJpZ2h0XG4gICAgdG1wID0gbGVmdDtcbiAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgcmlnaHQgPSB0bXA7XG4gIH1cblxuICAvLyByb3RhdGUgcmlnaHQgMSBiaXRcbiAgbGVmdCA9ICgobGVmdCA+Pj4gMSkgfCAobGVmdCA8PCAzMSkpO1xuICByaWdodCA9ICgocmlnaHQgPj4+IDEpIHwgKHJpZ2h0IDw8IDMxKSk7XG5cbiAgLy8gbm93IHBlcmZvcm0gSVAtMSwgd2hpY2ggaXMgSVAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gOCkgXiBsZWZ0KSAmIDB4MDBmZjAwZmY7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDE2KSBeIHJpZ2h0KSAmIDB4MDAwMGZmZmY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDE2KTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDQpIF4gcmlnaHQpICYgMHgwZjBmMGYwZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgb3V0cHV0WzBdID0gbGVmdDtcbiAgb3V0cHV0WzFdID0gcmlnaHQ7XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBERVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogICAgICAgICAgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICogICAgICAgICAgbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlQ2lwaGVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCAnQ0JDJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIGFsZ29yaXRobSA9ICdERVMtJyArIG1vZGU7XG5cbiAgdmFyIGNpcGhlcjtcbiAgaWYob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH1cblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdGFydCBBUElcbiAgdmFyIHN0YXJ0ID0gY2lwaGVyLnN0YXJ0O1xuICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9ucykge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBzdXBwb3J0IHNlY29uZCBhcmcgYXMgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciBvdXRwdXQgPSBudWxsO1xuICAgIGlmKG9wdGlvbnMgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgIG91dHB1dCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMub3V0cHV0ID0gb3V0cHV0O1xuICAgIG9wdGlvbnMuaXYgPSBpdjtcbiAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24gIzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogU2VlIFJGQyAyODk4IGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBwa2NzNSA9IGZvcmdlLnBrY3M1ID0gZm9yZ2UucGtjczUgfHwge307XG5cbnZhciBjcnlwdG87XG5pZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0KSB7XG4gIGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xufVxuXG4vKipcbiAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBwIHRoZSBwYXNzd29yZCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBzIHRoZSBzYWx0IGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIGMgdGhlIGl0ZXJhdGlvbiBjb3VudCwgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICogQHBhcmFtIGRrTGVuIHRoZSBpbnRlbmRlZCBsZW5ndGgsIGluIGJ5dGVzLCBvZiB0aGUgZGVyaXZlZCBrZXksXG4gKiAgICAgICAgICAobWF4OiAyXjMyIC0gMSkgKiBoYXNoIGxlbmd0aCBvZiB0aGUgUFJGLlxuICogQHBhcmFtIFttZF0gdGhlIG1lc3NhZ2UgZGlnZXN0IChvciBhbGdvcml0aG0gaWRlbnRpZmllciBhcyBhIHN0cmluZykgdG8gdXNlXG4gKiAgICAgICAgICBpbiB0aGUgUFJGLCBkZWZhdWx0cyB0byBTSEEtMS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXkpXSBwcmVzZW5jZSB0cmlnZ2VycyBhc3luY2hyb25vdXMgdmVyc2lvbiwgY2FsbGVkXG4gKiAgICAgICAgICBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlcml2ZWQga2V5LCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcywgZm9yIHRoZVxuICogICAgICAgICAgIHN5bmNocm9ub3VzIHZlcnNpb24gKGlmIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCkuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGJrZGYyID0gcGtjczUucGJrZGYyID0gZnVuY3Rpb24oXG4gIHAsIHMsIGMsIGRrTGVuLCBtZCwgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG1kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtZDtcbiAgICBtZCA9IG51bGw7XG4gIH1cblxuICAvLyB1c2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlmIHBvc3NpYmxlIGFuZCBub3QgZGlzYWJsZWQsIG5vdGUgdGhhdFxuICAvLyBzb21lIG5vZGUgdmVyc2lvbnMgb25seSBzdXBwb3J0IFNIQS0xLCBvdGhlcnMgYWxsb3cgZGlnZXN0IHRvIGJlIGNoYW5nZWRcbiAgaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAgIGNyeXB0by5wYmtkZjIgJiYgKG1kID09PSBudWxsIHx8IHR5cGVvZiBtZCAhPT0gJ29iamVjdCcpICYmXG4gICAgKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA+IDQgfHwgKCFtZCB8fCBtZCA9PT0gJ3NoYTEnKSkpIHtcbiAgICBpZih0eXBlb2YgbWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkZWZhdWx0IHByZiB0byBTSEEtMVxuICAgICAgbWQgPSAnc2hhMSc7XG4gICAgfVxuICAgIHAgPSBuZXcgQnVmZmVyKHAsICdiaW5hcnknKTtcbiAgICBzID0gbmV3IEJ1ZmZlcihzLCAnYmluYXJ5Jyk7XG4gICAgaWYoIWNhbGxiYWNrKSB7XG4gICAgICBpZihjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjJTeW5jKHAsIHMsIGMsIGRrTGVuKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3J5cHRvLnBia2RmMlN5bmMocCwgcywgYywgZGtMZW4sIG1kKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgfVxuICAgIGlmKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjIocCwgcywgYywgZGtMZW4sIGZ1bmN0aW9uKGVyciwga2V5KSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcnlwdG8ucGJrZGYyKHAsIHMsIGMsIGRrTGVuLCBtZCwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIC8vIGRlZmF1bHQgcHJmIHRvIFNIQS0xXG4gICAgbWQgPSAnc2hhMSc7XG4gIH1cbiAgaWYodHlwZW9mIG1kID09PSAnc3RyaW5nJykge1xuICAgIGlmKCEobWQgaW4gZm9yZ2UubWQuYWxnb3JpdGhtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIG1kKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gIH1cblxuICB2YXIgaExlbiA9IG1kLmRpZ2VzdExlbmd0aDtcblxuICAvKiAxLiBJZiBka0xlbiA+ICgyXjMyIC0gMSkgKiBoTGVuLCBvdXRwdXQgXCJkZXJpdmVkIGtleSB0b28gbG9uZ1wiIGFuZFxuICAgIHN0b3AuICovXG4gIGlmKGRrTGVuID4gKDB4RkZGRkZGRkYgKiBoTGVuKSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Rlcml2ZWQga2V5IGlzIHRvbyBsb25nLicpO1xuICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgLyogMi4gTGV0IGxlbiBiZSB0aGUgbnVtYmVyIG9mIGhMZW4tb2N0ZXQgYmxvY2tzIGluIHRoZSBkZXJpdmVkIGtleSxcbiAgICByb3VuZGluZyB1cCwgYW5kIGxldCByIGJlIHRoZSBudW1iZXIgb2Ygb2N0ZXRzIGluIHRoZSBsYXN0XG4gICAgYmxvY2s6XG5cbiAgICBsZW4gPSBDRUlMKGRrTGVuIC8gaExlbiksXG4gICAgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbi4gKi9cbiAgdmFyIGxlbiA9IE1hdGguY2VpbChka0xlbiAvIGhMZW4pO1xuICB2YXIgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbjtcblxuICAvKiAzLiBGb3IgZWFjaCBibG9jayBvZiB0aGUgZGVyaXZlZCBrZXkgYXBwbHkgdGhlIGZ1bmN0aW9uIEYgZGVmaW5lZFxuICAgIGJlbG93IHRvIHRoZSBwYXNzd29yZCBQLCB0aGUgc2FsdCBTLCB0aGUgaXRlcmF0aW9uIGNvdW50IGMsIGFuZFxuICAgIHRoZSBibG9jayBpbmRleCB0byBjb21wdXRlIHRoZSBibG9jazpcblxuICAgIFRfMSA9IEYoUCwgUywgYywgMSksXG4gICAgVF8yID0gRihQLCBTLCBjLCAyKSxcbiAgICAuLi5cbiAgICBUX2xlbiA9IEYoUCwgUywgYywgbGVuKSxcblxuICAgIHdoZXJlIHRoZSBmdW5jdGlvbiBGIGlzIGRlZmluZWQgYXMgdGhlIGV4Y2x1c2l2ZS1vciBzdW0gb2YgdGhlXG4gICAgZmlyc3QgYyBpdGVyYXRlcyBvZiB0aGUgdW5kZXJseWluZyBwc2V1ZG9yYW5kb20gZnVuY3Rpb24gUFJGXG4gICAgYXBwbGllZCB0byB0aGUgcGFzc3dvcmQgUCBhbmQgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHNhbHQgU1xuICAgIGFuZCB0aGUgYmxvY2sgaW5kZXggaTpcblxuICAgIEYoUCwgUywgYywgaSkgPSB1XzEgWE9SIHVfMiBYT1IgLi4uIFhPUiB1X2NcblxuICAgIHdoZXJlXG5cbiAgICB1XzEgPSBQUkYoUCwgUyB8fCBJTlQoaSkpLFxuICAgIHVfMiA9IFBSRihQLCB1XzEpLFxuICAgIC4uLlxuICAgIHVfYyA9IFBSRihQLCB1X3tjLTF9KS5cblxuICAgIEhlcmUsIElOVChpKSBpcyBhIGZvdXItb2N0ZXQgZW5jb2Rpbmcgb2YgdGhlIGludGVnZXIgaSwgbW9zdFxuICAgIHNpZ25pZmljYW50IG9jdGV0IGZpcnN0LiAqL1xuICB2YXIgcHJmID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgcHJmLnN0YXJ0KG1kLCBwKTtcbiAgdmFyIGRrID0gJyc7XG4gIHZhciB4b3IsIHVfYywgdV9jMTtcblxuICAvLyBzeW5jIHZlcnNpb25cbiAgaWYoIWNhbGxiYWNrKSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8PSBsZW47ICsraSkge1xuICAgICAgLy8gUFJGKFAsIFMgfHwgSU5UKGkpKSAoZmlyc3QgaXRlcmF0aW9uKVxuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZShzKTtcbiAgICAgIHByZi51cGRhdGUoZm9yZ2UudXRpbC5pbnQzMlRvQnl0ZXMoaSkpO1xuICAgICAgeG9yID0gdV9jMSA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgICBmb3IodmFyIGogPSAyOyBqIDw9IGM7ICsraikge1xuICAgICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICAgIHByZi51cGRhdGUodV9jMSk7XG4gICAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgICAvLyBGKHAsIHMsIGMsIGkpXG4gICAgICAgIHhvciA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoeG9yLCB1X2MsIGhMZW4pO1xuICAgICAgICB1X2MxID0gdV9jO1xuICAgICAgfVxuXG4gICAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgICAgcHJvZHVjZSBhIGRlcml2ZWQga2V5IERLOlxuXG4gICAgICAgIERLID0gVF8xIHx8IFRfMiB8fCAgLi4uICB8fCBUX2xlbjwwLi5yLTE+ICovXG4gICAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuICAgIH1cbiAgICAvKiA1LiBPdXRwdXQgdGhlIGRlcml2ZWQga2V5IERLLiAqL1xuICAgIHJldHVybiBkaztcbiAgfVxuXG4gIC8vIGFzeW5jIHZlcnNpb25cbiAgdmFyIGkgPSAxLCBqO1xuICBmdW5jdGlvbiBvdXRlcigpIHtcbiAgICBpZihpID4gbGVuKSB7XG4gICAgICAvLyBkb25lXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGspO1xuICAgIH1cblxuICAgIC8vIFBSRihQLCBTIHx8IElOVChpKSkgKGZpcnN0IGl0ZXJhdGlvbilcbiAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgcHJmLnVwZGF0ZShzKTtcbiAgICBwcmYudXBkYXRlKGZvcmdlLnV0aWwuaW50MzJUb0J5dGVzKGkpKTtcbiAgICB4b3IgPSB1X2MxID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgaiA9IDI7XG4gICAgaW5uZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgIGlmKGogPD0gYykge1xuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZSh1X2MxKTtcbiAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgLy8gRihwLCBzLCBjLCBpKVxuICAgICAgeG9yID0gZm9yZ2UudXRpbC54b3JCeXRlcyh4b3IsIHVfYywgaExlbik7XG4gICAgICB1X2MxID0gdV9jO1xuICAgICAgKytqO1xuICAgICAgcmV0dXJuIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGlubmVyKTtcbiAgICB9XG5cbiAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgIHByb2R1Y2UgYSBkZXJpdmVkIGtleSBESzpcblxuICAgICAgREsgPSBUXzEgfHwgVF8yIHx8ICAuLi4gIHx8IFRfbGVuPDAuLnItMT4gKi9cbiAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuXG4gICAgKytpO1xuICAgIG91dGVyKCk7XG4gIH1cblxuICBvdXRlcigpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSGFzaC1iYXNlZCBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgaW1wbGVtZW50YXRpb24uIFJlcXVpcmVzIGEgbWVzc2FnZVxuICogZGlnZXN0IG9iamVjdCB0aGF0IGNhbiBiZSBvYnRhaW5lZCwgZm9yIGV4YW1wbGUsIGZyb20gZm9yZ2UubWQuc2hhMSBvclxuICogZm9yZ2UubWQubWQ1LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBITUFDIEFQSSAqL1xudmFyIGhtYWMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmhtYWMgPSBmb3JnZS5obWFjIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gSE1BQyBvYmplY3QgdGhhdCB1c2VzIHRoZSBnaXZlbiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhbiBITUFDIG9iamVjdC5cbiAqL1xuaG1hYy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gdGhlIGhtYWMga2V5IHRvIHVzZVxuICB2YXIgX2tleSA9IG51bGw7XG5cbiAgLy8gdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZVxuICB2YXIgX21kID0gbnVsbDtcblxuICAvLyB0aGUgaW5uZXIgcGFkZGluZ1xuICB2YXIgX2lwYWRkaW5nID0gbnVsbDtcblxuICAvLyB0aGUgb3V0ZXIgcGFkZGluZ1xuICB2YXIgX29wYWRkaW5nID0gbnVsbDtcblxuICAvLyBobWFjIGNvbnRleHRcbiAgdmFyIGN0eCA9IHt9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIEhNQUMgd2l0aCB0aGUgZ2l2ZW4ga2V5IGFuZCBtZXNzYWdlIGRpZ2VzdC5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2UsIG51bGwgdG8gcmV1c2UgdGhlIHByZXZpb3VzIG9uZSxcbiAgICogICAgICAgICAgIGEgc3RyaW5nIHRvIHVzZSBidWlsdGluICdzaGExJywgJ21kNScsICdzaGEyNTYnLlxuICAgKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGFzIGEgc3RyaW5nLCBhcnJheSBvZiBieXRlcywgYnl0ZSBidWZmZXIsXG4gICAqICAgICAgICAgICBvciBudWxsIHRvIHJldXNlIHRoZSBwcmV2aW91cyBrZXkuXG4gICAqL1xuICBjdHguc3RhcnQgPSBmdW5jdGlvbihtZCwga2V5KSB7XG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIGlmKHR5cGVvZiBtZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY3JlYXRlIGJ1aWx0aW4gbWVzc2FnZSBkaWdlc3RcbiAgICAgICAgbWQgPSBtZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZihtZCBpbiBmb3JnZS5tZC5hbGdvcml0aG1zKSB7XG4gICAgICAgICAgX21kID0gZm9yZ2UubWQuYWxnb3JpdGhtc1ttZF0uY3JlYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhhc2ggYWxnb3JpdGhtIFwiJyArIG1kICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0b3JlIG1lc3NhZ2UgZGlnZXN0XG4gICAgICAgIF9tZCA9IG1kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGtleSA9PT0gbnVsbCkge1xuICAgICAgLy8gcmV1c2UgcHJldmlvdXMga2V5XG4gICAgICBrZXkgPSBfa2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gICAgICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgLy8gY29udmVydCBieXRlIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICAgICAgdmFyIHRtcCA9IGtleTtcbiAgICAgICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleS5wdXRCeXRlKHRtcFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIGxvbmdlciB0aGFuIGJsb2Nrc2l6ZSwgaGFzaCBpdFxuICAgICAgdmFyIGtleWxlbiA9IGtleS5sZW5ndGgoKTtcbiAgICAgIGlmKGtleWxlbiA+IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICBfbWQuc3RhcnQoKTtcbiAgICAgICAgX21kLnVwZGF0ZShrZXkuYnl0ZXMoKSk7XG4gICAgICAgIGtleSA9IF9tZC5kaWdlc3QoKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWl4IGtleSBpbnRvIGlubmVyIGFuZCBvdXRlciBwYWRkaW5nXG4gICAgICAvLyBpcGFkZGluZyA9IFsweDM2ICogYmxvY2tzaXplXSBeIGtleVxuICAgICAgLy8gb3BhZGRpbmcgPSBbMHg1QyAqIGJsb2Nrc2l6ZV0gXiBrZXlcbiAgICAgIF9pcGFkZGluZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfb3BhZGRpbmcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGtleWxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0bXAgPSBrZXkuYXQoaSk7XG4gICAgICAgIF9pcGFkZGluZy5wdXRCeXRlKDB4MzYgXiB0bXApO1xuICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDIF4gdG1wKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIHNob3J0ZXIgdGhhbiBibG9ja3NpemUsIGFkZCBhZGRpdGlvbmFsIHBhZGRpbmdcbiAgICAgIGlmKGtleWxlbiA8IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICB2YXIgdG1wID0gX21kLmJsb2NrTGVuZ3RoIC0ga2V5bGVuO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wOyArK2kpIHtcbiAgICAgICAgICBfaXBhZGRpbmcucHV0Qnl0ZSgweDM2KTtcbiAgICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2tleSA9IGtleTtcbiAgICAgIF9pcGFkZGluZyA9IF9pcGFkZGluZy5ieXRlcygpO1xuICAgICAgX29wYWRkaW5nID0gX29wYWRkaW5nLmJ5dGVzKCk7XG4gICAgfVxuXG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcblxuICAgIC8vIHByZXBhcmUgdG8gZG8gaW5uZXIgaGFzaFxuICAgIC8vIGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKVxuICAgIF9tZC5zdGFydCgpO1xuICAgIF9tZC51cGRhdGUoX2lwYWRkaW5nKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgSE1BQyB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIHVwZGF0ZSB3aXRoLlxuICAgKi9cbiAgY3R4LnVwZGF0ZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgX21kLnVwZGF0ZShieXRlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgKE1BQykuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBjdHguZ2V0TWFjID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcbiAgICAvLyBoZXJlIHdlIGRvIHRoZSBvdXRlciBoYXNoaW5nXG4gICAgdmFyIGlubmVyID0gX21kLmRpZ2VzdCgpLmJ5dGVzKCk7XG4gICAgX21kLnN0YXJ0KCk7XG4gICAgX21kLnVwZGF0ZShfb3BhZGRpbmcpO1xuICAgIF9tZC51cGRhdGUoaW5uZXIpO1xuICAgIHJldHVybiBfbWQuZGlnZXN0KCk7XG4gIH07XG4gIC8vIGFsaWFzIGZvciBnZXRNYWNcbiAgY3R4LmRpZ2VzdCA9IGN0eC5nZXRNYWM7XG5cbiAgcmV0dXJuIGN0eDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiAoaWdub3JlZCkgKi9cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDUgIFRvbSBXdVxuLy8gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscy5cblxuLy8gQmFzaWMgSmF2YVNjcmlwdCBCTiBsaWJyYXJ5IC0gc3Vic2V0IHVzZWZ1bCBmb3IgUlNBIGVuY3J5cHRpb24uXG5cbi8qXG5MaWNlbnNpbmcgKExJQ0VOU0UpXG4tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblRoaXMgc29mdHdhcmUgaXMgY292ZXJlZCB1bmRlciB0aGUgZm9sbG93aW5nIGNvcHlyaWdodDpcbiovXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDAzLTIwMDUgIFRvbSBXdVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUy1JU1wiIEFORCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUywgSU1QTElFRCBPUiBPVEhFUldJU0UsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04sIEFOWVxuICogV0FSUkFOVFkgT0YgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLlxuICpcbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRPTSBXVSBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBJTkNJREVOVEFMLFxuICogSU5ESVJFQ1QgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9GIEFOWSBLSU5ELCBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSXG4gKiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIE9SIE5PVCBBRFZJU0VEIE9GXG4gKiBUSEUgUE9TU0lCSUxJVFkgT0YgREFNQUdFLCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIEFSSVNJTkcgT1VUXG4gKiBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqIEluIGFkZGl0aW9uLCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiBhcHBsaWVzOlxuICpcbiAqIEFsbCByZWRpc3RyaWJ1dGlvbnMgbXVzdCByZXRhaW4gYW4gaW50YWN0IGNvcHkgb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlXG4gKiBhbmQgZGlzY2xhaW1lci5cbiAqL1xuLypcbkFkZHJlc3MgYWxsIHF1ZXN0aW9ucyByZWdhcmRpbmcgdGhpcyBsaWNlbnNlIHRvOlxuXG4gIFRvbSBXdVxuICB0andAY3MuU3RhbmZvcmQuRURVXG4qL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5qc2JuID0gZm9yZ2UuanNibiB8fCB7fTtcblxuLy8gQml0cyBwZXIgZGlnaXRcbnZhciBkYml0cztcblxuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkmMHhmZmZmZmYpPT0weGVmY2FmZSk7XG5cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG5mdW5jdGlvbiBCaWdJbnRlZ2VyKGEsYixjKSB7XG4gIHRoaXMuZGF0YSA9IFtdO1xuICBpZihhICE9IG51bGwpXG4gICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICBlbHNlIGlmKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwyNTYpO1xuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYik7XG59XG5mb3JnZS5qc2JuLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuXG4vLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG5mdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxuXG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuXG4vLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4vLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKSB7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIHYgPSB4KnRoaXMuZGF0YVtpKytdK3cuZGF0YVtqXStjO1xuICAgIGMgPSBNYXRoLmZsb29yKHYvMHg0MDAwMDAwKTtcbiAgICB3LmRhdGFbaisrXSA9IHYmMHgzZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHg3ZmZmLCB4aCA9IHg+PjE1O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4N2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNTtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHg3ZmZmKTw8MTUpK3cuZGF0YVtqXSsoYyYweDNmZmZmZmZmKTtcbiAgICBjID0gKGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHgzZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4M2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNDtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHgzZmZmKTw8MTQpK3cuZGF0YVtqXStjO1xuICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHhmZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBub2RlLmpzIChubyBicm93c2VyKVxuaWYodHlwZW9mKG5hdmlnYXRvcikgPT09ICd1bmRlZmluZWQnKVxue1xuICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICBkYml0cyA9IDI4O1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICBkYml0cyA9IDMwO1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gIGRiaXRzID0gMjY7XG59IGVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gIGRiaXRzID0gMjg7XG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMTw8ZGJpdHMpLTEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMTw8ZGJpdHMpO1xuXG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMixCSV9GUCk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQLWRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyKmRiaXRzLUJJX0ZQO1xuXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbnZhciBCSV9SQyA9IG5ldyBBcnJheSgpO1xudmFyIHJyLHZ2O1xucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xucnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5cbmZ1bmN0aW9uIGludDJjaGFyKG4pIHsgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTsgfVxuZnVuY3Rpb24gaW50QXQocyxpKSB7XG4gIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgcmV0dXJuIChjPT1udWxsKT8tMTpjO1xufVxuXG4vLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gIHIudCA9IHRoaXMudDtcbiAgci5zID0gdGhpcy5zO1xufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbmZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICB0aGlzLnQgPSAxO1xuICB0aGlzLnMgPSAoeDwwKT8tMTowO1xuICBpZih4ID4gMCkgdGhpcy5kYXRhWzBdID0geDtcbiAgZWxzZSBpZih4IDwgLTEpIHRoaXMuZGF0YVswXSA9IHgrdGhpcy5EVjtcbiAgZWxzZSB0aGlzLnQgPSAwO1xufVxuXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkgeyB2YXIgciA9IG5iaSgpOyByLmZyb21JbnQoaSk7IHJldHVybiByOyB9XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbmZ1bmN0aW9uIGJucEZyb21TdHJpbmcocyxiKSB7XG4gIHZhciBrO1xuICBpZihiID09IDE2KSBrID0gNDtcbiAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICBlbHNlIGlmKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgZWxzZSB7IHRoaXMuZnJvbVJhZGl4KHMsYik7IHJldHVybjsgfVxuICB0aGlzLnQgPSAwO1xuICB0aGlzLnMgPSAwO1xuICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgdmFyIHggPSAoaz09OCk/c1tpXSYweGZmOmludEF0KHMsaSk7XG4gICAgaWYoeCA8IDApIHtcbiAgICAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbWkgPSBmYWxzZTtcbiAgICBpZihzaCA9PSAwKVxuICAgICAgdGhpcy5kYXRhW3RoaXMudCsrXSA9IHg7XG4gICAgZWxzZSBpZihzaCtrID4gdGhpcy5EQikge1xuICAgICAgdGhpcy5kYXRhW3RoaXMudC0xXSB8PSAoeCYoKDE8PCh0aGlzLkRCLXNoKSktMSkpPDxzaDtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAoeD4+KHRoaXMuREItc2gpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQtMV0gfD0geDw8c2g7XG4gICAgc2ggKz0gaztcbiAgICBpZihzaCA+PSB0aGlzLkRCKSBzaCAtPSB0aGlzLkRCO1xuICB9XG4gIGlmKGsgPT0gOCAmJiAoc1swXSYweDgwKSAhPSAwKSB7XG4gICAgdGhpcy5zID0gLTE7XG4gICAgaWYoc2ggPiAwKSB0aGlzLmRhdGFbdGhpcy50LTFdIHw9ICgoMTw8KHRoaXMuREItc2gpKS0xKTw8c2g7XG4gIH1cbiAgdGhpcy5jbGFtcCgpO1xuICBpZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gIHZhciBjID0gdGhpcy5zJnRoaXMuRE07XG4gIHdoaWxlKHRoaXMudCA+IDAgJiYgdGhpcy5kYXRhW3RoaXMudC0xXSA9PSBjKSAtLXRoaXMudDtcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIGlmKHRoaXMucyA8IDApIHJldHVybiBcIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgdmFyIGttID0gKDE8PGspLTEsIGQsIG0gPSBmYWxzZSwgciA9IFwiXCIsIGkgPSB0aGlzLnQ7XG4gIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSVrO1xuICBpZihpLS0gPiAwKSB7XG4gICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzLmRhdGFbaV0+PnApID4gMCkgeyBtID0gdHJ1ZTsgciA9IGludDJjaGFyKGQpOyB9XG4gICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICBpZihwIDwgaykge1xuICAgICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KGstcCk7XG4gICAgICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLWspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT1rKSkma207XG4gICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgfVxuICAgICAgaWYoZCA+IDApIG0gPSB0cnVlO1xuICAgICAgaWYobSkgciArPSBpbnQyY2hhcihkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0/cjpcIjBcIjtcbn1cblxuLy8gKHB1YmxpYykgLXRoaXNcbmZ1bmN0aW9uIGJuTmVnYXRlKCkgeyB2YXIgciA9IG5iaSgpOyBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyxyKTsgcmV0dXJuIHI7IH1cblxuLy8gKHB1YmxpYykgfHRoaXN8XG5mdW5jdGlvbiBibkFicygpIHsgcmV0dXJuICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzOyB9XG5cbi8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG5mdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gIHZhciByID0gdGhpcy5zLWEucztcbiAgaWYociAhPSAwKSByZXR1cm4gcjtcbiAgdmFyIGkgPSB0aGlzLnQ7XG4gIHIgPSBpLWEudDtcbiAgaWYociAhPSAwKSByZXR1cm4gKHRoaXMuczwwKT8tcjpyO1xuICB3aGlsZSgtLWkgPj0gMCkgaWYoKHI9dGhpcy5kYXRhW2ldLWEuZGF0YVtpXSkgIT0gMCkgcmV0dXJuIHI7XG4gIHJldHVybiAwO1xufVxuXG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICB2YXIgciA9IDEsIHQ7XG4gIGlmKCh0PXg+Pj4xNikgIT0gMCkgeyB4ID0gdDsgciArPSAxNjsgfVxuICBpZigodD14Pj44KSAhPSAwKSB7IHggPSB0OyByICs9IDg7IH1cbiAgaWYoKHQ9eD4+NCkgIT0gMCkgeyB4ID0gdDsgciArPSA0OyB9XG4gIGlmKCh0PXg+PjIpICE9IDApIHsgeCA9IHQ7IHIgKz0gMjsgfVxuICBpZigodD14Pj4xKSAhPSAwKSB7IHggPSB0OyByICs9IDE7IH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbmZ1bmN0aW9uIGJuQml0TGVuZ3RoKCkge1xuICBpZih0aGlzLnQgPD0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpcy5kYXRhW3RoaXMudC0xXV4odGhpcy5zJnRoaXMuRE0pKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4scikge1xuICB2YXIgaTtcbiAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpK25dID0gdGhpcy5kYXRhW2ldO1xuICBmb3IoaSA9IG4tMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpXSA9IDA7XG4gIHIudCA9IHRoaXMudCtuO1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbmZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpIHtcbiAgZm9yKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaS1uXSA9IHRoaXMuZGF0YVtpXTtcbiAgci50ID0gTWF0aC5tYXgodGhpcy50LW4sMCk7XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuZnVuY3Rpb24gYm5wTFNoaWZ0VG8obixyKSB7XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxjYnMpLTE7XG4gIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKSwgYyA9ICh0aGlzLnM8PGJzKSZ0aGlzLkRNLCBpO1xuICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkge1xuICAgIHIuZGF0YVtpK2RzKzFdID0gKHRoaXMuZGF0YVtpXT4+Y2JzKXxjO1xuICAgIGMgPSAodGhpcy5kYXRhW2ldJmJtKTw8YnM7XG4gIH1cbiAgZm9yKGkgPSBkcy0xOyBpID49IDA7IC0taSkgci5kYXRhW2ldID0gMDtcbiAgci5kYXRhW2RzXSA9IGM7XG4gIHIudCA9IHRoaXMudCtkcysxO1xuICByLnMgPSB0aGlzLnM7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKSB7XG4gIHIucyA9IHRoaXMucztcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICBpZihkcyA+PSB0aGlzLnQpIHsgci50ID0gMDsgcmV0dXJuOyB9XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxicyktMTtcbiAgci5kYXRhWzBdID0gdGhpcy5kYXRhW2RzXT4+YnM7XG4gIGZvcih2YXIgaSA9IGRzKzE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgIHIuZGF0YVtpLWRzLTFdIHw9ICh0aGlzLmRhdGFbaV0mYm0pPDxjYnM7XG4gICAgci5kYXRhW2ktZHNdID0gdGhpcy5kYXRhW2ldPj5icztcbiAgfVxuICBpZihicyA+IDApIHIuZGF0YVt0aGlzLnQtZHMtMV0gfD0gKHRoaXMucyZibSk8PGNicztcbiAgci50ID0gdGhpcy50LWRzO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5wU3ViVG8oYSxyKSB7XG4gIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgd2hpbGUoaSA8IG0pIHtcbiAgICBjICs9IHRoaXMuZGF0YVtpXS1hLmRhdGFbaV07XG4gICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICAgYyA+Pj0gdGhpcy5EQjtcbiAgfVxuICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICBjIC09IGEucztcbiAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyArPSB0aGlzLnM7XG4gIH0gZWxzZSB7XG4gICAgYyArPSB0aGlzLnM7XG4gICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgYyAtPSBhLmRhdGFbaV07XG4gICAgICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgfVxuICAgIGMgLT0gYS5zO1xuICB9XG4gIHIucyA9IChjPDApPy0xOjA7XG4gIGlmKGMgPCAtMSkgci5kYXRhW2krK10gPSB0aGlzLkRWK2M7XG4gIGVsc2UgaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbiAgci50ID0gaTtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVRvKGEscikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICB2YXIgaSA9IHgudDtcbiAgci50ID0gaSt5LnQ7XG4gIHdoaWxlKC0taSA+PSAwKSByLmRhdGFbaV0gPSAwO1xuICBmb3IoaSA9IDA7IGkgPCB5LnQ7ICsraSkgci5kYXRhW2kreC50XSA9IHguYW0oMCx5LmRhdGFbaV0scixpLDAseC50KTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xuICBpZih0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG5mdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgdmFyIGkgPSByLnQgPSAyKngudDtcbiAgd2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG4gIGZvcihpID0gMDsgaSA8IHgudC0xOyArK2kpIHtcbiAgICB2YXIgYyA9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgICBpZigoci5kYXRhW2kreC50XSs9eC5hbShpKzEsMip4LmRhdGFbaV0sciwyKmkrMSxjLHgudC1pLTEpKSA+PSB4LkRWKSB7XG4gICAgICByLmRhdGFbaSt4LnRdIC09IHguRFY7XG4gICAgICByLmRhdGFbaSt4LnQrMV0gPSAxO1xuICAgIH1cbiAgfVxuICBpZihyLnQgPiAwKSByLmRhdGFbci50LTFdICs9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpIHtcbiAgdmFyIHBtID0gbS5hYnMoKTtcbiAgaWYocG0udCA8PSAwKSByZXR1cm47XG4gIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgaWYocSAhPSBudWxsKSBxLmZyb21JbnQoMCk7XG4gICAgaWYociAhPSBudWxsKSB0aGlzLmNvcHlUbyhyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYociA9PSBudWxsKSByID0gbmJpKCk7XG4gIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgdmFyIG5zaCA9IHRoaXMuREItbmJpdHMocG0uZGF0YVtwbS50LTFdKTtcdC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gIGlmKG5zaCA+IDApIHsgcG0ubFNoaWZ0VG8obnNoLHkpOyBwdC5sU2hpZnRUbyhuc2gscik7IH0gZWxzZSB7IHBtLmNvcHlUbyh5KTsgcHQuY29weVRvKHIpOyB9XG4gIHZhciB5cyA9IHkudDtcbiAgdmFyIHkwID0geS5kYXRhW3lzLTFdO1xuICBpZih5MCA9PSAwKSByZXR1cm47XG4gIHZhciB5dCA9IHkwKigxPDx0aGlzLkYxKSsoKHlzPjEpP3kuZGF0YVt5cy0yXT4+dGhpcy5GMjowKTtcbiAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICB2YXIgaSA9IHIudCwgaiA9IGkteXMsIHQgPSAocT09bnVsbCk/bmJpKCk6cTtcbiAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHIuZGF0YVtyLnQrK10gPSAxO1xuICAgIHIuc3ViVG8odCxyKTtcbiAgfVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsdCk7XG4gIHQuc3ViVG8oeSx5KTtcdC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlKHkudCA8IHlzKSB5LmRhdGFbeS50KytdID0gMDtcbiAgd2hpbGUoLS1qID49IDApIHtcbiAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgIHZhciBxZCA9IChyLmRhdGFbLS1pXT09eTApP3RoaXMuRE06TWF0aC5mbG9vcihyLmRhdGFbaV0qZDErKHIuZGF0YVtpLTFdK2UpKmQyKTtcbiAgICBpZigoci5kYXRhW2ldKz15LmFtKDAscWQscixqLDAseXMpKSA8IHFkKSB7XHQvLyBUcnkgaXQgb3V0XG4gICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgci5zdWJUbyh0LHIpO1xuICAgICAgd2hpbGUoci5kYXRhW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgIH1cbiAgfVxuICBpZihxICE9IG51bGwpIHtcbiAgICByLmRyU2hpZnRUbyh5cyxxKTtcbiAgICBpZih0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSk7XG4gIH1cbiAgci50ID0geXM7XG4gIHIuY2xhbXAoKTtcbiAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7XHQvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5iaSgpO1xuICB0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtcbiAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG5mdW5jdGlvbiBDbGFzc2ljKG0pIHsgdGhpcy5tID0gbTsgfVxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gIGVsc2UgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkgeyB4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpOyB9XG5mdW5jdGlvbiBjTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5mdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbkNsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG5DbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmKHRoaXMudCA8IDEpIHJldHVybiAwO1xuICB2YXIgeCA9IHRoaXMuZGF0YVswXTtcbiAgaWYoKHgmMSkgPT0gMCkgcmV0dXJuIDA7XG4gIHZhciB5ID0geCYzO1x0XHQvLyB5ID09IDEveCBtb2QgMl4yXG4gIHkgPSAoeSooMi0oeCYweGYpKnkpKSYweGY7XHQvLyB5ID09IDEveCBtb2QgMl40XG4gIHkgPSAoeSooMi0oeCYweGZmKSp5KSkmMHhmZjtcdC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgeSA9ICh5KigyLSgoKHgmMHhmZmZmKSp5KSYweGZmZmYpKSkmMHhmZmZmO1x0Ly8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5KigyLXgqeSV0aGlzLkRWKSkldGhpcy5EVjtcdFx0Ly8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5PjApP3RoaXMuRFYteToteTtcbn1cblxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbmZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICB0aGlzLm0gPSBtO1xuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICB0aGlzLm1wbCA9IHRoaXMubXAmMHg3ZmZmO1xuICB0aGlzLm1waCA9IHRoaXMubXA+PjE1O1xuICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgdGhpcy5tdDIgPSAyKm0udDtcbn1cblxuLy8geFIgbW9kIG1cbmZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gIHIuZGl2UmVtVG8odGhpcy5tLG51bGwscik7XG4gIGlmKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5jb3B5VG8ocik7XG4gIHRoaXMucmVkdWNlKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gIHdoaWxlKHgudCA8PSB0aGlzLm10MilcdC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgIHguZGF0YVt4LnQrK10gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4LmRhdGFbaV0qbXAgbW9kIERWXG4gICAgdmFyIGogPSB4LmRhdGFbaV0mMHg3ZmZmO1xuICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHguZGF0YVtpXT4+MTUpKnRoaXMubXBsKSZ0aGlzLnVtKTw8MTUpKSZ4LkRNO1xuICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgIGogPSBpK3RoaXMubS50O1xuICAgIHguZGF0YVtqXSArPSB0aGlzLm0uYW0oMCx1MCx4LGksMCx0aGlzLm0udCk7XG4gICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgd2hpbGUoeC5kYXRhW2pdID49IHguRFYpIHsgeC5kYXRhW2pdIC09IHguRFY7IHguZGF0YVsrK2pdKys7IH1cbiAgfVxuICB4LmNsYW1wKCk7XG4gIHguZHJTaGlmdFRvKHRoaXMubS50LHgpO1xuICBpZih4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xufVxuXG4vLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbmZ1bmN0aW9uIG1vbnRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuZnVuY3Rpb24gbW9udE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnQ7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbk1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xuTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuZnVuY3Rpb24gYm5wSXNFdmVuKCkgeyByZXR1cm4gKCh0aGlzLnQ+MCk/KHRoaXMuZGF0YVswXSYxKTp0aGlzLnMpID09IDA7IH1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUseikge1xuICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICB2YXIgciA9IG5iaSgpLCByMiA9IG5iaSgpLCBnID0gei5jb252ZXJ0KHRoaXMpLCBpID0gbmJpdHMoZSktMTtcbiAgZy5jb3B5VG8ocik7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLHIyKTtcbiAgICBpZigoZSYoMTw8aSkpID4gMCkgei5tdWxUbyhyMixnLHIpO1xuICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLG0pIHtcbiAgdmFyIHo7XG4gIGlmKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pOyBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgcmV0dXJuIHRoaXMuZXhwKGUseik7XG59XG5cbi8vIHByb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcblxuLy8gcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBqc2JuMiBsaWJcblxuLy9Db3B5cmlnaHQgKGMpIDIwMDUtMjAwOSAgVG9tIFd1XG4vL0FsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1NlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscyAoU2VlIGpzYm4uanMgZm9yIExJQ0VOU0UpLlxuXG4vL0V4dGVuZGVkIEphdmFTY3JpcHQgQk4gZnVuY3Rpb25zLCByZXF1aXJlZCBmb3IgUlNBIHByaXZhdGUgb3BzLlxuXG4vL1ZlcnNpb24gMS4xOiBuZXcgQmlnSW50ZWdlcihcIjBcIiwgMTApIHJldHVybnMgXCJwcm9wZXJcIiB6ZXJvXG5cbi8vKHB1YmxpYylcbmZ1bmN0aW9uIGJuQ2xvbmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuY29weVRvKHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG5mdW5jdGlvbiBibkludFZhbHVlKCkge1xuaWYodGhpcy5zIDwgMCkge1xuIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdLXRoaXMuRFY7XG4gZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIC0xO1xufSBlbHNlIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdO1xuZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIDA7XG4vLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxucmV0dXJuICgodGhpcy5kYXRhWzFdJigoMTw8KDMyLXRoaXMuREIpKS0xKSk8PHRoaXMuREIpfHRoaXMuZGF0YVswXTtcbn1cblxuLy8ocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MjQpPj4yNDsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG5mdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MTYpPj4xNjsgfVxuXG4vLyhwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbmZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpOyB9XG5cbi8vKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbmZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuaWYodGhpcy5zIDwgMCkgcmV0dXJuIC0xO1xuZWxzZSBpZih0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpcy5kYXRhWzBdIDw9IDApKSByZXR1cm4gMDtcbmVsc2UgcmV0dXJuIDE7XG59XG5cbi8vKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuaWYoYiA9PSBudWxsKSBiID0gMTA7XG5pZih0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSByZXR1cm4gXCIwXCI7XG52YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbnZhciBhID0gTWF0aC5wb3coYixjcyk7XG52YXIgZCA9IG5idihhKSwgeSA9IG5iaSgpLCB6ID0gbmJpKCksIHIgPSBcIlwiO1xudGhpcy5kaXZSZW1UbyhkLHkseik7XG53aGlsZSh5LnNpZ251bSgpID4gMCkge1xuIHIgPSAoYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4geS5kaXZSZW1UbyhkLHkseik7XG59XG5yZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbn1cblxuLy8ocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBGcm9tUmFkaXgocyxiKSB7XG50aGlzLmZyb21JbnQoMCk7XG5pZihiID09IG51bGwpIGIgPSAxMDtcbnZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xudmFyIGQgPSBNYXRoLnBvdyhiLGNzKSwgbWkgPSBmYWxzZSwgaiA9IDAsIHcgPSAwO1xuZm9yKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiB2YXIgeCA9IGludEF0KHMsaSk7XG4gaWYoeCA8IDApIHtcbiAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHRoaXMuc2lnbnVtKCkgPT0gMCkgbWkgPSB0cnVlO1xuICAgY29udGludWU7XG4gfVxuIHcgPSBiKncreDtcbiBpZigrK2ogPj0gY3MpIHtcbiAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG4gICBqID0gMDtcbiAgIHcgPSAwO1xuIH1cbn1cbmlmKGogPiAwKSB7XG4gdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7XG4gdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG59XG5pZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsYixjKSB7XG5pZihcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gaWYoYSA8IDIpIHRoaXMuZnJvbUludCgxKTtcbiBlbHNlIHtcbiAgIHRoaXMuZnJvbU51bWJlcihhLGMpO1xuICAgaWYoIXRoaXMudGVzdEJpdChhLTEpKSAgLy8gZm9yY2UgTVNCIHNldFxuICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxvcF9vcix0aGlzKTtcbiAgIGlmKHRoaXMuaXNFdmVuKCkpIHRoaXMuZEFkZE9mZnNldCgxLDApOyAvLyBmb3JjZSBvZGRcbiAgIHdoaWxlKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICB0aGlzLmRBZGRPZmZzZXQoMiwwKTtcbiAgICAgaWYodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksdGhpcyk7XG4gICB9XG4gfVxufSBlbHNlIHtcbiAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuIHZhciB4ID0gbmV3IEFycmF5KCksIHQgPSBhJjc7XG4geC5sZW5ndGggPSAoYT4+MykrMTtcbiBiLm5leHRCeXRlcyh4KTtcbiBpZih0ID4gMCkgeFswXSAmPSAoKDE8PHQpLTEpOyBlbHNlIHhbMF0gPSAwO1xuIHRoaXMuZnJvbVN0cmluZyh4LDI1Nik7XG59XG59XG5cbi8vKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbnZhciBpID0gdGhpcy50LCByID0gbmV3IEFycmF5KCk7XG5yWzBdID0gdGhpcy5zO1xudmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJTgsIGQsIGsgPSAwO1xuaWYoaS0tID4gMCkge1xuIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldPj5wKSAhPSAodGhpcy5zJnRoaXMuRE0pPj5wKVxuICAgcltrKytdID0gZHwodGhpcy5zPDwodGhpcy5EQi1wKSk7XG4gd2hpbGUoaSA+PSAwKSB7XG4gICBpZihwIDwgOCkge1xuICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KDgtcCk7XG4gICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLTgpO1xuICAgfSBlbHNlIHtcbiAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT04KSkmMHhmZjtcbiAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICB9XG4gICBpZigoZCYweDgwKSAhPSAwKSBkIHw9IC0yNTY7XG4gICBpZihrID09IDAgJiYgKHRoaXMucyYweDgwKSAhPSAoZCYweDgwKSkgKytrO1xuICAgaWYoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHJbaysrXSA9IGQ7XG4gfVxufVxucmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJuRXF1YWxzKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPT0wKTsgfVxuZnVuY3Rpb24gYm5NaW4oYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk8MCk/dGhpczphOyB9XG5mdW5jdGlvbiBibk1heChhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT4wKT90aGlzOmE7IH1cblxuLy8ocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsb3Ascikge1xudmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbmZvcihpID0gMDsgaSA8IG07ICsraSkgci5kYXRhW2ldID0gb3AodGhpcy5kYXRhW2ldLGEuZGF0YVtpXSk7XG5pZihhLnQgPCB0aGlzLnQpIHtcbiBmID0gYS5zJnRoaXMuRE07XG4gZm9yKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHIuZGF0YVtpXSA9IG9wKHRoaXMuZGF0YVtpXSxmKTtcbiByLnQgPSB0aGlzLnQ7XG59IGVsc2Uge1xuIGYgPSB0aGlzLnMmdGhpcy5ETTtcbiBmb3IoaSA9IG07IGkgPCBhLnQ7ICsraSkgci5kYXRhW2ldID0gb3AoZixhLmRhdGFbaV0pO1xuIHIudCA9IGEudDtcbn1cbnIucyA9IG9wKHRoaXMucyxhLnMpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCx5KSB7IHJldHVybiB4Jnk7IH1cbmZ1bmN0aW9uIGJuQW5kKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmQscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyB8IGFcbmZ1bmN0aW9uIG9wX29yKHgseSkgeyByZXR1cm4geHx5OyB9XG5mdW5jdGlvbiBibk9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgseSkgeyByZXR1cm4geF55OyB9XG5mdW5jdGlvbiBiblhvcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfeG9yLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgseSkgeyByZXR1cm4geCZ+eTsgfVxuZnVuY3Rpb24gYm5BbmROb3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZG5vdCxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB+dGhpc1xuZnVuY3Rpb24gYm5Ob3QoKSB7XG52YXIgciA9IG5iaSgpO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaV0gPSB0aGlzLkRNJn50aGlzLmRhdGFbaV07XG5yLnQgPSB0aGlzLnQ7XG5yLnMgPSB+dGhpcy5zO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA8PCBuXG5mdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG52YXIgciA9IG5iaSgpO1xuaWYobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5sU2hpZnRUbyhuLHIpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA+PiBuXG5mdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xudmFyIHIgPSBuYmkoKTtcbmlmKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtcbnJldHVybiByO1xufVxuXG4vL3JldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuaWYoeCA9PSAwKSByZXR1cm4gLTE7XG52YXIgciA9IDA7XG5pZigoeCYweGZmZmYpID09IDApIHsgeCA+Pj0gMTY7IHIgKz0gMTY7IH1cbmlmKCh4JjB4ZmYpID09IDApIHsgeCA+Pj0gODsgciArPSA4OyB9XG5pZigoeCYweGYpID09IDApIHsgeCA+Pj0gNDsgciArPSA0OyB9XG5pZigoeCYzKSA9PSAwKSB7IHggPj49IDI7IHIgKz0gMjsgfVxuaWYoKHgmMSkgPT0gMCkgKytyO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG5mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbmZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiBpZih0aGlzLmRhdGFbaV0gIT0gMCkgcmV0dXJuIGkqdGhpcy5EQitsYml0KHRoaXMuZGF0YVtpXSk7XG5pZih0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50KnRoaXMuREI7XG5yZXR1cm4gLTE7XG59XG5cbi8vcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG52YXIgciA9IDA7XG53aGlsZSh4ICE9IDApIHsgeCAmPSB4LTE7ICsrcjsgfVxucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuZnVuY3Rpb24gYm5CaXRDb3VudCgpIHtcbnZhciByID0gMCwgeCA9IHRoaXMucyZ0aGlzLkRNO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpcy5kYXRhW2ldXngpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbmZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG52YXIgaiA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbmlmKGogPj0gdGhpcy50KSByZXR1cm4odGhpcy5zIT0wKTtcbnJldHVybigodGhpcy5kYXRhW2pdJigxPDwobiV0aGlzLkRCKSkpIT0wKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sb3ApIHtcbnZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xudGhpcy5iaXR3aXNlVG8ocixvcCxyKTtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgfCAoMTw8bilcbmZ1bmN0aW9uIGJuU2V0Qml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbmZ1bmN0aW9uIGJuQ2xlYXJCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuZnVuY3Rpb24gYm5GbGlwQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKTsgfVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuZnVuY3Rpb24gYm5wQWRkVG8oYSxyKSB7XG52YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG53aGlsZShpIDwgbSkge1xuIGMgKz0gdGhpcy5kYXRhW2ldK2EuZGF0YVtpXTtcbiByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiBjID4+PSB0aGlzLkRCO1xufVxuaWYoYS50IDwgdGhpcy50KSB7XG4gYyArPSBhLnM7XG4gd2hpbGUoaSA8IHRoaXMudCkge1xuICAgYyArPSB0aGlzLmRhdGFbaV07XG4gICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgIGMgPj49IHRoaXMuREI7XG4gfVxuIGMgKz0gdGhpcy5zO1xufSBlbHNlIHtcbiBjICs9IHRoaXMucztcbiB3aGlsZShpIDwgYS50KSB7XG4gICBjICs9IGEuZGF0YVtpXTtcbiAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgYyA+Pj0gdGhpcy5EQjtcbiB9XG4gYyArPSBhLnM7XG59XG5yLnMgPSAoYzwwKT8tMTowO1xuaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbmVsc2UgaWYoYyA8IC0xKSByLmRhdGFbaSsrXSA9IHRoaXMuRFYrYztcbnIudCA9IGk7XG5yLmNsYW1wKCk7XG59XG5cbi8vKHB1YmxpYykgdGhpcyArIGFcbmZ1bmN0aW9uIGJuQWRkKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5hZGRUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgLSBhXG5mdW5jdGlvbiBiblN1YnRyYWN0KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5zdWJUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgKiBhXG5mdW5jdGlvbiBibk11bHRpcGx5KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5tdWx0aXBseVRvKGEscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAvIGFcbmZ1bmN0aW9uIGJuRGl2aWRlKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAlIGFcbmZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLG51bGwscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG5mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG52YXIgcSA9IG5iaSgpLCByID0gbmJpKCk7XG50aGlzLmRpdlJlbVRvKGEscSxyKTtcbnJldHVybiBuZXcgQXJyYXkocSxyKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pIHtcbnRoaXMuZGF0YVt0aGlzLnRdID0gdGhpcy5hbSgwLG4tMSx0aGlzLDAsMCx0aGlzLnQpO1xuKyt0aGlzLnQ7XG50aGlzLmNsYW1wKCk7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpIHtcbmlmKG4gPT0gMCkgcmV0dXJuO1xud2hpbGUodGhpcy50IDw9IHcpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xudGhpcy5kYXRhW3ddICs9IG47XG53aGlsZSh0aGlzLmRhdGFbd10gPj0gdGhpcy5EVikge1xuIHRoaXMuZGF0YVt3XSAtPSB0aGlzLkRWO1xuIGlmKCsrdyA+PSB0aGlzLnQpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xuICsrdGhpcy5kYXRhW3ddO1xufVxufVxuXG4vL0EgXCJudWxsXCIgcmVkdWNlclxuZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG5mdW5jdGlvbiBuTm9wKHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIG5NdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgfVxuZnVuY3Rpb24gblNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB9XG5cbk51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbk51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvO1xuTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lXG5mdW5jdGlvbiBiblBvdyhlKSB7IHJldHVybiB0aGlzLmV4cChlLG5ldyBOdWxsRXhwKCkpOyB9XG5cbi8vKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSxuLHIpIHtcbnZhciBpID0gTWF0aC5taW4odGhpcy50K2EudCxuKTtcbnIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbnIudCA9IGk7XG53aGlsZShpID4gMCkgci5kYXRhWy0taV0gPSAwO1xudmFyIGo7XG5mb3IoaiA9IHIudC10aGlzLnQ7IGkgPCBqOyArK2kpIHIuZGF0YVtpK3RoaXMudF0gPSB0aGlzLmFtKDAsYS5kYXRhW2ldLHIsaSwwLHRoaXMudCk7XG5mb3IoaiA9IE1hdGgubWluKGEudCxuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLGEuZGF0YVtpXSxyLGksMCxuLWkpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSxuLHIpIHtcbi0tbjtcbnZhciBpID0gci50ID0gdGhpcy50K2EudC1uO1xuci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxud2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG5mb3IoaSA9IE1hdGgubWF4KG4tdGhpcy50LDApOyBpIDwgYS50OyArK2kpXG4gci5kYXRhW3RoaXMudCtpLW5dID0gdGhpcy5hbShuLWksYS5kYXRhW2ldLHIsMCwwLHRoaXMudCtpLW4pO1xuci5jbGFtcCgpO1xuci5kclNoaWZ0VG8oMSxyKTtcbn1cblxuLy9CYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG5mdW5jdGlvbiBCYXJyZXR0KG0pIHtcbi8vIHNldHVwIEJhcnJldHRcbnRoaXMucjIgPSBuYmkoKTtcbnRoaXMucTMgPSBuYmkoKTtcbkJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTtcbnRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbnRoaXMubSA9IG07XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbmlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG5lbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbmVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuXG4vL3ggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbnguZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7XG5pZih4LnQgPiB0aGlzLm0udCsxKSB7IHgudCA9IHRoaXMubS50KzE7IHguY2xhbXAoKTsgfVxudGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpO1xudGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7XG53aGlsZSh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO1xueC5zdWJUbyh0aGlzLnIyLHgpO1xud2hpbGUoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbn1cblxuLy9yID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy9yID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuZnVuY3Rpb24gYm5Nb2RQb3coZSxtKSB7XG52YXIgaSA9IGUuYml0TGVuZ3RoKCksIGssIHIgPSBuYnYoMSksIHo7XG5pZihpIDw9IDApIHJldHVybiByO1xuZWxzZSBpZihpIDwgMTgpIGsgPSAxO1xuZWxzZSBpZihpIDwgNDgpIGsgPSAzO1xuZWxzZSBpZihpIDwgMTQ0KSBrID0gNDtcbmVsc2UgaWYoaSA8IDc2OCkgayA9IDU7XG5lbHNlIGsgPSA2O1xuaWYoaSA8IDgpXG4geiA9IG5ldyBDbGFzc2ljKG0pO1xuZWxzZSBpZihtLmlzRXZlbigpKVxuIHogPSBuZXcgQmFycmV0dChtKTtcbmVsc2VcbiB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG5cbi8vIHByZWNvbXB1dGF0aW9uXG52YXIgZyA9IG5ldyBBcnJheSgpLCBuID0gMywgazEgPSBrLTEsIGttID0gKDE8PGspLTE7XG5nWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuaWYoayA+IDEpIHtcbiB2YXIgZzIgPSBuYmkoKTtcbiB6LnNxclRvKGdbMV0sZzIpO1xuIHdoaWxlKG4gPD0ga20pIHtcbiAgIGdbbl0gPSBuYmkoKTtcbiAgIHoubXVsVG8oZzIsZ1tuLTJdLGdbbl0pO1xuICAgbiArPSAyO1xuIH1cbn1cblxudmFyIGogPSBlLnQtMSwgdywgaXMxID0gdHJ1ZSwgcjIgPSBuYmkoKSwgdDtcbmkgPSBuYml0cyhlLmRhdGFbal0pLTE7XG53aGlsZShqID49IDApIHtcbiBpZihpID49IGsxKSB3ID0gKGUuZGF0YVtqXT4+KGktazEpKSZrbTtcbiBlbHNlIHtcbiAgIHcgPSAoZS5kYXRhW2pdJigoMTw8KGkrMSkpLTEpKTw8KGsxLWkpO1xuICAgaWYoaiA+IDApIHcgfD0gZS5kYXRhW2otMV0+Pih0aGlzLkRCK2ktazEpO1xuIH1cblxuIG4gPSBrO1xuIHdoaWxlKCh3JjEpID09IDApIHsgdyA+Pj0gMTsgLS1uOyB9XG4gaWYoKGkgLT0gbikgPCAwKSB7IGkgKz0gdGhpcy5EQjsgLS1qOyB9XG4gaWYoaXMxKSB7ICAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICBnW3ddLmNvcHlUbyhyKTtcbiAgIGlzMSA9IGZhbHNlO1xuIH0gZWxzZSB7XG4gICB3aGlsZShuID4gMSkgeyB6LnNxclRvKHIscjIpOyB6LnNxclRvKHIyLHIpOyBuIC09IDI7IH1cbiAgIGlmKG4gPiAwKSB6LnNxclRvKHIscjIpOyBlbHNlIHsgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICB6Lm11bFRvKHIyLGdbd10scik7XG4gfVxuXG4gd2hpbGUoaiA+PSAwICYmIChlLmRhdGFbal0mKDE8PGkpKSA9PSAwKSB7XG4gICB6LnNxclRvKHIscjIpOyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7XG4gICBpZigtLWkgPCAwKSB7IGkgPSB0aGlzLkRCLTE7IC0tajsgfVxuIH1cbn1cbnJldHVybiB6LnJldmVydChyKTtcbn1cblxuLy8ocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuZnVuY3Rpb24gYm5HQ0QoYSkge1xudmFyIHggPSAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpcy5jbG9uZSgpO1xudmFyIHkgPSAoYS5zPDApP2EubmVnYXRlKCk6YS5jbG9uZSgpO1xuaWYoeC5jb21wYXJlVG8oeSkgPCAwKSB7IHZhciB0ID0geDsgeCA9IHk7IHkgPSB0OyB9XG52YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCksIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuaWYoZyA8IDApIHJldHVybiB4O1xuaWYoaSA8IGcpIGcgPSBpO1xuaWYoZyA+IDApIHtcbiB4LnJTaGlmdFRvKGcseCk7XG4geS5yU2hpZnRUbyhnLHkpO1xufVxud2hpbGUoeC5zaWdudW0oKSA+IDApIHtcbiBpZigoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLHgpO1xuIGlmKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGkseSk7XG4gaWYoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgeC5zdWJUbyh5LHgpO1xuICAgeC5yU2hpZnRUbygxLHgpO1xuIH0gZWxzZSB7XG4gICB5LnN1YlRvKHgseSk7XG4gICB5LnJTaGlmdFRvKDEseSk7XG4gfVxufVxuaWYoZyA+IDApIHkubFNoaWZ0VG8oZyx5KTtcbnJldHVybiB5O1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbmlmKG4gPD0gMCkgcmV0dXJuIDA7XG52YXIgZCA9IHRoaXMuRFYlbiwgciA9ICh0aGlzLnM8MCk/bi0xOjA7XG5pZih0aGlzLnQgPiAwKVxuIGlmKGQgPT0gMCkgciA9IHRoaXMuZGF0YVswXSVuO1xuIGVsc2UgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByID0gKGQqcit0aGlzLmRhdGFbaV0pJW47XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG5mdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xudmFyIGFjID0gbS5pc0V2ZW4oKTtcbmlmKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG52YXIgdSA9IG0uY2xvbmUoKSwgdiA9IHRoaXMuY2xvbmUoKTtcbnZhciBhID0gbmJ2KDEpLCBiID0gbmJ2KDApLCBjID0gbmJ2KDApLCBkID0gbmJ2KDEpO1xud2hpbGUodS5zaWdudW0oKSAhPSAwKSB7XG4gd2hpbGUodS5pc0V2ZW4oKSkge1xuICAgdS5yU2hpZnRUbygxLHUpO1xuICAgaWYoYWMpIHtcbiAgICAgaWYoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHsgYS5hZGRUbyh0aGlzLGEpOyBiLnN1YlRvKG0sYik7IH1cbiAgICAgYS5yU2hpZnRUbygxLGEpO1xuICAgfSBlbHNlIGlmKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sYik7XG4gICBiLnJTaGlmdFRvKDEsYik7XG4gfVxuIHdoaWxlKHYuaXNFdmVuKCkpIHtcbiAgIHYuclNoaWZ0VG8oMSx2KTtcbiAgIGlmKGFjKSB7XG4gICAgIGlmKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7IGMuYWRkVG8odGhpcyxjKTsgZC5zdWJUbyhtLGQpOyB9XG4gICAgIGMuclNoaWZ0VG8oMSxjKTtcbiAgIH0gZWxzZSBpZighZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLGQpO1xuICAgZC5yU2hpZnRUbygxLGQpO1xuIH1cbiBpZih1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICB1LnN1YlRvKHYsdSk7XG4gICBpZihhYykgYS5zdWJUbyhjLGEpO1xuICAgYi5zdWJUbyhkLGIpO1xuIH0gZWxzZSB7XG4gICB2LnN1YlRvKHUsdik7XG4gICBpZihhYykgYy5zdWJUbyhhLGMpO1xuICAgZC5zdWJUbyhiLGQpO1xuIH1cbn1cbmlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuaWYoZC5jb21wYXJlVG8obSkgPj0gMCkgcmV0dXJuIGQuc3VidHJhY3QobSk7XG5pZihkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLGQpOyBlbHNlIHJldHVybiBkO1xuaWYoZC5zaWdudW0oKSA8IDApIHJldHVybiBkLmFkZChtKTsgZWxzZSByZXR1cm4gZDtcbn1cblxudmFyIGxvd3ByaW1lcyA9IFsyLDMsNSw3LDExLDEzLDE3LDE5LDIzLDI5LDMxLDM3LDQxLDQzLDQ3LDUzLDU5LDYxLDY3LDcxLDczLDc5LDgzLDg5LDk3LDEwMSwxMDMsMTA3LDEwOSwxMTMsMTI3LDEzMSwxMzcsMTM5LDE0OSwxNTEsMTU3LDE2MywxNjcsMTczLDE3OSwxODEsMTkxLDE5MywxOTcsMTk5LDIxMSwyMjMsMjI3LDIyOSwyMzMsMjM5LDI0MSwyNTEsMjU3LDI2MywyNjksMjcxLDI3NywyODEsMjgzLDI5MywzMDcsMzExLDMxMywzMTcsMzMxLDMzNywzNDcsMzQ5LDM1MywzNTksMzY3LDM3MywzNzksMzgzLDM4OSwzOTcsNDAxLDQwOSw0MTksNDIxLDQzMSw0MzMsNDM5LDQ0Myw0NDksNDU3LDQ2MSw0NjMsNDY3LDQ3OSw0ODcsNDkxLDQ5OSw1MDMsNTA5XTtcbnZhciBscGxpbSA9ICgxPDwyNikvbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV07XG5cbi8vKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG5mdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG52YXIgaSwgeCA9IHRoaXMuYWJzKCk7XG5pZih4LnQgPT0gMSAmJiB4LmRhdGFbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV0pIHtcbiBmb3IoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICBpZih4LmRhdGFbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZTtcbiByZXR1cm4gZmFsc2U7XG59XG5pZih4LmlzRXZlbigpKSByZXR1cm4gZmFsc2U7XG5pID0gMTtcbndoaWxlKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gdmFyIG0gPSBsb3dwcmltZXNbaV0sIGogPSBpKzE7XG4gd2hpbGUoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdO1xuIG0gPSB4Lm1vZEludChtKTtcbiB3aGlsZShpIDwgaikgaWYobSVsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2U7XG59XG5yZXR1cm4geC5taWxsZXJSYWJpbih0KTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xudmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG52YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuaWYoayA8PSAwKSByZXR1cm4gZmFsc2U7XG52YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG52YXIgcHJuZyA9IGJuR2V0UHJuZygpO1xudmFyIGE7XG5mb3IodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gLy8gc2VsZWN0IHdpdG5lc3MgJ2EnIGF0IHJhbmRvbSBmcm9tIGJldHdlZW4gMSBhbmQgbjFcbiBkbyB7XG4gICBhID0gbmV3IEJpZ0ludGVnZXIodGhpcy5iaXRMZW5ndGgoKSwgcHJuZyk7XG4gfVxuIHdoaWxlKGEuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA8PSAwIHx8IGEuY29tcGFyZVRvKG4xKSA+PSAwKTtcbiB2YXIgeSA9IGEubW9kUG93KHIsdGhpcyk7XG4gaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgIHZhciBqID0gMTtcbiAgIHdoaWxlKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgeSA9IHkubW9kUG93SW50KDIsdGhpcyk7XG4gICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBpZih5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlO1xuIH1cbn1cbnJldHVybiB0cnVlO1xufVxuXG4vLyBnZXQgcHNldWRvIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5mdW5jdGlvbiBibkdldFBybmcoKSB7XG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgcmV0dXJuIHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vL3Byb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gYm5wQWRkVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XG5cbi8vcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBiblNpZ051bTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gYm5TZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gYm5BZGQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBibkRpdmlkZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG5cbi8vQmlnSW50ZWdlciBpbnRlcmZhY2VzIG5vdCBpbXBsZW1lbnRlZCBpbiBqc2JuOlxuXG4vL0JpZ0ludGVnZXIoaW50IHNpZ251bSwgYnl0ZVtdIG1hZ25pdHVkZSlcbi8vZG91YmxlIGRvdWJsZVZhbHVlKClcbi8vZmxvYXQgZmxvYXRWYWx1ZSgpXG4vL2ludCBoYXNoQ29kZSgpXG4vL2xvbmcgbG9uZ1ZhbHVlKClcbi8vc3RhdGljIEJpZ0ludGVnZXIgdmFsdWVPZihsb25nIHZhbClcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMTYwLWJpdCBkaWdlc3QgKFNIQS0xKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHNoYTEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnNoYTEgPSBmb3JnZS5zaGExIHx8IHt9O1xuZm9yZ2UubWQuc2hhMSA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMSA9IHNoYTE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNIQS0xIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICovXG5zaGExLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMSBzdGF0ZSBjb250YWlucyBmaXZlIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg4MCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGExJyxcbiAgICBibG9ja0xlbmd0aDogNjQsXG4gICAgZGlnZXN0TGVuZ3RoOiAyMCxcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDY0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGg2NCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9zdGF0ZSA9IHtcbiAgICAgIGgwOiAweDY3NDUyMzAxLFxuICAgICAgaDE6IDB4RUZDREFCODksXG4gICAgICBoMjogMHg5OEJBRENGRSxcbiAgICAgIGgzOiAweDEwMzI1NDc2LFxuICAgICAgaDQ6IDB4QzNEMkUxRjBcbiAgICB9O1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgLy8gc3RhcnQgZGlnZXN0IGF1dG9tYXRpY2FsbHkgZm9yIGZpcnN0IHRpbWVcbiAgbWQuc3RhcnQoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGlnZXN0IHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgaW5wdXQuIFRoZSBnaXZlbiBpbnB1dCBjYW5cbiAgICogdHJlYXRlZCBhcyByYXcgaW5wdXQgKG5vIGVuY29kaW5nIHdpbGwgYmUgYXBwbGllZCkgb3IgYW4gZW5jb2Rpbmcgb2ZcbiAgICogJ3V0ZjgnIG1heWJlIGdpdmVuIHRvIGVuY29kZSB0aGUgaW5wdXQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgdGhlIG1lc3NhZ2UgaW5wdXQgdG8gdXBkYXRlIHdpdGguXG4gICAqIEBwYXJhbSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQudXBkYXRlID0gZnVuY3Rpb24obXNnLCBlbmNvZGluZykge1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIG1zZyA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtZXNzYWdlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgIG1kLm1lc3NhZ2VMZW5ndGggKz0gbGVuO1xuICAgIGxlbiA9IFsobGVuIC8gMHgxMDAwMDAwMDApID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICBsZW5bMV0gPSBsZW5bMF0gKyAoKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPj4+IDA7XG4gICAgICBsZW5bMF0gPSAoKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX3N0YXRlLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgIC8qKlxuICAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICAqXG4gICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgICovXG4gICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTEgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDggYnl0ZXMgKDY0XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSA1NiBieXRlc1xuICAgICg0NDggYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiBiZWNhdXNlXG4gICAgNTEyIC0gMTI4ID0gNDQ4LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiwgdGhlbiA1MTIgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeSBmcm9tIG5leHQgaW50XG4gICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgY2FycnkgPSAobmV4dCAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgYml0cyA9IG5leHQgPj4+IDA7XG4gICAgfVxuICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG5cbiAgICB2YXIgczIgPSB7XG4gICAgICBoMDogX3N0YXRlLmgwLFxuICAgICAgaDE6IF9zdGF0ZS5oMSxcbiAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICBoMzogX3N0YXRlLmgzLFxuICAgICAgaDQ6IF9zdGF0ZS5oNFxuICAgIH07XG4gICAgX3VwZGF0ZShzMiwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgxKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgyKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg0KTtcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtMSBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgNjQpO1xuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBTSEEtMSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gcyB0aGUgU0hBLTEgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQsIGEsIGIsIGMsIGQsIGUsIGYsIGk7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDY0KSB7XG4gICAgLy8gdGhlIHcgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBzaXh0ZWVuIDMyLWJpdCBiaWctZW5kaWFuIHdvcmRzXG4gICAgLy8gYW5kIHRoZW4gZXh0ZW5kZWQgaW50byA4MCAzMi1iaXQgd29yZHMgYWNjb3JkaW5nIHRvIFNIQS0xIGFsZ29yaXRobVxuICAgIC8vIGFuZCBmb3IgMzItNzkgdXNpbmcgTWF4IExvY2t0eXVraGluJ3Mgb3B0aW1pemF0aW9uXG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhID0gcy5oMDtcbiAgICBiID0gcy5oMTtcbiAgICBjID0gcy5oMjtcbiAgICBkID0gcy5oMztcbiAgICBlID0gcy5oNDtcblxuICAgIC8vIHJvdW5kIDFcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB0ID0gYnl0ZXMuZ2V0SW50MzIoKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIGZvcig7IGkgPCAyMDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDNdIF4gd1tpIC0gOF0gXiB3W2kgLSAxNF0gXiB3W2kgLSAxNl0pO1xuICAgICAgdCA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDJcbiAgICBmb3IoOyBpIDwgMzI7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSAzXSBeIHdbaSAtIDhdIF4gd1tpIC0gMTRdIF4gd1tpIC0gMTZdKTtcbiAgICAgIHQgPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NkVEOUVCQTEgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDQwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg2RUQ5RUJBMSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCAzXG4gICAgZm9yKDsgaSA8IDYwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIF4gYykpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDhGMUJCQ0RDICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDRcbiAgICBmb3IoOyBpIDwgODA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweENBNjJDMUQ2ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuXG4gICAgbGVuIC09IDY0O1xuICB9XG59XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgWC41MDkgYW5kIHJlbGF0ZWQgY29tcG9uZW50cyAoc3VjaCBhc1xuICogQ2VydGlmaWNhdGlvbiBTaWduaW5nIFJlcXVlc3RzKSBvZiBhIFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIGNlcnRpZmljYXRlIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDIDI0NTkpOlxuICpcbiAqIENlcnRpZmljYXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHRic0NlcnRpZmljYXRlICAgICAgIFRCU0NlcnRpZmljYXRlLFxuICogICBzaWduYXR1cmVBbGdvcml0aG0gICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBzaWduYXR1cmVWYWx1ZSAgICAgICBCSVQgU1RSSU5HXG4gKiB9XG4gKlxuICogVEJTQ2VydGlmaWNhdGUgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgIFswXSAgRVhQTElDSVQgVmVyc2lvbiBERUZBVUxUIHYxLFxuICogICBzZXJpYWxOdW1iZXIgICAgICAgICBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlcixcbiAqICAgc2lnbmF0dXJlICAgICAgICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgaXNzdWVyICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgdmFsaWRpdHkgICAgICAgICAgICAgVmFsaWRpdHksXG4gKiAgIHN1YmplY3QgICAgICAgICAgICAgIE5hbWUsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXlJbmZvIFN1YmplY3RQdWJsaWNLZXlJbmZvLFxuICogICBpc3N1ZXJVbmlxdWVJRCAgWzFdICBJTVBMSUNJVCBVbmlxdWVJZGVudGlmaWVyIE9QVElPTkFMLFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYyIG9yIHYzXG4gKiAgIHN1YmplY3RVbmlxdWVJRCBbMl0gIElNUExJQ0lUIFVuaXF1ZUlkZW50aWZpZXIgT1BUSU9OQUwsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIC0tIElmIHByZXNlbnQsIHZlcnNpb24gc2hhbGwgYmUgdjIgb3IgdjNcbiAqICAgZXh0ZW5zaW9ucyAgICAgIFszXSAgRVhQTElDSVQgRXh0ZW5zaW9ucyBPUFRJT05BTFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYzXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUiAgeyB2MSgwKSwgdjIoMSksIHYzKDIpIH1cbiAqXG4gKiBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlciA6Oj0gSU5URUdFUlxuICpcbiAqIE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIC8vIG9ubHkgb25lIHBvc3NpYmxlIGNob2ljZSBmb3Igbm93XG4gKiAgIFJETlNlcXVlbmNlXG4gKiB9XG4gKlxuICogUkROU2VxdWVuY2UgOjo9IFNFUVVFTkNFIE9GIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqXG4gKiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIDo6PSBTRVQgT0YgQXR0cmlidXRlVHlwZUFuZFZhbHVlXG4gKlxuICogQXR0cmlidXRlVHlwZUFuZFZhbHVlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICAgIEF0dHJpYnV0ZVR5cGUsXG4gKiAgIHZhbHVlICAgIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKiBBdHRyaWJ1dGVUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWSBERUZJTkVEIEJZIEF0dHJpYnV0ZVR5cGVcbiAqXG4gKiBWYWxpZGl0eSA6Oj0gU0VRVUVOQ0Uge1xuICogICBub3RCZWZvcmUgICAgICBUaW1lLFxuICogICBub3RBZnRlciAgICAgICBUaW1lXG4gKiB9XG4gKlxuICogVGltZSA6Oj0gQ0hPSUNFIHtcbiAqICAgdXRjVGltZSAgICAgICAgVVRDVGltZSxcbiAqICAgZ2VuZXJhbFRpbWUgICAgR2VuZXJhbGl6ZWRUaW1lXG4gKiB9XG4gKlxuICogVW5pcXVlSWRlbnRpZmllciA6Oj0gQklUIFNUUklOR1xuICpcbiAqIFN1YmplY3RQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSAgICAgICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgICAgIEJJVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBFeHRlbnNpb25zIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEV4dGVuc2lvblxuICpcbiAqIEV4dGVuc2lvbiA6Oj0gU0VRVUVOQ0Uge1xuICogICBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFLFxuICogICBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBUaGUgb25seSBrZXkgYWxnb3JpdGhtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIFBLSSBpcyBSU0EuXG4gKlxuICogUlNBU1NBLVBTUyBzaWduYXR1cmVzIGFyZSBkZXNjcmliZWQgaW4gUkZDIDM0NDcgYW5kIFJGQyA0MDU1LlxuICpcbiAqIFBLQ1MjMTAgdjEuNyBkZXNjcmliZXMgY2VydGlmaWNhdGUgc2lnbmluZyByZXF1ZXN0czpcbiAqXG4gKiBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm86XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgSU5URUdFUiB7IHYxKDApIH0gKHYxLC4uLiksXG4gKiAgIHN1YmplY3QgICAgICAgTmFtZSxcbiAqICAgc3ViamVjdFBLSW5mbyBTdWJqZWN0UHVibGljS2V5SW5mb3t7IFBLSW5mb0FsZ29yaXRobXMgfX0sXG4gKiAgIGF0dHJpYnV0ZXMgICAgWzBdIEF0dHJpYnV0ZXN7eyBDUklBdHRyaWJ1dGVzIH19XG4gKiB9XG4gKlxuICogQXR0cmlidXRlcyB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVQgT0YgQXR0cmlidXRle3sgSU9TZXQgfX1cbiAqXG4gKiBDUklBdHRyaWJ1dGVzICBBVFRSSUJVVEUgIDo6PSB7XG4gKiAgIC4uLiAtLSBhZGQgYW55IGxvY2FsbHkgZGVmaW5lZCBhdHRyaWJ1dGVzIGhlcmUgLS0gfVxuICpcbiAqIEF0dHJpYnV0ZSB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICBBVFRSSUJVVEUuJmlkKHtJT1NldH0pLFxuICogICB2YWx1ZXMgU0VUIFNJWkUoMS4uTUFYKSBPRiBBVFRSSUJVVEUuJlR5cGUoe0lPU2V0fXtAdHlwZX0pXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3QgOjo9IFNFUVVFTkNFIHtcbiAqICAgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyxcbiAqICAgc2lnbmF0dXJlQWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXJ7eyBTaWduYXR1cmVBbGdvcml0aG1zIH19LFxuICogICBzaWduYXR1cmUgICAgICAgICAgQklUIFNUUklOR1xuICogfVxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKiBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIChQS0kpIGltcGxlbWVudGF0aW9uLiAqL1xudmFyIHBraSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xudmFyIG9pZHMgPSBwa2kub2lkcztcblxuLy8gc2hvcnQgbmFtZSBPSUQgbWFwcGluZ3NcbnZhciBfc2hvcnROYW1lcyA9IHt9O1xuX3Nob3J0TmFtZXNbJ0NOJ10gPSBvaWRzWydjb21tb25OYW1lJ107XG5fc2hvcnROYW1lc1snY29tbW9uTmFtZSddID0gJ0NOJztcbl9zaG9ydE5hbWVzWydDJ10gPSBvaWRzWydjb3VudHJ5TmFtZSddO1xuX3Nob3J0TmFtZXNbJ2NvdW50cnlOYW1lJ10gPSAnQyc7XG5fc2hvcnROYW1lc1snTCddID0gb2lkc1snbG9jYWxpdHlOYW1lJ107XG5fc2hvcnROYW1lc1snbG9jYWxpdHlOYW1lJ10gPSAnTCc7XG5fc2hvcnROYW1lc1snU1QnXSA9IG9pZHNbJ3N0YXRlT3JQcm92aW5jZU5hbWUnXTtcbl9zaG9ydE5hbWVzWydzdGF0ZU9yUHJvdmluY2VOYW1lJ10gPSAnU1QnO1xuX3Nob3J0TmFtZXNbJ08nXSA9IG9pZHNbJ29yZ2FuaXphdGlvbk5hbWUnXTtcbl9zaG9ydE5hbWVzWydvcmdhbml6YXRpb25OYW1lJ10gPSAnTyc7XG5fc2hvcnROYW1lc1snT1UnXSA9IG9pZHNbJ29yZ2FuaXphdGlvbmFsVW5pdE5hbWUnXTtcbl9zaG9ydE5hbWVzWydvcmdhbml6YXRpb25hbFVuaXROYW1lJ10gPSAnT1UnO1xuX3Nob3J0TmFtZXNbJ0UnXSA9IG9pZHNbJ2VtYWlsQWRkcmVzcyddO1xuX3Nob3J0TmFtZXNbJ2VtYWlsQWRkcmVzcyddID0gJ0UnO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFN1YmplY3RQdWJsaWNLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCBhbiBSU0EgcHVibGljIGtleVxudmFyIHB1YmxpY0tleVZhbGlkYXRvciA9IGZvcmdlLnBraS5yc2EucHVibGljS2V5VmFsaWRhdG9yO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFguNTA5djMgY2VydGlmaWNhdGVcbnZhciB4NTA5Q2VydGlmaWNhdGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0ZScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAndGJzQ2VydGlmaWNhdGUnLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZlcnNpb24nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDAsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uLmludGVnZXInLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmVyc2lvbidcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNlcmlhbE51bWJlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjZXJ0U2VyaWFsTnVtYmVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRpbmZvU2lnbmF0dXJlT2lkJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlQXNuMTogJ2NlcnRpbmZvU2lnbmF0dXJlUGFyYW1zJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0SXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIC8vIE5vdGU6IFVUQyBhbmQgZ2VuZXJhbGl6ZWQgdGltZXMgbWF5IGJvdGggYXBwZWFyIHNvIHRoZSBjYXB0dXJlXG4gICAgICAvLyBuYW1lcyBhcmUgYmFzZWQgb24gdGhlaXIgZGV0ZWN0ZWQgb3JkZXIsIHRoZSBuYW1lcyB1c2VkIGJlbG93XG4gICAgICAvLyBhcmUgb25seSBmb3IgdGhlIGNvbW1vbiBjYXNlLCB3aGljaCB2YWxpZGl0eSB0aW1lIHJlYWxseSBtZWFuc1xuICAgICAgLy8gXCJub3RCZWZvcmVcIiBhbmQgd2hpY2ggbWVhbnMgXCJub3RBZnRlclwiIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBvcmRlclxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKFVUQyB0aW1lIGNhc2UpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKHV0YyknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5MVVUQ1RpbWUnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKGdlbmVyYWxpemVkIHRpbWUgY2FzZSlcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZSAoZ2VuZXJhbGl6ZWQpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZSdcbiAgICAgIH0sIHtcbiAgICAgICAgLy8gbm90QWZ0ZXIgKFRpbWUpIChvbmx5IFVUQyB0aW1lIGlzIHN1cHBvcnRlZClcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEFmdGVyICh1dGMpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTNVVENUaW1lJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBub3RBZnRlciAoVGltZSkgKG9ubHkgVVRDIHRpbWUgaXMgc3VwcG9ydGVkKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKGdlbmVyYWxpemVkKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWUnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zdWJqZWN0JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U3ViamVjdCdcbiAgICB9LFxuICAgICAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgICAgIHB1YmxpY0tleVZhbGlkYXRvcixcbiAgICB7XG4gICAgICAvLyBpc3N1ZXJVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSUQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDEsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJVbmlxdWVJRC5pZCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0SXNzdWVyVW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIHN1YmplY3RVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlEJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAyLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlELmlkJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTdWJqZWN0VW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIEV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmV4dGVuc2lvbnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDMsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydEV4dGVuc2lvbnMnLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllciAoc2lnbmF0dXJlIGFsZ29yaXRobSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2NlcnRTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U2lnbmF0dXJlUGFyYW1zJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5zaWduYXR1cmVWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTaWduYXR1cmUnXG4gIH1dXG59O1xuXG52YXIgcnNhc3NhUHNzUGFyYW1ldGVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAncnNhcHNzJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnaGFzaE9pZCdcbiAgICAgICAgLyogcGFyYW1ldGVyIGJsb2NrIG9taXR0ZWQsIGZvciBTSEExIE5VTEwgYW55aG93LiAqL1xuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ21hc2tHZW5PaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtcycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1zLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYXNrR2VuSGFzaE9pZCdcbiAgICAgICAgICAvKiBwYXJhbWV0ZXIgYmxvY2sgb21pdHRlZCwgZm9yIFNIQTEgTlVMTCBhbnlob3cuICovXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnNhbHRMZW5ndGgnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMixcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3Muc2FsdExlbmd0aC5zYWx0TGVuZ3RoJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdzYWx0TGVuZ3RoJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnRyYWlsZXJGaWVsZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAzLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ3JzYXBzcy50cmFpbGVyLnRyYWlsZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5DbGFzcy5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3RyYWlsZXInXG4gICAgfV1cbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICBjYXB0dXJlQXNuMTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uaW50ZWdlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmVyc2lvbidcbiAgfSwge1xuICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLnN1YmplY3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0J1xuICB9LFxuICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gIHtcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcycsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzLnR5cGUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMudmFsdWUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlXG4gICAgICB9XVxuICAgIH1dXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgQ2VydGlmaWNhdGlvblJlcXVlc3Qgc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdCcsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdjc3InLFxuICB2YWx1ZTogW1xuICAgIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvciwge1xuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjc3JTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjc3JTaWduYXR1cmVQYXJhbXMnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIHNpZ25hdHVyZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjc3JTaWduYXR1cmUnXG4gIH1dXG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJETlNlcXVlbmNlIG9mIEFTTi4xIERFUi1lbmNvZGVkIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqIHNldHMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kIHZhbHVlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHJkbiB0aGUgUkROU2VxdWVuY2UgdG8gY29udmVydC5cbiAqIEBwYXJhbSBtZCBhIG1lc3NhZ2UgZGlnZXN0IHRvIGFwcGVuZCB0eXBlIGFuZCB2YWx1ZSB0byBpZiBwcm92aWRlZC5cbiAqL1xucGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5ID0gZnVuY3Rpb24ocmRuLCBtZCkge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIGVhY2ggdmFsdWUgaW4gJ3JkbicgaW4gaXMgYSBTRVQgb2YgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZVxuICB2YXIgc2V0LCBhdHRyLCBvYmo7XG4gIGZvcih2YXIgc2kgPSAwOyBzaSA8IHJkbi52YWx1ZS5sZW5ndGg7ICsrc2kpIHtcbiAgICAvLyBnZXQgdGhlIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgc2V0ID0gcmRuLnZhbHVlW3NpXTtcblxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIFNFVCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgc2VxdWVuY2VcbiAgICAvLyBjb250YWluaW5nIGZpcnN0IGEgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIGEgdmFsdWUgKGRlZmluZWQgYnlcbiAgICAvLyB0aGUgT0lEKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXQudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIG9iaiA9IHt9O1xuICAgICAgYXR0ciA9IHNldC52YWx1ZVtpXTtcbiAgICAgIG9iai50eXBlID0gYXNuMS5kZXJUb09pZChhdHRyLnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgIG9iai52YWx1ZSA9IGF0dHIudmFsdWVbMV0udmFsdWU7XG4gICAgICBvYmoudmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVbMV0udHlwZTtcbiAgICAgIC8vIGlmIHRoZSBPSUQgaXMga25vd24sIGdldCBpdHMgbmFtZSBhbmQgc2hvcnQgbmFtZVxuICAgICAgaWYob2JqLnR5cGUgaW4gb2lkcykge1xuICAgICAgICBvYmoubmFtZSA9IG9pZHNbb2JqLnR5cGVdO1xuICAgICAgICBpZihvYmoubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICAgIG9iai5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1tvYmoubmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kKSB7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudHlwZSk7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudmFsdWUpO1xuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIEFTTi4xIENSSUF0dHJpYnV0ZXMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kXG4gKiB2YWx1ZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIHRoZSBDUklBdHRyaWJ1dGVzIHRvIGNvbnZlcnQuXG4gKi9cbnBraS5DUklBdHRyaWJ1dGVzQXNBcnJheSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBlYWNoIHZhbHVlIGluICdhdHRyaWJ1dGVzJyBpbiBpcyBhIFNFUVVFTkNFIHdpdGggYW4gT0lEIGFuZCBhIFNFVFxuICBmb3IodmFyIHNpID0gMDsgc2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytzaSkge1xuICAgIC8vIGdldCB0aGUgYXR0cmlidXRlIHNlcXVlbmNlXG4gICAgdmFyIHNlcSA9IGF0dHJpYnV0ZXNbc2ldO1xuXG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgU0VRVUVOQ0UgY29udGFpbmluZyBmaXJzdCBhIHR5cGUgKGFuIE9JRCkgYW5kXG4gICAgLy8gc2Vjb25kIGEgc2V0IG9mIHZhbHVlcyAoZGVmaW5lZCBieSB0aGUgT0lEKVxuICAgIHZhciB0eXBlID0gYXNuMS5kZXJUb09pZChzZXEudmFsdWVbMF0udmFsdWUpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXEudmFsdWVbMV0udmFsdWU7XG4gICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgdmFsdWVzLmxlbmd0aDsgKyt2aSkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgb2JqLnR5cGUgPSB0eXBlO1xuICAgICAgb2JqLnZhbHVlID0gdmFsdWVzW3ZpXS52YWx1ZTtcbiAgICAgIG9iai52YWx1ZVRhZ0NsYXNzID0gdmFsdWVzW3ZpXS50eXBlO1xuICAgICAgLy8gaWYgdGhlIE9JRCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lIGFuZCBzaG9ydCBuYW1lXG4gICAgICBpZihvYmoudHlwZSBpbiBvaWRzKSB7XG4gICAgICAgIG9iai5uYW1lID0gb2lkc1tvYmoudHlwZV07XG4gICAgICAgIGlmKG9iai5uYW1lIGluIF9zaG9ydE5hbWVzKSB7XG4gICAgICAgICAgb2JqLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW29iai5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcGFyc2UgZXh0ZW5zaW9uc1xuICAgICAgaWYob2JqLnR5cGUgPT09IG9pZHMuZXh0ZW5zaW9uUmVxdWVzdCkge1xuICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgb2JqLmV4dGVuc2lvbnMucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMShvYmoudmFsdWVbZWldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaChvYmopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGlzc3VlciBvciBzdWJqZWN0IGF0dHJpYnV0ZSBmcm9tIGl0cyBuYW1lLCB0eXBlLCBvciBzaG9ydCBuYW1lLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGlzc3VlciBvciBzdWJqZWN0IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIGEgc2hvcnQgbmFtZSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICBzaG9ydE5hbWUgdGhlIHNob3J0IG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIGZvciB0aGUgYXR0cmlidXRlLlxuICogICAgICAgICAgdHlwZSB0aGUgdHlwZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGUob2JqLCBvcHRpb25zKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7c2hvcnROYW1lOiBvcHRpb25zfTtcbiAgfVxuXG4gIHZhciBydmFsID0gbnVsbDtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IG9iai5hdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IG9iai5hdHRyaWJ1dGVzW2ldO1xuICAgIGlmKG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgPT09IGF0dHIudHlwZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMubmFtZSAmJiBvcHRpb25zLm5hbWUgPT09IGF0dHIubmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMuc2hvcnROYW1lICYmIG9wdGlvbnMuc2hvcnROYW1lID09PSBhdHRyLnNob3J0TmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGZyb20gQVNOLjEgc3RydWN0dXJlLlxuICpcbiAqIEN1cnJlbnRseSBvbmx5IFJTQVNTQS1QU1Mgc3VwcG9ydGVkLiAgVGhlIFBLQ1MjMSB2MS41IHNpZ25hdHVyZSBzY2hlbWUgaGFkXG4gKiBubyBwYXJhbWV0ZXJzLlxuICpcbiAqIFJTQVNTQS1QU1MtcGFyYW1zICA6Oj0gIFNFUVVFTkNFICB7XG4gKiAgIGhhc2hBbGdvcml0aG0gICAgICBbMF0gSGFzaEFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhMUlkZW50aWZpZXIsXG4gKiAgIG1hc2tHZW5BbGdvcml0aG0gICBbMV0gTWFza0dlbkFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWdmMVNIQTFJZGVudGlmaWVyLFxuICogICBzYWx0TGVuZ3RoICAgICAgICAgWzJdIElOVEVHRVIgREVGQVVMVCAyMCxcbiAqICAgdHJhaWxlckZpZWxkICAgICAgIFszXSBJTlRFR0VSIERFRkFVTFQgMVxuICogfVxuICpcbiAqIEhhc2hBbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIE1hc2tHZW5BbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQHBhcmFtIG9pZCBUaGUgT0lEIHNwZWNpZnlpbmcgdGhlIHNpZ25hdHVyZSBhbGdvcml0aG1cbiAqIEBwYXJhbSBvYmogVGhlIEFTTi4xIHN0cnVjdHVyZSBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gZmlsbERlZmF1bHRzIFdoZXRoZXIgdG8gdXNlIHJldHVybiBkZWZhdWx0IHZhbHVlcyB3aGVyZSBvbWl0dGVkXG4gKiBAcmV0dXJuIHNpZ25hdHVyZSBwYXJhbWV0ZXIgb2JqZWN0XG4gKi9cbnZhciBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihvaWQsIG9iaiwgZmlsbERlZmF1bHRzKSB7XG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBpZihvaWQgIT09IG9pZHNbJ1JTQVNTQS1QU1MnXSkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBpZihmaWxsRGVmYXVsdHMpIHtcbiAgICBwYXJhbXMgPSB7XG4gICAgICBoYXNoOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snc2hhMSddXG4gICAgICB9LFxuICAgICAgbWdmOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snbWdmMSddLFxuICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydzaGExJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNhbHRMZW5ndGg6IDIwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2Fzc2FQc3NQYXJhbWV0ZXJWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFJTQVNTQS1QU1MgcGFyYW1ldGVyIGJsb2NrLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuaGFzaE9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLmhhc2ggPSBwYXJhbXMuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuaGFzaE9pZCk7XG4gIH1cblxuICBpZihjYXB0dXJlLm1hc2tHZW5PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcy5tZ2YgPSBwYXJhbXMubWdmIHx8IHt9O1xuICAgIHBhcmFtcy5tZ2YuYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5PaWQpO1xuICAgIHBhcmFtcy5tZ2YuaGFzaCA9IHBhcmFtcy5tZ2YuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMubWdmLmhhc2guYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5IYXNoT2lkKTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnNhbHRMZW5ndGggPSBjYXB0dXJlLnNhbHRMZW5ndGguY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5IGNlcnRpZmljYXRlIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhpcyB3aWxsIHNjYW4gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWQgYmFja1xuICogdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY2VydGlmaWNhdGVGcm9tUGVtID0gZnVuY3Rpb24ocGVtLCBjb21wdXRlSGFzaCwgc3RyaWN0KSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdDRVJUSUZJQ0FURScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1g1MDkgQ0VSVElGSUNBVEUnICYmXG4gICAgbXNnLnR5cGUgIT09ICdUUlVTVEVEIENFUlRJRklDQVRFJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGUgZnJvbSBQRU07IFBFTSBoZWFkZXIgdHlwZSAnICtcbiAgICAgICdpcyBub3QgXCJDRVJUSUZJQ0FURVwiLCBcIlg1MDkgQ0VSVElGSUNBVEVcIiwgb3IgXCJUUlVTVEVEIENFUlRJRklDQVRFXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBjZXJ0aWZpY2F0ZSB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZVRvUGVtID0gZnVuY3Rpb24oY2VydCwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0NFUlRJRklDQVRFJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnB1YmxpY0tleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ1BVQkxJQyBLRVknICYmIG1zZy50eXBlICE9PSAnUlNBIFBVQkxJQyBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwdWJsaWMga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyICcgK1xuICAgICAgJ3R5cGUgaXMgbm90IFwiUFVCTElDIEtFWVwiIG9yIFwiUlNBIFBVQkxJQyBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcblxuICByZXR1cm4gcGtpLnB1YmxpY0tleUZyb21Bc24xKG9iaik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IHRvIFBFTSBmb3JtYXQgKHVzaW5nIGEgU3ViamVjdFB1YmxpY0tleUluZm8pLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1BlbSA9IGZ1bmN0aW9uKGtleSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BVQkxJQyBLRVknLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHB1YmxpYyBrZXkgdG8gUEVNIGZvcm1hdCAodXNpbmcgYW4gUlNBUHVibGljS2V5KS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXlQZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFVCTElDIEtFWScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBmaW5nZXJwcmludCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW21kXSB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSAoZGVmYXVsdHMgdG8gZm9yZ2UubWQuc2hhMSkuXG4gKiAgICAgICAgICBbdHlwZV0gdGhlIHR5cGUgb2YgZmluZ2VycHJpbnQsIHN1Y2ggYXMgJ1JTQVB1YmxpY0tleScsXG4gKiAgICAgICAgICAgICdTdWJqZWN0UHVibGljS2V5SW5mbycgKGRlZmF1bHRzIHRvICdSU0FQdWJsaWNLZXknKS5cbiAqICAgICAgICAgIFtlbmNvZGluZ10gYW4gYWx0ZXJuYXRpdmUgb3V0cHV0IGVuY29kaW5nLCBzdWNoIGFzICdoZXgnXG4gKiAgICAgICAgICAgIChkZWZhdWx0cyB0byBub25lLCBvdXRwdXRzIGEgYnl0ZSBidWZmZXIpLlxuICogICAgICAgICAgW2RlbGltaXRlcl0gdGhlIGRlbGltaXRlciB0byB1c2UgYmV0d2VlbiBieXRlcyBmb3IgJ2hleCcgZW5jb2RlZFxuICogICAgICAgICAgICBvdXRwdXQsIGVnOiAnOicgKGRlZmF1bHRzIHRvIG5vbmUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbmdlcnByaW50IGFzIGEgYnl0ZSBidWZmZXIgb3Igb3RoZXIgZW5jb2RpbmcgYmFzZWQgb24gb3B0aW9ucy5cbiAqL1xucGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50ID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbWQgPSBvcHRpb25zLm1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8ICdSU0FQdWJsaWNLZXknO1xuXG4gIHZhciBieXRlcztcbiAgc3dpdGNoKHR5cGUpIHtcbiAgY2FzZSAnUlNBUHVibGljS2V5JzpcbiAgICBieXRlcyA9IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSkpLmdldEJ5dGVzKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1N1YmplY3RQdWJsaWNLZXlJbmZvJzpcbiAgICBieXRlcyA9IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaW5nZXJwcmludCB0eXBlIFwiJyArIG9wdGlvbnMudHlwZSArICdcIi4nKTtcbiAgfVxuXG4gIC8vIGhhc2ggcHVibGljIGtleSBieXRlc1xuICBtZC5zdGFydCgpO1xuICBtZC51cGRhdGUoYnl0ZXMpO1xuICB2YXIgZGlnZXN0ID0gbWQuZGlnZXN0KCk7XG4gIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgdmFyIGhleCA9IGRpZ2VzdC50b0hleCgpO1xuICAgIGlmKG9wdGlvbnMuZGVsaW1pdGVyKSB7XG4gICAgICByZXR1cm4gaGV4Lm1hdGNoKC8uezJ9L2cpLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9IGVsc2UgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICByZXR1cm4gZGlnZXN0LmdldEJ5dGVzKCk7XG4gIH0gZWxzZSBpZihvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIFwiJyArIG9wdGlvbnMuZW5jb2RpbmcgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIGRpZ2VzdDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGlzIHdpbGwgc2NhbiB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2ZcbiAqIHRoZSBBU04uMSBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWRcbiAqIGJhY2sgdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKS5cbiAqL1xucGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbVBlbSA9IGZ1bmN0aW9uKHBlbSwgY29tcHV0ZUhhc2gsIHN0cmljdCkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnQ0VSVElGSUNBVEUgUkVRVUVTVCcpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRpb24gcmVxdWVzdCBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIG5vdCBcIkNFUlRJRklDQVRFIFJFUVVFU1RcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGZyb20gUEVNOyAnICtcbiAgICAgICdQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvUGVtID0gZnVuY3Rpb24oY3NyLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnQ0VSVElGSUNBVEUgUkVRVUVTVCcsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGlvblJlcXVlc3RUb0FzbjEoY3NyKSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgWC41MDl2MyBSU0EgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jcmVhdGVDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2VydCA9IHt9O1xuICBjZXJ0LnZlcnNpb24gPSAweDAyO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9ICcwMCc7XG4gIGNlcnQuc2lnbmF0dXJlT2lkID0gbnVsbDtcbiAgY2VydC5zaWduYXR1cmUgPSBudWxsO1xuICBjZXJ0LnNpZ2luZm8gPSB7fTtcbiAgY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IG51bGw7XG4gIGNlcnQudmFsaWRpdHkgPSB7fTtcbiAgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgPSBuZXcgRGF0ZSgpO1xuICBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyID0gbmV3IERhdGUoKTtcblxuICBjZXJ0Lmlzc3VlciA9IHt9O1xuICBjZXJ0Lmlzc3Vlci5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5pc3N1ZXIsIHNuKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gW107XG4gIGNlcnQuaXNzdWVyLmhhc2ggPSBudWxsO1xuXG4gIGNlcnQuc3ViamVjdCA9IHt9O1xuICBjZXJ0LnN1YmplY3QuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuc3ViamVjdCwgc24pO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBbXTtcbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuXG4gIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICBjZXJ0LnB1YmxpY0tleSA9IG51bGw7XG4gIGNlcnQubWQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2Ygc3ViamVjdCBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICogQHBhcmFtIHVuaXF1ZUlkIGFuIG9wdGlvbmFsIGEgdW5pcXVlIElEIHRvIHVzZS5cbiAgICovXG4gIGNlcnQuc2V0U3ViamVjdCA9IGZ1bmN0aW9uKGF0dHJzLCB1bmlxdWVJZCkge1xuICAgIC8vIHNldCBuZXcgYXR0cmlidXRlcywgY2xlYXIgaGFzaFxuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycyk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBkZWxldGUgY2VydC5zdWJqZWN0LnVuaXF1ZUlkO1xuICAgIGlmKHVuaXF1ZUlkKSB7XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgY2VydC5zdWJqZWN0LnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgfVxuICAgIGNlcnQuc3ViamVjdC5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgaXNzdWVyIG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2YgaXNzdWVyIGF0dHJpYnV0ZXMgdG8gdXNlLlxuICAgKiBAcGFyYW0gdW5pcXVlSWQgYW4gb3B0aW9uYWwgYSB1bmlxdWUgSUQgdG8gdXNlLlxuICAgKi9cbiAgY2VydC5zZXRJc3N1ZXIgPSBmdW5jdGlvbihhdHRycywgdW5pcXVlSWQpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXMsIGNsZWFyIGhhc2hcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBkZWxldGUgY2VydC5pc3N1ZXIudW5pcXVlSWQ7XG4gICAgaWYodW5pcXVlSWQpIHtcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICBjZXJ0Lmlzc3Vlci51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIH1cbiAgICBjZXJ0Lmlzc3Vlci5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgZXh0ZW5zaW9ucyBvZiB0aGlzIGNlcnRpZmljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gZXh0cyB0aGUgYXJyYXkgb2YgZXh0ZW5zaW9ucyB0byB1c2UuXG4gICAqL1xuICBjZXJ0LnNldEV4dGVuc2lvbnMgPSBmdW5jdGlvbihleHRzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhleHRzW2ldLCB7Y2VydDogY2VydH0pO1xuICAgIH1cbiAgICAvLyBzZXQgbmV3IGV4dGVuc2lvbnNcbiAgICBjZXJ0LmV4dGVuc2lvbnMgPSBleHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGV4dGVuc2lvbiBieSBpdHMgbmFtZSBvciBpZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG5hbWUgdG8gdXNlIG9yIGFuIG9iamVjdCB3aXRoOlxuICAgKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIHRvIHVzZS5cbiAgICogICAgICAgICAgaWQgdGhlIGlkIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgY2VydC5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0ge25hbWU6IG9wdGlvbnN9O1xuICAgIH1cblxuICAgIHZhciBydmFsID0gbnVsbDtcbiAgICB2YXIgZXh0O1xuICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IGNlcnQuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgZXh0ID0gY2VydC5leHRlbnNpb25zW2ldO1xuICAgICAgaWYob3B0aW9ucy5pZCAmJiBleHQuaWQgPT09IG9wdGlvbnMuaWQpIHtcbiAgICAgICAgcnZhbCA9IGV4dDtcbiAgICAgIH0gZWxzZSBpZihvcHRpb25zLm5hbWUgJiYgZXh0Lm5hbWUgPT09IG9wdGlvbnMubmFtZSkge1xuICAgICAgICBydmFsID0gZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhpcyBjZXJ0aWZpY2F0ZSB1c2luZyB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aC5cbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIChkZWZhdWx0cyB0byBmb3JnZS5tZC5zaGExKS5cbiAgICovXG4gIGNlcnQuc2lnbiA9IGZ1bmN0aW9uKGtleSwgbWQpIHtcbiAgICAvLyBUT0RPOiBnZXQgc2lnbmF0dXJlIE9JRCBmcm9tIHByaXZhdGUga2V5XG4gICAgY2VydC5tZCA9IG1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIGFsZ29yaXRobU9pZCA9IG9pZHNbY2VydC5tZC5hbGdvcml0aG0gKyAnV2l0aFJTQUVuY3J5cHRpb24nXTtcbiAgICBpZighYWxnb3JpdGhtT2lkKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSBPSUQuJyk7XG4gICAgICBlcnJvci5hbGdvcml0aG0gPSBjZXJ0Lm1kLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBhbGdvcml0aG1PaWQ7XG5cbiAgICAvLyBnZXQgVEJTQ2VydGlmaWNhdGUsIGNvbnZlcnQgdG8gREVSXG4gICAgY2VydC50YnNDZXJ0aWZpY2F0ZSA9IHBraS5nZXRUQlNDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNlcnQudGJzQ2VydGlmaWNhdGUpO1xuXG4gICAgLy8gZGlnZXN0IGFuZCBzaWduXG4gICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgY2VydC5zaWduYXR1cmUgPSBrZXkuc2lnbihjZXJ0Lm1kKTtcbiAgfTtcblxuICAvKipcbiAgICogQXR0ZW1wdHMgdmVyaWZ5IHRoZSBzaWduYXR1cmUgb24gdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSB1c2luZyB0aGlzXG4gICAqIGNlcnRpZmljYXRlJ3MgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGNoaWxkIHRoZSBjZXJ0aWZpY2F0ZSB0byB2ZXJpZnkuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnkgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIHZhciBydmFsID0gZmFsc2U7XG5cbiAgICBpZighY2VydC5pc3N1ZWQoY2hpbGQpKSB7XG4gICAgICB2YXIgaXNzdWVyID0gY2hpbGQuaXNzdWVyO1xuICAgICAgdmFyIHN1YmplY3QgPSBjZXJ0LnN1YmplY3Q7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1RoZSBwYXJlbnQgY2VydGlmaWNhdGUgZGlkIG5vdCBpc3N1ZSB0aGUgZ2l2ZW4gY2hpbGQgJyArXG4gICAgICAgICdjZXJ0aWZpY2F0ZTsgdGhlIGNoaWxkIGNlcnRpZmljYXRlXFwncyBpc3N1ZXIgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xuICAgICAgICAncGFyZW50XFwncyBzdWJqZWN0LicpO1xuICAgICAgZXJyb3IuZXhwZWN0ZWRJc3N1ZXIgPSBpc3N1ZXIuYXR0cmlidXRlcztcbiAgICAgIGVycm9yLmFjdHVhbElzc3VlciA9IHN1YmplY3QuYXR0cmlidXRlcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBtZCA9IGNoaWxkLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBpZihjaGlsZC5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgICB2YXIgb2lkID0gb2lkc1tjaGlsZC5zaWduYXR1cmVPaWRdO1xuICAgICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICAgIGNhc2UgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhMzg0V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihtZCA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICAgJ1Vua25vd24gc2lnbmF0dXJlIE9JRC4nKTtcbiAgICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY2hpbGQuc2lnbmF0dXJlT2lkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIFRCU0NlcnRpZmljYXRlIGFuZCBkaWdlc3QgaXRcbiAgICAgIHZhciB0YnNDZXJ0aWZpY2F0ZSA9IGNoaWxkLnRic0NlcnRpZmljYXRlIHx8IHBraS5nZXRUQlNDZXJ0aWZpY2F0ZShjaGlsZCk7XG4gICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKHRic0NlcnRpZmljYXRlKTtcbiAgICAgIG1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgICB9XG5cbiAgICBpZihtZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHNjaGVtZTtcblxuICAgICAgc3dpdGNoKGNoaWxkLnNpZ25hdHVyZU9pZCkge1xuICAgICAgY2FzZSBvaWRzLnNoYTFXaXRoUlNBRW5jcnlwdGlvbjpcbiAgICAgICAgc2NoZW1lID0gdW5kZWZpbmVkOyAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgc2NoZW1lICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICAgIHZhciBoYXNoLCBtZ2Y7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBtZ2YgKi9cbiAgICAgICAgaGFzaCA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgICAgZXJyb3Iub2lkID0gY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IGhhc2g7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICBtZ2YgPSBvaWRzW2NoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZF07XG4gICAgICAgIGlmKG1nZiA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1nZlttZ2ZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBlcnJvci5vaWQgPSBjaGlsZC5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgIGhhc2ggPSBvaWRzW2NoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdVbnN1cHBvcnRlZCBSU0FTU0EtUFNTIGhhc2ggZnVuY3Rpb24uJyxcbiAgICAgICAgICAgIG9pZDogY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZCxcbiAgICAgICAgICAgIG5hbWU6IGhhc2hcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2NoZW1lID0gZm9yZ2UucHNzLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSwgbWdmLFxuICAgICAgICAgIGNoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuc2FsdExlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyB2ZXJpZnkgc2lnbmF0dXJlIG9uIGNlcnQgdXNpbmcgcHVibGljIGtleVxuICAgICAgcnZhbCA9IGNlcnQucHVibGljS2V5LnZlcmlmeShcbiAgICAgICAgbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSwgY2hpbGQuc2lnbmF0dXJlLCBzY2hlbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIGlzc3VlciBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogY2VydGlmaWNhdGUncyBzdWJqZWN0LiBOb3RlIHRoYXQgbm8gc2lnbmF0dXJlIGNoZWNrIGlzIHBlcmZvcm1lZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3MgaXNzdWVyIG1hdGNoZXMgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSdzXG4gICAqICAgICAgICAgc3ViamVjdC5cbiAgICovXG4gIGNlcnQuaXNJc3N1ZXIgPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIGkgPSBjZXJ0Lmlzc3VlcjtcbiAgICB2YXIgcyA9IHBhcmVudC5zdWJqZWN0O1xuXG4gICAgLy8gY29tcGFyZSBoYXNoZXMgaWYgcHJlc2VudFxuICAgIGlmKGkuaGFzaCAmJiBzLmhhc2gpIHtcbiAgICAgIHJ2YWwgPSAoaS5oYXNoID09PSBzLmhhc2gpO1xuICAgIH0gZWxzZSBpZihpLmF0dHJpYnV0ZXMubGVuZ3RoID09PSBzLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBhbGwgYXR0cmlidXRlcyBhcmUgdGhlIHNhbWUgc28gaXNzdWVyIG1hdGNoZXMgc3ViamVjdFxuICAgICAgcnZhbCA9IHRydWU7XG4gICAgICB2YXIgaWF0dHIsIHNhdHRyO1xuICAgICAgZm9yKHZhciBuID0gMDsgcnZhbCAmJiBuIDwgaS5hdHRyaWJ1dGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGlhdHRyID0gaS5hdHRyaWJ1dGVzW25dO1xuICAgICAgICBzYXR0ciA9IHMuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgaWYoaWF0dHIudHlwZSAhPT0gc2F0dHIudHlwZSB8fCBpYXR0ci52YWx1ZSAhPT0gc2F0dHIudmFsdWUpIHtcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgbWlzbWF0Y2hcbiAgICAgICAgICBydmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2VydGlmaWNhdGUncyBzdWJqZWN0IG1hdGNoZXMgdGhlIGlzc3VlciBvZiB0aGVcbiAgICogZ2l2ZW4gY2VydGlmaWNhdGUpLiBOb3RlIHRoYXQgbm90IHNpZ25hdHVyZSBjaGVjayBpcyBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGlsZCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3Mgc3ViamVjdCBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogICAgICAgICBjZXJ0aWZpY2F0ZSdzIGlzc3Vlci5cbiAgICovXG4gIGNlcnQuaXNzdWVkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuaXNJc3N1ZXIoY2VydCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgc3ViamVjdEtleUlkZW50aWZpZXIgZm9yIHRoaXMgY2VydGlmaWNhdGUgYXMgYnl0ZSBidWZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGZvciB0aGlzIGNlcnRpZmljYXRlIGFzIGJ5dGUgYnVmZmVyLlxuICAgKi9cbiAgY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgLyogU2VlOiA0LjIuMS4yIHNlY3Rpb24gb2YgdGhlIHRoZSBSRkMzMjgwLCBrZXlJZGVudGlmaWVyIGlzIGVpdGhlcjpcblxuICAgICAgKDEpIFRoZSBrZXlJZGVudGlmaWVyIGlzIGNvbXBvc2VkIG9mIHRoZSAxNjAtYml0IFNIQS0xIGhhc2ggb2YgdGhlXG4gICAgICAgIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXkgKGV4Y2x1ZGluZyB0aGUgdGFnLFxuICAgICAgICBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdHMpLlxuXG4gICAgICAoMikgVGhlIGtleUlkZW50aWZpZXIgaXMgY29tcG9zZWQgb2YgYSBmb3VyIGJpdCB0eXBlIGZpZWxkIHdpdGhcbiAgICAgICAgdGhlIHZhbHVlIDAxMDAgZm9sbG93ZWQgYnkgdGhlIGxlYXN0IHNpZ25pZmljYW50IDYwIGJpdHMgb2YgdGhlXG4gICAgICAgIFNIQS0xIGhhc2ggb2YgdGhlIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgKGV4Y2x1ZGluZyB0aGUgdGFnLCBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdCBzdHJpbmcgYml0cykuXG4gICAgKi9cblxuICAgIC8vIHNraXBwaW5nIHRoZSB0YWcsIGxlbmd0aCwgYW5kIG51bWJlciBvZiB1bnVzZWQgYml0cyBpcyB0aGUgc2FtZVxuICAgIC8vIGFzIGp1c3QgdXNpbmcgdGhlIFJTQVB1YmxpY0tleSAoZm9yIFJTQSBrZXlzLCB3aGljaCBhcmUgdGhlXG4gICAgLy8gb25seSBvbmVzIHN1cHBvcnRlZClcbiAgICByZXR1cm4gcGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50KGNlcnQucHVibGljS2V5LCB7dHlwZTogJ1JTQVB1YmxpY0tleSd9KTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGV4dGVuc2lvbiB2YWx1ZSBmb3IgdGhpcyBjZXJ0aWZpY2F0ZVxuICAgKiBhZ2FpbnN0IGl0cyBwdWJsaWMga2V5LiBJZiBubyBleHRlbnNpb24gaXMgZm91bmQsIGZhbHNlIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnlTdWJqZWN0S2V5SWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvaWQgPSBvaWRzWydzdWJqZWN0S2V5SWRlbnRpZmllciddO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICBpZihleHQuaWQgPT09IG9pZCkge1xuICAgICAgICB2YXIgc2tpID0gY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIChmb3JnZS51dGlsLmhleFRvQnl0ZXMoZXh0LnN1YmplY3RLZXlJZGVudGlmaWVyKSA9PT0gc2tpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZSBmcm9tIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGltcGxlbWVudGF0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBhIGNlcnRpZmljYXRlIGJhY2sgdG8gQVNOLjEgc28gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNlcnQgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gIC8vIHZhbGlkYXRlIGNlcnRpZmljYXRlIGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgWC41MDkgY2VydGlmaWNhdGUuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYW4gWDUwOXYzIENlcnRpZmljYXRlLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRlXG4gIHZhciBjZXJ0ID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRlKCk7XG4gIGNlcnQudmVyc2lvbiA9IGNhcHR1cmUuY2VydFZlcnNpb24gP1xuICAgIGNhcHR1cmUuY2VydFZlcnNpb24uY2hhckNvZGVBdCgwKSA6IDA7XG4gIHZhciBzZXJpYWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmNlcnRTZXJpYWxOdW1iZXIpO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9IHNlcmlhbC50b0hleCgpO1xuICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0U2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNlcnQuc2lnbmF0dXJlT2lkLCBjYXB0dXJlLmNlcnRTaWduYXR1cmVQYXJhbXMsIHRydWUpO1xuICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCxcbiAgICBjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zLCBmYWxzZSk7XG4gIGNlcnQuc2lnbmF0dXJlID0gY2FwdHVyZS5jZXJ0U2lnbmF0dXJlO1xuXG4gIHZhciB2YWxpZGl0eSA9IFtdO1xuICBpZihjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEudXRjVGltZVRvRGF0ZShjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlKFxuICAgICAgY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLnV0Y1RpbWVUb0RhdGUoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShcbiAgICAgIGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSkpO1xuICB9XG4gIGlmKHZhbGlkaXR5Lmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIG5vdEJlZm9yZS9ub3RBZnRlciB2YWxpZGl0eSB0aW1lczsgbW9yZSAnICtcbiAgICAgICd0aGFuIHR3byB0aW1lcyB3ZXJlIHByb3ZpZGVkIGluIHRoZSBjZXJ0aWZpY2F0ZS4nKTtcbiAgfVxuICBpZih2YWxpZGl0eS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBub3RCZWZvcmUvbm90QWZ0ZXIgdmFsaWRpdHkgdGltZXM7IHRoZXkgJyArXG4gICAgICAnd2VyZSBub3QgcHJvdmlkZWQgYXMgZWl0aGVyIFVUQ1RpbWUgb3IgR2VuZXJhbGl6ZWRUaW1lLicpO1xuICB9XG4gIGNlcnQudmFsaWRpdHkubm90QmVmb3JlID0gdmFsaWRpdHlbMF07XG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSB2YWxpZGl0eVsxXTtcblxuICAvLyBrZWVwIFRCU0NlcnRpZmljYXRlIHRvIHByZXNlcnZlIHNpZ25hdHVyZSB3aGVuIGV4cG9ydGluZ1xuICBjZXJ0LnRic0NlcnRpZmljYXRlID0gY2FwdHVyZS50YnNDZXJ0aWZpY2F0ZTtcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICBjZXJ0Lm1kID0gbnVsbDtcbiAgICBpZihjZXJ0LnNpZ25hdHVyZU9pZCBpbiBvaWRzKSB7XG4gICAgICB2YXIgb2lkID0gb2lkc1tjZXJ0LnNpZ25hdHVyZU9pZF07XG4gICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUlNBU1NBLVBTUyc6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihjZXJ0Lm1kID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIHNpZ25hdHVyZSBPSUQuJyk7XG4gICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjZXJ0LnNpZ25hdHVyZU9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBUQlNDZXJ0aWZpY2F0ZSBhbmQgZGlnZXN0IGl0XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjZXJ0LnRic0NlcnRpZmljYXRlKTtcbiAgICBjZXJ0Lm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBpc3N1ZXIsIGJ1aWxkIGlzc3VlciBtZXNzYWdlIGRpZ2VzdFxuICB2YXIgaW1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgY2VydC5pc3N1ZXIuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuaXNzdWVyLCBzbik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRJc3N1ZXIsIGltZCk7XG4gIGlmKGNhcHR1cmUuY2VydElzc3VlclVuaXF1ZUlkKSB7XG4gICAgY2VydC5pc3N1ZXIudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRJc3N1ZXJVbmlxdWVJZDtcbiAgfVxuICBjZXJ0Lmlzc3Vlci5oYXNoID0gaW1kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNlcnQuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5zdWJqZWN0LCBzbik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRTdWJqZWN0LCBzbWQpO1xuICBpZihjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQpIHtcbiAgICBjZXJ0LnN1YmplY3QudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQ7XG4gIH1cbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBzbWQuZGlnZXN0KCkudG9IZXgoKTtcblxuICAvLyBoYW5kbGUgZXh0ZW5zaW9uc1xuICBpZihjYXB0dXJlLmNlcnRFeHRlbnNpb25zKSB7XG4gICAgY2VydC5leHRlbnNpb25zID0gcGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uc0Zyb21Bc24xKGNhcHR1cmUuY2VydEV4dGVuc2lvbnMpO1xuICB9IGVsc2Uge1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICB9XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNlcnQucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU04uMSBleHRlbnNpb25zIG9iamVjdCAod2l0aCBleHRlbnNpb24gc2VxdWVuY2VzIGFzIGl0c1xuICogdmFsdWVzKSBpbnRvIGFuIGFycmF5IG9mIGV4dGVuc2lvbiBvYmplY3RzIHdpdGggdHlwZXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBTdXBwb3J0ZWQgZXh0ZW5zaW9uczpcbiAqXG4gKiBpZC1jZS1rZXlVc2FnZSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTUgfVxuICogS2V5VXNhZ2UgOjo9IEJJVCBTVFJJTkcge1xuICogICBkaWdpdGFsU2lnbmF0dXJlICAgICAgICAoMCksXG4gKiAgIG5vblJlcHVkaWF0aW9uICAgICAgICAgICgxKSxcbiAqICAga2V5RW5jaXBoZXJtZW50ICAgICAgICAgKDIpLFxuICogICBkYXRhRW5jaXBoZXJtZW50ICAgICAgICAoMyksXG4gKiAgIGtleUFncmVlbWVudCAgICAgICAgICAgICg0KSxcbiAqICAga2V5Q2VydFNpZ24gICAgICAgICAgICAgKDUpLFxuICogICBjUkxTaWduICAgICAgICAgICAgICAgICAoNiksXG4gKiAgIGVuY2lwaGVyT25seSAgICAgICAgICAgICg3KSxcbiAqICAgZGVjaXBoZXJPbmx5ICAgICAgICAgICAgKDgpXG4gKiB9XG4gKlxuICogaWQtY2UtYmFzaWNDb25zdHJhaW50cyBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTkgfVxuICogQmFzaWNDb25zdHJhaW50cyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjQSAgICAgICAgICAgICAgICAgICAgICBCT09MRUFOIERFRkFVTFQgRkFMU0UsXG4gKiAgIHBhdGhMZW5Db25zdHJhaW50ICAgICAgIElOVEVHRVIgKDAuLk1BWCkgT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBzdWJqZWN0QWx0TmFtZSBFWFRFTlNJT04gOjo9IHtcbiAqICAgU1lOVEFYIEdlbmVyYWxOYW1lc1xuICogICBJREVOVElGSUVEIEJZIGlkLWNlLXN1YmplY3RBbHROYW1lXG4gKiB9XG4gKlxuICogR2VuZXJhbE5hbWVzIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEdlbmVyYWxOYW1lXG4gKlxuICogR2VuZXJhbE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIG90aGVyTmFtZSAgICAgIFswXSBJTlNUQU5DRSBPRiBPVEhFUi1OQU1FLFxuICogICByZmM4MjJOYW1lICAgICBbMV0gSUE1U3RyaW5nLFxuICogICBkTlNOYW1lICAgICAgICBbMl0gSUE1U3RyaW5nLFxuICogICB4NDAwQWRkcmVzcyAgICBbM10gT1JBZGRyZXNzLFxuICogICBkaXJlY3RvcnlOYW1lICBbNF0gTmFtZSxcbiAqICAgZWRpUGFydHlOYW1lICAgWzVdIEVESVBhcnR5TmFtZSxcbiAqICAgdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciBbNl0gSUE1U3RyaW5nLFxuICogICBJUEFkZHJlc3MgICAgICBbN10gT0NURVQgU1RSSU5HLFxuICogICByZWdpc3RlcmVkSUQgICBbOF0gT0JKRUNUIElERU5USUZJRVJcbiAqIH1cbiAqXG4gKiBPVEhFUi1OQU1FIDo6PSBUWVBFLUlERU5USUZJRVJcbiAqXG4gKiBFRElQYXJ0eU5hbWUgOjo9IFNFUVVFTkNFIHtcbiAqICAgbmFtZUFzc2lnbmVyIFswXSBEaXJlY3RvcnlTdHJpbmcge3ViLW5hbWV9IE9QVElPTkFMLFxuICogICBwYXJ0eU5hbWUgICAgWzFdIERpcmVjdG9yeVN0cmluZyB7dWItbmFtZX1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyBBU04uMSB3aXRoIGV4dGVuc2lvbiBzZXF1ZW5jZXMgdG8gcGFyc2UuXG4gKlxuICogQHJldHVybiB0aGUgYXJyYXkuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMSA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgZXh0ZW5zaW9uIHNlcXVlbmNlXG4gICAgdmFyIGV4dHNlcSA9IGV4dHMudmFsdWVbaV07XG4gICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgZXh0c2VxLnZhbHVlLmxlbmd0aDsgKytlaSkge1xuICAgICAgcnZhbC5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xKGV4dHNlcS52YWx1ZVtlaV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2luZ2xlIGNlcnRpZmljYXRlIGV4dGVuc2lvbiBmcm9tIEFTTi4xLlxuICpcbiAqIEBwYXJhbSBleHQgdGhlIGV4dGVuc2lvbiBpbiBBU04uMSBmb3JtYXQuXG4gKlxuICogQHJldHVybiB0aGUgcGFyc2VkIGV4dGVuc2lvbiBhcyBhbiBvYmplY3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGFuIGV4dGVuc2lvbiBoYXM6XG4gIC8vIFswXSBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUlxuICAvLyBbMV0gY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFXG4gIC8vIFsyXSBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAgdmFyIGUgPSB7fTtcbiAgZS5pZCA9IGFzbjEuZGVyVG9PaWQoZXh0LnZhbHVlWzBdLnZhbHVlKTtcbiAgZS5jcml0aWNhbCA9IGZhbHNlO1xuICBpZihleHQudmFsdWVbMV0udHlwZSA9PT0gYXNuMS5UeXBlLkJPT0xFQU4pIHtcbiAgICBlLmNyaXRpY2FsID0gKGV4dC52YWx1ZVsxXS52YWx1ZS5jaGFyQ29kZUF0KDApICE9PSAweDAwKTtcbiAgICBlLnZhbHVlID0gZXh0LnZhbHVlWzJdLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGUudmFsdWUgPSBleHQudmFsdWVbMV0udmFsdWU7XG4gIH1cbiAgLy8gaWYgdGhlIG9pZCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lXG4gIGlmKGUuaWQgaW4gb2lkcykge1xuICAgIGUubmFtZSA9IG9pZHNbZS5pZF07XG5cbiAgICAvLyBoYW5kbGUga2V5IHVzYWdlXG4gICAgaWYoZS5uYW1lID09PSAna2V5VXNhZ2UnKSB7XG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIHZhciBiMyA9IDB4MDA7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNraXAgZmlyc3QgYnl0ZSwganVzdCBpbmRpY2F0ZXMgdW51c2VkIGJpdHMgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBiZSBwYWRkZWQgd2l0aCAwcyBhbnl3YXlcbiAgICAgICAgLy8gZ2V0IGJ5dGVzIHdpdGggZmxhZyBiaXRzXG4gICAgICAgIGIyID0gZXYudmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgICAgYjMgPSBldi52YWx1ZS5sZW5ndGggPiAyID8gZXYudmFsdWUuY2hhckNvZGVBdCgyKSA6IDA7XG4gICAgICB9XG4gICAgICAvLyBzZXQgZmxhZ3NcbiAgICAgIGUuZGlnaXRhbFNpZ25hdHVyZSA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5ub25SZXB1ZGlhdGlvbiA9IChiMiAmIDB4NDApID09PSAweDQwO1xuICAgICAgZS5rZXlFbmNpcGhlcm1lbnQgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUuZGF0YUVuY2lwaGVybWVudCA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5rZXlBZ3JlZW1lbnQgPSAoYjIgJiAweDA4KSA9PT0gMHgwODtcbiAgICAgIGUua2V5Q2VydFNpZ24gPSAoYjIgJiAweDA0KSA9PT0gMHgwNDtcbiAgICAgIGUuY1JMU2lnbiA9IChiMiAmIDB4MDIpID09PSAweDAyO1xuICAgICAgZS5lbmNpcGhlck9ubHkgPSAoYjIgJiAweDAxKSA9PT0gMHgwMTtcbiAgICAgIGUuZGVjaXBoZXJPbmx5ID0gKGIzICYgMHg4MCkgPT09IDB4ODA7XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgICAvLyBoYW5kbGUgYmFzaWMgY29uc3RyYWludHNcbiAgICAgIC8vIGdldCB2YWx1ZSBhcyBTRVFVRU5DRVxuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgLy8gZ2V0IGNBIEJPT0xFQU4gZmxhZyAoZGVmYXVsdHMgdG8gZmFsc2UpXG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAwICYmIGV2LnZhbHVlWzBdLnR5cGUgPT09IGFzbjEuVHlwZS5CT09MRUFOKSB7XG4gICAgICAgIGUuY0EgPSAoZXYudmFsdWVbMF0udmFsdWUuY2hhckNvZGVBdCgwKSAhPT0gMHgwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLmNBID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBnZXQgcGF0aCBsZW5ndGggY29uc3RyYWludFxuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDAgJiYgZXYudmFsdWVbMF0udHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIpIHtcbiAgICAgICAgdmFsdWUgPSBldi52YWx1ZVswXS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gZXYudmFsdWVbMV0udmFsdWU7XG4gICAgICB9XG4gICAgICBpZih2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBlLnBhdGhMZW5Db25zdHJhaW50ID0gYXNuMS5kZXJUb0ludGVnZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihlLm5hbWUgPT09ICdleHRLZXlVc2FnZScpIHtcbiAgICAgIC8vIGhhbmRsZSBleHRLZXlVc2FnZVxuICAgICAgLy8gdmFsdWUgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBmb3IodmFyIHZpID0gMDsgdmkgPCBldi52YWx1ZS5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoZXYudmFsdWVbdmldLnZhbHVlKTtcbiAgICAgICAgaWYob2lkIGluIG9pZHMpIHtcbiAgICAgICAgICBlW29pZHNbb2lkXV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVbb2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnbnNDZXJ0VHlwZScpIHtcbiAgICAgIC8vIGhhbmRsZSBuc0NlcnRUeXBlXG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gc2tpcCBmaXJzdCBieXRlLCBqdXN0IGluZGljYXRlcyB1bnVzZWQgYml0cyB3aGljaFxuICAgICAgICAvLyB3aWxsIGJlIHBhZGRlZCB3aXRoIDBzIGFueXdheVxuICAgICAgICAvLyBnZXQgYnl0ZXMgd2l0aCBmbGFnIGJpdHNcbiAgICAgICAgYjIgPSBldi52YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGZsYWdzXG4gICAgICBlLmNsaWVudCA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5zZXJ2ZXIgPSAoYjIgJiAweDQwKSA9PT0gMHg0MDtcbiAgICAgIGUuZW1haWwgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUub2Jqc2lnbiA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5yZXNlcnZlZCA9IChiMiAmIDB4MDgpID09PSAweDA4O1xuICAgICAgZS5zc2xDQSA9IChiMiAmIDB4MDQpID09PSAweDA0O1xuICAgICAgZS5lbWFpbENBID0gKGIyICYgMHgwMikgPT09IDB4MDI7XG4gICAgICBlLm9iakNBID0gKGIyICYgMHgwMSkgPT09IDB4MDE7XG4gICAgfSBlbHNlIGlmKFxuICAgICAgZS5uYW1lID09PSAnc3ViamVjdEFsdE5hbWUnIHx8XG4gICAgICBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgICAgLy8gaGFuZGxlIHN1YmplY3RBbHROYW1lL2lzc3VlckFsdE5hbWVcbiAgICAgIGUuYWx0TmFtZXMgPSBbXTtcblxuICAgICAgLy8gZXYgaXMgYSBTWU5UQVggU0VRVUVOQ0VcbiAgICAgIHZhciBnbjtcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBldi52YWx1ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICAvLyBnZXQgR2VuZXJhbE5hbWVcbiAgICAgICAgZ24gPSBldi52YWx1ZVtuXTtcblxuICAgICAgICB2YXIgYWx0TmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBnbi50eXBlLFxuICAgICAgICAgIHZhbHVlOiBnbi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBlLmFsdE5hbWVzLnB1c2goYWx0TmFtZSk7XG5cbiAgICAgICAgLy8gTm90ZTogU3VwcG9ydCBmb3IgdHlwZXMgMSwyLDYsNyw4XG4gICAgICAgIHN3aXRjaChnbi50eXBlKSB7XG4gICAgICAgIC8vIHJmYzgyMk5hbWVcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAvLyBkTlNOYW1lXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciAoVVJJKVxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElQQWRkcmVzc1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgLy8gY29udmVydCB0byBJUHY0L0lQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgYWx0TmFtZS5pcCA9IGZvcmdlLnV0aWwuYnl0ZXNUb0lQKGduLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gcmVnaXN0ZXJlZElEXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBhbHROYW1lLm9pZCA9IGFzbjEuZGVyVG9PaWQoZ24udmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHVuc3VwcG9ydGVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnc3ViamVjdEtleUlkZW50aWZpZXInKSB7XG4gICAgICAvLyB2YWx1ZSBpcyBhbiBPQ1RFVFNUUklORyB3L3RoZSBoYXNoIG9mIHRoZSBrZXktdHlwZSBzcGVjaWZpY1xuICAgICAgLy8gcHVibGljIGtleSBzdHJ1Y3R1cmUgKGVnOiBSU0FQdWJsaWNLZXkpXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGV2LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gaW1wbGVtZW50YXRpb24gZm9yIGNvbnZlcnRpbmdcbiAqIGEgY2VydGlmaWNhdGUgYmFjayB0byBBU04uMSBzbyB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2YgdGhlXG4gKiBBU04uMSBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNzciBvYmplY3QgaXMgY3JlYXRlZC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaiwgY29tcHV0ZUhhc2gpIHtcbiAgLy8gdmFsaWRhdGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIGNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEwIGNlcnRpZmljYXRlIHJlcXVlc3QuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYSBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdFxuICB2YXIgY3NyID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0KCk7XG4gIGNzci52ZXJzaW9uID0gY2FwdHVyZS5jc3JWZXJzaW9uID8gY2FwdHVyZS5jc3JWZXJzaW9uLmNoYXJDb2RlQXQoMCkgOiAwO1xuICBjc3Iuc2lnbmF0dXJlT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNzci5zaWduYXR1cmVPaWQsIGNhcHR1cmUuY3NyU2lnbmF0dXJlUGFyYW1zLCB0cnVlKTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoXG4gICAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkLCBjYXB0dXJlLmNzclNpZ25hdHVyZVBhcmFtcywgZmFsc2UpO1xuICBjc3Iuc2lnbmF0dXJlID0gY2FwdHVyZS5jc3JTaWduYXR1cmU7XG5cbiAgLy8ga2VlcCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gdG8gcHJlc2VydmUgc2lnbmF0dXJlIHdoZW4gZXhwb3J0aW5nXG4gIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBjYXB0dXJlLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbztcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICBjc3IubWQgPSBudWxsO1xuICAgIGlmKGNzci5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgdmFyIG9pZCA9IG9pZHNbY3NyLnNpZ25hdHVyZU9pZF07XG4gICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTUxMldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihjc3IubWQgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIHNpZ25hdHVyZSBPSUQuJyk7XG4gICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnbmF0dXJlT2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBhbmQgZGlnZXN0IGl0XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcihjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKTtcbiAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICB9XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNzci5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3Iuc3ViamVjdCwgc24pO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBwa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoXG4gICAgY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0LCBzbWQpO1xuICBjc3Iuc3ViamVjdC5oYXNoID0gc21kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNzci5wdWJsaWNLZXkgPSBwa2kucHVibGljS2V5RnJvbUFzbjEoY2FwdHVyZS5zdWJqZWN0UHVibGljS2V5SW5mbyk7XG5cbiAgLy8gY29udmVydCBhdHRyaWJ1dGVzIGZyb20gQVNOLjFcbiAgY3NyLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLCBzbik7XG4gIH07XG4gIGNzci5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY3NyLmF0dHJpYnV0ZXMgPSBwa2kuQ1JJQXR0cmlidXRlc0FzQXJyYXkoXG4gICAgY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9BdHRyaWJ1dGVzIHx8IFtdKTtcblxuICByZXR1cm4gY3NyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IGNlcnRpZmljYXRpb24gcmVxdWVzdCAoYSBDU1Igb3IgY2VydGlmaWNhdGUgc2lnbmluZ1xuICogcmVxdWVzdCkuIE9uY2UgY3JlYXRlZCwgaXRzIHB1YmxpYyBrZXkgYW5kIGF0dHJpYnV0ZXMgY2FuIGJlIHNldCBhbmQgdGhlblxuICogaXQgY2FuIGJlIHNpZ25lZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBlbXB0eSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jcmVhdGVDZXJ0aWZpY2F0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3NyID0ge307XG4gIGNzci52ZXJzaW9uID0gMHgwMDtcbiAgY3NyLnNpZ25hdHVyZU9pZCA9IG51bGw7XG4gIGNzci5zaWduYXR1cmUgPSBudWxsO1xuICBjc3Iuc2lnaW5mbyA9IHt9O1xuICBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBudWxsO1xuXG4gIGNzci5zdWJqZWN0ID0ge307XG4gIGNzci5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3Iuc3ViamVjdCwgc24pO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBbXTtcbiAgY3NyLnN1YmplY3QuaGFzaCA9IG51bGw7XG5cbiAgY3NyLnB1YmxpY0tleSA9IG51bGw7XG4gIGNzci5hdHRyaWJ1dGVzID0gW107XG4gIGNzci5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNzciwgc24pO1xuICB9O1xuICBjc3IuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNzci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5tZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN1YmplY3Qgb2YgdGhpcyBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2Ygc3ViamVjdCBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICovXG4gIGNzci5zZXRTdWJqZWN0ID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXNcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBjc3Iuc3ViamVjdC5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIHRoZSBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICovXG4gIGNzci5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXNcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNzci5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoaXMgY2VydGlmaWNhdGlvbiByZXF1ZXN0IHVzaW5nIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoLlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgKGRlZmF1bHRzIHRvIGZvcmdlLm1kLnNoYTEpLlxuICAgKi9cbiAgY3NyLnNpZ24gPSBmdW5jdGlvbihrZXksIG1kKSB7XG4gICAgLy8gVE9ETzogZ2V0IHNpZ25hdHVyZSBPSUQgZnJvbSBwcml2YXRlIGtleVxuICAgIGNzci5tZCA9IG1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIGFsZ29yaXRobU9pZCA9IG9pZHNbY3NyLm1kLmFsZ29yaXRobSArICdXaXRoUlNBRW5jcnlwdGlvbiddO1xuICAgIGlmKCFhbGdvcml0aG1PaWQpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSBPSUQuJyk7XG4gICAgICBlcnJvci5hbGdvcml0aG0gPSBjc3IubWQuYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNzci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBhbGdvcml0aG1PaWQ7XG5cbiAgICAvLyBnZXQgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLCBjb252ZXJ0IHRvIERFUlxuICAgIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBwa2kuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGNzcik7XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcihjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKTtcblxuICAgIC8vIGRpZ2VzdCBhbmQgc2lnblxuICAgIGNzci5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgY3NyLnNpZ25hdHVyZSA9IGtleS5zaWduKGNzci5tZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHZlcmlmeSB0aGUgc2lnbmF0dXJlIG9uIHRoZSBwYXNzZWQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IHVzaW5nXG4gICAqIGl0cyBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBBIENTUiB0aGF0IGhhcyBiZWVuIGV4cG9ydGVkIHRvIGEgZmlsZSBpbiBQRU0gZm9ybWF0IGNhbiBiZSB2ZXJpZmllZCB1c2luZ1xuICAgKiBPcGVuU1NMIHVzaW5nIHRoaXMgY29tbWFuZDpcbiAgICpcbiAgICogb3BlbnNzbCByZXEgLWluIDx0aGUtY3NyLXBlbS1maWxlPiAtdmVyaWZ5IC1ub291dCAtdGV4dFxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNzci52ZXJpZnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIG1kID0gY3NyLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBpZihjc3Iuc2lnbmF0dXJlT2lkIGluIG9pZHMpIHtcbiAgICAgICAgLy8gVE9ETzogY3JlYXRlIERSWSBgT0lEIHRvIG1kYCBmdW5jdGlvblxuICAgICAgICB2YXIgb2lkID0gb2lkc1tjc3Iuc2lnbmF0dXJlT2lkXTtcbiAgICAgICAgc3dpdGNoKG9pZCkge1xuICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhNTEyV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSU0FTU0EtUFNTJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZGlnZXN0LiAnICtcbiAgICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnbmF0dXJlT2lkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBhbmQgZGlnZXN0IGl0XG4gICAgICB2YXIgY3JpID0gY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyB8fFxuICAgICAgICBwa2kuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGNzcik7XG4gICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNyaSk7XG4gICAgICBtZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgfVxuXG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBzY2hlbWU7XG5cbiAgICAgIHN3aXRjaChjc3Iuc2lnbmF0dXJlT2lkKSB7XG4gICAgICBjYXNlIG9pZHMuc2hhMVdpdGhSU0FFbmNyeXB0aW9uOlxuICAgICAgICAvKiB1c2UgUEtDUyMxIHYxLjUgcGFkZGluZyBzY2hlbWUgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9pZHNbJ1JTQVNTQS1QU1MnXTpcbiAgICAgICAgdmFyIGhhc2gsIG1nZjtcblxuICAgICAgICAvKiBpbml0aWFsaXplIG1nZiAqL1xuICAgICAgICBoYXNoID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgICAgZXJyb3Iub2lkID0gY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkO1xuICAgICAgICAgIGVycm9yLm5hbWUgPSBoYXNoO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgbWdmID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgaWYobWdmID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWdmW21nZl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIGVycm9yLm9pZCA9IGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgIGhhc2ggPSBvaWRzW2Nzci5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgaWYoaGFzaCA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1kW2hhc2hdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBlcnJvci5vaWQgPSBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZDtcbiAgICAgICAgICBlcnJvci5uYW1lID0gaGFzaDtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtZSA9IGZvcmdlLnBzcy5jcmVhdGUoZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCksIG1nZixcbiAgICAgICAgICBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHZlcmlmeSBzaWduYXR1cmUgb24gY3NyIHVzaW5nIGl0cyBwdWJsaWMga2V5XG4gICAgICBydmFsID0gY3NyLnB1YmxpY0tleS52ZXJpZnkoXG4gICAgICAgIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCksIGNzci5zaWduYXR1cmUsIHNjaGVtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIGNzcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDkgc3ViamVjdCBvciBpc3N1ZXIgdG8gYW4gQVNOLjEgUkROU2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgc3ViamVjdCBvciBpc3N1ZXIgKGRpc3Rpbmd1aXNoZWQgbmFtZSkuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgUkROU2VxdWVuY2UuXG4gKi9cbmZ1bmN0aW9uIF9kblRvQXNuMShvYmopIHtcbiAgLy8gY3JlYXRlIGFuIGVtcHR5IFJETlNlcXVlbmNlXG4gIHZhciBydmFsID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGl0ZXJhdGUgb3ZlciBhdHRyaWJ1dGVzXG4gIHZhciBhdHRyLCBzZXQ7XG4gIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgIC8vIHJldXNlIHRhZyBjbGFzcyBmb3IgYXR0cmlidXRlIHZhbHVlIGlmIGF2YWlsYWJsZVxuICAgIHZhciB2YWx1ZVRhZ0NsYXNzID0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORztcbiAgICBpZigndmFsdWVUYWdDbGFzcycgaW4gYXR0cikge1xuICAgICAgdmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVUYWdDbGFzcztcblxuICAgICAgaWYodmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gRklYTUU6IGhhbmRsZSBtb3JlIGVuY29kaW5nc1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgc2V0IGlzIGFuIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZSBmaXJzdFxuICAgIC8vIGNvbnRhaW5pbmcgdGhlIHR5cGUgKGFuIE9JRCkgYW5kIHNlY29uZCB0aGUgdmFsdWVcbiAgICBzZXQgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKGF0dHIudHlwZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIEF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCB2YWx1ZVRhZ0NsYXNzLCBmYWxzZSwgdmFsdWUpXG4gICAgICBdKVxuICAgIF0pO1xuICAgIHJ2YWwudmFsdWUucHVzaChzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogR2V0cyBhbGwgcHJpbnRhYmxlIGF0dHJpYnV0ZXMgKHR5cGljYWxseSBvZiBhbiBpc3N1ZXIgb3Igc3ViamVjdCkgaW4gYVxuICogc2ltcGxpZmllZCBKU09OIGZvcm1hdCBmb3IgZGlzcGxheS5cbiAqXG4gKiBAcGFyYW0gYXR0cnMgdGhlIGF0dHJpYnV0ZXMuXG4gKlxuICogQHJldHVybiB0aGUgSlNPTiBmb3IgZGlzcGxheS5cbiAqL1xuZnVuY3Rpb24gX2dldEF0dHJpYnV0ZXNBc0pzb24oYXR0cnMpIHtcbiAgdmFyIHJ2YWwgPSB7fTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZihhdHRyLnNob3J0TmFtZSAmJiAoXG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5VVEY4IHx8XG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5QUklOVEFCTEVTVFJJTkcgfHxcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLklBNVNUUklORykpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICBpZihhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KGF0dHIudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYoIShhdHRyLnNob3J0TmFtZSBpbiBydmFsKSkge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmKGZvcmdlLnV0aWwuaXNBcnJheShydmFsW2F0dHIuc2hvcnROYW1lXSkpIHtcbiAgICAgICAgcnZhbFthdHRyLnNob3J0TmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXSA9IFtydmFsW2F0dHIuc2hvcnROYW1lXSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBGaWxscyBpbiBtaXNzaW5nIGZpZWxkcyBpbiBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSBhdHRycyB0aGUgYXR0cmlidXRlcyB0byBmaWxsIG1pc3NpbmcgZmllbGRzIGluLlxuICovXG5mdW5jdGlvbiBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpIHtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcblxuICAgIC8vIHBvcHVsYXRlIG1pc3NpbmcgbmFtZVxuICAgIGlmKHR5cGVvZiBhdHRyLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZihhdHRyLnR5cGUgJiYgYXR0ci50eXBlIGluIHBraS5vaWRzKSB7XG4gICAgICAgIGF0dHIubmFtZSA9IHBraS5vaWRzW2F0dHIudHlwZV07XG4gICAgICB9IGVsc2UgaWYoYXR0ci5zaG9ydE5hbWUgJiYgYXR0ci5zaG9ydE5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gcGtpLm9pZHNbX3Nob3J0TmFtZXNbYXR0ci5zaG9ydE5hbWVdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3B1bGF0ZSBtaXNzaW5nIHR5cGUgKE9JRClcbiAgICBpZih0eXBlb2YgYXR0ci50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYoYXR0ci5uYW1lICYmIGF0dHIubmFtZSBpbiBwa2kub2lkcykge1xuICAgICAgICBhdHRyLnR5cGUgPSBwa2kub2lkc1thdHRyLm5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdBdHRyaWJ1dGUgdHlwZSBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgICBlcnJvci5hdHRyaWJ1dGUgPSBhdHRyO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3B1bGF0ZSBtaXNzaW5nIHNob3J0bmFtZVxuICAgIGlmKHR5cGVvZiBhdHRyLnNob3J0TmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmKGF0dHIubmFtZSAmJiBhdHRyLm5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgYXR0ci5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1thdHRyLm5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZXh0ZW5zaW9ucyB0byB2YWx1ZVxuICAgIGlmKGF0dHIudHlwZSA9PT0gb2lkcy5leHRlbnNpb25SZXF1ZXN0KSB7XG4gICAgICBhdHRyLnZhbHVlQ29uc3RydWN0ZWQgPSB0cnVlO1xuICAgICAgYXR0ci52YWx1ZVRhZ0NsYXNzID0gYXNuMS5UeXBlLlNFUVVFTkNFO1xuICAgICAgaWYoIWF0dHIudmFsdWUgJiYgYXR0ci5leHRlbnNpb25zKSB7XG4gICAgICAgIGF0dHIudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgYXR0ci5leHRlbnNpb25zLmxlbmd0aDsgKytlaSkge1xuICAgICAgICAgIGF0dHIudmFsdWUucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEoXG4gICAgICAgICAgICBfZmlsbE1pc3NpbmdFeHRlbnNpb25GaWVsZHMoYXR0ci5leHRlbnNpb25zW2VpXSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiBhdHRyLnZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdBdHRyaWJ1dGUgdmFsdWUgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgIGVycm9yLmF0dHJpYnV0ZSA9IGF0dHI7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGaWxscyBpbiBtaXNzaW5nIGZpZWxkcyBpbiBjZXJ0aWZpY2F0ZSBleHRlbnNpb25zLlxuICpcbiAqIEBwYXJhbSBlIHRoZSBleHRlbnNpb24uXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIFtjZXJ0XSB0aGUgY2VydGlmaWNhdGUgdGhlIGV4dGVuc2lvbnMgYXJlIGZvci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHRlbnNpb24uXG4gKi9cbmZ1bmN0aW9uIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvcHVsYXRlIG1pc3NpbmcgbmFtZVxuICBpZih0eXBlb2YgZS5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKGUuaWQgJiYgZS5pZCBpbiBwa2kub2lkcykge1xuICAgICAgZS5uYW1lID0gcGtpLm9pZHNbZS5pZF07XG4gICAgfVxuICB9XG5cbiAgLy8gcG9wdWxhdGUgbWlzc2luZyBpZFxuICBpZih0eXBlb2YgZS5pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZihlLm5hbWUgJiYgZS5uYW1lIGluIHBraS5vaWRzKSB7XG4gICAgICBlLmlkID0gcGtpLm9pZHNbZS5uYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFeHRlbnNpb24gSUQgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgIGVycm9yLmV4dGVuc2lvbiA9IGU7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBpZih0eXBlb2YgZS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBtaXNzaW5nIHZhbHVlOlxuXG4gIC8vIHZhbHVlIGlzIGEgQklUIFNUUklOR1xuICBpZihlLm5hbWUgPT09ICdrZXlVc2FnZScpIHtcbiAgICAvLyBidWlsZCBmbGFnc1xuICAgIHZhciB1bnVzZWQgPSAwO1xuICAgIHZhciBiMiA9IDB4MDA7XG4gICAgdmFyIGIzID0gMHgwMDtcbiAgICBpZihlLmRpZ2l0YWxTaWduYXR1cmUpIHtcbiAgICAgIGIyIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cbiAgICBpZihlLm5vblJlcHVkaWF0aW9uKSB7XG4gICAgICBiMiB8PSAweDQwO1xuICAgICAgdW51c2VkID0gNjtcbiAgICB9XG4gICAgaWYoZS5rZXlFbmNpcGhlcm1lbnQpIHtcbiAgICAgIGIyIHw9IDB4MjA7XG4gICAgICB1bnVzZWQgPSA1O1xuICAgIH1cbiAgICBpZihlLmRhdGFFbmNpcGhlcm1lbnQpIHtcbiAgICAgIGIyIHw9IDB4MTA7XG4gICAgICB1bnVzZWQgPSA0O1xuICAgIH1cbiAgICBpZihlLmtleUFncmVlbWVudCkge1xuICAgICAgYjIgfD0gMHgwODtcbiAgICAgIHVudXNlZCA9IDM7XG4gICAgfVxuICAgIGlmKGUua2V5Q2VydFNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MDQ7XG4gICAgICB1bnVzZWQgPSAyO1xuICAgIH1cbiAgICBpZihlLmNSTFNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MDI7XG4gICAgICB1bnVzZWQgPSAxO1xuICAgIH1cbiAgICBpZihlLmVuY2lwaGVyT25seSkge1xuICAgICAgYjIgfD0gMHgwMTtcbiAgICAgIHVudXNlZCA9IDA7XG4gICAgfVxuICAgIGlmKGUuZGVjaXBoZXJPbmx5KSB7XG4gICAgICBiMyB8PSAweDgwO1xuICAgICAgdW51c2VkID0gNztcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYml0IHN0cmluZ1xuICAgIHZhciB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodW51c2VkKTtcbiAgICBpZihiMyAhPT0gMCkge1xuICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiMikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGIzKTtcbiAgICB9IGVsc2UgaWYoYjIgIT09IDApIHtcbiAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjIpO1xuICAgIH1cbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgLy8gYmFzaWNDb25zdHJhaW50cyBpcyBhIFNFUVVFTkNFXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgIC8vIGNBIEJPT0xFQU4gZmxhZyBkZWZhdWx0cyB0byBmYWxzZVxuICAgIGlmKGUuY0EpIHtcbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CT09MRUFOLCBmYWxzZSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGKSkpO1xuICAgIH1cbiAgICBpZigncGF0aExlbkNvbnN0cmFpbnQnIGluIGUpIHtcbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoZS5wYXRoTGVuQ29uc3RyYWludCkuZ2V0Qnl0ZXMoKSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2V4dEtleVVzYWdlJykge1xuICAgIC8vIGV4dEtleVVzYWdlIGlzIGEgU0VRVUVOQ0Ugb2YgT0lEc1xuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcbiAgICBmb3IodmFyIGtleSBpbiBlKSB7XG4gICAgICBpZihlW2tleV0gIT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBrZXkgaXMgbmFtZSBpbiBPSUQgbWFwXG4gICAgICBpZihrZXkgaW4gb2lkcykge1xuICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSwgYXNuMS5vaWRUb0RlcihvaWRzW2tleV0pLmdldEJ5dGVzKCkpKTtcbiAgICAgIH0gZWxzZSBpZihrZXkuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAvLyBhc3N1bWUga2V5IGlzIGFuIE9JRFxuICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSwgYXNuMS5vaWRUb0RlcihrZXkpLmdldEJ5dGVzKCkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICduc0NlcnRUeXBlJykge1xuICAgIC8vIG5zQ2VydFR5cGUgaXMgYSBCSVQgU1RSSU5HXG4gICAgLy8gYnVpbGQgZmxhZ3NcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICB2YXIgYjIgPSAweDAwO1xuXG4gICAgaWYoZS5jbGllbnQpIHtcbiAgICAgIGIyIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cbiAgICBpZihlLnNlcnZlcikge1xuICAgICAgYjIgfD0gMHg0MDtcbiAgICAgIHVudXNlZCA9IDY7XG4gICAgfVxuICAgIGlmKGUuZW1haWwpIHtcbiAgICAgIGIyIHw9IDB4MjA7XG4gICAgICB1bnVzZWQgPSA1O1xuICAgIH1cbiAgICBpZihlLm9ianNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MTA7XG4gICAgICB1bnVzZWQgPSA0O1xuICAgIH1cbiAgICBpZihlLnJlc2VydmVkKSB7XG4gICAgICBiMiB8PSAweDA4O1xuICAgICAgdW51c2VkID0gMztcbiAgICB9XG4gICAgaWYoZS5zc2xDQSkge1xuICAgICAgYjIgfD0gMHgwNDtcbiAgICAgIHVudXNlZCA9IDI7XG4gICAgfVxuICAgIGlmKGUuZW1haWxDQSkge1xuICAgICAgYjIgfD0gMHgwMjtcbiAgICAgIHVudXNlZCA9IDE7XG4gICAgfVxuICAgIGlmKGUub2JqQ0EpIHtcbiAgICAgIGIyIHw9IDB4MDE7XG4gICAgICB1bnVzZWQgPSAwO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBiaXQgc3RyaW5nXG4gICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bnVzZWQpO1xuICAgIGlmKGIyICE9PSAwKSB7XG4gICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIyKTtcbiAgICB9XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICdzdWJqZWN0QWx0TmFtZScgfHwgZS5uYW1lID09PSAnaXNzdWVyQWx0TmFtZScpIHtcbiAgICAvLyBTWU5UQVggU0VRVUVOQ0VcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gICAgdmFyIGFsdE5hbWU7XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IGUuYWx0TmFtZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGFsdE5hbWUgPSBlLmFsdE5hbWVzW25dO1xuICAgICAgdmFyIHZhbHVlID0gYWx0TmFtZS52YWx1ZTtcbiAgICAgIC8vIGhhbmRsZSBJUFxuICAgICAgaWYoYWx0TmFtZS50eXBlID09PSA3ICYmIGFsdE5hbWUuaXApIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmJ5dGVzRnJvbUlQKGFsdE5hbWUuaXApO1xuICAgICAgICBpZih2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdFeHRlbnNpb24gXCJpcFwiIHZhbHVlIGlzIG5vdCBhIHZhbGlkIElQdjQgb3IgSVB2NiBhZGRyZXNzLicpO1xuICAgICAgICAgIGVycm9yLmV4dGVuc2lvbiA9IGU7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihhbHROYW1lLnR5cGUgPT09IDgpIHtcbiAgICAgICAgLy8gaGFuZGxlIE9JRFxuICAgICAgICBpZihhbHROYW1lLm9pZCkge1xuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcihhc24xLm9pZFRvRGVyKGFsdE5hbWUub2lkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVwcmVjYXRlZCAuLi4gY29udmVydCB2YWx1ZSB0byBPSURcbiAgICAgICAgICB2YWx1ZSA9IGFzbjEub2lkVG9EZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlLnZhbHVlLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgYWx0TmFtZS50eXBlLCBmYWxzZSxcbiAgICAgICAgdmFsdWUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICdzdWJqZWN0S2V5SWRlbnRpZmllcicgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgdmFyIHNraSA9IG9wdGlvbnMuY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCk7XG4gICAgZS5zdWJqZWN0S2V5SWRlbnRpZmllciA9IHNraS50b0hleCgpO1xuICAgIC8vIE9DVEVUU1RSSU5HIHcvZGlnZXN0XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNraS5nZXRCeXRlcygpKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2F1dGhvcml0eUtleUlkZW50aWZpZXInICYmIG9wdGlvbnMuY2VydCkge1xuICAgIC8vIFNZTlRBWCBTRVFVRU5DRVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgdmFyIHNlcSA9IGUudmFsdWUudmFsdWU7XG5cbiAgICBpZihlLmtleUlkZW50aWZpZXIpIHtcbiAgICAgIHZhciBrZXlJZGVudGlmaWVyID0gKGUua2V5SWRlbnRpZmllciA9PT0gdHJ1ZSA/XG4gICAgICAgIG9wdGlvbnMuY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKSA6XG4gICAgICAgIGUua2V5SWRlbnRpZmllcik7XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCBmYWxzZSwga2V5SWRlbnRpZmllcikpO1xuICAgIH1cblxuICAgIGlmKGUuYXV0aG9yaXR5Q2VydElzc3Vlcikge1xuICAgICAgdmFyIGF1dGhvcml0eUNlcnRJc3N1ZXIgPSBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgNCwgdHJ1ZSwgW1xuICAgICAgICAgIF9kblRvQXNuMShlLmF1dGhvcml0eUNlcnRJc3N1ZXIgPT09IHRydWUgP1xuICAgICAgICAgICAgb3B0aW9ucy5jZXJ0Lmlzc3VlciA6IGUuYXV0aG9yaXR5Q2VydElzc3VlcilcbiAgICAgICAgXSlcbiAgICAgIF07XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBhdXRob3JpdHlDZXJ0SXNzdWVyKSk7XG4gICAgfVxuXG4gICAgaWYoZS5zZXJpYWxOdW1iZXIpIHtcbiAgICAgIHZhciBzZXJpYWxOdW1iZXIgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoZS5zZXJpYWxOdW1iZXIgPT09IHRydWUgP1xuICAgICAgICBvcHRpb25zLmNlcnQuc2VyaWFsTnVtYmVyIDogZS5zZXJpYWxOdW1iZXIpO1xuICAgICAgc2VxLnB1c2goXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgZmFsc2UsIHNlcmlhbE51bWJlcikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKSB7XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcblxuICAgIC8vIENyZWF0ZSBzdWIgU0VRVUVOQ0Ugb2YgRGlzdHJpYnV0aW9uUG9pbnROYW1lXG4gICAgdmFyIHN1YlNlcSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcblxuICAgIC8vIENyZWF0ZSBmdWxsTmFtZSBDSE9JQ0VcbiAgICB2YXIgZnVsbE5hbWVHZW5lcmFsTmFtZXMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcbiAgICB2YXIgYWx0TmFtZTtcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgZS5hbHROYW1lcy5sZW5ndGg7ICsrbikge1xuICAgICAgYWx0TmFtZSA9IGUuYWx0TmFtZXNbbl07XG4gICAgICB2YXIgdmFsdWUgPSBhbHROYW1lLnZhbHVlO1xuICAgICAgLy8gaGFuZGxlIElQXG4gICAgICBpZihhbHROYW1lLnR5cGUgPT09IDcgJiYgYWx0TmFtZS5pcCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuYnl0ZXNGcm9tSVAoYWx0TmFtZS5pcCk7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4dGVuc2lvbiBcImlwXCIgdmFsdWUgaXMgbm90IGEgdmFsaWQgSVB2NCBvciBJUHY2IGFkZHJlc3MuJyk7XG4gICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGFsdE5hbWUudHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBoYW5kbGUgT0lEXG4gICAgICAgIGlmKGFsdE5hbWUub2lkKSB7XG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKGFzbjEub2lkVG9EZXIoYWx0TmFtZS5vaWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZXByZWNhdGVkIC4uLiBjb252ZXJ0IHZhbHVlIHRvIE9JRFxuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bGxOYW1lR2VuZXJhbE5hbWVzLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgYWx0TmFtZS50eXBlLCBmYWxzZSxcbiAgICAgICAgdmFsdWUpKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gdGhlIHBhcmVudCBTRVFVRU5DRVxuICAgIHN1YlNlcS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW2Z1bGxOYW1lR2VuZXJhbE5hbWVzXSkpO1xuICAgIHNlcS5wdXNoKHN1YlNlcSk7XG4gIH1cblxuICAvLyBlbnN1cmUgdmFsdWUgaGFzIGJlZW4gZGVmaW5lZCBieSBub3dcbiAgaWYodHlwZW9mIGUudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFeHRlbnNpb24gdmFsdWUgbm90IHNwZWNpZmllZC4nKTtcbiAgICBlcnJvci5leHRlbnNpb24gPSBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBvYmplY3QgdG8gQVNOLjFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2lkIFNpZ25hdHVyZSBhbGdvcml0aG0gT0lEXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBzaWduYXR1cmUgcGFyYW1ldHJzIG9iamVjdFxuICogQHJldHVybiBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIF9zaWduYXR1cmVQYXJhbWV0ZXJzVG9Bc24xKG9pZCwgcGFyYW1zKSB7XG4gIHN3aXRjaChvaWQpIHtcbiAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICBpZihwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFydHMucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgXSlcbiAgICAgIF0pKTtcbiAgICB9XG5cbiAgICBpZihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIF0pKTtcbiAgICB9XG5cbiAgICBpZihwYXJhbXMuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKHBhcmFtcy5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpKVxuICAgICAgXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBwYXJ0cyk7XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QncyBhdHRyaWJ1dGVzIHRvIGFuIEFTTi4xIHNldCBvZlxuICogQ1JJQXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0gY3NyIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBzZXQgb2YgQ1JJQXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gX0NSSUF0dHJpYnV0ZXNUb0FzbjEoY3NyKSB7XG4gIC8vIGNyZWF0ZSBhbiBlbXB0eSBjb250ZXh0LXNwZWNpZmljIGNvbnRhaW5lclxuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW10pO1xuXG4gIC8vIG5vIGF0dHJpYnV0ZXMsIHJldHVybiBlbXB0eSBjb250YWluZXJcbiAgaWYoY3NyLmF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cblxuICAvLyBlYWNoIGF0dHJpYnV0ZSBoYXMgYSBzZXF1ZW5jZSB3aXRoIGEgdHlwZSBhbmQgYSBzZXQgb2YgdmFsdWVzXG4gIHZhciBhdHRycyA9IGNzci5hdHRyaWJ1dGVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG5cbiAgICAvLyByZXVzZSB0YWcgY2xhc3MgZm9yIGF0dHJpYnV0ZSB2YWx1ZSBpZiBhdmFpbGFibGVcbiAgICB2YXIgdmFsdWVUYWdDbGFzcyA9IGFzbjEuVHlwZS5VVEY4O1xuICAgIGlmKCd2YWx1ZVRhZ0NsYXNzJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuICAgIH1cbiAgICBpZih2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgodmFsdWUpO1xuICAgIH1cbiAgICB2YXIgdmFsdWVDb25zdHJ1Y3RlZCA9IGZhbHNlO1xuICAgIGlmKCd2YWx1ZUNvbnN0cnVjdGVkJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZUNvbnN0cnVjdGVkID0gYXR0ci52YWx1ZUNvbnN0cnVjdGVkO1xuICAgIH1cbiAgICAvLyBGSVhNRTogaGFuZGxlIG1vcmUgZW5jb2RpbmdzXG5cbiAgICAvLyBjcmVhdGUgYSBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIHNldFxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIHNldCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgZmlyc3RcbiAgICAvLyBjb250YWluaW5nIHRoZSB0eXBlIChhbiBPSUQpIGFuZCBzZWNvbmQgdGhlIHZhbHVlXG4gICAgdmFyIHNlcSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIEF0dHJpYnV0ZVR5cGVcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0RlcihhdHRyLnR5cGUpLmdldEJ5dGVzKCkpLFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVQsIHRydWUsIFtcbiAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIHZhbHVlVGFnQ2xhc3MsIHZhbHVlQ29uc3RydWN0ZWQsIHZhbHVlKVxuICAgICAgXSlcbiAgICBdKTtcbiAgICBydmFsLnZhbHVlLnB1c2goc2VxKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuXG5jb25zdCBqYW5fMV8xOTUwID0gbmV3IERhdGUoJzE5NTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5jb25zdCBqYW5fMV8yMDUwID0gbmV3IERhdGUoJzIwNTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBEYXRlIG9iamVjdCB0byBBU04uMVxuICogSGFuZGxlcyB0aGUgZGlmZmVyZW50IGZvcm1hdCBiZWZvcmUgYW5kIGFmdGVyIDFzdCBKYW51YXJ5IDIwNTBcbiAqXG4gKiBAcGFyYW0gZGF0ZSBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRlLlxuICovXG4gZnVuY3Rpb24gX2RhdGVUb0FzbjEoZGF0ZSl7XG4gIGlmKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuVVRDVElNRSwgZmFsc2UsXG4gICAgICBhc24xLmRhdGVUb1V0Y1RpbWUoZGF0ZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLCBmYWxzZSxcbiAgICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGRhdGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIEFTTi4xIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBUQlNDZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmdldFRCU0NlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICB2YXIgbm90QmVmb3JlID0gX2RhdGVUb0FzbjEoY2VydC52YWxpZGl0eS5ub3RCZWZvcmUpO1xuICB2YXIgbm90QWZ0ZXIgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKTtcbiAgdmFyIHRicyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihjZXJ0LnZlcnNpb24pLmdldEJ5dGVzKCkpXG4gICAgXSksXG4gICAgLy8gc2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhjZXJ0LnNlcmlhbE51bWJlcikpLFxuICAgIC8vIHNpZ25hdHVyZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoXG4gICAgICAgIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzKVxuICAgIF0pLFxuICAgIC8vIGlzc3VlclxuICAgIF9kblRvQXNuMShjZXJ0Lmlzc3VlciksXG4gICAgLy8gdmFsaWRpdHlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBub3RCZWZvcmUsXG4gICAgICBub3RBZnRlclxuICAgIF0pLFxuICAgIC8vIHN1YmplY3RcbiAgICBfZG5Ub0FzbjEoY2VydC5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY2VydC5wdWJsaWNLZXkpXG4gIF0pO1xuXG4gIGlmKGNlcnQuaXNzdWVyLnVuaXF1ZUlkKSB7XG4gICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBpZihjZXJ0LnN1YmplY3QudW5pcXVlSWQpIHtcbiAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZFxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBpZihjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIGV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoY2VydC5leHRlbnNpb25zKSk7XG4gIH1cblxuICByZXR1cm4gdGJzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBBU04uMSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZiBhXG4gKiBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5cbiAqL1xucGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cbiAgdmFyIGNyaSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKGNzci52ZXJzaW9uKS5nZXRCeXRlcygpKSxcbiAgICAvLyBzdWJqZWN0XG4gICAgX2RuVG9Bc24xKGNzci5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY3NyLnB1YmxpY0tleSksXG4gICAgLy8gYXR0cmlidXRlc1xuICAgIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcilcbiAgXSk7XG5cbiAgcmV0dXJuIGNyaTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBEaXN0aW5ndWlzaGVkTmFtZSAoc3ViamVjdCBvciBpc3N1ZXIpIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZG4gdGhlIERpc3Rpbmd1aXNoZWROYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBEaXN0aW5ndWlzaGVkTmFtZS5cbiAqL1xucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xID0gZnVuY3Rpb24oZG4pIHtcbiAgcmV0dXJuIF9kblRvQXNuMShkbik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5djMgUlNBIGNlcnRpZmljYXRlIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlVG9Bc24xID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBwcmVmZXIgY2FjaGVkIFRCU0NlcnRpZmljYXRlIG92ZXIgZ2VuZXJhdGluZyBvbmVcbiAgdmFyIHRic0NlcnRpZmljYXRlID0gY2VydC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG5cbiAgLy8gQ2VydGlmaWNhdGVcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICAgIHRic0NlcnRpZmljYXRlLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY2VydC5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoY2VydC5zaWduYXR1cmVPaWQsIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgKyBjZXJ0LnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIFguNTA5djMgY2VydGlmaWNhdGUgZXh0ZW5zaW9ucyB0byBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbnMgaW4gQVNOLjEgZm9ybWF0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zVG9Bc24xID0gZnVuY3Rpb24oZXh0cykge1xuICAvLyBjcmVhdGUgdG9wLWxldmVsIGV4dGVuc2lvbiBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDMsIHRydWUsIFtdKTtcblxuICAvLyBjcmVhdGUgZXh0ZW5zaW9uIHNlcXVlbmNlIChzdG9yZXMgYSBzZXF1ZW5jZSBmb3IgZWFjaCBleHRlbnNpb24pXG4gIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHJ2YWwudmFsdWUucHVzaChzZXEpO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgc2VxLnZhbHVlLnB1c2gocGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xKGV4dHNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gdG8gQVNOLjEuXG4gKlxuICogQHBhcmFtIGV4dCB0aGUgZXh0ZW5zaW9uIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIGluIEFTTi4xIGZvcm1hdC5cbiAqL1xucGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGNyZWF0ZSBhIHNlcXVlbmNlIGZvciBlYWNoIGV4dGVuc2lvblxuICB2YXIgZXh0c2VxID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGV4dG5JRCAoT0lEKVxuICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgYXNuMS5vaWRUb0RlcihleHQuaWQpLmdldEJ5dGVzKCkpKTtcblxuICAvLyBjcml0aWNhbCBkZWZhdWx0cyB0byBmYWxzZVxuICBpZihleHQuY3JpdGljYWwpIHtcbiAgICAvLyBjcml0aWNhbCBCT09MRUFOIERFRkFVTFQgRkFMU0VcbiAgICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQk9PTEVBTiwgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBleHQudmFsdWU7XG4gIGlmKHR5cGVvZiBleHQudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUgaXMgYXNuLjFcbiAgICB2YWx1ZSA9IGFzbjEudG9EZXIodmFsdWUpLmdldEJ5dGVzKCk7XG4gIH1cblxuICAvLyBleHRuVmFsdWUgKE9DVEVUIFNUUklORylcbiAgZXh0c2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIGV4dHNlcTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCB0byBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBwcmVmZXIgY2FjaGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBvdmVyIGdlbmVyYXRpbmcgb25lXG4gIHZhciBjcmkgPSBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHx8XG4gICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuXG4gIC8vIENlcnRpZmljYXRlXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXG4gICAgY3JpLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY3NyLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzXG4gICAgICBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShjc3Iuc2lnbmF0dXJlT2lkLCBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBzaWduYXR1cmVcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApICsgY3NyLnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDQSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gY2VydHMgYW4gb3B0aW9uYWwgYXJyYXkgb2YgY2VydGlmaWNhdGUgb2JqZWN0cyBvciBQRU0tZm9ybWF0dGVkXG4gKiAgICAgICAgICBjZXJ0aWZpY2F0ZSBzdHJpbmdzIHRvIGFkZCB0byB0aGUgQ0Egc3RvcmUuXG4gKlxuICogQHJldHVybiB0aGUgQ0Egc3RvcmUuXG4gKi9cbnBraS5jcmVhdGVDYVN0b3JlID0gZnVuY3Rpb24oY2VydHMpIHtcbiAgLy8gY3JlYXRlIENBIHN0b3JlXG4gIHZhciBjYVN0b3JlID0ge1xuICAgIC8vIHN0b3JlZCBjZXJ0aWZpY2F0ZXNcbiAgICBjZXJ0czoge31cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY2VydGlmaWNhdGUgdGhhdCBpc3N1ZWQgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSBvciBpdHNcbiAgICogJ3BhcmVudCcuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBvciBudWxsIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cbiAgY2FTdG9yZS5nZXRJc3N1ZXIgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJ2YWwgPSBnZXRCeVN1YmplY3QoY2VydC5pc3N1ZXIpO1xuXG4gICAgLy8gc2VlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzXG4gICAgLyppZihmb3JnZS51dGlsLmlzQXJyYXkocnZhbCkpIHtcbiAgICAgIC8vIFRPRE86IHJlc29sdmUgbXVsdGlwbGUgbWF0Y2hlcyBieSBjaGVja2luZ1xuICAgICAgLy8gYXV0aG9yaXR5S2V5L3N1YmplY3RLZXkvaXNzdWVyVW5pcXVlSUQvb3RoZXIgaWRlbnRpZmllcnMsIGV0Yy5cbiAgICAgIC8vIEZJWE1FOiBvciBhbHRlcm5hdGl2ZWx5IGRvIGF1dGhvcml0eSBrZXkgbWFwcGluZ1xuICAgICAgLy8gaWYgcG9zc2libGUgKFguNTA5djEgY2VydHMgY2FuJ3Qgd29yaz8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBtdWx0aXBsZSBpc3N1ZXIgbWF0Y2hlcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH0qL1xuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0cnVzdGVkIGNlcnRpZmljYXRlIHRvIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGFkZCBhcyBhIHRydXN0ZWQgY2VydGlmaWNhdGUgKGVpdGhlciBhXG4gICAqICAgICAgICAgIHBraS5jZXJ0aWZpY2F0ZSBvYmplY3Qgb3IgYSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICovXG4gIGNhU3RvcmUuYWRkQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkgeyAgLy8gYXZvaWQgZHVwbGljYXRlIGNlcnRpZmljYXRlcyBpbiBzdG9yZVxuICAgICAgaWYoY2VydC5zdWJqZWN0Lmhhc2ggaW4gY2FTdG9yZS5jZXJ0cykge1xuICAgICAgICAvLyBzdWJqZWN0IGhhc2ggYWxyZWFkeSBleGlzdHMsIGFwcGVuZCB0byBhcnJheVxuICAgICAgICB2YXIgdG1wID0gY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkodG1wKSkge1xuICAgICAgICAgIHRtcCA9IFt0bXBdO1xuICAgICAgICB9XG4gICAgICAgIHRtcC5wdXNoKGNlcnQpO1xuICAgICAgICBjYVN0b3JlLmNlcnRzW2NlcnQuc3ViamVjdC5oYXNoXSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdID0gY2VydDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIGdpdmVuIGNlcnRpZmljYXRlIGlzIGluIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGNoZWNrIChlaXRoZXIgYSBwa2kuY2VydGlmaWNhdGUgb3IgYVxuICAgKiAgICAgICAgICBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBpbiB0aGUgc3RvcmUsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNhU3RvcmUuaGFzQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGdldEJ5U3ViamVjdChjZXJ0LnN1YmplY3QpO1xuICAgIGlmKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgbWF0Y2ggPSBbbWF0Y2hdO1xuICAgIH1cbiAgICAvLyBjb21wYXJlIERFUi1lbmNvZGluZyBvZiBjZXJ0aWZpY2F0ZXNcbiAgICB2YXIgZGVyMSA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKGNlcnQpKS5nZXRCeXRlcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGRlcjIgPSBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShtYXRjaFtpXSkpLmdldEJ5dGVzKCk7XG4gICAgICBpZihkZXIxID09PSBkZXIyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBvZiB0aGUgY2VydGlmaWNhdGVzIGtlcHQgaW4gdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUgcGtpLmNlcnRpZmljYXRlIG9iamVjdHMgaW4gdGhlIHN0b3JlLlxuICAgKi9cbiAgY2FTdG9yZS5saXN0QWxsQ2VydGlmaWNhdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNlcnRMaXN0ID0gW107XG5cbiAgICBmb3IodmFyIGhhc2ggaW4gY2FTdG9yZS5jZXJ0cykge1xuICAgICAgaWYoY2FTdG9yZS5jZXJ0cy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjYVN0b3JlLmNlcnRzW2hhc2hdO1xuICAgICAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGNlcnRMaXN0LnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlcnRMaXN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2VydGlmaWNhdGUgZnJvbSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byByZW1vdmUgKGVpdGhlciBhIHBraS5jZXJ0aWZpY2F0ZSBvciBhXG4gICAqICAgICAgICAgIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZSB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwgaWYgdGhlIGNlcnRpZmljYXRlXG4gICAqICAgICAgICAgICB3YXNuJ3QgaW4gc3RvcmUuXG4gICAqL1xuICBjYVN0b3JlLnJlbW92ZUNlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBjb252ZXJ0IGZyb20gcGVtIGlmIG5lY2Vzc2FyeVxuICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2VydCA9IGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgfVxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG4gICAgaWYoIWNhU3RvcmUuaGFzQ2VydGlmaWNhdGUoY2VydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGdldEJ5U3ViamVjdChjZXJ0LnN1YmplY3QpO1xuXG4gICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShtYXRjaCkpIHtcbiAgICAgIHJlc3VsdCA9IGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgICAgZGVsZXRlIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIERFUi1lbmNvZGluZyBvZiBjZXJ0aWZpY2F0ZXNcbiAgICB2YXIgZGVyMSA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKGNlcnQpKS5nZXRCeXRlcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGRlcjIgPSBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShtYXRjaFtpXSkpLmdldEJ5dGVzKCk7XG4gICAgICBpZihkZXIxID09PSBkZXIyKSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGNoW2ldO1xuICAgICAgICBtYXRjaC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG1hdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QnlTdWJqZWN0KHN1YmplY3QpIHtcbiAgICBlbnN1cmVTdWJqZWN0SGFzSGFzaChzdWJqZWN0KTtcbiAgICByZXR1cm4gY2FTdG9yZS5jZXJ0c1tzdWJqZWN0Lmhhc2hdIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdWJqZWN0SGFzSGFzaChzdWJqZWN0KSB7XG4gICAgLy8gcHJvZHVjZSBzdWJqZWN0IGhhc2ggaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmKCFzdWJqZWN0Lmhhc2gpIHtcbiAgICAgIHZhciBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBzdWJqZWN0LmF0dHJpYnV0ZXMgPSAgcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KF9kblRvQXNuMShzdWJqZWN0KSwgbWQpO1xuICAgICAgc3ViamVjdC5oYXNoID0gbWQuZGlnZXN0KCkudG9IZXgoKTtcbiAgICB9XG4gIH1cblxuICAvLyBhdXRvLWFkZCBwYXNzZWQgaW4gY2VydHNcbiAgaWYoY2VydHMpIHtcbiAgICAvLyBwYXJzZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlcyBhcyBuZWNlc3NhcnlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2VydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjZXJ0ID0gY2VydHNbaV07XG4gICAgICBjYVN0b3JlLmFkZENlcnRpZmljYXRlKGNlcnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYVN0b3JlO1xufTtcblxuLyoqXG4gKiBDZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24gZXJyb3JzLCBiYXNlZCBvbiBUTFMuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUVycm9yID0ge1xuICBiYWRfY2VydGlmaWNhdGU6ICdmb3JnZS5wa2kuQmFkQ2VydGlmaWNhdGUnLFxuICB1bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZTogJ2ZvcmdlLnBraS5VbnN1cHBvcnRlZENlcnRpZmljYXRlJyxcbiAgY2VydGlmaWNhdGVfcmV2b2tlZDogJ2ZvcmdlLnBraS5DZXJ0aWZpY2F0ZVJldm9rZWQnLFxuICBjZXJ0aWZpY2F0ZV9leHBpcmVkOiAnZm9yZ2UucGtpLkNlcnRpZmljYXRlRXhwaXJlZCcsXG4gIGNlcnRpZmljYXRlX3Vua25vd246ICdmb3JnZS5wa2kuQ2VydGlmaWNhdGVVbmtub3duJyxcbiAgdW5rbm93bl9jYTogJ2ZvcmdlLnBraS5Vbmtub3duQ2VydGlmaWNhdGVBdXRob3JpdHknXG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGEgY2VydGlmaWNhdGUgY2hhaW4gYWdhaW5zdCB0aGUgZ2l2ZW4gQ2VydGlmaWNhdGUgQXV0aG9yaXR5IHN0b3JlXG4gKiB3aXRoIGFuIG9wdGlvbmFsIGN1c3RvbSB2ZXJpZnkgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIGNhU3RvcmUgYSBjZXJ0aWZpY2F0ZSBzdG9yZSB0byB2ZXJpZnkgYWdhaW5zdC5cbiAqIEBwYXJhbSBjaGFpbiB0aGUgY2VydGlmaWNhdGUgY2hhaW4gdG8gdmVyaWZ5LCB3aXRoIHRoZSByb290IG9yIGhpZ2hlc3RcbiAqICAgICAgICAgIGF1dGhvcml0eSBhdCB0aGUgZW5kIChhbiBhcnJheSBvZiBjZXJ0aWZpY2F0ZXMpLlxuICogQHBhcmFtIHZlcmlmeSBjYWxsZWQgZm9yIGV2ZXJ5IGNlcnRpZmljYXRlIGluIHRoZSBjaGFpbi5cbiAqXG4gKiBUaGUgdmVyaWZ5IGNhbGxiYWNrIGhhcyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqXG4gKiB2ZXJpZmllZCAtIFNldCB0byB0cnVlIGlmIGNlcnRpZmljYXRlIHdhcyB2ZXJpZmllZCwgb3RoZXJ3aXNlIHRoZVxuICogICBwa2kuY2VydGlmaWNhdGVFcnJvciBmb3Igd2h5IHRoZSBjZXJ0aWZpY2F0ZSBmYWlsZWQuXG4gKiBkZXB0aCAtIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBjaGFpbiwgd2hlcmUgMCBpcyB0aGUgZW5kIHBvaW50J3MgY2VydC5cbiAqIGNlcnRzIC0gVGhlIGNlcnRpZmljYXRlIGNoYWluLCAqTk9URSogYW4gZW1wdHkgY2hhaW4gaW5kaWNhdGVzIGFuIGFub255bW91c1xuICogICBlbmQgcG9pbnQuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzIGFuZCBvbiBmYWlsdXJlIGVpdGhlciB0aGUgYXBwcm9wcmlhdGVcbiAqIHBraS5jZXJ0aWZpY2F0ZUVycm9yIG9yIGFuIG9iamVjdCB3aXRoICdlcnJvcicgc2V0IHRvIHRoZSBhcHByb3ByaWF0ZVxuICogcGtpLmNlcnRpZmljYXRlRXJyb3IgYW5kICdtZXNzYWdlJyBzZXQgdG8gYSBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZXJyb3IgdGhyb3duIGlmIG5vdC5cbiAqL1xucGtpLnZlcmlmeUNlcnRpZmljYXRlQ2hhaW4gPSBmdW5jdGlvbihjYVN0b3JlLCBjaGFpbiwgdmVyaWZ5KSB7XG4gIC8qIEZyb206IFJGQzMyODAgLSBJbnRlcm5ldCBYLjUwOSBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIENlcnRpZmljYXRlXG4gICAgU2VjdGlvbiA2OiBDZXJ0aWZpY2F0aW9uIFBhdGggVmFsaWRhdGlvblxuICAgIFNlZSBpbmxpbmUgcGFyZW50aGV0aWNhbHMgcmVsYXRlZCB0byB0aGlzIHBhcnRpY3VsYXIgaW1wbGVtZW50YXRpb24uXG5cbiAgICBUaGUgcHJpbWFyeSBnb2FsIG9mIHBhdGggdmFsaWRhdGlvbiBpcyB0byB2ZXJpZnkgdGhlIGJpbmRpbmcgYmV0d2VlblxuICAgIGEgc3ViamVjdCBkaXN0aW5ndWlzaGVkIG5hbWUgb3IgYSBzdWJqZWN0IGFsdGVybmF0aXZlIG5hbWUgYW5kIHN1YmplY3RcbiAgICBwdWJsaWMga2V5LCBhcyByZXByZXNlbnRlZCBpbiB0aGUgZW5kIGVudGl0eSBjZXJ0aWZpY2F0ZSwgYmFzZWQgb24gdGhlXG4gICAgcHVibGljIGtleSBvZiB0aGUgdHJ1c3QgYW5jaG9yLiBUaGlzIHJlcXVpcmVzIG9idGFpbmluZyBhIHNlcXVlbmNlIG9mXG4gICAgY2VydGlmaWNhdGVzIHRoYXQgc3VwcG9ydCB0aGF0IGJpbmRpbmcuIFRoYXQgc2VxdWVuY2Ugc2hvdWxkIGJlIHByb3ZpZGVkXG4gICAgaW4gdGhlIHBhc3NlZCAnY2hhaW4nLiBUaGUgdHJ1c3QgYW5jaG9yIHNob3VsZCBiZSBpbiB0aGUgZ2l2ZW4gQ0FcbiAgICBzdG9yZS4gVGhlICdlbmQgZW50aXR5JyBjZXJ0aWZpY2F0ZSBpcyB0aGUgY2VydGlmaWNhdGUgcHJvdmlkZWQgYnkgdGhlXG4gICAgZW5kIHBvaW50ICh0eXBpY2FsbHkgYSBzZXJ2ZXIpIGFuZCBpcyB0aGUgZmlyc3QgaW4gdGhlIGNoYWluLlxuXG4gICAgVG8gbWVldCB0aGlzIGdvYWwsIHRoZSBwYXRoIHZhbGlkYXRpb24gcHJvY2VzcyB2ZXJpZmllcywgYW1vbmcgb3RoZXJcbiAgICB0aGluZ3MsIHRoYXQgYSBwcm9zcGVjdGl2ZSBjZXJ0aWZpY2F0aW9uIHBhdGggKGEgc2VxdWVuY2Ugb2YgblxuICAgIGNlcnRpZmljYXRlcyBvciBhICdjaGFpbicpIHNhdGlzZmllcyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICAoYSkgZm9yIGFsbCB4IGluIHsxLCAuLi4sIG4tMX0sIHRoZSBzdWJqZWN0IG9mIGNlcnRpZmljYXRlIHggaXNcbiAgICAgICAgICB0aGUgaXNzdWVyIG9mIGNlcnRpZmljYXRlIHgrMTtcblxuICAgIChiKSBjZXJ0aWZpY2F0ZSAxIGlzIGlzc3VlZCBieSB0aGUgdHJ1c3QgYW5jaG9yO1xuXG4gICAgKGMpIGNlcnRpZmljYXRlIG4gaXMgdGhlIGNlcnRpZmljYXRlIHRvIGJlIHZhbGlkYXRlZDsgYW5kXG5cbiAgICAoZCkgZm9yIGFsbCB4IGluIHsxLCAuLi4sIG59LCB0aGUgY2VydGlmaWNhdGUgd2FzIHZhbGlkIGF0IHRoZVxuICAgICAgICAgIHRpbWUgaW4gcXVlc3Rpb24uXG5cbiAgICBOb3RlIHRoYXQgaGVyZSAnbicgaXMgaW5kZXggMCBpbiB0aGUgY2hhaW4gYW5kIDEgaXMgdGhlIGxhc3QgY2VydGlmaWNhdGVcbiAgICBpbiB0aGUgY2hhaW4gYW5kIGl0IG11c3QgYmUgc2lnbmVkIGJ5IGEgY2VydGlmaWNhdGUgaW4gdGhlIGNvbm5lY3Rpb24nc1xuICAgIENBIHN0b3JlLlxuXG4gICAgVGhlIHBhdGggdmFsaWRhdGlvbiBwcm9jZXNzIGFsc28gZGV0ZXJtaW5lcyB0aGUgc2V0IG9mIGNlcnRpZmljYXRlXG4gICAgcG9saWNpZXMgdGhhdCBhcmUgdmFsaWQgZm9yIHRoaXMgcGF0aCwgYmFzZWQgb24gdGhlIGNlcnRpZmljYXRlIHBvbGljaWVzXG4gICAgZXh0ZW5zaW9uLCBwb2xpY3kgbWFwcGluZyBleHRlbnNpb24sIHBvbGljeSBjb25zdHJhaW50cyBleHRlbnNpb24sIGFuZFxuICAgIGluaGliaXQgYW55LXBvbGljeSBleHRlbnNpb24uXG5cbiAgICBOb3RlOiBQb2xpY3kgbWFwcGluZyBleHRlbnNpb24gbm90IHN1cHBvcnRlZCAoTm90IFJlcXVpcmVkKS5cblxuICAgIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0ZSBoYXMgYW4gdW5zdXBwb3J0ZWQgY3JpdGljYWwgZXh0ZW5zaW9uLCB0aGVuIGl0XG4gICAgbXVzdCBiZSByZWplY3RlZC5cblxuICAgIE5vdGU6IEEgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgaWYgdGhlIEROcyB0aGF0IGFwcGVhciBpbiB0aGUgc3ViamVjdFxuICAgIGFuZCBpc3N1ZXIgZmllbGRzIGFyZSBpZGVudGljYWwgYW5kIGFyZSBub3QgZW1wdHkuXG5cbiAgICBUaGUgcGF0aCB2YWxpZGF0aW9uIGFsZ29yaXRobSBhc3N1bWVzIHRoZSBmb2xsb3dpbmcgc2V2ZW4gaW5wdXRzIGFyZVxuICAgIHByb3ZpZGVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmcgbG9naWMuIFdoYXQgdGhpcyBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuICAgIHdpbGwgdXNlIGlzIHByb3ZpZGVkIHBhcmVudGhldGljYWxseTpcblxuICAgIChhKSBhIHByb3NwZWN0aXZlIGNlcnRpZmljYXRpb24gcGF0aCBvZiBsZW5ndGggbiAodGhlICdjaGFpbicpXG4gICAgKGIpIHRoZSBjdXJyZW50IGRhdGUvdGltZTogKCdub3cnKS5cbiAgICAoYykgdXNlci1pbml0aWFsLXBvbGljeS1zZXQ6IEEgc2V0IG9mIGNlcnRpZmljYXRlIHBvbGljeSBpZGVudGlmaWVyc1xuICAgICAgICAgIG5hbWluZyB0aGUgcG9saWNpZXMgdGhhdCBhcmUgYWNjZXB0YWJsZSB0byB0aGUgY2VydGlmaWNhdGUgdXNlci5cbiAgICAgICAgICBUaGUgdXNlci1pbml0aWFsLXBvbGljeS1zZXQgY29udGFpbnMgdGhlIHNwZWNpYWwgdmFsdWUgYW55LXBvbGljeVxuICAgICAgICAgIGlmIHRoZSB1c2VyIGlzIG5vdCBjb25jZXJuZWQgYWJvdXQgY2VydGlmaWNhdGUgcG9saWN5XG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZC4gQW55IHBvbGljeSBpcyBhY2NlcHRlZCkuXG4gICAgKGQpIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvbiwgZGVzY3JpYmluZyBhIENBIHRoYXQgc2VydmVzIGFzIGEgdHJ1c3RcbiAgICAgICAgICBhbmNob3IgZm9yIHRoZSBjZXJ0aWZpY2F0aW9uIHBhdGguIFRoZSB0cnVzdCBhbmNob3IgaW5mb3JtYXRpb25cbiAgICAgICAgICBpbmNsdWRlczpcblxuICAgICAgKDEpICB0aGUgdHJ1c3RlZCBpc3N1ZXIgbmFtZSxcbiAgICAgICgyKSAgdGhlIHRydXN0ZWQgcHVibGljIGtleSBhbGdvcml0aG0sXG4gICAgICAoMykgIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXksIGFuZFxuICAgICAgKDQpICBvcHRpb25hbGx5LCB0aGUgdHJ1c3RlZCBwdWJsaWMga2V5IHBhcmFtZXRlcnMgYXNzb2NpYXRlZFxuICAgICAgICAgICAgIHdpdGggdGhlIHB1YmxpYyBrZXkuXG5cbiAgICAgIChUcnVzdCBhbmNob3JzIGFyZSBwcm92aWRlZCB2aWEgY2VydGlmaWNhdGVzIGluIHRoZSBDQSBzdG9yZSkuXG5cbiAgICAgIFRoZSB0cnVzdCBhbmNob3IgaW5mb3JtYXRpb24gbWF5IGJlIHByb3ZpZGVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmdcbiAgICAgIHByb2NlZHVyZSBpbiB0aGUgZm9ybSBvZiBhIHNlbGYtc2lnbmVkIGNlcnRpZmljYXRlLiBUaGUgdHJ1c3RlZCBhbmNob3JcbiAgICAgIGluZm9ybWF0aW9uIGlzIHRydXN0ZWQgYmVjYXVzZSBpdCB3YXMgZGVsaXZlcmVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmdcbiAgICAgIHByb2NlZHVyZSBieSBzb21lIHRydXN0d29ydGh5IG91dC1vZi1iYW5kIHByb2NlZHVyZS4gSWYgdGhlIHRydXN0ZWRcbiAgICAgIHB1YmxpYyBrZXkgYWxnb3JpdGhtIHJlcXVpcmVzIHBhcmFtZXRlcnMsIHRoZW4gdGhlIHBhcmFtZXRlcnMgYXJlXG4gICAgICBwcm92aWRlZCBhbG9uZyB3aXRoIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXkgKE5vIHBhcmFtZXRlcnMgdXNlZCBpbiB0aGlzXG4gICAgICBpbXBsZW1lbnRhdGlvbikuXG5cbiAgICAoZSkgaW5pdGlhbC1wb2xpY3ktbWFwcGluZy1pbmhpYml0LCB3aGljaCBpbmRpY2F0ZXMgaWYgcG9saWN5IG1hcHBpbmcgaXNcbiAgICAgICAgICBhbGxvd2VkIGluIHRoZSBjZXJ0aWZpY2F0aW9uIHBhdGguXG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZCwgbm8gcG9saWN5IGNoZWNraW5nKVxuXG4gICAgKGYpIGluaXRpYWwtZXhwbGljaXQtcG9saWN5LCB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIHBhdGggbXVzdCBiZSB2YWxpZFxuICAgICAgICAgIGZvciBhdCBsZWFzdCBvbmUgb2YgdGhlIGNlcnRpZmljYXRlIHBvbGljaWVzIGluIHRoZSB1c2VyLWluaXRpYWwtXG4gICAgICAgICAgcG9saWN5LXNldC5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBubyBwb2xpY3kgY2hlY2tpbmcpXG5cbiAgICAoZykgaW5pdGlhbC1hbnktcG9saWN5LWluaGliaXQsIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIHRoZVxuICAgICAgICAgIGFueVBvbGljeSBPSUQgc2hvdWxkIGJlIHByb2Nlc3NlZCBpZiBpdCBpcyBpbmNsdWRlZCBpbiBhXG4gICAgICAgICAgY2VydGlmaWNhdGUuXG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZCwgc28gYW55IHBvbGljeSBpcyB2YWxpZCBwcm92aWRlZCB0aGF0IGl0IGlzXG4gICAgICAgICAgbm90IG1hcmtlZCBhcyBjcml0aWNhbCkgKi9cblxuICAvKiBCYXNpYyBQYXRoIFByb2Nlc3Npbmc6XG5cbiAgICBGb3IgZWFjaCBjZXJ0aWZpY2F0ZSBpbiB0aGUgJ2NoYWluJywgdGhlIGZvbGxvd2luZyBpcyBjaGVja2VkOlxuXG4gICAgMS4gVGhlIGNlcnRpZmljYXRlIHZhbGlkaXR5IHBlcmlvZCBpbmNsdWRlcyB0aGUgY3VycmVudCB0aW1lLlxuICAgIDIuIFRoZSBjZXJ0aWZpY2F0ZSB3YXMgc2lnbmVkIGJ5IGl0cyBwYXJlbnQgKHdoZXJlIHRoZSBwYXJlbnQgaXMgZWl0aGVyXG4gICAgICAgdGhlIG5leHQgaW4gdGhlIGNoYWluIG9yIGZyb20gdGhlIENBIHN0b3JlKS4gQWxsb3cgcHJvY2Vzc2luZyB0b1xuICAgICAgIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHN0ZXAgaWYgbm8gcGFyZW50IGlzIGZvdW5kIGJ1dCB0aGUgY2VydGlmaWNhdGUgaXNcbiAgICAgICBpbiB0aGUgQ0Egc3RvcmUuXG4gICAgMy4gVE9ETzogVGhlIGNlcnRpZmljYXRlIGhhcyBub3QgYmVlbiByZXZva2VkLlxuICAgIDQuIFRoZSBjZXJ0aWZpY2F0ZSBpc3N1ZXIgbmFtZSBtYXRjaGVzIHRoZSBwYXJlbnQncyBzdWJqZWN0IG5hbWUuXG4gICAgNS4gVE9ETzogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHNlbGYtaXNzdWVkIGFuZCBub3QgdGhlIGZpbmFsIGNlcnRpZmljYXRlXG4gICAgICAgaW4gdGhlIGNoYWluLCBza2lwIHRoaXMgc3RlcCwgb3RoZXJ3aXNlIHZlcmlmeSB0aGF0IHRoZSBzdWJqZWN0IG5hbWVcbiAgICAgICBpcyB3aXRoaW4gb25lIG9mIHRoZSBwZXJtaXR0ZWQgc3VidHJlZXMgb2YgWC41MDAgZGlzdGluZ3Vpc2hlZCBuYW1lc1xuICAgICAgIGFuZCB0aGF0IGVhY2ggb2YgdGhlIGFsdGVybmF0aXZlIG5hbWVzIGluIHRoZSBzdWJqZWN0QWx0TmFtZSBleHRlbnNpb25cbiAgICAgICAoY3JpdGljYWwgb3Igbm9uLWNyaXRpY2FsKSBpcyB3aXRoaW4gb25lIG9mIHRoZSBwZXJtaXR0ZWQgc3VidHJlZXMgZm9yXG4gICAgICAgdGhhdCBuYW1lIHR5cGUuXG4gICAgNi4gVE9ETzogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHNlbGYtaXNzdWVkIGFuZCBub3QgdGhlIGZpbmFsIGNlcnRpZmljYXRlXG4gICAgICAgaW4gdGhlIGNoYWluLCBza2lwIHRoaXMgc3RlcCwgb3RoZXJ3aXNlIHZlcmlmeSB0aGF0IHRoZSBzdWJqZWN0IG5hbWVcbiAgICAgICBpcyBub3Qgd2l0aGluIG9uZSBvZiB0aGUgZXhjbHVkZWQgc3VidHJlZXMgZm9yIFguNTAwIGRpc3Rpbmd1aXNoZWRcbiAgICAgICBuYW1lcyBhbmQgbm9uZSBvZiB0aGUgc3ViamVjdEFsdE5hbWUgZXh0ZW5zaW9uIG5hbWVzIGFyZSBleGNsdWRlZCBmb3JcbiAgICAgICB0aGF0IG5hbWUgdHlwZS5cbiAgICA3LiBUaGUgb3RoZXIgc3RlcHMgaW4gdGhlIGFsZ29yaXRobSBmb3IgYmFzaWMgcGF0aCBwcm9jZXNzaW5nIGludm9sdmVcbiAgICAgICBoYW5kbGluZyB0aGUgcG9saWN5IGV4dGVuc2lvbiB3aGljaCBpcyBub3QgcHJlc2VudGx5IHN1cHBvcnRlZCBpbiB0aGlzXG4gICAgICAgaW1wbGVtZW50YXRpb24uIEluc3RlYWQsIGlmIGEgY3JpdGljYWwgcG9saWN5IGV4dGVuc2lvbiBpcyBmb3VuZCwgdGhlXG4gICAgICAgY2VydGlmaWNhdGUgaXMgcmVqZWN0ZWQgYXMgbm90IHN1cHBvcnRlZC5cbiAgICA4LiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgbm90IHRoZSBmaXJzdCBvciBpZiBpdHMgdGhlIG9ubHkgY2VydGlmaWNhdGUgaW5cbiAgICAgICB0aGUgY2hhaW4gKGhhdmluZyBubyBwYXJlbnQgZnJvbSB0aGUgQ0Egc3RvcmUgb3IgaXMgc2VsZi1zaWduZWQpIGFuZCBpdFxuICAgICAgIGhhcyBhIGNyaXRpY2FsIGtleSB1c2FnZSBleHRlbnNpb24sIHZlcmlmeSB0aGF0IHRoZSBrZXlDZXJ0U2lnbiBiaXQgaXNcbiAgICAgICBzZXQuIElmIHRoZSBrZXkgdXNhZ2UgZXh0ZW5zaW9uIGV4aXN0cywgdmVyaWZ5IHRoYXQgdGhlIGJhc2ljXG4gICAgICAgY29uc3RyYWludHMgZXh0ZW5zaW9uIGV4aXN0cy4gSWYgdGhlIGJhc2ljIGNvbnN0cmFpbnRzIGV4dGVuc2lvbiBleGlzdHMsXG4gICAgICAgdmVyaWZ5IHRoYXQgdGhlIGNBIGZsYWcgaXMgc2V0LiBJZiBwYXRoTGVuQ29uc3RyYWludCBpcyBzZXQsIGVuc3VyZSB0aGF0XG4gICAgICAgdGhlIG51bWJlciBvZiBjZXJ0aWZpY2F0ZXMgdGhhdCBwcmVjZWRlIGluIHRoZSBjaGFpbiAoY29tZSBlYXJsaWVyXG4gICAgICAgaW4gdGhlIGNoYWluIGFzIGltcGxlbWVudGVkIGJlbG93KSwgZXhjbHVkaW5nIHRoZSB2ZXJ5IGZpcnN0IGluIHRoZVxuICAgICAgIGNoYWluICh0eXBpY2FsbHkgdGhlIGVuZC1lbnRpdHkgb25lKSwgaXNuJ3QgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAgIHBhdGhMZW5Db25zdHJhaW50LiBUaGlzIGNvbnN0cmFpbnQgbGltaXRzIHRoZSBudW1iZXIgb2YgaW50ZXJtZWRpYXRlXG4gICAgICAgQ0FzIHRoYXQgbWF5IGFwcGVhciBiZWxvdyBhIENBIGJlZm9yZSBvbmx5IGVuZC1lbnRpdHkgY2VydGlmaWNhdGVzXG4gICAgICAgbWF5IGJlIGlzc3VlZC4gKi9cblxuICAvLyBjb3B5IGNlcnQgY2hhaW4gcmVmZXJlbmNlcyB0byBhbm90aGVyIGFycmF5IHRvIHByb3RlY3QgYWdhaW5zdCBjaGFuZ2VzXG4gIC8vIGluIHZlcmlmeSBjYWxsYmFja1xuICBjaGFpbiA9IGNoYWluLnNsaWNlKDApO1xuICB2YXIgY2VydHMgPSBjaGFpbi5zbGljZSgwKTtcblxuICAvLyBnZXQgY3VycmVudCBkYXRlXG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIC8vIHZlcmlmeSBlYWNoIGNlcnQgaW4gdGhlIGNoYWluIHVzaW5nIGl0cyBwYXJlbnQsIHdoZXJlIHRoZSBwYXJlbnRcbiAgLy8gaXMgZWl0aGVyIHRoZSBuZXh0IGluIHRoZSBjaGFpbiBvciBmcm9tIHRoZSBDQSBzdG9yZVxuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuICB2YXIgZGVwdGggPSAwO1xuICBkbyB7XG4gICAgdmFyIGNlcnQgPSBjaGFpbi5zaGlmdCgpO1xuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBzZWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICAvLyAxLiBjaGVjayB2YWxpZCB0aW1lXG4gICAgaWYobm93IDwgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgfHwgbm93ID4gY2VydC52YWxpZGl0eS5ub3RBZnRlcikge1xuICAgICAgZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdmFsaWQgeWV0IG9yIGhhcyBleHBpcmVkLicsXG4gICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5jZXJ0aWZpY2F0ZV9leHBpcmVkLFxuICAgICAgICBub3RCZWZvcmU6IGNlcnQudmFsaWRpdHkubm90QmVmb3JlLFxuICAgICAgICBub3RBZnRlcjogY2VydC52YWxpZGl0eS5ub3RBZnRlcixcbiAgICAgICAgbm93OiBub3dcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMi4gdmVyaWZ5IHdpdGggcGFyZW50IGZyb20gY2hhaW4gb3IgQ0Egc3RvcmVcbiAgICBpZihlcnJvciA9PT0gbnVsbCkge1xuICAgICAgcGFyZW50ID0gY2hhaW5bMF0gfHwgY2FTdG9yZS5nZXRJc3N1ZXIoY2VydCk7XG4gICAgICBpZihwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHNlbGYtc2lnbmVkIGNlcnRcbiAgICAgICAgaWYoY2VydC5pc0lzc3VlcihjZXJ0KSkge1xuICAgICAgICAgIHNlbGZTaWduZWQgPSB0cnVlO1xuICAgICAgICAgIHBhcmVudCA9IGNlcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocGFyZW50KSB7XG4gICAgICAgIC8vIEZJWE1FOiBjdXJyZW50IENBIHN0b3JlIGltcGxlbWVudGF0aW9uIG1pZ2h0IGhhdmUgbXVsdGlwbGVcbiAgICAgICAgLy8gY2VydGlmaWNhdGVzIHdoZXJlIHRoZSBpc3N1ZXIgY2FuJ3QgYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZVxuICAgICAgICAvLyBjZXJ0aWZpY2F0ZSAoaGFwcGVucyByYXJlbHkgd2l0aCwgZWc6IG9sZCBjZXJ0aWZpY2F0ZXMpIHNvIG5vcm1hbGl6ZVxuICAgICAgICAvLyBieSBhbHdheXMgcHV0dGluZyBwYXJlbnRzIGludG8gYW4gYXJyYXlcbiAgICAgICAgLy8gVE9ETzogdGhlcmUncyBtYXkgYmUgYW4gZXh0cmVtZSBkZWdlbmVyYXRlIGNhc2UgY3VycmVudGx5IHVuY292ZXJlZFxuICAgICAgICAvLyB3aGVyZSBhbiBvbGQgaW50ZXJtZWRpYXRlIGNlcnRpZmljYXRlIHNlZW1zIHRvIGhhdmUgYSBtYXRjaGluZyBwYXJlbnRcbiAgICAgICAgLy8gYnV0IG5vbmUgb2YgdGhlIHBhcmVudHMgYWN0dWFsbHkgdmVyaWZ5IC4uLiBidXQgdGhlIGludGVybWVkaWF0ZVxuICAgICAgICAvLyBpcyBpbiB0aGUgQ0EgYW5kIGl0IHNob3VsZCBwYXNzIHRoaXMgY2hlY2s7IG5lZWRzIGludmVzdGlnYXRpb25cbiAgICAgICAgdmFyIHBhcmVudHMgPSBwYXJlbnQ7XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkocGFyZW50cykpIHtcbiAgICAgICAgICBwYXJlbnRzID0gW3BhcmVudHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHZlcmlmeSB3aXRoIGVhY2ggcG9zc2libGUgcGFyZW50ICh0eXBpY2FsbHkgb25seSBvbmUpXG4gICAgICAgIHZhciB2ZXJpZmllZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSghdmVyaWZpZWQgJiYgcGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50cy5zaGlmdCgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2ZXJpZmllZCA9IHBhcmVudC52ZXJpZnkoY2VydCk7XG4gICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgLy8gZmFpbHVyZSB0byB2ZXJpZnksIGRvbid0IGNhcmUgd2h5LCB0cnkgbmV4dCBvbmVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZighdmVyaWZpZWQpIHtcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBzaWduYXR1cmUgaXMgaW52YWxpZC4nLFxuICAgICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYgKCFwYXJlbnQgfHwgc2VsZlNpZ25lZCkgJiZcbiAgICAgICAgIWNhU3RvcmUuaGFzQ2VydGlmaWNhdGUoY2VydCkpIHtcbiAgICAgICAgLy8gbm8gcGFyZW50IGlzc3VlciBhbmQgY2VydGlmaWNhdGUgaXRzZWxmIGlzIG5vdCB0cnVzdGVkXG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdHJ1c3RlZC4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci51bmtub3duX2NhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogMy4gY2hlY2sgcmV2b2tlZFxuXG4gICAgLy8gNC4gY2hlY2sgZm9yIG1hdGNoaW5nIGlzc3Vlci9zdWJqZWN0XG4gICAgaWYoZXJyb3IgPT09IG51bGwgJiYgcGFyZW50ICYmICFjZXJ0LmlzSXNzdWVyKHBhcmVudCkpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBub3QgaXNzdWVyXG4gICAgICBlcnJvciA9IHtcbiAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIGlzc3VlciBpcyBpbnZhbGlkLicsXG4gICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNS4gVE9ETzogY2hlY2sgbmFtZXMgd2l0aCBwZXJtaXR0ZWQgbmFtZXMgdHJlZVxuXG4gICAgLy8gNi4gVE9ETzogY2hlY2sgbmFtZXMgYWdhaW5zdCBleGNsdWRlZCBuYW1lcyB0cmVlXG5cbiAgICAvLyA3LiBjaGVjayBmb3IgdW5zdXBwb3J0ZWQgY3JpdGljYWwgZXh0ZW5zaW9uc1xuICAgIGlmKGVycm9yID09PSBudWxsKSB7XG4gICAgICAvLyBzdXBwb3J0ZWQgZXh0ZW5zaW9uc1xuICAgICAgdmFyIHNlID0ge1xuICAgICAgICBrZXlVc2FnZTogdHJ1ZSxcbiAgICAgICAgYmFzaWNDb25zdHJhaW50czogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGVycm9yID09PSBudWxsICYmIGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGV4dCA9IGNlcnQuZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgaWYoZXh0LmNyaXRpY2FsICYmICEoZXh0Lm5hbWUgaW4gc2UpKSB7XG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnQ2VydGlmaWNhdGUgaGFzIGFuIHVuc3VwcG9ydGVkIGNyaXRpY2FsIGV4dGVuc2lvbi4nLFxuICAgICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDguIGNoZWNrIGZvciBDQSBpZiBjZXJ0IGlzIG5vdCBmaXJzdCBvciBpcyB0aGUgb25seSBjZXJ0aWZpY2F0ZVxuICAgIC8vIHJlbWFpbmluZyBpbiBjaGFpbiB3aXRoIG5vIHBhcmVudCBvciBpcyBzZWxmLXNpZ25lZFxuICAgIGlmKGVycm9yID09PSBudWxsICYmXG4gICAgICAoIWZpcnN0IHx8IChjaGFpbi5sZW5ndGggPT09IDAgJiYgKCFwYXJlbnQgfHwgc2VsZlNpZ25lZCkpKSkge1xuICAgICAgLy8gZmlyc3QgY2hlY2sga2V5VXNhZ2UgZXh0ZW5zaW9uIGFuZCB0aGVuIGJhc2ljIGNvbnN0cmFpbnRzXG4gICAgICB2YXIgYmNFeHQgPSBjZXJ0LmdldEV4dGVuc2lvbignYmFzaWNDb25zdHJhaW50cycpO1xuICAgICAgdmFyIGtleVVzYWdlRXh0ID0gY2VydC5nZXRFeHRlbnNpb24oJ2tleVVzYWdlJyk7XG4gICAgICBpZihrZXlVc2FnZUV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBrZXlDZXJ0U2lnbiBtdXN0IGJlIHRydWUgYW5kIHRoZXJlIG11c3QgYmUgYSBiYXNpY1xuICAgICAgICAvLyBjb25zdHJhaW50cyBleHRlbnNpb25cbiAgICAgICAgaWYoIWtleVVzYWdlRXh0LmtleUNlcnRTaWduIHx8IGJjRXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gYmFkIGNlcnRpZmljYXRlXG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnQ2VydGlmaWNhdGUga2V5VXNhZ2Ugb3IgYmFzaWNDb25zdHJhaW50cyBjb25mbGljdCAnICtcbiAgICAgICAgICAgICAgJ29yIGluZGljYXRlIHRoYXQgdGhlIGNlcnRpZmljYXRlIGlzIG5vdCBhIENBLiAnICtcbiAgICAgICAgICAgICAgJ0lmIHRoZSBjZXJ0aWZpY2F0ZSBpcyB0aGUgb25seSBvbmUgaW4gdGhlIGNoYWluIG9yICcgK1xuICAgICAgICAgICAgICAnaXNuXFwndCB0aGUgZmlyc3QgdGhlbiB0aGUgY2VydGlmaWNhdGUgbXVzdCBiZSBhICcgK1xuICAgICAgICAgICAgICAndmFsaWQgQ0EuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBiYXNpYyBjb25zdHJhaW50cyBjQSBmbGFnIG11c3QgYmUgc2V0XG4gICAgICBpZihlcnJvciA9PT0gbnVsbCAmJiBiY0V4dCAhPT0gbnVsbCAmJiAhYmNFeHQuY0EpIHtcbiAgICAgICAgLy8gYmFkIGNlcnRpZmljYXRlXG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAnQ2VydGlmaWNhdGUgYmFzaWNDb25zdHJhaW50cyBpbmRpY2F0ZXMgdGhlIGNlcnRpZmljYXRlICcgK1xuICAgICAgICAgICAgJ2lzIG5vdCBhIENBLicsXG4gICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gaWYgZXJyb3IgaXMgbm90IG51bGwgYW5kIGtleVVzYWdlIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBrbm93IGl0XG4gICAgICAvLyBoYXMga2V5Q2VydFNpZ24gYW5kIHRoZXJlIGlzIGEgYmFzaWMgY29uc3RyYWludHMgZXh0ZW5zaW9uIHRvbyxcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHdlIGNhbiBjaGVjayBwYXRoTGVuQ29uc3RyYWludCAoaWYgaXQgZXhpc3RzKVxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYga2V5VXNhZ2VFeHQgIT09IG51bGwgJiZcbiAgICAgICAgJ3BhdGhMZW5Db25zdHJhaW50JyBpbiBiY0V4dCkge1xuICAgICAgICAvLyBwYXRoTGVuIGlzIHRoZSBtYXhpbXVtICMgb2YgaW50ZXJtZWRpYXRlIENBIGNlcnRzIHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGZvdW5kIGJldHdlZW4gdGhlIGN1cnJlbnQgY2VydGlmaWNhdGUgYW5kIHRoZSBlbmQtZW50aXR5IChkZXB0aCAwKVxuICAgICAgICAvLyBjZXJ0aWZpY2F0ZTsgdGhpcyBudW1iZXIgZG9lcyBub3QgaW5jbHVkZSB0aGUgZW5kLWVudGl0eSAoZGVwdGggMCxcbiAgICAgICAgLy8gbGFzdCBpbiB0aGUgY2hhaW4pIGV2ZW4gaWYgaXQgaGFwcGVucyB0byBiZSBhIENBIGNlcnRpZmljYXRlIGl0c2VsZlxuICAgICAgICB2YXIgcGF0aExlbiA9IGRlcHRoIC0gMTtcbiAgICAgICAgaWYocGF0aExlbiA+IGJjRXh0LnBhdGhMZW5Db25zdHJhaW50KSB7XG4gICAgICAgICAgLy8gcGF0aExlbkNvbnN0cmFpbnQgdmlvbGF0ZWQsIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGJhc2ljQ29uc3RyYWludHMgcGF0aExlbkNvbnN0cmFpbnQgdmlvbGF0ZWQuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsbCBhcHBsaWNhdGlvbiBjYWxsYmFja1xuICAgIHZhciB2ZmQgPSAoZXJyb3IgPT09IG51bGwpID8gdHJ1ZSA6IGVycm9yLmVycm9yO1xuICAgIHZhciByZXQgPSB2ZXJpZnkgPyB2ZXJpZnkodmZkLCBkZXB0aCwgY2VydHMpIDogdmZkO1xuICAgIGlmKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gY2xlYXIgYW55IHNldCBlcnJvclxuICAgICAgZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBwYXNzZWQgYmFzaWMgdGVzdHMsIHNldCBkZWZhdWx0IG1lc3NhZ2UgYW5kIGFsZXJ0XG4gICAgICBpZih2ZmQgPT09IHRydWUpIHtcbiAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgbWVzc2FnZTogJ1RoZSBhcHBsaWNhdGlvbiByZWplY3RlZCB0aGUgY2VydGlmaWNhdGUuJyxcbiAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBjdXN0b20gZXJyb3IgaW5mb1xuICAgICAgaWYocmV0IHx8IHJldCA9PT0gMCkge1xuICAgICAgICAvLyBzZXQgY3VzdG9tIG1lc3NhZ2UgYW5kIGVycm9yXG4gICAgICAgIGlmKHR5cGVvZiByZXQgPT09ICdvYmplY3QnICYmICFmb3JnZS51dGlsLmlzQXJyYXkocmV0KSkge1xuICAgICAgICAgIGlmKHJldC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IHJldC5tZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmVycm9yID0gcmV0LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gc2V0IGN1c3RvbSBlcnJvclxuICAgICAgICAgIGVycm9yLmVycm9yID0gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBubyBsb25nZXIgZmlyc3QgY2VydCBpbiBjaGFpblxuICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgKytkZXB0aDtcbiAgfSB3aGlsZShjaGFpbi5sZW5ndGggPiAwKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgUEtDUyMxIFBTUyBzaWduYXR1cmUgcGFkZGluZy5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIHNob3J0Y3V0IGZvciBQU1MgQVBJXG52YXIgcHNzID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wc3MgPSBmb3JnZS5wc3MgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIFBTUyBzaWduYXR1cmUgc2NoZW1lIG9iamVjdC5cbiAqXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCB3YXlzIHRvIHByb3ZpZGUgYSBzYWx0IGZvciBlbmNvZGluZzpcbiAqXG4gKiAxLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIG9ubHkgYW5kIHRoZSBidWlsdC1pbiBQUk5HIHdpbGwgZ2VuZXJhdGUgaXQuXG4gKiAyLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIGFuZCBhIGN1c3RvbSBQUk5HIHdpdGggJ2dldEJ5dGVzU3luYycgZGVmaW5lZCB0aGF0XG4gKiAgIHdpbGwgYmUgdXNlZC5cbiAqIDMuIFNwZWNpZnkgdGhlIHNhbHQgaXRzZWxmIGFzIGEgZm9yZ2UudXRpbC5CeXRlQnVmZmVyLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLCBhIGZvcmdlIG1kIGluc3RhbmNlLlxuICogICAgICAgICAgbWdmIHRoZSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gdG8gdXNlLCBhIGZvcmdlIG1nZiBpbnN0YW5jZS5cbiAqICAgICAgICAgIFtzYWx0TGVuZ3RoXSB0aGUgbGVuZ3RoIG9mIHRoZSBzYWx0IGluIG9jdGV0cy5cbiAqICAgICAgICAgIFtwcm5nXSB0aGUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSB0byBwcm9kdWNlIGEgc2FsdC5cbiAqICAgICAgICAgIFtzYWx0XSB0aGUgc2FsdCB0byB1c2Ugd2hlbiBlbmNvZGluZy5cbiAqXG4gKiBAcmV0dXJuIGEgc2lnbmF0dXJlIHNjaGVtZSBvYmplY3QuXG4gKi9cbnBzcy5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHcvbGVnYWN5IGFyZ3M6IGhhc2gsIG1nZiwgc0xlblxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1kOiBhcmd1bWVudHNbMF0sXG4gICAgICBtZ2Y6IGFyZ3VtZW50c1sxXSxcbiAgICAgIHNhbHRMZW5ndGg6IGFyZ3VtZW50c1syXVxuICAgIH07XG4gIH1cblxuICB2YXIgaGFzaCA9IG9wdGlvbnMubWQ7XG4gIHZhciBtZ2YgPSBvcHRpb25zLm1nZjtcbiAgdmFyIGhMZW4gPSBoYXNoLmRpZ2VzdExlbmd0aDtcblxuICB2YXIgc2FsdF8gPSBvcHRpb25zLnNhbHQgfHwgbnVsbDtcbiAgaWYodHlwZW9mIHNhbHRfID09PSAnc3RyaW5nJykge1xuICAgIC8vIGFzc3VtZSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICBzYWx0XyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNhbHRfKTtcbiAgfVxuXG4gIHZhciBzTGVuO1xuICBpZignc2FsdExlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgIHNMZW4gPSBvcHRpb25zLnNhbHRMZW5ndGg7XG4gIH0gZWxzZSBpZihzYWx0XyAhPT0gbnVsbCkge1xuICAgIHNMZW4gPSBzYWx0Xy5sZW5ndGgoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbHQgbGVuZ3RoIG5vdCBzcGVjaWZpZWQgb3Igc3BlY2lmaWMgc2FsdCBub3QgZ2l2ZW4uJyk7XG4gIH1cblxuICBpZihzYWx0XyAhPT0gbnVsbCAmJiBzYWx0Xy5sZW5ndGgoKSAhPT0gc0xlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gc2FsdCBsZW5ndGggZG9lcyBub3QgbWF0Y2ggbGVuZ3RoIG9mIGdpdmVuIHNhbHQuJyk7XG4gIH1cblxuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG5cbiAgdmFyIHBzc29iaiA9IHt9O1xuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgUFNTIHNpZ25hdHVyZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIEVNU0EtUFNTLUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcsIHNlY3Rpb24gOS4xLjEuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAgICogQHBhcmFtIG1vZHNCaXRzIHRoZSBsZW5ndGggb2YgdGhlIFJTQSBtb2R1bHVzIGluIGJpdHMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBsZW5ndGhcbiAgICogICAgICAgICAgIGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpLlxuICAgKi9cbiAgcHNzb2JqLmVuY29kZSA9IGZ1bmN0aW9uKG1kLCBtb2RCaXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgIHZhciBlbUxlbiA9IE1hdGguY2VpbChlbUJpdHMgLyA4KTtcblxuICAgIC8qIDIuIExldCBtSGFzaCA9IEhhc2goTSksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICB2YXIgbUhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogMy4gSWYgZW1MZW4gPCBoTGVuICsgc0xlbiArIDIsIG91dHB1dCBcImVuY29kaW5nIGVycm9yXCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyB0byBlbmNyeXB0LicpO1xuICAgIH1cblxuICAgIC8qIDQuIEdlbmVyYXRlIGEgcmFuZG9tIG9jdGV0IHN0cmluZyBzYWx0IG9mIGxlbmd0aCBzTGVuOyBpZiBzTGVuID0gMCxcbiAgICAgKiAgICB0aGVuIHNhbHQgaXMgdGhlIGVtcHR5IHN0cmluZy4gKi9cbiAgICB2YXIgc2FsdDtcbiAgICBpZihzYWx0XyA9PT0gbnVsbCkge1xuICAgICAgc2FsdCA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHNMZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYWx0ID0gc2FsdF8uYnl0ZXMoKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgTScgPSAoMHgpMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgfHwgbUhhc2ggfHwgc2FsdDsgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDYuIExldCBIID0gSGFzaChNJyksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUobV8uZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIGggPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiA3LiBHZW5lcmF0ZSBhbiBvY3RldCBzdHJpbmcgUFMgY29uc2lzdGluZyBvZiBlbUxlbiAtIHNMZW4gLSBoTGVuIC0gMlxuICAgICAqICAgIHplcm8gb2N0ZXRzLiAgVGhlIGxlbmd0aCBvZiBQUyBtYXkgYmUgMC4gKi9cbiAgICB2YXIgcHMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgcHMuZmlsbFdpdGhCeXRlKDAsIGVtTGVuIC0gc0xlbiAtIGhMZW4gLSAyKTtcblxuICAgIC8qIDguIExldCBEQiA9IFBTIHx8IDB4MDEgfHwgc2FsdDsgREIgaXMgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aFxuICAgICAqICAgIGVtTGVuIC0gaExlbiAtIDEuICovXG4gICAgcHMucHV0Qnl0ZSgweDAxKTtcbiAgICBwcy5wdXRCeXRlcyhzYWx0KTtcbiAgICB2YXIgZGIgPSBwcy5nZXRCeXRlcygpO1xuXG4gICAgLyogOS4gTGV0IGRiTWFzayA9IE1HRihILCBlbUxlbiAtIGhMZW4gLSAxKS4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIGRiTWFzayA9IG1nZi5nZW5lcmF0ZShoLCBtYXNrTGVuKTtcblxuICAgIC8qIDEwLiBMZXQgbWFza2VkREIgPSBEQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIG1hc2tlZERCID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBtYXNrZWREQiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRiLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogMTEuIFNldCB0aGUgbGVmdG1vc3QgOGVtTGVuIC0gZW1CaXRzIGJpdHMgb2YgdGhlIGxlZnRtb3N0IG9jdGV0IGluXG4gICAgICogICAgIG1hc2tlZERCIHRvIHplcm8uICovXG4gICAgdmFyIG1hc2sgPSAoMHhGRjAwID4+ICg4ICogZW1MZW4gLSBlbUJpdHMpKSAmIDB4RkY7XG4gICAgbWFza2VkREIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoMCkgJiB+bWFzaykgK1xuICAgICAgbWFza2VkREIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTIuIExldCBFTSA9IG1hc2tlZERCIHx8IEggfHwgMHhiYy5cbiAgICAgKiAxMy4gT3V0cHV0IEVNLiAqL1xuICAgIHJldHVybiBtYXNrZWREQiArIGggKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIFBTUyBzaWduYXR1cmUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBFTVNBLVBTUy1WRVJJRlkgYXMgcGVyIFJGQyAzNDQ3LCBzZWN0aW9uIDkuMS4yLlxuICAgKlxuICAgKiBAcGFyYW0gbUhhc2ggdGhlIG1lc3NhZ2UgZGlnZXN0IGhhc2gsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nLCB0b1xuICAgKiAgICAgICAgIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLlxuICAgKiBAcGFyYW0gZW0gdGhlIGVuY29kZWQgbWVzc2FnZSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICogICAgICAgICAgKFJTQSBkZWNyeXB0aW9uIHJlc3VsdCkuXG4gICAqIEBwYXJhbSBtb2RzQml0cyB0aGUgbGVuZ3RoIG9mIHRoZSBSU0EgbW9kdWx1cyBpbiBiaXRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHNpZ25hdHVyZSB3YXMgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIHBzc29iai52ZXJpZnkgPSBmdW5jdGlvbihtSGFzaCwgZW0sIG1vZEJpdHMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgZW1CaXRzID0gbW9kQml0cyAtIDE7XG4gICAgdmFyIGVtTGVuID0gTWF0aC5jZWlsKGVtQml0cyAvIDgpO1xuXG4gICAgLyogYy4gQ29udmVydCB0aGUgbWVzc2FnZSByZXByZXNlbnRhdGl2ZSBtIHRvIGFuIGVuY29kZWQgbWVzc2FnZSBFTVxuICAgICAqICAgIG9mIGxlbmd0aCBlbUxlbiA9IGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpIG9jdGV0cywgd2hlcmUgbW9kQml0c1xuICAgICAqICAgIGlzIHRoZSBsZW5ndGggaW4gYml0cyBvZiB0aGUgUlNBIG1vZHVsdXMgbiAqL1xuICAgIGVtID0gZW0uc3Vic3RyKC1lbUxlbik7XG5cbiAgICAvKiAzLiBJZiBlbUxlbiA8IGhMZW4gKyBzTGVuICsgMiwgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IHBhcmFtZXRlcnMgdG8gUFNTIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24uJyk7XG4gICAgfVxuXG4gICAgLyogNC4gSWYgdGhlIHJpZ2h0bW9zdCBvY3RldCBvZiBFTSBkb2VzIG5vdCBoYXZlIGhleGFkZWNpbWFsIHZhbHVlXG4gICAgICogICAgMHhiYywgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW0uY2hhckNvZGVBdChlbUxlbiAtIDEpICE9PSAweGJjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kZWQgbWVzc2FnZSBkb2VzIG5vdCBlbmQgaW4gMHhCQy4nKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgbWFza2VkREIgYmUgdGhlIGxlZnRtb3N0IGVtTGVuIC0gaExlbiAtIDEgb2N0ZXRzIG9mIEVNLCBhbmRcbiAgICAgKiAgICBsZXQgSCBiZSB0aGUgbmV4dCBoTGVuIG9jdGV0cy4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyKDAsIG1hc2tMZW4pO1xuICAgIHZhciBoID0gZW0uc3Vic3RyKG1hc2tMZW4sIGhMZW4pO1xuXG4gICAgLyogNi4gSWYgdGhlIGxlZnRtb3N0IDhlbUxlbiAtIGVtQml0cyBiaXRzIG9mIHRoZSBsZWZ0bW9zdCBvY3RldCBpblxuICAgICAqICAgIG1hc2tlZERCIGFyZSBub3QgYWxsIGVxdWFsIHRvIHplcm8sIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBtYXNrID0gKDB4RkYwMCA+PiAoOCAqIGVtTGVuIC0gZW1CaXRzKSkgJiAweEZGO1xuICAgIGlmKChtYXNrZWREQi5jaGFyQ29kZUF0KDApICYgbWFzaykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQml0cyBiZXlvbmQga2V5c2l6ZSBub3QgemVybyBhcyBleHBlY3RlZC4nKTtcbiAgICB9XG5cbiAgICAvKiA3LiBMZXQgZGJNYXNrID0gTUdGKEgsIGVtTGVuIC0gaExlbiAtIDEpLiAqL1xuICAgIHZhciBkYk1hc2sgPSBtZ2YuZ2VuZXJhdGUoaCwgbWFza0xlbik7XG5cbiAgICAvKiA4LiBMZXQgREIgPSBtYXNrZWREQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIGRiID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBkYiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogOS4gU2V0IHRoZSBsZWZ0bW9zdCA4ZW1MZW4gLSBlbUJpdHMgYml0cyBvZiB0aGUgbGVmdG1vc3Qgb2N0ZXRcbiAgICAgKiBpbiBEQiB0byB6ZXJvLiAqL1xuICAgIGRiID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYi5jaGFyQ29kZUF0KDApICYgfm1hc2spICsgZGIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTAuIElmIHRoZSBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMiBsZWZ0bW9zdCBvY3RldHMgb2YgREIgYXJlIG5vdCB6ZXJvXG4gICAgICogb3IgaWYgdGhlIG9jdGV0IGF0IHBvc2l0aW9uIGVtTGVuIC0gaExlbiAtIHNMZW4gLSAxICh0aGUgbGVmdG1vc3RcbiAgICAgKiBwb3NpdGlvbiBpcyBcInBvc2l0aW9uIDFcIikgZG9lcyBub3QgaGF2ZSBoZXhhZGVjaW1hbCB2YWx1ZSAweDAxLFxuICAgICAqIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBjaGVja0xlbiA9IGVtTGVuIC0gaExlbiAtIHNMZW4gLSAyO1xuICAgIGZvcihpID0gMDsgaSA8IGNoZWNrTGVuOyBpKyspIHtcbiAgICAgIGlmKGRiLmNoYXJDb2RlQXQoaSkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWZ0bW9zdCBvY3RldHMgbm90IHplcm8gYXMgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihkYi5jaGFyQ29kZUF0KGNoZWNrTGVuKSAhPT0gMHgwMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbnNpc3RlbnQgUFNTIHNpZ25hdHVyZSwgMHgwMSBtYXJrZXIgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgLyogMTEuIExldCBzYWx0IGJlIHRoZSBsYXN0IHNMZW4gb2N0ZXRzIG9mIERCLiAqL1xuICAgIHZhciBzYWx0ID0gZGIuc3Vic3RyKC1zTGVuKTtcblxuICAgIC8qIDEyLiAgTGV0IE0nID0gKDB4KTAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIHx8IG1IYXNoIHx8IHNhbHQgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDEzLiBMZXQgSCcgPSBIYXNoKE0nKSwgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aCBoTGVuLiAqL1xuICAgIGhhc2guc3RhcnQoKTtcbiAgICBoYXNoLnVwZGF0ZShtXy5nZXRCeXRlcygpKTtcbiAgICB2YXIgaF8gPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiAxNC4gSWYgSCA9IEgnLCBvdXRwdXQgXCJjb25zaXN0ZW50LlwiIE90aGVyd2lzZSwgb3V0cHV0IFwiaW5jb25zaXN0ZW50LlwiICovXG4gICAgcmV0dXJuIGggPT09IGhfO1xuICB9O1xuXG4gIHJldHVybiBwc3NvYmo7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBiYXNpYyBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAqIHN1cHBvcnQgZm9yIFJTQSBwdWJsaWMgYW5kIHByaXZhdGUga2V5cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbl9fd2VicGFja19yZXF1aXJlX18oOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbl9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKiBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIChQS0kpIGltcGxlbWVudGF0aW9uLiAqL1xudmFyIHBraSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQuIFVzZSBwZW0uZGVjb2RlKCkgaW5zdGVhZC5cbiAqXG4gKiBDb252ZXJ0cyBQRU0tZm9ybWF0dGVkIGRhdGEgdG8gREVSLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBERVItZm9ybWF0dGVkIGRhdGEuXG4gKi9cbnBraS5wZW1Ub0RlciA9IGZ1bmN0aW9uKHBlbSkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQRU0gdG8gREVSOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG4gIHJldHVybiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuYm9keSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwcml2YXRlIGtleSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwcml2YXRlIGtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiYgbXNnLnR5cGUgIT09ICdSU0EgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNICcgK1xuICAgICAgJ2hlYWRlciB0eXBlIGlzIG5vdCBcIlBSSVZBVEUgS0VZXCIgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG5cbiAgcmV0dXJuIHBraS5wcml2YXRlS2V5RnJvbUFzbjEob2JqKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHByaXZhdGUga2V5IHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleVRvUGVtID0gZnVuY3Rpb24oa2V5LCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5wcml2YXRlS2V5VG9Bc24xKGtleSkpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBraSB0aGUgUHJpdmF0ZUtleUluZm8uXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUluZm9Ub1BlbSA9IGZ1bmN0aW9uKHBraSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBCYXNlLU4vQmFzZS1YIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBmcm9tIGJhc2UteDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmFzZS14XG4gKlxuICogV2hpY2ggaXMgTUlUIGxpY2Vuc2VkOlxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCBiYXNlLXggY29udHJpYnV0b3JzIChjKSAyMDE2XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGJhc2VOIGFscGhhYmV0IGluZGV4ZXNcbnZhciBfcmV2ZXJzZUFscGhhYmV0cyA9IHt9O1xuXG4vKipcbiAqIEJhc2VOLWVuY29kZXMgYSBVaW50OEFycmF5IHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2VOLWVuY29kZWQgb3V0cHV0IHN0cmluZy5cbiAqL1xuYXBpLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCwgbWF4bGluZSkge1xuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYobWF4bGluZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBtYXhsaW5lICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibWF4bGluZVwiIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgaWYoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgLy8gYXNzdW1lIGZvcmdlIGJ5dGUgYnVmZmVyXG4gICAgb3V0cHV0ID0gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgICB2YXIgZGlnaXRzID0gWzBdO1xuICAgIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0W2ldOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIGJhc2U7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IoaSA9IDA7IGlucHV0W2ldID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG91dHB1dCArPSBmaXJzdDtcbiAgICB9XG4gICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gICAgfVxuICB9XG5cbiAgaWYobWF4bGluZSkge1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJy57MSwnICsgbWF4bGluZSArICd9JywgJ2cnKTtcbiAgICBvdXRwdXQgPSBvdXRwdXQubWF0Y2gocmVnZXgpLmpvaW4oJ1xcclxcbicpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2VOLWVuY29kZWQgKHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldCkgc3RyaW5nIHRvIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlTi1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5LlxuICovXG5hcGkuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIGFscGhhYmV0KSB7XG4gIGlmKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlucHV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF07XG4gIGlmKCF0YWJsZSkge1xuICAgIC8vIGNvbXB1dGUgcmV2ZXJzZSBhbHBoYWJldFxuICAgIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0YWJsZVthbHBoYWJldC5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgdmFyIGJ5dGVzID0gWzBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB0YWJsZVtpbnB1dC5jaGFyQ29kZUF0KGkpXTtcbiAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBieXRlc1tqXSAqIGJhc2U7XG4gICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgIGNhcnJ5ID4+PSA4O1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgY2FycnkgPj49IDg7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgZm9yKHZhciBrID0gMDsgaW5wdXRba10gPT09IGZpcnN0ICYmIGsgPCBpbnB1dC5sZW5ndGggLSAxOyArK2spIHtcbiAgICBieXRlcy5wdXNoKDApO1xuICB9XG5cbiAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpO1xufTtcblxuZnVuY3Rpb24gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCkge1xuICB2YXIgaSA9IDA7XG4gIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gIHZhciBkaWdpdHMgPSBbMF07XG4gIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCgpOyArK2kpIHtcbiAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0LmF0KGkpOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IoaSA9IDA7IGlucHV0LmF0KGkpID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGgoKSAtIDE7ICsraSkge1xuICAgIG91dHB1dCArPSBmaXJzdDtcbiAgfVxuICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIG91dHB1dCArPSBhbHBoYWJldFtkaWdpdHNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMjU2LWJpdCBkaWdlc3QgKFNIQS0yNTYpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFNlZSBGSVBTIDE4MC0yIGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgc2hhMjU2ID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGEyNTYgPSBmb3JnZS5zaGEyNTYgfHwge307XG5mb3JnZS5tZC5zaGEyNTYgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTI1NiA9IHNoYTI1NjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTI1NiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMjU2LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMjU2IHN0YXRlIGNvbnRhaW5zIGVpZ2h0IDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg2NCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICBkaWdlc3RMZW5ndGg6IDMyLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogOFxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoNjQgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDY0ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX3N0YXRlID0ge1xuICAgICAgaDA6IDB4NkEwOUU2NjcsXG4gICAgICBoMTogMHhCQjY3QUU4NSxcbiAgICAgIGgyOiAweDNDNkVGMzcyLFxuICAgICAgaDM6IDB4QTU0RkY1M0EsXG4gICAgICBoNDogMHg1MTBFNTI3RixcbiAgICAgIGg1OiAweDlCMDU2ODhDLFxuICAgICAgaDY6IDB4MUY4M0Q5QUIsXG4gICAgICBoNzogMHg1QkUwQ0QxOVxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtMjU2IHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDQsXG4gICAgICBoNTogX3N0YXRlLmg1LFxuICAgICAgaDY6IF9zdGF0ZS5oNixcbiAgICAgIGg3OiBfc3RhdGUuaDdcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNyk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTI1NiBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIHRhYmxlIG9mIGNvbnN0YW50c1xudmFyIF9rID0gbnVsbDtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gY3JlYXRlIEsgdGFibGUgZm9yIFNIQS0yNTZcbiAgX2sgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gICAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAgIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gICAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAgIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gICAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMl07XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS0yNTYgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0yNTYgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQxLCB0MiwgczAsIHMxLCBjaCwgbWFqLCBpLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gNjQgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMjU2XG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgd1tpXSA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgfVxuICAgIGZvcig7IGkgPCA2NDsgKytpKSB7XG4gICAgICAvLyBYT1Igd29yZCAyIHdvcmRzIGFnbyByb3QgcmlnaHQgMTcsIHJvdCByaWdodCAxOSwgc2hmdCByaWdodCAxMFxuICAgICAgdDEgPSB3W2kgLSAyXTtcbiAgICAgIHQxID1cbiAgICAgICAgKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXlxuICAgICAgICAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeXG4gICAgICAgICh0MSA+Pj4gMTApO1xuICAgICAgLy8gWE9SIHdvcmQgMTUgd29yZHMgYWdvIHJvdCByaWdodCA3LCByb3QgcmlnaHQgMTgsIHNoZnQgcmlnaHQgM1xuICAgICAgdDIgPSB3W2kgLSAxNV07XG4gICAgICB0MiA9XG4gICAgICAgICgodDIgPj4+IDcpIHwgKHQyIDw8IDI1KSkgXlxuICAgICAgICAoKHQyID4+PiAxOCkgfCAodDIgPDwgMTQpKSBeXG4gICAgICAgICh0MiA+Pj4gMyk7XG4gICAgICAvLyBzdW0odDEsIHdvcmQgNyBhZ28sIHQyLCB3b3JkIDE2IGFnbykgbW9kdWxvIDJeMzJcbiAgICAgIHdbaV0gPSAodDEgKyB3W2kgLSA3XSArIHQyICsgd1tpIC0gMTZdKSB8IDA7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG4gICAgZiA9IHMuaDU7XG4gICAgZyA9IHMuaDY7XG4gICAgaCA9IHMuaDc7XG5cbiAgICAvLyByb3VuZCBmdW5jdGlvblxuICAgIGZvcihpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIC8vIFN1bTEoZSlcbiAgICAgIHMxID1cbiAgICAgICAgKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXlxuICAgICAgICAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXlxuICAgICAgICAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgIC8vIENoKGUsIGYsIGcpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgY2ggPSBnIF4gKGUgJiAoZiBeIGcpKTtcbiAgICAgIC8vIFN1bTAoYSlcbiAgICAgIHMwID1cbiAgICAgICAgKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXlxuICAgICAgICAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXlxuICAgICAgICAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAvLyBNYWooYSwgYiwgYykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBtYWogPSAoYSAmIGIpIHwgKGMgJiAoYSBeIGIpKTtcblxuICAgICAgLy8gbWFpbiBhbGdvcml0aG1cbiAgICAgIHQxID0gaCArIHMxICsgY2ggKyBfa1tpXSArIHdbaV07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgaCA9IGc7XG4gICAgICBnID0gZjtcbiAgICAgIGYgPSBlO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICAvLyBjYW4ndCB0cnVuY2F0ZSB3aXRoIGB8IDBgXG4gICAgICBlID0gKGQgKyB0MSkgPj4+IDA7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiA9IGE7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIC8vIGNhbid0IHRydW5jYXRlIHdpdGggYHwgMGBcbiAgICAgIGEgPSAodDEgKyB0MikgPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuICAgIHMuaDUgPSAocy5oNSArIGYpIHwgMDtcbiAgICBzLmg2ID0gKHMuaDYgKyBnKSB8IDA7XG4gICAgcy5oNyA9IChzLmg3ICsgaCkgfCAwO1xuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmVcbiAqIFBzZXVkbyBSYW5kb20gTnVtYmVyIEdlbmVyYXRvciAoUFJORykuIFRoZSBGb3J0dW5hIGFsZ29yaXRobSBpcyBmb2xsb3dlZFxuICogaGVyZSB0aG91Z2ggdGhlIHVzZSBvZiBTSEEtMjU2IGlzIG5vdCBlbmZvcmNlZDsgd2hlbiBnZW5lcmF0aW5nIGFuXG4gKiBhIFBSTkcgY29udGV4dCwgdGhlIGhhc2hpbmcgYWxnb3JpdGhtIGFuZCBibG9jayBjaXBoZXIgdXNlZCBmb3JcbiAqIHRoZSBnZW5lcmF0b3IgYXJlIHNwZWNpZmllZCB2aWEgYSBwbHVnaW4uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcnlwdG8gPSBudWxsO1xuaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXSkge1xuICBfY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG59XG5cbi8qIFBSTkcgQVBJICovXG52YXIgcHJuZyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJuZyA9IGZvcmdlLnBybmcgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HIGNvbnRleHQuXG4gKlxuICogQSBQUk5HIHBsdWdpbiBtdXN0IGJlIHBhc3NlZCBpbiB0aGF0IHdpbGwgcHJvdmlkZTpcbiAqXG4gKiAxLiBBIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGtleSBhbmQgc2VlZCBvZiBhIFBSTkcgY29udGV4dC4gSXRcbiAqICAgd2lsbCBiZSBnaXZlbiBhIDE2IGJ5dGUga2V5IGFuZCBhIDE2IGJ5dGUgc2VlZC4gQW55IGtleSBleHBhbnNpb25cbiAqICAgb3IgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHNlZWQgZnJvbSBhIGJ5dGUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2ZcbiAqICAgaW50ZWdlcnMgKG9yIHNpbWlsYXIpIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gKiAyLiBUaGUgY3J5cHRvZ3JhcGhpYyBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBnZW5lcmF0b3IuIEl0IHRha2VzIGEga2V5IGFuZFxuICogICBhIHNlZWQuXG4gKiAzLiBBIHNlZWQgaW5jcmVtZW50IGZ1bmN0aW9uLiBJdCB0YWtlcyB0aGUgc2VlZCBhbmQgcmV0dXJucyBzZWVkICsgMS5cbiAqIDQuIEFuIGFwaSB0byBjcmVhdGUgYSBtZXNzYWdlIGRpZ2VzdC5cbiAqXG4gKiBGb3IgYW4gZXhhbXBsZSwgc2VlIHJhbmRvbS5qcy5cbiAqXG4gKiBAcGFyYW0gcGx1Z2luIHRoZSBQUk5HIHBsdWdpbiB0byB1c2UuXG4gKi9cbnBybmcuY3JlYXRlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gIHZhciBjdHggPSB7XG4gICAgcGx1Z2luOiBwbHVnaW4sXG4gICAga2V5OiBudWxsLFxuICAgIHNlZWQ6IG51bGwsXG4gICAgdGltZTogbnVsbCxcbiAgICAvLyBudW1iZXIgb2YgcmVzZWVkcyBzbyBmYXJcbiAgICByZXNlZWRzOiAwLFxuICAgIC8vIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBzbyBmYXJcbiAgICBnZW5lcmF0ZWQ6IDAsXG4gICAgLy8gbm8gaW5pdGlhbCBrZXkgYnl0ZXNcbiAgICBrZXlCeXRlczogJydcbiAgfTtcblxuICAvLyBjcmVhdGUgMzIgZW50cm9weSBwb29scyAoZWFjaCBpcyBhIG1lc3NhZ2UgZGlnZXN0KVxuICB2YXIgbWQgPSBwbHVnaW4ubWQ7XG4gIHZhciBwb29scyA9IG5ldyBBcnJheSgzMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgcG9vbHNbaV0gPSBtZC5jcmVhdGUoKTtcbiAgfVxuICBjdHgucG9vbHMgPSBwb29scztcblxuICAvLyBlbnRyb3B5IHBvb2xzIGFyZSB3cml0dGVuIHRvIGN5Y2xpY2FsbHksIHN0YXJ0aW5nIGF0IGluZGV4IDBcbiAgY3R4LnBvb2wgPSAwO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmFuZG9tIGJ5dGVzLiBUaGUgYnl0ZXMgbWF5IGJlIGdlbmVyYXRlZCBzeW5jaHJvbm91c2x5IG9yXG4gICAqIGFzeW5jaHJvbm91c2x5LiBXZWIgd29ya2VycyBtdXN0IHVzZSB0aGUgYXN5bmNocm9ub3VzIGludGVyZmFjZSBvclxuICAgKiBlbHNlIHRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGJ5dGVzKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4gY291bnQgcmFuZG9tIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdlbmVyYXRlID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgLy8gZG8gc3luY2hyb25vdXNseVxuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGN0eC5nZW5lcmF0ZVN5bmMoY291bnQpO1xuICAgIH1cblxuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHJlc2V0IGtleSBmb3IgZXZlcnkgcmVxdWVzdCB0byBwcm90ZWN0IHByZXZpb3VzbHlcbiAgICAvLyBnZW5lcmF0ZWQgcmFuZG9tIGJ5dGVzIHNob3VsZCB0aGUga2V5IGJlIGRpc2NvdmVyZWQ7XG4gICAgLy8gdGhlcmUgaXMgbm8gMTAwbXMgYmFzZWQgcmVzZWVkaW5nIGJlY2F1c2Ugb2YgdGhpc1xuICAgIC8vIGZvcmNlZCByZXNlZWQgZm9yIGV2ZXJ5IGBnZW5lcmF0ZWAgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgZ2VuZXJhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGVycikge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdWZmaWNpZW50IGJ5dGVzIGdlbmVyYXRlZFxuICAgICAgaWYoYi5sZW5ndGgoKSA+PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYi5nZXRCeXRlcyhjb3VudCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbW91bnQgb2YgZGF0YSBnZW5lcmF0ZWQgaXMgZ3JlYXRlciB0aGFuIDEgTWlCLCB0cmlnZ2VyIHJlc2VlZFxuICAgICAgaWYoY3R4LmdlbmVyYXRlZCA+IDB4ZmZmZmYpIHtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcHJldmVudCBzdGFjayBvdmVyZmxvd1xuICAgICAgICByZXR1cm4gZm9yZ2UudXRpbC5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVzZWVkKGdlbmVyYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG5cbiAgICAgIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGdlbmVyYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZXMgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIGNvdW50IHJhbmRvbSBieXRlcyBhcyBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZW5lcmF0ZVN5bmMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gcmVzZXQga2V5IGZvciBldmVyeSByZXF1ZXN0IHRvIHByb3RlY3QgcHJldmlvdXNseVxuICAgIC8vIGdlbmVyYXRlZCByYW5kb20gYnl0ZXMgc2hvdWxkIHRoZSBrZXkgYmUgZGlzY292ZXJlZDtcbiAgICAvLyB0aGVyZSBpcyBubyAxMDBtcyBiYXNlZCByZXNlZWRpbmcgYmVjYXVzZSBvZiB0aGlzXG4gICAgLy8gZm9yY2VkIHJlc2VlZCBmb3IgZXZlcnkgYGdlbmVyYXRlU3luY2AgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHdoaWxlKGIubGVuZ3RoKCkgPCBjb3VudCkge1xuICAgICAgLy8gaWYgYW1vdW50IG9mIGRhdGEgZ2VuZXJhdGVkIGlzIGdyZWF0ZXIgdGhhbiAxIE1pQiwgdHJpZ2dlciByZXNlZWRcbiAgICAgIGlmKGN0eC5nZW5lcmF0ZWQgPiAweGZmZmZmKSB7XG4gICAgICAgIGN0eC5rZXkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZihjdHgua2V5ID09PSBudWxsKSB7XG4gICAgICAgIF9yZXNlZWRTeW5jKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMoY291bnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrKGVycikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzZWVkKGNhbGxiYWNrKSB7XG4gICAgaWYoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgIF9zZWVkKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LnNlZWRGaWxlKG5lZWRlZCwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICAgICAgX3NlZWQoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNlZWRTeW5jKCkge1xuICAgIGlmKGN0eC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoID49IDMyKSB7XG4gICAgICByZXR1cm4gX3NlZWQoKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LmNvbGxlY3QoY3R4LnNlZWRGaWxlU3luYyhuZWVkZWQpKTtcbiAgICBfc2VlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBzZWVkcyBhIGdlbmVyYXRvciBvbmNlIGVub3VnaCBieXRlcyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3NlZWQoKSB7XG4gICAgLy8gdXBkYXRlIHJlc2VlZCBjb3VudFxuICAgIGN0eC5yZXNlZWRzID0gKGN0eC5yZXNlZWRzID09PSAweGZmZmZmZmZmKSA/IDAgOiBjdHgucmVzZWVkcyArIDE7XG5cbiAgICAvLyBnb2FsIGlzIHRvIHVwZGF0ZSBga2V5YCB2aWE6XG4gICAgLy8ga2V5ID0gaGFzaChrZXkgKyBzKVxuICAgIC8vICAgd2hlcmUgJ3MnIGlzIGFsbCBjb2xsZWN0ZWQgZW50cm9weSBmcm9tIHNlbGVjdGVkIHBvb2xzLCB0aGVuLi4uXG5cbiAgICAvLyBjcmVhdGUgYSBwbHVnaW4tYmFzZWQgbWVzc2FnZSBkaWdlc3RcbiAgICB2YXIgbWQgPSBjdHgucGx1Z2luLm1kLmNyZWF0ZSgpO1xuXG4gICAgLy8gY29uc3VtZSBjdXJyZW50IGtleSBieXRlc1xuICAgIG1kLnVwZGF0ZShjdHgua2V5Qnl0ZXMpO1xuXG4gICAgLy8gZGlnZXN0IHRoZSBlbnRyb3B5IG9mIHBvb2xzIHdob3NlIGluZGV4IGsgbWVldCB0aGVcbiAgICAvLyBjb25kaXRpb24gJ24gbW9kIDJeayA9PSAwJyB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcmVzZWVkc1xuICAgIHZhciBfMnBvd0sgPSAxO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCAzMjsgKytrKSB7XG4gICAgICBpZihjdHgucmVzZWVkcyAlIF8ycG93SyA9PT0gMCkge1xuICAgICAgICBtZC51cGRhdGUoY3R4LnBvb2xzW2tdLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICAgICAgICBjdHgucG9vbHNba10uc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIF8ycG93SyA9IF8ycG93SyA8PCAxO1xuICAgIH1cblxuICAgIC8vIGdldCBkaWdlc3QgZm9yIGtleSBieXRlc1xuICAgIGN0eC5rZXlCeXRlcyA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHVwZGF0ZSBgc2VlZGAgdmlhIGBzZWVkID0gaGFzaChrZXkpYFxuICAgIC8vIGluc3RlYWQgb2YgaW5pdGlhbGl6aW5nIHRvIHplcm8gb25jZSBhbmQgb25seVxuICAgIC8vIGV2ZXIgaW5jcmVtZW50aW5nIGl0XG4gICAgbWQuc3RhcnQoKTtcbiAgICBtZC51cGRhdGUoY3R4LmtleUJ5dGVzKTtcbiAgICB2YXIgc2VlZEJ5dGVzID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIHVwZGF0ZSBzdGF0ZVxuICAgIGN0eC5rZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleShjdHgua2V5Qnl0ZXMpO1xuICAgIGN0eC5zZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkKHNlZWRCeXRlcyk7XG4gICAgY3R4LmdlbmVyYXRlZCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgc2VlZEZpbGUuIFRoaXMgc2VlZEZpbGUgaXMgdXNlZCB3aGVuIGVudHJvcHlcbiAgICogaXMgbmVlZGVkIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gbmVlZGVkIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0U2VlZEZpbGUobmVlZGVkKSB7XG4gICAgLy8gdXNlIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHN0cm9uZyBzb3VyY2Ugb2YgZW50cm9weSBpZiBhdmFpbGFibGVcbiAgICB2YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbiAgICBpZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIF9jcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcbiAgICAgIGlmKF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGlmKGdldFJhbmRvbVZhbHVlcykge1xuICAgICAgd2hpbGUoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgICAvLyBtYXggYnl0ZSBsZW5ndGggaXMgNjU1MzYgYmVmb3JlIFF1b3RhRXhjZWVkZWRFcnJvciBpcyB0aHJvd25cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLyNSYW5kb21Tb3VyY2UtbWV0aG9kLWdldFJhbmRvbVZhbHVlc1xuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihuZWVkZWQgLSBiLmxlbmd0aCgpLCA2NTUzNikgLyA0KTtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5mbG9vcihjb3VudCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdldFJhbmRvbVZhbHVlcyhlbnRyb3B5KTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYi5wdXRJbnQzMihlbnRyb3B5W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8qIG9ubHkgaWdub3JlIFF1b3RhRXhjZWVkZWRFcnJvciAqL1xuICAgICAgICAgIGlmKCEodHlwZW9mIFF1b3RhRXhjZWVkZWRFcnJvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBRdW90YUV4Y2VlZGVkRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJlIHNhZCBhbmQgYWRkIHNvbWUgd2VhayByYW5kb20gZGF0YVxuICAgIGlmKGIubGVuZ3RoKCkgPCBuZWVkZWQpIHtcbiAgICAgIC8qIERyYXdzIGZyb20gUGFyay1NaWxsZXIgXCJtaW5pbWFsIHN0YW5kYXJkXCIgMzEgYml0IFBSTkcsXG4gICAgICBpbXBsZW1lbnRlZCB3aXRoIERhdmlkIEcuIENhcnRhJ3Mgb3B0aW1pemF0aW9uOiB3aXRoIDMyIGJpdCBtYXRoXG4gICAgICBhbmQgd2l0aG91dCBkaXZpc2lvbiAoUHVibGljIERvbWFpbikuICovXG4gICAgICB2YXIgaGksIGxvLCBuZXh0O1xuICAgICAgdmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDAwMCk7XG4gICAgICB3aGlsZShiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgIGxvID0gMTY4MDcgKiAoc2VlZCAmIDB4RkZGRik7XG4gICAgICAgIGhpID0gMTY4MDcgKiAoc2VlZCA+PiAxNik7XG4gICAgICAgIGxvICs9IChoaSAmIDB4N0ZGRikgPDwgMTY7XG4gICAgICAgIGxvICs9IGhpID4+IDE1O1xuICAgICAgICBsbyA9IChsbyAmIDB4N0ZGRkZGRkYpICsgKGxvID4+IDMxKTtcbiAgICAgICAgc2VlZCA9IGxvICYgMHhGRkZGRkZGRjtcblxuICAgICAgICAvLyBjb25zdW1lIGxvd2VyIDMgYnl0ZXMgb2Ygc2VlZFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgLy8gdGhyb3cgaW4gbW9yZSBwc2V1ZG8gcmFuZG9tXG4gICAgICAgICAgbmV4dCA9IHNlZWQgPj4+IChpIDw8IDMpO1xuICAgICAgICAgIG5leHQgXj0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgwMTAwKTtcbiAgICAgICAgICBiLnB1dEJ5dGUoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0ICYgMHhGRikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMobmVlZGVkKTtcbiAgfVxuICAvLyBpbml0aWFsaXplIHNlZWQgZmlsZSBBUElzXG4gIGlmKF9jcnlwdG8pIHtcbiAgICAvLyB1c2Ugbm9kZWpzIGFzeW5jIEFQSVxuICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzLnRvU3RyaW5nKCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1c2Ugbm9kZWpzIHN5bmMgQVBJXG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGZ1bmN0aW9uKG5lZWRlZCkge1xuICAgICAgcmV0dXJuIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkKS50b1N0cmluZygpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNlZWRGaWxlID0gZnVuY3Rpb24obmVlZGVkLCBjYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGVmYXVsdFNlZWRGaWxlKG5lZWRlZCkpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGRlZmF1bHRTZWVkRmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGVudHJvcHkgdG8gYSBwcm5nIGN0eCdzIGFjY3VtdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIG9mIGVudHJvcHkgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjdHguY29sbGVjdCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBvb2xzIGRpc3RyaWJ1dGluZyBlbnRyb3B5IGN5Y2xpY2FsbHlcbiAgICB2YXIgY291bnQgPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGN0eC5wb29sc1tjdHgucG9vbF0udXBkYXRlKGJ5dGVzLnN1YnN0cihpLCAxKSk7XG4gICAgICBjdHgucG9vbCA9IChjdHgucG9vbCA9PT0gMzEpID8gMCA6IGN0eC5wb29sICsgMTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbGxlY3RzIGFuIGludGVnZXIgb2YgbiBiaXRzLlxuICAgKlxuICAgKiBAcGFyYW0gaSB0aGUgaW50ZWdlciBlbnRyb3B5LlxuICAgKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gICAqL1xuICBjdHguY29sbGVjdEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgICB2YXIgYnl0ZXMgPSAnJztcbiAgICBmb3IodmFyIHggPSAwOyB4IDwgbjsgeCArPSA4KSB7XG4gICAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IHgpICYgMHhGRik7XG4gICAgfVxuICAgIGN0eC5jb2xsZWN0KGJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgV2ViIFdvcmtlciB0byByZWNlaXZlIGltbWVkaWF0ZSBlbnRyb3B5IGZyb20gdGhlIG1haW4gdGhyZWFkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB1bnRpbCBXZWIgV29ya2VycyBjYW4gYWNjZXNzIHRoZSBuYXRpdmUgY3J5cHRvXG4gICAqIEFQSS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0d2ljZSBmb3IgZWFjaCBjcmVhdGVkIHdvcmtlciwgb25jZSBpblxuICAgKiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBvbmNlIGluIHRoZSB3b3JrZXIgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gd29ya2VyIHRoZSB3b3JrZXIgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBjdHgucmVnaXN0ZXJXb3JrZXIgPSBmdW5jdGlvbih3b3JrZXIpIHtcbiAgICAvLyB3b3JrZXIgcmVjZWl2ZXMgcmFuZG9tIGJ5dGVzXG4gICAgaWYod29ya2VyID09PSBzZWxmKSB7XG4gICAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YS5mb3JnZS5wcm5nLmVyciwgZGF0YS5mb3JnZS5wcm5nLmJ5dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtmb3JnZToge3Bybmc6IHtuZWVkZWQ6IG5lZWRlZH19fSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWluIHRocmVhZCBzZW5kcyByYW5kb20gYnl0ZXMgdXBvbiByZXF1ZXN0XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgIGN0eC5zZWVkRmlsZShkYXRhLmZvcmdlLnBybmcubmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe2ZvcmdlOiB7cHJuZzoge2VycjogZXJyLCBieXRlczogYnl0ZXN9fX0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhlIHdvcmtlciBkaWVzP1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjdHg7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBSQzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBJbmZvcm1hdGlvbiBvbiB0aGUgUkMyIGNpcGhlciBpcyBhdmFpbGFibGUgZnJvbSBSRkMgIzIyNjgsXG4gKiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjY4LnR4dFxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHBpVGFibGUgPSBbXG4gIDB4ZDksIDB4NzgsIDB4ZjksIDB4YzQsIDB4MTksIDB4ZGQsIDB4YjUsIDB4ZWQsIDB4MjgsIDB4ZTksIDB4ZmQsIDB4NzksIDB4NGEsIDB4YTAsIDB4ZDgsIDB4OWQsXG4gIDB4YzYsIDB4N2UsIDB4MzcsIDB4ODMsIDB4MmIsIDB4NzYsIDB4NTMsIDB4OGUsIDB4NjIsIDB4NGMsIDB4NjQsIDB4ODgsIDB4NDQsIDB4OGIsIDB4ZmIsIDB4YTIsXG4gIDB4MTcsIDB4OWEsIDB4NTksIDB4ZjUsIDB4ODcsIDB4YjMsIDB4NGYsIDB4MTMsIDB4NjEsIDB4NDUsIDB4NmQsIDB4OGQsIDB4MDksIDB4ODEsIDB4N2QsIDB4MzIsXG4gIDB4YmQsIDB4OGYsIDB4NDAsIDB4ZWIsIDB4ODYsIDB4YjcsIDB4N2IsIDB4MGIsIDB4ZjAsIDB4OTUsIDB4MjEsIDB4MjIsIDB4NWMsIDB4NmIsIDB4NGUsIDB4ODIsXG4gIDB4NTQsIDB4ZDYsIDB4NjUsIDB4OTMsIDB4Y2UsIDB4NjAsIDB4YjIsIDB4MWMsIDB4NzMsIDB4NTYsIDB4YzAsIDB4MTQsIDB4YTcsIDB4OGMsIDB4ZjEsIDB4ZGMsXG4gIDB4MTIsIDB4NzUsIDB4Y2EsIDB4MWYsIDB4M2IsIDB4YmUsIDB4ZTQsIDB4ZDEsIDB4NDIsIDB4M2QsIDB4ZDQsIDB4MzAsIDB4YTMsIDB4M2MsIDB4YjYsIDB4MjYsXG4gIDB4NmYsIDB4YmYsIDB4MGUsIDB4ZGEsIDB4NDYsIDB4NjksIDB4MDcsIDB4NTcsIDB4MjcsIDB4ZjIsIDB4MWQsIDB4OWIsIDB4YmMsIDB4OTQsIDB4NDMsIDB4MDMsXG4gIDB4ZjgsIDB4MTEsIDB4YzcsIDB4ZjYsIDB4OTAsIDB4ZWYsIDB4M2UsIDB4ZTcsIDB4MDYsIDB4YzMsIDB4ZDUsIDB4MmYsIDB4YzgsIDB4NjYsIDB4MWUsIDB4ZDcsXG4gIDB4MDgsIDB4ZTgsIDB4ZWEsIDB4ZGUsIDB4ODAsIDB4NTIsIDB4ZWUsIDB4ZjcsIDB4ODQsIDB4YWEsIDB4NzIsIDB4YWMsIDB4MzUsIDB4NGQsIDB4NmEsIDB4MmEsXG4gIDB4OTYsIDB4MWEsIDB4ZDIsIDB4NzEsIDB4NWEsIDB4MTUsIDB4NDksIDB4NzQsIDB4NGIsIDB4OWYsIDB4ZDAsIDB4NWUsIDB4MDQsIDB4MTgsIDB4YTQsIDB4ZWMsXG4gIDB4YzIsIDB4ZTAsIDB4NDEsIDB4NmUsIDB4MGYsIDB4NTEsIDB4Y2IsIDB4Y2MsIDB4MjQsIDB4OTEsIDB4YWYsIDB4NTAsIDB4YTEsIDB4ZjQsIDB4NzAsIDB4MzksXG4gIDB4OTksIDB4N2MsIDB4M2EsIDB4ODUsIDB4MjMsIDB4YjgsIDB4YjQsIDB4N2EsIDB4ZmMsIDB4MDIsIDB4MzYsIDB4NWIsIDB4MjUsIDB4NTUsIDB4OTcsIDB4MzEsXG4gIDB4MmQsIDB4NWQsIDB4ZmEsIDB4OTgsIDB4ZTMsIDB4OGEsIDB4OTIsIDB4YWUsIDB4MDUsIDB4ZGYsIDB4MjksIDB4MTAsIDB4NjcsIDB4NmMsIDB4YmEsIDB4YzksXG4gIDB4ZDMsIDB4MDAsIDB4ZTYsIDB4Y2YsIDB4ZTEsIDB4OWUsIDB4YTgsIDB4MmMsIDB4NjMsIDB4MTYsIDB4MDEsIDB4M2YsIDB4NTgsIDB4ZTIsIDB4ODksIDB4YTksXG4gIDB4MGQsIDB4MzgsIDB4MzQsIDB4MWIsIDB4YWIsIDB4MzMsIDB4ZmYsIDB4YjAsIDB4YmIsIDB4NDgsIDB4MGMsIDB4NWYsIDB4YjksIDB4YjEsIDB4Y2QsIDB4MmUsXG4gIDB4YzUsIDB4ZjMsIDB4ZGIsIDB4NDcsIDB4ZTUsIDB4YTUsIDB4OWMsIDB4NzcsIDB4MGEsIDB4YTYsIDB4MjAsIDB4NjgsIDB4ZmUsIDB4N2YsIDB4YzEsIDB4YWRcbl07XG5cbnZhciBzID0gWzEsIDIsIDMsIDVdO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHdvcmQgbGVmdCBieSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBCaXRzIHRoYXQgYXJlIHNoaWZ0ZWQgb3V0IG9uIHRoZSBsZWZ0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgcmlnaHRcbiAqIGhhbmQgc2lkZS5cbiAqXG4gKiBAcGFyYW0gd29yZCBUaGUgd29yZCB0byBzaGlmdCBsZWZ0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9sID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkIDw8IGJpdHMpICYgMHhmZmZmKSB8ICgod29yZCAmIDB4ZmZmZikgPj4gKDE2IC0gYml0cykpO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB3b3JkIHJpZ2h0IGJ5IGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIEJpdHMgdGhhdCBhcmUgc2hpZnRlZCBvdXQgb24gdGhlIHJpZ2h0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgbGVmdFxuICogaGFuZCBzaWRlLlxuICpcbiAqIEBwYXJhbSB3b3JkIFRoZSB3b3JkIHRvIHNoaWZ0IHJpZ2h0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9yID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkICYgMHhmZmZmKSA+PiBiaXRzKSB8ICgod29yZCA8PCAoMTYgLSBiaXRzKSkgJiAweGZmZmYpO1xufTtcblxuLyogUkMyIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYzIgPSBmb3JnZS5yYzIgfHwge307XG5cbi8qKlxuICogUGVyZm9ybSBSQzIga2V5IGV4cGFuc2lvbiBhcyBwZXIgUkZDICMyMjY4LCBzZWN0aW9uIDIuXG4gKlxuICogQHBhcmFtIGtleSB2YXJpYWJsZS1sZW5ndGggdXNlciBrZXkgKGJldHdlZW4gMSBhbmQgMTI4IGJ5dGVzKVxuICogQHBhcmFtIGVmZktleUJpdHMgbnVtYmVyIG9mIGVmZmVjdGl2ZSBrZXkgYml0cyAoZGVmYXVsdDogMTI4KVxuICogQHJldHVybiB0aGUgZXhwYW5kZWQgUkMyIGtleSAoQnl0ZUJ1ZmZlciBvZiAxMjggYnl0ZXMpXG4gKi9cbmZvcmdlLnJjMi5leHBhbmRLZXkgPSBmdW5jdGlvbihrZXksIGVmZktleUJpdHMpIHtcbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9XG4gIGVmZktleUJpdHMgPSBlZmZLZXlCaXRzIHx8IDEyODtcblxuICAvKiBpbnRyb2R1Y2UgdmFyaWFibGVzIHRoYXQgbWF0Y2ggdGhlIG5hbWVzIHVzZWQgaW4gUkZDICMyMjY4ICovXG4gIHZhciBMID0ga2V5O1xuICB2YXIgVCA9IGtleS5sZW5ndGgoKTtcbiAgdmFyIFQxID0gZWZmS2V5Qml0cztcbiAgdmFyIFQ4ID0gTWF0aC5jZWlsKFQxIC8gOCk7XG4gIHZhciBUTSA9IDB4ZmYgPj4gKFQxICYgMHgwNyk7XG4gIHZhciBpO1xuXG4gIGZvcihpID0gVDsgaSA8IDEyODsgaSsrKSB7XG4gICAgTC5wdXRCeXRlKHBpVGFibGVbKEwuYXQoaSAtIDEpICsgTC5hdChpIC0gVCkpICYgMHhmZl0pO1xuICB9XG5cbiAgTC5zZXRBdCgxMjggLSBUOCwgcGlUYWJsZVtMLmF0KDEyOCAtIFQ4KSAmIFRNXSk7XG5cbiAgZm9yKGkgPSAxMjcgLSBUODsgaSA+PSAwOyBpLS0pIHtcbiAgICBMLnNldEF0KGksIHBpVGFibGVbTC5hdChpICsgMSkgXiBMLmF0KGkgKyBUOCldKTtcbiAgfVxuXG4gIHJldHVybiBMO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUkMyIGNpcGhlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKGFzIGJhc2UgZm9yIGtleSBnZW5lcmF0aW9uKS5cbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgZWZmZWN0aXZlIGtleSBiaXRzLlxuICogQHBhcmFtIGVuY3J5cHQgZmFsc2UgZm9yIGRlY3J5cHRpb24sIHRydWUgZm9yIGVuY3J5cHRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG52YXIgY3JlYXRlQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzLCBlbmNyeXB0KSB7XG4gIHZhciBfZmluaXNoID0gZmFsc2UsIF9pbnB1dCA9IG51bGwsIF9vdXRwdXQgPSBudWxsLCBfaXYgPSBudWxsO1xuICB2YXIgbWl4Um91bmQsIG1hc2hSb3VuZDtcbiAgdmFyIGksIGosIEsgPSBbXTtcblxuICAvKiBFeHBhbmQga2V5IGFuZCBmaWxsIGludG8gS1tdIEFycmF5ICovXG4gIGtleSA9IGZvcmdlLnJjMi5leHBhbmRLZXkoa2V5LCBiaXRzKTtcbiAgZm9yKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIEsucHVzaChrZXkuZ2V0SW50MTZMZSgpKTtcbiAgfVxuXG4gIGlmKGVuY3J5cHQpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtaXhpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1peGluZyBvbi5cbiAgICAgKi9cbiAgICBtaXhSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgUltpXSA9IHJvbChSW2ldLCBzW2ldKTtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtYXNoaW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtYXNoaW5nIG9uLlxuICAgICAqL1xuICAgIG1hc2hSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1peGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWl4aW5nIG9uLlxuICAgICAqL1xuICAgIG1peFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldID0gcm9yKFJbaV0sIHNbaV0pO1xuICAgICAgICBSW2ldIC09IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1hc2hpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1hc2hpbmcgb24uXG4gICAgICovXG4gICAgbWFzaFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldIC09IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhlIHNwZWNpZmllZCBjaXBoZXIgZXhlY3V0aW9uIHBsYW4uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgZm91ciB3b3JkcyBmcm9tIHRoZSBpbnB1dCBidWZmZXIsIGFwcGxpZXMgdGhlIElWIG9uXG4gICAqIGl0IChpZiByZXF1ZXN0ZWQpIGFuZCBydW5zIHRoZSBwcm92aWRlZCBleGVjdXRpb24gcGxhbi5cbiAgICpcbiAgICogVGhlIHBsYW4gbXVzdCBiZSBwdXQgdG9nZXRoZXIgaW4gZm9ybSBvZiBhIGFycmF5IG9mIGFycmF5cy4gIFdoZXJlIHRoZVxuICAgKiBvdXRlciBvbmUgaXMgc2ltcGx5IGEgbGlzdCBvZiBzdGVwcyB0byBwZXJmb3JtIGFuZCB0aGUgaW5uZXIgb25lIG5lZWRzXG4gICAqIHRvIGhhdmUgdHdvIGVsZW1lbnRzOiB0aGUgZmlyc3Qgb25lIHRlbGxpbmcgaG93IG1hbnkgcm91bmRzIHRvIHBlcmZvcm0sXG4gICAqIHRoZSBzZWNvbmQgb25lIHRlbGxpbmcgd2hhdCB0byBkbyAoaS5lLiB0aGUgZnVuY3Rpb24gdG8gY2FsbCkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBsYW4gVGhlIHBsYW4gdG8gZXhlY3V0ZS5cbiAgICovXG4gIHZhciBydW5QbGFuID0gZnVuY3Rpb24ocGxhbikge1xuICAgIHZhciBSID0gW107XG5cbiAgICAvKiBHZXQgZGF0YSBmcm9tIGlucHV0IGJ1ZmZlciBhbmQgZmlsbCB0aGUgZm91ciB3b3JkcyBpbnRvIFIgKi9cbiAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSBfaW5wdXQuZ2V0SW50MTZMZSgpO1xuXG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcsIGFwcGx5IHRoZSBJViBmaXJzdC4gKi9cbiAgICAgICAgICB2YWwgXj0gX2l2LmdldEludDE2TGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBXZSdyZSBkZWNyeXB0aW9uLCBrZWVwIGNpcGhlciB0ZXh0IGZvciBuZXh0IGJsb2NrLiAqL1xuICAgICAgICAgIF9pdi5wdXRJbnQxNkxlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUi5wdXNoKHZhbCAmIDB4ZmZmZik7XG4gICAgfVxuXG4gICAgLyogUmVzZXQgZ2xvYmFsIFwialwiIHZhcmlhYmxlIGFzIHBlciBzcGVjLiAqL1xuICAgIGogPSBlbmNyeXB0ID8gMCA6IDYzO1xuXG4gICAgLyogUnVuIGV4ZWN1dGlvbiBwbGFuLiAqL1xuICAgIGZvcih2YXIgcHRyID0gMDsgcHRyIDwgcGxhbi5sZW5ndGg7IHB0cisrKSB7XG4gICAgICBmb3IodmFyIGN0ciA9IDA7IGN0ciA8IHBsYW5bcHRyXVswXTsgY3RyKyspIHtcbiAgICAgICAgcGxhbltwdHJdWzFdKFIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFdyaXRlIGJhY2sgcmVzdWx0IHRvIG91dHB1dCBidWZmZXIuICovXG4gICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcgaW4gQ0JDLW1vZGUsIGZlZWQgYmFjayBlbmNyeXB0ZWQgYnl0ZXMgaW50b1xuICAgICAgICAgICAgIElWIGJ1ZmZlciB0byBjYXJyeSBpdCBmb3J3YXJkIHRvIG5leHQgYmxvY2suICovXG4gICAgICAgICAgX2l2LnB1dEludDE2TGUoUltpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUltpXSBePSBfaXYuZ2V0SW50MTZMZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vdXRwdXQucHV0SW50MTZMZShSW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyogQ3JlYXRlIGNpcGhlciBvYmplY3QgKi9cbiAgdmFyIGNpcGhlciA9IG51bGw7XG4gIGNpcGhlciA9IHtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLCB3aGljaGV2ZXJcbiAgICAgKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICAgICAqXG4gICAgICogVG8gdXNlIHRoZSBjaXBoZXIgaW4gQ0JDIG1vZGUsIGl2IG1heSBiZSBnaXZlbiBlaXRoZXIgYXMgYSBzdHJpbmdcbiAgICAgKiBvZiBieXRlcywgb3IgYXMgYSBieXRlIGJ1ZmZlci4gIEZvciBFQ0IgbW9kZSwgZ2l2ZSBudWxsIGFzIGl2LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLCBudWxsIGZvciBFQ0IgbW9kZS5cbiAgICAgKiBAcGFyYW0gb3V0cHV0IHRoZSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbihpdiwgb3V0cHV0KSB7XG4gICAgICBpZihpdikge1xuICAgICAgICAvKiBDQkMgbW9kZSAqL1xuICAgICAgICBpZih0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihpdik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2ZpbmlzaCA9IGZhbHNlO1xuICAgICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9vdXRwdXQgPSBvdXRwdXQgfHwgbmV3IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfaXYgPSBpdjtcblxuICAgICAgY2lwaGVyLm91dHB1dCA9IF9vdXRwdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYoIV9maW5pc2gpIHtcbiAgICAgICAgLy8gbm90IGZpbmlzaGluZywgc28gZmlsbCB0aGUgaW5wdXQgYnVmZmVyIHdpdGggbW9yZSBpbnB1dFxuICAgICAgICBfaW5wdXQucHV0QnVmZmVyKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoX2lucHV0Lmxlbmd0aCgpID49IDgpIHtcbiAgICAgICAgcnVuUGxhbihbXG4gICAgICAgICAgICBbIDUsIG1peFJvdW5kIF0sXG4gICAgICAgICAgICBbIDEsIG1hc2hSb3VuZCBdLFxuICAgICAgICAgICAgWyA2LCBtaXhSb3VuZCBdLFxuICAgICAgICAgICAgWyAxLCBtYXNoUm91bmQgXSxcbiAgICAgICAgICAgIFsgNSwgbWl4Um91bmQgXVxuICAgICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2hlcyBlbmNyeXB0aW5nIG9yIGRlY3J5cHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFkIGEgcGFkZGluZyBmdW5jdGlvbiB0byB1c2UsIG51bGwgZm9yIFBLQ1MjNyBwYWRkaW5nLFxuICAgICAqICAgICAgICAgICBzaWduYXR1cmUoYmxvY2tTaXplLCBidWZmZXIsIGRlY3J5cHQpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICAgICAqL1xuICAgIGZpbmlzaDogZnVuY3Rpb24ocGFkKSB7XG4gICAgICB2YXIgcnZhbCA9IHRydWU7XG5cbiAgICAgIGlmKGVuY3J5cHQpIHtcbiAgICAgICAgaWYocGFkKSB7XG4gICAgICAgICAgcnZhbCA9IHBhZCg4LCBfaW5wdXQsICFlbmNyeXB0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gICAgICAgICAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSAoX2lucHV0Lmxlbmd0aCgpID09PSA4KSA/IDggOiAoOCAtIF9pbnB1dC5sZW5ndGgoKSk7XG4gICAgICAgICAgX2lucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nLCBwYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihydmFsKSB7XG4gICAgICAgIC8vIGRvIGZpbmFsIHVwZGF0ZVxuICAgICAgICBfZmluaXNoID0gdHJ1ZTtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZighZW5jcnlwdCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2sgc2l6ZVxuICAgICAgICBydmFsID0gKF9pbnB1dC5sZW5ndGgoKSA9PT0gMCk7XG4gICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICBpZihwYWQpIHtcbiAgICAgICAgICAgIHJ2YWwgPSBwYWQoOCwgX291dHB1dCwgIWVuY3J5cHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgcGFkZGluZyBieXRlIGNvdW50IGlzIHZhbGlkXG4gICAgICAgICAgICB2YXIgbGVuID0gX291dHB1dC5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IF9vdXRwdXQuYXQobGVuIC0gMSk7XG5cbiAgICAgICAgICAgIGlmKGNvdW50ID4gbGVuKSB7XG4gICAgICAgICAgICAgIHJ2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgICAgICAgICAgICAgX291dHB1dC50cnVuY2F0ZShjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXJcbiAqIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKiBUaGUgY2lwaGVyIGlzIGluaXRpYWxpemVkIHRvIHVzZSAxMjggZWZmZWN0aXZlIGtleSBiaXRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuc3RhcnRFbmNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0KSB7XG4gIHZhciBjaXBoZXIgPSBmb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gIGNpcGhlci5zdGFydChpdiwgb3V0cHV0KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIFRvIHN0YXJ0IGVuY3J5cHRpbmcgY2FsbCBzdGFydCgpIG9uIHRoZSBjaXBoZXIgd2l0aCBhbiBpdiBhbmQgb3B0aW9uYWxcbiAqIG91dHB1dCBidWZmZXIuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgYml0cykge1xuICByZXR1cm4gY3JlYXRlQ2lwaGVyKGtleSwgYml0cywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlclxuICogb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqIFRoZSBjaXBoZXIgaXMgaW5pdGlhbGl6ZWQgdG8gdXNlIDEyOCBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQpIHtcbiAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgY2lwaGVyLnN0YXJ0KGl2LCBvdXRwdXQpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogVG8gc3RhcnQgZGVjcnlwdGluZyBjYWxsIHN0YXJ0KCkgb24gdGhlIGNpcGhlciB3aXRoIGFuIGl2IGFuZCBvcHRpb25hbFxuICogb3V0cHV0IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzKSB7XG4gIHJldHVybiBjcmVhdGVDaXBoZXIoa2V5LCBiaXRzLCBmYWxzZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBQYXJ0aWFsIGltcGxlbWVudGF0aW9uIG9mIFBLQ1MjMSB2Mi4yOiBSU0EtT0VBUFxuICpcbiAqIE1vZGlmaWVkIGJ1dCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIE1JVCBhbmQgQlNEIGxpY2Vuc2VkIGNvZGU6XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2tqdXIvanNqd3MvYmxvYi9tYXN0ZXIvcnNhLmpzOlxuICpcbiAqIFRoZSAnanNqd3MnKEpTT04gV2ViIFNpZ25hdHVyZSBKYXZhU2NyaXB0IExpYnJhcnkpIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgS2VuamkgVXJ1c2hpbWFcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIGh0dHA6Ly93ZWJyc2EuY3ZzLnNvdXJjZWZvcmdlLm5ldC92aWV3dmMvd2VicnNhL0NsaWVudC9SU0FFUy1PQUVQLmpzP2NvbnRlbnQtdHlwZT10ZXh0JTJGcGxhaW46XG4gKlxuICogUlNBRVMtT0FFUC5qc1xuICogJElkOiBSU0FFUy1PQUVQLmpzLHYgMS4xLjEuMSAyMDAzLzAzLzE5IDE1OjM3OjIwIGVsbGlzcHJpdGNoYXJkIEV4cCAkXG4gKiBKYXZhU2NyaXB0IEltcGxlbWVudGF0aW9uIG9mIFBLQ1MgIzEgdjIuMSBSU0EgQ1JZUFRPR1JBUEhZIFNUQU5EQVJEIChSU0EgTGFib3JhdG9yaWVzLCBKdW5lIDE0LCAyMDAyKVxuICogQ29weXJpZ2h0IChDKSBFbGxpcyBQcml0Y2hhcmQsIEd1YXJkaWFuIFVubGltaXRlZCAyMDAzLlxuICogQ29udGFjdDogZWxsaXNAbnVraW5ldGljcy5jb21cbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbiAqXG4gKiBPZmZpY2lhbCBkb2N1bWVudGF0aW9uOiBodHRwOi8vd3d3LnJzYS5jb20vcnNhbGFicy9ub2RlLmFzcD9pZD0yMTI1XG4gKlxuICogQGF1dGhvciBFdmFuIEpvbmVzIChodHRwOi8vZXZhbmpvbmVzLmNhLylcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbi8vIHNob3J0Y3V0IGZvciBQS0NTIzEgQVBJXG52YXIgcGtjczEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3MxID0gZm9yZ2UucGtjczEgfHwge307XG5cbi8qKlxuICogRW5jb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIG1lc3NhZ2UgKE0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbCBsYWJlbCAoTClcbiAqIGFuZCBzZWVkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGVuY3J5cHRpb24sIGl0IG9ubHkgZW5jb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIHNlZWQgdGhlIHNlZWQgdG8gdXNlLlxuICogICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UsIHVuZGVmaW5lZCBmb3IgU0hBLTEuXG4gKiAgICAgICAgICBtZ2YxIG9wdGlvbmFsIG1nZjEgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE1HRjEuXG4gKlxuICogQHJldHVybiB0aGUgZW5jb2RlZCBtZXNzYWdlIGJ5dGVzLlxuICovXG5wa2NzMS5lbmNvZGVfcnNhX29hZXAgPSBmdW5jdGlvbihrZXksIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgLy8gcGFyc2UgYXJndW1lbnRzXG4gIHZhciBsYWJlbDtcbiAgdmFyIHNlZWQ7XG4gIHZhciBtZDtcbiAgdmFyIG1nZjFNZDtcbiAgLy8gbGVnYWN5IGFyZ3MgKGxhYmVsLCBzZWVkLCBtZClcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zO1xuICAgIHNlZWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gYXJndW1lbnRzWzRdIHx8IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmKG9wdGlvbnMpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgdW5kZWZpbmVkO1xuICAgIHNlZWQgPSBvcHRpb25zLnNlZWQgfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gb3B0aW9ucy5tZCB8fCB1bmRlZmluZWQ7XG4gICAgaWYob3B0aW9ucy5tZ2YxICYmIG9wdGlvbnMubWdmMS5tZCkge1xuICAgICAgbWdmMU1kID0gb3B0aW9ucy5tZ2YxLm1kO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlZmF1bHQgT0FFUCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZighbWQpIHtcbiAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgbWQuc3RhcnQoKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgTUdGLTEgdG8gc2FtZSBhcyBPQUVQXG4gIGlmKCFtZ2YxTWQpIHtcbiAgICBtZ2YxTWQgPSBtZDtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgbGVuZ3RoIGluIGJ5dGVzIGFuZCBjaGVjayBvdXRwdXRcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICB2YXIgbWF4TGVuZ3RoID0ga2V5TGVuZ3RoIC0gMiAqIG1kLmRpZ2VzdExlbmd0aCAtIDI7XG4gIGlmKG1lc3NhZ2UubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGlucHV0IG1lc3NhZ2UgbGVuZ3RoIGlzIHRvbyBsb25nLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoO1xuICAgIGVycm9yLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKCFsYWJlbCkge1xuICAgIGxhYmVsID0gJyc7XG4gIH1cbiAgbWQudXBkYXRlKGxhYmVsLCAncmF3Jyk7XG4gIHZhciBsSGFzaCA9IG1kLmRpZ2VzdCgpO1xuXG4gIHZhciBQUyA9ICcnO1xuICB2YXIgUFNfbGVuZ3RoID0gbWF4TGVuZ3RoIC0gbWVzc2FnZS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgUFNfbGVuZ3RoOyBpKyspIHtcbiAgICBQUyArPSAnXFx4MDAnO1xuICB9XG5cbiAgdmFyIERCID0gbEhhc2guZ2V0Qnl0ZXMoKSArIFBTICsgJ1xceDAxJyArIG1lc3NhZ2U7XG5cbiAgaWYoIXNlZWQpIHtcbiAgICBzZWVkID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG1kLmRpZ2VzdExlbmd0aCk7XG4gIH0gZWxzZSBpZihzZWVkLmxlbmd0aCAhPT0gbWQuZGlnZXN0TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIFJTQUVTLU9BRVAgc2VlZC4gVGhlIHNlZWQgbGVuZ3RoIG11c3QgJyArXG4gICAgICAnbWF0Y2ggdGhlIGRpZ2VzdCBsZW5ndGguJyk7XG4gICAgZXJyb3Iuc2VlZExlbmd0aCA9IHNlZWQubGVuZ3RoO1xuICAgIGVycm9yLmRpZ2VzdExlbmd0aCA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgbWFza2VkREIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKERCLCBkYk1hc2ssIERCLmxlbmd0aCk7XG5cbiAgdmFyIHNlZWRNYXNrID0gcnNhX21nZjEobWFza2VkREIsIG1kLmRpZ2VzdExlbmd0aCwgbWdmMU1kKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHNlZWQsIHNlZWRNYXNrLCBzZWVkLmxlbmd0aCk7XG5cbiAgLy8gcmV0dXJuIGVuY29kZWQgbWVzc2FnZVxuICByZXR1cm4gJ1xceDAwJyArIG1hc2tlZFNlZWQgKyBtYXNrZWREQjtcbn07XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSAoRU0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbFxuICogbGFiZWwgKEwpLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGRlY3J5cHRpb24sIGl0IG9ubHkgZGVjb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBlbSB0aGUgZW5jb2RlZCBtZXNzYWdlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBPQUVQLCB1bmRlZmluZWQgZm9yIFNIQS0xLlxuICogICAgICAgICAgbWdmMSBvcHRpb25hbCBtZ2YxIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBNR0YxLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgbWVzc2FnZSBieXRlcy5cbiAqL1xucGtjczEuZGVjb2RlX3JzYV9vYWVwID0gZnVuY3Rpb24oa2V5LCBlbSwgb3B0aW9ucykge1xuICAvLyBwYXJzZSBhcmdzXG4gIHZhciBsYWJlbDtcbiAgdmFyIG1kO1xuICB2YXIgbWdmMU1kO1xuICAvLyBsZWdhY3kgYXJnc1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnM7XG4gICAgbWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYob3B0aW9ucykge1xuICAgIGxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCB1bmRlZmluZWQ7XG4gICAgbWQgPSBvcHRpb25zLm1kIHx8IHVuZGVmaW5lZDtcbiAgICBpZihvcHRpb25zLm1nZjEgJiYgb3B0aW9ucy5tZ2YxLm1kKSB7XG4gICAgICBtZ2YxTWQgPSBvcHRpb25zLm1nZjEubWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcHV0ZSBsZW5ndGggaW4gYnl0ZXNcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIGlmKGVtLmxlbmd0aCAhPT0ga2V5TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlbS5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWRMZW5ndGggPSBrZXlMZW5ndGg7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBkZWZhdWx0IE9BRVAgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYobWQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBtZC5zdGFydCgpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCBNR0YtMSB0byBzYW1lIGFzIE9BRVBcbiAgaWYoIW1nZjFNZCkge1xuICAgIG1nZjFNZCA9IG1kO1xuICB9XG5cbiAgaWYoa2V5TGVuZ3RoIDwgMiAqIG1kLmRpZ2VzdExlbmd0aCArIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JTQUVTLU9BRVAga2V5IGlzIHRvbyBzaG9ydCBmb3IgdGhlIGhhc2ggZnVuY3Rpb24uJyk7XG4gIH1cblxuICBpZighbGFiZWwpIHtcbiAgICBsYWJlbCA9ICcnO1xuICB9XG4gIG1kLnVwZGF0ZShsYWJlbCwgJ3JhdycpO1xuICB2YXIgbEhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gIC8vIHNwbGl0IHRoZSBtZXNzYWdlIGludG8gaXRzIHBhcnRzXG4gIHZhciB5ID0gZW0uY2hhckF0KDApO1xuICB2YXIgbWFza2VkU2VlZCA9IGVtLnN1YnN0cmluZygxLCBtZC5kaWdlc3RMZW5ndGggKyAxKTtcbiAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyaW5nKDEgKyBtZC5kaWdlc3RMZW5ndGgpO1xuXG4gIHZhciBzZWVkTWFzayA9IHJzYV9tZ2YxKG1hc2tlZERCLCBtZC5kaWdlc3RMZW5ndGgsIG1nZjFNZCk7XG4gIHZhciBzZWVkID0gZm9yZ2UudXRpbC54b3JCeXRlcyhtYXNrZWRTZWVkLCBzZWVkTWFzaywgbWFza2VkU2VlZC5sZW5ndGgpO1xuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgZGIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKG1hc2tlZERCLCBkYk1hc2ssIG1hc2tlZERCLmxlbmd0aCk7XG5cbiAgdmFyIGxIYXNoUHJpbWUgPSBkYi5zdWJzdHJpbmcoMCwgbWQuZGlnZXN0TGVuZ3RoKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIHRoYXQgYWxsIHZhbHVlcyBtYXRjaCB3aGF0IGlzIGV4cGVjdGVkXG4gIHZhciBlcnJvciA9ICh5ICE9PSAnXFx4MDAnKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIGxIYXNoIHZzIGxIYXNoUHJpbWVcbiAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmRpZ2VzdExlbmd0aDsgKytpKSB7XG4gICAgZXJyb3IgfD0gKGxIYXNoLmNoYXJBdChpKSAhPT0gbEhhc2hQcmltZS5jaGFyQXQoaSkpO1xuICB9XG5cbiAgLy8gXCJjb25zdGFudCB0aW1lXCIgZmluZCB0aGUgMHgxIGJ5dGUgc2VwYXJhdGluZyB0aGUgcGFkZGluZyAoemVyb3MpIGZyb20gdGhlXG4gIC8vIG1lc3NhZ2VcbiAgLy8gVE9ETzogSXQgbXVzdCBiZSBwb3NzaWJsZSB0byBkbyB0aGlzIGluIGEgYmV0dGVyL3NtYXJ0ZXIgd2F5P1xuICB2YXIgaW5fcHMgPSAxO1xuICB2YXIgaW5kZXggPSBtZC5kaWdlc3RMZW5ndGg7XG4gIGZvcih2YXIgaiA9IG1kLmRpZ2VzdExlbmd0aDsgaiA8IGRiLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGNvZGUgPSBkYi5jaGFyQ29kZUF0KGopO1xuXG4gICAgdmFyIGlzXzAgPSAoY29kZSAmIDB4MSkgXiAweDE7XG5cbiAgICAvLyBub24temVybyBpZiBub3QgMCBvciAxIGluIHRoZSBwcyBzZWN0aW9uXG4gICAgdmFyIGVycm9yX21hc2sgPSBpbl9wcyA/IDB4ZmZmZSA6IDB4MDAwMDtcbiAgICBlcnJvciB8PSAoY29kZSAmIGVycm9yX21hc2spO1xuXG4gICAgLy8gbGF0Y2ggaW5fcHMgdG8gemVybyBhZnRlciB3ZSBmaW5kIDB4MVxuICAgIGluX3BzID0gaW5fcHMgJiBpc18wO1xuICAgIGluZGV4ICs9IGluX3BzO1xuICB9XG5cbiAgaWYoZXJyb3IgfHwgZGIuY2hhckNvZGVBdChpbmRleCkgIT09IDB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSU0FFUy1PQUVQIHBhZGRpbmcuJyk7XG4gIH1cblxuICByZXR1cm4gZGIuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG59O1xuXG5mdW5jdGlvbiByc2FfbWdmMShzZWVkLCBtYXNrTGVuZ3RoLCBoYXNoKSB7XG4gIC8vIGRlZmF1bHQgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYoIWhhc2gpIHtcbiAgICBoYXNoID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfVxuICB2YXIgdCA9ICcnO1xuICB2YXIgY291bnQgPSBNYXRoLmNlaWwobWFza0xlbmd0aCAvIGhhc2guZGlnZXN0TGVuZ3RoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAoaSA+PiAyNCkgJiAweEZGLCAoaSA+PiAxNikgJiAweEZGLCAoaSA+PiA4KSAmIDB4RkYsIGkgJiAweEZGKTtcbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUoc2VlZCArIGMpO1xuICAgIHQgKz0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICB9XG4gIHJldHVybiB0LnN1YnN0cmluZygwLCBtYXNrTGVuZ3RoKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogUHJpbWUgbnVtYmVyIGdlbmVyYXRpb24gQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnByaW1lIGFscmVhZHkgZGVmaW5lZFxuaWYoZm9yZ2UucHJpbWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcmltZTtcbiAgcmV0dXJuO1xufVxuXG4vKiBQUklNRSBBUEkgKi9cbnZhciBwcmltZSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJpbWUgPSBmb3JnZS5wcmltZSB8fCB7fTtcblxudmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG5cbi8vIHByaW1lcyBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xudmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuVEhJUlRZLmZyb21JbnQoMzApO1xudmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4fHk7fTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcHJvYmFibGUgcHJpbWUgd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQWx0ZXJuYXRpdmUgYWxnb3JpdGhtcyBjYW4gYmUgc3BlY2lmaWVkIGJ5IG5hbWUgYXMgYSBzdHJpbmcgb3IgYXMgYW5cbiAqIG9iamVjdCB3aXRoIGN1c3RvbSBvcHRpb25zIGxpa2Ugc286XG4gKlxuICoge1xuICogICBuYW1lOiAnUFJJTUVJTkMnLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgbWF4QmxvY2tUaW1lOiA8dGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gYmxvY2sgdGhlIG1haW5cbiAqICAgICAgIHRocmVhZCBiZWZvcmUgYWxsb3dpbmcgSS9PIG90aGVyIEpTIHRvIHJ1bj4sXG4gKiAgICAgbWlsbGVyUmFiaW5UZXN0czogPHRoZSBudW1iZXIgb2YgbWlsbGVyLXJhYmluIHRlc3RzIHRvIHJ1bj4sXG4gKiAgICAgd29ya2VyU2NyaXB0OiA8dGhlIHdvcmtlciBzY3JpcHQgVVJMPixcbiAqICAgICB3b3JrZXJzOiA8dGhlIG51bWJlciBvZiB3ZWIgd29ya2VycyAoaWYgc3VwcG9ydGVkKSB0byB1c2UsXG4gKiAgICAgICAtMSB0byB1c2UgZXN0aW1hdGVkIGNvcmVzIG1pbnVzIG9uZT4uXG4gKiAgICAgd29ya0xvYWQ6IHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgbnVtYmVyIG9mIGJpdHMgZm9yIHRoZSBwcmltZSBudW1iZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBbYWxnb3JpdGhtXSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiAgICAgICAgICBbcHJuZ10gYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuXG4gKlxuICogQHJldHVybiBjYWxsYmFjayhlcnIsIG51bSkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnByaW1lLmdlbmVyYXRlUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBkZWZhdWx0IHRvIFBSSU1FSU5DIGFsZ29yaXRobVxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcbiAgaWYodHlwZW9mIGFsZ29yaXRobSA9PT0gJ3N0cmluZycpIHtcbiAgICBhbGdvcml0aG0gPSB7bmFtZTogYWxnb3JpdGhtfTtcbiAgfVxuICBhbGdvcml0aG0ub3B0aW9ucyA9IGFsZ29yaXRobS5vcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICB2YXIgcm5nID0ge1xuICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgYiA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHgubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHhbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmKGFsZ29yaXRobS5uYW1lID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcmV0dXJuIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgYWxnb3JpdGhtLm9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmltZSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobS5uYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoJ3dvcmtlcnMnIGluIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIGluaXRpYWxpemUgcmFuZG9tIG51bWJlclxuICB2YXIgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcblxuICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybSAzMGsraSBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEuIFRoZVxuICBudW1iZXIgd2UgYXJlIGdpdmVuIGlzIGFsd2F5cyBhbGlnbmVkIGF0IDMwayArIDEuIEVhY2ggdGltZSB0aGUgbnVtYmVyIGlzXG4gIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlclxuICB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgdmFyIGRlbHRhSWR4ID0gMDtcblxuICAvLyBnZXQgcmVxdWlyZWQgbnVtYmVyIG9mIE1SIHRlc3RzXG4gIHZhciBtclRlc3RzID0gZ2V0TWlsbGVyUmFiaW5UZXN0cyhudW0uYml0TGVuZ3RoKCkpO1xuICBpZignbWlsbGVyUmFiaW5UZXN0cycgaW4gb3B0aW9ucykge1xuICAgIG1yVGVzdHMgPSBvcHRpb25zLm1pbGxlclJhYmluVGVzdHM7XG4gIH1cblxuICAvLyBmaW5kIHByaW1lIG5lYXJlc3QgdG8gJ251bScgZm9yIG1heEJsb2NrVGltZSBtc1xuICAvLyAxMCBtcyBnaXZlcyA1bXMgb2YgbGVld2F5IGZvciBvdGhlciBjYWxjdWxhdGlvbnMgYmVmb3JlIGRyb3BwaW5nXG4gIC8vIGJlbG93IDYwZnBzICgxMDAwLzYwID09IDE2LjY3KSwgYnV0IGluIHJlYWxpdHksIHRoZSBudW1iZXIgd2lsbFxuICAvLyBsaWtlbHkgYmUgaGlnaGVyIGR1ZSB0byBhbiAnYXRvbWljJyBiaWcgaW50IG1vZFBvd1xuICB2YXIgbWF4QmxvY2tUaW1lID0gMTA7XG4gIGlmKCdtYXhCbG9ja1RpbWUnIGluIG9wdGlvbnMpIHtcbiAgICBtYXhCbG9ja1RpbWUgPSBvcHRpb25zLm1heEJsb2NrVGltZTtcbiAgfVxuXG4gIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGFydCA9ICtuZXcgRGF0ZSgpO1xuICBkbyB7XG4gICAgLy8gb3ZlcmZsb3csIHJlZ2VuZXJhdGUgcmFuZG9tIG51bWJlclxuICAgIGlmKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgfVxuICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgaWYobnVtLmlzUHJvYmFibGVQcmltZShtclRlc3RzKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bSk7XG4gICAgfVxuICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgIG51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICB9IHdoaWxlKG1heEJsb2NrVGltZSA8IDAgfHwgKCtuZXcgRGF0ZSgpIC0gc3RhcnQgPCBtYXhCbG9ja1RpbWUpKTtcblxuICAvLyBrZWVwIHRyeWluZyBsYXRlclxuICBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8vIE5PVEU6IFRoaXMgYWxnb3JpdGhtIGlzIGluZGV0ZXJtaW5hdGUgaW4gbmF0dXJlIGJlY2F1c2Ugd29ya2Vyc1xuLy8gcnVuIGluIHBhcmFsbGVsIGxvb2tpbmcgYXQgZGlmZmVyZW50IHNlZ21lbnRzIG9mIG51bWJlcnMuIEV2ZW4gaWYgdGhpc1xuLy8gYWxnb3JpdGhtIGlzIHJ1biB0d2ljZSB3aXRoIHRoZSBzYW1lIGlucHV0IGZyb20gYSBwcmVkaWN0YWJsZSBSTkcsIGl0XG4vLyBtYXkgcHJvZHVjZSBkaWZmZXJlbnQgb3V0cHV0cy5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lV2l0aFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyB3ZWIgd29ya2VycyB1bmF2YWlsYWJsZVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSByYW5kb20gbnVtYmVyXG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuXG4gIC8vIHVzZSB3ZWIgd29ya2VycyB0byBnZW5lcmF0ZSBrZXlzXG4gIHZhciBudW1Xb3JrZXJzID0gb3B0aW9ucy53b3JrZXJzO1xuICB2YXIgd29ya0xvYWQgPSBvcHRpb25zLndvcmtMb2FkIHx8IDEwMDtcbiAgdmFyIHJhbmdlID0gd29ya0xvYWQgKiAzMCAvIDg7XG4gIHZhciB3b3JrZXJTY3JpcHQgPSBvcHRpb25zLndvcmtlclNjcmlwdCB8fCAnZm9yZ2UvcHJpbWUud29ya2VyLmpzJztcbiAgaWYobnVtV29ya2VycyA9PT0gLTEpIHtcbiAgICByZXR1cm4gZm9yZ2UudXRpbC5lc3RpbWF0ZUNvcmVzKGZ1bmN0aW9uKGVyciwgY29yZXMpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIDJcbiAgICAgICAgY29yZXMgPSAyO1xuICAgICAgfVxuICAgICAgbnVtV29ya2VycyA9IGNvcmVzIC0gMTtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyByZXF1aXJlIGF0IGxlYXN0IDEgd29ya2VyXG4gICAgbnVtV29ya2VycyA9IE1hdGgubWF4KDEsIG51bVdvcmtlcnMpO1xuXG4gICAgLy8gVE9ETzogY29uc2lkZXIgb3B0aW1pemluZyBieSBzdGFydGluZyB3b3JrZXJzIG91dHNpZGUgZ2V0UHJpbWUoKSAuLi5cbiAgICAvLyBub3RlIHRoYXQgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhleSB3aWxsIGhhdmUgdG8gYmUgbWFkZSBpbnRlcm5hbGx5XG4gICAgLy8gYXN5bmNocm9ub3VzIHdoaWNoIG1heSBhY3R1YWxseSBiZSBzbG93ZXJcblxuICAgIC8vIHN0YXJ0IHdvcmtlcnMgaW1tZWRpYXRlbHlcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIC8vIEZJWE1FOiBmaXggcGF0aCBvciB1c2UgYmxvYiBVUkxzXG4gICAgICB3b3JrZXJzW2ldID0gbmV3IFdvcmtlcih3b3JrZXJTY3JpcHQpO1xuICAgIH1cbiAgICB2YXIgcnVubmluZyA9IG51bVdvcmtlcnM7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHJlcXVlc3RzIGZyb20gd29ya2VycyBhbmQgYXNzaWduIHJhbmdlcyB0byBmaW5kIHByaW1lXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyogTm90ZTogVGhlIGRpc3RyaWJ1dGlvbiBvZiByYW5kb20gbnVtYmVycyBpcyB1bmtub3duLiBUaGVyZWZvcmUsIGVhY2hcbiAgICB3ZWIgd29ya2VyIGlzIGNvbnRpbnVvdXNseSBhbGxvY2F0ZWQgYSByYW5nZSBvZiBudW1iZXJzIHRvIGNoZWNrIGZvciBhXG4gICAgcmFuZG9tIG51bWJlciB1bnRpbCBvbmUgaXMgZm91bmQuXG5cbiAgICBFdmVyeSAzMCBudW1iZXJzIHdpbGwgYmUgY2hlY2tlZCBqdXN0IDggdGltZXMsIGJlY2F1c2UgcHJpbWUgbnVtYmVyc1xuICAgIGhhdmUgdGhlIGZvcm06XG5cbiAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xICh0aGVyZSBhcmUgOCB2YWx1ZXMgb2YgaSBmb3IgdGhpcylcblxuICAgIFRoZXJlZm9yZSwgaWYgd2Ugd2FudCBhIHdlYiB3b3JrZXIgdG8gcnVuIE4gY2hlY2tzIGJlZm9yZSBhc2tpbmcgZm9yXG4gICAgYSBuZXcgcmFuZ2Ugb2YgbnVtYmVycywgZWFjaCByYW5nZSBtdXN0IGNvbnRhaW4gTiozMC84IG51bWJlcnMuXG5cbiAgICBGb3IgMTAwIGNoZWNrcyAod29ya0xvYWQpLCB0aGlzIGlzIGEgcmFuZ2Ugb2YgMzc1LiAqL1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gd29ya2VyTWVzc2FnZShlKSB7XG4gICAgICAvLyBpZ25vcmUgbWVzc2FnZSwgcHJpbWUgYWxyZWFkeSBmb3VuZFxuICAgICAgaWYoZm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAtLXJ1bm5pbmc7XG4gICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgIGlmKGRhdGEuZm91bmQpIHtcbiAgICAgICAgLy8gdGVybWluYXRlIGFsbCB3b3JrZXJzXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB3b3JrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQmlnSW50ZWdlcihkYXRhLnByaW1lLCAxNikpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVyZmxvdywgcmVnZW5lcmF0ZSByYW5kb20gbnVtYmVyXG4gICAgICBpZihudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc2lnbiBuZXcgcmFuZ2UgdG8gY2hlY2tcbiAgICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuXG4gICAgICAvLyBzdGFydCBwcmltZSBzZWFyY2hcbiAgICAgIGUudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaGV4OiBoZXgsXG4gICAgICAgIHdvcmtMb2FkOiB3b3JrTG9hZFxuICAgICAgfSk7XG5cbiAgICAgIG51bS5kQWRkT2Zmc2V0KHJhbmdlLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIHVzaW5nIHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cyBhbmQgUk5HLlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgYml0cyBmb3IgdGhlIG51bWJlci5cbiAqIEBwYXJhbSBybmcgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpIHtcbiAgdmFyIG51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHJuZyk7XG4gIC8vIGZvcmNlIE1TQiBzZXRcbiAgdmFyIGJpdHMxID0gYml0cyAtIDE7XG4gIGlmKCFudW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICBudW0uYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChiaXRzMSksIG9wX29yLCBudW0pO1xuICB9XG4gIC8vIGFsaWduIG51bWJlciBvbiAzMGsrMSBib3VuZGFyeVxuICBudW0uZEFkZE9mZnNldCgzMSAtIG51bS5tb2QoVEhJUlRZKS5ieXRlVmFsdWUoKSwgMCk7XG4gIHJldHVybiBudW07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIE1pbGxlci1SYWJpbiB0ZXN0cyB0byBnZW5lcmF0ZSBhXG4gKiBwcmltZSB3aXRoIGFuIGVycm9yIHByb2JhYmlsaXR5IG9mICgxLzIpXjgwLlxuICpcbiAqIFNlZSBIYW5kYm9vayBvZiBBcHBsaWVkIENyeXB0b2dyYXBoeSBDaGFwdGVyIDQsIFRhYmxlIDQuNC5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUuXG4gKlxuICogQHJldHVybiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBQS0NTIzEyLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBQS0NTIzEyIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgZnRwOi8vZnRwLnJzYXNlY3VyaXR5LmNvbS9wdWIvcGtjcy9wa2NzLTEyL3BrY3MtMTItdGMxLnBkZiBmb3IgZGV0YWlscylcbiAqXG4gKiBQRlggOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgSU5URUdFUiB7djMoMyl9KHYzLC4uLiksXG4gKiAgIGF1dGhTYWZlIENvbnRlbnRJbmZvLFxuICogICBtYWNEYXRhICBNYWNEYXRhIE9QVElPTkFMXG4gKiB9XG4gKlxuICogTWFjRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICBtYWMgRGlnZXN0SW5mbyxcbiAqICAgbWFjU2FsdCBPQ1RFVCBTVFJJTkcsXG4gKiAgIGl0ZXJhdGlvbnMgSU5URUdFUiBERUZBVUxUIDFcbiAqIH1cbiAqIE5vdGU6IFRoZSBpdGVyYXRpb25zIGRlZmF1bHQgaXMgZm9yIGhpc3RvcmljYWwgcmVhc29ucyBhbmQgaXRzIHVzZSBpc1xuICogZGVwcmVjYXRlZC4gQSBoaWdoZXIgdmFsdWUsIGxpa2UgMTAyNCwgaXMgcmVjb21tZW5kZWQuXG4gKlxuICogRGlnZXN0SW5mbyBpcyBkZWZpbmVkIGluIFBLQ1MjNyBhcyBmb2xsb3dzOlxuICpcbiAqIERpZ2VzdEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGRpZ2VzdCBEaWdlc3RcbiAqIH1cbiAqXG4gKiBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIFNIQTEgdGhlcmUgaXMgbm9uZS5cbiAqXG4gKiBBbGdvcml0aG1JZGVudGlmZXIgOjo9IFNFUVVFTkNFIHtcbiAqICAgIGFsZ29yaXRobSBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAqXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgIFswXSBFWFBMSUNJVCBBTlkgREVGSU5FRCBCWSBjb250ZW50VHlwZSBPUFRJT05BTFxuICogfVxuICpcbiAqIENvbnRlbnRUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICpcbiAqIEF1dGhlbnRpY2F0ZWRTYWZlIDo6PSBTRVFVRU5DRSBPRiBDb250ZW50SW5mb1xuICogLS0gRGF0YSBpZiB1bmVuY3J5cHRlZFxuICogLS0gRW5jcnlwdGVkRGF0YSBpZiBwYXNzd29yZC1lbmNyeXB0ZWRcbiAqIC0tIEVudmVsb3BlZERhdGEgaWYgcHVibGljIGtleS1lbmNyeXB0ZWRcbiAqXG4gKlxuICogU2FmZUNvbnRlbnRzIDo6PSBTRVFVRU5DRSBPRiBTYWZlQmFnXG4gKlxuICogU2FmZUJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBiYWdJZCAgICAgQkFHLVRZUEUuJmlkICh7UEtDUzEyQmFnU2V0fSlcbiAqICAgYmFnVmFsdWUgIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSh7UEtDUzEyQmFnU2V0fXtAYmFnSWR9KSxcbiAqICAgYmFnQXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogUEtDUzEyQXR0cmlidXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGF0dHJJZCBBVFRSSUJVVEUuJmlkICh7UEtDUzEyQXR0clNldH0pLFxuICogICBhdHRyVmFsdWVzIFNFVCBPRiBBVFRSSUJVVEUuJlR5cGUgKHtQS0NTMTJBdHRyU2V0fXtAYXR0cklkfSlcbiAqIH0gLS0gVGhpcyB0eXBlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgWC41MDAgdHlwZSDigJlBdHRyaWJ1dGXigJlcbiAqXG4gKiBQS0NTMTJBdHRyU2V0IEFUVFJJQlVURSA6Oj0ge1xuICogICBmcmllbmRseU5hbWUgfCAtLSBmcm9tIFBLQ1MgIzlcbiAqICAgbG9jYWxLZXlJZCwgLS0gZnJvbSBQS0NTICM5XG4gKiAgIC4uLiAtLSBPdGhlciBhdHRyaWJ1dGVzIGFyZSBhbGxvd2VkXG4gKiB9XG4gKlxuICogQ2VydEJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjZXJ0SWQgICAgQkFHLVRZUEUuJmlkICAgKHtDZXJ0VHlwZXN9KSxcbiAqICAgY2VydFZhbHVlIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSAoe0NlcnRUeXBlc317QGNlcnRJZH0pXG4gKiB9XG4gKlxuICogeDUwOUNlcnRpZmljYXRlIEJBRy1UWVBFIDo6PSB7T0NURVQgU1RSSU5HIElERU5USUZJRUQgQlkge2NlcnRUeXBlcyAxfX1cbiAqICAgLS0gREVSLWVuY29kZWQgWC41MDkgY2VydGlmaWNhdGUgc3RvcmVkIGluIE9DVEVUIFNUUklOR1xuICpcbiAqIHNkc2lDZXJ0aWZpY2F0ZSBCQUctVFlQRSA6Oj0ge0lBNVN0cmluZyBJREVOVElGSUVEIEJZIHtjZXJ0VHlwZXMgMn19XG4gKiAtLSBCYXNlNjQtZW5jb2RlZCBTRFNJIGNlcnRpZmljYXRlIHN0b3JlZCBpbiBJQTVTdHJpbmdcbiAqXG4gKiBDZXJ0VHlwZXMgQkFHLVRZUEUgOjo9IHtcbiAqICAgeDUwOUNlcnRpZmljYXRlIHxcbiAqICAgc2RzaUNlcnRpZmljYXRlLFxuICogICAuLi4gLS0gRm9yIGZ1dHVyZSBleHRlbnNpb25zXG4gKiB9XG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xICYgUEtJIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjMTIgQVBJXG52YXIgcDEyID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2NzMTIgPSBmb3JnZS5wa2NzMTIgfHwge307XG5cbnZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsICAvLyBhIENvbnRlbnRJbmZvXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NvbnRlbnQnXG4gIH1dXG59O1xuXG52YXIgcGZ4VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUEZYJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUEZYLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sXG4gIGNvbnRlbnRJbmZvVmFsaWRhdG9yLCB7XG4gICAgbmFtZTogJ1BGWC5tYWNEYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnbWFjJyxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLCAgLy8gRGlnZXN0SW5mb1xuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ1BGWC5tYWNEYXRhLm1hYy5kaWdlc3RBbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSwgIC8vIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMuZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYWNBbGdvcml0aG0nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6ICdtYWNBbGdvcml0aG1QYXJhbWV0ZXJzJ1xuICAgICAgICB9XVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdtYWNEaWdlc3QnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWNTYWx0JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdtYWNTYWx0J1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5pdGVyYXRpb25zJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlOiAnbWFjSXRlcmF0aW9ucydcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHNhZmVCYWdWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTYWZlQmFnJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdJZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdiYWdJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdTYWZlQmFnLmJhZ1ZhbHVlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnYmFnVmFsdWUnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnYmFnQXR0cmlidXRlcydcbiAgfV1cbn07XG5cbnZhciBhdHRyaWJ1dGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdBdHRyaWJ1dGUnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0cklkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ29pZCdcbiAgfSwge1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0clZhbHVlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZTogJ3ZhbHVlcydcbiAgfV1cbn07XG5cbnZhciBjZXJ0QmFnVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydEJhZycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NlcnRCYWcuY2VydElkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NlcnRJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdDZXJ0QmFnLmNlcnRWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAvKiBTbyBmYXIgd2Ugb25seSBzdXBwb3J0IFguNTA5IGNlcnRpZmljYXRlcyAod2hpY2ggYXJlIHdyYXBwZWQgaW5cbiAgICAgICBhbiBPQ1RFVCBTVFJJTkcsIGhlbmNlIGhhcmQgY29kZSB0aGF0IGhlcmUpLiAqL1xuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRCYWcuY2VydFZhbHVlWzBdJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnY2VydCdcbiAgICB9XVxuICB9XVxufTtcblxuLyoqXG4gKiBTZWFyY2ggU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSBmb3IgYmFncyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhlIHNlYXJjaCBjYW4gb3B0aW9uYWxseSBiZSBuYXJyb3dlZCBieSBhIGNlcnRhaW4gYmFnIHR5cGUuXG4gKlxuICogQHBhcmFtIHNhZmVDb250ZW50cyB0aGUgU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0gYXR0ck5hbWUgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gKiBAcGFyYW0gYXR0clZhbHVlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAqXG4gKiBAcmV0dXJuIGFuIGFycmF5IG9mIG1hdGNoaW5nIGJhZ3MuXG4gKi9cbmZ1bmN0aW9uIF9nZXRCYWdzQnlBdHRyaWJ1dGUoc2FmZUNvbnRlbnRzLCBhdHRyTmFtZSwgYXR0clZhbHVlLCBiYWdUeXBlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgc2FmZUNvbnRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHNhZmVDb250ZW50c1tpXS5zYWZlQmFncy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGJhZyA9IHNhZmVDb250ZW50c1tpXS5zYWZlQmFnc1tqXTtcbiAgICAgIGlmKGJhZ1R5cGUgIT09IHVuZGVmaW5lZCAmJiBiYWcudHlwZSAhPT0gYmFnVHlwZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgZmlsdGVyIGJ5IGJhZyB0eXBlLCBubyBhdHRyaWJ1dGUgc3BlY2lmaWVkXG4gICAgICBpZihhdHRyTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXS5pbmRleE9mKGF0dHJWYWx1ZSkgPj0gMCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbiBpbnRvIGEgUEZYIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbi5cbiAqIEBwYXJhbSBzdHJpY3QgdHJ1ZSB0byB1c2Ugc3RyaWN0IERFUiBkZWNvZGluZywgZmFsc2Ugbm90IHRvIChkZWZhdWx0OiB0cnVlKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIFBLQ1MjMTIgUEZYIG9iamVjdC5cbiAqL1xucDEyLnBrY3MxMkZyb21Bc24xID0gZnVuY3Rpb24ob2JqLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGhhbmRsZSBhcmdzXG4gIGlmKHR5cGVvZiBzdHJpY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBzdHJpY3Q7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmKHN0cmljdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIFBGWCBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBwZnhWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFBLQ1MjMTIgUEZYLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjMTIgUEZYLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9yO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHBmeCA9IHtcbiAgICB2ZXJzaW9uOiBjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSxcbiAgICBzYWZlQ29udGVudHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBiYWdzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgdGhlIGF0dHJpYnV0ZXMgdG8gZmlsdGVyIGJ5OlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkXSB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkSGV4XSB0aGUgbG9jYWxLZXlJZCBpbiBoZXggdG8gc2VhcmNoIGZvci5cbiAgICAgKiAgICAgICAgICBbZnJpZW5kbHlOYW1lXSB0aGUgZnJpZW5kbHkgbmFtZSB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtiYWdUeXBlXSBiYWcgdHlwZSB0byBuYXJyb3cgZWFjaCBhdHRyaWJ1dGUgc2VhcmNoIGJ5LlxuICAgICAqXG4gICAgICogQHJldHVybiBhIG1hcCBvZiBhdHRyaWJ1dGUgdHlwZSB0byBhbiBhcnJheSBvZiBtYXRjaGluZyBiYWdzIG9yLCBpZiBub1xuICAgICAqICAgICAgICAgICBhdHRyaWJ1dGUgd2FzIGdpdmVuIGJ1dCBhIGJhZyB0eXBlLCB0aGUgbWFwIGtleSB3aWxsIGJlIHRoZVxuICAgICAqICAgICAgICAgICBiYWcgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRCYWdzOiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgIHZhciBydmFsID0ge307XG5cbiAgICAgIHZhciBsb2NhbEtleUlkO1xuICAgICAgaWYoJ2xvY2FsS2V5SWQnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZmlsdGVyLmxvY2FsS2V5SWQ7XG4gICAgICB9IGVsc2UgaWYoJ2xvY2FsS2V5SWRIZXgnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGZpbHRlci5sb2NhbEtleUlkSGV4KTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIG9uIGJhZ1R5cGUgb25seVxuICAgICAgaWYobG9jYWxLZXlJZCA9PT0gdW5kZWZpbmVkICYmICEoJ2ZyaWVuZGx5TmFtZScgaW4gZmlsdGVyKSAmJlxuICAgICAgICAnYmFnVHlwZScgaW4gZmlsdGVyKSB7XG4gICAgICAgIHJ2YWxbZmlsdGVyLmJhZ1R5cGVdID0gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCBudWxsLCBudWxsLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGxvY2FsS2V5SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBydmFsLmxvY2FsS2V5SWQgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdsb2NhbEtleUlkJyxcbiAgICAgICAgICBsb2NhbEtleUlkLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG4gICAgICBpZignZnJpZW5kbHlOYW1lJyBpbiBmaWx0ZXIpIHtcbiAgICAgICAgcnZhbC5mcmllbmRseU5hbWUgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdmcmllbmRseU5hbWUnLFxuICAgICAgICAgIGZpbHRlci5mcmllbmRseU5hbWUsIGZpbHRlci5iYWdUeXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgZnJpZW5kbHlOYW1lIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcmllbmRseU5hbWUgdGhlIGZyaWVuZGx5IG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gW2JhZ1R5cGVdIGJhZyB0eXBlIHRvIG5hcnJvdyBzZWFyY2ggYnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGJhZ3Mgd2l0aCBtYXRjaGluZyBmcmllbmRseU5hbWUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUZyaWVuZGx5TmFtZTogZnVuY3Rpb24oZnJpZW5kbHlOYW1lLCBiYWdUeXBlKSB7XG4gICAgICByZXR1cm4gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgcGZ4LnNhZmVDb250ZW50cywgJ2ZyaWVuZGx5TmFtZScsIGZyaWVuZGx5TmFtZSwgYmFnVHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgbG9jYWxLZXlJZCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxLZXlJZCB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYmFncyB3aXRoIG1hdGNoaW5nIGxvY2FsS2V5SWQgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUxvY2FsS2V5SWQ6IGZ1bmN0aW9uKGxvY2FsS2V5SWQsIGJhZ1R5cGUpIHtcbiAgICAgIHJldHVybiBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCAnbG9jYWxLZXlJZCcsIGxvY2FsS2V5SWQsIGJhZ1R5cGUpO1xuICAgIH1cbiAgfTtcblxuICBpZihjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSAhPT0gMykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignUEtDUyMxMiBQRlggb2YgdmVyc2lvbiBvdGhlciB0aGFuIDMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci52ZXJzaW9uID0gY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpICE9PSBwa2kub2lkcy5kYXRhKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdPbmx5IFBLQ1MjMTIgUEZYIGluIHBhc3N3b3JkIGludGVncml0eSBtb2RlIHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci5vaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gIGlmKGRhdGEudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGRhdGEudHlwZSAhPT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIGF1dGhTYWZlIGNvbnRlbnQgZGF0YSBpcyBub3QgYW4gT0NURVQgU1RSSU5HLicpO1xuICB9XG4gIGRhdGEgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpO1xuXG4gIC8vIGNoZWNrIGZvciBNQUNcbiAgaWYoY2FwdHVyZS5tYWMpIHtcbiAgICB2YXIgbWQgPSBudWxsO1xuICAgIHZhciBtYWNLZXlCeXRlcyA9IDA7XG4gICAgdmFyIG1hY0FsZ29yaXRobSA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5tYWNBbGdvcml0aG0pO1xuICAgIHN3aXRjaChtYWNBbGdvcml0aG0pIHtcbiAgICBjYXNlIHBraS5vaWRzLnNoYTE6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDIwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5zaGEyNTY6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHBraS5vaWRzLnNoYTM4NDpcbiAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgbWFjS2V5Qnl0ZXMgPSA0ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcGtpLm9pZHMuc2hhNTEyOlxuICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5tZDU6XG4gICAgICBtZCA9IGZvcmdlLm1kLm1kNS5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMTY7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiB1c2VzIHVuc3VwcG9ydGVkIE1BQyBhbGdvcml0aG06ICcgKyBtYWNBbGdvcml0aG0pO1xuICAgIH1cblxuICAgIC8vIHZlcmlmeSBNQUMgKGl0ZXJhdGlvbnMgZGVmYXVsdCB0byAxKVxuICAgIHZhciBtYWNTYWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihjYXB0dXJlLm1hY1NhbHQpO1xuICAgIHZhciBtYWNJdGVyYXRpb25zID0gKCgnbWFjSXRlcmF0aW9ucycgaW4gY2FwdHVyZSkgP1xuICAgICAgcGFyc2VJbnQoZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGNhcHR1cmUubWFjSXRlcmF0aW9ucyksIDE2KSA6IDEpO1xuICAgIHZhciBtYWNLZXkgPSBwMTIuZ2VuZXJhdGVLZXkoXG4gICAgICBwYXNzd29yZCwgbWFjU2FsdCwgMywgbWFjSXRlcmF0aW9ucywgbWFjS2V5Qnl0ZXMsIG1kKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQobWQsIG1hY0tleSk7XG4gICAgbWFjLnVwZGF0ZShkYXRhLnZhbHVlKTtcbiAgICB2YXIgbWFjVmFsdWUgPSBtYWMuZ2V0TWFjKCk7XG4gICAgaWYobWFjVmFsdWUuZ2V0Qnl0ZXMoKSAhPT0gY2FwdHVyZS5tYWNEaWdlc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBNQUMgY291bGQgbm90IGJlIHZlcmlmaWVkLiBJbnZhbGlkIHBhc3N3b3JkPycpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWNvZGVBdXRoZW50aWNhdGVkU2FmZShwZngsIGRhdGEudmFsdWUsIHN0cmljdCwgcGFzc3dvcmQpO1xuICByZXR1cm4gcGZ4O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIFBLQ1MjNyBEYXRhLiBQS0NTIzcgKFJGQyAyMzE1KSBkZWZpbmVzIFwiRGF0YVwiIGFzIGFuIE9DVEVUIFNUUklORyxcbiAqIGJ1dCBpdCBpcyBzb21ldGltZXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaXMgY29tcG9zZWQvY29uc3RydWN0ZWQgb2YgY2h1bmtzLFxuICogZWFjaCBpdHMgb3duIE9DVEVUIFNUUklORy4gVGhpcyBpcyBCRVItZW5jb2RpbmcgdnMuIERFUi1lbmNvZGluZy4gVGhpc1xuICogZnVuY3Rpb24gdHJhbnNmb3JtcyB0aGlzIGNvcm5lci1jYXNlIGludG8gdGhlIHVzdWFsIHNpbXBsZSxcbiAqIG5vbi1jb21wb3NlZC9jb25zdHJ1Y3RlZCBPQ1RFVCBTVFJJTkcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXkgYmUgbW92ZWQgdG8gQVNOLjEgYXQgc29tZSBwb2ludCB0byBiZXR0ZXIgZGVhbCB3aXRoXG4gKiBtb3JlIEJFUi1lbmNvZGluZyBpc3N1ZXMsIHNob3VsZCB0aGV5IGFyaXNlLlxuICpcbiAqIEBwYXJhbSBkYXRhIHRoZSBBU04uMSBEYXRhIG9iamVjdCB0byB0cmFuc2Zvcm0uXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVQa2NzN0RhdGEoZGF0YSkge1xuICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIFwiY2h1bmtlZFwiIGRhdGEgY29udGVudDogYW4gb2N0ZXQgc3RyaW5nIGNvbXBvc2VkXG4gIC8vIG9mIG90aGVyIG9jdGV0IHN0cmluZ3NcbiAgaWYoZGF0YS5jb21wb3NlZCB8fCBkYXRhLmNvbnN0cnVjdGVkKSB7XG4gICAgdmFyIHZhbHVlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsdWUucHV0Qnl0ZXMoZGF0YS52YWx1ZVtpXS52YWx1ZSk7XG4gICAgfVxuICAgIGRhdGEuY29tcG9zZWQgPSBkYXRhLmNvbnN0cnVjdGVkID0gZmFsc2U7XG4gICAgZGF0YS52YWx1ZSA9IHZhbHVlLmdldEJ5dGVzKCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlIFBLQ1MjMTIgQXV0aGVudGljYXRlZFNhZmUgKEJFUiBlbmNvZGVkKSBpbnRvIFBGWCBvYmplY3QuXG4gKlxuICogVGhlIEF1dGhlbnRpY2F0ZWRTYWZlIGlzIGEgQkVSLWVuY29kZWQgU0VRVUVOQ0UgT0YgQ29udGVudEluZm8uXG4gKlxuICogQHBhcmFtIHBmeCBUaGUgUEtDUyMxMiBQRlggb2JqZWN0IHRvIGZpbGwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYXV0aFNhZmUgQkVSLWVuY29kZWQgQXV0aGVudGljYXRlZFNhZmUuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUF1dGhlbnRpY2F0ZWRTYWZlKHBmeCwgYXV0aFNhZmUsIHN0cmljdCwgcGFzc3dvcmQpIHtcbiAgYXV0aFNhZmUgPSBhc24xLmZyb21EZXIoYXV0aFNhZmUsIHN0cmljdCk7ICAvKiBhY3R1YWxseSBpdCdzIEJFUiBlbmNvZGVkICovXG5cbiAgaWYoYXV0aFNhZmUudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGF1dGhTYWZlLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgICBhdXRoU2FmZS5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBBdXRoZW50aWNhdGVkU2FmZSBleHBlY3RlZCB0byBiZSBhICcgK1xuICAgICAgJ1NFUVVFTkNFIE9GIENvbnRlbnRJbmZvJyk7XG4gIH1cblxuICBmb3IodmFyIGkgPSAwOyBpIDwgYXV0aFNhZmUudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGVudEluZm8gPSBhdXRoU2FmZS52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIGNvbnRlbnRJbmZvIGFuZCBjYXB0dXJlIGRhdGFcbiAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZighYXNuMS52YWxpZGF0ZShjb250ZW50SW5mbywgY29udGVudEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgQ29udGVudEluZm8uJyk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge1xuICAgICAgZW5jcnlwdGVkOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIHNhZmVDb250ZW50cyA9IG51bGw7XG4gICAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gICAgc3dpdGNoKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jb250ZW50VHlwZSkpIHtcbiAgICBjYXNlIHBraS5vaWRzLmRhdGE6XG4gICAgICBpZihkYXRhLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fFxuICAgICAgICAgZGF0YS50eXBlICE9PSBhc24xLlR5cGUuT0NURVRTVFJJTkcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIFNhZmVDb250ZW50cyBEYXRhIGlzIG5vdCBhbiBPQ1RFVCBTVFJJTkcuJyk7XG4gICAgICB9XG4gICAgICBzYWZlQ29udGVudHMgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5lbmNyeXB0ZWREYXRhOlxuICAgICAgc2FmZUNvbnRlbnRzID0gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpO1xuICAgICAgb2JqLmVuY3J5cHRlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQS0NTIzEyIGNvbnRlbnRUeXBlLicpO1xuICAgICAgZXJyb3IuY29udGVudFR5cGUgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgb2JqLnNhZmVCYWdzID0gX2RlY29kZVNhZmVDb250ZW50cyhzYWZlQ29udGVudHMsIHN0cmljdCwgcGFzc3dvcmQpO1xuICAgIHBmeC5zYWZlQ29udGVudHMucHVzaChvYmopO1xuICB9XG59XG5cbi8qKlxuICogRGVjcnlwdCBQS0NTIzcgRW5jcnlwdGVkRGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIGRhdGEgQVNOLjEgZW5jb2RlZCBFbmNyeXB0ZWRDb250ZW50SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHVzZXItcHJvdmlkZWQgcGFzc3dvcmQuXG4gKlxuICogQHJldHVybiBUaGUgZGVjcnlwdGVkIFNhZmVDb250ZW50cyAoQVNOLjEgb2JqZWN0KS5cbiAqL1xuZnVuY3Rpb24gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShcbiAgICBkYXRhLCBmb3JnZS5wa2NzNy5hc24xLmVuY3J5cHRlZERhdGFWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIEVuY3J5cHRlZENvbnRlbnRJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLmRhdGEpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAnUEtDUyMxMiBFbmNyeXB0ZWRDb250ZW50SW5mbyBDb250ZW50VHlwZSBpcyBub3QgRGF0YS4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgY2lwaGVyXG4gIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNBbGdvcml0aG0pO1xuICB2YXIgY2lwaGVyID0gcGtpLnBiZS5nZXRDaXBoZXIob2lkLCBjYXB0dXJlLmVuY1BhcmFtZXRlciwgcGFzc3dvcmQpO1xuXG4gIC8vIGdldCBlbmNyeXB0ZWQgZGF0YVxuICB2YXIgZW5jcnlwdGVkQ29udGVudEFzbjEgPSBfZGVjb2RlUGtjczdEYXRhKGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudEFzbjEpO1xuICB2YXIgZW5jcnlwdGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZW5jcnlwdGVkQ29udGVudEFzbjEudmFsdWUpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoIWNpcGhlci5maW5pc2goKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgUEtDUyMxMiBTYWZlQ29udGVudHMuJyk7XG4gIH1cblxuICByZXR1cm4gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNhZmVDb250ZW50cyAoQkVSLWVuY29kZWQpIGludG8gYXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKlxuICogVGhlIHNhZmVDb250ZW50cyBpcyBhIEJFUi1lbmNvZGVkIFNFUVVFTkNFIE9GIFNhZmVCYWcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNhZmVDb250ZW50cyBCRVItZW5jb2RlZCBzYWZlQ29udGVudHMuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVTYWZlQ29udGVudHMoc2FmZUNvbnRlbnRzLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGlmIHN0cmljdCBhbmQgbm8gc2FmZSBjb250ZW50cywgcmV0dXJuIGVtcHR5IHNhZmVzXG4gIGlmKCFzdHJpY3QgJiYgc2FmZUNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIGFjdHVhbGx5IGl0J3MgQkVSLWVuY29kZWRcbiAgc2FmZUNvbnRlbnRzID0gYXNuMS5mcm9tRGVyKHNhZmVDb250ZW50cywgc3RyaWN0KTtcblxuICBpZihzYWZlQ29udGVudHMudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgc2FmZUNvbnRlbnRzLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgIHNhZmVDb250ZW50cy5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdQS0NTIzEyIFNhZmVDb250ZW50cyBleHBlY3RlZCB0byBiZSBhIFNFUVVFTkNFIE9GIFNhZmVCYWcuJyk7XG4gIH1cblxuICB2YXIgcmVzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzYWZlQ29udGVudHMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2FmZUJhZyA9IHNhZmVDb250ZW50cy52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIFNhZmVCYWcgYW5kIGNhcHR1cmUgZGF0YVxuICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGlmKCFhc24xLnZhbGlkYXRlKHNhZmVCYWcsIHNhZmVCYWdWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgU2FmZUJhZy4nKTtcbiAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8qIENyZWF0ZSBiYWcgb2JqZWN0IGFuZCBwdXNoIHRvIHJlc3VsdCBhcnJheS4gKi9cbiAgICB2YXIgYmFnID0ge1xuICAgICAgdHlwZTogYXNuMS5kZXJUb09pZChjYXB0dXJlLmJhZ0lkKSxcbiAgICAgIGF0dHJpYnV0ZXM6IF9kZWNvZGVCYWdBdHRyaWJ1dGVzKGNhcHR1cmUuYmFnQXR0cmlidXRlcylcbiAgICB9O1xuICAgIHJlcy5wdXNoKGJhZyk7XG5cbiAgICB2YXIgdmFsaWRhdG9yLCBkZWNvZGVyO1xuICAgIHZhciBiYWdBc24xID0gY2FwdHVyZS5iYWdWYWx1ZS52YWx1ZVswXTtcbiAgICBzd2l0Y2goYmFnLnR5cGUpIHtcbiAgICAgIGNhc2UgcGtpLm9pZHMucGtjczhTaHJvdWRlZEtleUJhZzpcbiAgICAgICAgLyogYmFnQXNuMSBoYXMgYSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbywgd2hpY2ggd2UgbmVlZCB0byBkZWNyeXB0LlxuICAgICAgICAgICBBZnRlcndhcmRzIHdlIGNhbiBoYW5kbGUgaXQgbGlrZSBhIGtleUJhZyxcbiAgICAgICAgICAgd2hpY2ggaXMgYSBQcml2YXRlS2V5SW5mby4gKi9cbiAgICAgICAgYmFnQXNuMSA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYmFnQXNuMSwgcGFzc3dvcmQpO1xuICAgICAgICBpZihiYWdBc24xID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1VuYWJsZSB0byBkZWNyeXB0IFBLQ1MjOCBTaHJvdWRlZEtleUJhZywgd3JvbmcgcGFzc3dvcmQ/Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgcGtpLm9pZHMua2V5QmFnOlxuICAgICAgICAvKiBBIFBLQ1MjMTIga2V5QmFnIGlzIGEgc2ltcGxlIFByaXZhdGVLZXlJbmZvIGFzIHVuZGVyc3Rvb2QgYnkgb3VyXG4gICAgICAgICAgIFBLSSBtb2R1bGUsIGhlbmNlIHdlIGRvbid0IGhhdmUgdG8gZG8gdmFsaWRhdGlvbi9jYXB0dXJpbmcgaGVyZSxcbiAgICAgICAgICAganVzdCBwYXNzIHdoYXQgd2UgYWxyZWFkeSBnb3QuICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYmFnLmtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoYmFnQXNuMSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSB1bmtub3duIGtleSB0eXBlLCBwYXNzIGFzbjEgdmFsdWVcbiAgICAgICAgICBiYWcua2V5ID0gbnVsbDtcbiAgICAgICAgICBiYWcuYXNuMSA9IGJhZ0FzbjE7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7ICAvKiBOb3RoaW5nIG1vcmUgdG8gZG8uICovXG5cbiAgICAgIGNhc2UgcGtpLm9pZHMuY2VydEJhZzpcbiAgICAgICAgLyogQSBQS0NTIzEyIGNlcnRCYWcgY2FuIHdyYXAgYm90aCBYLjUwOSBhbmQgc2RzaSBjZXJ0aWZpY2F0ZXMuXG4gICAgICAgICAgIFRoZXJlZm9yZSBwdXQgdGhlIFNhZmVCYWcgY29udGVudCB0aHJvdWdoIGFub3RoZXIgdmFsaWRhdG9yIHRvXG4gICAgICAgICAgIGNhcHR1cmUgdGhlIGZpZWxkcy4gIEFmdGVyd2FyZHMgY2hlY2sgJiBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICAgICAgdmFsaWRhdG9yID0gY2VydEJhZ1ZhbGlkYXRvcjtcbiAgICAgICAgZGVjb2RlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0SWQpICE9PSBwa2kub2lkcy54NTA5Q2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1Vuc3VwcG9ydGVkIGNlcnRpZmljYXRlIHR5cGUsIG9ubHkgWC41MDkgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRJZCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0cnVlPXByb2R1Y2UgY2VydCBoYXNoXG4gICAgICAgICAgdmFyIGNlcnRBc24xID0gYXNuMS5mcm9tRGVyKGNhcHR1cmUuY2VydCwgc3RyaWN0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmFnLmNlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tQXNuMShjZXJ0QXNuMSwgdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBjZXJ0IHR5cGUsIHBhc3MgYXNuMSB2YWx1ZVxuICAgICAgICAgICAgYmFnLmNlcnQgPSBudWxsO1xuICAgICAgICAgICAgYmFnLmFzbjEgPSBjZXJ0QXNuMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBLQ1MjMTIgU2FmZUJhZyB0eXBlLicpO1xuICAgICAgICBlcnJvci5vaWQgPSBiYWcudHlwZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLyogVmFsaWRhdGUgU2FmZUJhZyB2YWx1ZSAoaS5lLiBDZXJ0QmFnLCBldGMuKSBhbmQgY2FwdHVyZSBkYXRhIGlmIG5lZWRlZC4gKi9cbiAgICBpZih2YWxpZGF0b3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICFhc24xLnZhbGlkYXRlKGJhZ0FzbjEsIHZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyICcgKyB2YWxpZGF0b3IubmFtZSk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvKiBDYWxsIGRlY29kZXIgZnVuY3Rpb24gZnJvbSBhYm92ZSB0byBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICBkZWNvZGVyKCk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNFVCBPRiBQS0NTMTJBdHRyaWJ1dGUgaW50byBKYXZhU2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIChBU04uMSBvYmplY3QpLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUJhZ0F0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICB2YXIgZGVjb2RlZEF0dHJzID0ge307XG5cbiAgaWYoYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZighYXNuMS52YWxpZGF0ZShhdHRyaWJ1dGVzW2ldLCBhdHRyaWJ1dGVWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyIEJhZ0F0dHJpYnV0ZS4nKTtcbiAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5vaWQpO1xuICAgICAgaWYocGtpLm9pZHNbb2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlLCBpZ25vcmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0gPSBbXTtcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBjYXB0dXJlLnZhbHVlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0ucHVzaChjYXB0dXJlLnZhbHVlc1tqXS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZWRBdHRycztcbn1cblxuLyoqXG4gKiBXcmFwcyBhIHByaXZhdGUga2V5IGFuZCBjZXJ0aWZpY2F0ZSBpbiBhIFBLQ1MjMTIgUEZYIHdyYXBwZXIuIElmIGFcbiAqIHBhc3N3b3JkIGlzIHByb3ZpZGVkIHRoZW4gdGhlIHByaXZhdGUga2V5IHdpbGwgYmUgZW5jcnlwdGVkLlxuICpcbiAqIEFuIGVudGlyZSBjZXJ0aWZpY2F0ZSBjaGFpbiBtYXkgYWxzbyBiZSBpbmNsdWRlZC4gVG8gZG8gdGhpcywgcGFzc1xuICogYW4gYXJyYXkgZm9yIHRoZSBcImNlcnRcIiBwYXJhbWV0ZXIgd2hlcmUgdGhlIGZpcnN0IGNlcnRpZmljYXRlIGlzXG4gKiB0aGUgb25lIHRoYXQgaXMgcGFpcmVkIHdpdGggdGhlIHByaXZhdGUga2V5IGFuZCBlYWNoIHN1YnNlcXVlbnQgb25lXG4gKiB2ZXJpZmllcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgY2VydGlmaWNhdGVzIG1heSBiZSBpbiBQRU0gZm9ybWF0IG9yXG4gKiBoYXZlIGJlZW4gYWxyZWFkeSBwYXJzZWQgYnkgRm9yZ2UuXG4gKlxuICogQHRvZG8gaW1wbGVtZW50IHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gZm9yIHRoZSB3aG9sZSBwYWNrYWdlXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgKG1heSBiZSBhbiBhcnJheSBvZiBjZXJ0aWZpY2F0ZXMgaW4gb3JkZXJcbiAqICAgICAgICAgIHRvIHNwZWNpZnkgYSBjZXJ0aWZpY2F0ZSBjaGFpbikuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdhZXMxMjgnLCAnYWVzMTkyJywgJ2FlczI1NicsICczZGVzJyksIGRlZmF1bHRzIHRvICdhZXMxMjgnLlxuICogICAgICAgICAgY291bnQgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZSB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIHVzZU1hYyB0cnVlIHRvIGluY2x1ZGUgYSBNQUMsIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqICAgICAgICAgIGxvY2FsS2V5SWQgdGhlIGxvY2FsIGtleSBJRCB0byB1c2UsIGluIGhleC5cbiAqICAgICAgICAgIGZyaWVuZGx5TmFtZSB0aGUgZnJpZW5kbHkgbmFtZSB0byB1c2UuXG4gKiAgICAgICAgICBnZW5lcmF0ZUxvY2FsS2V5SWQgdHJ1ZSB0byBnZW5lcmF0ZSBhIHJhbmRvbSBsb2NhbCBrZXkgSUQsXG4gKiAgICAgICAgICAgIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQS0NTIzEyIFBGWCBBU04uMSBvYmplY3QuXG4gKi9cbnAxMi50b1BrY3MxMkFzbjEgPSBmdW5jdGlvbihrZXksIGNlcnQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc2FsdFNpemUgPSBvcHRpb25zLnNhbHRTaXplIHx8IDg7XG4gIG9wdGlvbnMuY291bnQgPSBvcHRpb25zLmNvdW50IHx8IDIwNDg7XG4gIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgb3B0aW9ucy5lbmNBbGdvcml0aG0gfHwgJ2FlczEyOCc7XG4gIGlmKCEoJ3VzZU1hYycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnVzZU1hYyA9IHRydWU7XG4gIH1cbiAgaWYoISgnbG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmxvY2FsS2V5SWQgPSBudWxsO1xuICB9XG4gIGlmKCEoJ2dlbmVyYXRlTG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmdlbmVyYXRlTG9jYWxLZXlJZCA9IHRydWU7XG4gIH1cblxuICB2YXIgbG9jYWxLZXlJZCA9IG9wdGlvbnMubG9jYWxLZXlJZDtcbiAgdmFyIGJhZ0F0dHJzO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgbG9jYWxLZXlJZCA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhsb2NhbEtleUlkKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZ2VuZXJhdGVMb2NhbEtleUlkKSB7XG4gICAgLy8gdXNlIFNIQS0xIG9mIHBhaXJlZCBjZXJ0LCBpZiBhdmFpbGFibGVcbiAgICBpZihjZXJ0KSB7XG4gICAgICB2YXIgcGFpcmVkQ2VydCA9IGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSA/IGNlcnRbMF0gOiBjZXJ0O1xuICAgICAgaWYodHlwZW9mIHBhaXJlZENlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhaXJlZENlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tUGVtKHBhaXJlZENlcnQpO1xuICAgICAgfVxuICAgICAgdmFyIHNoYTEgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgc2hhMS51cGRhdGUoYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEocGFpcmVkQ2VydCkpLmdldEJ5dGVzKCkpO1xuICAgICAgbG9jYWxLZXlJZCA9IHNoYTEuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IGNvbnNpZGVyIHVzaW5nIFNIQS0xIG9mIHB1YmxpYyBrZXkgKHdoaWNoIGNhbiBiZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGZyb20gcHJpdmF0ZSBrZXkgY29tcG9uZW50cyksIHNlZTogY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyXG4gICAgICAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXNcbiAgICAgIGxvY2FsS2V5SWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoMjApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRycyA9IFtdO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgYXR0cnMucHVzaChcbiAgICAgIC8vIGxvY2FsS2V5SURcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYXR0cklkXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmxvY2FsS2V5SWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgICBsb2NhbEtleUlkKVxuICAgICAgICBdKVxuICAgICAgXSkpO1xuICB9XG4gIGlmKCdmcmllbmRseU5hbWUnIGluIG9wdGlvbnMpIHtcbiAgICBhdHRycy5wdXNoKFxuICAgICAgLy8gZnJpZW5kbHlOYW1lXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGF0dHJJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5mcmllbmRseU5hbWUpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CTVBTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9ucy5mcmllbmRseU5hbWUpXG4gICAgICAgIF0pXG4gICAgICBdKSk7XG4gIH1cblxuICBpZihhdHRycy5sZW5ndGggPiAwKSB7XG4gICAgYmFnQXR0cnMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgYXR0cnMpO1xuICB9XG5cbiAgLy8gY29sbGVjdCBjb250ZW50cyBmb3IgQXV0aGVudGljYXRlZFNhZmVcbiAgdmFyIGNvbnRlbnRzID0gW107XG5cbiAgLy8gY3JlYXRlIHNhZmUgYmFnKHMpIGZvciBjZXJ0aWZpY2F0ZSBjaGFpblxuICB2YXIgY2hhaW4gPSBbXTtcbiAgaWYoY2VydCAhPT0gbnVsbCkge1xuICAgIGlmKGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSkge1xuICAgICAgY2hhaW4gPSBjZXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFpbiA9IFtjZXJ0XTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2VydFNhZmVCYWdzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjaGFpbi5sZW5ndGg7ICsraSkge1xuICAgIC8vIGNvbnZlcnQgY2VydCBmcm9tIFBFTSBhcyBuZWNlc3NhcnlcbiAgICBjZXJ0ID0gY2hhaW5baV07XG4gICAgaWYodHlwZW9mIGNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjZXJ0ID0gcGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICB9XG5cbiAgICAvLyBTYWZlQmFnXG4gICAgdmFyIGNlcnRCYWdBdHRycyA9IChpID09PSAwKSA/IGJhZ0F0dHJzIDogdW5kZWZpbmVkO1xuICAgIHZhciBjZXJ0QXNuMSA9IHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KTtcbiAgICB2YXIgY2VydFNhZmVCYWcgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5jZXJ0QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gQ2VydEJhZ1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIC8vIGNlcnRJZFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLng1MDlDZXJ0aWZpY2F0ZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgICAvLyBjZXJ0VmFsdWUgKHg1MDlDZXJ0aWZpY2F0ZSlcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLnRvRGVyKGNlcnRBc24xKS5nZXRCeXRlcygpKVxuICAgICAgICAgICAgXSldKV0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgY2VydEJhZ0F0dHJzXG4gICAgICBdKTtcbiAgICBjZXJ0U2FmZUJhZ3MucHVzaChjZXJ0U2FmZUJhZyk7XG4gIH1cblxuICBpZihjZXJ0U2FmZUJhZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBjZXJ0U2FmZUNvbnRlbnRzID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBjZXJ0U2FmZUJhZ3MpO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIgY2VydENJID1cbiAgICAgIC8vIFBLQ1MjNyBDb250ZW50SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBjb250ZW50VHlwZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEudG9EZXIoY2VydFNhZmVDb250ZW50cykuZ2V0Qnl0ZXMoKSlcbiAgICAgICAgXSlcbiAgICAgIF0pO1xuICAgIGNvbnRlbnRzLnB1c2goY2VydENJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBzYWZlIGNvbnRlbnRzIGZvciBwcml2YXRlIGtleVxuICB2YXIga2V5QmFnID0gbnVsbDtcbiAgaWYoa2V5ICE9PSBudWxsKSB7XG4gICAgLy8gU2FmZUJhZ1xuICAgIHZhciBwa0FzbjEgPSBwa2kud3JhcFJzYVByaXZhdGVLZXkocGtpLnByaXZhdGVLZXlUb0FzbjEoa2V5KSk7XG4gICAgaWYocGFzc3dvcmQgPT09IG51bGwpIHtcbiAgICAgIC8vIG5vIGVuY3J5cHRpb25cbiAgICAgIGtleUJhZyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYmFnSWRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMua2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa0FzbjFcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGJhZ0F0dHJpYnV0ZXMgKE9QVElPTkFMKVxuICAgICAgICBiYWdBdHRyc1xuICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuY3J5cHRlZCBQcml2YXRlS2V5SW5mb1xuICAgICAga2V5QmFnID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5wa2NzOFNocm91ZGVkS2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa2kuZW5jcnlwdFByaXZhdGVLZXlJbmZvKHBrQXNuMSwgcGFzc3dvcmQsIG9wdGlvbnMpXG4gICAgICAgIF0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgYmFnQXR0cnNcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBrZXlTYWZlQ29udGVudHMgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW2tleUJhZ10pO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIga2V5Q0kgPVxuICAgICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGNvbnRlbnRUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAvLyBPSUQgZm9yIHRoZSBjb250ZW50IHR5cGUgaXMgJ2RhdGEnXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5kYXRhKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gY29udGVudFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS50b0RlcihrZXlTYWZlQ29udGVudHMpLmdldEJ5dGVzKCkpXG4gICAgICAgIF0pXG4gICAgICBdKTtcbiAgICBjb250ZW50cy5wdXNoKGtleUNJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBBdXRoZW50aWNhdGVkU2FmZSBieSBzdHJpbmdpbmcgdG9nZXRoZXIgdGhlIGNvbnRlbnRzXG4gIHZhciBzYWZlID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgY29udGVudHMpO1xuXG4gIHZhciBtYWNEYXRhO1xuICBpZihvcHRpb25zLnVzZU1hYykge1xuICAgIC8vIE1hY0RhdGFcbiAgICB2YXIgc2hhMSA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIG1hY1NhbHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKFxuICAgICAgZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG9wdGlvbnMuc2FsdFNpemUpKTtcbiAgICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgIC8vIDE2MC1iaXQga2V5XG4gICAgdmFyIGtleSA9IHAxMi5nZW5lcmF0ZUtleShwYXNzd29yZCwgbWFjU2FsdCwgMywgY291bnQsIDIwKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQoc2hhMSwga2V5KTtcbiAgICBtYWMudXBkYXRlKGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIG1hY1ZhbHVlID0gbWFjLmdldE1hYygpO1xuICAgIG1hY0RhdGEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBtYWMgRGlnZXN0SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBkaWdlc3RBbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIGFsZ29yaXRobSA9IFNIQS0xXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5zaGExKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAvLyBwYXJhbWV0ZXJzID0gTnVsbFxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgICBdKSxcbiAgICAgICAgLy8gZGlnZXN0XG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgICAgZmFsc2UsIG1hY1ZhbHVlLmdldEJ5dGVzKCkpXG4gICAgICBdKSxcbiAgICAgIC8vIG1hY1NhbHQgT0NURVQgU1RSSU5HXG4gICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIG1hY1NhbHQuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBpdGVyYXRpb25zIElOVEVHRVIgKFhYWDogT25seSBzdXBwb3J0IGNvdW50IDwgNjU1MzYpXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0Rlcihjb3VudCkuZ2V0Qnl0ZXMoKVxuICAgICAgKVxuICAgIF0pO1xuICB9XG5cbiAgLy8gUEZYXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMykuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gY29udGVudFR5cGVcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmRhdGEpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gY29udGVudFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgIGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSlcbiAgICAgIF0pXG4gICAgXSksXG4gICAgbWFjRGF0YVxuICBdKTtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucDEyLmdlbmVyYXRlS2V5ID0gZm9yZ2UucGJlLmdlbmVyYXRlUGtjczEyS2V5O1xuXG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFTTi4xIHZhbGlkYXRvcnMgZm9yIFBLQ1MjNyB2MS41LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgUEtDUyM3IGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDICMyMzE1IGZvciBkZXRhaWxzLCBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzE1LnR4dCk6XG4gKlxuICogQSBQS0NTIzcgbWVzc2FnZSBjb25zaXN0cyBvZiBhIENvbnRlbnRJbmZvIG9uIHJvb3QgbGV2ZWwsIHdoaWNoIG1heVxuICogY29udGFpbiBhbnkgbnVtYmVyIG9mIGZ1cnRoZXIgQ29udGVudEluZm8gbmVzdGVkIGludG8gaXQuXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgICAgICAgICAgICBbMF0gIEVYUExJQ0lUIEFOWSBERUZJTkVEIEJZIGNvbnRlbnRUeXBlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudFR5cGUgOjo9IE9CSkVDVCBJREVOVElGSUVSXG4gKlxuICogRW52ZWxvcGVkRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICByZWNpcGllbnRJbmZvcyAgICAgICAgICAgICBSZWNpcGllbnRJbmZvcyxcbiAqICAgZW5jcnlwdGVkQ29udGVudEluZm8gICAgICAgRW5jcnlwdGVkQ29udGVudEluZm9cbiAqIH1cbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGVuY3J5cHRlZENvbnRlbnRJbmZvICAgICAgIEVuY3J5cHRlZENvbnRlbnRJbmZvXG4gKiB9XG4gKlxuICogaWQtc2lnbmVkRGF0YSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0geyBpc28oMSkgbWVtYmVyLWJvZHkoMilcbiAqICAgdXMoODQwKSByc2Fkc2koMTEzNTQ5KSBwa2NzKDEpIHBrY3M3KDcpIDIgfVxuICpcbiAqIFNpZ25lZERhdGEgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgSU5URUdFUixcbiAqICAgZGlnZXN0QWxnb3JpdGhtcyAgRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMsXG4gKiAgIGNvbnRlbnRJbmZvICAgICAgIENvbnRlbnRJbmZvLFxuICogICBjZXJ0aWZpY2F0ZXMgICAgICBbMF0gSU1QTElDSVQgQ2VydGlmaWNhdGVzIE9QVElPTkFMLFxuICogICBjcmxzICAgICAgICAgICAgICBbMV0gSU1QTElDSVQgQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMgT1BUSU9OQUwsXG4gKiAgIHNpZ25lckluZm9zICAgICAgIFNpZ25lckluZm9zXG4gKiB9XG4gKlxuICogU2lnbmVySW5mb3MgOjo9IFNFVCBPRiBTaWduZXJJbmZvXG4gKlxuICogU2lnbmVySW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICBpc3N1ZXJBbmRTZXJpYWxOdW1iZXIgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGRpZ2VzdEFsZ29yaXRobSAgICAgICAgICAgIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICAgIFswXSBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMLFxuICogICBkaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtICBEaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGlnZXN0ICAgICAgICAgICAgRW5jcnlwdGVkRGlnZXN0LFxuICogICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICBbMV0gSU1QTElDSVQgQXR0cmlidXRlcyBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEF0dHJpYnV0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICBhdHRyVHlwZSAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgYXR0clZhbHVlcyAgU0VUIE9GIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqXG4gKiBSZWNpcGllbnRJbmZvcyA6Oj0gU0VUIE9GIFJlY2lwaWVudEluZm9cbiAqXG4gKiBFbmNyeXB0ZWRDb250ZW50SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjb250ZW50VHlwZSAgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtICBDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGVuY3J5cHRlZENvbnRlbnQgICAgICAgWzBdICBJTVBMSUNJVCBFbmNyeXB0ZWRDb250ZW50IE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIEFFUyBhbmQgREVTMywgdGhlcmUgaXMgb25seSBvbmUsXG4gKiB0aGUgSVYuXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZENvbnRlbnQgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIFJlY2lwaWVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGlzc3VlckFuZFNlcmlhbE51bWJlciAgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGtleUVuY3J5cHRpb25BbGdvcml0aG0gICAgICBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkS2V5ICAgICAgICAgICAgICAgIEVuY3J5cHRlZEtleVxuICogfVxuICpcbiAqIElzc3VlckFuZFNlcmlhbE51bWJlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBpc3N1ZXIgICAgICAgICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgICAgICAgIENlcnRpZmljYXRlU2VyaWFsTnVtYmVyXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZEtleSA6Oj0gT0NURVQgU1RSSU5HXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gc2hvcnRjdXQgZm9yIEFTTi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vLyBzaG9ydGN1dCBmb3IgUEtDUyM3IEFQSVxudmFyIHA3diA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtjczdhc24xID0gZm9yZ2UucGtjczdhc24xIHx8IHt9O1xuZm9yZ2UucGtjczcgPSBmb3JnZS5wa2NzNyB8fCB7fTtcbmZvcmdlLnBrY3M3LmFzbjEgPSBwN3Y7XG5cbnZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ29udGVudEluZm8uQ29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAwLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY29udGVudCdcbiAgfV1cbn07XG5wN3YuY29udGVudEluZm9WYWxpZGF0b3IgPSBjb250ZW50SW5mb1ZhbGlkYXRvcjtcblxudmFyIGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50VHlwZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdjb250ZW50VHlwZSdcbiAgfSwge1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNBbGdvcml0aG0nXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvLmNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtLnBhcmFtZXRlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICBjYXB0dXJlQXNuMTogJ2VuY1BhcmFtZXRlcidcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvLmVuY3J5cHRlZENvbnRlbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICAvKiBUaGUgUEtDUyM3IHN0cnVjdHVyZSBvdXRwdXQgYnkgT3BlblNTTCBzb21ld2hhdCBkaWZmZXJzIGZyb20gd2hhdFxuICAgICAqIG90aGVyIGltcGxlbWVudGF0aW9ucyBkbyBnZW5lcmF0ZS5cbiAgICAgKlxuICAgICAqIE9wZW5TU0wgZ2VuZXJhdGVzIGEgc3RydWN0dXJlIGxpa2UgdGhpczpcbiAgICAgKiBTRVFVRU5DRSB7XG4gICAgICogICAgLi4uXG4gICAgICogICAgWzBdXG4gICAgICogICAgICAgMjYgREEgNjcgRDIgMTcgOUMgNDUgM0MgQjEgMkEgQTggNTkgMkYgMjkgMzMgMzhcbiAgICAgKiAgICAgICBDMyBDMyBERiA4NiA3MSA3NCA3QSAxOSA5RiA0MCBEMCAyOSBCRSA4NSA5MCA0NVxuICAgICAqICAgICAgIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFdoZXJlYXMgb3RoZXIgaW1wbGVtZW50YXRpb25zIChhbmQgdGhpcyBQS0NTIzcgbW9kdWxlKSBnZW5lcmF0ZTpcbiAgICAgKiBTRVFVRU5DRSB7XG4gICAgICogICAgLi4uXG4gICAgICogICAgWzBdIHtcbiAgICAgKiAgICAgICBPQ1RFVCBTVFJJTkdcbiAgICAgKiAgICAgICAgICAyNiBEQSA2NyBEMiAxNyA5QyA0NSAzQyBCMSAyQSBBOCA1OSAyRiAyOSAzMyAzOFxuICAgICAqICAgICAgICAgIEMzIEMzIERGIDg2IDcxIDc0IDdBIDE5IDlGIDQwIEQwIDI5IEJFIDg1IDkwIDQ1XG4gICAgICogICAgICAgICAgLi4uXG4gICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIHN1cHBvcnQgYm90aCwgd2UganVzdCBjYXB0dXJlIHRoZSBjb250ZXh0IHNwZWNpZmljXG4gICAgICogZmllbGQgaGVyZS4gIFRoZSBPQ1RFVCBTVFJJTkcgYml0IGlzIHJlbW92ZWQgYmVsb3cuXG4gICAgICovXG4gICAgY2FwdHVyZTogJ2VuY3J5cHRlZENvbnRlbnQnLFxuICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGVkQ29udGVudEFzbjEnXG4gIH1dXG59O1xuXG5wN3YuZW52ZWxvcGVkRGF0YVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VudmVsb3BlZERhdGEnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdFbnZlbG9wZWREYXRhLlZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAnRW52ZWxvcGVkRGF0YS5SZWNpcGllbnRJbmZvcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdyZWNpcGllbnRJbmZvcydcbiAgfV0uY29uY2F0KGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yKVxufTtcblxucDd2LmVuY3J5cHRlZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbmNyeXB0ZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9XS5jb25jYXQoZW5jcnlwdGVkQ29udGVudEluZm9WYWxpZGF0b3IpXG59O1xuXG52YXIgc2lnbmVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnU2lnbmVySW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1NpZ25lckluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1NpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnaXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlci5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2VyaWFsJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZGlnZXN0QWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdkaWdlc3RQYXJhbWV0ZXInLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmU6ICdzaWduYXR1cmVBbGdvcml0aG0nXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5lbmNyeXB0ZWREaWdlc3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzaWduYXR1cmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby51bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ3VuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnXG4gIH1dXG59O1xuXG5wN3Yuc2lnbmVkRGF0YVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1NpZ25lZERhdGEnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTaWduZWREYXRhLlZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5EaWdlc3RBbGdvcml0aG1zJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2RpZ2VzdEFsZ29yaXRobXMnXG4gIH0sXG4gIGNvbnRlbnRJbmZvVmFsaWRhdG9yLFxuICB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuQ2VydGlmaWNhdGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0ZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5DZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0cycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY3JscydcbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZWREYXRhLlNpZ25lckluZm9zJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjYXB0dXJlOiAnc2lnbmVySW5mb3MnLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbc2lnbmVyVmFsaWRhdG9yXVxuICB9XVxufTtcblxucDd2LnJlY2lwaWVudEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdSZWNpcGllbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnaXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2VyaWFsJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5rZXlFbmNyeXB0aW9uQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNBbGdvcml0aG0nXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdlbmNQYXJhbWV0ZXInXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmVuY3J5cHRlZEtleScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2VuY0tleSdcbiAgfV1cbn07XG5cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIE5vZGUuanMgbW9kdWxlIGZvciBGb3JnZSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKlxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZiA9IGZvcmdlLm1nZiB8fCB7fTtcbmZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMTtcblxuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gTUdGMS5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZm9yZ2UubWdmID0gZm9yZ2UubWdmIHx8IHt9O1xudmFyIG1nZjEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMSA9IGZvcmdlLm1nZjEgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIE1HRjEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IEFQSSB0byB1c2UgKGVnOiBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpKS5cbiAqXG4gKiBAcmV0dXJuIGEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqL1xubWdmMS5jcmVhdGUgPSBmdW5jdGlvbihtZCkge1xuICB2YXIgbWdmID0ge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG1hc2sgb2Ygc3BlY2lmaWVkIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWVkIFRoZSBzZWVkIGZvciBtYXNrIGdlbmVyYXRpb24uXG4gICAgICogQHBhcmFtIG1hc2tMZW4gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCBtYXNrLlxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihzZWVkLCBtYXNrTGVuKSB7XG4gICAgICAvKiAyLiBMZXQgVCBiZSB0aGUgZW1wdHkgb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgdmFyIHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgICAgIC8qIDMuIEZvciBjb3VudGVyIGZyb20gMCB0byBjZWlsKG1hc2tMZW4gLyBoTGVuKSwgZG8gdGhlIGZvbGxvd2luZzogKi9cbiAgICAgIHZhciBsZW4gPSBNYXRoLmNlaWwobWFza0xlbiAvIG1kLmRpZ2VzdExlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLyogYS4gQ29udmVydCBjb3VudGVyIHRvIGFuIG9jdGV0IHN0cmluZyBDIG9mIGxlbmd0aCA0IG9jdGV0cyAqL1xuICAgICAgICB2YXIgYyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgICAgYy5wdXRJbnQzMihpKTtcblxuICAgICAgICAvKiBiLiBDb25jYXRlbmF0ZSB0aGUgaGFzaCBvZiB0aGUgc2VlZCBtZ2ZTZWVkIGFuZCBDIHRvIHRoZSBvY3RldFxuICAgICAgICAgKiBzdHJpbmcgVDogKi9cbiAgICAgICAgbWQuc3RhcnQoKTtcbiAgICAgICAgbWQudXBkYXRlKHNlZWQgKyBjLmdldEJ5dGVzKCkpO1xuICAgICAgICB0LnB1dEJ1ZmZlcihtZC5kaWdlc3QoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qIE91dHB1dCB0aGUgbGVhZGluZyBtYXNrTGVuIG9jdGV0cyBvZiBUIGFzIHRoZSBvY3RldCBzdHJpbmcgbWFzay4gKi9cbiAgICAgIHQudHJ1bmNhdGUodC5sZW5ndGgoKSAtIG1hc2tMZW4pO1xuICAgICAgcmV0dXJuIHQuZ2V0Qnl0ZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIG1nZjtcbn07XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9