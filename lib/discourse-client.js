(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("discourse-client", [], factory);
	else if(typeof exports === 'object')
		exports["discourse-client"] = factory();
	else
		root["discourse-client"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"discourse-client.js": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// The chunk loading function for additional chunks
/******/ 	// Since all referenced chunks are already included
/******/ 	// in this file, this function is empty here.
/******/ 	__webpack_require__.e = function requireEnsure() {
/******/ 		return Promise.resolve();
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonpdiscourse_client"] = window["webpackJsonpdiscourse_client"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/discourse.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@ungap/url-search-params/esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ungap/url-search-params/esm/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*! (c) Andrea Giammarchi - ISC */
var self = undefined || /* istanbul ignore next */ {};
try {
  (function (URLSearchParams, plus) {
    if (
      new URLSearchParams('q=%2B').get('q') !== plus ||
      new URLSearchParams({q: plus}).get('q') !== plus ||
      new URLSearchParams([['q', plus]]).get('q') !== plus ||
      new URLSearchParams('q=\n').toString() !== 'q=%0A' ||
      new URLSearchParams({q: ' &'}).toString() !== 'q=+%26'
    )
      throw URLSearchParams;
    self.URLSearchParams = URLSearchParams;
  }(URLSearchParams, '+'));
} catch(URLSearchParams) {
  (function (Object, String, isArray) {'use strict';
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var find = /[!'\(\)~]|%20|%00/g;
    var plus = /\+/g;
    var replace = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    var proto = {
      append: function (key, value) {
        appendTo(this._ungap, key, value);
      },
      delete: function (key) {
        delete this._ungap[key];
      },
      get: function (key) {
        return this.has(key) ? this._ungap[key][0] : null;
      },
      getAll: function (key) {
        return this.has(key) ? this._ungap[key].slice(0) : [];
      },
      has: function (key) {
        return key in this._ungap;
      },
      set: function (key, value) {
        this._ungap[key] = [String(value)];
      },
      forEach: function (callback, thisArg) {
        var self = this;
        for (var key in self._ungap)
          self._ungap[key].forEach(invoke, key);
        function invoke(value) {
          callback.call(thisArg, value, String(key), self);
        }
      },
      toJSON: function () {
        return {};
      },
      toString: function () {
        var query = [];
        for (var key in this._ungap) {
          var encoded = encode(key);
          for (var
            i = 0,
            value = this._ungap[key];
            i < value.length; i++
          ) {
            query.push(encoded + '=' + encode(value[i]));
          }
        }
        return query.join('&');
      }
    };
    for (var key in proto)
      defineProperty(URLSearchParams.prototype, key, {
        configurable: true,
        writable: true,
        value: proto[key]
      });
    self.URLSearchParams = URLSearchParams;
    function URLSearchParams(query) {
      var dict = create(null);
      defineProperty(this, '_ungap', {value: dict});
      switch (true) {
        case !query:
          break;
        case typeof query === 'string':
          if (query.charAt(0) === '?') {
            query = query.slice(1);
          }
          for (var
            pairs = query.split('&'),
            i = 0,
            length = pairs.length; i < length; i++
          ) {
            var value = pairs[i];
            var index = value.indexOf('=');
            if (-1 < index) {
              appendTo(
                dict,
                decode(value.slice(0, index)),
                decode(value.slice(index + 1))
              );
            } else if (value.length){
              appendTo(
                dict,
                decode(value),
                ''
              );
            }
          }
          break;
        case isArray(query):
          for (var
            i = 0,
            length = query.length; i < length; i++
          ) {
            var value = query[i];
            appendTo(dict, value[0], value[1]);
          }
          break;
        case 'forEach' in query:
          query.forEach(addEach, dict);
          break;
        default:
          for (var key in query)
            appendTo(dict, key, query[key]);
      }
    }

    function addEach(value, key) {
      appendTo(this, key, value);
    }
    
    function appendTo(dict, key, value) {
      var res = isArray(value) ? value.join(',') : value;
      if (key in dict)
        dict[key].push(res);
      else
        dict[key] = [res];
    }
    
    function decode(str) {
      return decodeURIComponent(str.replace(plus, ' '));
    }
    
    function encode(str) {
      return encodeURIComponent(str).replace(find, replacer);
    }

    function replacer(match) {
      return replace[match];
    }

  }(Object, String, Array.isArray));
}

(function (URLSearchParamsProto) {

  var iterable = false;
  try { iterable = !!Symbol.iterator; } catch (o_O) {}

  /* istanbul ignore else */
  if (!('forEach' in URLSearchParamsProto)) {
    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
      var self = this;
      var names = Object.create(null);
      this.toString()
          .replace(/=[\s\S]*?(?:&|$)/g, '=')
          .split('=')
          .forEach(function (name) {
            if (!name.length || name in names)
              return;
            (names[name] = self.getAll(name)).forEach(function(value) {
              callback.call(thisArg, value, name, self);
            });
          });
    };
  }

  /* istanbul ignore else */
  if (!('keys' in URLSearchParamsProto)) {
    URLSearchParamsProto.keys = function keys() {
      return iterator(this, function(value, key) { this.push(key); });
    };
  }

   /* istanbul ignore else */
  if (!('values' in URLSearchParamsProto)) {
    URLSearchParamsProto.values = function values() {
      return iterator(this, function(value, key) { this.push(value); });
    };
  }

  /* istanbul ignore else */
  if (!('entries' in URLSearchParamsProto)) {
    URLSearchParamsProto.entries = function entries() {
      return iterator(this, function(value, key) { this.push([key, value]); });
    };
  }

  /* istanbul ignore else */
  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {
    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
  }

  /* istanbul ignore else */
  if (!('sort' in URLSearchParamsProto)) {
    URLSearchParamsProto.sort = function sort() {
      var
        entries = this.entries(),
        entry = entries.next(),
        done = entry.done,
        keys = [],
        values = Object.create(null),
        i, key, value
      ;
      while (!done) {
        value = entry.value;
        key = value[0];
        keys.push(key);
        if (!(key in values)) {
          values[key] = [];
        }
        values[key].push(value[1]);
        entry = entries.next();
        done = entry.done;
      }
      // not the champion in efficiency
      // but these two bits just do the job
      keys.sort();
      for (i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        this.append(key, values[key].shift());
      }
    };
  }

  function iterator(self, callback) {
    var items = [];
    self.forEach(callback, items);
    return iterable ?
      items[Symbol.iterator]() :
      {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value};
        }
      };
  }

  /* istanbul ignore next */
  (function (Object) {
    var
      dP = Object.defineProperty,
      gOPD = Object.getOwnPropertyDescriptor,
      createSearchParamsPollute = function (search) {
        function append(name, value) {
          URLSearchParamsProto.append.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function del(name) {
          URLSearchParamsProto.delete.call(this, name);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function set(name, value) {
          URLSearchParamsProto.set.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        return function (sp, value) {
          sp.append = append;
          sp.delete = del;
          sp.set = set;
          return dP(sp, '_usp', {
            configurable: true,
            writable: true,
            value: value
          });
        };
      },
      createSearchParamsCreate = function (polluteSearchParams) {
        return function (obj, sp) {
          dP(
            obj, '_searchParams', {
              configurable: true,
              writable: true,
              value: polluteSearchParams(sp, obj)
            }
          );
          return sp;
        };
      },
      updateSearchParams = function (sp) {
        var append = sp.append;
        sp.append = URLSearchParamsProto.append;
        URLSearchParams.call(sp, sp._usp.search.slice(1));
        sp.append = append;
      },
      verifySearchParams = function (obj, Class) {
        if (!(obj instanceof Class)) throw new TypeError(
          "'searchParams' accessed on an object that " +
          "does not implement interface " + Class.name
        );
      },
      upgradeClass = function (Class) {
        var
          ClassProto = Class.prototype,
          searchParams = gOPD(ClassProto, 'searchParams'),
          href = gOPD(ClassProto, 'href'),
          search = gOPD(ClassProto, 'search'),
          createSearchParams
        ;
        if (!searchParams && search && search.set) {
          createSearchParams = createSearchParamsCreate(
            createSearchParamsPollute(search)
          );
          Object.defineProperties(
            ClassProto,
            {
              href: {
                get: function () {
                  return href.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  href.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              search: {
                get: function () {
                  return search.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  search.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              searchParams: {
                get: function () {
                  verifySearchParams(this, Class);
                  return this._searchParams || createSearchParams(
                    this,
                    new URLSearchParams(this.search.slice(1))
                  );
                },
                set: function (sp) {
                  verifySearchParams(this, Class);
                  createSearchParams(this, sp);
                }
              }
            }
          );
        }
      }
    ;
    try {
      upgradeClass(HTMLAnchorElement);
      if (/^function|object$/.test(typeof URL) && URL.prototype)
        upgradeClass(URL);
    } catch (meh) {}
  }(Object));

}(self.URLSearchParams.prototype, Object));
/* harmony default export */ __webpack_exports__["default"] = (self.URLSearchParams);


/***/ }),

/***/ "./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cacheAdapterEnhancer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buildSortedURL */ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js");
/* harmony import */ var _utils_isCacheLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/isCacheLike */ "./node_modules/axios-extensions/esm/utils/isCacheLike.js");
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-12
 */




var FIVE_MINUTES = 1000 * 60 * 5;
var CAPACITY = 100;
function cacheAdapterEnhancer(adapter, options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    var _a = options.enabledByDefault, enabledByDefault = _a === void 0 ? true : _a, _b = options.cacheFlag, cacheFlag = _b === void 0 ? 'cache' : _b, _c = options.defaultCache, defaultCache = _c === void 0 ? new lru_cache__WEBPACK_IMPORTED_MODULE_1___default.a({ maxAge: FIVE_MINUTES, max: CAPACITY }) : _c;
    return function (config) {
        var url = config.url, method = config.method, params = config.params, paramsSerializer = config.paramsSerializer, forceUpdate = config.forceUpdate;
        var useCache = (config[cacheFlag] !== void 0 && config[cacheFlag] !== null) ? config[cacheFlag] : enabledByDefault;
        if (method === 'get' && useCache) {
            // if had provide a specified cache, then use it instead
            var cache_1 = Object(_utils_isCacheLike__WEBPACK_IMPORTED_MODULE_3__["default"])(useCache) ? useCache : defaultCache;
            // build the index according to the url and params
            var index_1 = Object(_utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__["default"])(url, params, paramsSerializer);
            var responsePromise = cache_1.get(index_1);
            if (!responsePromise || forceUpdate) {
                responsePromise = (function () { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
                    var reason_1;
                    return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, adapter(config)];
                            case 1: return [2 /*return*/, _a.sent()];
                            case 2:
                                reason_1 = _a.sent();
                                cache_1.del(index_1);
                                throw reason_1;
                            case 3: return [2 /*return*/];
                        }
                    });
                }); })();
                // put the promise for the non-transformed response into cache as a placeholder
                cache_1.set(index_1, responsePromise);
                return responsePromise;
            }
            /* istanbul ignore next */
            if (process.env.LOGGER_LEVEL === 'info') {
                // eslint-disable-next-line no-console
                console.info("request cached by cache adapter: " + index_1);
            }
            return responsePromise;
        }
        return adapter(config);
    };
}
//# sourceMappingURL=cacheAdapterEnhancer.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios-extensions/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/axios-extensions/esm/index.js ***!
  \****************************************************/
/*! exports provided: Cache, cacheAdapterEnhancer, throttleAdapterEnhancer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a; });
/* harmony import */ var _cacheAdapterEnhancer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cacheAdapterEnhancer */ "./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cacheAdapterEnhancer", function() { return _cacheAdapterEnhancer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _throttleAdapterEnhancer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./throttleAdapterEnhancer */ "./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttleAdapterEnhancer", function() { return _throttleAdapterEnhancer__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-09-28
 */




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return throttleAdapterEnhancer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buildSortedURL */ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js");
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-11
 */



function throttleAdapterEnhancer(adapter, options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    var _a = options.threshold, threshold = _a === void 0 ? 1000 : _a, _b = options.cache, cache = _b === void 0 ? new lru_cache__WEBPACK_IMPORTED_MODULE_1___default.a({ max: 10 }) : _b;
    var recordCacheWithRequest = function (index, config) {
        var responsePromise = (function () { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
            var response, reason_1;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, adapter(config)];
                    case 1:
                        response = _a.sent();
                        cache.set(index, {
                            timestamp: Date.now(),
                            value: Promise.resolve(response),
                        });
                        return [2 /*return*/, response];
                    case 2:
                        reason_1 = _a.sent();
                        cache.del(index);
                        throw reason_1;
                    case 3: return [2 /*return*/];
                }
            });
        }); })();
        cache.set(index, {
            timestamp: Date.now(),
            value: responsePromise,
        });
        return responsePromise;
    };
    return function (config) {
        var url = config.url, method = config.method, params = config.params, paramsSerializer = config.paramsSerializer;
        var index = Object(_utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__["default"])(url, params, paramsSerializer);
        var now = Date.now();
        var cachedRecord = cache.get(index) || { timestamp: now };
        if (method === 'get') {
            if (now - cachedRecord.timestamp <= threshold) {
                var responsePromise = cachedRecord.value;
                if (responsePromise) {
                    /* istanbul ignore next */
                    if (process.env.LOGGER_LEVEL === 'info') {
                        // eslint-disable-next-line no-console
                        console.info("request cached by throttle adapter: " + index);
                    }
                    return responsePromise;
                }
            }
            return recordCacheWithRequest(index, config);
        }
        return adapter(config);
    };
}
//# sourceMappingURL=throttleAdapterEnhancer.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js":
/*!*******************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/utils/buildSortedURL.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return buildSortedURL; });
/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios/lib/helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-12
 */

function buildSortedURL() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var builtURL = axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0___default.a.apply(void 0, args);
    var _a = builtURL.split('?'), urlPath = _a[0], queryString = _a[1];
    if (queryString) {
        var paramsPair = queryString.split('&');
        return urlPath + "?" + paramsPair.sort().join('&');
    }
    return builtURL;
}
//# sourceMappingURL=buildSortedURL.js.map

/***/ }),

/***/ "./node_modules/axios-extensions/esm/utils/isCacheLike.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/utils/isCacheLike.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isCacheLike; });
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2018-03-19
 */
function isCacheLike(cache) {
    return !!(cache.set && cache.get && cache.del &&
        typeof cache.get === 'function' && typeof cache.set === 'function' && typeof cache.del === 'function');
}
//# sourceMappingURL=isCacheLike.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(/*! ./../helpers/btoa */ "./node_modules/axios/lib/helpers/btoa.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ( true &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
var isAbsoluteURL = __webpack_require__(/*! ./../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ./../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/btoa.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/btoa.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_advance-string-index.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_advance-string-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-instance.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_an-instance.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-copy-within.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-copy-within.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-fill.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_array-fill.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-methods.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-methods.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-reduce.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_array-reduce.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-constructor.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-create.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-create.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_classof.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_fix-re-wks.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_fix-re-wks.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ./es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_flags.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_flags.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_for-of.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_for-of.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_inherit-if-required.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_inherit-if-required.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_invoke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-regexp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-regexp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-call.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-detect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-step.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iterators.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/modules/_meta.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_meta.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/modules/_microtask.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_microtask.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_new-promise-capability.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/_new-promise-capability.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-create.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dps.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gops.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gpo.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-sap.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-sap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_perform.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_perform.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_promise-resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_promise-resolve.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "./node_modules/core-js/modules/_same-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_same-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_set-proto.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_set-proto.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "./node_modules/core-js/modules/_set-species.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_set-species.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/modules/_species-constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_species-constructor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_strict-method.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_strict-method.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-at.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_task.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_task.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");
var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-index.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_to-index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/modules/_typed-array.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-array.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
  var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");
  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");
  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
  var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");
  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");
  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js");
  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");
  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");
  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");
  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js");
  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/modules/_typed-buffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-buffer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "./node_modules/core-js/modules/_typed.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_typed.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_user-agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_user-agent.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "./node_modules/core-js/modules/_wks-define.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-define.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");
var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_wks-ext.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-ext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");


/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.filter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.for-each.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.for-each.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);
var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.index-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.index-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.is-array.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.is-array.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', { isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.map.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.now.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.now.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.name.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-property.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.promise.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;
var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();
var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);
__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(PROMISE);
Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");
var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('RegExp');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.exec.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.exec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");
__webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.flags.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.flags.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js")
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.match.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.match.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

// @@match logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.replace.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.replace.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return ch;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return ch;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return ch;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.search.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.search.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var sameValue = __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js");
var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

// @@search logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.split.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.split.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");
var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';

// eslint-disable-next-line no-empty
var SUPPORTS_Y = !!(function () { try { return new RegExp('x', 'y'); } catch (e) {} })();

// @@split logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? 0xffffffff : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ./es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").KEY;
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");
var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js");
var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/modules/_enum-keys.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.data-view.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.data-view.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js").DataView
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom.iterable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jsencrypt/bin/jsencrypt.js":
/*!*************************************************!*\
  !*** ./node_modules/jsencrypt/bin/jsencrypt.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
function int2char(n) {
    return BI_RM.charAt(n);
}
//#region BIT_OPERATIONS
// (public) this & a
function op_and(x, y) {
    return x & y;
}
// (public) this | a
function op_or(x, y) {
    return x | y;
}
// (public) this ^ a
function op_xor(x, y) {
    return x ^ y;
}
// (public) this & ~a
function op_andnot(x, y) {
    return x & ~y;
}
// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
    if (x == 0) {
        return -1;
    }
    var r = 0;
    if ((x & 0xffff) == 0) {
        x >>= 16;
        r += 16;
    }
    if ((x & 0xff) == 0) {
        x >>= 8;
        r += 8;
    }
    if ((x & 0xf) == 0) {
        x >>= 4;
        r += 4;
    }
    if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
    }
    if ((x & 1) == 0) {
        ++r;
    }
    return r;
}
// return number of 1 bits in x
function cbit(x) {
    var r = 0;
    while (x != 0) {
        x &= x - 1;
        ++r;
    }
    return r;
}
//#endregion BIT_OPERATIONS

var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";
function hex2b64(h) {
    var i;
    var c;
    var ret = "";
    for (i = 0; i + 3 <= h.length; i += 3) {
        c = parseInt(h.substring(i, i + 3), 16);
        ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
    }
    if (i + 1 == h.length) {
        c = parseInt(h.substring(i, i + 1), 16);
        ret += b64map.charAt(c << 2);
    }
    else if (i + 2 == h.length) {
        c = parseInt(h.substring(i, i + 2), 16);
        ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
    }
    while ((ret.length & 3) > 0) {
        ret += b64pad;
    }
    return ret;
}
// convert a base64 string to hex
function b64tohex(s) {
    var ret = "";
    var i;
    var k = 0; // b64 state, 0-3
    var slop = 0;
    for (i = 0; i < s.length; ++i) {
        if (s.charAt(i) == b64pad) {
            break;
        }
        var v = b64map.indexOf(s.charAt(i));
        if (v < 0) {
            continue;
        }
        if (k == 0) {
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 1;
        }
        else if (k == 1) {
            ret += int2char((slop << 2) | (v >> 4));
            slop = v & 0xf;
            k = 2;
        }
        else if (k == 2) {
            ret += int2char(slop);
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 3;
        }
        else {
            ret += int2char((slop << 2) | (v >> 4));
            ret += int2char(v & 0xf);
            k = 0;
        }
    }
    if (k == 1) {
        ret += int2char(slop << 2);
    }
    return ret;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// Hex JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder;
var Hex = {
    decode: function (a) {
        var i;
        if (decoder === undefined) {
            var hex = "0123456789ABCDEF";
            var ignore = " \f\n\r\t\u00A0\u2028\u2029";
            decoder = {};
            for (i = 0; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            hex = hex.toLowerCase();
            for (i = 10; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 2) {
                out[out.length] = bits;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 4;
            }
        }
        if (char_count) {
            throw new Error("Hex encoding incomplete: 4 bits missing");
        }
        return out;
    }
};

// Base64 JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder$1;
var Base64 = {
    decode: function (a) {
        var i;
        if (decoder$1 === undefined) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var ignore = "= \f\n\r\t\u00A0\u2028\u2029";
            decoder$1 = Object.create(null);
            for (i = 0; i < 64; ++i) {
                decoder$1[b64.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder$1[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder$1[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 4) {
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                out[out.length] = bits & 0xFF;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 6;
            }
        }
        switch (char_count) {
            case 1:
                throw new Error("Base64 encoding incomplete: at least 2 bits missing");
            case 2:
                out[out.length] = (bits >> 10);
                break;
            case 3:
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                break;
        }
        return out;
    },
    re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
    unarmor: function (a) {
        var m = Base64.re.exec(a);
        if (m) {
            if (m[1]) {
                a = m[1];
            }
            else if (m[2]) {
                a = m[2];
            }
            else {
                throw new Error("RegExp out of sync");
            }
        }
        return Base64.decode(a);
    }
};

// Big integer base-10 printing library
// Copyright (c) 2014 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var max = 10000000000000; // biggest integer that can still fit 2^53 when multiplied by 256
var Int10 = /** @class */ (function () {
    function Int10(value) {
        this.buf = [+value || 0];
    }
    Int10.prototype.mulAdd = function (m, c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] * m + c;
            if (t < max) {
                c = 0;
            }
            else {
                c = 0 | (t / max);
                t -= c * max;
            }
            b[i] = t;
        }
        if (c > 0) {
            b[i] = c;
        }
    };
    Int10.prototype.sub = function (c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] - c;
            if (t < 0) {
                t += max;
                c = 1;
            }
            else {
                c = 0;
            }
            b[i] = t;
        }
        while (b[b.length - 1] === 0) {
            b.pop();
        }
    };
    Int10.prototype.toString = function (base) {
        if ((base || 10) != 10) {
            throw new Error("only base 10 is supported");
        }
        var b = this.buf;
        var s = b[b.length - 1].toString();
        for (var i = b.length - 2; i >= 0; --i) {
            s += (max + b[i]).toString().substring(1);
        }
        return s;
    };
    Int10.prototype.valueOf = function () {
        var b = this.buf;
        var v = 0;
        for (var i = b.length - 1; i >= 0; --i) {
            v = v * max + b[i];
        }
        return v;
    };
    Int10.prototype.simplify = function () {
        var b = this.buf;
        return (b.length == 1) ? b[0] : this;
    };
    return Int10;
}());

// ASN.1 JavaScript decoder
var ellipsis = "\u2026";
var reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
var reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
function stringCut(str, len) {
    if (str.length > len) {
        str = str.substring(0, len) + ellipsis;
    }
    return str;
}
var Stream = /** @class */ (function () {
    function Stream(enc, pos) {
        this.hexDigits = "0123456789ABCDEF";
        if (enc instanceof Stream) {
            this.enc = enc.enc;
            this.pos = enc.pos;
        }
        else {
            // enc should be an array or a binary string
            this.enc = enc;
            this.pos = pos;
        }
    }
    Stream.prototype.get = function (pos) {
        if (pos === undefined) {
            pos = this.pos++;
        }
        if (pos >= this.enc.length) {
            throw new Error("Requesting byte offset " + pos + " on a stream of length " + this.enc.length);
        }
        return ("string" === typeof this.enc) ? this.enc.charCodeAt(pos) : this.enc[pos];
    };
    Stream.prototype.hexByte = function (b) {
        return this.hexDigits.charAt((b >> 4) & 0xF) + this.hexDigits.charAt(b & 0xF);
    };
    Stream.prototype.hexDump = function (start, end, raw) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
            if (raw !== true) {
                switch (i & 0xF) {
                    case 0x7:
                        s += "  ";
                        break;
                    case 0xF:
                        s += "\n";
                        break;
                    default:
                        s += " ";
                }
            }
        }
        return s;
    };
    Stream.prototype.isASCII = function (start, end) {
        for (var i = start; i < end; ++i) {
            var c = this.get(i);
            if (c < 32 || c > 176) {
                return false;
            }
        }
        return true;
    };
    Stream.prototype.parseStringISO = function (start, end) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += String.fromCharCode(this.get(i));
        }
        return s;
    };
    Stream.prototype.parseStringUTF = function (start, end) {
        var s = "";
        for (var i = start; i < end;) {
            var c = this.get(i++);
            if (c < 128) {
                s += String.fromCharCode(c);
            }
            else if ((c > 191) && (c < 224)) {
                s += String.fromCharCode(((c & 0x1F) << 6) | (this.get(i++) & 0x3F));
            }
            else {
                s += String.fromCharCode(((c & 0x0F) << 12) | ((this.get(i++) & 0x3F) << 6) | (this.get(i++) & 0x3F));
            }
        }
        return s;
    };
    Stream.prototype.parseStringBMP = function (start, end) {
        var str = "";
        var hi;
        var lo;
        for (var i = start; i < end;) {
            hi = this.get(i++);
            lo = this.get(i++);
            str += String.fromCharCode((hi << 8) | lo);
        }
        return str;
    };
    Stream.prototype.parseTime = function (start, end, shortYear) {
        var s = this.parseStringISO(start, end);
        var m = (shortYear ? reTimeS : reTimeL).exec(s);
        if (!m) {
            return "Unrecognized time: " + s;
        }
        if (shortYear) {
            // to avoid querying the timer, use the fixed range [1970, 2069]
            // it will conform with ITU X.400 [-10, +40] sliding window until 2030
            m[1] = +m[1];
            m[1] += (+m[1] < 70) ? 2000 : 1900;
        }
        s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];
        if (m[5]) {
            s += ":" + m[5];
            if (m[6]) {
                s += ":" + m[6];
                if (m[7]) {
                    s += "." + m[7];
                }
            }
        }
        if (m[8]) {
            s += " UTC";
            if (m[8] != "Z") {
                s += m[8];
                if (m[9]) {
                    s += ":" + m[9];
                }
            }
        }
        return s;
    };
    Stream.prototype.parseInteger = function (start, end) {
        var v = this.get(start);
        var neg = (v > 127);
        var pad = neg ? 255 : 0;
        var len;
        var s = "";
        // skip unuseful bits (not allowed in DER)
        while (v == pad && ++start < end) {
            v = this.get(start);
        }
        len = end - start;
        if (len === 0) {
            return neg ? -1 : 0;
        }
        // show bit length of huge integers
        if (len > 4) {
            s = v;
            len <<= 3;
            while (((+s ^ pad) & 0x80) == 0) {
                s = +s << 1;
                --len;
            }
            s = "(" + len + " bit)\n";
        }
        // decode the integer
        if (neg) {
            v = v - 256;
        }
        var n = new Int10(v);
        for (var i = start + 1; i < end; ++i) {
            n.mulAdd(256, this.get(i));
        }
        return s + n.toString();
    };
    Stream.prototype.parseBitString = function (start, end, maxLength) {
        var unusedBit = this.get(start);
        var lenBit = ((end - start - 1) << 3) - unusedBit;
        var intro = "(" + lenBit + " bit)\n";
        var s = "";
        for (var i = start + 1; i < end; ++i) {
            var b = this.get(i);
            var skip = (i == end - 1) ? unusedBit : 0;
            for (var j = 7; j >= skip; --j) {
                s += (b >> j) & 1 ? "1" : "0";
            }
            if (s.length > maxLength) {
                return intro + stringCut(s, maxLength);
            }
        }
        return intro + s;
    };
    Stream.prototype.parseOctetString = function (start, end, maxLength) {
        if (this.isASCII(start, end)) {
            return stringCut(this.parseStringISO(start, end), maxLength);
        }
        var len = end - start;
        var s = "(" + len + " byte)\n";
        maxLength /= 2; // we work in bytes
        if (len > maxLength) {
            end = start + maxLength;
        }
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
        }
        if (len > maxLength) {
            s += ellipsis;
        }
        return s;
    };
    Stream.prototype.parseOID = function (start, end, maxLength) {
        var s = "";
        var n = new Int10();
        var bits = 0;
        for (var i = start; i < end; ++i) {
            var v = this.get(i);
            n.mulAdd(128, v & 0x7F);
            bits += 7;
            if (!(v & 0x80)) { // finished
                if (s === "") {
                    n = n.simplify();
                    if (n instanceof Int10) {
                        n.sub(80);
                        s = "2." + n.toString();
                    }
                    else {
                        var m = n < 80 ? n < 40 ? 0 : 1 : 2;
                        s = m + "." + (n - m * 40);
                    }
                }
                else {
                    s += "." + n.toString();
                }
                if (s.length > maxLength) {
                    return stringCut(s, maxLength);
                }
                n = new Int10();
                bits = 0;
            }
        }
        if (bits > 0) {
            s += ".incomplete";
        }
        return s;
    };
    return Stream;
}());
var ASN1 = /** @class */ (function () {
    function ASN1(stream, header, length, tag, sub) {
        if (!(tag instanceof ASN1Tag)) {
            throw new Error("Invalid tag value.");
        }
        this.stream = stream;
        this.header = header;
        this.length = length;
        this.tag = tag;
        this.sub = sub;
    }
    ASN1.prototype.typeName = function () {
        switch (this.tag.tagClass) {
            case 0: // universal
                switch (this.tag.tagNumber) {
                    case 0x00:
                        return "EOC";
                    case 0x01:
                        return "BOOLEAN";
                    case 0x02:
                        return "INTEGER";
                    case 0x03:
                        return "BIT_STRING";
                    case 0x04:
                        return "OCTET_STRING";
                    case 0x05:
                        return "NULL";
                    case 0x06:
                        return "OBJECT_IDENTIFIER";
                    case 0x07:
                        return "ObjectDescriptor";
                    case 0x08:
                        return "EXTERNAL";
                    case 0x09:
                        return "REAL";
                    case 0x0A:
                        return "ENUMERATED";
                    case 0x0B:
                        return "EMBEDDED_PDV";
                    case 0x0C:
                        return "UTF8String";
                    case 0x10:
                        return "SEQUENCE";
                    case 0x11:
                        return "SET";
                    case 0x12:
                        return "NumericString";
                    case 0x13:
                        return "PrintableString"; // ASCII subset
                    case 0x14:
                        return "TeletexString"; // aka T61String
                    case 0x15:
                        return "VideotexString";
                    case 0x16:
                        return "IA5String"; // ASCII
                    case 0x17:
                        return "UTCTime";
                    case 0x18:
                        return "GeneralizedTime";
                    case 0x19:
                        return "GraphicString";
                    case 0x1A:
                        return "VisibleString"; // ASCII subset
                    case 0x1B:
                        return "GeneralString";
                    case 0x1C:
                        return "UniversalString";
                    case 0x1E:
                        return "BMPString";
                }
                return "Universal_" + this.tag.tagNumber.toString();
            case 1:
                return "Application_" + this.tag.tagNumber.toString();
            case 2:
                return "[" + this.tag.tagNumber.toString() + "]"; // Context
            case 3:
                return "Private_" + this.tag.tagNumber.toString();
        }
    };
    ASN1.prototype.content = function (maxLength) {
        if (this.tag === undefined) {
            return null;
        }
        if (maxLength === undefined) {
            maxLength = Infinity;
        }
        var content = this.posContent();
        var len = Math.abs(this.length);
        if (!this.tag.isUniversal()) {
            if (this.sub !== null) {
                return "(" + this.sub.length + " elem)";
            }
            return this.stream.parseOctetString(content, content + len, maxLength);
        }
        switch (this.tag.tagNumber) {
            case 0x01: // BOOLEAN
                return (this.stream.get(content) === 0) ? "false" : "true";
            case 0x02: // INTEGER
                return this.stream.parseInteger(content, content + len);
            case 0x03: // BIT_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseBitString(content, content + len, maxLength);
            case 0x04: // OCTET_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseOctetString(content, content + len, maxLength);
            // case 0x05: // NULL
            case 0x06: // OBJECT_IDENTIFIER
                return this.stream.parseOID(content, content + len, maxLength);
            // case 0x07: // ObjectDescriptor
            // case 0x08: // EXTERNAL
            // case 0x09: // REAL
            // case 0x0A: // ENUMERATED
            // case 0x0B: // EMBEDDED_PDV
            case 0x10: // SEQUENCE
            case 0x11: // SET
                if (this.sub !== null) {
                    return "(" + this.sub.length + " elem)";
                }
                else {
                    return "(no elem)";
                }
            case 0x0C: // UTF8String
                return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);
            case 0x12: // NumericString
            case 0x13: // PrintableString
            case 0x14: // TeletexString
            case 0x15: // VideotexString
            case 0x16: // IA5String
            // case 0x19: // GraphicString
            case 0x1A: // VisibleString
                // case 0x1B: // GeneralString
                // case 0x1C: // UniversalString
                return stringCut(this.stream.parseStringISO(content, content + len), maxLength);
            case 0x1E: // BMPString
                return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);
            case 0x17: // UTCTime
            case 0x18: // GeneralizedTime
                return this.stream.parseTime(content, content + len, (this.tag.tagNumber == 0x17));
        }
        return null;
    };
    ASN1.prototype.toString = function () {
        return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + ((this.sub === null) ? "null" : this.sub.length) + "]";
    };
    ASN1.prototype.toPrettyString = function (indent) {
        if (indent === undefined) {
            indent = "";
        }
        var s = indent + this.typeName() + " @" + this.stream.pos;
        if (this.length >= 0) {
            s += "+";
        }
        s += this.length;
        if (this.tag.tagConstructed) {
            s += " (constructed)";
        }
        else if ((this.tag.isUniversal() && ((this.tag.tagNumber == 0x03) || (this.tag.tagNumber == 0x04))) && (this.sub !== null)) {
            s += " (encapsulates)";
        }
        s += "\n";
        if (this.sub !== null) {
            indent += "  ";
            for (var i = 0, max = this.sub.length; i < max; ++i) {
                s += this.sub[i].toPrettyString(indent);
            }
        }
        return s;
    };
    ASN1.prototype.posStart = function () {
        return this.stream.pos;
    };
    ASN1.prototype.posContent = function () {
        return this.stream.pos + this.header;
    };
    ASN1.prototype.posEnd = function () {
        return this.stream.pos + this.header + Math.abs(this.length);
    };
    ASN1.prototype.toHexString = function () {
        return this.stream.hexDump(this.posStart(), this.posEnd(), true);
    };
    ASN1.decodeLength = function (stream) {
        var buf = stream.get();
        var len = buf & 0x7F;
        if (len == buf) {
            return len;
        }
        // no reason to use Int10, as it would be a huge buffer anyways
        if (len > 6) {
            throw new Error("Length over 48 bits not supported at position " + (stream.pos - 1));
        }
        if (len === 0) {
            return null;
        } // undefined
        buf = 0;
        for (var i = 0; i < len; ++i) {
            buf = (buf * 256) + stream.get();
        }
        return buf;
    };
    /**
     * Retrieve the hexadecimal value (as a string) of the current ASN.1 element
     * @returns {string}
     * @public
     */
    ASN1.prototype.getHexStringValue = function () {
        var hexString = this.toHexString();
        var offset = this.header * 2;
        var length = this.length * 2;
        return hexString.substr(offset, length);
    };
    ASN1.decode = function (str) {
        var stream;
        if (!(str instanceof Stream)) {
            stream = new Stream(str, 0);
        }
        else {
            stream = str;
        }
        var streamStart = new Stream(stream);
        var tag = new ASN1Tag(stream);
        var len = ASN1.decodeLength(stream);
        var start = stream.pos;
        var header = start - streamStart.pos;
        var sub = null;
        var getSub = function () {
            var ret = [];
            if (len !== null) {
                // definite length
                var end = start + len;
                while (stream.pos < end) {
                    ret[ret.length] = ASN1.decode(stream);
                }
                if (stream.pos != end) {
                    throw new Error("Content size is not correct for container starting at offset " + start);
                }
            }
            else {
                // undefined length
                try {
                    for (;;) {
                        var s = ASN1.decode(stream);
                        if (s.tag.isEOC()) {
                            break;
                        }
                        ret[ret.length] = s;
                    }
                    len = start - stream.pos; // undefined lengths are represented as negative values
                }
                catch (e) {
                    throw new Error("Exception while decoding undefined length content: " + e);
                }
            }
            return ret;
        };
        if (tag.tagConstructed) {
            // must have valid content
            sub = getSub();
        }
        else if (tag.isUniversal() && ((tag.tagNumber == 0x03) || (tag.tagNumber == 0x04))) {
            // sometimes BitString and OctetString are used to encapsulate ASN.1
            try {
                if (tag.tagNumber == 0x03) {
                    if (stream.get() != 0) {
                        throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
                    }
                }
                sub = getSub();
                for (var i = 0; i < sub.length; ++i) {
                    if (sub[i].tag.isEOC()) {
                        throw new Error("EOC is not supposed to be actual content.");
                    }
                }
            }
            catch (e) {
                // but silently ignore when they don't
                sub = null;
            }
        }
        if (sub === null) {
            if (len === null) {
                throw new Error("We can't skip over an invalid tag with undefined length at offset " + start);
            }
            stream.pos = start + Math.abs(len);
        }
        return new ASN1(streamStart, header, len, tag, sub);
    };
    return ASN1;
}());
var ASN1Tag = /** @class */ (function () {
    function ASN1Tag(stream) {
        var buf = stream.get();
        this.tagClass = buf >> 6;
        this.tagConstructed = ((buf & 0x20) !== 0);
        this.tagNumber = buf & 0x1F;
        if (this.tagNumber == 0x1F) { // long tag
            var n = new Int10();
            do {
                buf = stream.get();
                n.mulAdd(128, buf & 0x7F);
            } while (buf & 0x80);
            this.tagNumber = n.simplify();
        }
    }
    ASN1Tag.prototype.isUniversal = function () {
        return this.tagClass === 0x00;
    };
    ASN1Tag.prototype.isEOC = function () {
        return this.tagClass === 0x00 && this.tagNumber === 0x00;
    };
    return ASN1Tag;
}());

// Copyright (c) 2005  Tom Wu
// Bits per digit
var dbits;
// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary & 0xffffff) == 0xefcafe);
//#region
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
//#endregion
// (public) Constructor
var BigInteger = /** @class */ (function () {
    function BigInteger(a, b, c) {
        if (a != null) {
            if ("number" == typeof a) {
                this.fromNumber(a, b, c);
            }
            else if (b == null && "string" != typeof a) {
                this.fromString(a, 256);
            }
            else {
                this.fromString(a, b);
            }
        }
    }
    //#region PUBLIC
    // BigInteger.prototype.toString = bnToString;
    // (public) return string representation in given radix
    BigInteger.prototype.toString = function (b) {
        if (this.s < 0) {
            return "-" + this.negate().toString(b);
        }
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            return this.toRadix(b);
        }
        var km = (1 << k) - 1;
        var d;
        var m = false;
        var r = "";
        var i = this.t;
        var p = this.DB - (i * this.DB) % k;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
                m = true;
                r = int2char(d);
            }
            while (i >= 0) {
                if (p < k) {
                    d = (this[i] & ((1 << p) - 1)) << (k - p);
                    d |= this[--i] >> (p += this.DB - k);
                }
                else {
                    d = (this[i] >> (p -= k)) & km;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if (d > 0) {
                    m = true;
                }
                if (m) {
                    r += int2char(d);
                }
            }
        }
        return m ? r : "0";
    };
    // BigInteger.prototype.negate = bnNegate;
    // (public) -this
    BigInteger.prototype.negate = function () {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
    };
    // BigInteger.prototype.abs = bnAbs;
    // (public) |this|
    BigInteger.prototype.abs = function () {
        return (this.s < 0) ? this.negate() : this;
    };
    // BigInteger.prototype.compareTo = bnCompareTo;
    // (public) return + if this > a, - if this < a, 0 if equal
    BigInteger.prototype.compareTo = function (a) {
        var r = this.s - a.s;
        if (r != 0) {
            return r;
        }
        var i = this.t;
        r = i - a.t;
        if (r != 0) {
            return (this.s < 0) ? -r : r;
        }
        while (--i >= 0) {
            if ((r = this[i] - a[i]) != 0) {
                return r;
            }
        }
        return 0;
    };
    // BigInteger.prototype.bitLength = bnBitLength;
    // (public) return the number of bits in "this"
    BigInteger.prototype.bitLength = function () {
        if (this.t <= 0) {
            return 0;
        }
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
    };
    // BigInteger.prototype.mod = bnMod;
    // (public) this mod a
    BigInteger.prototype.mod = function (a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            a.subTo(r, r);
        }
        return r;
    };
    // BigInteger.prototype.modPowInt = bnModPowInt;
    // (public) this^e % m, 0 <= e < 2^32
    BigInteger.prototype.modPowInt = function (e, m) {
        var z;
        if (e < 256 || m.isEven()) {
            z = new Classic(m);
        }
        else {
            z = new Montgomery(m);
        }
        return this.exp(e, z);
    };
    // BigInteger.prototype.clone = bnClone;
    // (public)
    BigInteger.prototype.clone = function () {
        var r = nbi();
        this.copyTo(r);
        return r;
    };
    // BigInteger.prototype.intValue = bnIntValue;
    // (public) return value as integer
    BigInteger.prototype.intValue = function () {
        if (this.s < 0) {
            if (this.t == 1) {
                return this[0] - this.DV;
            }
            else if (this.t == 0) {
                return -1;
            }
        }
        else if (this.t == 1) {
            return this[0];
        }
        else if (this.t == 0) {
            return 0;
        }
        // assumes 16 < DB < 32
        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
    };
    // BigInteger.prototype.byteValue = bnByteValue;
    // (public) return value as byte
    BigInteger.prototype.byteValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
    };
    // BigInteger.prototype.shortValue = bnShortValue;
    // (public) return value as short (assumes DB>=16)
    BigInteger.prototype.shortValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
    };
    // BigInteger.prototype.signum = bnSigNum;
    // (public) 0 if this == 0, 1 if this > 0
    BigInteger.prototype.signum = function () {
        if (this.s < 0) {
            return -1;
        }
        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {
            return 0;
        }
        else {
            return 1;
        }
    };
    // BigInteger.prototype.toByteArray = bnToByteArray;
    // (public) convert to bigendian byte array
    BigInteger.prototype.toByteArray = function () {
        var i = this.t;
        var r = [];
        r[0] = this.s;
        var p = this.DB - (i * this.DB) % 8;
        var d;
        var k = 0;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {
                r[k++] = d | (this.s << (this.DB - p));
            }
            while (i >= 0) {
                if (p < 8) {
                    d = (this[i] & ((1 << p) - 1)) << (8 - p);
                    d |= this[--i] >> (p += this.DB - 8);
                }
                else {
                    d = (this[i] >> (p -= 8)) & 0xff;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if ((d & 0x80) != 0) {
                    d |= -256;
                }
                if (k == 0 && (this.s & 0x80) != (d & 0x80)) {
                    ++k;
                }
                if (k > 0 || d != this.s) {
                    r[k++] = d;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.equals = function (a) {
        return (this.compareTo(a) == 0);
    };
    // BigInteger.prototype.min = bnMin;
    BigInteger.prototype.min = function (a) {
        return (this.compareTo(a) < 0) ? this : a;
    };
    // BigInteger.prototype.max = bnMax;
    BigInteger.prototype.max = function (a) {
        return (this.compareTo(a) > 0) ? this : a;
    };
    // BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.and = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
    };
    // BigInteger.prototype.or = bnOr;
    BigInteger.prototype.or = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
    };
    // BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.xor = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
    };
    // BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.andNot = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
    };
    // BigInteger.prototype.not = bnNot;
    // (public) ~this
    BigInteger.prototype.not = function () {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) {
            r[i] = this.DM & ~this[i];
        }
        r.t = this.t;
        r.s = ~this.s;
        return r;
    };
    // BigInteger.prototype.shiftLeft = bnShiftLeft;
    // (public) this << n
    BigInteger.prototype.shiftLeft = function (n) {
        var r = nbi();
        if (n < 0) {
            this.rShiftTo(-n, r);
        }
        else {
            this.lShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.shiftRight = bnShiftRight;
    // (public) this >> n
    BigInteger.prototype.shiftRight = function (n) {
        var r = nbi();
        if (n < 0) {
            this.lShiftTo(-n, r);
        }
        else {
            this.rShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    // (public) returns index of lowest 1-bit (or -1 if none)
    BigInteger.prototype.getLowestSetBit = function () {
        for (var i = 0; i < this.t; ++i) {
            if (this[i] != 0) {
                return i * this.DB + lbit(this[i]);
            }
        }
        if (this.s < 0) {
            return this.t * this.DB;
        }
        return -1;
    };
    // BigInteger.prototype.bitCount = bnBitCount;
    // (public) return number of set bits
    BigInteger.prototype.bitCount = function () {
        var r = 0;
        var x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) {
            r += cbit(this[i] ^ x);
        }
        return r;
    };
    // BigInteger.prototype.testBit = bnTestBit;
    // (public) true iff nth bit is set
    BigInteger.prototype.testBit = function (n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) {
            return (this.s != 0);
        }
        return ((this[j] & (1 << (n % this.DB))) != 0);
    };
    // BigInteger.prototype.setBit = bnSetBit;
    // (public) this | (1<<n)
    BigInteger.prototype.setBit = function (n) {
        return this.changeBit(n, op_or);
    };
    // BigInteger.prototype.clearBit = bnClearBit;
    // (public) this & ~(1<<n)
    BigInteger.prototype.clearBit = function (n) {
        return this.changeBit(n, op_andnot);
    };
    // BigInteger.prototype.flipBit = bnFlipBit;
    // (public) this ^ (1<<n)
    BigInteger.prototype.flipBit = function (n) {
        return this.changeBit(n, op_xor);
    };
    // BigInteger.prototype.add = bnAdd;
    // (public) this + a
    BigInteger.prototype.add = function (a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
    };
    // BigInteger.prototype.subtract = bnSubtract;
    // (public) this - a
    BigInteger.prototype.subtract = function (a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
    };
    // BigInteger.prototype.multiply = bnMultiply;
    // (public) this * a
    BigInteger.prototype.multiply = function (a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
    };
    // BigInteger.prototype.divide = bnDivide;
    // (public) this / a
    BigInteger.prototype.divide = function (a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
    };
    // BigInteger.prototype.remainder = bnRemainder;
    // (public) this % a
    BigInteger.prototype.remainder = function (a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
    };
    // BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    // (public) [this/a,this%a]
    BigInteger.prototype.divideAndRemainder = function (a) {
        var q = nbi();
        var r = nbi();
        this.divRemTo(a, q, r);
        return [q, r];
    };
    // BigInteger.prototype.modPow = bnModPow;
    // (public) this^e % m (HAC 14.85)
    BigInteger.prototype.modPow = function (e, m) {
        var i = e.bitLength();
        var k;
        var r = nbv(1);
        var z;
        if (i <= 0) {
            return r;
        }
        else if (i < 18) {
            k = 1;
        }
        else if (i < 48) {
            k = 3;
        }
        else if (i < 144) {
            k = 4;
        }
        else if (i < 768) {
            k = 5;
        }
        else {
            k = 6;
        }
        if (i < 8) {
            z = new Classic(m);
        }
        else if (m.isEven()) {
            z = new Barrett(m);
        }
        else {
            z = new Montgomery(m);
        }
        // precomputation
        var g = [];
        var n = 3;
        var k1 = k - 1;
        var km = (1 << k) - 1;
        g[1] = z.convert(this);
        if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
                g[n] = nbi();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
            }
        }
        var j = e.t - 1;
        var w;
        var is1 = true;
        var r2 = nbi();
        var t;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
            if (i >= k1) {
                w = (e[j] >> (i - k1)) & km;
            }
            else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0) {
                    w |= e[j - 1] >> (this.DB + i - k1);
                }
            }
            n = k;
            while ((w & 1) == 0) {
                w >>= 1;
                --n;
            }
            if ((i -= n) < 0) {
                i += this.DB;
                --j;
            }
            if (is1) { // ret == 1, don't bother squaring or multiplying it
                g[w].copyTo(r);
                is1 = false;
            }
            else {
                while (n > 1) {
                    z.sqrTo(r, r2);
                    z.sqrTo(r2, r);
                    n -= 2;
                }
                if (n > 0) {
                    z.sqrTo(r, r2);
                }
                else {
                    t = r;
                    r = r2;
                    r2 = t;
                }
                z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2);
                t = r;
                r = r2;
                r2 = t;
                if (--i < 0) {
                    i = this.DB - 1;
                    --j;
                }
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.modInverse = bnModInverse;
    // (public) 1/this % m (HAC 14.61)
    BigInteger.prototype.modInverse = function (m) {
        var ac = m.isEven();
        if ((this.isEven() && ac) || m.signum() == 0) {
            return BigInteger.ZERO;
        }
        var u = m.clone();
        var v = this.clone();
        var a = nbv(1);
        var b = nbv(0);
        var c = nbv(0);
        var d = nbv(1);
        while (u.signum() != 0) {
            while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                    if (!a.isEven() || !b.isEven()) {
                        a.addTo(this, a);
                        b.subTo(m, b);
                    }
                    a.rShiftTo(1, a);
                }
                else if (!b.isEven()) {
                    b.subTo(m, b);
                }
                b.rShiftTo(1, b);
            }
            while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                    if (!c.isEven() || !d.isEven()) {
                        c.addTo(this, c);
                        d.subTo(m, d);
                    }
                    c.rShiftTo(1, c);
                }
                else if (!d.isEven()) {
                    d.subTo(m, d);
                }
                d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac) {
                    a.subTo(c, a);
                }
                b.subTo(d, b);
            }
            else {
                v.subTo(u, v);
                if (ac) {
                    c.subTo(a, c);
                }
                d.subTo(b, d);
            }
        }
        if (v.compareTo(BigInteger.ONE) != 0) {
            return BigInteger.ZERO;
        }
        if (d.compareTo(m) >= 0) {
            return d.subtract(m);
        }
        if (d.signum() < 0) {
            d.addTo(m, d);
        }
        else {
            return d;
        }
        if (d.signum() < 0) {
            return d.add(m);
        }
        else {
            return d;
        }
    };
    // BigInteger.prototype.pow = bnPow;
    // (public) this^e
    BigInteger.prototype.pow = function (e) {
        return this.exp(e, new NullExp());
    };
    // BigInteger.prototype.gcd = bnGCD;
    // (public) gcd(this,a) (HAC 14.54)
    BigInteger.prototype.gcd = function (a) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            return x;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
        }
        if (g > 0) {
            y.lShiftTo(g, y);
        }
        return y;
    };
    // BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    // (public) test primality with certainty >= 1-.5^t
    BigInteger.prototype.isProbablePrime = function (t) {
        var i;
        var x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i) {
                if (x[0] == lowprimes[i]) {
                    return true;
                }
            }
            return false;
        }
        if (x.isEven()) {
            return false;
        }
        i = 1;
        while (i < lowprimes.length) {
            var m = lowprimes[i];
            var j = i + 1;
            while (j < lowprimes.length && m < lplim) {
                m *= lowprimes[j++];
            }
            m = x.modInt(m);
            while (i < j) {
                if (m % lowprimes[i++] == 0) {
                    return false;
                }
            }
        }
        return x.millerRabin(t);
    };
    //#endregion PUBLIC
    //#region PROTECTED
    // BigInteger.prototype.copyTo = bnpCopyTo;
    // (protected) copy this to r
    BigInteger.prototype.copyTo = function (r) {
        for (var i = this.t - 1; i >= 0; --i) {
            r[i] = this[i];
        }
        r.t = this.t;
        r.s = this.s;
    };
    // BigInteger.prototype.fromInt = bnpFromInt;
    // (protected) set from integer value x, -DV <= x < DV
    BigInteger.prototype.fromInt = function (x) {
        this.t = 1;
        this.s = (x < 0) ? -1 : 0;
        if (x > 0) {
            this[0] = x;
        }
        else if (x < -1) {
            this[0] = x + this.DV;
        }
        else {
            this.t = 0;
        }
    };
    // BigInteger.prototype.fromString = bnpFromString;
    // (protected) set from string and radix
    BigInteger.prototype.fromString = function (s, b) {
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 256) {
            k = 8;
            /* byte array */
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            this.fromRadix(s, b);
            return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length;
        var mi = false;
        var sh = 0;
        while (--i >= 0) {
            var x = (k == 8) ? (+s[i]) & 0xff : intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-") {
                    mi = true;
                }
                continue;
            }
            mi = false;
            if (sh == 0) {
                this[this.t++] = x;
            }
            else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                this[this.t++] = (x >> (this.DB - sh));
            }
            else {
                this[this.t - 1] |= x << sh;
            }
            sh += k;
            if (sh >= this.DB) {
                sh -= this.DB;
            }
        }
        if (k == 8 && ((+s[0]) & 0x80) != 0) {
            this.s = -1;
            if (sh > 0) {
                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
            }
        }
        this.clamp();
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.clamp = bnpClamp;
    // (protected) clamp off excess high words
    BigInteger.prototype.clamp = function () {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) {
            --this.t;
        }
    };
    // BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    // (protected) r = this << n*DB
    BigInteger.prototype.dlShiftTo = function (n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) {
            r[i + n] = this[i];
        }
        for (i = n - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r.t = this.t + n;
        r.s = this.s;
    };
    // BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    // (protected) r = this >> n*DB
    BigInteger.prototype.drShiftTo = function (n, r) {
        for (var i = n; i < this.t; ++i) {
            r[i - n] = this[i];
        }
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
    };
    // BigInteger.prototype.lShiftTo = bnpLShiftTo;
    // (protected) r = this << n
    BigInteger.prototype.lShiftTo = function (n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB);
        var c = (this.s << bs) & this.DM;
        for (var i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = (this[i] >> cbs) | c;
            c = (this[i] & bm) << bs;
        }
        for (var i = ds - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
    };
    // BigInteger.prototype.rShiftTo = bnpRShiftTo;
    // (protected) r = this >> n
    BigInteger.prototype.rShiftTo = function (n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
            r.t = 0;
            return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) {
            r[this.t - ds - 1] |= (this.s & bm) << cbs;
        }
        r.t = this.t - ds;
        r.clamp();
    };
    // BigInteger.prototype.subTo = bnpSubTo;
    // (protected) r = this - a
    BigInteger.prototype.subTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c -= a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c -= a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c < -1) {
            r[i++] = this.DV + c;
        }
        else if (c > 0) {
            r[i++] = c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyTo = function (a, r) {
        var x = this.abs();
        var y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < y.t; ++i) {
            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        }
        r.s = 0;
        r.clamp();
        if (this.s != a.s) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.squareTo = bnpSquareTo;
    // (protected) r = this^2, r != this (HAC 14.16)
    BigInteger.prototype.squareTo = function (r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
            }
        }
        if (r.t > 0) {
            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        }
        r.s = 0;
        r.clamp();
    };
    // BigInteger.prototype.divRemTo = bnpDivRemTo;
    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    BigInteger.prototype.divRemTo = function (m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) {
            return;
        }
        var pt = this.abs();
        if (pt.t < pm.t) {
            if (q != null) {
                q.fromInt(0);
            }
            if (r != null) {
                this.copyTo(r);
            }
            return;
        }
        if (r == null) {
            r = nbi();
        }
        var y = nbi();
        var ts = this.s;
        var ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
        if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
        }
        else {
            pm.copyTo(y);
            pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) {
            return;
        }
        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt;
        var d2 = (1 << this.F1) / yt;
        var e = 1 << this.F2;
        var i = r.t;
        var j = i - ys;
        var t = (q == null) ? nbi() : q;
        y.dlShiftTo(j, t);
        if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t);
        t.subTo(y, y); // "negative" y so we can replace sub with am later
        while (y.t < ys) {
            y[y.t++] = 0;
        }
        while (--j >= 0) {
            // Estimate quotient digit
            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd) {
                    r.subTo(t, r);
                }
            }
        }
        if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) {
                BigInteger.ZERO.subTo(q, q);
            }
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) {
            r.rShiftTo(nsh, r);
        } // Denormalize remainder
        if (ts < 0) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.invDigit = bnpInvDigit;
    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    BigInteger.prototype.invDigit = function () {
        if (this.t < 1) {
            return 0;
        }
        var x = this[0];
        if ((x & 1) == 0) {
            return 0;
        }
        var y = x & 3; // y == 1/x mod 2^2
        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
        // last step - calculate inverse mod DV directly;
        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
        y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
        // we really want the negative inverse, and -DV < y < DV
        return (y > 0) ? this.DV - y : -y;
    };
    // BigInteger.prototype.isEven = bnpIsEven;
    // (protected) true iff this is even
    BigInteger.prototype.isEven = function () {
        return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
    };
    // BigInteger.prototype.exp = bnpExp;
    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    BigInteger.prototype.exp = function (e, z) {
        if (e > 0xffffffff || e < 1) {
            return BigInteger.ONE;
        }
        var r = nbi();
        var r2 = nbi();
        var g = z.convert(this);
        var i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & (1 << i)) > 0) {
                z.mulTo(r2, g, r);
            }
            else {
                var t = r;
                r = r2;
                r2 = t;
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.chunkSize = bnpChunkSize;
    // (protected) return x s.t. r^x < DV
    BigInteger.prototype.chunkSize = function (r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
    };
    // BigInteger.prototype.toRadix = bnpToRadix;
    // (protected) convert to radix string
    BigInteger.prototype.toRadix = function (b) {
        if (b == null) {
            b = 10;
        }
        if (this.signum() == 0 || b < 2 || b > 36) {
            return "0";
        }
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a);
        var y = nbi();
        var z = nbi();
        var r = "";
        this.divRemTo(d, y, z);
        while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
        }
        return z.intValue().toString(b) + r;
    };
    // BigInteger.prototype.fromRadix = bnpFromRadix;
    // (protected) convert from radix string
    BigInteger.prototype.fromRadix = function (s, b) {
        this.fromInt(0);
        if (b == null) {
            b = 10;
        }
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs);
        var mi = false;
        var j = 0;
        var w = 0;
        for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0) {
                    mi = true;
                }
                continue;
            }
            w = b * w + x;
            if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
            }
        }
        if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
        }
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.fromNumber = bnpFromNumber;
    // (protected) alternate constructor
    BigInteger.prototype.fromNumber = function (a, b, c) {
        if ("number" == typeof b) {
            // new BigInteger(int,int,RNG)
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    // force MSB set
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                } // force odd
                while (!this.isProbablePrime(b)) {
                    this.dAddOffset(2, 0);
                    if (this.bitLength() > a) {
                        this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                    }
                }
            }
        }
        else {
            // new BigInteger(int,RNG)
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    // BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    // (protected) r = this op a (bitwise)
    BigInteger.prototype.bitwiseTo = function (a, op, r) {
        var i;
        var f;
        var m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) {
            r[i] = op(this[i], a[i]);
        }
        if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) {
                r[i] = op(this[i], f);
            }
            r.t = this.t;
        }
        else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) {
                r[i] = op(f, a[i]);
            }
            r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
    };
    // BigInteger.prototype.changeBit = bnpChangeBit;
    // (protected) this op (1<<n)
    BigInteger.prototype.changeBit = function (n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
    };
    // BigInteger.prototype.addTo = bnpAddTo;
    // (protected) r = this + a
    BigInteger.prototype.addTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c += a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c > 0) {
            r[i++] = c;
        }
        else if (c < -1) {
            r[i++] = this.DV + c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.dMultiply = bnpDMultiply;
    // (protected) this *= n, this >= 0, 1 < n < DV
    BigInteger.prototype.dMultiply = function (n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
    };
    // BigInteger.prototype.dAddOffset = bnpDAddOffset;
    // (protected) this += n << w words, this >= 0
    BigInteger.prototype.dAddOffset = function (n, w) {
        if (n == 0) {
            return;
        }
        while (this.t <= w) {
            this[this.t++] = 0;
        }
        this[w] += n;
        while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) {
                this[this.t++] = 0;
            }
            ++this[w];
        }
    };
    // BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0; // assumes a,this >= 0
        r.t = i;
        while (i > 0) {
            r[--i] = 0;
        }
        for (var j = r.t - this.t; i < j; ++i) {
            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        }
        for (var j = Math.min(a.t, n); i < j; ++i) {
            this.am(0, a[i], r, i, 0, n - i);
        }
        r.clamp();
    };
    // BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0; // assumes a,this >= 0
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        }
        r.clamp();
        r.drShiftTo(1, r);
    };
    // BigInteger.prototype.modInt = bnpModInt;
    // (protected) this % n, n < 2^26
    BigInteger.prototype.modInt = function (n) {
        if (n <= 0) {
            return 0;
        }
        var d = this.DV % n;
        var r = (this.s < 0) ? n - 1 : 0;
        if (this.t > 0) {
            if (d == 0) {
                r = this[0] % n;
            }
            else {
                for (var i = this.t - 1; i >= 0; --i) {
                    r = (d * r + this[i]) % n;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.millerRabin = bnpMillerRabin;
    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    BigInteger.prototype.millerRabin = function (t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) {
            return false;
        }
        var r = n1.shiftRight(k);
        t = (t + 1) >> 1;
        if (t > lowprimes.length) {
            t = lowprimes.length;
        }
        var a = nbi();
        for (var i = 0; i < t; ++i) {
            // Pick bases at random, instead of starting at 2
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                    y = y.modPowInt(2, this);
                    if (y.compareTo(BigInteger.ONE) == 0) {
                        return false;
                    }
                }
                if (y.compareTo(n1) != 0) {
                    return false;
                }
            }
        }
        return true;
    };
    // BigInteger.prototype.square = bnSquare;
    // (public) this^2
    BigInteger.prototype.square = function () {
        var r = nbi();
        this.squareTo(r);
        return r;
    };
    //#region ASYNC
    // Public API method
    BigInteger.prototype.gcda = function (a, callback) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            callback(x);
            return;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        // Workhorse of the algorithm, gets called 200 - 800 times per 512 bit keygen.
        var gcda1 = function () {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
            if (!(x.signum() > 0)) {
                if (g > 0) {
                    y.lShiftTo(g, y);
                }
                setTimeout(function () { callback(y); }, 0); // escape
            }
            else {
                setTimeout(gcda1, 0);
            }
        };
        setTimeout(gcda1, 10);
    };
    // (protected) alternate constructor
    BigInteger.prototype.fromNumberAsync = function (a, b, c, callback) {
        if ("number" == typeof b) {
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                }
                var bnp_1 = this;
                var bnpfn1_1 = function () {
                    bnp_1.dAddOffset(2, 0);
                    if (bnp_1.bitLength() > a) {
                        bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);
                    }
                    if (bnp_1.isProbablePrime(b)) {
                        setTimeout(function () { callback(); }, 0); // escape
                    }
                    else {
                        setTimeout(bnpfn1_1, 0);
                    }
                };
                setTimeout(bnpfn1_1, 0);
            }
        }
        else {
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    return BigInteger;
}());
//#region REDUCERS
//#region NullExp
var NullExp = /** @class */ (function () {
    function NullExp() {
    }
    // NullExp.prototype.convert = nNop;
    NullExp.prototype.convert = function (x) {
        return x;
    };
    // NullExp.prototype.revert = nNop;
    NullExp.prototype.revert = function (x) {
        return x;
    };
    // NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
    };
    // NullExp.prototype.sqrTo = nSqrTo;
    NullExp.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
    };
    return NullExp;
}());
// Modular reduction using "classic" algorithm
var Classic = /** @class */ (function () {
    function Classic(m) {
        this.m = m;
    }
    // Classic.prototype.convert = cConvert;
    Classic.prototype.convert = function (x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) {
            return x.mod(this.m);
        }
        else {
            return x;
        }
    };
    // Classic.prototype.revert = cRevert;
    Classic.prototype.revert = function (x) {
        return x;
    };
    // Classic.prototype.reduce = cReduce;
    Classic.prototype.reduce = function (x) {
        x.divRemTo(this.m, null, x);
    };
    // Classic.prototype.mulTo = cMulTo;
    Classic.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Classic.prototype.sqrTo = cSqrTo;
    Classic.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Classic;
}());
//#endregion
//#region Montgomery
// Montgomery reduction
var Montgomery = /** @class */ (function () {
    function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 0x7fff;
        this.mph = this.mp >> 15;
        this.um = (1 << (m.DB - 15)) - 1;
        this.mt2 = 2 * m.t;
    }
    // Montgomery.prototype.convert = montConvert;
    // xR mod m
    Montgomery.prototype.convert = function (x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            this.m.subTo(r, r);
        }
        return r;
    };
    // Montgomery.prototype.revert = montRevert;
    // x/R mod m
    Montgomery.prototype.revert = function (x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
    };
    // Montgomery.prototype.reduce = montReduce;
    // x = x/R mod m (HAC 14.32)
    Montgomery.prototype.reduce = function (x) {
        while (x.t <= this.mt2) {
            // pad x so am has enough room later
            x[x.t++] = 0;
        }
        for (var i = 0; i < this.m.t; ++i) {
            // faster way of calculating u0 = x[i]*mp mod DV
            var j = x[i] & 0x7fff;
            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
            // use am to combine the multiply-shift-add into one call
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            // propagate carry
            while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
            }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Montgomery.prototype.mulTo = montMulTo;
    // r = "xy/R mod m"; x,y != r
    Montgomery.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Montgomery.prototype.sqrTo = montSqrTo;
    // r = "x^2/R mod m"; x != r
    Montgomery.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Montgomery;
}());
//#endregion Montgomery
//#region Barrett
// Barrett modular reduction
var Barrett = /** @class */ (function () {
    function Barrett(m) {
        this.m = m;
        // setup Barrett
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
    }
    // Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.convert = function (x) {
        if (x.s < 0 || x.t > 2 * this.m.t) {
            return x.mod(this.m);
        }
        else if (x.compareTo(this.m) < 0) {
            return x;
        }
        else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
        }
    };
    // Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.revert = function (x) {
        return x;
    };
    // Barrett.prototype.reduce = barrettReduce;
    // x = x mod m (HAC 14.42)
    Barrett.prototype.reduce = function (x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) {
            x.dAddOffset(1, this.m.t + 1);
        }
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Barrett.prototype.mulTo = barrettMulTo;
    // r = x*y mod m; x,y != r
    Barrett.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Barrett.prototype.sqrTo = barrettSqrTo;
    // r = x^2 mod m; x != r
    Barrett.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Barrett;
}());
//#endregion
//#endregion REDUCERS
// return new, unset BigInteger
function nbi() { return new BigInteger(null); }
function parseBigInt(str, r) {
    return new BigInteger(str, r);
}
// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
    while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 0x4000000);
        w[j++] = v & 0x3ffffff;
    }
    return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
    var xl = x & 0x7fff;
    var xh = x >> 15;
    while (--n >= 0) {
        var l = this[i] & 0x7fff;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 0x3fffffff;
    }
    return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
    var xl = x & 0x3fff;
    var xh = x >> 14;
    while (--n >= 0) {
        var l = this[i] & 0x3fff;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 0xfffffff;
    }
    return c;
}
if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    BigInteger.prototype.am = am2;
    dbits = 30;
}
else if (j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
// Digit conversions
var BI_RC = [];
var rr;
var vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
}
// return bigint initialized to value
function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
}
// returns bit length of the integer x
function nbits(x) {
    var r = 1;
    var t;
    if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
    }
    if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
    }
    if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
    }
    if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
    }
    if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
    }
    return r;
}
// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// prng4.js - uses Arcfour as a PRNG
var Arcfour = /** @class */ (function () {
    function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = [];
    }
    // Arcfour.prototype.init = ARC4init;
    // Initialize arcfour context from key, an array of ints, each from [0..255]
    Arcfour.prototype.init = function (key) {
        var i;
        var j;
        var t;
        for (i = 0; i < 256; ++i) {
            this.S[i] = i;
        }
        j = 0;
        for (i = 0; i < 256; ++i) {
            j = (j + this.S[i] + key[i % key.length]) & 255;
            t = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t;
        }
        this.i = 0;
        this.j = 0;
    };
    // Arcfour.prototype.next = ARC4next;
    Arcfour.prototype.next = function () {
        var t;
        this.i = (this.i + 1) & 255;
        this.j = (this.j + this.S[this.i]) & 255;
        t = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t;
        return this.S[(t + this.S[this.i]) & 255];
    };
    return Arcfour;
}());
// Plug in your RNG constructor here
function prng_newstate() {
    return new Arcfour();
}
// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;

// Random number generator - requires a PRNG backend, e.g. prng4.js
var rng_state;
var rng_pool = null;
var rng_pptr;
// Initialize the pool with junk if needed.
if (rng_pool == null) {
    rng_pool = [];
    rng_pptr = 0;
    var t = void 0;
    if (window.crypto && window.crypto.getRandomValues) {
        // Extract entropy (2048 bits) from RNG if available
        var z = new Uint32Array(256);
        window.crypto.getRandomValues(z);
        for (t = 0; t < z.length; ++t) {
            rng_pool[rng_pptr++] = z[t] & 255;
        }
    }
    // Use mouse events for entropy, if we do not have enough entropy by the time
    // we need it, entropy will be generated by Math.random.
    var onMouseMoveListener_1 = function (ev) {
        this.count = this.count || 0;
        if (this.count >= 256 || rng_pptr >= rng_psize) {
            if (window.removeEventListener) {
                window.removeEventListener("mousemove", onMouseMoveListener_1, false);
            }
            else if (window.detachEvent) {
                window.detachEvent("onmousemove", onMouseMoveListener_1);
            }
            return;
        }
        try {
            var mouseCoordinates = ev.x + ev.y;
            rng_pool[rng_pptr++] = mouseCoordinates & 255;
            this.count += 1;
        }
        catch (e) {
            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.
        }
    };
    if (window.addEventListener) {
        window.addEventListener("mousemove", onMouseMoveListener_1, false);
    }
    else if (window.attachEvent) {
        window.attachEvent("onmousemove", onMouseMoveListener_1);
    }
}
function rng_get_byte() {
    if (rng_state == null) {
        rng_state = prng_newstate();
        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random
        while (rng_pptr < rng_psize) {
            var random = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = random & 255;
        }
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
            rng_pool[rng_pptr] = 0;
        }
        rng_pptr = 0;
    }
    // TODO: allow reseeding after first request
    return rng_state.next();
}
var SecureRandom = /** @class */ (function () {
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = function (ba) {
        for (var i = 0; i < ba.length; ++i) {
            ba[i] = rng_get_byte();
        }
    };
    return SecureRandom;
}());

// Depends on jsbn.js and rng.js
// function linebrk(s,n) {
//   var ret = "";
//   var i = 0;
//   while(i + n < s.length) {
//     ret += s.substring(i,i+n) + "\n";
//     i += n;
//   }
//   return ret + s.substring(i,s.length);
// }
// function byte2Hex(b) {
//   if(b < 0x10)
//     return "0" + b.toString(16);
//   else
//     return b.toString(16);
// }
function pkcs1pad1(s, n) {
    if (n < s.length + 22) {
        console.error("Message too long for RSA");
        return null;
    }
    var len = n - s.length - 6;
    var filler = "";
    for (var f = 0; f < len; f += 2) {
        filler += "ff";
    }
    var m = "0001" + filler + "00" + s;
    return parseBigInt(m, 16);
}
// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s, n) {
    if (n < s.length + 11) { // TODO: fix for utf-8
        console.error("Message too long for RSA");
        return null;
    }
    var ba = [];
    var i = s.length - 1;
    while (i >= 0 && n > 0) {
        var c = s.charCodeAt(i--);
        if (c < 128) { // encode using utf-8
            ba[--n] = c;
        }
        else if ((c > 127) && (c < 2048)) {
            ba[--n] = (c & 63) | 128;
            ba[--n] = (c >> 6) | 192;
        }
        else {
            ba[--n] = (c & 63) | 128;
            ba[--n] = ((c >> 6) & 63) | 128;
            ba[--n] = (c >> 12) | 224;
        }
    }
    ba[--n] = 0;
    var rng = new SecureRandom();
    var x = [];
    while (n > 2) { // random non-zero pad
        x[0] = 0;
        while (x[0] == 0) {
            rng.nextBytes(x);
        }
        ba[--n] = x[0];
    }
    ba[--n] = 2;
    ba[--n] = 0;
    return new BigInteger(ba);
}
// "empty" RSA key constructor
var RSAKey = /** @class */ (function () {
    function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
    }
    //#region PROTECTED
    // protected
    // RSAKey.prototype.doPublic = RSADoPublic;
    // Perform raw public operation on "x": return x^e (mod n)
    RSAKey.prototype.doPublic = function (x) {
        return x.modPowInt(this.e, this.n);
    };
    // RSAKey.prototype.doPrivate = RSADoPrivate;
    // Perform raw private operation on "x": return x^d (mod n)
    RSAKey.prototype.doPrivate = function (x) {
        if (this.p == null || this.q == null) {
            return x.modPow(this.d, this.n);
        }
        // TODO: re-calculate any missing CRT params
        var xp = x.mod(this.p).modPow(this.dmp1, this.p);
        var xq = x.mod(this.q).modPow(this.dmq1, this.q);
        while (xp.compareTo(xq) < 0) {
            xp = xp.add(this.p);
        }
        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
    };
    //#endregion PROTECTED
    //#region PUBLIC
    // RSAKey.prototype.setPublic = RSASetPublic;
    // Set the public key fields N and e from hex strings
    RSAKey.prototype.setPublic = function (N, E) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
        }
        else {
            console.error("Invalid RSA public key");
        }
    };
    // RSAKey.prototype.encrypt = RSAEncrypt;
    // Return the PKCS#1 RSA encryption of "text" as an even-length hex string
    RSAKey.prototype.encrypt = function (text) {
        var m = pkcs1pad2(text, (this.n.bitLength() + 7) >> 3);
        if (m == null) {
            return null;
        }
        var c = this.doPublic(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    // RSAKey.prototype.setPrivate = RSASetPrivate;
    // Set the private key fields N, e, and d from hex strings
    RSAKey.prototype.setPrivate = function (N, E, D) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
    // Set the private key fields N, e, d and CRT params from hex strings
    RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
            this.p = parseBigInt(P, 16);
            this.q = parseBigInt(Q, 16);
            this.dmp1 = parseBigInt(DP, 16);
            this.dmq1 = parseBigInt(DQ, 16);
            this.coeff = parseBigInt(C, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.generate = RSAGenerate;
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generate = function (B, E) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        for (;;) {
            for (;;) {
                this.p = new BigInteger(B - qs, 1, rng);
                if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
                    break;
                }
            }
            for (;;) {
                this.q = new BigInteger(qs, 1, rng);
                if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
                    break;
                }
            }
            if (this.p.compareTo(this.q) <= 0) {
                var t = this.p;
                this.p = this.q;
                this.q = t;
            }
            var p1 = this.p.subtract(BigInteger.ONE);
            var q1 = this.q.subtract(BigInteger.ONE);
            var phi = p1.multiply(q1);
            if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                this.n = this.p.multiply(this.q);
                this.d = ee.modInverse(phi);
                this.dmp1 = this.d.mod(p1);
                this.dmq1 = this.d.mod(q1);
                this.coeff = this.q.modInverse(this.p);
                break;
            }
        }
    };
    // RSAKey.prototype.decrypt = RSADecrypt;
    // Return the PKCS#1 RSA decryption of "ctext".
    // "ctext" is an even-length hex string and the output is a plain string.
    RSAKey.prototype.decrypt = function (ctext) {
        var c = parseBigInt(ctext, 16);
        var m = this.doPrivate(c);
        if (m == null) {
            return null;
        }
        return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);
    };
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generateAsync = function (B, E, callback) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        var rsa = this;
        // These functions have non-descript names because they were originally for(;;) loops.
        // I don't know about cryptography to give them better names than loop1-4.
        var loop1 = function () {
            var loop4 = function () {
                if (rsa.p.compareTo(rsa.q) <= 0) {
                    var t = rsa.p;
                    rsa.p = rsa.q;
                    rsa.q = t;
                }
                var p1 = rsa.p.subtract(BigInteger.ONE);
                var q1 = rsa.q.subtract(BigInteger.ONE);
                var phi = p1.multiply(q1);
                if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                    rsa.n = rsa.p.multiply(rsa.q);
                    rsa.d = ee.modInverse(phi);
                    rsa.dmp1 = rsa.d.mod(p1);
                    rsa.dmq1 = rsa.d.mod(q1);
                    rsa.coeff = rsa.q.modInverse(rsa.p);
                    setTimeout(function () { callback(); }, 0); // escape
                }
                else {
                    setTimeout(loop1, 0);
                }
            };
            var loop3 = function () {
                rsa.q = nbi();
                rsa.q.fromNumberAsync(qs, 1, rng, function () {
                    rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
                            setTimeout(loop4, 0);
                        }
                        else {
                            setTimeout(loop3, 0);
                        }
                    });
                });
            };
            var loop2 = function () {
                rsa.p = nbi();
                rsa.p.fromNumberAsync(B - qs, 1, rng, function () {
                    rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
                            setTimeout(loop3, 0);
                        }
                        else {
                            setTimeout(loop2, 0);
                        }
                    });
                });
            };
            setTimeout(loop2, 0);
        };
        setTimeout(loop1, 0);
    };
    RSAKey.prototype.sign = function (text, digestMethod, digestName) {
        var header = getDigestHeader(digestName);
        var digest = header + digestMethod(text).toString();
        var m = pkcs1pad1(digest, this.n.bitLength() / 4);
        if (m == null) {
            return null;
        }
        var c = this.doPrivate(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    RSAKey.prototype.verify = function (text, signature, digestMethod) {
        var c = parseBigInt(signature, 16);
        var m = this.doPublic(c);
        if (m == null) {
            return null;
        }
        var unpadded = m.toString(16).replace(/^1f+00/, "");
        var digest = removeDigestHeader(unpadded);
        return digest == digestMethod(text).toString();
    };
    return RSAKey;
}());
// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d, n) {
    var b = d.toByteArray();
    var i = 0;
    while (i < b.length && b[i] == 0) {
        ++i;
    }
    if (b.length - i != n - 1 || b[i] != 2) {
        return null;
    }
    ++i;
    while (b[i] != 0) {
        if (++i >= b.length) {
            return null;
        }
    }
    var ret = "";
    while (++i < b.length) {
        var c = b[i] & 255;
        if (c < 128) { // utf-8 decode
            ret += String.fromCharCode(c);
        }
        else if ((c > 191) && (c < 224)) {
            ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
            ++i;
        }
        else {
            ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
            i += 2;
        }
    }
    return ret;
}
// https://tools.ietf.org/html/rfc3447#page-43
var DIGEST_HEADERS = {
    md2: "3020300c06082a864886f70d020205000410",
    md5: "3020300c06082a864886f70d020505000410",
    sha1: "3021300906052b0e03021a05000414",
    sha224: "302d300d06096086480165030402040500041c",
    sha256: "3031300d060960864801650304020105000420",
    sha384: "3041300d060960864801650304020205000430",
    sha512: "3051300d060960864801650304020305000440",
    ripemd160: "3021300906052b2403020105000414",
};
function getDigestHeader(name) {
    return DIGEST_HEADERS[name] || "";
}
function removeDigestHeader(str) {
    for (var name_1 in DIGEST_HEADERS) {
        if (DIGEST_HEADERS.hasOwnProperty(name_1)) {
            var header = DIGEST_HEADERS[name_1];
            var len = header.length;
            if (str.substr(0, len) == header) {
                return str.substr(len);
            }
        }
    }
    return str;
}
// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
// function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
// }
// public
// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
var YAHOO = {};
YAHOO.lang = {
    /**
     * Utility to set up the prototype, constructor and superclass properties to
     * support an inheritance strategy that can chain constructors and methods.
     * Static members will not be inherited.
     *
     * @method extend
     * @static
     * @param {Function} subc   the object to modify
     * @param {Function} superc the object to inherit
     * @param {Object} overrides  additional properties/methods to add to the
     *                              subclass prototype.  These will override the
     *                              matching items obtained from the superclass
     *                              if present.
     */
    extend: function(subc, superc, overrides) {
        if (! superc || ! subc) {
            throw new Error("YAHOO.lang.extend failed, please check that " +
                "all dependencies are included.");
        }

        var F = function() {};
        F.prototype = superc.prototype;
        subc.prototype = new F();
        subc.prototype.constructor = subc;
        subc.superclass = superc.prototype;

        if (superc.prototype.constructor == Object.prototype.constructor) {
            superc.prototype.constructor = superc;
        }

        if (overrides) {
            var i;
            for (i in overrides) {
                subc.prototype[i] = overrides[i];
            }

            /*
             * IE will not enumerate native functions in a derived object even if the
             * function was overridden.  This is a workaround for specific functions
             * we care about on the Object prototype.
             * @property _IEEnumFix
             * @param {Function} r  the object to receive the augmentation
             * @param {Function} s  the object that supplies the properties to augment
             * @static
             * @private
             */
            var _IEEnumFix = function() {},
                ADD = ["toString", "valueOf"];
            try {
                if (/MSIE/.test(navigator.userAgent)) {
                    _IEEnumFix = function(r, s) {
                        for (i = 0; i < ADD.length; i = i + 1) {
                            var fname = ADD[i], f = s[fname];
                            if (typeof f === 'function' && f != Object.prototype[fname]) {
                                r[fname] = f;
                            }
                        }
                    };
                }
            } catch (ex) {}            _IEEnumFix(subc.prototype, overrides);
        }
    }
};

/* asn1-1.0.13.js (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */

/**
 * @fileOverview
 * @name asn1-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version asn1 1.0.13 (2017-Jun-02)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * kjur's class library name space
 * <p>
 * This name space provides following name spaces:
 * <ul>
 * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>
 * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>
 * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature
 * class and utilities</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * @name KJUR
 * @namespace kjur's class library name space
 */
var KJUR = {};

/**
 * kjur's ASN.1 class library name space
 * <p>
 * This is ITU-T X.690 ASN.1 DER encoder class library and
 * class structure and methods is very similar to
 * org.bouncycastle.asn1 package of
 * well known BouncyCaslte Cryptography Library.
 * <h4>PROVIDING ASN.1 PRIMITIVES</h4>
 * Here are ASN.1 DER primitive classes.
 * <ul>
 * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>
 * <li>0x02 {@link KJUR.asn1.DERInteger}</li>
 * <li>0x03 {@link KJUR.asn1.DERBitString}</li>
 * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>
 * <li>0x05 {@link KJUR.asn1.DERNull}</li>
 * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>
 * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>
 * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>
 * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>
 * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>
 * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>
 * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>
 * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>
 * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>
 * <li>0x30 {@link KJUR.asn1.DERSequence}</li>
 * <li>0x31 {@link KJUR.asn1.DERSet}</li>
 * </ul>
 * <h4>OTHER ASN.1 CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ASN1Object}</li>
 * <li>{@link KJUR.asn1.DERAbstractString}</li>
 * <li>{@link KJUR.asn1.DERAbstractTime}</li>
 * <li>{@link KJUR.asn1.DERAbstractStructured}</li>
 * <li>{@link KJUR.asn1.DERTaggedObject}</li>
 * </ul>
 * <h4>SUB NAME SPACES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>
 * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>
 * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>
 * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>
 * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace.
 * This caused by a bug of jsdoc2.
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * ASN1 utilities class
 * @name KJUR.asn1.ASN1Util
 * @class ASN1 utilities class
 * @since asn1 1.0.2
 */
KJUR.asn1.ASN1Util = new function() {
    this.integerToByteHex = function(i) {
        var h = i.toString(16);
        if ((h.length % 2) == 1) h = '0' + h;
        return h;
    };
    this.bigIntToMinTwosComplementsHex = function(bigIntegerValue) {
        var h = bigIntegerValue.toString(16);
        if (h.substr(0, 1) != '-') {
            if (h.length % 2 == 1) {
                h = '0' + h;
            } else {
                if (! h.match(/^[0-7]/)) {
                    h = '00' + h;
                }
            }
        } else {
            var hPos = h.substr(1);
            var xorLen = hPos.length;
            if (xorLen % 2 == 1) {
                xorLen += 1;
            } else {
                if (! h.match(/^[0-7]/)) {
                    xorLen += 2;
                }
            }
            var hMask = '';
            for (var i = 0; i < xorLen; i++) {
                hMask += 'f';
            }
            var biMask = new BigInteger(hMask, 16);
            var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
            h = biNeg.toString(16).replace(/^-/, '');
        }
        return h;
    };
    /**
     * get PEM string from hexadecimal data and header string
     * @name getPEMStringFromHex
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {String} dataHex hexadecimal string of PEM body
     * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
     * @return {String} PEM formatted string of input data
     * @description
     * This method converts a hexadecimal string to a PEM string with
     * a specified header. Its line break will be CRLF("\r\n").
     * @example
     * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');
     * // value of pem will be:
     * -----BEGIN PRIVATE KEY-----
     * YWFh
     * -----END PRIVATE KEY-----
     */
    this.getPEMStringFromHex = function(dataHex, pemHeader) {
        return hextopem(dataHex, pemHeader);
    };

    /**
     * generate ASN1Object specifed by JSON parameters
     * @name newObject
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return {KJUR.asn1.ASN1Object} generated object
     * @since asn1 1.0.3
     * @description
     * generate any ASN1Object specified by JSON param
     * including ASN.1 primitive or structured.
     * Generally 'param' can be described as follows:
     * <blockquote>
     * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}
     * </blockquote>
     * 'TYPE-OF-ASN1OBJ' can be one of following symbols:
     * <ul>
     * <li>'bool' - DERBoolean</li>
     * <li>'int' - DERInteger</li>
     * <li>'bitstr' - DERBitString</li>
     * <li>'octstr' - DEROctetString</li>
     * <li>'null' - DERNull</li>
     * <li>'oid' - DERObjectIdentifier</li>
     * <li>'enum' - DEREnumerated</li>
     * <li>'utf8str' - DERUTF8String</li>
     * <li>'numstr' - DERNumericString</li>
     * <li>'prnstr' - DERPrintableString</li>
     * <li>'telstr' - DERTeletexString</li>
     * <li>'ia5str' - DERIA5String</li>
     * <li>'utctime' - DERUTCTime</li>
     * <li>'gentime' - DERGeneralizedTime</li>
     * <li>'seq' - DERSequence</li>
     * <li>'set' - DERSet</li>
     * <li>'tag' - DERTaggedObject</li>
     * </ul>
     * @example
     * newObject({'prnstr': 'aaa'});
     * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})
     * // ASN.1 Tagged Object
     * newObject({'tag': {'tag': 'a1',
     *                    'explicit': true,
     *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});
     * // more simple representation of ASN.1 Tagged Object
     * newObject({'tag': ['a1',
     *                    true,
     *                    {'seq': [
     *                      {'int': 3},
     *                      {'prnstr': 'aaa'}]}
     *                   ]});
     */
    this.newObject = function(param) {
        var _KJUR = KJUR,
            _KJUR_asn1 = _KJUR.asn1,
            _DERBoolean = _KJUR_asn1.DERBoolean,
            _DERInteger = _KJUR_asn1.DERInteger,
            _DERBitString = _KJUR_asn1.DERBitString,
            _DEROctetString = _KJUR_asn1.DEROctetString,
            _DERNull = _KJUR_asn1.DERNull,
            _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
            _DEREnumerated = _KJUR_asn1.DEREnumerated,
            _DERUTF8String = _KJUR_asn1.DERUTF8String,
            _DERNumericString = _KJUR_asn1.DERNumericString,
            _DERPrintableString = _KJUR_asn1.DERPrintableString,
            _DERTeletexString = _KJUR_asn1.DERTeletexString,
            _DERIA5String = _KJUR_asn1.DERIA5String,
            _DERUTCTime = _KJUR_asn1.DERUTCTime,
            _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
            _DERSequence = _KJUR_asn1.DERSequence,
            _DERSet = _KJUR_asn1.DERSet,
            _DERTaggedObject = _KJUR_asn1.DERTaggedObject,
            _newObject = _KJUR_asn1.ASN1Util.newObject;

        var keys = Object.keys(param);
        if (keys.length != 1)
            throw "key of param shall be only one.";
        var key = keys[0];

        if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + key + ":") == -1)
            throw "undefined key: " + key;

        if (key == "bool")    return new _DERBoolean(param[key]);
        if (key == "int")     return new _DERInteger(param[key]);
        if (key == "bitstr")  return new _DERBitString(param[key]);
        if (key == "octstr")  return new _DEROctetString(param[key]);
        if (key == "null")    return new _DERNull(param[key]);
        if (key == "oid")     return new _DERObjectIdentifier(param[key]);
        if (key == "enum")    return new _DEREnumerated(param[key]);
        if (key == "utf8str") return new _DERUTF8String(param[key]);
        if (key == "numstr")  return new _DERNumericString(param[key]);
        if (key == "prnstr")  return new _DERPrintableString(param[key]);
        if (key == "telstr")  return new _DERTeletexString(param[key]);
        if (key == "ia5str")  return new _DERIA5String(param[key]);
        if (key == "utctime") return new _DERUTCTime(param[key]);
        if (key == "gentime") return new _DERGeneralizedTime(param[key]);

        if (key == "seq") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSequence({'array': a});
        }

        if (key == "set") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSet({'array': a});
        }

        if (key == "tag") {
            var tagParam = param[key];
            if (Object.prototype.toString.call(tagParam) === '[object Array]' &&
                tagParam.length == 3) {
                var obj = _newObject(tagParam[2]);
                return new _DERTaggedObject({tag: tagParam[0],
                    explicit: tagParam[1],
                    obj: obj});
            } else {
                var newParam = {};
                if (tagParam.explicit !== undefined)
                    newParam.explicit = tagParam.explicit;
                if (tagParam.tag !== undefined)
                    newParam.tag = tagParam.tag;
                if (tagParam.obj === undefined)
                    throw "obj shall be specified for 'tag'.";
                newParam.obj = _newObject(tagParam.obj);
                return new _DERTaggedObject(newParam);
            }
        }
    };

    /**
     * get encoded hexadecimal string of ASN1Object specifed by JSON parameters
     * @name jsonToASN1HEX
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return hexadecimal string of ASN1Object
     * @since asn1 1.0.4
     * @description
     * As for ASN.1 object representation of JSON object,
     * please see {@link newObject}.
     * @example
     * jsonToASN1HEX({'prnstr': 'aaa'});
     */
    this.jsonToASN1HEX = function(param) {
        var asn1Obj = this.newObject(param);
        return asn1Obj.getEncodedHex();
    };
};

/**
 * get dot noted oid number string from hexadecimal value of OID
 * @name oidHexToInt
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} hex hexadecimal value of object identifier
 * @return {String} dot noted string of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from hexadecimal string representation of
 * ASN.1 value of object identifier to oid number string.
 * @example
 * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; "2.5.4.6"
 */
KJUR.asn1.ASN1Util.oidHexToInt = function(hex) {
    var s = "";
    var i01 = parseInt(hex.substr(0, 2), 16);
    var i0 = Math.floor(i01 / 40);
    var i1 = i01 % 40;
    var s = i0 + "." + i1;

    var binbuf = "";
    for (var i = 2; i < hex.length; i += 2) {
        var value = parseInt(hex.substr(i, 2), 16);
        var bin = ("00000000" + value.toString(2)).slice(- 8);
        binbuf = binbuf + bin.substr(1, 7);
        if (bin.substr(0, 1) == "0") {
            var bi = new BigInteger(binbuf, 2);
            s = s + "." + bi.toString(10);
            binbuf = "";
        }
    }
    return s;
};

/**
 * get hexadecimal value of object identifier from dot noted oid value
 * @name oidIntToHex
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} oidString dot noted string of object identifier
 * @return {String} hexadecimal value of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from object identifier value string.
 * to hexadecimal string representation of it.
 * @example
 * KJUR.asn1.ASN1Util.oidIntToHex("2.5.4.6") &rarr; "550406"
 */
KJUR.asn1.ASN1Util.oidIntToHex = function(oidString) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };

    var roidtox = function(roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };

    if (! oidString.match(/^[0-9.]+$/)) {
        throw "malformed oid string: " + oidString;
    }
    var h = '';
    var a = oidString.split('.');
    var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
    h += itox(i0);
    a.splice(0, 2);
    for (var i = 0; i < a.length; i++) {
        h += roidtox(a[i]);
    }
    return h;
};


// ********************************************************************
//  Abstract ASN.1 Classes
// ********************************************************************

// ********************************************************************

/**
 * base class for ASN.1 DER encoder object
 * @name KJUR.asn1.ASN1Object
 * @class base class for ASN.1 DER encoder object
 * @property {Boolean} isModified flag whether internal data was changed
 * @property {String} hTLV hexadecimal string of ASN.1 TLV
 * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)
 * @property {String} hL hexadecimal string of ASN.1 TLV length(L)
 * @property {String} hV hexadecimal string of ASN.1 TLV value(V)
 * @description
 */
KJUR.asn1.ASN1Object = function() {
    var hV = '';

    /**
     * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)
     * @name getLengthHexFromValue
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV length(L)
     */
    this.getLengthHexFromValue = function() {
        if (typeof this.hV == "undefined" || this.hV == null) {
            throw "this.hV is null or undefined.";
        }
        if (this.hV.length % 2 == 1) {
            throw "value hex must be even length: n=" + hV.length + ",v=" + this.hV;
        }
        var n = this.hV.length / 2;
        var hN = n.toString(16);
        if (hN.length % 2 == 1) {
            hN = "0" + hN;
        }
        if (n < 128) {
            return hN;
        } else {
            var hNlen = hN.length / 2;
            if (hNlen > 15) {
                throw "ASN.1 length too long to represent by 8x: n = " + n.toString(16);
            }
            var head = 128 + hNlen;
            return head.toString(16) + hN;
        }
    };

    /**
     * get hexadecimal string of ASN.1 TLV bytes
     * @name getEncodedHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV
     */
    this.getEncodedHex = function() {
        if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
            //alert("first time: " + this.hTLV);
        }
        return this.hTLV;
    };

    /**
     * get hexadecimal string of ASN.1 TLV value(V) bytes
     * @name getValueHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes
     */
    this.getValueHex = function() {
        this.getEncodedHex();
        return this.hV;
    };

    this.getFreshValueHex = function() {
        return '';
    };
};

// == BEGIN DERAbstractString ================================================
/**
 * base class for ASN.1 DER string classes
 * @name KJUR.asn1.DERAbstractString
 * @class base class for ASN.1 DER string classes
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @property {String} s internal string of value
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERAbstractString = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);

    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @return {String} string value of this string object
     */
    this.getString = function() {
        return this.s;
    };

    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newS value by a string to set
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(this.s);
    };

    /**
     * set value by a hexadecimal string
     * @name setStringHex
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newHexString value by a hexadecimal string to set
     */
    this.setStringHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string") {
            this.setString(params);
        } else if (typeof params['str'] != "undefined") {
            this.setString(params['str']);
        } else if (typeof params['hex'] != "undefined") {
            this.setStringHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
// == END   DERAbstractString ================================================

// == BEGIN DERAbstractTime ==================================================
/**
 * base class for ASN.1 DER Generalized/UTCTime class
 * @name KJUR.asn1.DERAbstractTime
 * @class base class for ASN.1 DER Generalized/UTCTime class
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractTime = function(params) {
    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);

    // --- PRIVATE METHODS --------------------
    this.localDateToUTC = function(d) {
        utc = d.getTime() + (d.getTimezoneOffset() * 60000);
        var utcDate = new Date(utc);
        return utcDate;
    };

    /*
     * format date string by Data object
     * @name formatDate
     * @memberOf KJUR.asn1.AbstractTime;
     * @param {Date} dateObject
     * @param {string} type 'utc' or 'gen'
     * @param {boolean} withMillis flag for with millisections or not
     * @description
     * 'withMillis' flag is supported from asn1 1.0.6.
     */
    this.formatDate = function(dateObject, type, withMillis) {
        var pad = this.zeroPadding;
        var d = this.localDateToUTC(dateObject);
        var year = String(d.getFullYear());
        if (type == 'utc') year = year.substr(2, 2);
        var month = pad(String(d.getMonth() + 1), 2);
        var day = pad(String(d.getDate()), 2);
        var hour = pad(String(d.getHours()), 2);
        var min = pad(String(d.getMinutes()), 2);
        var sec = pad(String(d.getSeconds()), 2);
        var s = year + month + day + hour + min + sec;
        if (withMillis === true) {
            var millis = d.getMilliseconds();
            if (millis != 0) {
                var sMillis = pad(String(millis), 3);
                sMillis = sMillis.replace(/[0]+$/, "");
                s = s + "." + sMillis;
            }
        }
        return s + "Z";
    };

    this.zeroPadding = function(s, len) {
        if (s.length >= len) return s;
        return new Array(len - s.length + 1).join('0') + s;
    };

    // --- PUBLIC METHODS --------------------
    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @return {String} string value of this time object
     */
    this.getString = function() {
        return this.s;
    };

    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {String} newS value by a string to set such like "130430235959Z"
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(newS);
    };

    /**
     * set value by a Date object
     * @name setByDateValue
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {Integer} year year of date (ex. 2013)
     * @param {Integer} month month of date between 1 and 12 (ex. 12)
     * @param {Integer} day day of month
     * @param {Integer} hour hours of date
     * @param {Integer} min minutes of date
     * @param {Integer} sec seconds of date
     */
    this.setByDateValue = function(year, month, day, hour, min, sec) {
        var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
        this.setByDate(dateObject);
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
// == END   DERAbstractTime ==================================================

// == BEGIN DERAbstractStructured ============================================
/**
 * base class for ASN.1 DER structured class
 * @name KJUR.asn1.DERAbstractStructured
 * @class base class for ASN.1 DER structured class
 * @property {Array} asn1Array internal array of ASN1Object
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractStructured = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);

    /**
     * set value by array of ASN1Object
     * @name setByASN1ObjectArray
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {array} asn1ObjectArray array of ASN1Object to set
     */
    this.setByASN1ObjectArray = function(asn1ObjectArray) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = asn1ObjectArray;
    };

    /**
     * append an ASN1Object to internal array
     * @name appendASN1Object
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {ASN1Object} asn1Object to add
     */
    this.appendASN1Object = function(asn1Object) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(asn1Object);
    };

    this.asn1Array = new Array();
    if (typeof params != "undefined") {
        if (typeof params['array'] != "undefined") {
            this.asn1Array = params['array'];
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);


// ********************************************************************
//  ASN.1 Object Classes
// ********************************************************************

// ********************************************************************
/**
 * class for ASN.1 DER Boolean
 * @name KJUR.asn1.DERBoolean
 * @class class for ASN.1 DER Boolean
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERBoolean = function() {
    KJUR.asn1.DERBoolean.superclass.constructor.call(this);
    this.hT = "01";
    this.hTLV = "0101ff";
};
YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Integer
 * @name KJUR.asn1.DERInteger
 * @class class for ASN.1 DER Integer
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERInteger = function(params) {
    KJUR.asn1.DERInteger.superclass.constructor.call(this);
    this.hT = "02";

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DERInteger
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     * @example
     * new KJUR.asn1.DERInteger(123);
     * new KJUR.asn1.DERInteger({'int': 123});
     * new KJUR.asn1.DERInteger({'hex': '1fad'});
     */
    this.setValueHex = function(newHexString) {
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['bigint'] != "undefined") {
            this.setByBigInteger(params['bigint']);
        } else if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        } else if (typeof params == "number") {
            this.setByInteger(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER encoded BitString primitive
 * @name KJUR.asn1.DERBitString
 * @class class for ASN.1 DER encoded BitString primitive
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>bin - specify binary string (ex. '10111')</li>
 * <li>array - specify array of boolean (ex. [true,false,true,true])</li>
 * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>
 * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject}
 * argument for "BitString encapsulates" structure.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: 'obj' parameter have been supported since
 * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>
 * @example
 * // default constructor
 * o = new KJUR.asn1.DERBitString();
 * // initialize with binary string
 * o = new KJUR.asn1.DERBitString({bin: "1011"});
 * // initialize with boolean array
 * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});
 * // initialize with hexadecimal string (04 is unused bits)
 * o = new KJUR.asn1.DEROctetString({hex: "04bac0"});
 * // initialize with ASN1Util.newObject argument for encapsulated
 * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // BIT STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DERBitString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = "00" + o.getEncodedHex();
    }
    KJUR.asn1.DERBitString.superclass.constructor.call(this);
    this.hT = "03";

    /**
     * set ASN.1 value(V) by a hexadecimal string including unused bits
     * @name setHexValueIncludingUnusedBits
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} newHexStringIncludingUnusedBits
     */
    this.setHexValueIncludingUnusedBits = function(newHexStringIncludingUnusedBits) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = newHexStringIncludingUnusedBits;
    };

    /**
     * set ASN.1 value(V) by unused bit and hexadecimal string of value
     * @name setUnusedBitsAndHexValue
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {Integer} unusedBits
     * @param {String} hValue
     */
    this.setUnusedBitsAndHexValue = function(unusedBits, hValue) {
        if (unusedBits < 0 || 7 < unusedBits) {
            throw "unused bits shall be from 0 to 7: u = " + unusedBits;
        }
        var hUnusedBits = "0" + unusedBits;
        this.hTLV = null;
        this.isModified = true;
        this.hV = hUnusedBits + hValue;
    };

    /**
     * set ASN.1 DER BitString by binary string<br/>
     * @name setByBinaryString
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} binaryString binary value string (i.e. '10111')
     * @description
     * Its unused bits will be calculated automatically by length of
     * 'binaryValue'. <br/>
     * NOTE: Trailing zeros '0' will be ignored.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray("01011");
     */
    this.setByBinaryString = function(binaryString) {
        binaryString = binaryString.replace(/0+$/, '');
        var unusedBits = 8 - binaryString.length % 8;
        if (unusedBits == 8) unusedBits = 0;
        for (var i = 0; i <= unusedBits; i++) {
            binaryString += '0';
        }
        var h = '';
        for (var i = 0; i < binaryString.length - 1; i += 8) {
            var b = binaryString.substr(i, 8);
            var x = parseInt(b, 2).toString(16);
            if (x.length == 1) x = '0' + x;
            h += x;
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = '0' + unusedBits + h;
    };

    /**
     * set ASN.1 TLV value(V) by an array of boolean<br/>
     * @name setByBooleanArray
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {array} booleanArray array of boolean (ex. [true, false, true])
     * @description
     * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray([false, true, false, true, true]);
     */
    this.setByBooleanArray = function(booleanArray) {
        var s = '';
        for (var i = 0; i < booleanArray.length; i++) {
            if (booleanArray[i] == true) {
                s += '1';
            } else {
                s += '0';
            }
        }
        this.setByBinaryString(s);
    };

    /**
     * generate an array of falses with specified length<br/>
     * @name newFalseArray
     * @memberOf KJUR.asn1.DERBitString
     * @function
     * @param {Integer} nLength length of array to generate
     * @return {array} array of boolean falses
     * @description
     * This static method may be useful to initialize boolean array.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.newFalseArray(3) &rarr; [false, false, false]
     */
    this.newFalseArray = function(nLength) {
        var a = new Array(nLength);
        for (var i = 0; i < nLength; i++) {
            a[i] = false;
        }
        return a;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string" && params.toLowerCase().match(/^[0-9a-f]+$/)) {
            this.setHexValueIncludingUnusedBits(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setHexValueIncludingUnusedBits(params['hex']);
        } else if (typeof params['bin'] != "undefined") {
            this.setByBinaryString(params['bin']);
        } else if (typeof params['array'] != "undefined") {
            this.setByBooleanArray(params['array']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER OctetString<br/>
 * @name KJUR.asn1.DEROctetString
 * @class class for ASN.1 DER OctetString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * This class provides ASN.1 OctetString simple type.<br/>
 * Supported "params" attributes are:
 * <ul>
 * <li>str - to set a string as a value</li>
 * <li>hex - to set a hexadecimal string as a value</li>
 * <li>obj - to set a encapsulated ASN.1 value by JSON object
 * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>
 * </ul>
 * NOTE: A parameter 'obj' have been supported
 * for "OCTET STRING, encapsulates" structure.
 * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).
 * @see KJUR.asn1.DERAbstractString - superclass
 * @example
 * // default constructor
 * o = new KJUR.asn1.DEROctetString();
 * // initialize with string
 * o = new KJUR.asn1.DEROctetString({str: "aaa"});
 * // initialize with hexadecimal string
 * o = new KJUR.asn1.DEROctetString({hex: "616161"});
 * // initialize with ASN1Util.newObject argument
 * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // OCTET STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DEROctetString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = o.getEncodedHex();
    }
    KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
    this.hT = "04";
};
YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER Null
 * @name KJUR.asn1.DERNull
 * @class class for ASN.1 DER Null
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERNull = function() {
    KJUR.asn1.DERNull.superclass.constructor.call(this);
    this.hT = "05";
    this.hTLV = "0500";
};
YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER ObjectIdentifier
 * @name KJUR.asn1.DERObjectIdentifier
 * @class class for ASN.1 DER ObjectIdentifier
 * @param {Array} params associative array of parameters (ex. {'oid': '2.5.4.5'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERObjectIdentifier = function(params) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };
    var roidtox = function(roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };

    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
    this.hT = "06";

    /**
     * set value by a hexadecimal string
     * @name setValueHex
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} newHexString hexadecimal value of OID bytes
     */
    this.setValueHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    /**
     * set value by a OID string<br/>
     * @name setValueOidString
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidString OID string (ex. 2.5.4.13)
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueOidString("2.5.4.13");
     */
    this.setValueOidString = function(oidString) {
        if (! oidString.match(/^[0-9.]+$/)) {
            throw "malformed oid string: " + oidString;
        }
        var h = '';
        var a = oidString.split('.');
        var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
        h += itox(i0);
        a.splice(0, 2);
        for (var i = 0; i < a.length; i++) {
            h += roidtox(a[i]);
        }
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = h;
    };

    /**
     * set value by a OID name
     * @name setValueName
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidName OID name (ex. 'serverAuth')
     * @since 1.0.1
     * @description
     * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.
     * Otherwise raise error.
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueName("serverAuth");
     */
    this.setValueName = function(oidName) {
        var oid = KJUR.asn1.x509.OID.name2oid(oidName);
        if (oid !== '') {
            this.setValueOidString(oid);
        } else {
            throw "DERObjectIdentifier oidName undefined: " + oidName;
        }
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (params !== undefined) {
        if (typeof params === "string") {
            if (params.match(/^[0-2].[0-9.]+$/)) {
                this.setValueOidString(params);
            } else {
                this.setValueName(params);
            }
        } else if (params.oid !== undefined) {
            this.setValueOidString(params.oid);
        } else if (params.hex !== undefined) {
            this.setValueHex(params.hex);
        } else if (params.name !== undefined) {
            this.setValueName(params.name);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Enumerated
 * @name KJUR.asn1.DEREnumerated
 * @class class for ASN.1 DER Enumerated
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * @example
 * new KJUR.asn1.DEREnumerated(123);
 * new KJUR.asn1.DEREnumerated({int: 123});
 * new KJUR.asn1.DEREnumerated({hex: '1fad'});
 */
KJUR.asn1.DEREnumerated = function(params) {
    KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
    this.hT = "0a";

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     */
    this.setValueHex = function(newHexString) {
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        } else if (typeof params == "number") {
            this.setByInteger(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER UTF8String
 * @name KJUR.asn1.DERUTF8String
 * @class class for ASN.1 DER UTF8String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERUTF8String = function(params) {
    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
    this.hT = "0c";
};
YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER NumericString
 * @name KJUR.asn1.DERNumericString
 * @class class for ASN.1 DER NumericString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERNumericString = function(params) {
    KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
    this.hT = "12";
};
YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER PrintableString
 * @name KJUR.asn1.DERPrintableString
 * @class class for ASN.1 DER PrintableString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERPrintableString = function(params) {
    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
    this.hT = "13";
};
YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER TeletexString
 * @name KJUR.asn1.DERTeletexString
 * @class class for ASN.1 DER TeletexString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERTeletexString = function(params) {
    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
    this.hT = "14";
};
YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER IA5String
 * @name KJUR.asn1.DERIA5String
 * @class class for ASN.1 DER IA5String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERIA5String = function(params) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
    this.hT = "16";
};
YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER UTCTime
 * @name KJUR.asn1.DERUTCTime
 * @class class for ASN.1 DER UTCTime
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * <h4>EXAMPLES</h4>
 * @example
 * d1 = new KJUR.asn1.DERUTCTime();
 * d1.setString('130430125959Z');
 *
 * d2 = new KJUR.asn1.DERUTCTime({'str': '130430125959Z'});
 * d3 = new KJUR.asn1.DERUTCTime({'date': new Date(Date.UTC(2015, 0, 31, 0, 0, 0, 0))});
 * d4 = new KJUR.asn1.DERUTCTime('130430125959Z');
 */
KJUR.asn1.DERUTCTime = function(params) {
    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
    this.hT = "17";

    /**
     * set value by a Date object<br/>
     * @name setByDate
     * @memberOf KJUR.asn1.DERUTCTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * o = new KJUR.asn1.DERUTCTime();
     * o.setByDate(new Date("2016/12/31"));
     */
    this.setByDate = function(dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'utc');
        this.hV = stohex(this.s);
    };

    this.getFreshValueHex = function() {
        if (typeof this.date == "undefined" && typeof this.s == "undefined") {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'utc');
            this.hV = stohex(this.s);
        }
        return this.hV;
    };

    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        } else if (typeof params == "string" && params.match(/^[0-9]{12}Z$/)) {
            this.setString(params);
        } else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        } else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER GeneralizedTime
 * @name KJUR.asn1.DERGeneralizedTime
 * @class class for ASN.1 DER GeneralizedTime
 * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})
 * @property {Boolean} withMillis flag to show milliseconds or not
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
 * </ul>
 * NOTE1: 'params' can be omitted.
 * NOTE2: 'withMillis' property is supported from asn1 1.0.6.
 */
KJUR.asn1.DERGeneralizedTime = function(params) {
    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
    this.hT = "18";
    this.withMillis = false;

    /**
     * set value by a Date object
     * @name setByDate
     * @memberOf KJUR.asn1.DERGeneralizedTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * When you specify UTC time, use 'Date.UTC' method like this:<br/>
     * o1 = new DERUTCTime();
     * o1.setByDate(date);
     *
     * date = new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)); #2015JAN31 23:59:59
     */
    this.setByDate = function(dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'gen', this.withMillis);
        this.hV = stohex(this.s);
    };

    this.getFreshValueHex = function() {
        if (this.date === undefined && this.s === undefined) {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'gen', this.withMillis);
            this.hV = stohex(this.s);
        }
        return this.hV;
    };

    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        } else if (typeof params == "string" && params.match(/^[0-9]{14}Z$/)) {
            this.setString(params);
        } else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        } else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
        if (params.millis === true) {
            this.withMillis = true;
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER Sequence
 * @name KJUR.asn1.DERSequence
 * @class class for ASN.1 DER Sequence
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERSequence = function(params) {
    KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
    this.hT = "30";
    this.getFreshValueHex = function() {
        var h = '';
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            h += asn1Obj.getEncodedHex();
        }
        this.hV = h;
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER Set
 * @name KJUR.asn1.DERSet
 * @class class for ASN.1 DER Set
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: sortflag is supported since 1.0.5.
 */
KJUR.asn1.DERSet = function(params) {
    KJUR.asn1.DERSet.superclass.constructor.call(this, params);
    this.hT = "31";
    this.sortFlag = true; // item shall be sorted only in ASN.1 DER
    this.getFreshValueHex = function() {
        var a = new Array();
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            a.push(asn1Obj.getEncodedHex());
        }
        if (this.sortFlag == true) a.sort();
        this.hV = a.join('');
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params.sortflag != "undefined" &&
            params.sortflag == false)
            this.sortFlag = false;
    }
};
YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER TaggedObject
 * @name KJUR.asn1.DERTaggedObject
 * @class class for ASN.1 DER TaggedObject
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.
 * For example, if you find '[1]' tag in a ASN.1 dump,
 * 'tagNoHex' will be 'a1'.
 * <br/>
 * As for optional argument 'params' for constructor, you can specify *ANY* of
 * following properties:
 * <ul>
 * <li>explicit - specify true if this is explicit tag otherwise false
 *     (default is 'true').</li>
 * <li>tag - specify tag (default is 'a0' which means [0])</li>
 * <li>obj - specify ASN1Object which is tagged</li>
 * </ul>
 * @example
 * d1 = new KJUR.asn1.DERUTF8String({'str':'a'});
 * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});
 * hex = d2.getEncodedHex();
 */
KJUR.asn1.DERTaggedObject = function(params) {
    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
    this.hT = "a0";
    this.hV = '';
    this.isExplicit = true;
    this.asn1Object = null;

    /**
     * set value by an ASN1Object
     * @name setString
     * @memberOf KJUR.asn1.DERTaggedObject#
     * @function
     * @param {Boolean} isExplicitFlag flag for explicit/implicit tag
     * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag
     * @param {ASN1Object} asn1Object ASN.1 to encapsulate
     */
    this.setASN1Object = function(isExplicitFlag, tagNoHex, asn1Object) {
        this.hT = tagNoHex;
        this.isExplicit = isExplicitFlag;
        this.asn1Object = asn1Object;
        if (this.isExplicit) {
            this.hV = this.asn1Object.getEncodedHex();
            this.hTLV = null;
            this.isModified = true;
        } else {
            this.hV = null;
            this.hTLV = asn1Object.getEncodedHex();
            this.hTLV = this.hTLV.replace(/^../, tagNoHex);
            this.isModified = false;
        }
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['tag'] != "undefined") {
            this.hT = params['tag'];
        }
        if (typeof params['explicit'] != "undefined") {
            this.isExplicit = params['explicit'];
        }
        if (typeof params['obj'] != "undefined") {
            this.asn1Object = params['obj'];
            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);

/**
 * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.
 * This object is just a decorator for parsing the key parameter
 * @param {string|Object} key - The key in string format, or an object containing
 * the parameters needed to build a RSAKey object.
 * @constructor
 */
var JSEncryptRSAKey = /** @class */ (function (_super) {
    __extends(JSEncryptRSAKey, _super);
    function JSEncryptRSAKey(key) {
        var _this = _super.call(this) || this;
        // Call the super constructor.
        //  RSAKey.call(this);
        // If a key key was provided.
        if (key) {
            // If this is a string...
            if (typeof key === "string") {
                _this.parseKey(key);
            }
            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||
                JSEncryptRSAKey.hasPublicKeyProperty(key)) {
                // Set the values for the key.
                _this.parsePropertiesFrom(key);
            }
        }
        return _this;
    }
    /**
     * Method to parse a pem encoded string containing both a public or private key.
     * The method will translate the pem encoded string in a der encoded string and
     * will parse private key and public key parameters. This method accepts public key
     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).
     *
     * @todo Check how many rsa formats use the same format of pkcs #1.
     *
     * The format is defined as:
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * it's possible to examine the structure of the keys obtained from openssl using
     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/
     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer
     * @private
     */
    JSEncryptRSAKey.prototype.parseKey = function (pem) {
        try {
            var modulus = 0;
            var public_exponent = 0;
            var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
            var asn1 = ASN1.decode(der);
            // Fixes a bug with OpenSSL 1.0+ private keys
            if (asn1.sub.length === 3) {
                asn1 = asn1.sub[2].sub[0];
            }
            if (asn1.sub.length === 9) {
                // Parse the private key.
                modulus = asn1.sub[1].getHexStringValue(); // bigint
                this.n = parseBigInt(modulus, 16);
                public_exponent = asn1.sub[2].getHexStringValue(); // int
                this.e = parseInt(public_exponent, 16);
                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint
                this.d = parseBigInt(private_exponent, 16);
                var prime1 = asn1.sub[4].getHexStringValue(); // bigint
                this.p = parseBigInt(prime1, 16);
                var prime2 = asn1.sub[5].getHexStringValue(); // bigint
                this.q = parseBigInt(prime2, 16);
                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint
                this.dmp1 = parseBigInt(exponent1, 16);
                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint
                this.dmq1 = parseBigInt(exponent2, 16);
                var coefficient = asn1.sub[8].getHexStringValue(); // bigint
                this.coeff = parseBigInt(coefficient, 16);
            }
            else if (asn1.sub.length === 2) {
                // Parse the public key.
                var bit_string = asn1.sub[1];
                var sequence = bit_string.sub[0];
                modulus = sequence.sub[0].getHexStringValue();
                this.n = parseBigInt(modulus, 16);
                public_exponent = sequence.sub[1].getHexStringValue();
                this.e = parseInt(public_exponent, 16);
            }
            else {
                return false;
            }
            return true;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa key.
     *
     * The translation follow the ASN.1 notation :
     * RSAPrivateKey ::= SEQUENCE {
     *   version           Version,
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER,  -- e
     *   privateExponent   INTEGER,  -- d
     *   prime1            INTEGER,  -- p
     *   prime2            INTEGER,  -- q
     *   exponent1         INTEGER,  -- d mod (p1)
     *   exponent2         INTEGER,  -- d mod (q-1)
     *   coefficient       INTEGER,  -- (inverse of q) mod p
     * }
     * @returns {string}  DER Encoded String representing the rsa private key
     * @private
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {
        var options = {
            array: [
                new KJUR.asn1.DERInteger({ int: 0 }),
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e }),
                new KJUR.asn1.DERInteger({ bigint: this.d }),
                new KJUR.asn1.DERInteger({ bigint: this.p }),
                new KJUR.asn1.DERInteger({ bigint: this.q }),
                new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),
                new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),
                new KJUR.asn1.DERInteger({ bigint: this.coeff })
            ]
        };
        var seq = new KJUR.asn1.DERSequence(options);
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {
        return hex2b64(this.getPrivateBaseKey());
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa public key.
     * The representation follow the ASN.1 notation :
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * @returns {string} DER Encoded String representing the rsa public key
     * @private
     */
    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {
        var first_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }),
                new KJUR.asn1.DERNull()
            ]
        });
        var second_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e })
            ]
        });
        var bit_string = new KJUR.asn1.DERBitString({
            hex: "00" + second_sequence.getEncodedHex()
        });
        var seq = new KJUR.asn1.DERSequence({
            array: [
                first_sequence,
                bit_string
            ]
        });
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {
        return hex2b64(this.getPublicBaseKey());
    };
    /**
     * wrap the string in block of width chars. The default value for rsa keys is 64
     * characters.
     * @param {string} str the pem encoded string without header and footer
     * @param {Number} [width=64] - the length the string has to be wrapped at
     * @returns {string}
     * @private
     */
    JSEncryptRSAKey.wordwrap = function (str, width) {
        width = width || 64;
        if (!str) {
            return str;
        }
        var regex = "(.{1," + width + "})( +|$\n?)|(.{1," + width + "})";
        return str.match(RegExp(regex, "g")).join("\n");
    };
    /**
     * Retrieve the pem encoded private key
     * @returns {string} the pem encoded private key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateKey = function () {
        var key = "-----BEGIN RSA PRIVATE KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + "\n";
        key += "-----END RSA PRIVATE KEY-----";
        return key;
    };
    /**
     * Retrieve the pem encoded public key
     * @returns {string} the pem encoded public key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicKey = function () {
        var key = "-----BEGIN PUBLIC KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + "\n";
        key += "-----END PUBLIC KEY-----";
        return key;
    };
    /**
     * Check if the object contains the necessary parameters to populate the rsa modulus
     * and public exponent parameters.
     * @param {Object} [obj={}] - An object that may contain the two public key
     * parameters
     * @returns {boolean} true if the object contains both the modulus and the public exponent
     * properties (n and e)
     * @todo check for types of n and e. N should be a parseable bigInt object, E should
     * be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e"));
    };
    /**
     * Check if the object contains ALL the parameters of an RSA key.
     * @param {Object} [obj={}] - An object that may contain nine rsa key
     * parameters
     * @returns {boolean} true if the object contains all the parameters needed
     * @todo check for types of the parameters all the parameters but the public exponent
     * should be parseable bigint objects, the public exponent should be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e") &&
            obj.hasOwnProperty("d") &&
            obj.hasOwnProperty("p") &&
            obj.hasOwnProperty("q") &&
            obj.hasOwnProperty("dmp1") &&
            obj.hasOwnProperty("dmq1") &&
            obj.hasOwnProperty("coeff"));
    };
    /**
     * Parse the properties of obj in the current rsa object. Obj should AT LEAST
     * include the modulus and public exponent (n, e) parameters.
     * @param {Object} obj - the object containing rsa parameters
     * @private
     */
    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {
        this.n = obj.n;
        this.e = obj.e;
        if (obj.hasOwnProperty("d")) {
            this.d = obj.d;
            this.p = obj.p;
            this.q = obj.q;
            this.dmp1 = obj.dmp1;
            this.dmq1 = obj.dmq1;
            this.coeff = obj.coeff;
        }
    };
    return JSEncryptRSAKey;
}(RSAKey));

/**
 *
 * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour
 * possible parameters are:
 * - default_key_size        {number}  default: 1024 the key size in bit
 * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent
 * - log                     {boolean} default: false whether log warn/error or not
 * @constructor
 */
var JSEncrypt = /** @class */ (function () {
    function JSEncrypt(options) {
        options = options || {};
        this.default_key_size = parseInt(options.default_key_size, 10) || 1024;
        this.default_public_exponent = options.default_public_exponent || "010001"; // 65537 default openssl public exponent for rsa key type
        this.log = options.log || false;
        // The private and public key.
        this.key = null;
    }
    /**
     * Method to set the rsa key parameter (one method is enough to set both the public
     * and the private key, since the private key contains the public key paramenters)
     * Log a warning if logs are enabled
     * @param {Object|string} key the pem encoded string or an object (with or without header/footer)
     * @public
     */
    JSEncrypt.prototype.setKey = function (key) {
        if (this.log && this.key) {
            console.warn("A key was already set, overriding existing.");
        }
        this.key = new JSEncryptRSAKey(key);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPrivateKey = function (privkey) {
        // Create the key.
        this.setKey(privkey);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPublicKey = function (pubkey) {
        // Sets the public key.
        this.setKey(pubkey);
    };
    /**
     * Proxy method for RSAKey object's decrypt, decrypt the string using the private
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str base64 encoded crypted string to decrypt
     * @return {string} the decrypted string
     * @public
     */
    JSEncrypt.prototype.decrypt = function (str) {
        // Return the decrypted string.
        try {
            return this.getKey().decrypt(b64tohex(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's encrypt, encrypt the string using the public
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str the string to encrypt
     * @return {string} the encrypted string encoded in base64
     * @public
     */
    JSEncrypt.prototype.encrypt = function (str) {
        // Return the encrypted string.
        try {
            return hex2b64(this.getKey().encrypt(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's sign.
     * @param {string} str the string to sign
     * @param {function} digestMethod hash method
     * @param {string} digestName the name of the hash algorithm
     * @return {string} the signature encoded in base64
     * @public
     */
    JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {
        // return the RSA signature of 'str' in 'hex' format.
        try {
            return hex2b64(this.getKey().sign(str, digestMethod, digestName));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's verify.
     * @param {string} str the string to verify
     * @param {string} signature the signature encoded in base64 to compare the string to
     * @param {function} digestMethod hash method
     * @return {boolean} whether the data and signature match
     * @public
     */
    JSEncrypt.prototype.verify = function (str, signature, digestMethod) {
        // Return the decrypted 'digest' of the signature.
        try {
            return this.getKey().verify(str, b64tohex(signature), digestMethod);
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object
     * will be created and returned
     * @param {callback} [cb] the callback to be called if we want the key to be generated
     * in an async fashion
     * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object
     * @public
     */
    JSEncrypt.prototype.getKey = function (cb) {
        // Only create new if it does not exist.
        if (!this.key) {
            // Get a new private key.
            this.key = new JSEncryptRSAKey();
            if (cb && {}.toString.call(cb) === "[object Function]") {
                this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
                return;
            }
            // Generate the key.
            this.key.generate(this.default_key_size, this.default_public_exponent);
        }
        return this.key;
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateKey();
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateBaseKeyB64();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicKey();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicBaseKeyB64();
    };
    JSEncrypt.version = "3.0.0-rc.1";
    return JSEncrypt;
}());

window.JSEncrypt = JSEncrypt;

exports.JSEncrypt = JSEncrypt;
exports.default = JSEncrypt;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = __webpack_require__(/*! pseudomap */ "./node_modules/pseudomap/map.js")
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")

// A linked list to keep track of recently-used-ness
var Yallist = __webpack_require__(/*! yallist */ "./node_modules/yallist/yallist.js")

// use symbols if possible, otherwise just _props
var hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1'
var makeSymbol
if (hasSymbol) {
  makeSymbol = function (key) {
    return Symbol(key)
  }
} else {
  makeSymbol = function (key) {
    return '_' + key
  }
}

var MAX = makeSymbol('max')
var LENGTH = makeSymbol('length')
var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
var ALLOW_STALE = makeSymbol('allowStale')
var MAX_AGE = makeSymbol('maxAge')
var DISPOSE = makeSymbol('dispose')
var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
var LRU_LIST = makeSymbol('lruList')
var CACHE = makeSymbol('cache')

function naiveLength () { return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  if (typeof options === 'number') {
    options = { max: options }
  }

  if (!options) {
    options = {}
  }

  var max = this[MAX] = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) {
    this[MAX] = Infinity
  }

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') {
    lc = naiveLength
  }
  this[LENGTH_CALCULATOR] = lc

  this[ALLOW_STALE] = options.stale || false
  this[MAX_AGE] = options.maxAge || 0
  this[DISPOSE] = options.dispose
  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', {
  set: function (mL) {
    if (!mL || !(typeof mL === 'number') || mL <= 0) {
      mL = Infinity
    }
    this[MAX] = mL
    trim(this)
  },
  get: function () {
    return this[MAX]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', {
  set: function (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  },
  get: function () {
    return this[ALLOW_STALE]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', {
  set: function (mA) {
    if (!mA || !(typeof mA === 'number') || mA < 0) {
      mA = 0
    }
    this[MAX_AGE] = mA
    trim(this)
  },
  get: function () {
    return this[MAX_AGE]
  },
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
  set: function (lC) {
    if (typeof lC !== 'function') {
      lC = naiveLength
    }
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(function (hit) {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      }, this)
    }
    trim(this)
  },
  get: function () { return this[LENGTH_CALCULATOR] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', {
  get: function () { return this[LENGTH] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', {
  get: function () { return this[LRU_LIST].length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].tail; walker !== null;) {
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  }
}

function forEachStep (self, fn, node, thisp) {
  var hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE]) {
      hit = undefined
    }
  }
  if (hit) {
    fn.call(thisp, hit.value, hit.key, self)
  }
}

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].head; walker !== null;) {
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  }
}

LRUCache.prototype.keys = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.key
  }, this)
}

LRUCache.prototype.values = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.value
  }, this)
}

LRUCache.prototype.reset = function () {
  if (this[DISPOSE] &&
      this[LRU_LIST] &&
      this[LRU_LIST].length) {
    this[LRU_LIST].forEach(function (hit) {
      this[DISPOSE](hit.key, hit.value)
    }, this)
  }

  this[CACHE] = new Map() // hash of items by key
  this[LRU_LIST] = new Yallist() // list of items in order of use recency
  this[LENGTH] = 0 // length of items in the list
}

LRUCache.prototype.dump = function () {
  return this[LRU_LIST].map(function (hit) {
    if (!isStale(this, hit)) {
      return {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }
    }
  }, this).toArray().filter(function (h) {
    return h
  })
}

LRUCache.prototype.dumpLru = function () {
  return this[LRU_LIST]
}

/* istanbul ignore next */
LRUCache.prototype.inspect = function (n, opts) {
  var str = 'LRUCache {'
  var extras = false

  var as = this[ALLOW_STALE]
  if (as) {
    str += '\n  allowStale: true'
    extras = true
  }

  var max = this[MAX]
  if (max && max !== Infinity) {
    if (extras) {
      str += ','
    }
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  }

  var maxAge = this[MAX_AGE]
  if (maxAge) {
    if (extras) {
      str += ','
    }
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  }

  var lc = this[LENGTH_CALCULATOR]
  if (lc && lc !== naiveLength) {
    if (extras) {
      str += ','
    }
    str += '\n  length: ' + util.inspect(this[LENGTH], opts)
    extras = true
  }

  var didFirst = false
  this[LRU_LIST].forEach(function (item) {
    if (didFirst) {
      str += ',\n  '
    } else {
      if (extras) {
        str += ',\n'
      }
      didFirst = true
      str += '\n  '
    }
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = { value: item.value }
    if (item.maxAge !== maxAge) {
      val.maxAge = item.maxAge
    }
    if (lc !== naiveLength) {
      val.length = item.length
    }
    if (isStale(this, item)) {
      val.stale = true
    }

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  })

  if (didFirst || extras) {
    str += '\n'
  }
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this[MAX_AGE]

  var now = maxAge ? Date.now() : 0
  var len = this[LENGTH_CALCULATOR](value, key)

  if (this[CACHE].has(key)) {
    if (len > this[MAX]) {
      del(this, this[CACHE].get(key))
      return false
    }

    var node = this[CACHE].get(key)
    var item = node.value

    // dispose of the old one before overwriting
    // split out into 2 ifs for better coverage tracking
    if (this[DISPOSE]) {
      if (!this[NO_DISPOSE_ON_SET]) {
        this[DISPOSE](key, item.value)
      }
    }

    item.now = now
    item.maxAge = maxAge
    item.value = value
    this[LENGTH] += len - item.length
    item.length = len
    this.get(key)
    trim(this)
    return true
  }

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this[MAX]) {
    if (this[DISPOSE]) {
      this[DISPOSE](key, value)
    }
    return false
  }

  this[LENGTH] += hit.length
  this[LRU_LIST].unshift(hit)
  this[CACHE].set(key, this[LRU_LIST].head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) {
  if (!this[CACHE].has(key)) return false
  var hit = this[CACHE].get(key).value
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var node = this[LRU_LIST].tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) {
  del(this, this[CACHE].get(key))
}

LRUCache.prototype.load = function (arr) {
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) {
        this.set(hit.k, hit.v, maxAge)
      }
    }
  }
}

LRUCache.prototype.prune = function () {
  var self = this
  this[CACHE].forEach(function (value, key) {
    get(self, key, false)
  })
}

function get (self, key, doUse) {
  var node = self[CACHE].get(key)
  if (node) {
    var hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE]) hit = undefined
    } else {
      if (doUse) {
        self[LRU_LIST].unshiftNode(node)
      }
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale (self, hit) {
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {
    return false
  }
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self[MAX_AGE] && (diff > self[MAX_AGE])
  }
  return stale
}

function trim (self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

function del (self, node) {
  if (node) {
    var hit = node.value
    if (self[DISPOSE]) {
      self[DISPOSE](hit.key, hit.value)
    }
    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) {
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/promise-window/dist/promise-window.js":
/*!************************************************************!*\
  !*** ./node_modules/promise-window/dist/promise-window.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * PromiseWindow
 * https://github.com/amercier/promise-window
 * @ignore
 */
(function() {
  'use strict';

  var root = window,
      prototype,
      html = root.document.documentElement;

  /**
   * Merge the contents of two or more objects together into the first object.
   *
   *     merge( target [, object1 ] [, objectN ] )
   *
   * @param {Object} target  An object that will receive the new properties if
   *                         additional objects are passed in.
   * @param {Object} object1 An object containing additional properties to merge in.
   * @param {Object} objectN An object containing additional properties to merge in.
   * @return {Object} Returns the first object.
   * @ignore
   */
  function extend() {
    var extended = arguments[0], key, i;
    for (i = 1; i < arguments.length; i++) {
      for (key in arguments[i]) {
        if (arguments[i].hasOwnProperty(key)) {
          extended[key] = arguments[i][key];
        }
      }
    }
    return extended;
  }

  /**
   * Generates a pseudo-unique String
   *
   * @param  {String} prefix Optional.
   * @return {String} Returns a pseudo-unique string prefixed with the given prefix, if any.
   * @ignore
   */
  function generateUniqueString(prefix) {
    return prefix + new Date().getTime() + "-" + Math.floor(10e12 * Math.random());
  }

  /**
   * Create a new PromiseWindow object
   *
   * During the lifecycle of this object, popup windows can be opened, closed,
   * and reopened again. However, it'
   *
   * Instanciating this prototype does not immediately opens a new popup window.
   * To open the window, use `open()` on the created object.
   *
   * @param {String}   uri                    Destination URI
   * @param {Object}   config                 Configuration object. See description below.
   * @param {Number}   config.width           Width of the popup window. Defaults to the current document width.
   * @param {Number}   config.height          Height of the popup window. Defaults to the current document height.
   * @param {Function} config.promiseProvider Promise provider. Should return a plain object containing 3 fields:
   *                                          - `promise` {Promise}  a new Promise object
   *                                          - `resolve` {Function} the method to resolve the given Promise
   *                                          - `reject`  {Function} the method to reject the given Promise
   * @param {Function} config.onPostMessage   Handler for receiving a postMessage from the opened window. Default
   *                                          implementation resolves the promise with the data passed in the post
   *                                          message, except if this data contains an `error` field. In this case,
   *                                          it rejects the Promise with the value of that field. In all cases, closes
   *                                          the popup window.
   * @param {Function} config.onPostMessage.event Event The postMessage event
   * @param {Number}   config.watcherDelay    There is no programmatic way of knowing when a popup window is closed
   *                                          (either manually or programatically). For this reason, every time
   *                                          PromiseWindow opens a popup, a new watcher is created. The watcher checks
   *                                          regularly if the window is still open. This value defines at which
   *                                          interval this check is done. Defaults to 100ms.
   * @param {String}   config.windowName      Name to be ginven to the popup window. See `window.open` references for
   *                                          details. If `null`, a random name is generated.
   * @param {Object}   config.window          Object containing window configuration settings. Scrollbars are enabled
   *                                          by default. All `window.open` ptions are accepted, but please note that
   *                                          many of them have no effect in most modern browsers. See
   *                                          https://developer.mozilla.org/en-US/docs/Web/API/Window/open for more
   *                                          details.
   * @param {Function} config.onClose         Function being called whenever the popup is being closed (either after a
   *                                          post message has been received, or window has been closed by user, or
   *                                          `.close()` method has been called. Default implementation closes the
   *                                          popup window by calling `this._window.close()`).
   * @param {RegExp} config.originRegexp      Regular expression that matches the origin part of an URI. Defaults to
   *                                          `new RegExp('^[^:/?]+://[^/]*')`. If doesn't match (ex: relative URIs),
   *                                          use `location.origin`.
   * @constructor
   */
  function PromiseWindow(uri, config) {
    this.uri = uri;
    this.config = extend({}, this.constructor.defaultConfig, config);
    this.config.windowName = this.config.windowName || generateUniqueString('promise-window-');
    this._onPostMessage = this._onPostMessage.bind(this);
  }

  /**
   * Create a Promise provider from a Promise/A+ constructor to be used with
   * `config.promiseProvider`.
   *
   *     new PromiseWindow(..., {
   *       ...,
   *       promiseProvider: PromiseWindow.getAPlusPromiseProvider(MyCustomPromise)
   *     });
   *
   * @param  {Function} CustomPromise Promise/A+ contructor
   * @return {Function} Returns a promise provider
   * @static
   */
  PromiseWindow.getAPlusPromiseProvider = function getAPlusPromiseProvider(CustomPromise) {
    return function promiseProvider() {
      var module = {};
      module.promise = new CustomPromise(function(resolve, reject) {
        module.resolve = resolve;
        module.reject = reject;
      });
      return module;
    };
  };

  /**
   * Convenience method for:
   *
   *     new PromiseWindow(uri, config).open()
   *
   * Use this method only if you never need to close the window programatically.
   * If you do, please consider using the classic way:
   *
   *     var w = new PromiseWindow(uri, config)
   *     w.open();
   *     // ...
   *     w.close();
   *
   * @return {Promise} Returns a Promise equivalent to the one returned by `open()`
   * @static
   */
  PromiseWindow.open = function open(uri, config) {
    return new PromiseWindow(uri, config).open();
  };

  /**
   * Default configuration
   * @type {Object}
   */
  PromiseWindow.defaultConfig = {
    width: html.clientWidth,
    height: html.clientHeight,
    window: {
      scrollbars: true
    },
    watcherDelay: 100,
    promiseProvider: null,
    onPostMessage: function onPostMessage(event) {
      if (event.data.error) {
        this._reject(event.data.error);
      } else {
        this._resolve(event.data);
      }
      this.close();
    },
    windowName: null,
    onClose: function() {
      this._window.close();
    },
    originRegexp: new RegExp('^[^:/?]+://[^/]*')
  };

  // Configure default Promise provider from current invironment
  if (root.Promise) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.Promise);
  }
  else if (root.RSVP) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.RSVP.Promise);
  }
  else if (root.Q) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.Q.Promise);
  }
  else if (root.jQuery) {
    PromiseWindow.defaultConfig.promiseProvider = function promiseProvider() {
      var deferred = root.jQuery.Deferred();
      return {
        promise: deferred.promise(),
        resolve: deferred.resolve,
        reject: deferred.reject
      };
    };
  }
  else {
    PromiseWindow.defaultConfig.promiseProvider = function() {
      throw new Error('Missing promiseProvider in PromiseWindow configuration');
    };
  }

  prototype = PromiseWindow.prototype;

  /**
   * Checks whether a value is a boolean
   * @param {*} value The value to check
   * @return {boolean} `true` if value is a boolean, `false` otherwise
   * @protected
   */
  prototype._isBoolean = function _isBoolean(value) {
    return value === true || value === false;
  };

  /**
   * Converts a config value into a value compatible with `window.open`.
   * If value is a boolean, convert it to 'yes' or 'no', otherwise simply
   * casts it into a string.
   * @param {*} value The value to convert
   * @return {string} The converted value
   * @protected
   */
  prototype._serializeFeatureValue = function _serializeFeatureValue(key, value) {
    if (this._isBoolean(value)) {
      return value ? 'yes' : 'no';
    }
    return '' + value;
  };

  /**
   * Get the left and top position in the screen for a rectangle, taking
   * dual-screen position into account
   * @param {Number} width Width of the rectangle
   * @param {Number} height Height of the rectangle
   * @return {Object} position A new object representing the position of the rectangle, centered
   * @return {Number} position.left The X coordinate of the centered rectangle
   * @return {Number} position.top The Y coordinate of the centered rectangle
   * @return {Number} position.width The width of the centered rectangle
   * @return {Number} position.height The height of the centered rectangle
   * @protected
   */
  prototype._getCenteredPosition = function _getCenteredPosition(width, height) {
    var dualScreenLeft = root.screenLeft !== undefined ? root.screenLeft : screen.left,
        dualScreenTop = root.screenTop !== undefined ? root.screenTop : screen.top,
        w = root.innerWidth || html.clientWidth || screen.width,
        h = root.innerHeight || html.clientHeight || screen.height;

    return {
      left: (w / 2) - (width / 2) + dualScreenLeft,
      top:  (h / 2) - (height / 2) + dualScreenTop,
      width: width,
      height: height
    };
  };

  /**
   * Generates window features based on the current configuration
   * @return {String} Returns window features compatible with `window.open`
   * @protected
   */
  prototype._getFeatures = function _getFeatures() {
    var config = this._getCenteredPosition(this.config.width, this.config.height);
    for (var key in this.config.window) {
      if (this.config.window.hasOwnProperty(key)) {
        config[key] = this.config.window[key];
      }
    }

    return Object.keys(config)
      .map(function(key) { return key + '=' + this._serializeFeatureValue(key, config[key]); }.bind(this))
      .join(',');
  };

  /**
   * Creates a new Promise, using `config.promiseProvider`, and save reject and
   * resolve methods for later.
   *
   * @return {Promise} Returns the new Promise object created by the configured
   *                   Promise Provider.
   * @protected
   */
  prototype._createPromise = function _createPromise() {
    var module = this.config.promiseProvider();
    this._resolve = module.resolve;
    this._reject = module.reject;
    return module.promise;
  };

  /**
   * Checks whether the window is alive or not
   * @return {Boolean} Returns `true` if the window is alive, `false` otherwise
   * @protected
   */
  prototype._isWindowAlive = function _isWindowAlive() {
    return this._window && !this._window.closed;
  };

  /**
   * Starts the popup window watcher.
   * @return {void}
   * @protected
   */
  prototype._startWatcher = function _startWatcher() {
    if (this._watcherRunning) {
      throw new Error('Watcher is already started');
    }
    this._watcher = root.setInterval(function () {
      if (this._watcherRunning && !this._isWindowAlive()) {
        this.close();
      }
    }.bind(this), this.config.watcherDelay);
    this._watcherRunning = true;
  };

  /**
   * Stops the popup window watcher.
   * @return {void}
   * @protected
   */
  prototype._stopWatcher = function _stopWatcher() {
    if (!this._watcherRunning) {
      throw new Error('Watcher is already stopped');
    }
    this._watcherRunning = false;
    root.clearInterval(this._watcher);
  };

  /**
   * Callback for post message events. If and only of the event has been
   * generated from the opened popup window, it propagates it to the configured
   * post message handler (`config.onPostMessage`).
   *
   * @param {Event} event The postMessage event
   * @return {void}
   * @protected
   */
  prototype._onPostMessage = function _onPostMessage(event) {
    var expectedOriginMatches = this.config.originRegexp.exec(this.uri);
    var expectedOrigin = expectedOriginMatches && expectedOriginMatches[0] || location.origin;
    if (this._window === event.source && event.origin === expectedOrigin) {
      this.config.onPostMessage.call(this, event);
    }
  };

  /**
   * Changes the URI
   * @param {String} uri The new URI
   * @throws {Error} If the window is open
   * @return {PromiseWindow} Returns this object to allow chaining
   */
  prototype.setURI = function setURI(uri) {
    if (this.isOpen()) {
      throw new Error('Cannot change the URI while the window is open');
    }
    this.uri = uri;
    return this;
  };

  /**
   * Opens a new popup window.
   *
   * @return {Promise} Returns a new `Promise` object. This promise will be:
   *                   - rejected with `"blocked"` message if the popup window
   *                     does not open for any reason (popup blocker, etc...)
   *                   - rejected with `"closed"` if closed either manually by
   *                     the user, or programatically
   *                   - rejected with the given error if the web page opened in
   *                     the popup sends a post message with a `error` data field.
   *                   - resolved with the given data if the web page opened in
   *                     the popup sends a post message without a `error` data
   *                     field.
   */
  prototype.open = function open() {
    if (this.isOpen()) {
      throw new Error('Window is already open');
    }

    this._windowOpen = true;
    var promise = this._createPromise();
    this._window = root.open(
      this.uri,
      this.config.windowName,
      this._getFeatures()
    );
    if (!this._window) {
      this._reject("blocked");
    }
    else {
      root.addEventListener("message", this._onPostMessage, true);
      this._startWatcher();
    }
    return promise;
  };

  /**
   * Closes the popup window.
   *
   * @return {void}
   */
  prototype.close = function close() {
    if (!this.isOpen()) {
      throw new Error('Window is already closed');
    }
    this._stopWatcher();
    root.removeEventListener("message", this._onPostMessage);
    if (this._isWindowAlive()) {
      this.config.onClose.call(this);
    }
    this._reject("closed");
    this._window = null;
    this._windowOpen = false;
  };

  /**
   * Checks whether the window is open or not
   * @return {Boolean} Returns `true` if the window is opened, `false` otherwise.
   */
  prototype.isOpen = function isOpen() {
    return this._windowOpen;
  };

  // Exports PromiseWindow to the global scope
  /* jshint ignore:start */
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return PromiseWindow }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
  /* jshint ignore:end */

})();


/***/ }),

/***/ "./node_modules/pseudomap/map.js":
/*!***************************************!*\
  !*** ./node_modules/pseudomap/map.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {if (process.env.npm_package_name === 'pseudomap' &&
    process.env.npm_lifecycle_script === 'test')
  process.env.TEST_PSEUDOMAP = 'true'

if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
  module.exports = Map
} else {
  module.exports = __webpack_require__(/*! ./pseudomap */ "./node_modules/pseudomap/pseudomap.js")
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pseudomap/pseudomap.js":
/*!*********************************************!*\
  !*** ./node_modules/pseudomap/pseudomap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty

module.exports = PseudoMap

function PseudoMap (set) {
  if (!(this instanceof PseudoMap)) // whyyyyyyy
    throw new TypeError("Constructor PseudoMap requires 'new'")

  this.clear()

  if (set) {
    if ((set instanceof PseudoMap) ||
        (typeof Map === 'function' && set instanceof Map))
      set.forEach(function (value, key) {
        this.set(key, value)
      }, this)
    else if (Array.isArray(set))
      set.forEach(function (kv) {
        this.set(kv[0], kv[1])
      }, this)
    else
      throw new TypeError('invalid argument')
  }
}

PseudoMap.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  Object.keys(this._data).forEach(function (k) {
    if (k !== 'size')
      fn.call(thisp, this._data[k].value, this._data[k].key)
  }, this)
}

PseudoMap.prototype.has = function (k) {
  return !!find(this._data, k)
}

PseudoMap.prototype.get = function (k) {
  var res = find(this._data, k)
  return res && res.value
}

PseudoMap.prototype.set = function (k, v) {
  set(this._data, k, v)
}

PseudoMap.prototype.delete = function (k) {
  var res = find(this._data, k)
  if (res) {
    delete this._data[res._index]
    this._data.size--
  }
}

PseudoMap.prototype.clear = function () {
  var data = Object.create(null)
  data.size = 0

  Object.defineProperty(this, '_data', {
    value: data,
    enumerable: false,
    configurable: true,
    writable: false
  })
}

Object.defineProperty(PseudoMap.prototype, 'size', {
  get: function () {
    return this._data.size
  },
  set: function (n) {},
  enumerable: true,
  configurable: true
})

PseudoMap.prototype.values =
PseudoMap.prototype.keys =
PseudoMap.prototype.entries = function () {
  throw new Error('iterators are not implemented in this version')
}

// Either identical, or both NaN
function same (a, b) {
  return a === b || a !== a && b !== b
}

function Entry (k, v, i) {
  this.key = k
  this.value = v
  this._index = i
}

function find (data, k) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k))
      return data[key]
  }
}

function set (data, k, v) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k)) {
      data[key].value = v
      return
    }
  }
  data.size++
  data[key] = new Entry(k, v, key)
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}


/***/ }),

/***/ "./src/discourse.js":
/*!**************************!*\
  !*** ./src/discourse.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.array.for-each */ "./node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__(/*! core-js/modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");

__webpack_require__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! core-js/modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");

__webpack_require__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__(/*! core-js/modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");

__webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _discourseAuth = _interopRequireDefault(__webpack_require__(/*! ./discourseAuth */ "./src/discourseAuth.js"));

var _discourseApi = _interopRequireDefault(__webpack_require__(/*! ./discourseApi */ "./src/discourseApi.js"));

var _promiseWindow = _interopRequireDefault(__webpack_require__(/*! promise-window */ "./node_modules/promise-window/dist/promise-window.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DiscourseClient =
/*#__PURE__*/
function () {
  function DiscourseClient(options) {
    _classCallCheck(this, DiscourseClient);

    this._requireOptions(options);

    this.options = this._formatOptions(options);
    this.auth = new _discourseAuth.default(this.options);
    this.api = new _discourseApi.default(this.options.apiBaseUrl);
  }

  _createClass(DiscourseClient, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.auth.init();

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_requireOptions",
    value: function _requireOptions(options) {
      options && _typeof(options) === 'object' || function (e) {
        throw e;
      }(new Error('Options must be an object'));
      typeof options.appName === 'string' && options.appName.length > 0 || function (e) {
        throw e;
      }(new Error('options.appName must be a non-empty string'));
      typeof options.apiBaseUrl === 'string' && options.apiBaseUrl.length > 0 || function (e) {
        throw e;
      }(new Error('Options.apiBaseUrl must be a non-empty string'));
      options.scopes instanceof Array && options.scopes.length > 0 || function (e) {
        throw e;
      }(new Error('Options.scopes must be a non-empty array'));
    }
  }, {
    key: "_formatOptions",
    value: function _formatOptions(options) {
      var formattedOptions = _objectSpread({}, options); // remove trailing slash


      formattedOptions.apiBaseUrl = options.apiBaseUrl.replace(/\/$/, '');
      formattedOptions.scopes = options.scopes.join(',');
      return formattedOptions;
    }
  }, {
    key: "getApiBaseUrl",
    value: function getApiBaseUrl() {
      return this.options.apiBaseUrl;
    }
  }, {
    key: "isLoggedIn",
    value: function () {
      var _isLoggedIn = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.auth._hasUserApiKey()) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", false);

              case 2:
                _context2.prev = 2;
                _context2.next = 5;
                return this._refreshCurrentUser();

              case 5:
                return _context2.abrupt("return", true);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);
                return _context2.abrupt("return", false);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 8]]);
      }));

      function isLoggedIn() {
        return _isLoggedIn.apply(this, arguments);
      }

      return isLoggedIn;
    }()
  }, {
    key: "getCurrentUser",
    value: function getCurrentUser() {
      return JSON.parse(localStorage.getItem('currentUser'));
    }
  }, {
    key: "getCurrentUserName",
    value: function getCurrentUserName() {
      return this.getCurrentUser()['username'];
    }
  }, {
    key: "getCurrentUserDisplayName",
    value: function getCurrentUserDisplayName() {
      return this.getCurrentUser()['name'];
    }
  }, {
    key: "isCurrentUserSilenced",
    value: function isCurrentUserSilenced() {
      return !this.getCurrentUser()['can_create_topic'];
    }
  }, {
    key: "getCurrentUserAvatarUrl",
    value: function getCurrentUserAvatarUrl(size) {
      return [this.options.apiBaseUrl, this.getCurrentUser()['avatar_template'].replace('{size}', size || 110)].join('/');
    }
  }, {
    key: "getCurrentUserNotificationsUrl",
    value: function getCurrentUserNotificationsUrl() {
      return [this.options.apiBaseUrl, 'u', this.getCurrentUserName(), 'notifications'].join('/');
    }
  }, {
    key: "_refreshCurrentUser",
    value: function () {
      var _refreshCurrentUser2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.t0 = localStorage;
                _context3.t1 = JSON;
                _context3.next = 5;
                return this.api.getCurrentSessionUser();

              case 5:
                _context3.t2 = _context3.sent;
                _context3.t3 = _context3.t1.stringify.call(_context3.t1, _context3.t2);

                _context3.t0.setItem.call(_context3.t0, 'currentUser', _context3.t3);

                _context3.next = 15;
                break;

              case 10:
                _context3.prev = 10;
                _context3.t4 = _context3["catch"](0);
                _context3.next = 14;
                return this.logout();

              case 14:
                throw new Error('Not logged in.');

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 10]]);
      }));

      function _refreshCurrentUser() {
        return _refreshCurrentUser2.apply(this, arguments);
      }

      return _refreshCurrentUser;
    }()
  }, {
    key: "login",
    value: function () {
      var _login = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.isLoggedIn();

              case 2:
                if (!_context5.sent) {
                  _context5.next = 4;
                  break;
                }

                return _context5.abrupt("return");

              case 4:
                _context5.t0 = _promiseWindow.default;
                _context5.next = 7;
                return this.auth._getLoginUrl();

              case 7:
                _context5.t1 = _context5.sent;
                _context5.t2 = {
                  width: 700,
                  height: 650,
                  originRegexp: new RegExp('^' + location.origin)
                };

                _context5.t3 =
                /*#__PURE__*/
                function () {
                  var _ref = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee4(data) {
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return _this.api._setUserApiKey(data.result.key);

                          case 2:
                            _context4.next = 4;
                            return _this._refreshCurrentUser();

                          case 4:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, this);
                  }));

                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }();

                _context5.t4 = // Error
                function (error) {
                  switch (error) {
                    case 'closed':
                      dispatchEvent(new Event('discourseLoginCanceled'));
                      throw new Error('Authentication popup window closed by the user');

                    case 'blocked':
                      dispatchEvent(new Event('discourseLoginBlocked'));
                      throw new Error('Authentication popup window blocked by the browser');

                    default:
                      throw new Error('Authentication popup window returned an error: ', error);
                  }
                };

                _context5.t5 = function () {
                  return dispatchEvent(new Event('discourseLoggedIn'));
                };

                _context5.next = 14;
                return _context5.t0.open.call(_context5.t0, _context5.t1, _context5.t2).then(_context5.t3, _context5.t4).then(_context5.t5);

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function login() {
        return _login.apply(this, arguments);
      }

      return login;
    }()
  }, {
    key: "logout",
    value: function () {
      var _logout = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.api.logout(this.getCurrentUserName());

              case 2:
                this.auth._clearAuthData();

                dispatchEvent(new Event('discourseLoggedOut'));

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
  }]);

  return DiscourseClient;
}();

exports.default = DiscourseClient;

/***/ }),

/***/ "./src/discourseApi.js":
/*!*****************************!*\
  !*** ./src/discourseApi.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! core-js/modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! core-js/modules/es6.array.reduce */ "./node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _axios = _interopRequireDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));

var _axiosExtensions = __webpack_require__(/*! axios-extensions */ "./node_modules/axios-extensions/esm/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DiscourseApi =
/*#__PURE__*/
function () {
  function DiscourseApi(apiBaseUrl) {
    _classCallCheck(this, DiscourseApi);

    this.apiBaseUrl = apiBaseUrl;
    this.api = _axios.default.create({
      baseURL: this.apiBaseUrl,
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/json'
      },
      adapter: (0, _axiosExtensions.throttleAdapterEnhancer)((0, _axiosExtensions.cacheAdapterEnhancer)(_axios.default.defaults.adapter), {
        threshold: 500 // 120 reqs/min

      })
    });

    this._setUserApiKey(localStorage.getItem('user_api_key'));
  }

  _createClass(DiscourseApi, [{
    key: "_getCallResult",
    value: function () {
      var _getCallResult2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(endpoint, prop) {
        var nocache,
            response,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                nocache = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;
                _context.prev = 1;
                _context.next = 4;
                return this.api.get(endpoint, {
                  forceUpdate: nocache
                });

              case 4:
                response = _context.sent.data;
                _context.next = 10;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](1);
                throw new Error(_context.t0);

              case 10:
                if (prop) {
                  response = prop.split('.').reduce(function (returnedResponse, currentProp) {
                    return returnedResponse[currentProp];
                  }, response);
                }

                return _context.abrupt("return", response);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 7]]);
      }));

      function _getCallResult(_x, _x2) {
        return _getCallResult2.apply(this, arguments);
      }

      return _getCallResult;
    }()
  }, {
    key: "_postCallResult",
    value: function () {
      var _postCallResult2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(endpoint, payload) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.api.post(endpoint, payload);

              case 2:
                return _context2.abrupt("return", _context2.sent.data);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _postCallResult(_x3, _x4) {
        return _postCallResult2.apply(this, arguments);
      }

      return _postCallResult;
    }()
  }, {
    key: "_setUserApiKey",
    value: function () {
      var _setUserApiKey2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(userApiKey) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (userApiKey) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                this.api.defaults.headers.common['User-Api-Key'] = userApiKey;
                _context3.next = 5;
                return this._setCsrfToken();

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _setUserApiKey(_x5) {
        return _setUserApiKey2.apply(this, arguments);
      }

      return _setUserApiKey;
    }()
  }, {
    key: "_setCsrfToken",
    value: function () {
      var _setCsrfToken2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._getCallResult('/session/csrf.json', 'csrf');

              case 2:
                this.api.defaults.headers.common['X-CSRF-Token'] = _context4.sent;

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _setCsrfToken() {
        return _setCsrfToken2.apply(this, arguments);
      }

      return _setCsrfToken;
    }()
  }, {
    key: "_enforceUserApiKey",
    value: function _enforceUserApiKey() {
      this.api.defaults.headers.common['User-Api-Key'] || function (e) {
        throw e;
      }(new Error('User API key not set'));
    }
  }, {
    key: "getCurrentSessionUser",
    value: function () {
      var _getCurrentSessionUser = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._getCallResult('/session/current.json', 'current_user', true);

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getCurrentSessionUser() {
        return _getCurrentSessionUser.apply(this, arguments);
      }

      return getCurrentSessionUser;
    }()
  }, {
    key: "getLatestPosts",
    value: function () {
      var _getLatestPosts = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(descending) {
        var posts;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return this._getCallResult('/posts.json', 'latest_posts');

              case 3:
                posts = _context6.sent;
                _context6.next = 9;
                break;

              case 6:
                _context6.prev = 6;
                _context6.t0 = _context6["catch"](0);
                throw new Error(_context6.t0);

              case 9:
                if (descending) {
                  posts = posts.reverse();
                }

                return _context6.abrupt("return", posts.filter(function (post) {
                  return post.post_type === 1;
                }));

              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 6]]);
      }));

      function getLatestPosts(_x6) {
        return _getLatestPosts.apply(this, arguments);
      }

      return getLatestPosts;
    }()
  }, {
    key: "getPostsInTopic",
    value: function () {
      var _getPostsInTopic = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(topicId, descending, nocache) {
        var posts;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._getCallResult('/t/' + topicId + '/posts.json?include_raw=true', 'post_stream.posts', nocache);

              case 2:
                posts = _context7.sent;

                if (descending) {
                  posts = posts.reverse();
                }

                return _context7.abrupt("return", posts.filter(function (post) {
                  return post.post_type === 1;
                }));

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getPostsInTopic(_x7, _x8, _x9) {
        return _getPostsInTopic.apply(this, arguments);
      }

      return getPostsInTopic;
    }()
  }, {
    key: "getTopic",
    value: function () {
      var _getTopic = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(topicId, descending) {
        var topic;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._getCallResult('/t/' + topicId + '.json?include_raw=true');

              case 2:
                topic = _context8.sent;
                topic.post_stream.posts = topic.post_stream.posts.filter(function (post) {
                  return post.post_type === 1;
                });

                if (descending) {
                  topic.post_stream.posts = topic.post_stream.posts.reverse();
                }

                return _context8.abrupt("return", topic);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getTopic(_x10, _x11) {
        return _getTopic.apply(this, arguments);
      }

      return getTopic;
    }()
  }, {
    key: "getPublicUserFields",
    value: function () {
      var _getPublicUserFields = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(username) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._getCallResult('/u/' + username + '.json?stats=false', 'user.user_fields');

              case 2:
                return _context9.abrupt("return", _context9.sent);

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getPublicUserFields(_x12) {
        return _getPublicUserFields.apply(this, arguments);
      }

      return getPublicUserFields;
    }()
  }, {
    key: "getPublicUserField",
    value: function () {
      var _getPublicUserField = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(username, field) {
        var userFields;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getPublicUserFields(username);

              case 2:
                userFields = _context10.sent;
                return _context10.abrupt("return", userFields && userFields[field]);

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getPublicUserField(_x13, _x14) {
        return _getPublicUserField.apply(this, arguments);
      }

      return getPublicUserField;
    }()
  }, {
    key: "postMessage",
    value: function () {
      var _postMessage = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(topicId, message) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this._enforceUserApiKey();

                _context11.next = 3;
                return this._postCallResult('/posts.json', {
                  /* eslint-disable camelcase */
                  topic_id: topicId,
                  raw: message
                  /* eslint-enable camelcase */

                }).then(function (response) {
                  response.hidden && Promise.reject(response.hidden_reason_id);
                  return response;
                }).catch(function (error) {
                  return Promise.reject(error.response.data.errors);
                });

              case 3:
                return _context11.abrupt("return", _context11.sent);

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function postMessage(_x15, _x16) {
        return _postMessage.apply(this, arguments);
      }

      return postMessage;
    }()
  }, {
    key: "logout",
    value: function () {
      var _logout = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(username) {
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this._enforceUserApiKey(); // await this.api.delete('/session/' + username); // Not yet supported


                _context12.next = 3;
                return this.api.post('/user-api-key/revoke');

              case 3:
                delete this.api.defaults.headers.common['User-Api-Key'];
                delete this.api.defaults.headers.common['X-CSRF-Token'];

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function logout(_x17) {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
  }]);

  return DiscourseApi;
}();

exports.default = DiscourseApi;

/***/ }),

/***/ "./src/discourseAuth.js":
/*!******************************!*\
  !*** ./src/discourseAuth.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! core-js/modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__(/*! core-js/modules/es6.date.to-string */ "./node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");

__webpack_require__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! core-js/modules/es6.array.map */ "./node_modules/core-js/modules/es6.array.map.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _keyManager = _interopRequireDefault(__webpack_require__(/*! ./keyManager */ "./src/keyManager.js"));

var _urlSearchParams = _interopRequireDefault(__webpack_require__(/*! @ungap/url-search-params */ "./node_modules/@ungap/url-search-params/esm/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// polyfill
// import MobileDetect from 'mobile-detect';
var DiscourseAuth =
/*#__PURE__*/
function () {
  function DiscourseAuth(options) {
    _classCallCheck(this, DiscourseAuth);

    this.appId = this._slugify(options.appName);
    this.km = new _keyManager.default(this.appId);
    this.options = options;
  }

  _createClass(DiscourseAuth, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.km.getKeys();

              case 2:
                this._hasUserApiKey() || this._managePayload();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_hasUserApiKey",
    value: function _hasUserApiKey() {
      return localStorage.getItem('user_api_key') !== null;
    }
  }, {
    key: "_getLoginUrl",
    value: function () {
      var _getLoginUrl2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var params;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = this.options.appName;
                _context2.next = 3;
                return this.km.getPublicKey();

              case 3:
                _context2.t1 = _context2.sent;
                _context2.t2 = this._generateStoredRandom('nonce');
                _context2.t3 = this._getStoredRandom('clientId') || this._generateStoredRandom('clientId');
                _context2.t4 = location.href;
                _context2.t5 = this.options.scopes;
                params = {
                  application_name: _context2.t0,
                  public_key: _context2.t1,
                  nonce: _context2.t2,
                  client_id: _context2.t3,
                  auth_redirect: _context2.t4,
                  scopes: _context2.t5
                };
                return _context2.abrupt("return", this.options.apiBaseUrl + '/user-api-key/new?' + this._serializeParams(params));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getLoginUrl() {
        return _getLoginUrl2.apply(this, arguments);
      }

      return _getLoginUrl;
    }()
  }, {
    key: "_serializeParams",
    value: function _serializeParams(params) {
      return Object.keys(params).map(function (k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
      }).join('&');
    }
  }, {
    key: "_generateStoredRandom",
    value: function _generateStoredRandom(name) {
      var storedRandom = Math.random().toString(16).substr(2);
      localStorage.setItem(this.appId + '_' + name, storedRandom);
      return storedRandom;
    }
  }, {
    key: "_getStoredRandom",
    value: function _getStoredRandom(name) {
      var storedRandom = localStorage.getItem(this.appId + '_' + name);
      return storedRandom;
    }
  }, {
    key: "_removeStoredRandom",
    value: function _removeStoredRandom(name) {
      localStorage.removeItem(this.appId + '_' + name);
    }
  }, {
    key: "_getUserApiKey",
    value: function _getUserApiKey() {
      return localStorage.getItem('user_api_key');
    }
  }, {
    key: "_clearAuthData",
    value: function _clearAuthData() {
      localStorage.removeItem('user_api_key');
      localStorage.removeItem('currentUser');

      this._removeStoredRandom('clientId');
    }
  }, {
    key: "_managePayload",
    value: function _managePayload() {
      var _this = this;

      var url = new _urlSearchParams.default(window.location.search || window.location.hash.split('?')[1]);

      if (url.has('payload') && opener) {
        this.km.decryptPayload(url.get('payload')).then(function (payloadObject) {
          payloadObject.nonce === _this._getStoredRandom('nonce') || function (e) {
            throw e;
          }(new Error('The returned payload is invalid.'));
          payloadObject.api === 3 || function (e) {
            throw e;
          }(new Error('Wrong API version: ' + payloadObject.api + '. Discourse-js works with API version 3.'));
          localStorage.setItem('user_api_key', payloadObject.key);

          _this._removeStoredRandom('nonce');

          opener.postMessage({
            result: payloadObject
          }, location.origin);
        });
      } // var md = new MobileDetect(window.navigator.userAgent);

    }
  }, {
    key: "_slugify",
    value: function _slugify(text) {
      return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
    }
  }]);

  return DiscourseAuth;
}();

exports.default = DiscourseAuth;

/***/ }),

/***/ "./src/keyGenerator.js":
/*!*****************************!*\
  !*** ./src/keyGenerator.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

var forge = __webpack_require__(/*! ./vendor/forge-pki */ "./src/vendor/forge-pki.js");

var _default = function () {
  var generate = function generate(appId) {
    return new Promise(function (resolve, reject) {
      forge.rsa.generateKeyPair({
        workerScript: '/prime-worker.min.js'
      }, function (error, generatedKeypair) {
        generatedKeypair ? function () {
          var keypair = {
            public: forge.pki.publicKeyToPem(generatedKeypair.publicKey, 72).replace(/\r/g, ''),
            private: forge.pki.privateKeyToPem(generatedKeypair.privateKey, 72).replace(/\r/g, '')
          };
          localStorage.setItem(appId + '_publicKey', keypair.public);
          localStorage.setItem(appId + '_privateKey', keypair.private);
          resolve(keypair);
        }() : reject(error);
      });
    });
  };

  return {
    generate: generate
  };
}();

exports.default = _default;

/***/ }),

/***/ "./src/keyManager.js":
/*!***************************!*\
  !*** ./src/keyManager.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! core-js/modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var KeyManager =
/*#__PURE__*/
function () {
  function KeyManager(appId) {
    _classCallCheck(this, KeyManager);

    this.appId = appId;
  }

  _createClass(KeyManager, [{
    key: "generateNewKeypair",
    value: function () {
      var _generateNewKeypair = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve(/*! import() | keyGenerator */).then(__webpack_require__.t.bind(null, /*! ./keyGenerator */ "./src/keyGenerator.js", 7)).then(function (_ref) {
                  var keyGenerator = _ref.default;
                  return keyGenerator.generate(_this.appId).then(function (keypair) {
                    return keypair;
                  });
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function generateNewKeypair() {
        return _generateNewKeypair.apply(this, arguments);
      }

      return generateNewKeypair;
    }()
  }, {
    key: "getKeys",
    value: function () {
      var _getKeys = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = this.readKeysFromStorage();

                if (_context2.t0) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 4;
                return this.generateNewKeypair();

              case 4:
                _context2.t0 = _context2.sent;

              case 5:
                return _context2.abrupt("return", _context2.t0);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getKeys() {
        return _getKeys.apply(this, arguments);
      }

      return getKeys;
    }()
  }, {
    key: "readKeysFromStorage",
    value: function readKeysFromStorage() {
      var publicKey = localStorage.getItem(this.appId + '_publicKey');
      var privateKey = localStorage.getItem(this.appId + '_privateKey');
      return publicKey && privateKey ? {
        public: publicKey,
        private: privateKey
      } : null;
    }
  }, {
    key: "getPublicKey",
    value: function () {
      var _getPublicKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getKeys();

              case 2:
                return _context3.abrupt("return", _context3.sent['public']);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPublicKey() {
        return _getPublicKey.apply(this, arguments);
      }

      return getPublicKey;
    }()
  }, {
    key: "getPrivateKey",
    value: function () {
      var _getPrivateKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getKeys();

              case 2:
                return _context4.abrupt("return", _context4.sent['private']);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPrivateKey() {
        return _getPrivateKey.apply(this, arguments);
      }

      return getPrivateKey;
    }()
  }, {
    key: "decryptPayload",
    value: function () {
      var _decryptPayload = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(payload) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.getPrivateKey().then(function (privateKey) {
                  return Promise.resolve(/*! import() | jsencrypt */).then(__webpack_require__.t.bind(null, /*! jsencrypt */ "./node_modules/jsencrypt/bin/jsencrypt.js", 7)).then(function (_ref2) {
                    var Jsencrypt = _ref2.default;
                    var jsencrypt = new Jsencrypt();
                    jsencrypt.setPrivateKey(privateKey);
                    return JSON.parse(jsencrypt.decrypt(payload));
                  });
                }));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function decryptPayload(_x) {
        return _decryptPayload.apply(this, arguments);
      }

      return decryptPayload;
    }()
  }]);

  return KeyManager;
}();

exports.default = KeyManager;
;

/***/ }),

/***/ "./src/vendor/forge-pki.js":
/*!*********************************!*\
  !*** ./src/vendor/forge-pki.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, Buffer, module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(/*! core-js/modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");__webpack_require__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");__webpack_require__(/*! core-js/modules/es6.typed.uint32-array */ "./node_modules/core-js/modules/es6.typed.uint32-array.js");__webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");__webpack_require__(/*! core-js/modules/es6.regexp.match */ "./node_modules/core-js/modules/es6.regexp.match.js");__webpack_require__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");__webpack_require__(/*! core-js/modules/es6.array.reduce */ "./node_modules/core-js/modules/es6.array.reduce.js");__webpack_require__(/*! core-js/modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");__webpack_require__(/*! core-js/modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");__webpack_require__(/*! core-js/modules/es6.array.index-of */ "./node_modules/core-js/modules/es6.array.index-of.js");__webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");__webpack_require__(/*! core-js/modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");__webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");__webpack_require__(/*! core-js/modules/es6.typed.uint16-array */ "./node_modules/core-js/modules/es6.typed.uint16-array.js");__webpack_require__(/*! core-js/modules/es6.typed.data-view */ "./node_modules/core-js/modules/es6.typed.data-view.js");__webpack_require__(/*! core-js/modules/es6.typed.uint8-array */ "./node_modules/core-js/modules/es6.typed.uint8-array.js");__webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");__webpack_require__(/*! core-js/modules/es6.date.to-string */ "./node_modules/core-js/modules/es6.date.to-string.js");__webpack_require__(/*! core-js/modules/es6.array.is-array */ "./node_modules/core-js/modules/es6.array.is-array.js");__webpack_require__(/*! core-js/modules/es6.date.now */ "./node_modules/core-js/modules/es6.date.now.js");__webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");__webpack_require__(/*! core-js/modules/es6.array.for-each */ "./node_modules/core-js/modules/es6.array.for-each.js");__webpack_require__(/*! core-js/modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}(function webpackUniversalModuleDefinition(root,factory){if(( false?undefined:_typeof(exports))==='object'&&( false?undefined:_typeof(module))==='object')module.exports=factory();else if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(typeof self!=='undefined'?self:void 0,function(){return(/******/function(modules){// webpackBootstrap
/******/ // The module cache
/******/var installedModules={};/******/ /******/ // The require function
/******/function __webpack_require__(moduleId){/******/ /******/ // Check if module is in cache
/******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/ // Create a new module (and put it into the cache)
/******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******/ /******/ // Execute the module function
/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******/ /******/ // Flag the module as loaded
/******/module.l=true;/******/ /******/ // Return the exports of the module
/******/return module.exports;/******/}/******/ /******/ /******/ // expose the modules object (__webpack_modules__)
/******/__webpack_require__.m=modules;/******/ /******/ // expose the module cache
/******/__webpack_require__.c=installedModules;/******/ /******/ // define getter function for harmony exports
/******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{/******/configurable:false,/******/enumerable:true,/******/get:getter/******/});/******/}/******/};/******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
/******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******/ /******/ // Object.prototype.hasOwnProperty.call
/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******/ /******/ // __webpack_public_path__
/******/__webpack_require__.p="";/******/ /******/ // Load entry module and return exports
/******/return __webpack_require__(__webpack_require__.s=20);/******/}(/************************************************************************/ /******/[/* 0 */ /***/function(module,exports){/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */module.exports={// default options
options:{usePureJavaScript:false}};/***/},/* 1 */ /***/function(module,exports,__webpack_require__){/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);var baseN=__webpack_require__(22);/* Utilities API */var util=module.exports=forge.util=forge.util||{};// define setImmediate and nextTick
(function(){// use native nextTick (unless we're in webpack)
// webpack (or better node-libs-browser polyfill) sets process.browser.
// this way we can detect webpack properly
if(typeof process!=='undefined'&&process.nextTick&&!process.browser){util.nextTick=process.nextTick;if(typeof setImmediate==='function'){util.setImmediate=setImmediate;}else{// polyfill setImmediate with nextTick, older versions of node
// (those w/o setImmediate) won't totally starve IO
util.setImmediate=util.nextTick;}return;}// polyfill nextTick with native setImmediate
if(typeof setImmediate==='function'){util.setImmediate=function(){return setImmediate.apply(undefined,arguments);};util.nextTick=function(callback){return setImmediate(callback);};return;}/* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */ // polyfill with setTimeout
util.setImmediate=function(callback){setTimeout(callback,0);};// upgrade polyfill to use postMessage
if(typeof window!=='undefined'&&typeof window.postMessage==='function'){var handler=function handler(event){if(event.source===window&&event.data===msg){event.stopPropagation();var copy=callbacks.slice();callbacks.length=0;copy.forEach(function(callback){callback();});}};var msg='forge.setImmediate';var callbacks=[];util.setImmediate=function(callback){callbacks.push(callback);// only send message when one hasn't been sent in
// the current turn of the event loop
if(callbacks.length===1){window.postMessage(msg,'*');}};window.addEventListener('message',handler,true);}// upgrade polyfill to use MutationObserver
if(typeof MutationObserver!=='undefined'){// polyfill with MutationObserver
var now=Date.now();var attr=true;var div=document.createElement('div');var callbacks=[];new MutationObserver(function(){var copy=callbacks.slice();callbacks.length=0;copy.forEach(function(callback){callback();});}).observe(div,{attributes:true});var oldSetImmediate=util.setImmediate;util.setImmediate=function(callback){if(Date.now()-now>15){now=Date.now();oldSetImmediate(callback);}else{callbacks.push(callback);// only trigger observer when it hasn't been triggered in
// the current turn of the event loop
if(callbacks.length===1){div.setAttribute('a',attr=!attr);}}};}util.nextTick=util.setImmediate;})();// check if running under Node.js
util.isNodejs=typeof process!=='undefined'&&process.versions&&process.versions.node;// define isArray
util.isArray=Array.isArray||function(x){return Object.prototype.toString.call(x)==='[object Array]';};// define isArrayBuffer
util.isArrayBuffer=function(x){return typeof ArrayBuffer!=='undefined'&&x instanceof ArrayBuffer;};// define isArrayBufferView
util.isArrayBufferView=function(x){return x&&util.isArrayBuffer(x.buffer)&&x.byteLength!==undefined;};/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */function _checkBitsParam(n){if(!(n===8||n===16||n===24||n===32)){throw new Error('Only 8, 16, 24, or 32 bits supported: '+n);}}// TODO: set ByteBuffer to best available backing
util.ByteBuffer=ByteStringBuffer;/** Buffer w/BinaryString backing */ /**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */function ByteStringBuffer(b){// TODO: update to match DataBuffer API
// the data in this buffer
this.data='';// the pointer for reading from this buffer
this.read=0;if(typeof b==='string'){this.data=b;}else if(util.isArrayBuffer(b)||util.isArrayBufferView(b)){if(typeof Buffer!=='undefined'&&b instanceof Buffer){this.data=b.toString('binary');}else{// convert native buffer to forge buffer
// FIXME: support native buffers internally instead
var arr=new Uint8Array(b);try{this.data=String.fromCharCode.apply(null,arr);}catch(e){for(var i=0;i<arr.length;++i){this.putByte(arr[i]);}}}}else if(b instanceof ByteStringBuffer||_typeof(b)==='object'&&typeof b.data==='string'&&typeof b.read==='number'){// copy existing buffer
this.data=b.data;this.read=b.read;}// used for v8 optimization
this._constructedStringLength=0;}util.ByteStringBuffer=ByteStringBuffer;/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */var _MAX_CONSTRUCTED_STRING_LENGTH=4096;util.ByteStringBuffer.prototype._optimizeConstructedString=function(x){this._constructedStringLength+=x;if(this._constructedStringLength>_MAX_CONSTRUCTED_STRING_LENGTH){// this substr() should cause the constructed string to join
this.data.substr(0,1);this._constructedStringLength=0;}};/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */util.ByteStringBuffer.prototype.length=function(){return this.data.length-this.read;};/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */util.ByteStringBuffer.prototype.isEmpty=function(){return this.length()<=0;};/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putByte=function(b){return this.putBytes(String.fromCharCode(b));};/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.fillWithByte=function(b,n){b=String.fromCharCode(b);var d=this.data;while(n>0){if(n&1){d+=b;}n>>>=1;if(n>0){b+=b;}}this.data=d;this._optimizeConstructedString(n);return this;};/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a UTF-8 encoded string) to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putBytes=function(bytes){this.data+=bytes;this._optimizeConstructedString(bytes.length);return this;};/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putString=function(str){return this.putBytes(util.encodeUtf8(str));};/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt16=function(i){return this.putBytes(String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt24=function(i){return this.putBytes(String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt32=function(i){return this.putBytes(String.fromCharCode(i>>24&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt16Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF));};/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt24Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i>>16&0xFF));};/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt32Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>24&0xFF));};/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt=function(i,n){_checkBitsParam(n);var bytes='';do{n-=8;bytes+=String.fromCharCode(i>>n&0xFF);}while(n>0);return this.putBytes(bytes);};/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putSignedInt=function(i,n){// putInt checks n
if(i<0){i+=2<<n-1;}return this.putInt(i,n);};/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putBuffer=function(buffer){return this.putBytes(buffer.getBytes());};/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */util.ByteStringBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++);};/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.ByteStringBuffer.prototype.getInt16=function(){var rval=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.ByteStringBuffer.prototype.getInt24=function(){var rval=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.ByteStringBuffer.prototype.getInt32=function(){var rval=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);this.read+=4;return rval;};/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.ByteStringBuffer.prototype.getInt16Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.ByteStringBuffer.prototype.getInt24Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.ByteStringBuffer.prototype.getInt32Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;this.read+=4;return rval;};/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.ByteStringBuffer.prototype.getInt=function(n){_checkBitsParam(n);var rval=0;do{// TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
rval=(rval<<8)+this.data.charCodeAt(this.read++);n-=8;}while(n>0);return rval;};/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.ByteStringBuffer.prototype.getSignedInt=function(n){// getInt checks n
var x=this.getInt(n);var max=2<<n-2;if(x>=max){x-=max<<1;}return x;};/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */util.ByteStringBuffer.prototype.getBytes=function(count){var rval;if(count){// read count bytes
count=Math.min(this.length(),count);rval=this.data.slice(this.read,this.read+count);this.read+=count;}else if(count===0){rval='';}else{// read all bytes, optimize to only copy when needed
rval=this.read===0?this.data:this.data.slice(this.read);this.clear();}return rval;};/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */util.ByteStringBuffer.prototype.bytes=function(count){return typeof count==='undefined'?this.data.slice(this.read):this.data.slice(this.read,this.read+count);};/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */util.ByteStringBuffer.prototype.at=function(i){return this.data.charCodeAt(this.read+i);};/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.setAt=function(i,b){this.data=this.data.substr(0,this.read+i)+String.fromCharCode(b)+this.data.substr(this.read+i+1);return this;};/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */util.ByteStringBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1);};/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */util.ByteStringBuffer.prototype.copy=function(){var c=util.createBuffer(this.data);c.read=this.read;return c;};/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.compact=function(){if(this.read>0){this.data=this.data.slice(this.read);this.read=0;}return this;};/**
 * Clears this buffer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.clear=function(){this.data='';this.read=0;return this;};/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.truncate=function(count){var len=Math.max(0,this.length()-count);this.data=this.data.substr(this.read,len);this.read=0;return this;};/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */util.ByteStringBuffer.prototype.toHex=function(){var rval='';for(var i=this.read;i<this.data.length;++i){var b=this.data.charCodeAt(i);if(b<16){rval+='0';}rval+=b.toString(16);}return rval;};/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */util.ByteStringBuffer.prototype.toString=function(){return util.decodeUtf8(this.bytes());};/** End Buffer w/BinaryString backing */ /** Buffer w/UInt8Array backing */ /**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */function DataBuffer(b,options){// default options
options=options||{};// pointers for read from/write to buffer
this.read=options.readOffset||0;this.growSize=options.growSize||1024;var isArrayBuffer=util.isArrayBuffer(b);var isArrayBufferView=util.isArrayBufferView(b);if(isArrayBuffer||isArrayBufferView){// use ArrayBuffer directly
if(isArrayBuffer){this.data=new DataView(b);}else{// TODO: adjust read/write offset based on the type of view
// or specify that this must be done in the options ... that the
// offsets are byte-based
this.data=new DataView(b.buffer,b.byteOffset,b.byteLength);}this.write='writeOffset'in options?options.writeOffset:this.data.byteLength;return;}// initialize to empty array buffer and add any given bytes using putBytes
this.data=new DataView(new ArrayBuffer(0));this.write=0;if(b!==null&&b!==undefined){this.putBytes(b);}if('writeOffset'in options){this.write=options.writeOffset;}}util.DataBuffer=DataBuffer;/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */util.DataBuffer.prototype.length=function(){return this.write-this.read;};/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */util.DataBuffer.prototype.isEmpty=function(){return this.length()<=0;};/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */util.DataBuffer.prototype.accommodate=function(amount,growSize){if(this.length()>=amount){return this;}growSize=Math.max(growSize||this.growSize,amount);// grow buffer
var src=new Uint8Array(this.data.buffer,this.data.byteOffset,this.data.byteLength);var dst=new Uint8Array(this.length()+growSize);dst.set(src);this.data=new DataView(dst.buffer);return this;};/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putByte=function(b){this.accommodate(1);this.data.setUint8(this.write++,b);return this;};/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.fillWithByte=function(b,n){this.accommodate(n);for(var i=0;i<n;++i){this.data.setUint8(b);}return this;};/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putBytes=function(bytes,encoding){if(util.isArrayBufferView(bytes)){var src=new Uint8Array(bytes.buffer,bytes.byteOffset,bytes.byteLength);var len=src.byteLength-src.byteOffset;this.accommodate(len);var dst=new Uint8Array(this.data.buffer,this.write);dst.set(src);this.write+=len;return this;}if(util.isArrayBuffer(bytes)){var src=new Uint8Array(bytes);this.accommodate(src.byteLength);var dst=new Uint8Array(this.data.buffer);dst.set(src,this.write);this.write+=src.byteLength;return this;}// bytes is a util.DataBuffer or equivalent
if(bytes instanceof util.DataBuffer||_typeof(bytes)==='object'&&typeof bytes.read==='number'&&typeof bytes.write==='number'&&util.isArrayBufferView(bytes.data)){var src=new Uint8Array(bytes.data.byteLength,bytes.read,bytes.length());this.accommodate(src.byteLength);var dst=new Uint8Array(bytes.data.byteLength,this.write);dst.set(src);this.write+=src.byteLength;return this;}if(bytes instanceof util.ByteStringBuffer){// copy binary string and process as the same as a string parameter below
bytes=bytes.data;encoding='binary';}// string conversion
encoding=encoding||'binary';if(typeof bytes==='string'){var view;// decode from string
if(encoding==='hex'){this.accommodate(Math.ceil(bytes.length/2));view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.hex.decode(bytes,view,this.write);return this;}if(encoding==='base64'){this.accommodate(Math.ceil(bytes.length/4)*3);view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.base64.decode(bytes,view,this.write);return this;}// encode text as UTF-8 bytes
if(encoding==='utf8'){// encode as UTF-8 then decode string as raw binary
bytes=util.encodeUtf8(bytes);encoding='binary';}// decode string as raw binary
if(encoding==='binary'||encoding==='raw'){// one byte per character
this.accommodate(bytes.length);view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.raw.decode(view);return this;}// encode text as UTF-16 bytes
if(encoding==='utf16'){// two bytes per character
this.accommodate(bytes.length*2);view=new Uint16Array(this.data.buffer,this.write);this.write+=util.text.utf16.encode(view);return this;}throw new Error('Invalid encoding: '+encoding);}throw Error('Invalid parameter: '+bytes);};/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putBuffer=function(buffer){this.putBytes(buffer);buffer.clear();return this;};/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putString=function(str){return this.putBytes(str,'utf16');};/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt16=function(i){this.accommodate(2);this.data.setInt16(this.write,i);this.write+=2;return this;};/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt24=function(i){this.accommodate(3);this.data.setInt16(this.write,i>>8&0xFFFF);this.data.setInt8(this.write,i>>16&0xFF);this.write+=3;return this;};/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt32=function(i){this.accommodate(4);this.data.setInt32(this.write,i);this.write+=4;return this;};/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt16Le=function(i){this.accommodate(2);this.data.setInt16(this.write,i,true);this.write+=2;return this;};/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt24Le=function(i){this.accommodate(3);this.data.setInt8(this.write,i>>16&0xFF);this.data.setInt16(this.write,i>>8&0xFFFF,true);this.write+=3;return this;};/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt32Le=function(i){this.accommodate(4);this.data.setInt32(this.write,i,true);this.write+=4;return this;};/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt=function(i,n){_checkBitsParam(n);this.accommodate(n/8);do{n-=8;this.data.setInt8(this.write++,i>>n&0xFF);}while(n>0);return this;};/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putSignedInt=function(i,n){_checkBitsParam(n);this.accommodate(n/8);if(i<0){i+=2<<n-1;}return this.putInt(i,n);};/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */util.DataBuffer.prototype.getByte=function(){return this.data.getInt8(this.read++);};/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.DataBuffer.prototype.getInt16=function(){var rval=this.data.getInt16(this.read);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.DataBuffer.prototype.getInt24=function(){var rval=this.data.getInt16(this.read)<<8^this.data.getInt8(this.read+2);this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.DataBuffer.prototype.getInt32=function(){var rval=this.data.getInt32(this.read);this.read+=4;return rval;};/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.DataBuffer.prototype.getInt16Le=function(){var rval=this.data.getInt16(this.read,true);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.DataBuffer.prototype.getInt24Le=function(){var rval=this.data.getInt8(this.read)^this.data.getInt16(this.read+1,true)<<8;this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.DataBuffer.prototype.getInt32Le=function(){var rval=this.data.getInt32(this.read,true);this.read+=4;return rval;};/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.DataBuffer.prototype.getInt=function(n){_checkBitsParam(n);var rval=0;do{// TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
rval=(rval<<8)+this.data.getInt8(this.read++);n-=8;}while(n>0);return rval;};/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.DataBuffer.prototype.getSignedInt=function(n){// getInt checks n
var x=this.getInt(n);var max=2<<n-2;if(x>=max){x-=max<<1;}return x;};/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */util.DataBuffer.prototype.getBytes=function(count){// TODO: deprecate this method, it is poorly named and
// this.toString('binary') replaces it
// add a toTypedArray()/toArrayBuffer() function
var rval;if(count){// read count bytes
count=Math.min(this.length(),count);rval=this.data.slice(this.read,this.read+count);this.read+=count;}else if(count===0){rval='';}else{// read all bytes, optimize to only copy when needed
rval=this.read===0?this.data:this.data.slice(this.read);this.clear();}return rval;};/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */util.DataBuffer.prototype.bytes=function(count){// TODO: deprecate this method, it is poorly named, add "getString()"
return typeof count==='undefined'?this.data.slice(this.read):this.data.slice(this.read,this.read+count);};/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */util.DataBuffer.prototype.at=function(i){return this.data.getUint8(this.read+i);};/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.setAt=function(i,b){this.data.setUint8(i,b);return this;};/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */util.DataBuffer.prototype.last=function(){return this.data.getUint8(this.write-1);};/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */util.DataBuffer.prototype.copy=function(){return new util.DataBuffer(this);};/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.compact=function(){if(this.read>0){var src=new Uint8Array(this.data.buffer,this.read);var dst=new Uint8Array(src.byteLength);dst.set(src);this.data=new DataView(dst);this.write-=this.read;this.read=0;}return this;};/**
 * Clears this buffer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.clear=function(){this.data=new DataView(new ArrayBuffer(0));this.read=this.write=0;return this;};/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.truncate=function(count){this.write=Math.max(0,this.length()-count);this.read=Math.min(this.read,this.write);return this;};/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */util.DataBuffer.prototype.toHex=function(){var rval='';for(var i=this.read;i<this.data.byteLength;++i){var b=this.data.getUint8(i);if(b<16){rval+='0';}rval+=b.toString(16);}return rval;};/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */util.DataBuffer.prototype.toString=function(encoding){var view=new Uint8Array(this.data,this.read,this.length());encoding=encoding||'utf8';// encode to string
if(encoding==='binary'||encoding==='raw'){return util.binary.raw.encode(view);}if(encoding==='hex'){return util.binary.hex.encode(view);}if(encoding==='base64'){return util.binary.base64.encode(view);}// decode to text
if(encoding==='utf8'){return util.text.utf8.decode(view);}if(encoding==='utf16'){return util.text.utf16.decode(view);}throw new Error('Invalid encoding: '+encoding);};/** End Buffer w/UInt8Array backing */ /**
 * Creates a buffer that stores bytes. A value may be given to put into the
 * buffer that is either a string of bytes or a UTF-16 string that will
 * be encoded using UTF-8 (to do the latter, specify 'utf8' as the encoding).
 *
 * @param [input] the bytes to wrap (as a string) or a UTF-16 string to encode
 *          as UTF-8.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */util.createBuffer=function(input,encoding){// TODO: deprecate, use new ByteBuffer() instead
encoding=encoding||'raw';if(input!==undefined&&encoding==='utf8'){input=util.encodeUtf8(input);}return new util.ByteBuffer(input);};/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */util.fillString=function(c,n){var s='';while(n>0){if(n&1){s+=c;}n>>>=1;if(n>0){c+=c;}}return s;};/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */util.xorBytes=function(s1,s2,n){var s3='';var b='';var t='';var i=0;var c=0;for(;n>0;--n,++i){b=s1.charCodeAt(i)^s2.charCodeAt(i);if(c>=10){s3+=t;t='';c=0;}t+=String.fromCharCode(b);++c;}s3+=t;return s3;};/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */util.hexToBytes=function(hex){// TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
var rval='';var i=0;if(hex.length&1==1){// odd number of characters, convert first character alone
i=1;rval+=String.fromCharCode(parseInt(hex[0],16));}// convert 2 characters (1 byte) at a time
for(;i<hex.length;i+=2){rval+=String.fromCharCode(parseInt(hex.substr(i,2),16));}return rval;};/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */util.bytesToHex=function(bytes){// TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
return util.createBuffer(bytes).toHex();};/**
 * Converts an 32-bit integer to 4-big-endian byte string.
 *
 * @param i the integer.
 *
 * @return the byte string.
 */util.int32ToBytes=function(i){return String.fromCharCode(i>>24&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF);};// base64 characters, reverse mapping
var _base64='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';var _base64Idx=[/*43 -43 = 0*/ /*'+',  1,  2,  3,'/' */62,-1,-1,-1,63,/*'0','1','2','3','4','5','6','7','8','9' */52,53,54,55,56,57,58,59,60,61,/*15, 16, 17,'=', 19, 20, 21 */-1,-1,-1,64,-1,-1,-1,/*65 - 43 = 22*/ /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */0,1,2,3,4,5,6,7,8,9,10,11,12,/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */13,14,15,16,17,18,19,20,21,22,23,24,25,/*91 - 43 = 48 */ /*48, 49, 50, 51, 52, 53 */-1,-1,-1,-1,-1,-1,/*97 - 43 = 54*/ /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */26,27,28,29,30,31,32,33,34,35,36,37,38,/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */39,40,41,42,43,44,45,46,47,48,49,50,51];// base58 characters (Bitcoin alphabet)
var _base58='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';/**
 * Base64 encodes a 'binary' encoded string of bytes.
 *
 * @param input the binary encoded string of bytes to base64-encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output.
 */util.encode64=function(input,maxline){// TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
var line='';var output='';var chr1,chr2,chr3;var i=0;while(i<input.length){chr1=input.charCodeAt(i++);chr2=input.charCodeAt(i++);chr3=input.charCodeAt(i++);// encode 4 character group
line+=_base64.charAt(chr1>>2);line+=_base64.charAt((chr1&3)<<4|chr2>>4);if(isNaN(chr2)){line+='==';}else{line+=_base64.charAt((chr2&15)<<2|chr3>>6);line+=isNaN(chr3)?'=':_base64.charAt(chr3&63);}if(maxline&&line.length>maxline){output+=line.substr(0,maxline)+'\r\n';line=line.substr(maxline);}}output+=line;return output;};/**
 * Base64 decodes a string into a 'binary' encoded string of bytes.
 *
 * @param input the base64-encoded input.
 *
 * @return the binary encoded string.
 */util.decode64=function(input){// TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."
// remove all non-base64 characters
input=input.replace(/[^A-Za-z0-9\+\/\=]/g,'');var output='';var enc1,enc2,enc3,enc4;var i=0;while(i<input.length){enc1=_base64Idx[input.charCodeAt(i++)-43];enc2=_base64Idx[input.charCodeAt(i++)-43];enc3=_base64Idx[input.charCodeAt(i++)-43];enc4=_base64Idx[input.charCodeAt(i++)-43];output+=String.fromCharCode(enc1<<2|enc2>>4);if(enc3!==64){// decoded at least 2 bytes
output+=String.fromCharCode((enc2&15)<<4|enc3>>2);if(enc4!==64){// decoded 3 bytes
output+=String.fromCharCode((enc3&3)<<6|enc4);}}}return output;};/**
 * UTF-8 encodes the given UTF-16 encoded string (a standard JavaScript
 * string). Non-ASCII characters will be encoded as multiple bytes according
 * to UTF-8.
 *
 * @param str the string to encode.
 *
 * @return the UTF-8 encoded string.
 */util.encodeUtf8=function(str){return unescape(encodeURIComponent(str));};/**
 * Decodes a UTF-8 encoded string into a UTF-16 string.
 *
 * @param str the string to decode.
 *
 * @return the UTF-16 encoded string (standard JavaScript string).
 */util.decodeUtf8=function(str){return decodeURIComponent(escape(str));};// binary encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.binary={raw:{},hex:{},base64:{},base58:{},baseN:{encode:baseN.encode,decode:baseN.decode}};/**
 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param bytes the Uint8Array to encode.
 *
 * @return the binary-encoded string.
 */util.binary.raw.encode=function(bytes){return String.fromCharCode.apply(null,bytes);};/**
 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param str the binary-encoded string to decode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.raw.decode=function(str,output,offset){var out=output;if(!out){out=new Uint8Array(str.length);}offset=offset||0;var j=offset;for(var i=0;i<str.length;++i){out[j++]=str.charCodeAt(i);}return output?j-offset:out;};/**
 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
 * ByteBuffer as a string of hexadecimal characters.
 *
 * @param bytes the bytes to convert.
 *
 * @return the string of hexadecimal characters.
 */util.binary.hex.encode=util.bytesToHex;/**
 * Decodes a hex-encoded string to a Uint8Array.
 *
 * @param hex the hexadecimal string to convert.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.hex.decode=function(hex,output,offset){var out=output;if(!out){out=new Uint8Array(Math.ceil(hex.length/2));}offset=offset||0;var i=0,j=offset;if(hex.length&1){// odd number of characters, convert first character alone
i=1;out[j++]=parseInt(hex[0],16);}// convert 2 characters (1 byte) at a time
for(;i<hex.length;i+=2){out[j++]=parseInt(hex.substr(i,2),16);}return output?j-offset:out;};/**
 * Base64-encodes a Uint8Array.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output string.
 */util.binary.base64.encode=function(input,maxline){var line='';var output='';var chr1,chr2,chr3;var i=0;while(i<input.byteLength){chr1=input[i++];chr2=input[i++];chr3=input[i++];// encode 4 character group
line+=_base64.charAt(chr1>>2);line+=_base64.charAt((chr1&3)<<4|chr2>>4);if(isNaN(chr2)){line+='==';}else{line+=_base64.charAt((chr2&15)<<2|chr3>>6);line+=isNaN(chr3)?'=':_base64.charAt(chr3&63);}if(maxline&&line.length>maxline){output+=line.substr(0,maxline)+'\r\n';line=line.substr(maxline);}}output+=line;return output;};/**
 * Decodes a base64-encoded string to a Uint8Array.
 *
 * @param input the base64-encoded input string.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.base64.decode=function(input,output,offset){var out=output;if(!out){out=new Uint8Array(Math.ceil(input.length/4)*3);}// remove all non-base64 characters
input=input.replace(/[^A-Za-z0-9\+\/\=]/g,'');offset=offset||0;var enc1,enc2,enc3,enc4;var i=0,j=offset;while(i<input.length){enc1=_base64Idx[input.charCodeAt(i++)-43];enc2=_base64Idx[input.charCodeAt(i++)-43];enc3=_base64Idx[input.charCodeAt(i++)-43];enc4=_base64Idx[input.charCodeAt(i++)-43];out[j++]=enc1<<2|enc2>>4;if(enc3!==64){// decoded at least 2 bytes
out[j++]=(enc2&15)<<4|enc3>>2;if(enc4!==64){// decoded 3 bytes
out[j++]=(enc3&3)<<6|enc4;}}}// make sure result is the exact decoded length
return output?j-offset:out.subarray(0,j);};// add support for base58 encoding/decoding with Bitcoin alphabet
util.binary.base58.encode=function(input,maxline){return util.binary.baseN.encode(input,_base58,maxline);};util.binary.base58.decode=function(input,maxline){return util.binary.baseN.decode(input,_base58,maxline);};// text encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.text={utf8:{},utf16:{}};/**
 * Encodes the given string as UTF-8 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.text.utf8.encode=function(str,output,offset){str=util.encodeUtf8(str);var out=output;if(!out){out=new Uint8Array(str.length);}offset=offset||0;var j=offset;for(var i=0;i<str.length;++i){out[j++]=str.charCodeAt(i);}return output?j-offset:out;};/**
 * Decodes the UTF-8 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */util.text.utf8.decode=function(bytes){return util.decodeUtf8(String.fromCharCode.apply(null,bytes));};/**
 * Encodes the given string as UTF-16 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.text.utf16.encode=function(str,output,offset){var out=output;if(!out){out=new Uint8Array(str.length*2);}var view=new Uint16Array(out.buffer);offset=offset||0;var j=offset;var k=offset;for(var i=0;i<str.length;++i){view[k++]=str.charCodeAt(i);j+=2;}return output?j-offset:out;};/**
 * Decodes the UTF-16 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */util.text.utf16.decode=function(bytes){return String.fromCharCode.apply(null,new Uint16Array(bytes.buffer));};/**
 * Deflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true to return only raw deflate data, false to include zlib
 *          header and trailer.
 *
 * @return the deflated data as a string.
 */util.deflate=function(api,bytes,raw){bytes=util.decode64(api.deflate(util.encode64(bytes)).rval);// strip zlib header and trailer if necessary
if(raw){// zlib header is 2 bytes (CMF,FLG) where FLG indicates that
// there is a 4-byte DICT (alder-32) block before the data if
// its 5th bit is set
var start=2;var flg=bytes.charCodeAt(1);if(flg&0x20){start=6;}// zlib trailer is 4 bytes of adler-32
bytes=bytes.substring(start,bytes.length-4);}return bytes;};/**
 * Inflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true if the incoming data has no zlib header or trailer and is
 *          raw DEFLATE data.
 *
 * @return the inflated data as a string, null on error.
 */util.inflate=function(api,bytes,raw){// TODO: add zlib header and trailer if necessary/possible
var rval=api.inflate(util.encode64(bytes)).rval;return rval===null?null:util.decode64(rval);};/**
 * Sets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param obj the storage object, null to remove.
 */var _setStorageObject=function _setStorageObject(api,id,obj){if(!api){throw new Error('WebStorage not available.');}var rval;if(obj===null){rval=api.removeItem(id);}else{// json-encode and base64-encode object
obj=util.encode64(JSON.stringify(obj));rval=api.setItem(id,obj);}// handle potential flash error
if(typeof rval!=='undefined'&&rval.rval!==true){var error=new Error(rval.error.message);error.id=rval.error.id;error.name=rval.error.name;throw error;}};/**
 * Gets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 *
 * @return the storage object entry or null if none exists.
 */var _getStorageObject=function _getStorageObject(api,id){if(!api){throw new Error('WebStorage not available.');}// get the existing entry
var rval=api.getItem(id);/* Note: We check api.init because we can't do (api == localStorage)
    on IE because of "Class doesn't support Automation" exception. Only
    the flash api has an init method so this works too, but we need a
    better solution in the future. */ // flash returns item wrapped in an object, handle special case
if(api.init){if(rval.rval===null){if(rval.error){var error=new Error(rval.error.message);error.id=rval.error.id;error.name=rval.error.name;throw error;}// no error, but also no item
rval=null;}else{rval=rval.rval;}}// handle decoding
if(rval!==null){// base64-decode and json-decode data
rval=JSON.parse(util.decode64(rval));}return rval;};/**
 * Stores an item in local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 */var _setItem=function _setItem(api,id,key,data){// get storage object
var obj=_getStorageObject(api,id);if(obj===null){// create a new storage object
obj={};}// update key
obj[key]=data;// set storage object
_setStorageObject(api,id,obj);};/**
 * Gets an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 *
 * @return the item.
 */var _getItem=function _getItem(api,id,key){// get storage object
var rval=_getStorageObject(api,id);if(rval!==null){// return data at key
rval=key in rval?rval[key]:null;}return rval;};/**
 * Removes an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 */var _removeItem=function _removeItem(api,id,key){// get storage object
var obj=_getStorageObject(api,id);if(obj!==null&&key in obj){// remove key
delete obj[key];// see if entry has no keys remaining
var empty=true;for(var prop in obj){empty=false;break;}if(empty){// remove entry entirely if no keys are left
obj=null;}// set storage object
_setStorageObject(api,id,obj);}};/**
 * Clears the local disk storage identified by the given ID.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 */var _clearItems=function _clearItems(api,id){_setStorageObject(api,id,null);};/**
 * Calls a storage function.
 *
 * @param func the function to call.
 * @param args the arguments for the function.
 * @param location the location argument.
 *
 * @return the return value from the function.
 */var _callStorageFunction=function _callStorageFunction(func,args,location){var rval=null;// default storage types
if(typeof location==='undefined'){location=['web','flash'];}// apply storage types in order of preference
var type;var done=false;var exception=null;for(var idx in location){type=location[idx];try{if(type==='flash'||type==='both'){if(args[0]===null){throw new Error('Flash local storage not available.');}rval=func.apply(this,args);done=type==='flash';}if(type==='web'||type==='both'){args[0]=localStorage;rval=func.apply(this,args);done=true;}}catch(ex){exception=ex;}if(done){break;}}if(!done){throw exception;}return rval;};/**
 * Stores an item on local disk.
 *
 * The available types of local storage include 'flash', 'web', and 'both'.
 *
 * The type 'flash' refers to flash local storage (SharedObject). In order
 * to use flash local storage, the 'api' parameter must be valid. The type
 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
 * refers to storing using both 'flash' and 'web', not just one or the
 * other.
 *
 * The location array should list the storage types to use in order of
 * preference:
 *
 * ['flash']: flash only storage
 * ['web']: web only storage
 * ['both']: try to store in both
 * ['flash','web']: store in flash first, but if not available, 'web'
 * ['web','flash']: store in web first, but if not available, 'flash'
 *
 * The location array defaults to: ['web', 'flash']
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 * @param location an array with the preferred types of storage to use.
 */util.setItem=function(api,id,key,data,location){_callStorageFunction(_setItem,arguments,location);};/**
 * Gets an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 *
 * @return the item.
 */util.getItem=function(api,id,key,location){return _callStorageFunction(_getItem,arguments,location);};/**
 * Removes an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 */util.removeItem=function(api,id,key,location){_callStorageFunction(_removeItem,arguments,location);};/**
 * Clears the local disk storage identified by the given ID.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface if flash is available.
 * @param id the storage ID to use.
 * @param location an array with the preferred types of storage to use.
 */util.clearItems=function(api,id,location){_callStorageFunction(_clearItems,arguments,location);};/**
 * Parses the scheme, host, and port from an http(s) url.
 *
 * @param str the url string.
 *
 * @return the parsed url object or null if the url is invalid.
 */util.parseUrl=function(str){// FIXME: this regex looks a bit broken
var regex=/^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;regex.lastIndex=0;var m=regex.exec(str);var url=m===null?null:{full:str,scheme:m[1],host:m[2],port:m[3],path:m[4]};if(url){url.fullHost=url.host;if(url.port){if(url.port!==80&&url.scheme==='http'){url.fullHost+=':'+url.port;}else if(url.port!==443&&url.scheme==='https'){url.fullHost+=':'+url.port;}}else if(url.scheme==='http'){url.port=80;}else if(url.scheme==='https'){url.port=443;}url.full=url.scheme+'://'+url.fullHost;}return url;};/* Storage for query variables */var _queryVariables=null;/**
 * Returns the window location query variables. Query is parsed on the first
 * call and the same object is returned on subsequent calls. The mapping
 * is from keys to an array of values. Parameters without values will have
 * an object key set but no value added to the value array. Values are
 * unescaped.
 *
 * ...?k1=v1&k2=v2:
 * {
 *   "k1": ["v1"],
 *   "k2": ["v2"]
 * }
 *
 * ...?k1=v1&k1=v2:
 * {
 *   "k1": ["v1", "v2"]
 * }
 *
 * ...?k1=v1&k2:
 * {
 *   "k1": ["v1"],
 *   "k2": []
 * }
 *
 * ...?k1=v1&k1:
 * {
 *   "k1": ["v1"]
 * }
 *
 * ...?k1&k1:
 * {
 *   "k1": []
 * }
 *
 * @param query the query string to parse (optional, default to cached
 *          results from parsing window location search query).
 *
 * @return object mapping keys to variables.
 */util.getQueryVariables=function(query){var parse=function parse(q){var rval={};var kvpairs=q.split('&');for(var i=0;i<kvpairs.length;i++){var pos=kvpairs[i].indexOf('=');var key;var val;if(pos>0){key=kvpairs[i].substring(0,pos);val=kvpairs[i].substring(pos+1);}else{key=kvpairs[i];val=null;}if(!(key in rval)){rval[key]=[];}// disallow overriding object prototype keys
if(!(key in Object.prototype)&&val!==null){rval[key].push(unescape(val));}}return rval;};var rval;if(typeof query==='undefined'){// set cached variables if needed
if(_queryVariables===null){if(typeof window!=='undefined'&&window.location&&window.location.search){// parse window search query
_queryVariables=parse(window.location.search.substring(1));}else{// no query variables available
_queryVariables={};}}rval=_queryVariables;}else{// parse given query
rval=parse(query);}return rval;};/**
 * Parses a fragment into a path and query. This method will take a URI
 * fragment and break it up as if it were the main URI. For example:
 *    /bar/baz?a=1&b=2
 * results in:
 *    {
 *       path: ["bar", "baz"],
 *       query: {"k1": ["v1"], "k2": ["v2"]}
 *    }
 *
 * @return object with a path array and query object.
 */util.parseFragment=function(fragment){// default to whole fragment
var fp=fragment;var fq='';// split into path and query if possible at the first '?'
var pos=fragment.indexOf('?');if(pos>0){fp=fragment.substring(0,pos);fq=fragment.substring(pos+1);}// split path based on '/' and ignore first element if empty
var path=fp.split('/');if(path.length>0&&path[0]===''){path.shift();}// convert query into object
var query=fq===''?{}:util.getQueryVariables(fq);return{pathString:fp,queryString:fq,path:path,query:query};};/**
 * Makes a request out of a URI-like request string. This is intended to
 * be used where a fragment id (after a URI '#') is parsed as a URI with
 * path and query parts. The string should have a path beginning and
 * delimited by '/' and optional query parameters following a '?'. The
 * query should be a standard URL set of key value pairs delimited by
 * '&'. For backwards compatibility the initial '/' on the path is not
 * required. The request object has the following API, (fully described
 * in the method code):
 *    {
 *       path: <the path string part>.
 *       query: <the query string part>,
 *       getPath(i): get part or all of the split path array,
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */util.makeRequest=function(reqString){var frag=util.parseFragment(reqString);var req={// full path string
path:frag.pathString,// full query string
query:frag.queryString,/**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */getPath:function getPath(i){return typeof i==='undefined'?frag.path:frag.path[i];},/**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */getQuery:function getQuery(k,i){var rval;if(typeof k==='undefined'){rval=frag.query;}else{rval=frag.query[k];if(rval&&typeof i!=='undefined'){rval=rval[i];}}return rval;},getQueryLast:function getQueryLast(k,_default){var rval;var vals=req.getQuery(k);if(vals){rval=vals[vals.length-1];}else{rval=_default;}return rval;}};return req;};/**
 * Makes a URI out of a path, an object with query parameters, and a
 * fragment. Uses jQuery.param() internally for query string creation.
 * If the path is an array, it will be joined with '/'.
 *
 * @param path string path or array of strings.
 * @param query object with query parameters. (optional)
 * @param fragment fragment string. (optional)
 *
 * @return string object with request parameters.
 */util.makeLink=function(path,query,fragment){// join path parts if needed
path=jQuery.isArray(path)?path.join('/'):path;var qstr=jQuery.param(query||{});fragment=fragment||'';return path+(qstr.length>0?'?'+qstr:'')+(fragment.length>0?'#'+fragment:'');};/**
 * Follows a path of keys deep into an object hierarchy and set a value.
 * If a key does not exist or it's value is not an object, create an
 * object in it's place. This can be destructive to a object tree if
 * leaf nodes are given as non-final path keys.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param value the value to set.
 */util.setPath=function(object,keys,value){// need to start at an object
if(_typeof(object)==='object'&&object!==null){var i=0;var len=keys.length;while(i<len){var next=keys[i++];if(i==len){// last
object[next]=value;}else{// more
var hasNext=next in object;if(!hasNext||hasNext&&_typeof(object[next])!=='object'||hasNext&&object[next]===null){object[next]={};}object=object[next];}}}};/**
 * Follows a path of keys deep into an object hierarchy and return a value.
 * If a key does not exist, create an object in it's place.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param _default value to return if path not found.
 *
 * @return the value at the path if found, else default if given, else
 *         undefined.
 */util.getPath=function(object,keys,_default){var i=0;var len=keys.length;var hasNext=true;while(hasNext&&i<len&&_typeof(object)==='object'&&object!==null){var next=keys[i++];hasNext=next in object;if(hasNext){object=object[next];}}return hasNext?object:_default;};/**
 * Follow a path of keys deep into an object hierarchy and delete the
 * last one. If a key does not exist, do nothing.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 */util.deletePath=function(object,keys){// need to start at an object
if(_typeof(object)==='object'&&object!==null){var i=0;var len=keys.length;while(i<len){var next=keys[i++];if(i==len){// last
delete object[next];}else{// more
if(!(next in object)||_typeof(object[next])!=='object'||object[next]===null){break;}object=object[next];}}}};/**
 * Check if an object is empty.
 *
 * Taken from:
 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
 *
 * @param object the object to check.
 */util.isEmpty=function(obj){for(var prop in obj){if(obj.hasOwnProperty(prop)){return false;}}return true;};/**
 * Format with simple printf-style interpolation.
 *
 * %%: literal '%'
 * %s,%o: convert next argument into a string.
 *
 * @param format the string to format.
 * @param ... arguments to interpolate into the format string.
 */util.format=function(format){var re=/%./g;// current match
var match;// current part
var part;// current arg index
var argi=0;// collected parts to recombine later
var parts=[];// last index found
var last=0;// loop while matches remain
while(match=re.exec(format)){part=format.substring(last,re.lastIndex-2);// don't add empty strings (ie, parts between %s%s)
if(part.length>0){parts.push(part);}last=re.lastIndex;// switch on % code
var code=match[0][1];switch(code){case's':case'o':// check if enough arguments were given
if(argi<arguments.length){parts.push(arguments[argi++ +1]);}else{parts.push('<?>');}break;// FIXME: do proper formating for numbers, etc
//case 'f':
//case 'd':
case'%':parts.push('%');break;default:parts.push('<%'+code+'?>');}}// add trailing part of format string
parts.push(format.substring(last));return parts.join('');};/**
 * Formats a number.
 *
 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
 */util.formatNumber=function(number,decimals,dec_point,thousands_sep){// http://kevin.vanzonneveld.net
// +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +     bugfix by: Michael White (http://crestidg.com)
// +     bugfix by: Benjamin Lupton
// +     bugfix by: Allan Jensen (http://www.winternet.no)
// +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
// *     example 1: number_format(1234.5678, 2, '.', '');
// *     returns 1: 1234.57
var n=number,c=isNaN(decimals=Math.abs(decimals))?2:decimals;var d=dec_point===undefined?',':dec_point;var t=thousands_sep===undefined?'.':thousands_sep,s=n<0?'-':'';var i=parseInt(n=Math.abs(+n||0).toFixed(c),10)+'';var j=i.length>3?i.length%3:0;return s+(j?i.substr(0,j)+t:'')+i.substr(j).replace(/(\d{3})(?=\d)/g,'$1'+t)+(c?d+Math.abs(n-i).toFixed(c).slice(2):'');};/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */util.formatSize=function(size){if(size>=1073741824){size=util.formatNumber(size/1073741824,2,'.','')+' GiB';}else if(size>=1048576){size=util.formatNumber(size/1048576,2,'.','')+' MiB';}else if(size>=1024){size=util.formatNumber(size/1024,0)+' KiB';}else{size=util.formatNumber(size,0)+' bytes';}return size;};/**
 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */util.bytesFromIP=function(ip){if(ip.indexOf('.')!==-1){return util.bytesFromIPv4(ip);}if(ip.indexOf(':')!==-1){return util.bytesFromIPv6(ip);}return null;};/**
 * Converts an IPv4 string representation into bytes (in network order).
 *
 * @param ip the IPv4 address to convert.
 *
 * @return the 4-byte address or null if the address can't be parsed.
 */util.bytesFromIPv4=function(ip){ip=ip.split('.');if(ip.length!==4){return null;}var b=util.createBuffer();for(var i=0;i<ip.length;++i){var num=parseInt(ip[i],10);if(isNaN(num)){return null;}b.putByte(num);}return b.getBytes();};/**
 * Converts an IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv6 address to convert.
 *
 * @return the 16-byte address or null if the address can't be parsed.
 */util.bytesFromIPv6=function(ip){var blanks=0;ip=ip.split(':').filter(function(e){if(e.length===0)++blanks;return true;});var zeros=(8-ip.length+blanks)*2;var b=util.createBuffer();for(var i=0;i<8;++i){if(!ip[i]||ip[i].length===0){b.fillWithByte(0,zeros);zeros=0;continue;}var bytes=util.hexToBytes(ip[i]);if(bytes.length<2){b.putByte(0);}b.putBytes(bytes);}return b.getBytes();};/**
 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
 * an IPv6 string representation. The bytes must be in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */util.bytesToIP=function(bytes){if(bytes.length===4){return util.bytesToIPv4(bytes);}if(bytes.length===16){return util.bytesToIPv6(bytes);}return null;};/**
 * Converts 4-bytes into an IPv4 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 string representation or null for an invalid # of bytes.
 */util.bytesToIPv4=function(bytes){if(bytes.length!==4){return null;}var ip=[];for(var i=0;i<bytes.length;++i){ip.push(bytes.charCodeAt(i));}return ip.join('.');};/**
 * Converts 16-bytes into an IPv16 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv16 string representation or null for an invalid # of bytes.
 */util.bytesToIPv6=function(bytes){if(bytes.length!==16){return null;}var ip=[];var zeroGroups=[];var zeroMaxGroup=0;for(var i=0;i<bytes.length;i+=2){var hex=util.bytesToHex(bytes[i]+bytes[i+1]);// canonicalize zero representation
while(hex[0]==='0'&&hex!=='0'){hex=hex.substr(1);}if(hex==='0'){var last=zeroGroups[zeroGroups.length-1];var idx=ip.length;if(!last||idx!==last.end+1){zeroGroups.push({start:idx,end:idx});}else{last.end=idx;if(last.end-last.start>zeroGroups[zeroMaxGroup].end-zeroGroups[zeroMaxGroup].start){zeroMaxGroup=zeroGroups.length-1;}}}ip.push(hex);}if(zeroGroups.length>0){var group=zeroGroups[zeroMaxGroup];// only shorten group of length > 0
if(group.end-group.start>0){ip.splice(group.start,group.end-group.start+1,'');if(group.start===0){ip.unshift('');}if(group.end===7){ip.push('');}}}return ip.join(':');};/**
 * Estimates the number of processes that can be run concurrently. If
 * creating Web Workers, keep in mind that the main JavaScript process needs
 * its own core.
 *
 * @param options the options to use:
 *          update true to force an update (not use the cached value).
 * @param callback(err, max) called once the operation completes.
 */util.estimateCores=function(options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};if('cores'in util&&!options.update){return callback(null,util.cores);}if(typeof navigator!=='undefined'&&'hardwareConcurrency'in navigator&&navigator.hardwareConcurrency>0){util.cores=navigator.hardwareConcurrency;return callback(null,util.cores);}if(typeof Worker==='undefined'){// workers not available
util.cores=1;return callback(null,util.cores);}if(typeof Blob==='undefined'){// can't estimate, default to 2
util.cores=2;return callback(null,util.cores);}// create worker concurrency estimation code as blob
var blobUrl=URL.createObjectURL(new Blob(['(',function(){self.addEventListener('message',function(e){// run worker for 4 ms
var st=Date.now();var et=st+4;while(Date.now()<et){;}self.postMessage({st:st,et:et});});}.toString(),')()'],{type:'application/javascript'}));// take 5 samples using 16 workers
sample([],5,16);function sample(max,samples,numWorkers){if(samples===0){// get overlap average
var avg=Math.floor(max.reduce(function(avg,x){return avg+x;},0)/max.length);util.cores=Math.max(1,avg);URL.revokeObjectURL(blobUrl);return callback(null,util.cores);}map(numWorkers,function(err,results){max.push(reduce(numWorkers,results));sample(max,samples-1,numWorkers);});}function map(numWorkers,callback){var workers=[];var results=[];for(var i=0;i<numWorkers;++i){var worker=new Worker(blobUrl);worker.addEventListener('message',function(e){results.push(e.data);if(results.length===numWorkers){for(var i=0;i<numWorkers;++i){workers[i].terminate();}callback(null,results);}});workers.push(worker);}for(var i=0;i<numWorkers;++i){workers[i].postMessage(i);}}function reduce(numWorkers,results){// find overlapping time windows
var overlaps=[];for(var n=0;n<numWorkers;++n){var r1=results[n];var overlap=overlaps[n]=[];for(var i=0;i<numWorkers;++i){if(n===i){continue;}var r2=results[i];if(r1.st>r2.st&&r1.st<r2.et||r2.st>r1.st&&r2.st<r1.et){overlap.push(i);}}}// get maximum overlaps ... don't include overlapping worker itself
// as the main JS process was also being scheduled during the work and
// would have to be subtracted from the estimate anyway
return overlaps.reduce(function(max,overlap){return Math.max(max,overlap.length);},0);}};/***/},/* 2 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of Abstract Syntax Notation Number One.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 *
 * An API for storing data using the Abstract Syntax Notation Number One
 * format using DER (Distinguished Encoding Rules) encoding. This encoding is
 * commonly used to store data for PKI, i.e. X.509 Certificates, and this
 * implementation exists for that purpose.
 *
 * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract
 * syntax of information without restricting the way the information is encoded
 * for transmission. It provides a standard that allows for open systems
 * communication. ASN.1 defines the syntax of information data and a number of
 * simple data types as well as a notation for describing them and specifying
 * values for them.
 *
 * The RSA algorithm creates public and private keys that are often stored in
 * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This
 * class provides the most basic functionality required to store and load DSA
 * keys that are encoded according to ASN.1.
 *
 * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)
 * and DER (Distinguished Encoding Rules). DER is just a subset of BER that
 * has stricter requirements for how data must be encoded.
 *
 * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)
 * and a byte array for the value of this ASN1 structure which may be data or a
 * list of ASN.1 structures.
 *
 * Each ASN.1 structure using BER is (Tag-Length-Value):
 *
 * | byte 0 | bytes X | bytes Y |
 * |--------|---------|----------
 * |  tag   | length  |  value  |
 *
 * ASN.1 allows for tags to be of "High-tag-number form" which allows a tag to
 * be two or more octets, but that is not supported by this class. A tag is
 * only 1 byte. Bits 1-5 give the tag number (ie the data type within a
 * particular 'class'), 6 indicates whether or not the ASN.1 value is
 * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If
 * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,
 * then the class is APPLICATION. If only bit 8 is set, then the class is
 * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.
 * The tag numbers for the data types for the class UNIVERSAL are listed below:
 *
 * UNIVERSAL 0 Reserved for use by the encoding rules
 * UNIVERSAL 1 Boolean type
 * UNIVERSAL 2 Integer type
 * UNIVERSAL 3 Bitstring type
 * UNIVERSAL 4 Octetstring type
 * UNIVERSAL 5 Null type
 * UNIVERSAL 6 Object identifier type
 * UNIVERSAL 7 Object descriptor type
 * UNIVERSAL 8 External type and Instance-of type
 * UNIVERSAL 9 Real type
 * UNIVERSAL 10 Enumerated type
 * UNIVERSAL 11 Embedded-pdv type
 * UNIVERSAL 12 UTF8String type
 * UNIVERSAL 13 Relative object identifier type
 * UNIVERSAL 14-15 Reserved for future editions
 * UNIVERSAL 16 Sequence and Sequence-of types
 * UNIVERSAL 17 Set and Set-of types
 * UNIVERSAL 18-22, 25-30 Character string types
 * UNIVERSAL 23-24 Time types
 *
 * The length of an ASN.1 structure is specified after the tag identifier.
 * There is a definite form and an indefinite form. The indefinite form may
 * be used if the encoding is constructed and not all immediately available.
 * The indefinite form is encoded using a length byte with only the 8th bit
 * set. The end of the constructed object is marked using end-of-contents
 * octets (two zero bytes).
 *
 * The definite form looks like this:
 *
 * The length may take up 1 or more bytes, it depends on the length of the
 * value of the ASN.1 structure. DER encoding requires that if the ASN.1
 * structure has a value that has a length greater than 127, more than 1 byte
 * will be used to store its length, otherwise just one byte will be used.
 * This is strict.
 *
 * In the case that the length of the ASN.1 value is less than 127, 1 octet
 * (byte) is used to store the "short form" length. The 8th bit has a value of
 * 0 indicating the length is "short form" and not "long form" and bits 7-1
 * give the length of the data. (The 8th bit is the left-most, most significant
 * bit: also known as big endian or network format).
 *
 * In the case that the length of the ASN.1 value is greater than 127, 2 to
 * 127 octets (bytes) are used to store the "long form" length. The first
 * byte's 8th bit is set to 1 to indicate the length is "long form." Bits 7-1
 * give the number of additional octets. All following octets are in base 256
 * with the most significant digit first (typical big-endian binary unsigned
 * integer storage). So, for instance, if the length of a value was 257, the
 * first byte would be set to:
 *
 * 10000010 = 130 = 0x82.
 *
 * This indicates there are 2 octets (base 256) for the length. The second and
 * third bytes (the octets just mentioned) would store the length in base 256:
 *
 * octet 2: 00000001 = 1 * 256^1 = 256
 * octet 3: 00000001 = 1 * 256^0 = 1
 * total = 257
 *
 * The algorithm for converting a js integer value of 257 to base-256 is:
 *
 * var value = 257;
 * var bytes = [];
 * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first
 * bytes[1] = value & 0xFF;        // least significant byte last
 *
 * On the ASN.1 UNIVERSAL Object Identifier (OID) type:
 *
 * An OID can be written like: "value1.value2.value3...valueN"
 *
 * The DER encoding rules:
 *
 * The first byte has the value 40 * value1 + value2.
 * The following bytes, if any, encode the remaining values. Each value is
 * encoded in base 128, most significant digit first (big endian), with as
 * few digits as possible, and the most significant bit of each byte set
 * to 1 except the last in each value's encoding. For example: Given the
 * OID "1.2.840.113549", its DER encoding is (remember each byte except the
 * last one in each encoding is OR'd with 0x80):
 *
 * byte 1: 40 * 1 + 2 = 42 = 0x2A.
 * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648
 * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D
 *
 * The final value is: 0x2A864886F70D.
 * The full OID (including ASN.1 tag and length of 6 bytes) is:
 * 0x06062A864886F70D
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(3);/* ASN.1 API */var asn1=module.exports=forge.asn1=forge.asn1||{};/**
 * ASN.1 classes.
 */asn1.Class={UNIVERSAL:0x00,APPLICATION:0x40,CONTEXT_SPECIFIC:0x80,PRIVATE:0xC0};/**
 * ASN.1 types. Not all types are supported by this implementation, only
 * those necessary to implement a simple PKI are implemented.
 */asn1.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30};/**
 * Creates a new asn1 object.
 *
 * @param tagClass the tag class for the object.
 * @param type the data type (tag number) for the object.
 * @param constructed true if the asn1 object is in constructed form.
 * @param value the value for the object, if it is not constructed.
 * @param [options] the options to use:
 *          [bitStringContents] the plain BIT STRING content including padding
 *            byte.
 *
 * @return the asn1 object.
 */asn1.create=function(tagClass,type,constructed,value,options){/* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */ // remove undefined values
if(forge.util.isArray(value)){var tmp=[];for(var i=0;i<value.length;++i){if(value[i]!==undefined){tmp.push(value[i]);}}value=tmp;}var obj={tagClass:tagClass,type:type,constructed:constructed,composed:constructed||forge.util.isArray(value),value:value};if(options&&'bitStringContents'in options){// TODO: copy byte buffer if it's a buffer not a string
obj.bitStringContents=options.bitStringContents;// TODO: add readonly flag to avoid this overhead
// save copy to detect changes
obj.original=asn1.copy(obj);}return obj;};/**
 * Copies an asn1 object.
 *
 * @param obj the asn1 object.
 * @param [options] copy options:
 *          [excludeBitStringContents] true to not copy bitStringContents
 *
 * @return the a copy of the asn1 object.
 */asn1.copy=function(obj,options){var copy;if(forge.util.isArray(obj)){copy=[];for(var i=0;i<obj.length;++i){copy.push(asn1.copy(obj[i],options));}return copy;}if(typeof obj==='string'){// TODO: copy byte buffer if it's a buffer not a string
return obj;}copy={tagClass:obj.tagClass,type:obj.type,constructed:obj.constructed,composed:obj.composed,value:asn1.copy(obj.value,options)};if(options&&!options.excludeBitStringContents){// TODO: copy byte buffer if it's a buffer not a string
copy.bitStringContents=obj.bitStringContents;}return copy;};/**
 * Compares asn1 objects for equality.
 *
 * Note this function does not run in constant time.
 *
 * @param obj1 the first asn1 object.
 * @param obj2 the second asn1 object.
 * @param [options] compare options:
 *          [includeBitStringContents] true to compare bitStringContents
 *
 * @return true if the asn1 objects are equal.
 */asn1.equals=function(obj1,obj2,options){if(forge.util.isArray(obj1)){if(!forge.util.isArray(obj2)){return false;}if(obj1.length!==obj2.length){return false;}for(var i=0;i<obj1.length;++i){if(!asn1.equals(obj1[i],obj2[i])){return false;}}return true;}if(_typeof(obj1)!==_typeof(obj2)){return false;}if(typeof obj1==='string'){return obj1===obj2;}var equal=obj1.tagClass===obj2.tagClass&&obj1.type===obj2.type&&obj1.constructed===obj2.constructed&&obj1.composed===obj2.composed&&asn1.equals(obj1.value,obj2.value);if(options&&options.includeBitStringContents){equal=equal&&obj1.bitStringContents===obj2.bitStringContents;}return equal;};/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param b the BER-encoded ASN.1 byte buffer, starting with the first
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */asn1.getBerValueLength=function(b){// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
var b2=b.getByte();if(b2===0x80){return undefined;}// see if the length is "short form" or "long form" (bit 8 set)
var length;var longForm=b2&0x80;if(!longForm){// length is just the first byte
length=b2;}else{// the number of bytes the length is specified in bits 7 through 1
// and each length byte is in big-endian base-256
length=b.getInt((b2&0x7F)<<3);}return length;};/**
 * Check if the byte buffer has enough bytes. Throws an Error if not.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 * @param n the number of bytes the buffer must have.
 */function _checkBufferLength(bytes,remaining,n){if(n>remaining){var error=new Error('Too few bytes to parse DER.');error.available=bytes.length();error.remaining=remaining;error.requested=n;throw error;}}/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */var _getValueLength=function _getValueLength(bytes,remaining){// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
// fromDer already checked that this byte exists
var b2=bytes.getByte();remaining--;if(b2===0x80){return undefined;}// see if the length is "short form" or "long form" (bit 8 set)
var length;var longForm=b2&0x80;if(!longForm){// length is just the first byte
length=b2;}else{// the number of bytes the length is specified in bits 7 through 1
// and each length byte is in big-endian base-256
var longFormBytes=b2&0x7F;_checkBufferLength(bytes,remaining,longFormBytes);length=bytes.getInt(longFormBytes<<3);}// FIXME: this will only happen for 32 bit getInt with high bit set
if(length<0){throw new Error('Negative length: '+length);}return length;};/**
 * Parses an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param [strict] true to be strict when checking value lengths, false to
 *          allow truncated values (default: true).
 * @param [options] object with options or boolean strict flag
 *          [strict] true to be strict when checking value lengths, false to
 *            allow truncated values (default: true).
 *          [decodeBitStrings] true to attempt to decode the content of
 *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
 *            without schema support to understand the data context this can
 *            erroneously decode values that happen to be valid ASN.1. This
 *            flag will be deprecated or removed as soon as schema support is
 *            available. (default: true)
 *
 * @return the parsed asn1 object.
 */asn1.fromDer=function(bytes,options){if(options===undefined){options={strict:true,decodeBitStrings:true};}if(typeof options==='boolean'){options={strict:options,decodeBitStrings:true};}if(!('strict'in options)){options.strict=true;}if(!('decodeBitStrings'in options)){options.decodeBitStrings=true;}// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}return _fromDer(bytes,bytes.length(),0,options);};/**
 * Internal function to parse an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the number of bytes remaining for this chunk.
 * @param depth the current parsing depth.
 * @param options object with same options as fromDer().
 *
 * @return the parsed asn1 object.
 */function _fromDer(bytes,remaining,depth,options){// temporary storage for consumption calculations
var start;// minimum length for ASN.1 DER structure is 2
_checkBufferLength(bytes,remaining,2);// get the first byte
var b1=bytes.getByte();// consumed one byte
remaining--;// get the tag class
var tagClass=b1&0xC0;// get the type (bits 1-5)
var type=b1&0x1F;// get the variable value length and adjust remaining bytes
start=bytes.length();var length=_getValueLength(bytes,remaining);remaining-=start-bytes.length();// ensure there are enough bytes to get the value
if(length!==undefined&&length>remaining){if(options.strict){var error=new Error('Too few bytes to read ASN.1 value.');error.available=bytes.length();error.remaining=remaining;error.requested=length;throw error;}// Note: be lenient with truncated values and use remaining state bytes
length=remaining;}// value storage
var value;// possible BIT STRING contents storage
var bitStringContents;// constructed flag is bit 6 (32 = 0x20) of the first byte
var constructed=(b1&0x20)===0x20;if(constructed){// parse child asn1 objects from the value
value=[];if(length===undefined){// asn1 object of indefinite length, read until end tag
for(;;){_checkBufferLength(bytes,remaining,2);if(bytes.bytes(2)===String.fromCharCode(0,0)){bytes.getBytes(2);remaining-=2;break;}start=bytes.length();value.push(_fromDer(bytes,remaining,depth+1,options));remaining-=start-bytes.length();}}else{// parsing asn1 object of definite length
while(length>0){start=bytes.length();value.push(_fromDer(bytes,length,depth+1,options));remaining-=start-bytes.length();length-=start-bytes.length();}}}// if a BIT STRING, save the contents including padding
if(value===undefined&&tagClass===asn1.Class.UNIVERSAL&&type===asn1.Type.BITSTRING){bitStringContents=bytes.bytes(length);}// determine if a non-constructed value should be decoded as a composed
// value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)
// can be used this way.
if(value===undefined&&options.decodeBitStrings&&tagClass===asn1.Class.UNIVERSAL&&// FIXME: OCTET STRINGs not yet supported here
// .. other parts of forge expect to decode OCTET STRINGs manually
type===asn1.Type.BITSTRING/*|| type === asn1.Type.OCTETSTRING*/&&length>1){// save read position
var savedRead=bytes.read;var savedRemaining=remaining;var unused=0;if(type===asn1.Type.BITSTRING){/* The first octet gives the number of bits by which the length of the
        bit string is less than the next multiple of eight (this is called
        the "number of unused bits").

        The second and following octets give the value of the bit string
        converted to an octet string. */_checkBufferLength(bytes,remaining,1);unused=bytes.getByte();remaining--;}// if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs
if(unused===0){try{// attempt to parse child asn1 object from the value
// (stored in array to signal composed value)
start=bytes.length();var subOptions={// enforce strict mode to avoid parsing ASN.1 from plain data
verbose:options.verbose,strict:true,decodeBitStrings:true};var composed=_fromDer(bytes,remaining,depth+1,subOptions);var used=start-bytes.length();remaining-=used;if(type==asn1.Type.BITSTRING){used++;}// if the data all decoded and the class indicates UNIVERSAL or
// CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object
var tc=composed.tagClass;if(used===length&&(tc===asn1.Class.UNIVERSAL||tc===asn1.Class.CONTEXT_SPECIFIC)){value=[composed];}}catch(ex){}}if(value===undefined){// restore read position
bytes.read=savedRead;remaining=savedRemaining;}}if(value===undefined){// asn1 not constructed or composed, get raw value
// TODO: do DER to OID conversion and vice-versa in .toDer?
if(length===undefined){if(options.strict){throw new Error('Non-constructed ASN.1 object of indefinite length.');}// be lenient and use remaining state bytes
length=remaining;}if(type===asn1.Type.BMPSTRING){value='';for(;length>0;length-=2){_checkBufferLength(bytes,remaining,2);value+=String.fromCharCode(bytes.getInt16());remaining-=2;}}else{value=bytes.getBytes(length);}}// add BIT STRING contents if available
var asn1Options=bitStringContents===undefined?null:{bitStringContents:bitStringContents};// create and return asn1 object
return asn1.create(tagClass,type,constructed,value,asn1Options);}/**
 * Converts the given asn1 object to a buffer of bytes in DER format.
 *
 * @param asn1 the asn1 object to convert to bytes.
 *
 * @return the buffer of bytes.
 */asn1.toDer=function(obj){var bytes=forge.util.createBuffer();// build the first byte
var b1=obj.tagClass|obj.type;// for storing the ASN.1 value
var value=forge.util.createBuffer();// use BIT STRING contents if available and data not changed
var useBitStringContents=false;if('bitStringContents'in obj){useBitStringContents=true;if(obj.original){useBitStringContents=asn1.equals(obj,obj.original);}}if(useBitStringContents){value.putBytes(obj.bitStringContents);}else if(obj.composed){// if composed, use each child asn1 object's DER bytes as value
// turn on 6th bit (0x20 = 32) to indicate asn1 is constructed
// from other asn1 objects
if(obj.constructed){b1|=0x20;}else{// type is a bit string, add unused bits of 0x00
value.putByte(0x00);}// add all of the child DER bytes together
for(var i=0;i<obj.value.length;++i){if(obj.value[i]!==undefined){value.putBuffer(asn1.toDer(obj.value[i]));}}}else{// use asn1.value directly
if(obj.type===asn1.Type.BMPSTRING){for(var i=0;i<obj.value.length;++i){value.putInt16(obj.value.charCodeAt(i));}}else{// ensure integer is minimally-encoded
// TODO: should all leading bytes be stripped vs just one?
// .. ex '00 00 01' => '01'?
if(obj.type===asn1.Type.INTEGER&&obj.value.length>1&&(// leading 0x00 for positive integer
obj.value.charCodeAt(0)===0&&(obj.value.charCodeAt(1)&0x80)===0||// leading 0xFF for negative integer
obj.value.charCodeAt(0)===0xFF&&(obj.value.charCodeAt(1)&0x80)===0x80)){value.putBytes(obj.value.substr(1));}else{value.putBytes(obj.value);}}}// add tag byte
bytes.putByte(b1);// use "short form" encoding
if(value.length()<=127){// one byte describes the length
// bit 8 = 0 and bits 7-1 = length
bytes.putByte(value.length()&0x7F);}else{// use "long form" encoding
// 2 to 127 bytes describe the length
// first byte: bit 8 = 1 and bits 7-1 = # of additional bytes
// other bytes: length in base 256, big-endian
var len=value.length();var lenBytes='';do{lenBytes+=String.fromCharCode(len&0xFF);len=len>>>8;}while(len>0);// set first byte to # bytes used to store the length and turn on
// bit 8 to indicate long-form length is used
bytes.putByte(lenBytes.length|0x80);// concatenate length bytes in reverse since they were generated
// little endian and we need big endian
for(var i=lenBytes.length-1;i>=0;--i){bytes.putByte(lenBytes.charCodeAt(i));}}// concatenate value bytes
bytes.putBuffer(value);return bytes;};/**
 * Converts an OID dot-separated string to a byte buffer. The byte buffer
 * contains only the DER-encoded value, not any tag or length bytes.
 *
 * @param oid the OID dot-separated string.
 *
 * @return the byte buffer.
 */asn1.oidToDer=function(oid){// split OID into individual values
var values=oid.split('.');var bytes=forge.util.createBuffer();// first byte is 40 * value1 + value2
bytes.putByte(40*parseInt(values[0],10)+parseInt(values[1],10));// other bytes are each value in base 128 with 8th bit set except for
// the last byte for each value
var last,valueBytes,value,b;for(var i=2;i<values.length;++i){// produce value bytes in reverse because we don't know how many
// bytes it will take to store the value
last=true;valueBytes=[];value=parseInt(values[i],10);do{b=value&0x7F;value=value>>>7;// if value is not last, then turn on 8th bit
if(!last){b|=0x80;}valueBytes.push(b);last=false;}while(value>0);// add value bytes in reverse (needs to be in big endian)
for(var n=valueBytes.length-1;n>=0;--n){bytes.putByte(valueBytes[n]);}}return bytes;};/**
 * Converts a DER-encoded byte buffer to an OID dot-separated string. The
 * byte buffer should contain only the DER-encoded value, not any tag or
 * length bytes.
 *
 * @param bytes the byte buffer.
 *
 * @return the OID dot-separated string.
 */asn1.derToOid=function(bytes){var oid;// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}// first byte is 40 * value1 + value2
var b=bytes.getByte();oid=Math.floor(b/40)+'.'+b%40;// other bytes are each value in base 128 with 8th bit set except for
// the last byte for each value
var value=0;while(bytes.length()>0){b=bytes.getByte();value=value<<7;// not the last byte for the value
if(b&0x80){value+=b&0x7F;}else{// last byte
oid+='.'+(value+b);value=0;}}return oid;};/**
 * Converts a UTCTime value to a date.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Parsing that structure hasn't been implemented yet.
 *
 * @param utc the UTCTime value to convert.
 *
 * @return the date.
 */asn1.utcTimeToDate=function(utc){/* The following formats can be used:

    YYMMDDhhmmZ
    YYMMDDhhmm+hh'mm'
    YYMMDDhhmm-hh'mm'
    YYMMDDhhmmssZ
    YYMMDDhhmmss+hh'mm'
    YYMMDDhhmmss-hh'mm'

    Where:

    YY is the least significant two digits of the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */var date=new Date();// if YY >= 50 use 19xx, if YY < 50 use 20xx
var year=parseInt(utc.substr(0,2),10);year=year>=50?1900+year:2000+year;var MM=parseInt(utc.substr(2,2),10)-1;// use 0-11 for month
var DD=parseInt(utc.substr(4,2),10);var hh=parseInt(utc.substr(6,2),10);var mm=parseInt(utc.substr(8,2),10);var ss=0;// not just YYMMDDhhmmZ
if(utc.length>11){// get character after minutes
var c=utc.charAt(10);var end=10;// see if seconds are present
if(c!=='+'&&c!=='-'){// get seconds
ss=parseInt(utc.substr(10,2),10);end+=2;}}// update date
date.setUTCFullYear(year,MM,DD);date.setUTCHours(hh,mm,ss,0);if(end){// get +/- after end of time
c=utc.charAt(end);if(c==='+'||c==='-'){// get hours+minutes offset
var hhoffset=parseInt(utc.substr(end+1,2),10);var mmoffset=parseInt(utc.substr(end+4,2),10);// calculate offset in milliseconds
var offset=hhoffset*60+mmoffset;offset*=60000;// apply offset
if(c==='+'){date.setTime(+date-offset);}else{date.setTime(+date+offset);}}}return date;};/**
 * Converts a GeneralizedTime value to a date.
 *
 * @param gentime the GeneralizedTime value to convert.
 *
 * @return the date.
 */asn1.generalizedTimeToDate=function(gentime){/* The following formats can be used:

    YYYYMMDDHHMMSS
    YYYYMMDDHHMMSS.fff
    YYYYMMDDHHMMSSZ
    YYYYMMDDHHMMSS.fffZ
    YYYYMMDDHHMMSS+hh'mm'
    YYYYMMDDHHMMSS.fff+hh'mm'
    YYYYMMDDHHMMSS-hh'mm'
    YYYYMMDDHHMMSS.fff-hh'mm'

    Where:

    YYYY is the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    .fff is the second fraction, accurate to three decimal places
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */var date=new Date();var YYYY=parseInt(gentime.substr(0,4),10);var MM=parseInt(gentime.substr(4,2),10)-1;// use 0-11 for month
var DD=parseInt(gentime.substr(6,2),10);var hh=parseInt(gentime.substr(8,2),10);var mm=parseInt(gentime.substr(10,2),10);var ss=parseInt(gentime.substr(12,2),10);var fff=0;var offset=0;var isUTC=false;if(gentime.charAt(gentime.length-1)==='Z'){isUTC=true;}var end=gentime.length-5,c=gentime.charAt(end);if(c==='+'||c==='-'){// get hours+minutes offset
var hhoffset=parseInt(gentime.substr(end+1,2),10);var mmoffset=parseInt(gentime.substr(end+4,2),10);// calculate offset in milliseconds
offset=hhoffset*60+mmoffset;offset*=60000;// apply offset
if(c==='+'){offset*=-1;}isUTC=true;}// check for second fraction
if(gentime.charAt(14)==='.'){fff=parseFloat(gentime.substr(14),10)*1000;}if(isUTC){date.setUTCFullYear(YYYY,MM,DD);date.setUTCHours(hh,mm,ss,fff);// apply offset
date.setTime(+date+offset);}else{date.setFullYear(YYYY,MM,DD);date.setHours(hh,mm,ss,fff);}return date;};/**
 * Converts a date to a UTCTime value.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Converting to a GeneralizedTime hasn't been
 * implemented yet.
 *
 * @param date the date to convert.
 *
 * @return the UTCTime value.
 */asn1.dateToUtcTime=function(date){// TODO: validate; currently assumes proper format
if(typeof date==='string'){return date;}var rval='';// create format YYMMDDhhmmssZ
var format=[];format.push((''+date.getUTCFullYear()).substr(2));format.push(''+(date.getUTCMonth()+1));format.push(''+date.getUTCDate());format.push(''+date.getUTCHours());format.push(''+date.getUTCMinutes());format.push(''+date.getUTCSeconds());// ensure 2 digits are used for each format entry
for(var i=0;i<format.length;++i){if(format[i].length<2){rval+='0';}rval+=format[i];}rval+='Z';return rval;};/**
 * Converts a date to a GeneralizedTime value.
 *
 * @param date the date to convert.
 *
 * @return the GeneralizedTime value as a string.
 */asn1.dateToGeneralizedTime=function(date){// TODO: validate; currently assumes proper format
if(typeof date==='string'){return date;}var rval='';// create format YYYYMMDDHHMMSSZ
var format=[];format.push(''+date.getUTCFullYear());format.push(''+(date.getUTCMonth()+1));format.push(''+date.getUTCDate());format.push(''+date.getUTCHours());format.push(''+date.getUTCMinutes());format.push(''+date.getUTCSeconds());// ensure 2 digits are used for each format entry
for(var i=0;i<format.length;++i){if(format[i].length<2){rval+='0';}rval+=format[i];}rval+='Z';return rval;};/**
 * Converts a javascript integer to a DER-encoded byte buffer to be used
 * as the value for an INTEGER type.
 *
 * @param x the integer.
 *
 * @return the byte buffer.
 */asn1.integerToDer=function(x){var rval=forge.util.createBuffer();if(x>=-0x80&&x<0x80){return rval.putSignedInt(x,8);}if(x>=-0x8000&&x<0x8000){return rval.putSignedInt(x,16);}if(x>=-0x800000&&x<0x800000){return rval.putSignedInt(x,24);}if(x>=-0x80000000&&x<0x80000000){return rval.putSignedInt(x,32);}var error=new Error('Integer too large; max is 32-bits.');error.integer=x;throw error;};/**
 * Converts a DER-encoded byte buffer to a javascript integer. This is
 * typically used to decode the value of an INTEGER type.
 *
 * @param bytes the byte buffer.
 *
 * @return the integer.
 */asn1.derToInteger=function(bytes){// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}var n=bytes.length()*8;if(n>32){throw new Error('Integer too large; max is 32-bits.');}return bytes.getSignedInt(n);};/**
 * Validates that the given ASN.1 object is at least a super set of the
 * given ASN.1 structure. Only tag classes and types are checked. An
 * optional map may also be provided to capture ASN.1 values while the
 * structure is checked.
 *
 * To capture an ASN.1 value, set an object in the validator's 'capture'
 * parameter to the key to use in the capture map. To capture the full
 * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including
 * the leading unused bits counter byte, specify 'captureBitStringContents'.
 * To capture BIT STRING bytes, without the leading unused bits counter byte,
 * specify 'captureBitStringValue'.
 *
 * Objects in the validator may set a field 'optional' to true to indicate
 * that it isn't necessary to pass validation.
 *
 * @param obj the ASN.1 object to validate.
 * @param v the ASN.1 structure validator.
 * @param capture an optional map to capture values in.
 * @param errors an optional array for storing validation errors.
 *
 * @return true on success, false on failure.
 */asn1.validate=function(obj,v,capture,errors){var rval=false;// ensure tag class and type are the same if specified
if((obj.tagClass===v.tagClass||typeof v.tagClass==='undefined')&&(obj.type===v.type||typeof v.type==='undefined')){// ensure constructed flag is the same if specified
if(obj.constructed===v.constructed||typeof v.constructed==='undefined'){rval=true;// handle sub values
if(v.value&&forge.util.isArray(v.value)){var j=0;for(var i=0;rval&&i<v.value.length;++i){rval=v.value[i].optional||false;if(obj.value[j]){rval=asn1.validate(obj.value[j],v.value[i],capture,errors);if(rval){++j;}else if(v.value[i].optional){rval=true;}}if(!rval&&errors){errors.push('['+v.name+'] '+'Tag class "'+v.tagClass+'", type "'+v.type+'" expected value length "'+v.value.length+'", got "'+obj.value.length+'"');}}}if(rval&&capture){if(v.capture){capture[v.capture]=obj.value;}if(v.captureAsn1){capture[v.captureAsn1]=obj;}if(v.captureBitStringContents&&'bitStringContents'in obj){capture[v.captureBitStringContents]=obj.bitStringContents;}if(v.captureBitStringValue&&'bitStringContents'in obj){var value;if(obj.bitStringContents.length<2){capture[v.captureBitStringValue]='';}else{// FIXME: support unused bits with data shifting
var unused=obj.bitStringContents.charCodeAt(0);if(unused!==0){throw new Error('captureBitStringValue only supported for zero unused bits');}capture[v.captureBitStringValue]=obj.bitStringContents.slice(1);}}}}else if(errors){errors.push('['+v.name+'] '+'Expected constructed "'+v.constructed+'", got "'+obj.constructed+'"');}}else if(errors){if(obj.tagClass!==v.tagClass){errors.push('['+v.name+'] '+'Expected tag class "'+v.tagClass+'", got "'+obj.tagClass+'"');}if(obj.type!==v.type){errors.push('['+v.name+'] '+'Expected type "'+v.type+'", got "'+obj.type+'"');}}return rval;};// regex for testing for non-latin characters
var _nonLatinRegex=/[^\\u0000-\\u00ff]/;/**
 * Pretty prints an ASN.1 object to a string.
 *
 * @param obj the object to write out.
 * @param level the level in the tree.
 * @param indentation the indentation to use.
 *
 * @return the string.
 */asn1.prettyPrint=function(obj,level,indentation){var rval='';// set default level and indentation
level=level||0;indentation=indentation||2;// start new line for deep levels
if(level>0){rval+='\n';}// create indent
var indent='';for(var i=0;i<level*indentation;++i){indent+=' ';}// print class:type
rval+=indent+'Tag: ';switch(obj.tagClass){case asn1.Class.UNIVERSAL:rval+='Universal:';break;case asn1.Class.APPLICATION:rval+='Application:';break;case asn1.Class.CONTEXT_SPECIFIC:rval+='Context-Specific:';break;case asn1.Class.PRIVATE:rval+='Private:';break;}if(obj.tagClass===asn1.Class.UNIVERSAL){rval+=obj.type;// known types
switch(obj.type){case asn1.Type.NONE:rval+=' (None)';break;case asn1.Type.BOOLEAN:rval+=' (Boolean)';break;case asn1.Type.INTEGER:rval+=' (Integer)';break;case asn1.Type.BITSTRING:rval+=' (Bit string)';break;case asn1.Type.OCTETSTRING:rval+=' (Octet string)';break;case asn1.Type.NULL:rval+=' (Null)';break;case asn1.Type.OID:rval+=' (Object Identifier)';break;case asn1.Type.ODESC:rval+=' (Object Descriptor)';break;case asn1.Type.EXTERNAL:rval+=' (External or Instance of)';break;case asn1.Type.REAL:rval+=' (Real)';break;case asn1.Type.ENUMERATED:rval+=' (Enumerated)';break;case asn1.Type.EMBEDDED:rval+=' (Embedded PDV)';break;case asn1.Type.UTF8:rval+=' (UTF8)';break;case asn1.Type.ROID:rval+=' (Relative Object Identifier)';break;case asn1.Type.SEQUENCE:rval+=' (Sequence)';break;case asn1.Type.SET:rval+=' (Set)';break;case asn1.Type.PRINTABLESTRING:rval+=' (Printable String)';break;case asn1.Type.IA5String:rval+=' (IA5String (ASCII))';break;case asn1.Type.UTCTIME:rval+=' (UTC time)';break;case asn1.Type.GENERALIZEDTIME:rval+=' (Generalized time)';break;case asn1.Type.BMPSTRING:rval+=' (BMP String)';break;}}else{rval+=obj.type;}rval+='\n';rval+=indent+'Constructed: '+obj.constructed+'\n';if(obj.composed){var subvalues=0;var sub='';for(var i=0;i<obj.value.length;++i){if(obj.value[i]!==undefined){subvalues+=1;sub+=asn1.prettyPrint(obj.value[i],level+1,indentation);if(i+1<obj.value.length){sub+=',';}}}rval+=indent+'Sub values: '+subvalues+sub;}else{rval+=indent+'Value: ';if(obj.type===asn1.Type.OID){var oid=asn1.derToOid(obj.value);rval+=oid;if(forge.pki&&forge.pki.oids){if(oid in forge.pki.oids){rval+=' ('+forge.pki.oids[oid]+') ';}}}if(obj.type===asn1.Type.INTEGER){try{rval+=asn1.derToInteger(obj.value);}catch(ex){rval+='0x'+forge.util.bytesToHex(obj.value);}}else if(obj.type===asn1.Type.BITSTRING){// TODO: shift bits as needed to display without padding
if(obj.value.length>1){// remove unused bits field
rval+='0x'+forge.util.bytesToHex(obj.value.slice(1));}else{rval+='(none)';}// show unused bit count
if(obj.value.length>0){var unused=obj.value.charCodeAt(0);if(unused==1){rval+=' (1 unused bit shown)';}else if(unused>1){rval+=' ('+unused+' unused bits shown)';}}}else if(obj.type===asn1.Type.OCTETSTRING){if(!_nonLatinRegex.test(obj.value)){rval+='('+obj.value+') ';}rval+='0x'+forge.util.bytesToHex(obj.value);}else if(obj.type===asn1.Type.UTF8){rval+=forge.util.decodeUtf8(obj.value);}else if(obj.type===asn1.Type.PRINTABLESTRING||obj.type===asn1.Type.IA5String){rval+=obj.value;}else if(_nonLatinRegex.test(obj.value)){rval+='0x'+forge.util.bytesToHex(obj.value);}else if(obj.value.length===0){rval+='[null]';}else{rval+=obj.value;}}return rval;};/***/},/* 3 */ /***/function(module,exports,__webpack_require__){/**
 * Object IDs for ASN.1.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);forge.pki=forge.pki||{};var oids=module.exports=forge.pki.oids=forge.oids=forge.oids||{};// set id to name mapping and name to id mapping
function _IN(id,name){oids[id]=name;oids[name]=id;}// set id to name mapping only
function _I_(id,name){oids[id]=name;}// algorithm OIDs
_IN('1.2.840.113549.1.1.1','rsaEncryption');// Note: md2 & md4 not implemented
//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');
//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');
_IN('1.2.840.113549.1.1.4','md5WithRSAEncryption');_IN('1.2.840.113549.1.1.5','sha1WithRSAEncryption');_IN('1.2.840.113549.1.1.7','RSAES-OAEP');_IN('1.2.840.113549.1.1.8','mgf1');_IN('1.2.840.113549.1.1.9','pSpecified');_IN('1.2.840.113549.1.1.10','RSASSA-PSS');_IN('1.2.840.113549.1.1.11','sha256WithRSAEncryption');_IN('1.2.840.113549.1.1.12','sha384WithRSAEncryption');_IN('1.2.840.113549.1.1.13','sha512WithRSAEncryption');_IN('1.2.840.10040.4.3','dsa-with-sha1');_IN('1.3.14.3.2.7','desCBC');_IN('1.3.14.3.2.26','sha1');_IN('2.16.840.1.101.3.4.2.1','sha256');_IN('2.16.840.1.101.3.4.2.2','sha384');_IN('2.16.840.1.101.3.4.2.3','sha512');_IN('1.2.840.113549.2.5','md5');// pkcs#7 content types
_IN('1.2.840.113549.1.7.1','data');_IN('1.2.840.113549.1.7.2','signedData');_IN('1.2.840.113549.1.7.3','envelopedData');_IN('1.2.840.113549.1.7.4','signedAndEnvelopedData');_IN('1.2.840.113549.1.7.5','digestedData');_IN('1.2.840.113549.1.7.6','encryptedData');// pkcs#9 oids
_IN('1.2.840.113549.1.9.1','emailAddress');_IN('1.2.840.113549.1.9.2','unstructuredName');_IN('1.2.840.113549.1.9.3','contentType');_IN('1.2.840.113549.1.9.4','messageDigest');_IN('1.2.840.113549.1.9.5','signingTime');_IN('1.2.840.113549.1.9.6','counterSignature');_IN('1.2.840.113549.1.9.7','challengePassword');_IN('1.2.840.113549.1.9.8','unstructuredAddress');_IN('1.2.840.113549.1.9.14','extensionRequest');_IN('1.2.840.113549.1.9.20','friendlyName');_IN('1.2.840.113549.1.9.21','localKeyId');_IN('1.2.840.113549.1.9.22.1','x509Certificate');// pkcs#12 safe bags
_IN('1.2.840.113549.1.12.10.1.1','keyBag');_IN('1.2.840.113549.1.12.10.1.2','pkcs8ShroudedKeyBag');_IN('1.2.840.113549.1.12.10.1.3','certBag');_IN('1.2.840.113549.1.12.10.1.4','crlBag');_IN('1.2.840.113549.1.12.10.1.5','secretBag');_IN('1.2.840.113549.1.12.10.1.6','safeContentsBag');// password-based-encryption for pkcs#12
_IN('1.2.840.113549.1.5.13','pkcs5PBES2');_IN('1.2.840.113549.1.5.12','pkcs5PBKDF2');_IN('1.2.840.113549.1.12.1.1','pbeWithSHAAnd128BitRC4');_IN('1.2.840.113549.1.12.1.2','pbeWithSHAAnd40BitRC4');_IN('1.2.840.113549.1.12.1.3','pbeWithSHAAnd3-KeyTripleDES-CBC');_IN('1.2.840.113549.1.12.1.4','pbeWithSHAAnd2-KeyTripleDES-CBC');_IN('1.2.840.113549.1.12.1.5','pbeWithSHAAnd128BitRC2-CBC');_IN('1.2.840.113549.1.12.1.6','pbewithSHAAnd40BitRC2-CBC');// hmac OIDs
_IN('1.2.840.113549.2.7','hmacWithSHA1');_IN('1.2.840.113549.2.8','hmacWithSHA224');_IN('1.2.840.113549.2.9','hmacWithSHA256');_IN('1.2.840.113549.2.10','hmacWithSHA384');_IN('1.2.840.113549.2.11','hmacWithSHA512');// symmetric key algorithm oids
_IN('1.2.840.113549.3.7','des-EDE3-CBC');_IN('2.16.840.1.101.3.4.1.2','aes128-CBC');_IN('2.16.840.1.101.3.4.1.22','aes192-CBC');_IN('2.16.840.1.101.3.4.1.42','aes256-CBC');// certificate issuer/subject OIDs
_IN('2.5.4.3','commonName');_IN('2.5.4.5','serialName');_IN('2.5.4.6','countryName');_IN('2.5.4.7','localityName');_IN('2.5.4.8','stateOrProvinceName');_IN('2.5.4.10','organizationName');_IN('2.5.4.11','organizationalUnitName');_IN('2.5.4.13','description');// X.509 extension OIDs
_IN('2.16.840.1.113730.1.1','nsCertType');_I_('2.5.29.1','authorityKeyIdentifier');// deprecated, use .35
_I_('2.5.29.2','keyAttributes');// obsolete use .37 or .15
_I_('2.5.29.3','certificatePolicies');// deprecated, use .32
_I_('2.5.29.4','keyUsageRestriction');// obsolete use .37 or .15
_I_('2.5.29.5','policyMapping');// deprecated use .33
_I_('2.5.29.6','subtreesConstraint');// obsolete use .30
_I_('2.5.29.7','subjectAltName');// deprecated use .17
_I_('2.5.29.8','issuerAltName');// deprecated use .18
_I_('2.5.29.9','subjectDirectoryAttributes');_I_('2.5.29.10','basicConstraints');// deprecated use .19
_I_('2.5.29.11','nameConstraints');// deprecated use .30
_I_('2.5.29.12','policyConstraints');// deprecated use .36
_I_('2.5.29.13','basicConstraints');// deprecated use .19
_IN('2.5.29.14','subjectKeyIdentifier');_IN('2.5.29.15','keyUsage');_I_('2.5.29.16','privateKeyUsagePeriod');_IN('2.5.29.17','subjectAltName');_IN('2.5.29.18','issuerAltName');_IN('2.5.29.19','basicConstraints');_I_('2.5.29.20','cRLNumber');_I_('2.5.29.21','cRLReason');_I_('2.5.29.22','expirationDate');_I_('2.5.29.23','instructionCode');_I_('2.5.29.24','invalidityDate');_I_('2.5.29.25','cRLDistributionPoints');// deprecated use .31
_I_('2.5.29.26','issuingDistributionPoint');// deprecated use .28
_I_('2.5.29.27','deltaCRLIndicator');_I_('2.5.29.28','issuingDistributionPoint');_I_('2.5.29.29','certificateIssuer');_I_('2.5.29.30','nameConstraints');_IN('2.5.29.31','cRLDistributionPoints');_IN('2.5.29.32','certificatePolicies');_I_('2.5.29.33','policyMappings');_I_('2.5.29.34','policyConstraints');// deprecated use .36
_IN('2.5.29.35','authorityKeyIdentifier');_I_('2.5.29.36','policyConstraints');_IN('2.5.29.37','extKeyUsage');_I_('2.5.29.46','freshestCRL');_I_('2.5.29.54','inhibitAnyPolicy');// extKeyUsage purposes
_IN('1.3.6.1.4.1.11129.2.4.2','timestampList');_IN('1.3.6.1.5.5.7.1.1','authorityInfoAccess');_IN('1.3.6.1.5.5.7.3.1','serverAuth');_IN('1.3.6.1.5.5.7.3.2','clientAuth');_IN('1.3.6.1.5.5.7.3.3','codeSigning');_IN('1.3.6.1.5.5.7.3.4','emailProtection');_IN('1.3.6.1.5.5.7.3.8','timeStamping');/***/},/* 4 */ /***/function(module,exports,__webpack_require__){/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);module.exports=forge.md=forge.md||{};forge.md.algorithms=forge.md.algorithms||{};/***/},/* 5 */ /***/function(module,exports,__webpack_require__){/**
 * An API for getting cryptographically-secure random bytes. The bytes are
 * generated using the Fortuna algorithm devised by Bruce Schneier and
 * Niels Ferguson.
 *
 * Getting strong random bytes is not yet easy to do in javascript. The only
 * truish random entropy that can be collected is from the mouse, keyboard, or
 * from timing with respect to page loads, etc. This generator makes a poor
 * attempt at providing random bytes when those sources haven't yet provided
 * enough entropy to initially seed or to reseed the PRNG.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2009-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(23);__webpack_require__(24);__webpack_require__(1);(function(){// forge.random already defined
if(forge.random&&forge.random.getBytes){module.exports=forge.random;return;}(function(jQuery){// the default prng plugin, uses AES-128
var prng_aes={};var _prng_aes_output=new Array(4);var _prng_aes_buffer=forge.util.createBuffer();prng_aes.formatKey=function(key){// convert the key into 32-bit integers
var tmp=forge.util.createBuffer(key);key=new Array(4);key[0]=tmp.getInt32();key[1]=tmp.getInt32();key[2]=tmp.getInt32();key[3]=tmp.getInt32();// return the expanded key
return forge.aes._expandKey(key,false);};prng_aes.formatSeed=function(seed){// convert seed into 32-bit integers
var tmp=forge.util.createBuffer(seed);seed=new Array(4);seed[0]=tmp.getInt32();seed[1]=tmp.getInt32();seed[2]=tmp.getInt32();seed[3]=tmp.getInt32();return seed;};prng_aes.cipher=function(key,seed){forge.aes._updateBlock(key,seed,_prng_aes_output,false);_prng_aes_buffer.putInt32(_prng_aes_output[0]);_prng_aes_buffer.putInt32(_prng_aes_output[1]);_prng_aes_buffer.putInt32(_prng_aes_output[2]);_prng_aes_buffer.putInt32(_prng_aes_output[3]);return _prng_aes_buffer.getBytes();};prng_aes.increment=function(seed){// FIXME: do we care about carry or signed issues?
++seed[3];return seed;};prng_aes.md=forge.md.sha256;/**
 * Creates a new PRNG.
 */function spawnPrng(){var ctx=forge.prng.create(prng_aes);/**
   * Gets random bytes. If a native secure crypto API is unavailable, this
   * method tries to make the bytes more unpredictable by drawing from data that
   * can be collected from the user of the browser, eg: mouse movement.
   *
   * If a callback is given, this method will be called asynchronously.
   *
   * @param count the number of random bytes to get.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return the random bytes in a string.
   */ctx.getBytes=function(count,callback){return ctx.generate(count,callback);};/**
   * Gets random bytes asynchronously. If a native secure crypto API is
   * unavailable, this method tries to make the bytes more unpredictable by
   * drawing from data that can be collected from the user of the browser,
   * eg: mouse movement.
   *
   * @param count the number of random bytes to get.
   *
   * @return the random bytes in a string.
   */ctx.getBytesSync=function(count){return ctx.generate(count);};return ctx;}// create default prng context
var _ctx=spawnPrng();// add other sources of entropy only if window.crypto.getRandomValues is not
// available -- otherwise this source will be automatically used by the prng
var getRandomValues=null;if(typeof window!=='undefined'){var _crypto=window.crypto||window.msCrypto;if(_crypto&&_crypto.getRandomValues){getRandomValues=function getRandomValues(arr){return _crypto.getRandomValues(arr);};}}if(forge.options.usePureJavaScript||!forge.util.isNodejs&&!getRandomValues){// if this is a web worker, do not use weak entropy, instead register to
// receive strong entropy asynchronously from the main thread
if(typeof window==='undefined'||window.document===undefined){}// FIXME:
// get load time entropy
_ctx.collectInt(+new Date(),32);// add some entropy from navigator object
if(typeof navigator!=='undefined'){var _navBytes='';for(var key in navigator){try{if(typeof navigator[key]=='string'){_navBytes+=navigator[key];}}catch(e){/* Some navigator keys might not be accessible, e.g. the geolocation
          attribute throws an exception if touched in Mozilla chrome://
          context.

          Silently ignore this and just don't use this as a source of
          entropy. */}}_ctx.collect(_navBytes);_navBytes=null;}// add mouse and keyboard collectors if jquery is available
if(jQuery){// set up mouse entropy capture
jQuery().mousemove(function(e){// add mouse coords
_ctx.collectInt(e.clientX,16);_ctx.collectInt(e.clientY,16);});// set up keyboard entropy capture
jQuery().keypress(function(e){_ctx.collectInt(e.charCode,8);});}}/* Random API */if(!forge.random){forge.random=_ctx;}else{// extend forge.random with _ctx
for(var key in _ctx){forge.random[key]=_ctx[key];}}// expose spawn PRNG
forge.random.createInstance=spawnPrng;module.exports=forge.random;})(typeof jQuery!=='undefined'?jQuery:null);})();/***/},/* 6 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of basic RSA algorithms.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The only algorithm currently supported for PKI is RSA.
 *
 * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo
 * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier
 * and a subjectPublicKey of type bit string.
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of RSA, there aren't any.
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm AlgorithmIdentifier,
 *   subjectPublicKey BIT STRING
 * }
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * For an RSA public key, the subjectPublicKey is:
 *
 * RSAPublicKey ::= SEQUENCE {
 *   modulus            INTEGER,    -- n
 *   publicExponent     INTEGER     -- e
 * }
 *
 * PrivateKeyInfo ::= SEQUENCE {
 *   version                   Version,
 *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
 *   privateKey                PrivateKey,
 *   attributes           [0]  IMPLICIT Attributes OPTIONAL
 * }
 *
 * Version ::= INTEGER
 * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
 * PrivateKey ::= OCTET STRING
 * Attributes ::= SET OF Attribute
 *
 * An RSA private key as the following structure:
 *
 * RSAPrivateKey ::= SEQUENCE {
 *   version Version,
 *   modulus INTEGER, -- n
 *   publicExponent INTEGER, -- e
 *   privateExponent INTEGER, -- d
 *   prime1 INTEGER, -- p
 *   prime2 INTEGER, -- q
 *   exponent1 INTEGER, -- d mod (p-1)
 *   exponent2 INTEGER, -- d mod (q-1)
 *   coefficient INTEGER -- (inverse of q) mod p
 * }
 *
 * Version ::= INTEGER
 *
 * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(16);__webpack_require__(3);__webpack_require__(26);__webpack_require__(27);__webpack_require__(5);__webpack_require__(1);if(typeof BigInteger==='undefined'){var BigInteger=forge.jsbn.BigInteger;}// shortcut for asn.1 API
var asn1=forge.asn1;/*
 * RSA encryption and decryption, see RFC 2313.
 */forge.pki=forge.pki||{};module.exports=forge.pki.rsa=forge.rsa=forge.rsa||{};var pki=forge.pki;// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA=[6,4,2,4,2,4,6,2];// validator for a PrivateKeyInfo structure
var privateKeyValidator={// PrivateKeyInfo
name:'PrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// Version (INTEGER)
name:'PrivateKeyInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyVersion'},{// privateKeyAlgorithm
name:'PrivateKeyInfo.privateKeyAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'privateKeyOid'}]},{// PrivateKey
name:'PrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'privateKey'}]};// validator for an RSA private key
var rsaPrivateKeyValidator={// RSAPrivateKey
name:'RSAPrivateKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// Version (INTEGER)
name:'RSAPrivateKey.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyVersion'},{// modulus (n)
name:'RSAPrivateKey.modulus',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyModulus'},{// publicExponent (e)
name:'RSAPrivateKey.publicExponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPublicExponent'},{// privateExponent (d)
name:'RSAPrivateKey.privateExponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrivateExponent'},{// prime1 (p)
name:'RSAPrivateKey.prime1',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrime1'},{// prime2 (q)
name:'RSAPrivateKey.prime2',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrime2'},{// exponent1 (d mod (p-1))
name:'RSAPrivateKey.exponent1',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyExponent1'},{// exponent2 (d mod (q-1))
name:'RSAPrivateKey.exponent2',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyExponent2'},{// coefficient ((inverse of q) mod p)
name:'RSAPrivateKey.coefficient',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyCoefficient'}]};// validator for an RSA public key
var rsaPublicKeyValidator={// RSAPublicKey
name:'RSAPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// modulus (n)
name:'RSAPublicKey.modulus',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'publicKeyModulus'},{// publicExponent (e)
name:'RSAPublicKey.exponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'publicKeyExponent'}]};// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator=forge.pki.rsa.publicKeyValidator={name:'SubjectPublicKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'subjectPublicKeyInfo',value:[{name:'SubjectPublicKeyInfo.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'publicKeyOid'}]},{// subjectPublicKey
name:'SubjectPublicKeyInfo.subjectPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,value:[{// RSAPublicKey
name:'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,captureAsn1:'rsaPublicKey'}]}]};/**
 * Wrap digest in DigestInfo object.
 *
 * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 * Digest ::= OCTET STRING
 *
 * @param md the message digest object with the hash to sign.
 *
 * @return the encoded message (ready for RSA encrytion)
 */var emsaPkcs1v15encode=function emsaPkcs1v15encode(md){// get the oid for the algorithm
var oid;if(md.algorithm in pki.oids){oid=pki.oids[md.algorithm];}else{var error=new Error('Unknown message digest algorithm.');error.algorithm=md.algorithm;throw error;}var oidBytes=asn1.oidToDer(oid).getBytes();// create the digest info
var digestInfo=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var digestAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,oidBytes));digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,''));var digest=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,md.digest().getBytes());digestInfo.value.push(digestAlgorithm);digestInfo.value.push(digest);// encode digest info
return asn1.toDer(digestInfo).getBytes();};/**
 * Performs x^c mod n (RSA encryption or decryption operation).
 *
 * @param x the number to raise and mod.
 * @param key the key to use.
 * @param pub true if the key is public, false if private.
 *
 * @return the result of x^c mod n.
 */var _modPow=function _modPow(x,key,pub){if(pub){return x.modPow(key.e,key.n);}if(!key.p||!key.q){// allow calculation without CRT params (slow)
return x.modPow(key.d,key.n);}// pre-compute dP, dQ, and qInv if necessary
if(!key.dP){key.dP=key.d.mod(key.p.subtract(BigInteger.ONE));}if(!key.dQ){key.dQ=key.d.mod(key.q.subtract(BigInteger.ONE));}if(!key.qInv){key.qInv=key.q.modInverse(key.p);}/* Chinese remainder theorem (CRT) states:

    Suppose n1, n2, ..., nk are positive integers which are pairwise
    coprime (n1 and n2 have no common factors other than 1). For any
    integers x1, x2, ..., xk there exists an integer x solving the
    system of simultaneous congruences (where ~= means modularly
    congruent so a ~= b mod n means a mod n = b mod n):

    x ~= x1 mod n1
    x ~= x2 mod n2
    ...
    x ~= xk mod nk

    This system of congruences has a single simultaneous solution x
    between 0 and n - 1. Furthermore, each xk solution and x itself
    is congruent modulo the product n = n1*n2*...*nk.
    So x1 mod n = x2 mod n = xk mod n = x mod n.

    The single simultaneous solution x can be solved with the following
    equation:

    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.

    Where x is less than n, xi = x mod ni.

    For RSA we are only concerned with k = 2. The modulus n = pq, where
    p and q are coprime. The RSA decryption algorithm is:

    y = x^d mod n

    Given the above:

    x1 = x^d mod p
    r1 = n/p = q
    s1 = q^-1 mod p
    x2 = x^d mod q
    r2 = n/q = p
    s2 = p^-1 mod q

    So y = (x1r1s1 + x2r2s2) mod n
         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n

    According to Fermat's Little Theorem, if the modulus P is prime,
    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.
    Since A is not divisible by P it follows that if:
    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:

    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort
    to calculate). In order to calculate x^d mod p more quickly the
    exponent d mod (p - 1) is stored in the RSA private key (the same
    is done for x^d mod q). These values are referred to as dP and dQ
    respectively. Therefore we now have:

    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n

    Since we'll be reducing x^dP by modulo p (same for q) we can also
    reduce x by p (and q respectively) before hand. Therefore, let

    xp = ((x mod p)^dP mod p), and
    xq = ((x mod q)^dQ mod q), yielding:

    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n

    This can be further reduced to a simple algorithm that only
    requires 1 inverse (the q inverse is used) to be used and stored.
    The algorithm is called Garner's algorithm. If qInv is the
    inverse of q, we simply calculate:

    y = (qInv*(xp - xq) mod p) * q + xq

    However, there are two further complications. First, we need to
    ensure that xp > xq to prevent signed BigIntegers from being used
    so we add p until this is true (since we will be mod'ing with
    p anyway). Then, there is a known timing attack on algorithms
    using the CRT. To mitigate this risk, "cryptographic blinding"
    should be used. This requires simply generating a random number r
    between 0 and n-1 and its inverse and multiplying x by r^e before
    calculating y and then multiplying y by r^-1 afterwards. Note that
    r must be coprime with n (gcd(r, n) === 1) in order to have an
    inverse.
  */ // cryptographic blinding
var r;do{r=new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength()/8)),16);}while(r.compareTo(key.n)>=0||!r.gcd(key.n).equals(BigInteger.ONE));x=x.multiply(r.modPow(key.e,key.n)).mod(key.n);// calculate xp and xq
var xp=x.mod(key.p).modPow(key.dP,key.p);var xq=x.mod(key.q).modPow(key.dQ,key.q);// xp must be larger than xq to avoid signed bit usage
while(xp.compareTo(xq)<0){xp=xp.add(key.p);}// do last step
var y=xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);// remove effect of random for cryptographic blinding
y=y.multiply(r.modInverse(key.n)).mod(key.n);return y;};/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or
 * 'encrypt' on a public key object instead.
 *
 * Performs RSA encryption.
 *
 * The parameter bt controls whether to put padding bytes before the
 * message passed in. Set bt to either true or false to disable padding
 * completely (in order to handle e.g. EMSA-PSS encoding seperately before),
 * signaling whether the encryption operation is a public key operation
 * (i.e. encrypting data) or not, i.e. private key operation (data signing).
 *
 * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01
 * (for signing) or 0x02 (for encryption). The key operation mode (private
 * or public) is derived from this flag in that case).
 *
 * @param m the message to encrypt as a byte string.
 * @param key the RSA key to use.
 * @param bt for PKCS#1 v1.5 padding, the block type to use
 *   (0x01 for private key, 0x02 for public),
 *   to disable padding: true = public key, false = private key.
 *
 * @return the encrypted bytes as a string.
 */pki.rsa.encrypt=function(m,key,bt){var pub=bt;var eb;// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);if(bt!==false&&bt!==true){// legacy, default to PKCS#1 v1.5 padding
pub=bt===0x02;eb=_encodePkcs1_v1_5(m,key,bt);}else{eb=forge.util.createBuffer();eb.putBytes(m);}// load encryption block as big integer 'x'
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var x=new BigInteger(eb.toHex(),16);// do RSA encryption
var y=_modPow(x,key,pub);// convert y into the encrypted data byte string, if y is shorter in
// bytes than k, then prepend zero bytes to fill up ed
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var yhex=y.toString(16);var ed=forge.util.createBuffer();var zeros=k-Math.ceil(yhex.length/2);while(zeros>0){ed.putByte(0x00);--zeros;}ed.putBytes(forge.util.hexToBytes(yhex));return ed.getBytes();};/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or
 * 'verify' on a public key object instead.
 *
 * Performs RSA decryption.
 *
 * The parameter ml controls whether to apply PKCS#1 v1.5 padding
 * or not.  Set ml = false to disable padding removal completely
 * (in order to handle e.g. EMSA-PSS later on) and simply pass back
 * the RSA encryption block.
 *
 * @param ed the encrypted data to decrypt in as a byte string.
 * @param key the RSA key to use.
 * @param pub true for a public key operation, false for private.
 * @param ml the message length, if known, false to disable padding.
 *
 * @return the decrypted message as a byte string.
 */pki.rsa.decrypt=function(ed,key,pub,ml){// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);// error if the length of the encrypted data ED is not k
if(ed.length!==k){var error=new Error('Encrypted message length is invalid.');error.length=ed.length;error.expected=k;throw error;}// convert encrypted data into a big integer
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var y=new BigInteger(forge.util.createBuffer(ed).toHex(),16);// y must be less than the modulus or it wasn't the result of
// a previous mod operation (encryption) using that modulus
if(y.compareTo(key.n)>=0){throw new Error('Encrypted message is invalid.');}// do RSA decryption
var x=_modPow(y,key,pub);// create the encryption block, if x is shorter in bytes than k, then
// prepend zero bytes to fill up eb
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var xhex=x.toString(16);var eb=forge.util.createBuffer();var zeros=k-Math.ceil(xhex.length/2);while(zeros>0){eb.putByte(0x00);--zeros;}eb.putBytes(forge.util.hexToBytes(xhex));if(ml!==false){// legacy, default to PKCS#1 v1.5 padding
return _decodePkcs1_v1_5(eb.getBytes(),key,pub);}// return message
return eb.getBytes();};/**
 * Creates an RSA key-pair generation state object. It is used to allow
 * key-generation to be performed in steps. It also allows for a UI to
 * display progress updates.
 *
 * @param bits the size for the private key in bits, defaults to 2048.
 * @param e the public exponent to use, defaults to 65537 (0x10001).
 * @param [options] the options to use.
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 *
 * @return the state object to use to generate the key-pair.
 */pki.rsa.createKeyPairGenerationState=function(bits,e,options){// TODO: migrate step-based prime generation code to forge.prime
// set default bits
if(typeof bits==='string'){bits=parseInt(bits,10);}bits=bits||2048;// create prng with api that matches BigInteger secure random
options=options||{};var prng=options.prng||forge.random;var rng={// x is an array to fill with bytes
nextBytes:function nextBytes(x){var b=prng.getBytesSync(x.length);for(var i=0;i<x.length;++i){x[i]=b.charCodeAt(i);}}};var algorithm=options.algorithm||'PRIMEINC';// create PRIMEINC algorithm state
var rval;if(algorithm==='PRIMEINC'){rval={algorithm:algorithm,state:0,bits:bits,rng:rng,eInt:e||65537,e:new BigInteger(null),p:null,q:null,qBits:bits>>1,pBits:bits-(bits>>1),pqState:0,num:null,keys:null};rval.e.fromInt(rval.eInt);}else{throw new Error('Invalid key generation algorithm: '+algorithm);}return rval;};/**
 * Attempts to runs the key-generation algorithm for at most n seconds
 * (approximately) using the given state. When key-generation has completed,
 * the keys will be stored in state.keys.
 *
 * To use this function to update a UI while generating a key or to prevent
 * causing browser lockups/warnings, set "n" to a value other than 0. A
 * simple pattern for generating a key and showing a progress indicator is:
 *
 * var state = pki.rsa.createKeyPairGenerationState(2048);
 * var step = function() {
 *   // step key-generation, run algorithm for 100 ms, repeat
 *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {
 *     setTimeout(step, 1);
 *   } else {
 *     // key-generation complete
 *     // TODO: turn off progress indicator here
 *     // TODO: use the generated key-pair in "state.keys"
 *   }
 * };
 * // TODO: turn on progress indicator here
 * setTimeout(step, 0);
 *
 * @param state the state to use.
 * @param n the maximum number of milliseconds to run the algorithm for, 0
 *          to run the algorithm to completion.
 *
 * @return true if the key-generation completed, false if not.
 */pki.rsa.stepKeyPairGenerationState=function(state,n){// set default algorithm if not set
if(!('algorithm'in state)){state.algorithm='PRIMEINC';}// TODO: migrate step-based prime generation code to forge.prime
// TODO: abstract as PRIMEINC algorithm
// do key generation (based on Tom Wu's rsa.js, see jsbn.js license)
// with some minor optimizations and designed to run in steps
// local state vars
var THIRTY=new BigInteger(null);THIRTY.fromInt(30);var deltaIdx=0;var op_or=function op_or(x,y){return x|y;};// keep stepping until time limit is reached or done
var t1=+new Date();var t2;var total=0;while(state.keys===null&&(n<=0||total<n)){// generate p or q
if(state.state===0){/* Note: All primes are of the form:

        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i

        When we generate a random number, we always align it at 30k + 1. Each
        time the number is determined not to be prime we add to get to the
        next 'i', eg: if the number was at 30k + 1 we add 6. */var bits=state.p===null?state.pBits:state.qBits;var bits1=bits-1;// get a random number
if(state.pqState===0){state.num=new BigInteger(bits,state.rng);// force MSB set
if(!state.num.testBit(bits1)){state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1),op_or,state.num);}// align number on 30k+1 boundary
state.num.dAddOffset(31-state.num.mod(THIRTY).byteValue(),0);deltaIdx=0;++state.pqState;}else if(state.pqState===1){// try to make the number a prime
if(state.num.bitLength()>bits){// overflow, try again
state.pqState=0;// do primality test
}else if(state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))){++state.pqState;}else{// get next potential prime
state.num.dAddOffset(GCD_30_DELTA[deltaIdx++%8],0);}}else if(state.pqState===2){// ensure number is coprime with e
state.pqState=state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)===0?3:0;}else if(state.pqState===3){// store p or q
state.pqState=0;if(state.p===null){state.p=state.num;}else{state.q=state.num;}// advance state if both p and q are ready
if(state.p!==null&&state.q!==null){++state.state;}state.num=null;}}else if(state.state===1){// ensure p is larger than q (swap them if not)
if(state.p.compareTo(state.q)<0){state.num=state.p;state.p=state.q;state.q=state.num;}++state.state;}else if(state.state===2){// compute phi: (p - 1)(q - 1) (Euler's totient function)
state.p1=state.p.subtract(BigInteger.ONE);state.q1=state.q.subtract(BigInteger.ONE);state.phi=state.p1.multiply(state.q1);++state.state;}else if(state.state===3){// ensure e and phi are coprime
if(state.phi.gcd(state.e).compareTo(BigInteger.ONE)===0){// phi and e are coprime, advance
++state.state;}else{// phi and e aren't coprime, so generate a new p and q
state.p=null;state.q=null;state.state=0;}}else if(state.state===4){// create n, ensure n is has the right number of bits
state.n=state.p.multiply(state.q);// ensure n is right number of bits
if(state.n.bitLength()===state.bits){// success, advance
++state.state;}else{// failed, get new q
state.q=null;state.state=0;}}else if(state.state===5){// set keys
var d=state.e.modInverse(state.phi);state.keys={privateKey:pki.rsa.setPrivateKey(state.n,state.e,d,state.p,state.q,d.mod(state.p1),d.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)};}// update timing
t2=+new Date();total+=t2-t1;t1=t2;}return state.keys!==null;};/**
 * Generates an RSA public-private key pair in a single call.
 *
 * To generate a key-pair in steps (to allow for progress updates and to
 * prevent blocking or warnings in slow browsers) then use the key-pair
 * generation state functions.
 *
 * To generate a key-pair asynchronously (either through web-workers, if
 * available, or by breaking up the work on the main thread), pass a
 * callback function.
 *
 * @param [bits] the size for the private key in bits, defaults to 2048.
 * @param [e] the public exponent to use, defaults to 65537.
 * @param [options] options for key-pair generation, if given then 'bits'
 *          and 'e' must *not* be given:
 *          bits the size for the private key in bits, (default: 2048).
 *          e the public exponent to use, (default: 65537 (0x10001)).
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 * @param [callback(err, keypair)] called once the operation completes.
 *
 * @return an object with privateKey and publicKey properties.
 */pki.rsa.generateKeyPair=function(bits,e,options,callback){// (bits), (options), (callback)
if(arguments.length===1){if(_typeof(bits)==='object'){options=bits;bits=undefined;}else if(typeof bits==='function'){callback=bits;bits=undefined;}}else if(arguments.length===2){// (bits, e), (bits, options), (bits, callback), (options, callback)
if(typeof bits==='number'){if(typeof e==='function'){callback=e;e=undefined;}else if(typeof e!=='number'){options=e;e=undefined;}}else{options=bits;callback=e;bits=undefined;e=undefined;}}else if(arguments.length===3){// (bits, e, options), (bits, e, callback), (bits, options, callback)
if(typeof e==='number'){if(typeof options==='function'){callback=options;options=undefined;}}else{callback=options;options=e;e=undefined;}}options=options||{};if(bits===undefined){bits=options.bits||2048;}if(e===undefined){e=options.e||0x10001;}// if native code is permitted and a callback is given, use native
// key generation code if available and if parameters are acceptable
if(!forge.options.usePureJavaScript&&callback&&bits>=256&&bits<=16384&&(e===0x10001||e===3)){if(_detectSubtleCrypto('generateKey')&&_detectSubtleCrypto('exportKey')){// use standard native generateKey
return window.crypto.subtle.generateKey({name:'RSASSA-PKCS1-v1_5',modulusLength:bits,publicExponent:_intToUint8Array(e),hash:{name:'SHA-256'}},true/* key can be exported*/,['sign','verify']).then(function(pair){return window.crypto.subtle.exportKey('pkcs8',pair.privateKey);// avoiding catch(function(err) {...}) to support IE <= 8
}).then(undefined,function(err){callback(err);}).then(function(pkcs8){if(pkcs8){var privateKey=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));callback(null,{privateKey:privateKey,publicKey:pki.setRsaPublicKey(privateKey.n,privateKey.e)});}});}if(_detectSubtleMsCrypto('generateKey')&&_detectSubtleMsCrypto('exportKey')){var genOp=window.msCrypto.subtle.generateKey({name:'RSASSA-PKCS1-v1_5',modulusLength:bits,publicExponent:_intToUint8Array(e),hash:{name:'SHA-256'}},true/* key can be exported*/,['sign','verify']);genOp.oncomplete=function(e){var pair=e.target.result;var exportOp=window.msCrypto.subtle.exportKey('pkcs8',pair.privateKey);exportOp.oncomplete=function(e){var pkcs8=e.target.result;var privateKey=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));callback(null,{privateKey:privateKey,publicKey:pki.setRsaPublicKey(privateKey.n,privateKey.e)});};exportOp.onerror=function(err){callback(err);};};genOp.onerror=function(err){callback(err);};return;}}// use JavaScript implementation
var state=pki.rsa.createKeyPairGenerationState(bits,e,options);if(!callback){pki.rsa.stepKeyPairGenerationState(state,0);return state.keys;}_generateKeyPair(state,options,callback);};/**
 * Sets an RSA public key from BigIntegers modulus and exponent.
 *
 * @param n the modulus.
 * @param e the exponent.
 *
 * @return the public key.
 */pki.setRsaPublicKey=pki.rsa.setPublicKey=function(n,e){var key={n:n,e:e};/**
   * Encrypts the given data with this public key. Newer applications
   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
   * legacy applications.
   *
   * @param data the byte string to encrypt.
   * @param scheme the encryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA encryption,
   *          an object with an 'encode' property set to a function
   *          with the signature 'function(data, key)' that returns
   *          a binary-encoded string representing the encoded data.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the encrypted byte string.
   */key.encrypt=function(data,scheme,schemeOptions){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSAES-PKCS1-V1_5';}if(scheme==='RSAES-PKCS1-V1_5'){scheme={encode:function encode(m,key,pub){return _encodePkcs1_v1_5(m,key,0x02).getBytes();}};}else if(scheme==='RSA-OAEP'||scheme==='RSAES-OAEP'){scheme={encode:function encode(m,key){return forge.pkcs1.encode_rsa_oaep(key,m,schemeOptions);}};}else if(['RAW','NONE','NULL',null].indexOf(scheme)!==-1){scheme={encode:function encode(e){return e;}};}else if(typeof scheme==='string'){throw new Error('Unsupported encryption scheme: "'+scheme+'".');}// do scheme-based encoding then rsa encryption
var e=scheme.encode(data,key,true);return pki.rsa.encrypt(e,key,true);};/**
   * Verifies the given signature against the given digest.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
   * signature is an OCTET STRING that holds a DigestInfo.
   *
   * DigestInfo ::= SEQUENCE {
   *   digestAlgorithm DigestAlgorithmIdentifier,
   *   digest Digest
   * }
   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
   * Digest ::= OCTET STRING
   *
   * To perform PSS signature verification, provide an instance
   * of Forge PSS object as the scheme parameter.
   *
   * @param digest the message digest hash to compare against the signature,
   *          as a binary-encoded string.
   * @param signature the signature to verify, as a binary-encoded string.
   * @param scheme signature verification scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be expected, but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return true if the signature was verified, false if not.
   */key.verify=function(digest,signature,scheme){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSASSA-PKCS1-V1_5';}if(scheme==='RSASSA-PKCS1-V1_5'){scheme={verify:function verify(digest,d){// remove padding
d=_decodePkcs1_v1_5(d,key,true);// d is ASN.1 BER-encoded DigestInfo
var obj=asn1.fromDer(d);// compare the given digest to the decrypted one
return digest===obj.value[1].value;}};}else if(scheme==='NONE'||scheme==='NULL'||scheme===null){scheme={verify:function verify(digest,d){// remove padding
d=_decodePkcs1_v1_5(d,key,true);return digest===d;}};}// do rsa decryption w/o any decoding, then verify -- which does decoding
var d=pki.rsa.decrypt(signature,key,true,false);return scheme.verify(digest,d,key.n.bitLength());};return key;};/**
 * Sets an RSA private key from BigIntegers modulus, exponent, primes,
 * prime exponents, and modular multiplicative inverse.
 *
 * @param n the modulus.
 * @param e the public exponent.
 * @param d the private exponent ((inverse of e) mod n).
 * @param p the first prime.
 * @param q the second prime.
 * @param dP exponent1 (d mod (p-1)).
 * @param dQ exponent2 (d mod (q-1)).
 * @param qInv ((inverse of q) mod p)
 *
 * @return the private key.
 */pki.setRsaPrivateKey=pki.rsa.setPrivateKey=function(n,e,d,p,q,dP,dQ,qInv){var key={n:n,e:e,d:d,p:p,q:q,dP:dP,dQ:dQ,qInv:qInv};/**
   * Decrypts the given data with this private key. The decryption scheme
   * must match the one used to encrypt the data.
   *
   * @param data the byte string to decrypt.
   * @param scheme the decryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA decryption.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the decrypted byte string.
   */key.decrypt=function(data,scheme,schemeOptions){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSAES-PKCS1-V1_5';}// do rsa decryption w/o any decoding
var d=pki.rsa.decrypt(data,key,false,false);if(scheme==='RSAES-PKCS1-V1_5'){scheme={decode:_decodePkcs1_v1_5};}else if(scheme==='RSA-OAEP'||scheme==='RSAES-OAEP'){scheme={decode:function decode(d,key){return forge.pkcs1.decode_rsa_oaep(key,d,schemeOptions);}};}else if(['RAW','NONE','NULL',null].indexOf(scheme)!==-1){scheme={decode:function decode(d){return d;}};}else{throw new Error('Unsupported encryption scheme: "'+scheme+'".');}// decode according to scheme
return scheme.decode(d,key,false);};/**
   * Signs the given digest, producing a signature.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
   * an instance of Forge PSS object as the scheme parameter.
   *
   * @param md the message digest object with the hash to sign.
   * @param scheme the signature scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be used but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return the signature as a byte string.
   */key.sign=function(md,scheme){/* Note: The internal implementation of RSA operations is being
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy
      code like the use of an encoding block identifier 'bt' will eventually
      be removed. */ // private key operation
var bt=false;if(typeof scheme==='string'){scheme=scheme.toUpperCase();}if(scheme===undefined||scheme==='RSASSA-PKCS1-V1_5'){scheme={encode:emsaPkcs1v15encode};bt=0x01;}else if(scheme==='NONE'||scheme==='NULL'||scheme===null){scheme={encode:function encode(){return md;}};bt=0x01;}// encode and then encrypt
var d=scheme.encode(md,key.n.bitLength());return pki.rsa.encrypt(d,key,bt);};return key;};/**
 * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.
 *
 * @param rsaKey the ASN.1 RSAPrivateKey.
 *
 * @return the ASN.1 PrivateKeyInfo.
 */pki.wrapRsaPrivateKey=function(rsaKey){// PrivateKeyInfo
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (0)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(0).getBytes()),// privateKeyAlgorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// PrivateKey
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(rsaKey).getBytes())]);};/**
 * Converts a private key from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a PrivateKeyInfo containing an
 *          RSAPrivateKey or an RSAPrivateKey.
 *
 * @return the private key.
 */pki.privateKeyFromAsn1=function(obj){// get PrivateKeyInfo
var capture={};var errors=[];if(asn1.validate(obj,privateKeyValidator,capture,errors)){obj=asn1.fromDer(forge.util.createBuffer(capture.privateKey));}// get RSAPrivateKey
capture={};errors=[];if(!asn1.validate(obj,rsaPrivateKeyValidator,capture,errors)){var error=new Error('Cannot read private key. '+'ASN.1 object does not contain an RSAPrivateKey.');error.errors=errors;throw error;}// Note: Version is currently ignored.
// capture.privateKeyVersion
// FIXME: inefficient, get a BigInteger that uses byte strings
var n,e,d,p,q,dP,dQ,qInv;n=forge.util.createBuffer(capture.privateKeyModulus).toHex();e=forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();d=forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();p=forge.util.createBuffer(capture.privateKeyPrime1).toHex();q=forge.util.createBuffer(capture.privateKeyPrime2).toHex();dP=forge.util.createBuffer(capture.privateKeyExponent1).toHex();dQ=forge.util.createBuffer(capture.privateKeyExponent2).toHex();qInv=forge.util.createBuffer(capture.privateKeyCoefficient).toHex();// set private key
return pki.setRsaPrivateKey(new BigInteger(n,16),new BigInteger(e,16),new BigInteger(d,16),new BigInteger(p,16),new BigInteger(q,16),new BigInteger(dP,16),new BigInteger(dQ,16),new BigInteger(qInv,16));};/**
 * Converts a private key to an ASN.1 RSAPrivateKey.
 *
 * @param key the private key.
 *
 * @return the ASN.1 representation of an RSAPrivateKey.
 */pki.privateKeyToAsn1=pki.privateKeyToRSAPrivateKey=function(key){// RSAPrivateKey
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (0 = only 2 primes, 1 multiple primes)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(0).getBytes()),// modulus (n)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.n)),// publicExponent (e)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.e)),// privateExponent (d)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.d)),// privateKeyPrime1 (p)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.p)),// privateKeyPrime2 (q)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.q)),// privateKeyExponent1 (dP)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.dP)),// privateKeyExponent2 (dQ)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.dQ)),// coefficient (qInv)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.qInv))]);};/**
 * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @return the public key.
 */pki.publicKeyFromAsn1=function(obj){// get SubjectPublicKeyInfo
var capture={};var errors=[];if(asn1.validate(obj,publicKeyValidator,capture,errors)){// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){var error=new Error('Cannot read public key. Unknown OID.');error.oid=oid;throw error;}obj=capture.rsaPublicKey;}// get RSA params
errors=[];if(!asn1.validate(obj,rsaPublicKeyValidator,capture,errors)){var error=new Error('Cannot read public key. '+'ASN.1 object does not contain an RSAPublicKey.');error.errors=errors;throw error;}// FIXME: inefficient, get a BigInteger that uses byte strings
var n=forge.util.createBuffer(capture.publicKeyModulus).toHex();var e=forge.util.createBuffer(capture.publicKeyExponent).toHex();// set public key
return pki.setRsaPublicKey(new BigInteger(n,16),new BigInteger(e,16));};/**
 * Converts a public key to an ASN.1 SubjectPublicKeyInfo.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a SubjectPublicKeyInfo.
 */pki.publicKeyToAsn1=pki.publicKeyToSubjectPublicKeyInfo=function(key){// SubjectPublicKeyInfo
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AlgorithmIdentifier
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),// parameters (null)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// subjectPublicKey
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,[pki.publicKeyToRSAPublicKey(key)])]);};/**
 * Converts a public key to an ASN.1 RSAPublicKey.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a RSAPublicKey.
 */pki.publicKeyToRSAPublicKey=function(key){// RSAPublicKey
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// modulus (n)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.n)),// publicExponent (e)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.e))]);};/**
 * Encodes a message using PKCS#1 v1.5 padding.
 *
 * @param m the message to encode.
 * @param key the RSA key to use.
 * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02
 *          (for encryption).
 *
 * @return the padded byte buffer.
 */function _encodePkcs1_v1_5(m,key,bt){var eb=forge.util.createBuffer();// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);/* use PKCS#1 v1.5 padding */if(m.length>k-11){var error=new Error('Message is too long for PKCS#1 v1.5 padding.');error.length=m.length;error.max=k-11;throw error;}/* A block type BT, a padding string PS, and the data D shall be
    formatted into an octet string EB, the encryption block:

    EB = 00 || BT || PS || 00 || D

    The block type BT shall be a single octet indicating the structure of
    the encryption block. For this version of the document it shall have
    value 00, 01, or 02. For a private-key operation, the block type
    shall be 00 or 01. For a public-key operation, it shall be 02.

    The padding string PS shall consist of k-3-||D|| octets. For block
    type 00, the octets shall have value 00; for block type 01, they
    shall have value FF; and for block type 02, they shall be
    pseudorandomly generated and nonzero. This makes the length of the
    encryption block EB equal to k. */ // build the encryption block
eb.putByte(0x00);eb.putByte(bt);// create the padding
var padNum=k-3-m.length;var padByte;// private key op
if(bt===0x00||bt===0x01){padByte=bt===0x00?0x00:0xFF;for(var i=0;i<padNum;++i){eb.putByte(padByte);}}else{// public key op
// pad with random non-zero values
while(padNum>0){var numZeros=0;var padBytes=forge.random.getBytes(padNum);for(var i=0;i<padNum;++i){padByte=padBytes.charCodeAt(i);if(padByte===0){++numZeros;}else{eb.putByte(padByte);}}padNum=numZeros;}}// zero followed by message
eb.putByte(0x00);eb.putBytes(m);return eb;}/**
 * Decodes a message using PKCS#1 v1.5 padding.
 *
 * @param em the message to decode.
 * @param key the RSA key to use.
 * @param pub true if the key is a public key, false if it is private.
 * @param ml the message length, if specified.
 *
 * @return the decoded bytes.
 */function _decodePkcs1_v1_5(em,key,pub,ml){// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);/* It is an error if any of the following conditions occurs:

    1. The encryption block EB cannot be parsed unambiguously.
    2. The padding string PS consists of fewer than eight octets
      or is inconsisent with the block type BT.
    3. The decryption process is a public-key operation and the block
      type BT is not 00 or 01, or the decryption process is a
      private-key operation and the block type is not 02.
   */ // parse the encryption block
var eb=forge.util.createBuffer(em);var first=eb.getByte();var bt=eb.getByte();if(first!==0x00||pub&&bt!==0x00&&bt!==0x01||!pub&&bt!=0x02||pub&&bt===0x00&&typeof ml==='undefined'){throw new Error('Encryption block is invalid.');}var padNum=0;if(bt===0x00){// check all padding bytes for 0x00
padNum=k-3-ml;for(var i=0;i<padNum;++i){if(eb.getByte()!==0x00){throw new Error('Encryption block is invalid.');}}}else if(bt===0x01){// find the first byte that isn't 0xFF, should be after all padding
padNum=0;while(eb.length()>1){if(eb.getByte()!==0xFF){--eb.read;break;}++padNum;}}else if(bt===0x02){// look for 0x00 byte
padNum=0;while(eb.length()>1){if(eb.getByte()===0x00){--eb.read;break;}++padNum;}}// zero must be 0x00 and padNum must be (k - 3 - message length)
var zero=eb.getByte();if(zero!==0x00||padNum!==k-3-eb.length()){throw new Error('Encryption block is invalid.');}return eb.getBytes();}/**
 * Runs the key-generation algorithm asynchronously, either in the background
 * via Web Workers, or using the main thread and setImmediate.
 *
 * @param state the key-pair generation state.
 * @param [options] options for key-pair generation:
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2, -1 to use estimated cores minus one).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 * @param callback(err, keypair) called once the operation completes.
 */function _generateKeyPair(state,options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};var opts={algorithm:{name:options.algorithm||'PRIMEINC',options:{workers:options.workers||2,workLoad:options.workLoad||100,workerScript:options.workerScript}}};if('prng'in options){opts.prng=options.prng;}generate();function generate(){// find p and then q (done in series to simplify)
getPrime(state.pBits,function(err,num){if(err){return callback(err);}state.p=num;if(state.q!==null){return finish(err,state.q);}getPrime(state.qBits,finish);});}function getPrime(bits,callback){forge.prime.generateProbablePrime(bits,opts,callback);}function finish(err,num){if(err){return callback(err);}// set q
state.q=num;// ensure p is larger than q (swap them if not)
if(state.p.compareTo(state.q)<0){var tmp=state.p;state.p=state.q;state.q=tmp;}// ensure p is coprime with e
if(state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)!==0){state.p=null;generate();return;}// ensure q is coprime with e
if(state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)!==0){state.q=null;getPrime(state.qBits,finish);return;}// compute phi: (p - 1)(q - 1) (Euler's totient function)
state.p1=state.p.subtract(BigInteger.ONE);state.q1=state.q.subtract(BigInteger.ONE);state.phi=state.p1.multiply(state.q1);// ensure e and phi are coprime
if(state.phi.gcd(state.e).compareTo(BigInteger.ONE)!==0){// phi and e aren't coprime, so generate a new p and q
state.p=state.q=null;generate();return;}// create n, ensure n is has the right number of bits
state.n=state.p.multiply(state.q);if(state.n.bitLength()!==state.bits){// failed, get new q
state.q=null;getPrime(state.qBits,finish);return;}// set keys
var d=state.e.modInverse(state.phi);state.keys={privateKey:pki.rsa.setPrivateKey(state.n,state.e,d,state.p,state.q,d.mod(state.p1),d.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)};callback(null,state.keys);}}/**
 * Converts a positive BigInteger into 2's-complement big-endian bytes.
 *
 * @param b the big integer to convert.
 *
 * @return the bytes.
 */function _bnToBytes(b){// prepend 0x00 if first byte >= 0x80
var hex=b.toString(16);if(hex[0]>='8'){hex='00'+hex;}var bytes=forge.util.hexToBytes(hex);// ensure integer is minimally-encoded
if(bytes.length>1&&(// leading 0x00 for positive integer
bytes.charCodeAt(0)===0&&(bytes.charCodeAt(1)&0x80)===0||// leading 0xFF for negative integer
bytes.charCodeAt(0)===0xFF&&(bytes.charCodeAt(1)&0x80)===0x80)){return bytes.substr(1);}return bytes;}/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */function _getMillerRabinTests(bits){if(bits<=100)return 27;if(bits<=150)return 18;if(bits<=200)return 15;if(bits<=250)return 12;if(bits<=300)return 9;if(bits<=350)return 8;if(bits<=400)return 7;if(bits<=500)return 6;if(bits<=600)return 5;if(bits<=800)return 4;if(bits<=1250)return 3;return 2;}/**
 * Performs feature detection on the SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */function _detectSubtleCrypto(fn){return typeof window!=='undefined'&&_typeof(window.crypto)==='object'&&_typeof(window.crypto.subtle)==='object'&&typeof window.crypto.subtle[fn]==='function';}/**
 * Performs feature detection on the deprecated Microsoft Internet Explorer
 * outdated SubtleCrypto interface. This function should only be used after
 * checking for the modern, standard SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */function _detectSubtleMsCrypto(fn){return typeof window!=='undefined'&&_typeof(window.msCrypto)==='object'&&_typeof(window.msCrypto.subtle)==='object'&&typeof window.msCrypto.subtle[fn]==='function';}function _intToUint8Array(x){var bytes=forge.util.hexToBytes(x.toString(16));var buffer=new Uint8Array(bytes.length);for(var i=0;i<bytes.length;++i){buffer[i]=bytes.charCodeAt(i);}return buffer;}function _privateKeyFromJwk(jwk){if(jwk.kty!=='RSA'){throw new Error('Unsupported key algorithm "'+jwk.kty+'"; algorithm must be "RSA".');}return pki.setRsaPrivateKey(_base64ToBigInt(jwk.n),_base64ToBigInt(jwk.e),_base64ToBigInt(jwk.d),_base64ToBigInt(jwk.p),_base64ToBigInt(jwk.q),_base64ToBigInt(jwk.dp),_base64ToBigInt(jwk.dq),_base64ToBigInt(jwk.qi));}function _publicKeyFromJwk(jwk){if(jwk.kty!=='RSA'){throw new Error('Key algorithm must be "RSA".');}return pki.setRsaPublicKey(_base64ToBigInt(jwk.n),_base64ToBigInt(jwk.e));}function _base64ToBigInt(b64){return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)),16);}/***/},/* 7 */ /***/function(module,exports,__webpack_require__){/**
 * Advanced Encryption Standard (AES) implementation.
 *
 * This implementation is based on the public domain library 'jscrypto' which
 * was written by:
 *
 * Emily Stark (estark@stanford.edu)
 * Mike Hamburg (mhamburg@stanford.edu)
 * Dan Boneh (dabo@cs.stanford.edu)
 *
 * Parts of this code are based on the OpenSSL implementation of AES:
 * http://www.openssl.org
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(10);__webpack_require__(11);__webpack_require__(1);/* AES API */module.exports=forge.aes=forge.aes||{};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.startEncrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:false,mode:mode});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.createEncryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:false,mode:mode});};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.startDecrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:true,mode:mode});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.createDecryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:true,mode:mode});};/**
 * Creates a new AES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the AES algorithm object.
 */forge.aes.Algorithm=function(name,mode){if(!init){initialize();}var self=this;self.name=name;self.mode=new mode({blockSize:16,cipher:{encrypt:function encrypt(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,false);},decrypt:function decrypt(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,true);}}});self._init=false;};/**
 * Initializes this AES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */forge.aes.Algorithm.prototype.initialize=function(options){if(this._init){return;}var key=options.key;var tmp;/* Note: The key may be a string of bytes, an array of bytes, a byte
    buffer, or an array of 32-bit integers. If the key is in bytes, then
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit
    integers, it must be 4, 6, or 8 integers long. */if(typeof key==='string'&&(key.length===16||key.length===24||key.length===32)){// convert key string into byte buffer
key=forge.util.createBuffer(key);}else if(forge.util.isArray(key)&&(key.length===16||key.length===24||key.length===32)){// convert key integer array into byte buffer
tmp=key;key=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){key.putByte(tmp[i]);}}// convert key byte buffer into 32-bit integer array
if(!forge.util.isArray(key)){tmp=key;key=[];// key lengths of 16, 24, 32 bytes allowed
var len=tmp.length();if(len===16||len===24||len===32){len=len>>>2;for(var i=0;i<len;++i){key.push(tmp.getInt32());}}}// key must be an array of 32-bit integers by now
if(!forge.util.isArray(key)||!(key.length===4||key.length===6||key.length===8)){throw new Error('Invalid key parameter.');}// encryption operation is always used for these modes
var mode=this.mode.name;var encryptOp=['CFB','OFB','CTR','GCM'].indexOf(mode)!==-1;// do key expansion
this._w=_expandKey(key,options.decrypt&&!encryptOp);this._init=true;};/**
 * Expands a key. Typically only used for testing.
 *
 * @param key the symmetric key to expand, as an array of 32-bit words.
 * @param decrypt true to expand for decryption, false for encryption.
 *
 * @return the expanded key.
 */forge.aes._expandKey=function(key,decrypt){if(!init){initialize();}return _expandKey(key,decrypt);};/**
 * Updates a single block. Typically only used for testing.
 *
 * @param w the expanded key to use.
 * @param input an array of block-size 32-bit words.
 * @param output an array of block-size 32-bit words.
 * @param decrypt true to decrypt, false to encrypt.
 */forge.aes._updateBlock=_updateBlock;/** Register AES algorithms **/registerAlgorithm('AES-ECB',forge.cipher.modes.ecb);registerAlgorithm('AES-CBC',forge.cipher.modes.cbc);registerAlgorithm('AES-CFB',forge.cipher.modes.cfb);registerAlgorithm('AES-OFB',forge.cipher.modes.ofb);registerAlgorithm('AES-CTR',forge.cipher.modes.ctr);registerAlgorithm('AES-GCM',forge.cipher.modes.gcm);function registerAlgorithm(name,mode){var factory=function factory(){return new forge.aes.Algorithm(name,mode);};forge.cipher.registerAlgorithm(name,factory);}/** AES implementation **/var init=false;// not yet initialized
var Nb=4;// number of words comprising the state (AES = 4)
var sbox;// non-linear substitution table used in key expansion
var isbox;// inversion of sbox
var rcon;// round constant word array
var mix;// mix-columns table
var imix;// inverse mix-columns table
/**
 * Performs initialization, ie: precomputes tables to optimize for speed.
 *
 * One way to understand how AES works is to imagine that 'addition' and
 * 'multiplication' are interfaces that require certain mathematical
 * properties to hold true (ie: they are associative) but they might have
 * different implementations and produce different kinds of results ...
 * provided that their mathematical properties remain true. AES defines
 * its own methods of addition and multiplication but keeps some important
 * properties the same, ie: associativity and distributivity. The
 * explanation below tries to shed some light on how AES defines addition
 * and multiplication of bytes and 32-bit words in order to perform its
 * encryption and decryption algorithms.
 *
 * The basics:
 *
 * The AES algorithm views bytes as binary representations of polynomials
 * that have either 1 or 0 as the coefficients. It defines the addition
 * or subtraction of two bytes as the XOR operation. It also defines the
 * multiplication of two bytes as a finite field referred to as GF(2^8)
 * (Note: 'GF' means "Galois Field" which is a field that contains a finite
 * number of elements so GF(2^8) has 256 elements).
 *
 * This means that any two bytes can be represented as binary polynomials;
 * when they multiplied together and modularly reduced by an irreducible
 * polynomial of the 8th degree, the results are the field GF(2^8). The
 * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
 * This multiplication is associative with 0x01 as the identity:
 *
 * (b * 0x01 = GF(b, 0x01) = b).
 *
 * The operation GF(b, 0x02) can be performed at the byte level by left
 * shifting b once and then XOR'ing it (to perform the modular reduction)
 * with 0x11b if b is >= 128. Repeated application of the multiplication
 * of 0x02 can be used to implement the multiplication of any two bytes.
 *
 * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
 * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
 * factors can each be multiplied by 0x57 and then added together. To do
 * the multiplication, values for 0x57 multiplied by each of these 3 factors
 * can be precomputed and stored in a table. To add them, the values from
 * the table are XOR'd together.
 *
 * AES also defines addition and multiplication of words, that is 4-byte
 * numbers represented as polynomials of 3 degrees where the coefficients
 * are the values of the bytes.
 *
 * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
 *
 * Addition is performed by XOR'ing like powers of x. Multiplication
 * is performed in two steps, the first is an algebriac expansion as
 * you would do normally (where addition is XOR). But the result is
 * a polynomial larger than 3 degrees and thus it cannot fit in a word. So
 * next the result is modularly reduced by an AES-specific polynomial of
 * degree 4 which will always produce a polynomial of less than 4 degrees
 * such that it will fit in a word. In AES, this polynomial is x^4 + 1.
 *
 * The modular product of two polynomials 'a' and 'b' is thus:
 *
 * d(x) = d3x^3 + d2x^2 + d1x + d0
 * with
 * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
 * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
 * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
 * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
 *
 * As a matrix:
 *
 * [d0] = [a0 a3 a2 a1][b0]
 * [d1]   [a1 a0 a3 a2][b1]
 * [d2]   [a2 a1 a0 a3][b2]
 * [d3]   [a3 a2 a1 a0][b3]
 *
 * Special polynomials defined by AES (0x02 == {02}):
 * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
 * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
 *
 * These polynomials are used in the MixColumns() and InverseMixColumns()
 * operations, respectively, to cause each element in the state to affect
 * the output (referred to as diffusing).
 *
 * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
 * polynomial x3.
 *
 * The ShiftRows() method modifies the last 3 rows in the state (where
 * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
 * The 1st byte in the second row is moved to the end of the row. The 1st
 * and 2nd bytes in the third row are moved to the end of the row. The 1st,
 * 2nd, and 3rd bytes are moved in the fourth row.
 *
 * More details on how AES arithmetic works:
 *
 * In the polynomial representation of binary numbers, XOR performs addition
 * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
 * corresponds with the multiplication of polynomials modulo an irreducible
 * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply
 * polynomial 'a' with polynomial 'b' and then do a modular reduction by
 * an AES-specific irreducible polynomial of degree 8.
 *
 * A polynomial is irreducible if its only divisors are one and itself. For
 * the AES algorithm, this irreducible polynomial is:
 *
 * m(x) = x^8 + x^4 + x^3 + x + 1,
 *
 * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:
 * 100011011 = 283 = 0x11b.
 *
 * For example, GF(0x57, 0x83) = 0xc1 because
 *
 * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1
 * 0x85 = 131 = 10000101 = x^7 + x + 1
 *
 * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)
 * =  x^13 + x^11 + x^9 + x^8 + x^7 +
 *    x^7 + x^5 + x^3 + x^2 + x +
 *    x^6 + x^4 + x^2 + x + 1
 * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y
 *    y modulo (x^8 + x^4 + x^3 + x + 1)
 * =  x^7 + x^6 + 1.
 *
 * The modular reduction by m(x) guarantees the result will be a binary
 * polynomial of less than degree 8, so that it can fit in a byte.
 *
 * The operation to multiply a binary polynomial b with x (the polynomial
 * x in binary representation is 00000010) is:
 *
 * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1
 *
 * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the
 * most significant bit is 0 in b) then the result is already reduced. If
 * it is 1, then we can reduce it by subtracting m(x) via an XOR.
 *
 * It follows that multiplication by x (00000010 or 0x02) can be implemented
 * by performing a left shift followed by a conditional bitwise XOR with
 * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by
 * higher powers of x can be implemented by repeated application of xtime().
 *
 * By adding intermediate results, multiplication by any constant can be
 * implemented. For instance:
 *
 * GF(0x57, 0x13) = 0xfe because:
 *
 * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)
 *
 * Note: We XOR with 0x11b instead of 0x1b because in javascript our
 * datatype for b can be larger than 1 byte, so a left shift will not
 * automatically eliminate bits that overflow a byte ... by XOR'ing the
 * overflow bit with 1 (the extra one from 0x11b) we zero it out.
 *
 * GF(0x57, 0x02) = xtime(0x57) = 0xae
 * GF(0x57, 0x04) = xtime(0xae) = 0x47
 * GF(0x57, 0x08) = xtime(0x47) = 0x8e
 * GF(0x57, 0x10) = xtime(0x8e) = 0x07
 *
 * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))
 *
 * And by the distributive property (since XOR is addition and GF() is
 * multiplication):
 *
 * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)
 * = 0x57 ^ 0xae ^ 0x07
 * = 0xfe.
 */function initialize(){init=true;/* Populate the Rcon table. These are the values given by
    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)
    in the field of GF(2^8), where i starts at 1.

    rcon[0] = [0x00, 0x00, 0x00, 0x00]
    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1
    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2
    ...
    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B
    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36

    We only store the first byte because it is the only one used.
  */rcon=[0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36];// compute xtime table which maps i onto GF(i, 0x02)
var xtime=new Array(256);for(var i=0;i<128;++i){xtime[i]=i<<1;xtime[i+128]=i+128<<1^0x11B;}// compute all other tables
sbox=new Array(256);isbox=new Array(256);mix=new Array(4);imix=new Array(4);for(var i=0;i<4;++i){mix[i]=new Array(256);imix[i]=new Array(256);}var e=0,ei=0,e2,e4,e8,sx,sx2,me,ime;for(var i=0;i<256;++i){/* We need to generate the SubBytes() sbox and isbox tables so that
      we can perform byte substitutions. This requires us to traverse
      all of the elements in GF, find their multiplicative inverses,
      and apply to each the following affine transformation:

      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^
            b(i + 7) mod 8 ^ ci
      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the
      ith bit of a byte c with the value {63} or {01100011}.

      It is possible to traverse every possible value in a Galois field
      using what is referred to as a 'generator'. There are many
      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully
      traverse GF we iterate 255 times, multiplying by our generator
      each time.

      On each iteration we can determine the multiplicative inverse for
      the current element.

      Suppose there is an element in GF 'e'. For a given generator 'g',
      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns
      out that if use the inverse of a generator as another generator
      it will produce all of the corresponding multiplicative inverses
      at the same time. For this reason, we choose 5 as our inverse
      generator because it only requires 2 multiplies and 1 add and its
      inverse, 82, requires relatively few operations as well.

      In order to apply the affine transformation, the multiplicative
      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a
      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and
      'x'. Then 's' is left shifted and the high bit of 's' is made the
      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd
      with 's' and stored in 'x'. On each subsequent iteration the same
      operation is performed. When 4 iterations are complete, 'x' is
      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.
      For example:

      s = 01000001
      x = 01000001

      iteration 1: s = 10000010, x ^= s
      iteration 2: s = 00000101, x ^= s
      iteration 3: s = 00001010, x ^= s
      iteration 4: s = 00010100, x ^= s
      x ^= 0x63

      This can be done with a loop where s = (s << 1) | (s >> 7). However,
      it can also be done by using a single 16-bit (in this case 32-bit)
      number 'sx'. Since XOR is an associative operation, we can set 'sx'
      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.
      The most significant bits will flow into the high 8 bit positions
      and be correctly XOR'd with one another. All that remains will be
      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits
      afterwards.

      At the same time we're populating sbox and isbox we can precompute
      the multiplication we'll need to do to do MixColumns() later.
    */ // apply affine transformation
sx=ei^ei<<1^ei<<2^ei<<3^ei<<4;sx=sx>>8^sx&255^0x63;// update tables
sbox[e]=sx;isbox[sx]=e;/* Mixing columns is done using matrix multiplication. The columns
      that are to be mixed are each a single word in the current state.
      The state has Nb columns (4 columns). Therefore each column is a
      4 byte word. So to mix the columns in a single column 'c' where
      its rows are r0, r1, r2, and r3, we use the following matrix
      multiplication:

      [2 3 1 1]*[r0,c]=[r'0,c]
      [1 2 3 1] [r1,c] [r'1,c]
      [1 1 2 3] [r2,c] [r'2,c]
      [3 1 1 2] [r3,c] [r'3,c]

      r0, r1, r2, and r3 are each 1 byte of one of the words in the
      state (a column). To do matrix multiplication for each mixed
      column c' we multiply the corresponding row from the left matrix
      with the corresponding column from the right matrix. In total, we
      get 4 equations:

      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c
      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c
      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c
      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c

      As usual, the multiplication is as previously defined and the
      addition is XOR. In order to optimize mixing columns we can store
      the multiplication results in tables. If you think of the whole
      column as a word (it might help to visualize by mentally rotating
      the equations above by counterclockwise 90 degrees) then you can
      see that it would be useful to map the multiplications performed on
      each byte (r0, r1, r2, r3) onto a word as well. For instance, we
      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the
      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two
      respectively in the middle). This means that a table can be
      constructed that uses r0 as an index to the word. We can do the
      same with r1, r2, and r3, creating a total of 4 tables.

      To construct a full c', we can just look up each byte of c in
      their respective tables and XOR the results together.

      Also, to build each table we only have to calculate the word
      for 2,1,1,3 for every byte ... which we can do on each iteration
      of this loop since we will iterate over every byte. After we have
      calculated 2,1,1,3 we can get the results for the other tables
      by cycling the byte at the end to the beginning. For instance
      we can take the result of table 2,1,1,3 and produce table 3,2,1,1
      by moving the right most byte to the left most position just like
      how you can imagine the 3 moved out of 2,1,1,3 and to the front
      to produce 3,2,1,1.

      There is another optimization in that the same multiples of
      the current element we need in order to advance our generator
      to the next iteration can be reused in performing the 2,1,1,3
      calculation. We also calculate the inverse mix column tables,
      with e,9,d,b being the inverse of 2,1,1,3.

      When we're done, and we need to actually mix columns, the first
      byte of each state word should be put through mix[0] (2,1,1,3),
      the second through mix[1] (3,2,1,1) and so forth. Then they should
      be XOR'd together to produce the fully mixed column.
    */ // calculate mix and imix table values
sx2=xtime[sx];e2=xtime[e];e4=xtime[e2];e8=xtime[e4];me=sx2<<24^// 2
sx<<16^// 1
sx<<8^(// 1
sx^sx2);// 3
ime=(e2^e4^e8)<<24^// E (14)
(e^e8)<<16^// 9
(e^e4^e8)<<8^(// D (13)
e^e2^e8);// B (11)
// produce each of the mix tables by rotating the 2,1,1,3 value
for(var n=0;n<4;++n){mix[n][e]=me;imix[n][sx]=ime;// cycle the right most byte to the left most position
// ie: 2,1,1,3 becomes 3,2,1,1
me=me<<24|me>>>8;ime=ime<<24|ime>>>8;}// get next element and inverse
if(e===0){// 1 is the inverse of 1
e=ei=1;}else{// e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)
// ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)
e=e2^xtime[xtime[xtime[e2^e8]]];ei^=xtime[xtime[ei]];}}}/**
 * Generates a key schedule using the AES key expansion algorithm.
 *
 * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
 * routine to generate a key schedule. The Key Expansion generates a total
 * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
 * and each of the Nr rounds requires Nb words of key data. The resulting
 * key schedule consists of a linear array of 4-byte words, denoted [wi ],
 * with i in the range 0  i < Nb(Nr + 1).
 *
 * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
 * AES-128 (Nb=4, Nk=4, Nr=10)
 * AES-192 (Nb=4, Nk=6, Nr=12)
 * AES-256 (Nb=4, Nk=8, Nr=14)
 * Note: Nr=Nk+6.
 *
 * Nb is the number of columns (32-bit words) comprising the State (or
 * number of bytes in a block). For AES, Nb=4.
 *
 * @param key the key to schedule (as an array of 32-bit words).
 * @param decrypt true to modify the key schedule to decrypt, false not to.
 *
 * @return the generated key schedule.
 */function _expandKey(key,decrypt){// copy the key's words to initialize the key schedule
var w=key.slice(0);/* RotWord() will rotate a word, moving the first byte to the last
    byte's position (shifting the other bytes left).

    We will be getting the value of Rcon at i / Nk. 'i' will iterate
    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in
    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from
    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will
    increase by 1. We use a counter iNk to keep track of this.
   */ // go through the rounds expanding the key
var temp,iNk=1;var Nk=w.length;var Nr1=Nk+6+1;var end=Nb*Nr1;for(var i=Nk;i<end;++i){temp=w[i-1];if(i%Nk===0){// temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]
temp=sbox[temp>>>16&255]<<24^sbox[temp>>>8&255]<<16^sbox[temp&255]<<8^sbox[temp>>>24]^rcon[iNk]<<24;iNk++;}else if(Nk>6&&i%Nk===4){// temp = SubWord(temp)
temp=sbox[temp>>>24]<<24^sbox[temp>>>16&255]<<16^sbox[temp>>>8&255]<<8^sbox[temp&255];}w[i]=w[i-Nk]^temp;}/* When we are updating a cipher block we always use the code path for
     encryption whether we are decrypting or not (to shorten code and
     simplify the generation of look up tables). However, because there
     are differences in the decryption algorithm, other than just swapping
     in different look up tables, we must transform our key schedule to
     account for these changes:

     1. The decryption algorithm gets its key rounds in reverse order.
     2. The decryption algorithm adds the round key before mixing columns
       instead of afterwards.

     We don't need to modify our key schedule to handle the first case,
     we can just traverse the key schedule in reverse order when decrypting.

     The second case requires a little work.

     The tables we built for performing rounds will take an input and then
     perform SubBytes() and MixColumns() or, for the decrypt version,
     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires
     us to AddRoundKey() before InvMixColumns(). This means we'll need to
     apply some transformations to the round key to inverse-mix its columns
     so they'll be correct for moving AddRoundKey() to after the state has
     had its columns inverse-mixed.

     To inverse-mix the columns of the state when we're decrypting we use a
     lookup table that will apply InvSubBytes() and InvMixColumns() at the
     same time. However, the round key's bytes are not inverse-substituted
     in the decryption algorithm. To get around this problem, we can first
     substitute the bytes in the round key so that when we apply the
     transformation via the InvSubBytes()+InvMixColumns() table, it will
     undo our substitution leaving us with the original value that we
     want -- and then inverse-mix that value.

     This change will correctly alter our key schedule so that we can XOR
     each round key with our already transformed decryption state. This
     allows us to use the same code path as the encryption algorithm.

     We make one more change to the decryption key. Since the decryption
     algorithm runs in reverse from the encryption algorithm, we reverse
     the order of the round keys to avoid having to iterate over the key
     schedule backwards when running the encryption algorithm later in
     decryption mode. In addition to reversing the order of the round keys,
     we also swap each round key's 2nd and 4th rows. See the comments
     section where rounds are performed for more details about why this is
     done. These changes are done inline with the other substitution
     described above.
  */if(decrypt){var tmp;var m0=imix[0];var m1=imix[1];var m2=imix[2];var m3=imix[3];var wnew=w.slice(0);end=w.length;for(var i=0,wi=end-Nb;i<end;i+=Nb,wi-=Nb){// do not sub the first or last round key (round keys are Nb
// words) as no column mixing is performed before they are added,
// but do change the key order
if(i===0||i===end-Nb){wnew[i]=w[wi];wnew[i+1]=w[wi+3];wnew[i+2]=w[wi+2];wnew[i+3]=w[wi+1];}else{// substitute each round key byte because the inverse-mix
// table will inverse-substitute it (effectively cancel the
// substitution because round key bytes aren't sub'd in
// decryption mode) and swap indexes 3 and 1
for(var n=0;n<Nb;++n){tmp=w[wi+n];wnew[i+(3&-n)]=m0[sbox[tmp>>>24]]^m1[sbox[tmp>>>16&255]]^m2[sbox[tmp>>>8&255]]^m3[sbox[tmp&255]];}}}w=wnew;}return w;}/**
 * Updates a single block (16 bytes) using AES. The update will either
 * encrypt or decrypt the block.
 *
 * @param w the key schedule.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */function _updateBlock(w,input,output,decrypt){/*
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr1
      SubBytes(state)
      ShiftRows(state)
      MixColumns(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
  end

  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    for round = Nr-1 step -1 downto 1
      InvShiftRows(state)
      InvSubBytes(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
      InvMixColumns(state)
    end for
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
    out = state
  end
  */ // Encrypt: AddRoundKey(state, w[0, Nb-1])
// Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
var Nr=w.length/4-1;var m0,m1,m2,m3,sub;if(decrypt){m0=imix[0];m1=imix[1];m2=imix[2];m3=imix[3];sub=isbox;}else{m0=mix[0];m1=mix[1];m2=mix[2];m3=mix[3];sub=sbox;}var a,b,c,d,a2,b2,c2;a=input[0]^w[0];b=input[decrypt?3:1]^w[1];c=input[2]^w[2];d=input[decrypt?1:3]^w[3];var i=3;/* In order to share code we follow the encryption algorithm when both
    encrypting and decrypting. To account for the changes required in the
    decryption algorithm, we use different lookup tables when decrypting
    and use a modified key schedule to account for the difference in the
    order of transformations applied when performing rounds. We also get
    key rounds in reverse order (relative to encryption). */for(var round=1;round<Nr;++round){/* As described above, we'll be using table lookups to perform the
      column mixing. Each column is stored as a word in the state (the
      array 'input' has one column as a word at each index). In order to
      mix a column, we perform these transformations on each row in c,
      which is 1 byte in each word. The new column for c0 is c'0:

               m0      m1      m2      m3
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0

      So using mix tables where c0 is a word with r0 being its upper
      8 bits and r3 being its lower 8 bits:

      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]
      ...
      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]

      Therefore to mix the columns in each word in the state we
      do the following (& 255 omitted for brevity):
      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]

      However, before mixing, the algorithm requires us to perform
      ShiftRows(). The ShiftRows() transformation cyclically shifts the
      last 3 rows of the state over different offsets. The first row
      (r = 0) is not shifted.

      s'_r,c = s_r,(c + shift(r, Nb) mod Nb
      for 0 < r < 4 and 0 <= c < Nb and
      shift(1, 4) = 1
      shift(2, 4) = 2
      shift(3, 4) = 3.

      This causes the first byte in r = 1 to be moved to the end of
      the row, the first 2 bytes in r = 2 to be moved to the end of
      the row, the first 3 bytes in r = 3 to be moved to the end of
      the row:

      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]

      We can make these substitutions inline with our column mixing to
      generate an updated set of equations to produce each word in the
      state (note the columns have changed positions):

      c0 c1 c2 c3 => c0 c1 c2 c3
      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)
      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)
      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)

      Therefore:

      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3
      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3

      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0
      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0

      ... and so forth for c'2 and c'3. The important distinction is
      that the columns are cycling, with c0 being used with the m0
      map when calculating c0, but c1 being used with the m0 map when
      calculating c1 ... and so forth.

      When performing the inverse we transform the mirror image and
      skip the bottom row, instead of the top one, and move upwards:

      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption
      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)
      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption
      c3 c2 c1 c0    c3 c2 c1 c0

      If you compare the resulting matrices for ShiftRows()+MixColumns()
      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are
      different (in encrypt mode vs. decrypt mode). So in order to use
      the same code to handle both encryption and decryption, we will
      need to do some mapping.

      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be
      a row number in the state, then the resulting matrix in encryption
      mode for applying the above transformations would be:

      r1: a b c d
      r2: b c d a
      r3: c d a b
      r4: d a b c

      If we did the same in decryption mode we would get:

      r1: a d c b
      r2: b a d c
      r3: c b a d
      r4: d c b a

      If instead we swap d and b (set b=c3 and d=c1), then we get:

      r1: a b c d
      r2: d a b c
      r3: c d a b
      r4: b c d a

      Now the 1st and 3rd rows are the same as the encryption matrix. All
      we need to do then to make the mapping exactly the same is to swap
      the 2nd and 4th rows when in decryption mode. To do this without
      having to do it on each iteration, we swapped the 2nd and 4th rows
      in the decryption key schedule. We also have to do the swap above
      when we first pull in the input and when we set the final output. */a2=m0[a>>>24]^m1[b>>>16&255]^m2[c>>>8&255]^m3[d&255]^w[++i];b2=m0[b>>>24]^m1[c>>>16&255]^m2[d>>>8&255]^m3[a&255]^w[++i];c2=m0[c>>>24]^m1[d>>>16&255]^m2[a>>>8&255]^m3[b&255]^w[++i];d=m0[d>>>24]^m1[a>>>16&255]^m2[b>>>8&255]^m3[c&255]^w[++i];a=a2;b=b2;c=c2;}/*
    Encrypt:
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])

    Decrypt:
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
   */ // Note: rows are shifted inline
output[0]=sub[a>>>24]<<24^sub[b>>>16&255]<<16^sub[c>>>8&255]<<8^sub[d&255]^w[++i];output[decrypt?3:1]=sub[b>>>24]<<24^sub[c>>>16&255]<<16^sub[d>>>8&255]<<8^sub[a&255]^w[++i];output[2]=sub[c>>>24]<<24^sub[d>>>16&255]<<16^sub[a>>>8&255]<<8^sub[b&255]^w[++i];output[decrypt?1:3]=sub[d>>>24]<<24^sub[a>>>16&255]<<16^sub[b>>>8&255]<<8^sub[c&255]^w[++i];}/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('AES-<mode>', key);
 * forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates a deprecated AES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key and iv may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param options the options to use.
 *          key the symmetric key to use.
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */function _createCipher(options){options=options||{};var mode=(options.mode||'CBC').toUpperCase();var algorithm='AES-'+mode;var cipher;if(options.decrypt){cipher=forge.cipher.createDecipher(algorithm,options.key);}else{cipher=forge.cipher.createCipher(algorithm,options.key);}// backwards compatible start API
var start=cipher.start;cipher.start=function(iv,options){// backwards compatibility: support second arg as output buffer
var output=null;if(options instanceof forge.util.ByteBuffer){output=options;options={};}options=options||{};options.output=output;options.iv=iv;start.call(cipher,options);};return cipher;}/***/},/* 8 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
 *
 * See: RFC 1421.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 *
 * A Forge PEM object has the following fields:
 *
 * type: identifies the type of message (eg: "RSA PRIVATE KEY").
 *
 * procType: identifies the type of processing performed on the message,
 *   it has two subfields: version and type, eg: 4,ENCRYPTED.
 *
 * contentDomain: identifies the type of content in the message, typically
 *   only uses the value: "RFC822".
 *
 * dekInfo: identifies the message encryption algorithm and mode and includes
 *   any parameters for the algorithm, it has two subfields: algorithm and
 *   parameters, eg: DES-CBC,F8143EDE5960C597.
 *
 * headers: contains all other PEM encapsulated headers -- where order is
 *   significant (for pairing data like recipient ID + key info).
 *
 * body: the binary-encoded body.
 */var forge=__webpack_require__(0);__webpack_require__(1);// shortcut for pem API
var pem=module.exports=forge.pem=forge.pem||{};/**
 * Encodes (serializes) the given PEM object.
 *
 * @param msg the PEM message object to encode.
 * @param options the options to use:
 *          maxline the maximum characters per line for the body, (default: 64).
 *
 * @return the PEM-formatted string.
 */pem.encode=function(msg,options){options=options||{};var rval='-----BEGIN '+msg.type+'-----\r\n';// encode special headers
var header;if(msg.procType){header={name:'Proc-Type',values:[String(msg.procType.version),msg.procType.type]};rval+=foldHeader(header);}if(msg.contentDomain){header={name:'Content-Domain',values:[msg.contentDomain]};rval+=foldHeader(header);}if(msg.dekInfo){header={name:'DEK-Info',values:[msg.dekInfo.algorithm]};if(msg.dekInfo.parameters){header.values.push(msg.dekInfo.parameters);}rval+=foldHeader(header);}if(msg.headers){// encode all other headers
for(var i=0;i<msg.headers.length;++i){rval+=foldHeader(msg.headers[i]);}}// terminate header
if(msg.procType){rval+='\r\n';}// add body
rval+=forge.util.encode64(msg.body,options.maxline||64)+'\r\n';rval+='-----END '+msg.type+'-----\r\n';return rval;};/**
 * Decodes (deserializes) all PEM messages found in the given string.
 *
 * @param str the PEM-formatted string to decode.
 *
 * @return the PEM message objects in an array.
 */pem.decode=function(str){var rval=[];// split string into PEM messages (be lenient w/EOF on BEGIN line)
var rMessage=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;var rHeader=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;var rCRLF=/\r?\n/;var match;while(true){match=rMessage.exec(str);if(!match){break;}var msg={type:match[1],procType:null,contentDomain:null,dekInfo:null,headers:[],body:forge.util.decode64(match[3])};rval.push(msg);// no headers
if(!match[2]){continue;}// parse headers
var lines=match[2].split(rCRLF);var li=0;while(match&&li<lines.length){// get line, trim any rhs whitespace
var line=lines[li].replace(/\s+$/,'');// RFC2822 unfold any following folded lines
for(var nl=li+1;nl<lines.length;++nl){var next=lines[nl];if(!/\s/.test(next[0])){break;}line+=next;li=nl;}// parse header
match=line.match(rHeader);if(match){var header={name:match[1],values:[]};var values=match[2].split(',');for(var vi=0;vi<values.length;++vi){header.values.push(ltrim(values[vi]));}// Proc-Type must be the first header
if(!msg.procType){if(header.name!=='Proc-Type'){throw new Error('Invalid PEM formatted message. The first '+'encapsulated header must be "Proc-Type".');}else if(header.values.length!==2){throw new Error('Invalid PEM formatted message. The "Proc-Type" '+'header must have two subfields.');}msg.procType={version:values[0],type:values[1]};}else if(!msg.contentDomain&&header.name==='Content-Domain'){// special-case Content-Domain
msg.contentDomain=values[0]||'';}else if(!msg.dekInfo&&header.name==='DEK-Info'){// special-case DEK-Info
if(header.values.length===0){throw new Error('Invalid PEM formatted message. The "DEK-Info" '+'header must have at least one subfield.');}msg.dekInfo={algorithm:values[0],parameters:values[1]||null};}else{msg.headers.push(header);}}++li;}if(msg.procType==='ENCRYPTED'&&!msg.dekInfo){throw new Error('Invalid PEM formatted message. The "DEK-Info" '+'header must be present if "Proc-Type" is "ENCRYPTED".');}}if(rval.length===0){throw new Error('Invalid PEM formatted message.');}return rval;};function foldHeader(header){var rval=header.name+': ';// ensure values with CRLF are folded
var values=[];var insertSpace=function insertSpace(match,$1){return' '+$1;};for(var i=0;i<header.values.length;++i){values.push(header.values[i].replace(/^(\S+\r\n)/,insertSpace));}rval+=values.join(',')+'\r\n';// do folding
var length=0;var candidate=-1;for(var i=0;i<rval.length;++i,++length){if(length>65&&candidate!==-1){var insert=rval[candidate];if(insert===','){++candidate;rval=rval.substr(0,candidate)+'\r\n '+rval.substr(candidate);}else{rval=rval.substr(0,candidate)+'\r\n'+insert+rval.substr(candidate+1);}length=i-candidate-1;candidate=-1;++i;}else if(rval[i]===' '||rval[i]==='\t'||rval[i]===','){candidate=i;}}return rval;}function ltrim(str){return str.replace(/^\s+/,'');}/***/},/* 9 */ /***/function(module,exports,__webpack_require__){/**
 * Password-based encryption functions.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * An EncryptedPrivateKeyInfo:
 *
 * EncryptedPrivateKeyInfo ::= SEQUENCE {
 *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
 *   encryptedData        EncryptedData }
 *
 * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedData ::= OCTET STRING
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(2);__webpack_require__(12);__webpack_require__(4);__webpack_require__(3);__webpack_require__(13);__webpack_require__(8);__webpack_require__(5);__webpack_require__(25);__webpack_require__(6);__webpack_require__(1);if(typeof BigInteger==='undefined'){var BigInteger=forge.jsbn.BigInteger;}// shortcut for asn.1 API
var asn1=forge.asn1;/* Password-based encryption implementation. */var pki=forge.pki=forge.pki||{};module.exports=pki.pbe=forge.pbe=forge.pbe||{};var oids=pki.oids;// validator for an EncryptedPrivateKeyInfo structure
// Note: Currently only works w/algorithm params
var encryptedPrivateKeyValidator={name:'EncryptedPrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedPrivateKeyInfo.encryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encryptionOid'},{name:'AlgorithmIdentifier.parameters',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'encryptionParams'}]},{// encryptedData
name:'EncryptedPrivateKeyInfo.encryptedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encryptedData'}]};// validator for a PBES2Algorithms structure
// Note: Currently only works w/PBKDF2 + AES encryption schemes
var PBES2AlgorithmsValidator={name:'PBES2Algorithms',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.keyDerivationFunc',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.keyDerivationFunc.oid',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'kdfOid'},{name:'PBES2Algorithms.params',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.params.salt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'kdfSalt'},{name:'PBES2Algorithms.params.iterationCount',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'kdfIterationCount'},{name:'PBES2Algorithms.params.keyLength',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,optional:true,capture:'keyLength'},{// prf
name:'PBES2Algorithms.params.prf',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,value:[{name:'PBES2Algorithms.params.prf.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'prfOid'}]}]}]},{name:'PBES2Algorithms.encryptionScheme',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.encryptionScheme.oid',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encOid'},{name:'PBES2Algorithms.encryptionScheme.iv',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encIv'}]}]};var pkcs12PbeParamsValidator={name:'pkcs-12PbeParams',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'pkcs-12PbeParams.salt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'salt'},{name:'pkcs-12PbeParams.iterations',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'iterations'}]};/**
 * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.
 *
 * PBES2Algorithms ALGORITHM-IDENTIFIER ::=
 *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}
 *
 * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}
 *
 * PBES2-params ::= SEQUENCE {
 *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
 *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
 * }
 *
 * PBES2-KDFs ALGORITHM-IDENTIFIER ::=
 *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }
 *
 * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }
 *
 * PBKDF2-params ::= SEQUENCE {
 *   salt CHOICE {
 *     specified OCTET STRING,
 *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
 *   },
 *   iterationCount INTEGER (1..MAX),
 *   keyLength INTEGER (1..MAX) OPTIONAL,
 *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
 * }
 *
 * @param obj the ASN.1 PrivateKeyInfo object.
 * @param password the password to encrypt with.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          prfAlgorithm the PRF message digest algorithm to use
 *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptPrivateKeyInfo=function(obj,password,options){// set default options
options=options||{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||'aes128';options.prfAlgorithm=options.prfAlgorithm||'sha1';// generate PBE params
var salt=forge.random.getBytesSync(options.saltSize);var count=options.count;var countBytes=asn1.integerToDer(count);var dkLen;var encryptionAlgorithm;var encryptedData;if(options.algorithm.indexOf('aes')===0||options.algorithm==='des'){// do PBES2
var ivLen,encOid,cipherFn;switch(options.algorithm){case'aes128':dkLen=16;ivLen=16;encOid=oids['aes128-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'aes192':dkLen=24;ivLen=16;encOid=oids['aes192-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'aes256':dkLen=32;ivLen=16;encOid=oids['aes256-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'des':dkLen=8;ivLen=8;encOid=oids['desCBC'];cipherFn=forge.des.createEncryptionCipher;break;default:var error=new Error('Cannot encrypt private key. Unknown encryption algorithm.');error.algorithm=options.algorithm;throw error;}// get PRF message digest
var prfAlgorithm='hmacWith'+options.prfAlgorithm.toUpperCase();var md=prfAlgorithmToMessageDigest(prfAlgorithm);// encrypt private key using pbe SHA-1 and AES/DES
var dk=forge.pkcs5.pbkdf2(password,salt,count,dkLen,md);var iv=forge.random.getBytesSync(ivLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(asn1.toDer(obj));cipher.finish();encryptedData=cipher.output.getBytes();// get PBKDF2-params
var params=createPbkdf2Params(salt,countBytes,dkLen,prfAlgorithm);encryptionAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// keyDerivationFunc
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),// PBKDF2-params
params]),// encryptionScheme
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(encOid).getBytes()),// iv
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,iv)])])]);}else if(options.algorithm==='3des'){// Do PKCS12 PBE
dkLen=24;var saltBytes=new forge.util.ByteBuffer(salt);var dk=pki.pbe.generatePkcs12Key(password,saltBytes,1,count,dkLen);var iv=pki.pbe.generatePkcs12Key(password,saltBytes,2,count,dkLen);var cipher=forge.des.createEncryptionCipher(dk);cipher.start(iv);cipher.update(asn1.toDer(obj));cipher.finish();encryptedData=cipher.output.getBytes();encryptionAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),// pkcs-12PbeParams
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// salt
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,salt),// iteration count
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,countBytes.getBytes())])]);}else{var error=new Error('Cannot encrypt private key. Unknown encryption algorithm.');error.algorithm=options.algorithm;throw error;}// EncryptedPrivateKeyInfo
var rval=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// encryptionAlgorithm
encryptionAlgorithm,// encryptedData
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,encryptedData)]);return rval;};/**
 * Decrypts a ASN.1 PrivateKeyInfo object.
 *
 * @param obj the ASN.1 EncryptedPrivateKeyInfo object.
 * @param password the password to decrypt with.
 *
 * @return the ASN.1 PrivateKeyInfo on success, null on failure.
 */pki.decryptPrivateKeyInfo=function(obj,password){var rval=null;// get PBE params
var capture={};var errors=[];if(!asn1.validate(obj,encryptedPrivateKeyValidator,capture,errors)){var error=new Error('Cannot read encrypted private key. '+'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}// get cipher
var oid=asn1.derToOid(capture.encryptionOid);var cipher=pki.pbe.getCipher(oid,capture.encryptionParams,password);// get encrypted data
var encrypted=forge.util.createBuffer(capture.encryptedData);cipher.update(encrypted);if(cipher.finish()){rval=asn1.fromDer(cipher.output);}return rval;};/**
 * Converts a EncryptedPrivateKeyInfo to PEM format.
 *
 * @param epki the EncryptedPrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted encrypted private key.
 */pki.encryptedPrivateKeyToPem=function(epki,maxline){// convert to DER, then PEM-encode
var msg={type:'ENCRYPTED PRIVATE KEY',body:asn1.toDer(epki).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
 * is not performed.
 *
 * @param pem the EncryptedPrivateKeyInfo in PEM-format.
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptedPrivateKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='ENCRYPTED PRIVATE KEY'){var error=new Error('Could not convert encrypted private key from PEM; '+'PEM header type is "ENCRYPTED PRIVATE KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert encrypted private key from PEM; '+'PEM is encrypted.');}// convert DER to ASN.1 object
return asn1.fromDer(msg.body);};/**
 * Encrypts an RSA private key. By default, the key will be wrapped in
 * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.
 * This is the standard, preferred way to encrypt a private key.
 *
 * To produce a non-standard PEM-encrypted private key that uses encapsulated
 * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL
 * private key encryption), set the 'legacy' option to true. Note: Using this
 * option will cause the iteration count to be forced to 1.
 *
 * Note: The 'des' algorithm is supported, but it is not considered to be
 * secure because it only uses a single 56-bit key. If possible, it is highly
 * recommended that a different algorithm be used.
 *
 * @param rsaKey the RSA key to encrypt.
 * @param password the password to use.
 * @param options:
 *          algorithm: the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des', 'des').
 *          count: the iteration count to use.
 *          saltSize: the salt size to use.
 *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated
 *            headers (DEK-Info) private key.
 *
 * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptRsaPrivateKey=function(rsaKey,password,options){// standard PKCS#8
options=options||{};if(!options.legacy){// encrypt PrivateKeyInfo
var rval=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));rval=pki.encryptPrivateKeyInfo(rval,password,options);return pki.encryptedPrivateKeyToPem(rval);}// legacy non-PKCS#8
var algorithm;var iv;var dkLen;var cipherFn;switch(options.algorithm){case'aes128':algorithm='AES-128-CBC';dkLen=16;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'aes192':algorithm='AES-192-CBC';dkLen=24;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'aes256':algorithm='AES-256-CBC';dkLen=32;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'3des':algorithm='DES-EDE3-CBC';dkLen=24;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;case'des':algorithm='DES-CBC';dkLen=8;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;default:var error=new Error('Could not encrypt RSA private key; unsupported '+'encryption algorithm "'+options.algorithm+'".');error.algorithm=options.algorithm;throw error;}// encrypt private key using OpenSSL legacy key derivation
var dk=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));cipher.finish();var msg={type:'RSA PRIVATE KEY',procType:{version:'4',type:'ENCRYPTED'},dekInfo:{algorithm:algorithm,parameters:forge.util.bytesToHex(iv).toUpperCase()},body:cipher.output.getBytes()};return forge.pem.encode(msg);};/**
 * Decrypts an RSA private key.
 *
 * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.
 * @param password the password to use.
 *
 * @return the RSA key on success, null on failure.
 */pki.decryptRsaPrivateKey=function(pem,password){var rval=null;var msg=forge.pem.decode(pem)[0];if(msg.type!=='ENCRYPTED PRIVATE KEY'&&msg.type!=='PRIVATE KEY'&&msg.type!=='RSA PRIVATE KEY'){var error=new Error('Could not convert private key from PEM; PEM header type '+'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');error.headerType=error;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){var dkLen;var cipherFn;switch(msg.dekInfo.algorithm){case'DES-CBC':dkLen=8;cipherFn=forge.des.createDecryptionCipher;break;case'DES-EDE3-CBC':dkLen=24;cipherFn=forge.des.createDecryptionCipher;break;case'AES-128-CBC':dkLen=16;cipherFn=forge.aes.createDecryptionCipher;break;case'AES-192-CBC':dkLen=24;cipherFn=forge.aes.createDecryptionCipher;break;case'AES-256-CBC':dkLen=32;cipherFn=forge.aes.createDecryptionCipher;break;case'RC2-40-CBC':dkLen=5;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,40);};break;case'RC2-64-CBC':dkLen=8;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,64);};break;case'RC2-128-CBC':dkLen=16;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,128);};break;default:var error=new Error('Could not decrypt private key; unsupported '+'encryption algorithm "'+msg.dekInfo.algorithm+'".');error.algorithm=msg.dekInfo.algorithm;throw error;}// use OpenSSL legacy key derivation
var iv=forge.util.hexToBytes(msg.dekInfo.parameters);var dk=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(forge.util.createBuffer(msg.body));if(cipher.finish()){rval=cipher.output.getBytes();}else{return rval;}}else{rval=msg.body;}if(msg.type==='ENCRYPTED PRIVATE KEY'){rval=pki.decryptPrivateKeyInfo(asn1.fromDer(rval),password);}else{// decryption already performed above
rval=asn1.fromDer(rval);}if(rval!==null){rval=pki.privateKeyFromAsn1(rval);}return rval;};/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */pki.pbe.generatePkcs12Key=function(password,salt,id,iter,n,md){var j,l;if(typeof md==='undefined'||md===null){if(!('sha1'in forge.md)){throw new Error('"sha1" hash algorithm unavailable.');}md=forge.md.sha1.create();}var u=md.digestLength;var v=md.blockLength;var result=new forge.util.ByteBuffer();/* Convert password to Unicode byte buffer + trailing 0-byte. */var passBuf=new forge.util.ByteBuffer();if(password!==null&&password!==undefined){for(l=0;l<password.length;l++){passBuf.putInt16(password.charCodeAt(l));}passBuf.putInt16(0);}/* Length of salt and password in BYTES. */var p=passBuf.length();var s=salt.length();/* 1. Construct a string, D (the "diversifier"), by concatenating
        v copies of ID. */var D=new forge.util.ByteBuffer();D.fillWithByte(id,v);/* 2. Concatenate copies of the salt together to create a string S of length
        v * ceil(s / v) bytes (the final copy of the salt may be trunacted
        to create S).
        Note that if the salt is the empty string, then so is S. */var Slen=v*Math.ceil(s/v);var S=new forge.util.ByteBuffer();for(l=0;l<Slen;l++){S.putByte(salt.at(l%s));}/* 3. Concatenate copies of the password together to create a string P of
        length v * ceil(p / v) bytes (the final copy of the password may be
        truncated to create P).
        Note that if the password is the empty string, then so is P. */var Plen=v*Math.ceil(p/v);var P=new forge.util.ByteBuffer();for(l=0;l<Plen;l++){P.putByte(passBuf.at(l%p));}/* 4. Set I=S||P to be the concatenation of S and P. */var I=S;I.putBuffer(P);/* 5. Set c=ceil(n / u). */var c=Math.ceil(n/u);/* 6. For i=1, 2, ..., c, do the following: */for(var i=1;i<=c;i++){/* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */var buf=new forge.util.ByteBuffer();buf.putBytes(D.bytes());buf.putBytes(I.bytes());for(var round=0;round<iter;round++){md.start();md.update(buf.getBytes());buf=md.digest();}/* b) Concatenate copies of Ai to create a string B of length v bytes (the
          final copy of Ai may be truncated to create B). */var B=new forge.util.ByteBuffer();for(l=0;l<v;l++){B.putByte(buf.at(l%u));}/* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,
          where k=ceil(s / v) + ceil(p / v), modify I by setting
          Ij=(Ij+B+1) mod 2v for each j.  */var k=Math.ceil(s/v)+Math.ceil(p/v);var Inew=new forge.util.ByteBuffer();for(j=0;j<k;j++){var chunk=new forge.util.ByteBuffer(I.getBytes(v));var x=0x1ff;for(l=B.length()-1;l>=0;l--){x=x>>8;x+=B.at(l)+chunk.at(l);chunk.setAt(l,x&0xff);}Inew.putBuffer(chunk);}I=Inew;/* Add Ai to A. */result.putBuffer(buf);}result.truncate(result.length()-n);return result;};/**
 * Get new Forge cipher object instance.
 *
 * @param oid the OID (in string notation).
 * @param params the ASN.1 params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */pki.pbe.getCipher=function(oid,params,password){switch(oid){case pki.oids['pkcs5PBES2']:return pki.pbe.getCipherForPBES2(oid,params,password);case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:case pki.oids['pbewithSHAAnd40BitRC2-CBC']:return pki.pbe.getCipherForPKCS12PBE(oid,params,password);default:var error=new Error('Cannot read encrypted PBE data block. Unsupported OID.');error.oid=oid;error.supportedOids=['pkcs5PBES2','pbeWithSHAAnd3-KeyTripleDES-CBC','pbewithSHAAnd40BitRC2-CBC'];throw error;}};/**
 * Get new Forge cipher object instance according to PBES2 params block.
 *
 * The returned cipher instance is already started using the IV
 * from PBES2 parameter block.
 *
 * @param oid the PKCS#5 PBKDF2 OID (in string notation).
 * @param params the ASN.1 PBES2-params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */pki.pbe.getCipherForPBES2=function(oid,params,password){// get PBE params
var capture={};var errors=[];if(!asn1.validate(params,PBES2AlgorithmsValidator,capture,errors)){var error=new Error('Cannot read password-based-encryption algorithm '+'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}// check oids
oid=asn1.derToOid(capture.kdfOid);if(oid!==pki.oids['pkcs5PBKDF2']){var error=new Error('Cannot read encrypted private key. '+'Unsupported key derivation function OID.');error.oid=oid;error.supportedOids=['pkcs5PBKDF2'];throw error;}oid=asn1.derToOid(capture.encOid);if(oid!==pki.oids['aes128-CBC']&&oid!==pki.oids['aes192-CBC']&&oid!==pki.oids['aes256-CBC']&&oid!==pki.oids['des-EDE3-CBC']&&oid!==pki.oids['desCBC']){var error=new Error('Cannot read encrypted private key. '+'Unsupported encryption scheme OID.');error.oid=oid;error.supportedOids=['aes128-CBC','aes192-CBC','aes256-CBC','des-EDE3-CBC','desCBC'];throw error;}// set PBE params
var salt=capture.kdfSalt;var count=forge.util.createBuffer(capture.kdfIterationCount);count=count.getInt(count.length()<<3);var dkLen;var cipherFn;switch(pki.oids[oid]){case'aes128-CBC':dkLen=16;cipherFn=forge.aes.createDecryptionCipher;break;case'aes192-CBC':dkLen=24;cipherFn=forge.aes.createDecryptionCipher;break;case'aes256-CBC':dkLen=32;cipherFn=forge.aes.createDecryptionCipher;break;case'des-EDE3-CBC':dkLen=24;cipherFn=forge.des.createDecryptionCipher;break;case'desCBC':dkLen=8;cipherFn=forge.des.createDecryptionCipher;break;}// get PRF message digest
var md=prfOidToMessageDigest(capture.prfOid);// decrypt private key using pbe with chosen PRF and AES/DES
var dk=forge.pkcs5.pbkdf2(password,salt,count,dkLen,md);var iv=capture.encIv;var cipher=cipherFn(dk);cipher.start(iv);return cipher;};/**
 * Get new Forge cipher object instance for PKCS#12 PBE.
 *
 * The returned cipher instance is already started using the key & IV
 * derived from the provided password and PKCS#12 PBE salt.
 *
 * @param oid The PKCS#12 PBE OID (in string notation).
 * @param params The ASN.1 PKCS#12 PBE-params object.
 * @param password The password to decrypt with.
 *
 * @return the new cipher object instance.
 */pki.pbe.getCipherForPKCS12PBE=function(oid,params,password){// get PBE params
var capture={};var errors=[];if(!asn1.validate(params,pkcs12PbeParamsValidator,capture,errors)){var error=new Error('Cannot read password-based-encryption algorithm '+'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}var salt=forge.util.createBuffer(capture.salt);var count=forge.util.createBuffer(capture.iterations);count=count.getInt(count.length()<<3);var dkLen,dIvLen,cipherFn;switch(oid){case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:dkLen=24;dIvLen=8;cipherFn=forge.des.startDecrypting;break;case pki.oids['pbewithSHAAnd40BitRC2-CBC']:dkLen=5;dIvLen=8;cipherFn=function cipherFn(key,iv){var cipher=forge.rc2.createDecryptionCipher(key,40);cipher.start(iv,null);return cipher;};break;default:var error=new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');error.oid=oid;throw error;}// get PRF message digest
var md=prfOidToMessageDigest(capture.prfOid);var key=pki.pbe.generatePkcs12Key(password,salt,1,count,dkLen,md);md.start();var iv=pki.pbe.generatePkcs12Key(password,salt,2,count,dIvLen,md);return cipherFn(key,iv);};/**
 * OpenSSL's legacy key derivation function.
 *
 * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
 *
 * @param password the password to derive the key from.
 * @param salt the salt to use, null for none.
 * @param dkLen the number of bytes needed for the derived key.
 * @param [options] the options to use:
 *          [md] an optional message digest object to use.
 */pki.pbe.opensslDeriveBytes=function(password,salt,dkLen,md){if(typeof md==='undefined'||md===null){if(!('md5'in forge.md)){throw new Error('"md5" hash algorithm unavailable.');}md=forge.md.md5.create();}if(salt===null){salt='';}var digests=[hash(md,password+salt)];for(var length=16,i=1;length<dkLen;++i,length+=16){digests.push(hash(md,digests[i-1]+password+salt));}return digests.join('').substr(0,dkLen);};function hash(md,bytes){return md.start().update(bytes).digest().getBytes();}function prfOidToMessageDigest(prfOid){// get PRF algorithm, default to SHA-1
var prfAlgorithm;if(!prfOid){prfAlgorithm='hmacWithSHA1';}else{prfAlgorithm=pki.oids[asn1.derToOid(prfOid)];if(!prfAlgorithm){var error=new Error('Unsupported PRF OID.');error.oid=prfOid;error.supported=['hmacWithSHA1','hmacWithSHA224','hmacWithSHA256','hmacWithSHA384','hmacWithSHA512'];throw error;}}return prfAlgorithmToMessageDigest(prfAlgorithm);}function prfAlgorithmToMessageDigest(prfAlgorithm){var factory=forge.md;switch(prfAlgorithm){case'hmacWithSHA224':factory=forge.md.sha512;case'hmacWithSHA1':case'hmacWithSHA256':case'hmacWithSHA384':case'hmacWithSHA512':prfAlgorithm=prfAlgorithm.substr(8).toLowerCase();break;default:var error=new Error('Unsupported PRF algorithm.');error.algorithm=prfAlgorithm;error.supported=['hmacWithSHA1','hmacWithSHA224','hmacWithSHA256','hmacWithSHA384','hmacWithSHA512'];throw error;}if(!factory||!(prfAlgorithm in factory)){throw new Error('Unknown hash algorithm: '+prfAlgorithm);}return factory[prfAlgorithm].create();}function createPbkdf2Params(salt,countBytes,dkLen,prfAlgorithm){var params=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// salt
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,salt),// iteration count
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,countBytes.getBytes())]);// when PRF algorithm is not SHA-1 default, add key length and PRF algorithm
if(prfAlgorithm!=='hmacWithSHA1'){params.value.push(// key length
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,forge.util.hexToBytes(dkLen.toString(16))),// AlgorithmIdentifier
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),// parameters (null)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]));}return params;}/***/},/* 10 */ /***/function(module,exports,__webpack_require__){/**
 * Cipher base API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);module.exports=forge.cipher=forge.cipher||{};// registered algorithms
forge.cipher.algorithms=forge.cipher.algorithms||{};/**
 * Creates a cipher object that can be used to encrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */forge.cipher.createCipher=function(algorithm,key){var api=algorithm;if(typeof api==='string'){api=forge.cipher.getAlgorithm(api);if(api){api=api();}}if(!api){throw new Error('Unsupported algorithm: '+algorithm);}// assume block cipher
return new forge.cipher.BlockCipher({algorithm:api,key:key,decrypt:false});};/**
 * Creates a decipher object that can be used to decrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */forge.cipher.createDecipher=function(algorithm,key){var api=algorithm;if(typeof api==='string'){api=forge.cipher.getAlgorithm(api);if(api){api=api();}}if(!api){throw new Error('Unsupported algorithm: '+algorithm);}// assume block cipher
return new forge.cipher.BlockCipher({algorithm:api,key:key,decrypt:true});};/**
 * Registers an algorithm by name. If the name was already registered, the
 * algorithm API object will be overwritten.
 *
 * @param name the name of the algorithm.
 * @param algorithm the algorithm API object.
 */forge.cipher.registerAlgorithm=function(name,algorithm){name=name.toUpperCase();forge.cipher.algorithms[name]=algorithm;};/**
 * Gets a registered algorithm by name.
 *
 * @param name the name of the algorithm.
 *
 * @return the algorithm, if found, null if not.
 */forge.cipher.getAlgorithm=function(name){name=name.toUpperCase();if(name in forge.cipher.algorithms){return forge.cipher.algorithms[name];}return null;};var BlockCipher=forge.cipher.BlockCipher=function(options){this.algorithm=options.algorithm;this.mode=this.algorithm.mode;this.blockSize=this.mode.blockSize;this._finish=false;this._input=null;this.output=null;this._op=options.decrypt?this.mode.decrypt:this.mode.encrypt;this._decrypt=options.decrypt;this.algorithm.initialize(options);};/**
 * Starts or restarts the encryption or decryption process, whichever
 * was previously configured.
 *
 * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
 * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in
 * bytes, then it must be Nb (16) bytes in length. If the IV is given in as
 * 32-bit integers, then it must be 4 integers long.
 *
 * Note: an IV is not required or used in ECB mode.
 *
 * For GCM-mode, the IV must be given as a binary-encoded string of bytes or
 * a byte buffer. The number of bytes should be 12 (96 bits) as recommended
 * by NIST SP-800-38D but another length may be given.
 *
 * @param options the options to use:
 *          iv the initialization vector to use as a binary-encoded string of
 *            bytes, null to reuse the last ciphered block from a previous
 *            update() (this "residue" method is for legacy support only).
 *          additionalData additional authentication data as a binary-encoded
 *            string of bytes, for 'GCM' mode, (default: none).
 *          tagLength desired length of authentication tag, in bits, for
 *            'GCM' mode (0-128, default: 128).
 *          tag the authentication tag to check if decrypting, as a
 *             binary-encoded string of bytes.
 *          output the output the buffer to write to, null to create one.
 */BlockCipher.prototype.start=function(options){options=options||{};var opts={};for(var key in options){opts[key]=options[key];}opts.decrypt=this._decrypt;this._finish=false;this._input=forge.util.createBuffer();this.output=options.output||forge.util.createBuffer();this.mode.start(opts);};/**
 * Updates the next block according to the cipher mode.
 *
 * @param input the buffer to read from.
 */BlockCipher.prototype.update=function(input){if(input){// input given, so empty it into the input buffer
this._input.putBuffer(input);}// do cipher operation until it needs more input and not finished
while(!this._op.call(this.mode,this._input,this.output,this._finish)&&!this._finish){}// free consumed memory from input buffer
this._input.compact();};/**
 * Finishes encrypting or decrypting.
 *
 * @param pad a padding function to use in CBC mode, null for default,
 *          signature(blockSize, buffer, decrypt).
 *
 * @return true if successful, false on error.
 */BlockCipher.prototype.finish=function(pad){// backwards-compatibility w/deprecated padding API
// Note: will overwrite padding functions even after another start() call
if(pad&&(this.mode.name==='ECB'||this.mode.name==='CBC')){this.mode.pad=function(input){return pad(this.blockSize,input,false);};this.mode.unpad=function(output){return pad(this.blockSize,output,true);};}// build options for padding and afterFinish functions
var options={};options.decrypt=this._decrypt;// get # of bytes that won't fill a block
options.overflow=this._input.length()%this.blockSize;if(!this._decrypt&&this.mode.pad){if(!this.mode.pad(this._input,options)){return false;}}// do final update
this._finish=true;this.update();if(this._decrypt&&this.mode.unpad){if(!this.mode.unpad(this.output,options)){return false;}}if(this.mode.afterFinish){if(!this.mode.afterFinish(this.output,options)){return false;}}return true;};/***/},/* 11 */ /***/function(module,exports,__webpack_require__){/**
 * Supported cipher modes.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);forge.cipher=forge.cipher||{};// supported cipher modes
var modes=module.exports=forge.cipher.modes=forge.cipher.modes||{};/** Electronic codebook (ECB) (Don't use this; it's not secure) **/modes.ecb=function(options){options=options||{};this.name='ECB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);};modes.ecb.prototype.start=function(options){};modes.ecb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// write output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}};modes.ecb.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// decrypt block
this.cipher.decrypt(this._inBlock,this._outBlock);// write output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}};modes.ecb.prototype.pad=function(input,options){// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=input.length()===this.blockSize?this.blockSize:this.blockSize-input.length();input.fillWithByte(padding,padding);return true;};modes.ecb.prototype.unpad=function(output,options){// check for error: input data not a multiple of blockSize
if(options.overflow>0){return false;}// ensure padding byte count is valid
var len=output.length();var count=output.at(len-1);if(count>this.blockSize<<2){return false;}// trim off padding bytes
output.truncate(count);return true;};/** Cipher-block Chaining (CBC) **/modes.cbc=function(options){options=options||{};this.name='CBC';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);};modes.cbc.prototype.start=function(options){// Note: legacy support for using IV residue (has security flaws)
// if IV is null, reuse block from previous processing
if(options.iv===null){// must have a previous block
if(!this._prev){throw new Error('Invalid IV parameter.');}this._iv=this._prev.slice(0);}else if(!('iv'in options)){throw new Error('Invalid IV parameter.');}else{// save IV as "previous" block
this._iv=transformIV(options.iv);this._prev=this._iv.slice(0);}};modes.cbc.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
// CBC XOR's IV (or previous block) with plaintext
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._prev[i]^input.getInt32();}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// write output, save previous block
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}this._prev=this._outBlock;};modes.cbc.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// decrypt block
this.cipher.decrypt(this._inBlock,this._outBlock);// write output, save previous ciphered block
// CBC XOR's IV (or previous block) with ciphertext
for(var i=0;i<this._ints;++i){output.putInt32(this._prev[i]^this._outBlock[i]);}this._prev=this._inBlock.slice(0);};modes.cbc.prototype.pad=function(input,options){// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=input.length()===this.blockSize?this.blockSize:this.blockSize-input.length();input.fillWithByte(padding,padding);return true;};modes.cbc.prototype.unpad=function(output,options){// check for error: input data not a multiple of blockSize
if(options.overflow>0){return false;}// ensure padding byte count is valid
var len=output.length();var count=output.at(len-1);if(count>this.blockSize<<2){return false;}// trim off padding bytes
output.truncate(count);return true;};/** Cipher feedback (CFB) **/modes.cfb=function(options){options=options||{};this.name='CFB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.cfb.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.cfb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output, write input as output
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32()^this._outBlock[i];output.putInt32(this._inBlock[i]);}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output, write input as partial output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialBlock[i]=input.getInt32()^this._outBlock[i];this._partialOutput.putInt32(this._partialBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._partialBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};modes.cfb.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block (CFB always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output, write input as output
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();output.putInt32(this._inBlock[i]^this._outBlock[i]);}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output, write input as partial output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialBlock[i]=input.getInt32();this._partialOutput.putInt32(this._partialBlock[i]^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._partialBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};/** Output feedback (OFB) **/modes.ofb=function(options){options=options||{};this.name='OFB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.ofb.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.ofb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(input.length()===0){return true;}// encrypt block (OFB always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output and update next input
for(var i=0;i<this._ints;++i){output.putInt32(input.getInt32()^this._outBlock[i]);this._inBlock[i]=this._outBlock[i];}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._outBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};modes.ofb.prototype.decrypt=modes.ofb.prototype.encrypt;/** Counter (CTR) **/modes.ctr=function(options){options=options||{};this.name='CTR';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.ctr.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.ctr.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block (CTR always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output
for(var i=0;i<this._ints;++i){output.putInt32(input.getInt32()^this._outBlock[i]);}}else{// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;}// block complete, increment counter (input block)
inc32(this._inBlock);};modes.ctr.prototype.decrypt=modes.ctr.prototype.encrypt;/** Galois/Counter Mode (GCM) **/modes.gcm=function(options){options=options||{};this.name='GCM';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;// R is actually this value concatenated with 120 more zero bits, but
// we only XOR against R so the other zeros have no effect -- we just
// apply this value to the first integer in a block
this._R=0xE1000000;};modes.gcm.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// ensure IV is a byte buffer
var iv=forge.util.createBuffer(options.iv);// no ciphered data processed yet
this._cipherLength=0;// default additional data is none
var additionalData;if('additionalData'in options){additionalData=forge.util.createBuffer(options.additionalData);}else{additionalData=forge.util.createBuffer();}// default tag length is 128 bits
if('tagLength'in options){this._tagLength=options.tagLength;}else{this._tagLength=128;}// if tag is given, ensure tag matches tag length
this._tag=null;if(options.decrypt){// save tag to check later
this._tag=forge.util.createBuffer(options.tag).getBytes();if(this._tag.length!==this._tagLength/8){throw new Error('Authentication tag does not match tag length.');}}// create tmp storage for hash calculation
this._hashBlock=new Array(this._ints);// no tag generated yet
this.tag=null;// generate hash subkey
// (apply block cipher to "zero" block)
this._hashSubkey=new Array(this._ints);this.cipher.encrypt([0,0,0,0],this._hashSubkey);// generate table M
// use 4-bit tables (32 component decomposition of a 16 byte value)
// 8-bit tables take more space and are known to have security
// vulnerabilities (in native implementations)
this.componentBits=4;this._m=this.generateHashTable(this._hashSubkey,this.componentBits);// Note: support IV length different from 96 bits? (only supporting
// 96 bits is recommended by NIST SP-800-38D)
// generate J_0
var ivLength=iv.length();if(ivLength===12){// 96-bit IV
this._j0=[iv.getInt32(),iv.getInt32(),iv.getInt32(),1];}else{// IV is NOT 96-bits
this._j0=[0,0,0,0];while(iv.length()>0){this._j0=this.ghash(this._hashSubkey,this._j0,[iv.getInt32(),iv.getInt32(),iv.getInt32(),iv.getInt32()]);}this._j0=this.ghash(this._hashSubkey,this._j0,[0,0].concat(from64To32(ivLength*8)));}// generate ICB (initial counter block)
this._inBlock=this._j0.slice(0);inc32(this._inBlock);this._partialBytes=0;// consume authentication data
additionalData=forge.util.createBuffer(additionalData);// save additional data length as a BE 64-bit number
this._aDataLength=from64To32(additionalData.length()*8);// pad additional data to 128 bit (16 byte) block size
var overflow=additionalData.length()%this.blockSize;if(overflow){additionalData.fillWithByte(0,this.blockSize-overflow);}this._s=[0,0,0,0];while(additionalData.length()>0){this._s=this.ghash(this._hashSubkey,this._s,[additionalData.getInt32(),additionalData.getInt32(),additionalData.getInt32(),additionalData.getInt32()]);}};modes.gcm.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]^=input.getInt32());}this._cipherLength+=this.blockSize;}else{// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes===0||finish){// handle overflow prior to hashing
if(finish){// get block overflow
var overflow=inputLength%this.blockSize;this._cipherLength+=overflow;// truncate for hash function
this._partialOutput.truncate(this.blockSize-overflow);}else{this._cipherLength+=this.blockSize;}// get output block for hashing
for(var i=0;i<this._ints;++i){this._outBlock[i]=this._partialOutput.getInt32();}this._partialOutput.read-=this.blockSize;}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){// block still incomplete, restore input buffer, get partial output,
// and return early
input.read-=this.blockSize;output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;}// update hash block S
this._s=this.ghash(this._hashSubkey,this._s,this._outBlock);// increment counter (input block)
inc32(this._inBlock);};modes.gcm.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
var inputLength=input.length();if(inputLength<this.blockSize&&!(finish&&inputLength>0)){return true;}// encrypt block (GCM always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// increment counter (input block)
inc32(this._inBlock);// update hash block S
this._hashBlock[0]=input.getInt32();this._hashBlock[1]=input.getInt32();this._hashBlock[2]=input.getInt32();this._hashBlock[3]=input.getInt32();this._s=this.ghash(this._hashSubkey,this._s,this._hashBlock);// XOR hash input with output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]^this._hashBlock[i]);}// increment cipher data length
if(inputLength<this.blockSize){this._cipherLength+=inputLength%this.blockSize;}else{this._cipherLength+=this.blockSize;}};modes.gcm.prototype.afterFinish=function(output,options){var rval=true;// handle overflow
if(options.decrypt&&options.overflow){output.truncate(this.blockSize-options.overflow);}// handle authentication tag
this.tag=forge.util.createBuffer();// concatenate additional data length with cipher length
var lengths=this._aDataLength.concat(from64To32(this._cipherLength*8));// include lengths in hash
this._s=this.ghash(this._hashSubkey,this._s,lengths);// do GCTR(J_0, S)
var tag=[];this.cipher.encrypt(this._j0,tag);for(var i=0;i<this._ints;++i){this.tag.putInt32(this._s[i]^tag[i]);}// trim tag to length
this.tag.truncate(this.tag.length()%(this._tagLength/8));// check authentication tag
if(options.decrypt&&this.tag.bytes()!==this._tag){rval=false;}return rval;};/**
 * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois
 * field multiplication. The field, GF(2^128), is defined by the polynomial:
 *
 * x^128 + x^7 + x^2 + x + 1
 *
 * Which is represented in little-endian binary form as: 11100001 (0xe1). When
 * the value of a coefficient is 1, a bit is set. The value R, is the
 * concatenation of this value and 120 zero bits, yielding a 128-bit value
 * which matches the block size.
 *
 * This function will multiply two elements (vectors of bytes), X and Y, in
 * the field GF(2^128). The result is initialized to zero. For each bit of
 * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)
 * by the current value of Y. For each bit, the value of Y will be raised by
 * a power of x (multiplied by the polynomial x). This can be achieved by
 * shifting Y once to the right. If the current value of Y, prior to being
 * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.
 * Otherwise, we must divide by R after shifting to find the remainder.
 *
 * @param x the first block to multiply by the second.
 * @param y the second block to multiply by the first.
 *
 * @return the block result of the multiplication.
 */modes.gcm.prototype.multiply=function(x,y){var z_i=[0,0,0,0];var v_i=y.slice(0);// calculate Z_128 (block has 128 bits)
for(var i=0;i<128;++i){// if x_i is 0, Z_{i+1} = Z_i (unchanged)
// else Z_{i+1} = Z_i ^ V_i
// get x_i by finding 32-bit int position, then left shift 1 by remainder
var x_i=x[i/32|0]&1<<31-i%32;if(x_i){z_i[0]^=v_i[0];z_i[1]^=v_i[1];z_i[2]^=v_i[2];z_i[3]^=v_i[3];}// if LSB(V_i) is 1, V_i = V_i >> 1
// else V_i = (V_i >> 1) ^ R
this.pow(v_i,v_i);}return z_i;};modes.gcm.prototype.pow=function(x,out){// if LSB(x) is 1, x = x >>> 1
// else x = (x >>> 1) ^ R
var lsb=x[3]&1;// always do x >>> 1:
// starting with the rightmost integer, shift each integer to the right
// one bit, pulling in the bit from the integer to the left as its top
// most bit (do this for the last 3 integers)
for(var i=3;i>0;--i){out[i]=x[i]>>>1|(x[i-1]&1)<<31;}// shift the first integer normally
out[0]=x[0]>>>1;// if lsb was not set, then polynomial had a degree of 127 and doesn't
// need to divided; otherwise, XOR with R to find the remainder; we only
// need to XOR the first integer since R technically ends w/120 zero bits
if(lsb){out[0]^=this._R;}};modes.gcm.prototype.tableMultiply=function(x){// assumes 4-bit tables are used
var z=[0,0,0,0];for(var i=0;i<32;++i){var idx=i/8|0;var x_i=x[idx]>>>(7-i%8)*4&0xF;var ah=this._m[i][x_i];z[0]^=ah[0];z[1]^=ah[1];z[2]^=ah[2];z[3]^=ah[3];}return z;};/**
 * A continuing version of the GHASH algorithm that operates on a single
 * block. The hash block, last hash value (Ym) and the new block to hash
 * are given.
 *
 * @param h the hash block.
 * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.
 * @param x the block to hash.
 *
 * @return the hashed value (Ym).
 */modes.gcm.prototype.ghash=function(h,y,x){y[0]^=x[0];y[1]^=x[1];y[2]^=x[2];y[3]^=x[3];return this.tableMultiply(y);//return this.multiply(y, h);
};/**
 * Precomputes a table for multiplying against the hash subkey. This
 * mechanism provides a substantial speed increase over multiplication
 * performed without a table. The table-based multiplication this table is
 * for solves X * H by multiplying each component of X by H and then
 * composing the results together using XOR.
 *
 * This function can be used to generate tables with different bit sizes
 * for the components, however, this implementation assumes there are
 * 32 components of X (which is a 16 byte vector), therefore each component
 * takes 4-bits (so the table is constructed with bits=4).
 *
 * @param h the hash subkey.
 * @param bits the bit size for a component.
 */modes.gcm.prototype.generateHashTable=function(h,bits){// TODO: There are further optimizations that would use only the
// first table M_0 (or some variant) along with a remainder table;
// this can be explored in the future
var multiplier=8/bits;var perInt=4*multiplier;var size=16*multiplier;var m=new Array(size);for(var i=0;i<size;++i){var tmp=[0,0,0,0];var idx=i/perInt|0;var shft=(perInt-1-i%perInt)*bits;tmp[idx]=1<<bits-1<<shft;m[i]=this.generateSubHashTable(this.multiply(tmp,h),bits);}return m;};/**
 * Generates a table for multiplying against the hash subkey for one
 * particular component (out of all possible component values).
 *
 * @param mid the pre-multiplied value for the middle key of the table.
 * @param bits the bit size for a component.
 */modes.gcm.prototype.generateSubHashTable=function(mid,bits){// compute the table quickly by minimizing the number of
// POW operations -- they only need to be performed for powers of 2,
// all other entries can be composed from those powers using XOR
var size=1<<bits;var half=size>>>1;var m=new Array(size);m[half]=mid.slice(0);var i=half>>>1;while(i>0){// raise m0[2 * i] and store in m0[i]
this.pow(m[2*i],m[i]=[]);i>>=1;}i=2;while(i<half){for(var j=1;j<i;++j){var m_i=m[i];var m_j=m[j];m[i+j]=[m_i[0]^m_j[0],m_i[1]^m_j[1],m_i[2]^m_j[2],m_i[3]^m_j[3]];}i*=2;}m[0]=[0,0,0,0];/* Note: We could avoid storing these by doing composition during multiply
  calculate top half using composition by speed is preferred. */for(i=half+1;i<size;++i){var c=m[i^half];m[i]=[mid[0]^c[0],mid[1]^c[1],mid[2]^c[2],mid[3]^c[3]];}return m;};/** Utility functions */function transformIV(iv){if(typeof iv==='string'){// convert iv string into byte buffer
iv=forge.util.createBuffer(iv);}if(forge.util.isArray(iv)&&iv.length>4){// convert iv byte array into byte buffer
var tmp=iv;iv=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){iv.putByte(tmp[i]);}}if(!forge.util.isArray(iv)){// convert iv byte buffer into 32-bit integer array
iv=[iv.getInt32(),iv.getInt32(),iv.getInt32(),iv.getInt32()];}return iv;}function inc32(block){// increment last 32 bits of block only
block[block.length-1]=block[block.length-1]+1&0xFFFFFFFF;}function from64To32(num){// convert 64-bit number to two BE Int32s
return[num/0x100000000|0,num&0xFFFFFFFF];}/***/},/* 12 */ /***/function(module,exports,__webpack_require__){/**
 * DES (Data Encryption Standard) implementation.
 *
 * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.
 * It is based on the BSD-licensed implementation by Paul Tero:
 *
 * Paul Tero, July 2001
 * http://www.tero.co.uk/des/
 *
 * Optimised for performance with large blocks by Michael Hayworth, November 2001
 * http://www.netdealing.com
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2012-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(10);__webpack_require__(11);__webpack_require__(1);/* DES API */module.exports=forge.des=forge.des||{};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */forge.des.startEncrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:false,mode:mode||(iv===null?'ECB':'CBC')});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.des.createEncryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:false,mode:mode});};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */forge.des.startDecrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:true,mode:mode||(iv===null?'ECB':'CBC')});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.des.createDecryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:true,mode:mode});};/**
 * Creates a new DES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the DES algorithm object.
 */forge.des.Algorithm=function(name,mode){var self=this;self.name=name;self.mode=new mode({blockSize:8,cipher:{encrypt:function encrypt(inBlock,outBlock){return _updateBlock(self._keys,inBlock,outBlock,false);},decrypt:function decrypt(inBlock,outBlock){return _updateBlock(self._keys,inBlock,outBlock,true);}}});self._init=false;};/**
 * Initializes this DES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */forge.des.Algorithm.prototype.initialize=function(options){if(this._init){return;}var key=forge.util.createBuffer(options.key);if(this.name.indexOf('3DES')===0){if(key.length()!==24){throw new Error('Invalid Triple-DES key size: '+key.length()*8);}}// do key expansion to 16 or 48 subkeys (single or triple DES)
this._keys=_createKeys(key);this._init=true;};/** Register DES algorithms **/registerAlgorithm('DES-ECB',forge.cipher.modes.ecb);registerAlgorithm('DES-CBC',forge.cipher.modes.cbc);registerAlgorithm('DES-CFB',forge.cipher.modes.cfb);registerAlgorithm('DES-OFB',forge.cipher.modes.ofb);registerAlgorithm('DES-CTR',forge.cipher.modes.ctr);registerAlgorithm('3DES-ECB',forge.cipher.modes.ecb);registerAlgorithm('3DES-CBC',forge.cipher.modes.cbc);registerAlgorithm('3DES-CFB',forge.cipher.modes.cfb);registerAlgorithm('3DES-OFB',forge.cipher.modes.ofb);registerAlgorithm('3DES-CTR',forge.cipher.modes.ctr);function registerAlgorithm(name,mode){var factory=function factory(){return new forge.des.Algorithm(name,mode);};forge.cipher.registerAlgorithm(name,factory);}/** DES implementation **/var spfunction1=[0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004];var spfunction2=[-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000];var spfunction3=[0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200];var spfunction4=[0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080];var spfunction5=[0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100];var spfunction6=[0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010];var spfunction7=[0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002];var spfunction8=[0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000];/**
 * Create necessary sub keys.
 *
 * @param key the 64-bit or 192-bit key.
 *
 * @return the expanded keys.
 */function _createKeys(key){var pc2bytes0=[0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204],pc2bytes1=[0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101],pc2bytes2=[0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808],pc2bytes3=[0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000],pc2bytes4=[0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010],pc2bytes5=[0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420],pc2bytes6=[0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002],pc2bytes7=[0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800],pc2bytes8=[0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002],pc2bytes9=[0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408],pc2bytes10=[0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020],pc2bytes11=[0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200],pc2bytes12=[0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010],pc2bytes13=[0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105];// how many iterations (1 for des, 3 for triple des)
// changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys
var iterations=key.length()>8?3:1;// stores the return keys
var keys=[];// now define the left shifts which need to be done
var shifts=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0];var n=0,tmp;for(var j=0;j<iterations;j++){var left=key.getInt32();var right=key.getInt32();tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;tmp=(right>>>-16^left)&0x0000ffff;left^=tmp;right^=tmp<<-16;tmp=(left>>>2^right)&0x33333333;right^=tmp;left^=tmp<<2;tmp=(right>>>-16^left)&0x0000ffff;left^=tmp;right^=tmp<<-16;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;// right needs to be shifted and OR'd with last four bits of left
tmp=left<<8|right>>>20&0x000000f0;// left needs to be put upside down
left=right<<24|right<<8&0xff0000|right>>>8&0xff00|right>>>24&0xf0;right=tmp;// now go through and perform these shifts on the left and right keys
for(var i=0;i<shifts.length;++i){//shift the keys either one or two bits to the left
if(shifts[i]){left=left<<2|left>>>26;right=right<<2|right>>>26;}else{left=left<<1|left>>>27;right=right<<1|right>>>27;}left&=-0xf;right&=-0xf;// now apply PC-2, in such a way that E is easier when encrypting or
// decrypting this conversion will look like PC-2 except only the last 6
// bits of each byte are used rather than 48 consecutive bits and the
// order of lines will be according to how the S selection functions will
// be applied: S2, S4, S6, S8, S1, S3, S5, S7
var lefttmp=pc2bytes0[left>>>28]|pc2bytes1[left>>>24&0xf]|pc2bytes2[left>>>20&0xf]|pc2bytes3[left>>>16&0xf]|pc2bytes4[left>>>12&0xf]|pc2bytes5[left>>>8&0xf]|pc2bytes6[left>>>4&0xf];var righttmp=pc2bytes7[right>>>28]|pc2bytes8[right>>>24&0xf]|pc2bytes9[right>>>20&0xf]|pc2bytes10[right>>>16&0xf]|pc2bytes11[right>>>12&0xf]|pc2bytes12[right>>>8&0xf]|pc2bytes13[right>>>4&0xf];tmp=(righttmp>>>16^lefttmp)&0x0000ffff;keys[n++]=lefttmp^tmp;keys[n++]=righttmp^tmp<<16;}}return keys;}/**
 * Updates a single block (1 byte) using DES. The update will either
 * encrypt or decrypt the block.
 *
 * @param keys the expanded keys.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */function _updateBlock(keys,input,output,decrypt){// set up loops for single or triple DES
var iterations=keys.length===32?3:9;var looping;if(iterations===3){looping=decrypt?[30,-2,-2]:[0,32,2];}else{looping=decrypt?[94,62,-2,32,64,2,30,-2,-2]:[0,32,2,62,30,-2,64,96,2];}var tmp;var left=input[0];var right=input[1];// first each 64 bit chunk of the message must be permuted according to IP
tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;tmp=(left>>>16^right)&0x0000ffff;right^=tmp;left^=tmp<<16;tmp=(right>>>2^left)&0x33333333;left^=tmp;right^=tmp<<2;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;// rotate left 1 bit
left=left<<1|left>>>31;right=right<<1|right>>>31;for(var j=0;j<iterations;j+=3){var endloop=looping[j+1];var loopinc=looping[j+2];// now go through and perform the encryption or decryption
for(var i=looping[j];i!=endloop;i+=loopinc){var right1=right^keys[i];var right2=(right>>>4|right<<28)^keys[i+1];// passing these bytes through the S selection functions
tmp=left;left=right;right=tmp^(spfunction2[right1>>>24&0x3f]|spfunction4[right1>>>16&0x3f]|spfunction6[right1>>>8&0x3f]|spfunction8[right1&0x3f]|spfunction1[right2>>>24&0x3f]|spfunction3[right2>>>16&0x3f]|spfunction5[right2>>>8&0x3f]|spfunction7[right2&0x3f]);}// unreverse left and right
tmp=left;left=right;right=tmp;}// rotate right 1 bit
left=left>>>1|left<<31;right=right>>>1|right<<31;// now perform IP-1, which is IP in the opposite direction
tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(right>>>2^left)&0x33333333;left^=tmp;right^=tmp<<2;tmp=(left>>>16^right)&0x0000ffff;right^=tmp;left^=tmp<<16;tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;output[0]=left;output[1]=right;}/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('DES-<mode>', key);
 * forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates a deprecated DES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param options the options to use.
 *          key the symmetric key to use (64 or 192 bits).
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */function _createCipher(options){options=options||{};var mode=(options.mode||'CBC').toUpperCase();var algorithm='DES-'+mode;var cipher;if(options.decrypt){cipher=forge.cipher.createDecipher(algorithm,options.key);}else{cipher=forge.cipher.createCipher(algorithm,options.key);}// backwards compatible start API
var start=cipher.start;cipher.start=function(iv,options){// backwards compatibility: support second arg as output buffer
var output=null;if(options instanceof forge.util.ByteBuffer){output=options;options={};}options=options||{};options.output=output;options.iv=iv;start.call(cipher,options);};return cipher;}/***/},/* 13 */ /***/function(module,exports,__webpack_require__){/**
 * Password-Based Key-Derivation Function #2 implementation.
 *
 * See RFC 2898 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(14);__webpack_require__(4);__webpack_require__(1);var pkcs5=forge.pkcs5=forge.pkcs5||{};var crypto;if(forge.util.isNodejs&&!forge.options.usePureJavaScript){crypto=__webpack_require__(15);}/**
 * Derives a key from a password.
 *
 * @param p the password as a binary-encoded string of bytes.
 * @param s the salt as a binary-encoded string of bytes.
 * @param c the iteration count, a positive integer.
 * @param dkLen the intended length, in bytes, of the derived key,
 *          (max: 2^32 - 1) * hash length of the PRF.
 * @param [md] the message digest (or algorithm identifier as a string) to use
 *          in the PRF, defaults to SHA-1.
 * @param [callback(err, key)] presence triggers asynchronous version, called
 *          once the operation completes.
 *
 * @return the derived key, as a binary-encoded string of bytes, for the
 *           synchronous version (if no callback is specified).
 */module.exports=forge.pbkdf2=pkcs5.pbkdf2=function(p,s,c,dkLen,md,callback){if(typeof md==='function'){callback=md;md=null;}// use native implementation if possible and not disabled, note that
// some node versions only support SHA-1, others allow digest to be changed
if(forge.util.isNodejs&&!forge.options.usePureJavaScript&&crypto.pbkdf2&&(md===null||_typeof(md)!=='object')&&(crypto.pbkdf2Sync.length>4||!md||md==='sha1')){if(typeof md!=='string'){// default prf to SHA-1
md='sha1';}p=new Buffer(p,'binary');s=new Buffer(s,'binary');if(!callback){if(crypto.pbkdf2Sync.length===4){return crypto.pbkdf2Sync(p,s,c,dkLen).toString('binary');}return crypto.pbkdf2Sync(p,s,c,dkLen,md).toString('binary');}if(crypto.pbkdf2Sync.length===4){return crypto.pbkdf2(p,s,c,dkLen,function(err,key){if(err){return callback(err);}callback(null,key.toString('binary'));});}return crypto.pbkdf2(p,s,c,dkLen,md,function(err,key){if(err){return callback(err);}callback(null,key.toString('binary'));});}if(typeof md==='undefined'||md===null){// default prf to SHA-1
md='sha1';}if(typeof md==='string'){if(!(md in forge.md.algorithms)){throw new Error('Unknown hash algorithm: '+md);}md=forge.md[md].create();}var hLen=md.digestLength;/* 1. If dkLen > (2^32 - 1) * hLen, output "derived key too long" and
    stop. */if(dkLen>0xFFFFFFFF*hLen){var err=new Error('Derived key is too long.');if(callback){return callback(err);}throw err;}/* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:

    len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */var len=Math.ceil(dkLen/hLen);var r=dkLen-(len-1)*hLen;/* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:

    T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),

    where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:

    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c

    where

    u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).

    Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */var prf=forge.hmac.create();prf.start(md,p);var dk='';var xor,u_c,u_c1;// sync version
if(!callback){for(var i=1;i<=len;++i){// PRF(P, S || INT(i)) (first iteration)
prf.start(null,null);prf.update(s);prf.update(forge.util.int32ToBytes(i));xor=u_c1=prf.digest().getBytes();// PRF(P, u_{c-1}) (other iterations)
for(var j=2;j<=c;++j){prf.start(null,null);prf.update(u_c1);u_c=prf.digest().getBytes();// F(p, s, c, i)
xor=forge.util.xorBytes(xor,u_c,hLen);u_c1=u_c;}/* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:

        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */dk+=i<len?xor:xor.substr(0,r);}/* 5. Output the derived key DK. */return dk;}// async version
var i=1,j;function outer(){if(i>len){// done
return callback(null,dk);}// PRF(P, S || INT(i)) (first iteration)
prf.start(null,null);prf.update(s);prf.update(forge.util.int32ToBytes(i));xor=u_c1=prf.digest().getBytes();// PRF(P, u_{c-1}) (other iterations)
j=2;inner();}function inner(){if(j<=c){prf.start(null,null);prf.update(u_c1);u_c=prf.digest().getBytes();// F(p, s, c, i)
xor=forge.util.xorBytes(xor,u_c,hLen);u_c1=u_c;++j;return forge.util.setImmediate(inner);}/* 4. Concatenate the blocks and extract the first dkLen octets to
      produce a derived key DK:

      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */dk+=i<len?xor:xor.substr(0,r);++i;outer();}outer();};/***/},/* 14 */ /***/function(module,exports,__webpack_require__){/**
 * Hash-based Message Authentication Code implementation. Requires a message
 * digest object that can be obtained, for example, from forge.md.sha1 or
 * forge.md.md5.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);/* HMAC API */var hmac=module.exports=forge.hmac=forge.hmac||{};/**
 * Creates an HMAC object that uses the given message digest object.
 *
 * @return an HMAC object.
 */hmac.create=function(){// the hmac key to use
var _key=null;// the message digest to use
var _md=null;// the inner padding
var _ipadding=null;// the outer padding
var _opadding=null;// hmac context
var ctx={};/**
   * Starts or restarts the HMAC with the given key and message digest.
   *
   * @param md the message digest to use, null to reuse the previous one,
   *           a string to use builtin 'sha1', 'md5', 'sha256'.
   * @param key the key to use as a string, array of bytes, byte buffer,
   *           or null to reuse the previous key.
   */ctx.start=function(md,key){if(md!==null){if(typeof md==='string'){// create builtin message digest
md=md.toLowerCase();if(md in forge.md.algorithms){_md=forge.md.algorithms[md].create();}else{throw new Error('Unknown hash algorithm "'+md+'"');}}else{// store message digest
_md=md;}}if(key===null){// reuse previous key
key=_key;}else{if(typeof key==='string'){// convert string into byte buffer
key=forge.util.createBuffer(key);}else if(forge.util.isArray(key)){// convert byte array into byte buffer
var tmp=key;key=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){key.putByte(tmp[i]);}}// if key is longer than blocksize, hash it
var keylen=key.length();if(keylen>_md.blockLength){_md.start();_md.update(key.bytes());key=_md.digest();}// mix key into inner and outer padding
// ipadding = [0x36 * blocksize] ^ key
// opadding = [0x5C * blocksize] ^ key
_ipadding=forge.util.createBuffer();_opadding=forge.util.createBuffer();keylen=key.length();for(var i=0;i<keylen;++i){var tmp=key.at(i);_ipadding.putByte(0x36^tmp);_opadding.putByte(0x5C^tmp);}// if key is shorter than blocksize, add additional padding
if(keylen<_md.blockLength){var tmp=_md.blockLength-keylen;for(var i=0;i<tmp;++i){_ipadding.putByte(0x36);_opadding.putByte(0x5C);}}_key=key;_ipadding=_ipadding.bytes();_opadding=_opadding.bytes();}// digest is done like so: hash(opadding | hash(ipadding | message))
// prepare to do inner hash
// hash(ipadding | message)
_md.start();_md.update(_ipadding);};/**
   * Updates the HMAC with the given message bytes.
   *
   * @param bytes the bytes to update with.
   */ctx.update=function(bytes){_md.update(bytes);};/**
   * Produces the Message Authentication Code (MAC).
   *
   * @return a byte buffer containing the digest value.
   */ctx.getMac=function(){// digest is done like so: hash(opadding | hash(ipadding | message))
// here we do the outer hashing
var inner=_md.digest().bytes();_md.start();_md.update(_opadding);_md.update(inner);return _md.digest();};// alias for getMac
ctx.digest=ctx.getMac;return ctx;};/***/},/* 15 */ /***/function(module,exports){/* (ignored) */ /***/},/* 16 */ /***/function(module,exports,__webpack_require__){// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.
// Basic JavaScript BN library - subset useful for RSA encryption.
/*
Licensing (LICENSE)
-------------------

This software is covered under the following copyright:
*/ /*
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */ /*
Address all questions regarding this license to:

  Tom Wu
  tjw@cs.Stanford.EDU
*/var forge=__webpack_require__(0);module.exports=forge.jsbn=forge.jsbn||{};// Bits per digit
var dbits;// JavaScript engine analysis
var canary=0xdeadbeefcafe;var j_lm=(canary&0xffffff)==0xefcafe;// (public) Constructor
function BigInteger(a,b,c){this.data=[];if(a!=null)if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b);}forge.jsbn.BigInteger=BigInteger;// return new, unset BigInteger
function nbi(){return new BigInteger(null);}// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this.data[i++]+w.data[j]+c;c=Math.floor(v/0x4000000);w.data[j++]=v&0x3ffffff;}return c;}// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n){var xl=x&0x7fff,xh=x>>15;while(--n>=0){var l=this.data[i]&0x7fff;var h=this.data[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);w.data[j++]=l&0x3fffffff;}return c;}// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n){var xl=x&0x3fff,xh=x>>14;while(--n>=0){var l=this.data[i]&0x3fff;var h=this.data[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&0x3fff)<<14)+w.data[j]+c;c=(l>>28)+(m>>14)+xh*h;w.data[j++]=l&0xfffffff;}return c;}// node.js (no browser)
if(typeof navigator==='undefined'){BigInteger.prototype.am=am3;dbits=28;}else if(j_lm&&navigator.appName=="Microsoft Internet Explorer"){BigInteger.prototype.am=am2;dbits=30;}else if(j_lm&&navigator.appName!="Netscape"){BigInteger.prototype.am=am1;dbits=26;}else{// Mozilla/Netscape seems to prefer am3
BigInteger.prototype.am=am3;dbits=28;}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=(1<<dbits)-1;BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;// Digit conversions
var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array();var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv){BI_RC[rr++]=vv;}rr="a".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}rr="A".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}function int2char(n){return BI_RM.charAt(n);}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];return c==null?-1:c;}// (protected) copy this to r
function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i){r.data[i]=this.data[i];}r.t=this.t;r.s=this.s;}// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this.data[0]=x;else if(x<-1)this.data[0]=x+this.DV;else this.t=0;}// return bigint initialized to value
function nbv(i){var r=nbi();r.fromInt(i);return r;}// (protected) set from string and radix
function bnpFromString(s,b){var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;// byte array
else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{this.fromRadix(s,b);return;}this.t=0;this.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&0xff:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue;}mi=false;if(sh==0)this.data[this.t++]=x;else if(sh+k>this.DB){this.data[this.t-1]|=(x&(1<<this.DB-sh)-1)<<sh;this.data[this.t++]=x>>this.DB-sh;}else this.data[this.t-1]|=x<<sh;sh+=k;if(sh>=this.DB)sh-=this.DB;}if(k==8&&(s[0]&0x80)!=0){this.s=-1;if(sh>0)this.data[this.t-1]|=(1<<this.DB-sh)-1<<sh;}this.clamp();if(mi)BigInteger.ZERO.subTo(this,this);}// (protected) clamp off excess high words
function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this.data[this.t-1]==c){--this.t;}}// (public) return string representation in given radix
function bnToString(b){if(this.s<0)return"-"+this.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return this.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=this.t;var p=this.DB-i*this.DB%k;if(i-->0){if(p<this.DB&&(d=this.data[i]>>p)>0){m=true;r=int2char(d);}while(i>=0){if(p<k){d=(this.data[i]&(1<<p)-1)<<k-p;d|=this.data[--i]>>(p+=this.DB-k);}else{d=this.data[i]>>(p-=k)&km;if(p<=0){p+=this.DB;--i;}}if(d>0)m=true;if(m)r+=int2char(d);}}return m?r:"0";}// (public) -this
function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,r);return r;}// (public) |this|
function bnAbs(){return this.s<0?this.negate():this;}// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0){if((r=this.data[i]-a.data[i])!=0)return r;}return 0;}// returns bit length of the integer x
function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16;}if((t=x>>8)!=0){x=t;r+=8;}if((t=x>>4)!=0){x=t;r+=4;}if((t=x>>2)!=0){x=t;r+=2;}if((t=x>>1)!=0){x=t;r+=1;}return r;}// (public) return the number of bits in "this"
function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this.data[this.t-1]^this.s&this.DM);}// (protected) r = this << n*DB
function bnpDLShiftTo(n,r){var i;for(i=this.t-1;i>=0;--i){r.data[i+n]=this.data[i];}for(i=n-1;i>=0;--i){r.data[i]=0;}r.t=this.t+n;r.s=this.s;}// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i){r.data[i-n]=this.data[i];}r.t=Math.max(this.t-n,0);r.s=this.s;}// (protected) r = this << n
function bnpLShiftTo(n,r){var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/this.DB),c=this.s<<bs&this.DM,i;for(i=this.t-1;i>=0;--i){r.data[i+ds+1]=this.data[i]>>cbs|c;c=(this.data[i]&bm)<<bs;}for(i=ds-1;i>=0;--i){r.data[i]=0;}r.data[ds]=c;r.t=this.t+ds+1;r.s=this.s;r.clamp();}// (protected) r = this >> n
function bnpRShiftTo(n,r){r.s=this.s;var ds=Math.floor(n/this.DB);if(ds>=this.t){r.t=0;return;}var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<bs)-1;r.data[0]=this.data[ds]>>bs;for(var i=ds+1;i<this.t;++i){r.data[i-ds-1]|=(this.data[i]&bm)<<cbs;r.data[i-ds]=this.data[i]>>bs;}if(bs>0)r.data[this.t-ds-1]|=(this.s&bm)<<cbs;r.t=this.t-ds;r.clamp();}// (protected) r = this - a
function bnpSubTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this.data[i]-a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}if(a.t<this.t){c-=a.s;while(i<this.t){c+=this.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=this.s;}else{c+=this.s;while(i<a.t){c-=a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c-=a.s;}r.s=c<0?-1:0;if(c<-1)r.data[i++]=this.DV+c;else if(c>0)r.data[i++]=c;r.t=i;r.clamp();}// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0){r.data[i]=0;}for(i=0;i<y.t;++i){r.data[i+x.t]=x.am(0,y.data[i],r,i,0,x.t);}r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r);}// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0){r.data[i]=0;}for(i=0;i<x.t-1;++i){var c=x.am(i,x.data[i],r,2*i,0,1);if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1))>=x.DV){r.data[i+x.t]-=x.DV;r.data[i+x.t+1]=1;}}if(r.t>0)r.data[r.t-1]+=x.am(i,x.data[i],r,2*i,0,1);r.s=0;r.clamp();}// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r){var pm=m.abs();if(pm.t<=0)return;var pt=this.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)this.copyTo(r);return;}if(r==null)r=nbi();var y=nbi(),ts=this.s,ms=m.s;var nsh=this.DB-nbits(pm.data[pm.t-1]);// normalize modulus
if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r);}else{pm.copyTo(y);pt.copyTo(r);}var ys=y.t;var y0=y.data[ys-1];if(y0==0)return;var yt=y0*(1<<this.F1)+(ys>1?y.data[ys-2]>>this.F2:0);var d1=this.FV/yt,d2=(1<<this.F1)/yt,e=1<<this.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r.data[r.t++]=1;r.subTo(t,r);}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);// "negative" y so we can replace sub with am later
while(y.t<ys){y.data[y.t++]=0;}while(--j>=0){// Estimate quotient digit
var qd=r.data[--i]==y0?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);if((r.data[i]+=y.am(0,qd,r,j,0,ys))<qd){// Try it out
y.dlShiftTo(j,t);r.subTo(t,r);while(r.data[i]<--qd){r.subTo(t,r);}}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q);}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);// Denormalize remainder
if(ts<0)BigInteger.ZERO.subTo(r,r);}// (public) this mod a
function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r;}// Modular reduction using "classic" algorithm
function Classic(m){this.m=m;}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x;}function cRevert(x){return x;}function cReduce(x){x.divRemTo(this.m,null,x);}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}function cSqrTo(x,r){x.squareTo(r);this.reduce(r);}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit(){if(this.t<1)return 0;var x=this.data[0];if((x&1)==0)return 0;var y=x&3;// y == 1/x mod 2^2
y=y*(2-(x&0xf)*y)&0xf;// y == 1/x mod 2^4
y=y*(2-(x&0xff)*y)&0xff;// y == 1/x mod 2^8
y=y*(2-((x&0xffff)*y&0xffff))&0xffff;// y == 1/x mod 2^16
// last step - calculate inverse mod DV directly;
// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
y=y*(2-x*y%this.DV)%this.DV;// y == 1/x mod 2^dbits
// we really want the negative inverse, and -DV < y < DV
return y>0?this.DV-y:-y;}// Montgomery reduction
function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&0x7fff;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t;}// xR mod m
function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r;}// x/R mod m
function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r;}// x = x/R mod m (HAC 14.32)
function montReduce(x){while(x.t<=this.mt2){// pad x so am has enough room later
x.data[x.t++]=0;}for(var i=0;i<this.m.t;++i){// faster way of calculating u0 = x.data[i]*mp mod DV
var j=x.data[i]&0x7fff;var u0=j*this.mpl+((j*this.mph+(x.data[i]>>15)*this.mpl&this.um)<<15)&x.DM;// use am to combine the multiply-shift-add into one call
j=i+this.m.t;x.data[j]+=this.m.am(0,u0,x,i,0,this.m.t);// propagate carry
while(x.data[j]>=x.DV){x.data[j]-=x.DV;x.data[++j]++;}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x);}// r = "x^2/R mod m"; x != r
function montSqrTo(x,r){x.squareTo(r);this.reduce(r);}// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;// (protected) true iff this is even
function bnpIsEven(){return(this.t>0?this.data[0]&1:this.s)==0;}// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z){if(e>0xffffffff||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t;}}return z.revert(r);}// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z);}// protected
BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;// public
BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;// "constants"
BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);// jsbn2 lib
//Copyright (c) 2005-2009  Tom Wu
//All Rights Reserved.
//See "LICENSE" for details (See jsbn.js for LICENSE).
//Extended JavaScript BN functions, required for RSA private ops.
//Version 1.1: new BigInteger("0", 10) returns "proper" zero
//(public)
function bnClone(){var r=nbi();this.copyTo(r);return r;}//(public) return value as integer
function bnIntValue(){if(this.s<0){if(this.t==1)return this.data[0]-this.DV;else if(this.t==0)return-1;}else if(this.t==1)return this.data[0];else if(this.t==0)return 0;// assumes 16 < DB < 32
return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0];}//(public) return value as byte
function bnByteValue(){return this.t==0?this.s:this.data[0]<<24>>24;}//(public) return value as short (assumes DB>=16)
function bnShortValue(){return this.t==0?this.s:this.data[0]<<16>>16;}//(protected) return x s.t. r^x < DV
function bnpChunkSize(r){return Math.floor(Math.LN2*this.DB/Math.log(r));}//(public) 0 if this == 0, 1 if this > 0
function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this.data[0]<=0)return 0;else return 1;}//(protected) convert to radix string
function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z);}return z.intValue().toString(b)+r;}//(protected) convert from radix string
function bnpFromRadix(s,b){this.fromInt(0);if(b==null)b=10;var cs=this.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&this.signum()==0)mi=true;continue;}w=b*w+x;if(++j>=cs){this.dMultiply(d);this.dAddOffset(w,0);j=0;w=0;}}if(j>0){this.dMultiply(Math.pow(b,j));this.dAddOffset(w,0);}if(mi)BigInteger.ZERO.subTo(this,this);}//(protected) alternate constructor
function bnpFromNumber(a,b,c){if("number"==typeof b){// new BigInteger(int,int,RNG)
if(a<2)this.fromInt(1);else{this.fromNumber(a,c);if(!this.testBit(a-1))// force MSB set
this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);if(this.isEven())this.dAddOffset(1,0);// force odd
while(!this.isProbablePrime(b)){this.dAddOffset(2,0);if(this.bitLength()>a)this.subTo(BigInteger.ONE.shiftLeft(a-1),this);}}}else{// new BigInteger(int,RNG)
var x=new Array(),t=a&7;x.length=(a>>3)+1;b.nextBytes(x);if(t>0)x[0]&=(1<<t)-1;else x[0]=0;this.fromString(x,256);}}//(public) convert to bigendian byte array
function bnToByteArray(){var i=this.t,r=new Array();r[0]=this.s;var p=this.DB-i*this.DB%8,d,k=0;if(i-->0){if(p<this.DB&&(d=this.data[i]>>p)!=(this.s&this.DM)>>p)r[k++]=d|this.s<<this.DB-p;while(i>=0){if(p<8){d=(this.data[i]&(1<<p)-1)<<8-p;d|=this.data[--i]>>(p+=this.DB-8);}else{d=this.data[i]>>(p-=8)&0xff;if(p<=0){p+=this.DB;--i;}}if((d&0x80)!=0)d|=-256;if(k==0&&(this.s&0x80)!=(d&0x80))++k;if(k>0||d!=this.s)r[k++]=d;}}return r;}function bnEquals(a){return this.compareTo(a)==0;}function bnMin(a){return this.compareTo(a)<0?this:a;}function bnMax(a){return this.compareTo(a)>0?this:a;}//(protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r){var i,f,m=Math.min(a.t,this.t);for(i=0;i<m;++i){r.data[i]=op(this.data[i],a.data[i]);}if(a.t<this.t){f=a.s&this.DM;for(i=m;i<this.t;++i){r.data[i]=op(this.data[i],f);}r.t=this.t;}else{f=this.s&this.DM;for(i=m;i<a.t;++i){r.data[i]=op(f,a.data[i]);}r.t=a.t;}r.s=op(this.s,a.s);r.clamp();}//(public) this & a
function op_and(x,y){return x&y;}function bnAnd(a){var r=nbi();this.bitwiseTo(a,op_and,r);return r;}//(public) this | a
function op_or(x,y){return x|y;}function bnOr(a){var r=nbi();this.bitwiseTo(a,op_or,r);return r;}//(public) this ^ a
function op_xor(x,y){return x^y;}function bnXor(a){var r=nbi();this.bitwiseTo(a,op_xor,r);return r;}//(public) this & ~a
function op_andnot(x,y){return x&~y;}function bnAndNot(a){var r=nbi();this.bitwiseTo(a,op_andnot,r);return r;}//(public) ~this
function bnNot(){var r=nbi();for(var i=0;i<this.t;++i){r.data[i]=this.DM&~this.data[i];}r.t=this.t;r.s=~this.s;return r;}//(public) this << n
function bnShiftLeft(n){var r=nbi();if(n<0)this.rShiftTo(-n,r);else this.lShiftTo(n,r);return r;}//(public) this >> n
function bnShiftRight(n){var r=nbi();if(n<0)this.lShiftTo(-n,r);else this.rShiftTo(n,r);return r;}//return index of lowest 1-bit in x, x < 2^31
function lbit(x){if(x==0)return-1;var r=0;if((x&0xffff)==0){x>>=16;r+=16;}if((x&0xff)==0){x>>=8;r+=8;}if((x&0xf)==0){x>>=4;r+=4;}if((x&3)==0){x>>=2;r+=2;}if((x&1)==0)++r;return r;}//(public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit(){for(var i=0;i<this.t;++i){if(this.data[i]!=0)return i*this.DB+lbit(this.data[i]);}if(this.s<0)return this.t*this.DB;return-1;}//return number of 1 bits in x
function cbit(x){var r=0;while(x!=0){x&=x-1;++r;}return r;}//(public) return number of set bits
function bnBitCount(){var r=0,x=this.s&this.DM;for(var i=0;i<this.t;++i){r+=cbit(this.data[i]^x);}return r;}//(public) true iff nth bit is set
function bnTestBit(n){var j=Math.floor(n/this.DB);if(j>=this.t)return this.s!=0;return(this.data[j]&1<<n%this.DB)!=0;}//(protected) this op (1<<n)
function bnpChangeBit(n,op){var r=BigInteger.ONE.shiftLeft(n);this.bitwiseTo(r,op,r);return r;}//(public) this | (1<<n)
function bnSetBit(n){return this.changeBit(n,op_or);}//(public) this & ~(1<<n)
function bnClearBit(n){return this.changeBit(n,op_andnot);}//(public) this ^ (1<<n)
function bnFlipBit(n){return this.changeBit(n,op_xor);}//(protected) r = this + a
function bnpAddTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this.data[i]+a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}if(a.t<this.t){c+=a.s;while(i<this.t){c+=this.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=this.s;}else{c+=this.s;while(i<a.t){c+=a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=a.s;}r.s=c<0?-1:0;if(c>0)r.data[i++]=c;else if(c<-1)r.data[i++]=this.DV+c;r.t=i;r.clamp();}//(public) this + a
function bnAdd(a){var r=nbi();this.addTo(a,r);return r;}//(public) this - a
function bnSubtract(a){var r=nbi();this.subTo(a,r);return r;}//(public) this * a
function bnMultiply(a){var r=nbi();this.multiplyTo(a,r);return r;}//(public) this / a
function bnDivide(a){var r=nbi();this.divRemTo(a,r,null);return r;}//(public) this % a
function bnRemainder(a){var r=nbi();this.divRemTo(a,null,r);return r;}//(public) [this/a,this%a]
function bnDivideAndRemainder(a){var q=nbi(),r=nbi();this.divRemTo(a,q,r);return new Array(q,r);}//(protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n){this.data[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp();}//(protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w){this.data[this.t++]=0;}this.data[w]+=n;while(this.data[w]>=this.DV){this.data[w]-=this.DV;if(++w>=this.t)this.data[this.t++]=0;++this.data[w];}}//A "null" reducer
function NullExp(){}function nNop(x){return x;}function nMulTo(x,y,r){x.multiplyTo(y,r);}function nSqrTo(x,r){x.squareTo(r);}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;//(public) this^e
function bnPow(e){return this.exp(e,new NullExp());}//(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r){var i=Math.min(this.t+a.t,n);r.s=0;// assumes a,this >= 0
r.t=i;while(i>0){r.data[--i]=0;}var j;for(j=r.t-this.t;i<j;++i){r.data[i+this.t]=this.am(0,a.data[i],r,i,0,this.t);}for(j=Math.min(a.t,n);i<j;++i){this.am(0,a.data[i],r,i,0,n-i);}r.clamp();}//(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r){--n;var i=r.t=this.t+a.t-n;r.s=0;// assumes a,this >= 0
while(--i>=0){r.data[i]=0;}for(i=Math.max(n-this.t,0);i<a.t;++i){r.data[this.t+i-n]=this.am(n-i,a.data[i],r,0,0,this.t+i-n);}r.clamp();r.drShiftTo(1,r);}//Barrett modular reduction
function Barrett(m){// setup Barrett
this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*m.t,this.r2);this.mu=this.r2.divide(m);this.m=m;}function barrettConvert(x){if(x.s<0||x.t>2*this.m.t)return x.mod(this.m);else if(x.compareTo(this.m)<0)return x;else{var r=nbi();x.copyTo(r);this.reduce(r);return r;}}function barrettRevert(x){return x;}//x = x mod m (HAC 14.42)
function barrettReduce(x){x.drShiftTo(this.m.t-1,this.r2);if(x.t>this.m.t+1){x.t=this.m.t+1;x.clamp();}this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(x.compareTo(this.r2)<0){x.dAddOffset(1,this.m.t+1);}x.subTo(this.r2,x);while(x.compareTo(this.m)>=0){x.subTo(this.m,x);}}//r = x^2 mod m; x != r
function barrettSqrTo(x,r){x.squareTo(r);this.reduce(r);}//r = x*y mod m; x,y != r
function barrettMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;//(public) this^e % m (HAC 14.85)
function bnModPow(e,m){var i=e.bitLength(),k,r=nbv(1),z;if(i<=0)return r;else if(i<18)k=1;else if(i<48)k=3;else if(i<144)k=4;else if(i<768)k=5;else k=6;if(i<8)z=new Classic(m);else if(m.isEven())z=new Barrett(m);else z=new Montgomery(m);// precomputation
var g=new Array(),n=3,k1=k-1,km=(1<<k)-1;g[1]=z.convert(this);if(k>1){var g2=nbi();z.sqrTo(g[1],g2);while(n<=km){g[n]=nbi();z.mulTo(g2,g[n-2],g[n]);n+=2;}}var j=e.t-1,w,is1=true,r2=nbi(),t;i=nbits(e.data[j])-1;while(j>=0){if(i>=k1)w=e.data[j]>>i-k1&km;else{w=(e.data[j]&(1<<i+1)-1)<<k1-i;if(j>0)w|=e.data[j-1]>>this.DB+i-k1;}n=k;while((w&1)==0){w>>=1;--n;}if((i-=n)<0){i+=this.DB;--j;}if(is1){// ret == 1, don't bother squaring or multiplying it
g[w].copyTo(r);is1=false;}else{while(n>1){z.sqrTo(r,r2);z.sqrTo(r2,r);n-=2;}if(n>0)z.sqrTo(r,r2);else{t=r;r=r2;r2=t;}z.mulTo(r2,g[w],r);}while(j>=0&&(e.data[j]&1<<i)==0){z.sqrTo(r,r2);t=r;r=r2;r2=t;if(--i<0){i=this.DB-1;--j;}}}return z.revert(r);}//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a){var x=this.s<0?this.negate():this.clone();var y=a.s<0?a.negate():a.clone();if(x.compareTo(y)<0){var t=x;x=y;y=t;}var i=x.getLowestSetBit(),g=y.getLowestSetBit();if(g<0)return x;if(i<g)g=i;if(g>0){x.rShiftTo(g,x);y.rShiftTo(g,y);}while(x.signum()>0){if((i=x.getLowestSetBit())>0)x.rShiftTo(i,x);if((i=y.getLowestSetBit())>0)y.rShiftTo(i,y);if(x.compareTo(y)>=0){x.subTo(y,x);x.rShiftTo(1,x);}else{y.subTo(x,y);y.rShiftTo(1,y);}}if(g>0)y.lShiftTo(g,y);return y;}//(protected) this % n, n < 2^26
function bnpModInt(n){if(n<=0)return 0;var d=this.DV%n,r=this.s<0?n-1:0;if(this.t>0)if(d==0)r=this.data[0]%n;else for(var i=this.t-1;i>=0;--i){r=(d*r+this.data[i])%n;}return r;}//(public) 1/this % m (HAC 14.61)
function bnModInverse(m){var ac=m.isEven();if(this.isEven()&&ac||m.signum()==0)return BigInteger.ZERO;var u=m.clone(),v=this.clone();var a=nbv(1),b=nbv(0),c=nbv(0),d=nbv(1);while(u.signum()!=0){while(u.isEven()){u.rShiftTo(1,u);if(ac){if(!a.isEven()||!b.isEven()){a.addTo(this,a);b.subTo(m,b);}a.rShiftTo(1,a);}else if(!b.isEven())b.subTo(m,b);b.rShiftTo(1,b);}while(v.isEven()){v.rShiftTo(1,v);if(ac){if(!c.isEven()||!d.isEven()){c.addTo(this,c);d.subTo(m,d);}c.rShiftTo(1,c);}else if(!d.isEven())d.subTo(m,d);d.rShiftTo(1,d);}if(u.compareTo(v)>=0){u.subTo(v,u);if(ac)a.subTo(c,a);b.subTo(d,b);}else{v.subTo(u,v);if(ac)c.subTo(a,c);d.subTo(b,d);}}if(v.compareTo(BigInteger.ONE)!=0)return BigInteger.ZERO;if(d.compareTo(m)>=0)return d.subtract(m);if(d.signum()<0)d.addTo(m,d);else return d;if(d.signum()<0)return d.add(m);else return d;}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];var lplim=(1<<26)/lowprimes[lowprimes.length-1];//(public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t){var i,x=this.abs();if(x.t==1&&x.data[0]<=lowprimes[lowprimes.length-1]){for(i=0;i<lowprimes.length;++i){if(x.data[0]==lowprimes[i])return true;}return false;}if(x.isEven())return false;i=1;while(i<lowprimes.length){var m=lowprimes[i],j=i+1;while(j<lowprimes.length&&m<lplim){m*=lowprimes[j++];}m=x.modInt(m);while(i<j){if(m%lowprimes[i++]==0)return false;}}return x.millerRabin(t);}//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t){var n1=this.subtract(BigInteger.ONE);var k=n1.getLowestSetBit();if(k<=0)return false;var r=n1.shiftRight(k);var prng=bnGetPrng();var a;for(var i=0;i<t;++i){// select witness 'a' at random from between 1 and n1
do{a=new BigInteger(this.bitLength(),prng);}while(a.compareTo(BigInteger.ONE)<=0||a.compareTo(n1)>=0);var y=a.modPow(r,this);if(y.compareTo(BigInteger.ONE)!=0&&y.compareTo(n1)!=0){var j=1;while(j++<k&&y.compareTo(n1)!=0){y=y.modPowInt(2,this);if(y.compareTo(BigInteger.ONE)==0)return false;}if(y.compareTo(n1)!=0)return false;}}return true;}// get pseudo random number generator
function bnGetPrng(){// create prng with api that matches BigInteger secure random
return{// x is an array to fill with bytes
nextBytes:function nextBytes(x){for(var i=0;i<x.length;++i){x[i]=Math.floor(Math.random()*0x0100);}}};}//protected
BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.fromNumber=bnpFromNumber;BigInteger.prototype.bitwiseTo=bnpBitwiseTo;BigInteger.prototype.changeBit=bnpChangeBit;BigInteger.prototype.addTo=bnpAddTo;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger.prototype.modInt=bnpModInt;BigInteger.prototype.millerRabin=bnpMillerRabin;//public
BigInteger.prototype.clone=bnClone;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.byteValue=bnByteValue;BigInteger.prototype.shortValue=bnShortValue;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.toByteArray=bnToByteArray;BigInteger.prototype.equals=bnEquals;BigInteger.prototype.min=bnMin;BigInteger.prototype.max=bnMax;BigInteger.prototype.and=bnAnd;BigInteger.prototype.or=bnOr;BigInteger.prototype.xor=bnXor;BigInteger.prototype.andNot=bnAndNot;BigInteger.prototype.not=bnNot;BigInteger.prototype.shiftLeft=bnShiftLeft;BigInteger.prototype.shiftRight=bnShiftRight;BigInteger.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger.prototype.bitCount=bnBitCount;BigInteger.prototype.testBit=bnTestBit;BigInteger.prototype.setBit=bnSetBit;BigInteger.prototype.clearBit=bnClearBit;BigInteger.prototype.flipBit=bnFlipBit;BigInteger.prototype.add=bnAdd;BigInteger.prototype.subtract=bnSubtract;BigInteger.prototype.multiply=bnMultiply;BigInteger.prototype.divide=bnDivide;BigInteger.prototype.remainder=bnRemainder;BigInteger.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger.prototype.modPow=bnModPow;BigInteger.prototype.modInverse=bnModInverse;BigInteger.prototype.pow=bnPow;BigInteger.prototype.gcd=bnGCD;BigInteger.prototype.isProbablePrime=bnIsProbablePrime;//BigInteger interfaces not implemented in jsbn:
//BigInteger(int signum, byte[] magnitude)
//double doubleValue()
//float floatValue()
//int hashCode()
//long longValue()
//static BigInteger valueOf(long val)
/***/},/* 17 */ /***/function(module,exports,__webpack_require__){/**
 * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);var sha1=module.exports=forge.sha1=forge.sha1||{};forge.md.sha1=forge.md.algorithms.sha1=sha1;/**
 * Creates a SHA-1 message digest object.
 *
 * @return a message digest object.
 */sha1.create=function(){// do initialization as necessary
if(!_initialized){_init();}// SHA-1 state contains five 32-bit integers
var _state=null;// input buffer
var _input=forge.util.createBuffer();// used for word storage
var _w=new Array(80);// message digest object
var md={algorithm:'sha1',blockLength:64,digestLength:20,// 56-bit length of message so far (does not including padding)
messageLength:0,// true message length
fullMessageLength:null,// size of message length in bytes
messageLengthSize:8};/**
   * Starts the digest.
   *
   * @return this digest object.
   */md.start=function(){// up to 56-bit message length for convenience
md.messageLength=0;// full message length (set md.messageLength64 for backwards-compatibility)
md.fullMessageLength=md.messageLength64=[];var int32s=md.messageLengthSize/4;for(var i=0;i<int32s;++i){md.fullMessageLength.push(0);}_input=forge.util.createBuffer();_state={h0:0x67452301,h1:0xEFCDAB89,h2:0x98BADCFE,h3:0x10325476,h4:0xC3D2E1F0};return md;};// start digest automatically for first time
md.start();/**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */md.update=function(msg,encoding){if(encoding==='utf8'){msg=forge.util.encodeUtf8(msg);}// update message length
var len=msg.length;md.messageLength+=len;len=[len/0x100000000>>>0,len>>>0];for(var i=md.fullMessageLength.length-1;i>=0;--i){md.fullMessageLength[i]+=len[1];len[1]=len[0]+(md.fullMessageLength[i]/0x100000000>>>0);md.fullMessageLength[i]=md.fullMessageLength[i]>>>0;len[0]=len[1]/0x100000000>>>0;}// add bytes to input buffer
_input.putBytes(msg);// process bytes
_update(_state,_w,_input);// compact input buffer every 2K or if empty
if(_input.read>2048||_input.length()===0){_input.compact();}return md;};/**
    * Produces the digest.
    *
    * @return a byte buffer containing the digest value.
    */md.digest=function(){/* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */var finalBlock=forge.util.createBuffer();finalBlock.putBytes(_input.bytes());// compute remaining size to be digested (include message length size)
var remaining=md.fullMessageLength[md.fullMessageLength.length-1]+md.messageLengthSize;// add padding for overflow blockSize - overflow
// _padding starts with 1 byte with first bit is set (byte value 128), then
// there may be up to (blockSize - 1) other pad bytes
var overflow=remaining&md.blockLength-1;finalBlock.putBytes(_padding.substr(0,md.blockLength-overflow));// serialize message length in bits in big-endian order; since length
// is stored in bytes we multiply by 8 and add carry from next int
var next,carry;var bits=md.fullMessageLength[0]*8;for(var i=0;i<md.fullMessageLength.length-1;++i){next=md.fullMessageLength[i+1]*8;carry=next/0x100000000>>>0;bits+=carry;finalBlock.putInt32(bits>>>0);bits=next>>>0;}finalBlock.putInt32(bits);var s2={h0:_state.h0,h1:_state.h1,h2:_state.h2,h3:_state.h3,h4:_state.h4};_update(s2,_w,finalBlock);var rval=forge.util.createBuffer();rval.putInt32(s2.h0);rval.putInt32(s2.h1);rval.putInt32(s2.h2);rval.putInt32(s2.h3);rval.putInt32(s2.h4);return rval;};return md;};// sha-1 padding bytes not initialized yet
var _padding=null;var _initialized=false;/**
 * Initializes the constant tables.
 */function _init(){// create padding
_padding=String.fromCharCode(128);_padding+=forge.util.fillString(String.fromCharCode(0x00),64);// now initialized
_initialized=true;}/**
 * Updates a SHA-1 state with the given byte buffer.
 *
 * @param s the SHA-1 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */function _update(s,w,bytes){// consume 512 bit (64 byte) chunks
var t,a,b,c,d,e,f,i;var len=bytes.length();while(len>=64){// the w array will be populated with sixteen 32-bit big-endian words
// and then extended into 80 32-bit words according to SHA-1 algorithm
// and for 32-79 using Max Locktyukhin's optimization
// initialize hash value for this chunk
a=s.h0;b=s.h1;c=s.h2;d=s.h3;e=s.h4;// round 1
for(i=0;i<16;++i){t=bytes.getInt32();w[i]=t;f=d^b&(c^d);t=(a<<5|a>>>27)+f+e+0x5A827999+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}for(;i<20;++i){t=w[i-3]^w[i-8]^w[i-14]^w[i-16];t=t<<1|t>>>31;w[i]=t;f=d^b&(c^d);t=(a<<5|a>>>27)+f+e+0x5A827999+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 2
for(;i<32;++i){t=w[i-3]^w[i-8]^w[i-14]^w[i-16];t=t<<1|t>>>31;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0x6ED9EBA1+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}for(;i<40;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0x6ED9EBA1+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 3
for(;i<60;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b&c|d&(b^c);t=(a<<5|a>>>27)+f+e+0x8F1BBCDC+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 4
for(;i<80;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0xCA62C1D6+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// update hash state
s.h0=s.h0+a|0;s.h1=s.h1+b|0;s.h2=s.h2+c|0;s.h3=s.h3+d|0;s.h4=s.h4+e|0;len-=64;}}/***/},/* 18 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of X.509 and related components (such as
 * Certification Signing Requests) of a Public Key Infrastructure.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The ASN.1 representation of an X.509v3 certificate is as follows
 * (see RFC 2459):
 *
 * Certificate ::= SEQUENCE {
 *   tbsCertificate       TBSCertificate,
 *   signatureAlgorithm   AlgorithmIdentifier,
 *   signatureValue       BIT STRING
 * }
 *
 * TBSCertificate ::= SEQUENCE {
 *   version         [0]  EXPLICIT Version DEFAULT v1,
 *   serialNumber         CertificateSerialNumber,
 *   signature            AlgorithmIdentifier,
 *   issuer               Name,
 *   validity             Validity,
 *   subject              Name,
 *   subjectPublicKeyInfo SubjectPublicKeyInfo,
 *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   extensions      [3]  EXPLICIT Extensions OPTIONAL
 *                        -- If present, version shall be v3
 * }
 *
 * Version ::= INTEGER  { v1(0), v2(1), v3(2) }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * Name ::= CHOICE {
 *   // only one possible choice for now
 *   RDNSequence
 * }
 *
 * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 *
 * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
 *
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type     AttributeType,
 *   value    AttributeValue
 * }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY DEFINED BY AttributeType
 *
 * Validity ::= SEQUENCE {
 *   notBefore      Time,
 *   notAfter       Time
 * }
 *
 * Time ::= CHOICE {
 *   utcTime        UTCTime,
 *   generalTime    GeneralizedTime
 * }
 *
 * UniqueIdentifier ::= BIT STRING
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm            AlgorithmIdentifier,
 *   subjectPublicKey     BIT STRING
 * }
 *
 * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
 *
 * Extension ::= SEQUENCE {
 *   extnID      OBJECT IDENTIFIER,
 *   critical    BOOLEAN DEFAULT FALSE,
 *   extnValue   OCTET STRING
 * }
 *
 * The only key algorithm currently supported for PKI is RSA.
 *
 * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
 *
 * PKCS#10 v1.7 describes certificate signing requests:
 *
 * CertificationRequestInfo:
 *
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes{{ CRIAttributes }}
 * }
 *
 * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
 *
 * CRIAttributes  ATTRIBUTE  ::= {
 *   ... -- add any locally defined attributes here -- }
 *
 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
 *   type   ATTRIBUTE.&id({IOSet}),
 *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
 * }
 *
 * CertificationRequest ::= SEQUENCE {
 *   certificationRequestInfo CertificationRequestInfo,
 *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
 *   signature          BIT STRING
 * }
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(2);__webpack_require__(12);__webpack_require__(4);__webpack_require__(30);__webpack_require__(3);__webpack_require__(8);__webpack_require__(19);__webpack_require__(6);__webpack_require__(1);// shortcut for asn.1 API
var asn1=forge.asn1;/* Public Key Infrastructure (PKI) implementation. */var pki=module.exports=forge.pki=forge.pki||{};var oids=pki.oids;// short name OID mappings
var _shortNames={};_shortNames['CN']=oids['commonName'];_shortNames['commonName']='CN';_shortNames['C']=oids['countryName'];_shortNames['countryName']='C';_shortNames['L']=oids['localityName'];_shortNames['localityName']='L';_shortNames['ST']=oids['stateOrProvinceName'];_shortNames['stateOrProvinceName']='ST';_shortNames['O']=oids['organizationName'];_shortNames['organizationName']='O';_shortNames['OU']=oids['organizationalUnitName'];_shortNames['organizationalUnitName']='OU';_shortNames['E']=oids['emailAddress'];_shortNames['emailAddress']='E';// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator=forge.pki.rsa.publicKeyValidator;// validator for an X.509v3 certificate
var x509CertificateValidator={name:'Certificate',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Certificate.TBSCertificate',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'tbsCertificate',value:[{name:'Certificate.TBSCertificate.version',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.version.integer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certVersion'}]},{name:'Certificate.TBSCertificate.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certSerialNumber'},{name:'Certificate.TBSCertificate.signature',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Certificate.TBSCertificate.signature.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certinfoSignatureOid'},{name:'Certificate.TBSCertificate.signature.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'certinfoSignatureParams'}]},{name:'Certificate.TBSCertificate.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certIssuer'},{name:'Certificate.TBSCertificate.validity',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,// Note: UTC and generalized times may both appear so the capture
// names are based on their detected order, the names used below
// are only for the common case, which validity time really means
// "notBefore" and which means "notAfter" will be determined by order
value:[{// notBefore (Time) (UTC time case)
name:'Certificate.TBSCertificate.validity.notBefore (utc)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.UTCTIME,constructed:false,optional:true,capture:'certValidity1UTCTime'},{// notBefore (Time) (generalized time case)
name:'Certificate.TBSCertificate.validity.notBefore (generalized)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.GENERALIZEDTIME,constructed:false,optional:true,capture:'certValidity2GeneralizedTime'},{// notAfter (Time) (only UTC time is supported)
name:'Certificate.TBSCertificate.validity.notAfter (utc)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.UTCTIME,constructed:false,optional:true,capture:'certValidity3UTCTime'},{// notAfter (Time) (only UTC time is supported)
name:'Certificate.TBSCertificate.validity.notAfter (generalized)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.GENERALIZEDTIME,constructed:false,optional:true,capture:'certValidity4GeneralizedTime'}]},{// Name (subject) (RDNSequence)
name:'Certificate.TBSCertificate.subject',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certSubject'},// SubjectPublicKeyInfo
publicKeyValidator,{// issuerUniqueID (optional)
name:'Certificate.TBSCertificate.issuerUniqueID',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.issuerUniqueID.id',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,// TODO: support arbitrary bit length ids
captureBitStringValue:'certIssuerUniqueId'}]},{// subjectUniqueID (optional)
name:'Certificate.TBSCertificate.subjectUniqueID',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:2,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.subjectUniqueID.id',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,// TODO: support arbitrary bit length ids
captureBitStringValue:'certSubjectUniqueId'}]},{// Extensions (optional)
name:'Certificate.TBSCertificate.extensions',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:3,constructed:true,captureAsn1:'certExtensions',optional:true}]},{// AlgorithmIdentifier (signature algorithm)
name:'Certificate.signatureAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// algorithm
name:'Certificate.signatureAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certSignatureOid'},{name:'Certificate.TBSCertificate.signature.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'certSignatureParams'}]},{// SignatureValue
name:'Certificate.signatureValue',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,captureBitStringValue:'certSignature'}]};var rsassaPssParameterValidator={name:'rsapss',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'rsapss.hashAlgorithm',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,value:[{name:'rsapss.hashAlgorithm.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.SEQUENCE,constructed:true,optional:true,value:[{name:'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'hashOid'/* parameter block omitted, for SHA1 NULL anyhow. */}]}]},{name:'rsapss.maskGenAlgorithm',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.SEQUENCE,constructed:true,optional:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'maskGenOid'},{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'maskGenHashOid'/* parameter block omitted, for SHA1 NULL anyhow. */}]}]}]},{name:'rsapss.saltLength',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:2,optional:true,value:[{name:'rsapss.saltLength.saltLength',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.INTEGER,constructed:false,capture:'saltLength'}]},{name:'rsapss.trailerField',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:3,optional:true,value:[{name:'rsapss.trailer.trailer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.INTEGER,constructed:false,capture:'trailer'}]}]};// validator for a CertificationRequestInfo structure
var certificationRequestInfoValidator={name:'CertificationRequestInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certificationRequestInfo',value:[{name:'CertificationRequestInfo.integer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certificationRequestInfoVersion'},{// Name (subject) (RDNSequence)
name:'CertificationRequestInfo.subject',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certificationRequestInfoSubject'},// SubjectPublicKeyInfo
publicKeyValidator,{name:'CertificationRequestInfo.attributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,capture:'certificationRequestInfoAttributes',value:[{name:'CertificationRequestInfo.attributes',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'CertificationRequestInfo.attributes.type',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false},{name:'CertificationRequestInfo.attributes.value',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true}]}]}]};// validator for a CertificationRequest structure
var certificationRequestValidator={name:'CertificationRequest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'csr',value:[certificationRequestInfoValidator,{// AlgorithmIdentifier (signature algorithm)
name:'CertificationRequest.signatureAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// algorithm
name:'CertificationRequest.signatureAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'csrSignatureOid'},{name:'CertificationRequest.signatureAlgorithm.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'csrSignatureParams'}]},{// signature
name:'CertificationRequest.signature',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,captureBitStringValue:'csrSignature'}]};/**
 * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
 * sets into an array with objects that have type and value properties.
 *
 * @param rdn the RDNSequence to convert.
 * @param md a message digest to append type and value to if provided.
 */pki.RDNAttributesAsArray=function(rdn,md){var rval=[];// each value in 'rdn' in is a SET of RelativeDistinguishedName
var set,attr,obj;for(var si=0;si<rdn.value.length;++si){// get the RelativeDistinguishedName set
set=rdn.value[si];// each value in the SET is an AttributeTypeAndValue sequence
// containing first a type (an OID) and second a value (defined by
// the OID)
for(var i=0;i<set.value.length;++i){obj={};attr=set.value[i];obj.type=asn1.derToOid(attr.value[0].value);obj.value=attr.value[1].value;obj.valueTagClass=attr.value[1].type;// if the OID is known, get its name and short name
if(obj.type in oids){obj.name=oids[obj.type];if(obj.name in _shortNames){obj.shortName=_shortNames[obj.name];}}if(md){md.update(obj.type);md.update(obj.value);}rval.push(obj);}}return rval;};/**
 * Converts ASN.1 CRIAttributes into an array with objects that have type and
 * value properties.
 *
 * @param attributes the CRIAttributes to convert.
 */pki.CRIAttributesAsArray=function(attributes){var rval=[];// each value in 'attributes' in is a SEQUENCE with an OID and a SET
for(var si=0;si<attributes.length;++si){// get the attribute sequence
var seq=attributes[si];// each value in the SEQUENCE containing first a type (an OID) and
// second a set of values (defined by the OID)
var type=asn1.derToOid(seq.value[0].value);var values=seq.value[1].value;for(var vi=0;vi<values.length;++vi){var obj={};obj.type=type;obj.value=values[vi].value;obj.valueTagClass=values[vi].type;// if the OID is known, get its name and short name
if(obj.type in oids){obj.name=oids[obj.type];if(obj.name in _shortNames){obj.shortName=_shortNames[obj.name];}}// parse extensions
if(obj.type===oids.extensionRequest){obj.extensions=[];for(var ei=0;ei<obj.value.length;++ei){obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));}}rval.push(obj);}}return rval;};/**
 * Gets an issuer or subject attribute from its name, type, or short name.
 *
 * @param obj the issuer or subject object.
 * @param options a short name string or an object with:
 *          shortName the short name for the attribute.
 *          name the name for the attribute.
 *          type the type for the attribute.
 *
 * @return the attribute.
 */function _getAttribute(obj,options){if(typeof options==='string'){options={shortName:options};}var rval=null;var attr;for(var i=0;rval===null&&i<obj.attributes.length;++i){attr=obj.attributes[i];if(options.type&&options.type===attr.type){rval=attr;}else if(options.name&&options.name===attr.name){rval=attr;}else if(options.shortName&&options.shortName===attr.shortName){rval=attr;}}return rval;}/**
 * Converts signature parameters from ASN.1 structure.
 *
 * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
 * no parameters.
 *
 * RSASSA-PSS-params  ::=  SEQUENCE  {
 *   hashAlgorithm      [0] HashAlgorithm DEFAULT
 *                             sha1Identifier,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
 *                             mgf1SHA1Identifier,
 *   saltLength         [2] INTEGER DEFAULT 20,
 *   trailerField       [3] INTEGER DEFAULT 1
 * }
 *
 * HashAlgorithm  ::=  AlgorithmIdentifier
 *
 * MaskGenAlgorithm  ::=  AlgorithmIdentifier
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * @param oid The OID specifying the signature algorithm
 * @param obj The ASN.1 structure holding the parameters
 * @param fillDefaults Whether to use return default values where omitted
 * @return signature parameter object
 */var _readSignatureParameters=function _readSignatureParameters(oid,obj,fillDefaults){var params={};if(oid!==oids['RSASSA-PSS']){return params;}if(fillDefaults){params={hash:{algorithmOid:oids['sha1']},mgf:{algorithmOid:oids['mgf1'],hash:{algorithmOid:oids['sha1']}},saltLength:20};}var capture={};var errors=[];if(!asn1.validate(obj,rsassaPssParameterValidator,capture,errors)){var error=new Error('Cannot read RSASSA-PSS parameter block.');error.errors=errors;throw error;}if(capture.hashOid!==undefined){params.hash=params.hash||{};params.hash.algorithmOid=asn1.derToOid(capture.hashOid);}if(capture.maskGenOid!==undefined){params.mgf=params.mgf||{};params.mgf.algorithmOid=asn1.derToOid(capture.maskGenOid);params.mgf.hash=params.mgf.hash||{};params.mgf.hash.algorithmOid=asn1.derToOid(capture.maskGenHashOid);}if(capture.saltLength!==undefined){params.saltLength=capture.saltLength.charCodeAt(0);}return params;};/**
 * Converts an X.509 certificate from PEM format.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. This will scan the TBSCertificate part of the ASN.1
 * object while it is converted so it doesn't need to be converted back
 * to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certificate.
 */pki.certificateFromPem=function(pem,computeHash,strict){var msg=forge.pem.decode(pem)[0];if(msg.type!=='CERTIFICATE'&&msg.type!=='X509 CERTIFICATE'&&msg.type!=='TRUSTED CERTIFICATE'){var error=new Error('Could not convert certificate from PEM; PEM header type '+'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert certificate from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body,strict);return pki.certificateFromAsn1(obj,computeHash);};/**
 * Converts an X.509 certificate to PEM format.
 *
 * @param cert the certificate.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certificate.
 */pki.certificateToPem=function(cert,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'CERTIFICATE',body:asn1.toDer(pki.certificateToAsn1(cert)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts an RSA public key from PEM format.
 *
 * @param pem the PEM-formatted public key.
 *
 * @return the public key.
 */pki.publicKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='PUBLIC KEY'&&msg.type!=='RSA PUBLIC KEY'){var error=new Error('Could not convert public key from PEM; PEM header '+'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert public key from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body);return pki.publicKeyFromAsn1(obj);};/**
 * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */pki.publicKeyToPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'PUBLIC KEY',body:asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts an RSA public key to PEM format (using an RSAPublicKey).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */pki.publicKeyToRSAPublicKeyPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'RSA PUBLIC KEY',body:asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Gets a fingerprint for the given public key.
 *
 * @param options the options to use.
 *          [md] the message digest object to use (defaults to forge.md.sha1).
 *          [type] the type of fingerprint, such as 'RSAPublicKey',
 *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
 *          [encoding] an alternative output encoding, such as 'hex'
 *            (defaults to none, outputs a byte buffer).
 *          [delimiter] the delimiter to use between bytes for 'hex' encoded
 *            output, eg: ':' (defaults to none).
 *
 * @return the fingerprint as a byte buffer or other encoding based on options.
 */pki.getPublicKeyFingerprint=function(key,options){options=options||{};var md=options.md||forge.md.sha1.create();var type=options.type||'RSAPublicKey';var bytes;switch(type){case'RSAPublicKey':bytes=asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();break;case'SubjectPublicKeyInfo':bytes=asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();break;default:throw new Error('Unknown fingerprint type "'+options.type+'".');}// hash public key bytes
md.start();md.update(bytes);var digest=md.digest();if(options.encoding==='hex'){var hex=digest.toHex();if(options.delimiter){return hex.match(/.{2}/g).join(options.delimiter);}return hex;}else if(options.encoding==='binary'){return digest.getBytes();}else if(options.encoding){throw new Error('Unknown encoding "'+options.encoding+'".');}return digest;};/**
 * Converts a PKCS#10 certification request (CSR) from PEM format.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. This will scan the CertificationRequestInfo part of
 * the ASN.1 object while it is converted so it doesn't need to be converted
 * back to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certification request (CSR).
 */pki.certificationRequestFromPem=function(pem,computeHash,strict){var msg=forge.pem.decode(pem)[0];if(msg.type!=='CERTIFICATE REQUEST'){var error=new Error('Could not convert certification request from PEM; '+'PEM header type is not "CERTIFICATE REQUEST".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert certification request from PEM; '+'PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body,strict);return pki.certificationRequestFromAsn1(obj,computeHash);};/**
 * Converts a PKCS#10 certification request (CSR) to PEM format.
 *
 * @param csr the certification request.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certification request.
 */pki.certificationRequestToPem=function(csr,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'CERTIFICATE REQUEST',body:asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Creates an empty X.509v3 RSA certificate.
 *
 * @return the certificate.
 */pki.createCertificate=function(){var cert={};cert.version=0x02;cert.serialNumber='00';cert.signatureOid=null;cert.signature=null;cert.siginfo={};cert.siginfo.algorithmOid=null;cert.validity={};cert.validity.notBefore=new Date();cert.validity.notAfter=new Date();cert.issuer={};cert.issuer.getField=function(sn){return _getAttribute(cert.issuer,sn);};cert.issuer.addField=function(attr){_fillMissingFields([attr]);cert.issuer.attributes.push(attr);};cert.issuer.attributes=[];cert.issuer.hash=null;cert.subject={};cert.subject.getField=function(sn){return _getAttribute(cert.subject,sn);};cert.subject.addField=function(attr){_fillMissingFields([attr]);cert.subject.attributes.push(attr);};cert.subject.attributes=[];cert.subject.hash=null;cert.extensions=[];cert.publicKey=null;cert.md=null;/**
   * Sets the subject of this certificate.
   *
   * @param attrs the array of subject attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */cert.setSubject=function(attrs,uniqueId){// set new attributes, clear hash
_fillMissingFields(attrs);cert.subject.attributes=attrs;delete cert.subject.uniqueId;if(uniqueId){// TODO: support arbitrary bit length ids
cert.subject.uniqueId=uniqueId;}cert.subject.hash=null;};/**
   * Sets the issuer of this certificate.
   *
   * @param attrs the array of issuer attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */cert.setIssuer=function(attrs,uniqueId){// set new attributes, clear hash
_fillMissingFields(attrs);cert.issuer.attributes=attrs;delete cert.issuer.uniqueId;if(uniqueId){// TODO: support arbitrary bit length ids
cert.issuer.uniqueId=uniqueId;}cert.issuer.hash=null;};/**
   * Sets the extensions of this certificate.
   *
   * @param exts the array of extensions to use.
   */cert.setExtensions=function(exts){for(var i=0;i<exts.length;++i){_fillMissingExtensionFields(exts[i],{cert:cert});}// set new extensions
cert.extensions=exts;};/**
   * Gets an extension by its name or id.
   *
   * @param options the name to use or an object with:
   *          name the name to use.
   *          id the id to use.
   *
   * @return the extension or null if not found.
   */cert.getExtension=function(options){if(typeof options==='string'){options={name:options};}var rval=null;var ext;for(var i=0;rval===null&&i<cert.extensions.length;++i){ext=cert.extensions[i];if(options.id&&ext.id===options.id){rval=ext;}else if(options.name&&ext.name===options.name){rval=ext;}}return rval;};/**
   * Signs this certificate using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */cert.sign=function(key,md){// TODO: get signature OID from private key
cert.md=md||forge.md.sha1.create();var algorithmOid=oids[cert.md.algorithm+'WithRSAEncryption'];if(!algorithmOid){var error=new Error('Could not compute certificate digest. '+'Unknown message digest algorithm OID.');error.algorithm=cert.md.algorithm;throw error;}cert.signatureOid=cert.siginfo.algorithmOid=algorithmOid;// get TBSCertificate, convert to DER
cert.tbsCertificate=pki.getTBSCertificate(cert);var bytes=asn1.toDer(cert.tbsCertificate);// digest and sign
cert.md.update(bytes.getBytes());cert.signature=key.sign(cert.md);};/**
   * Attempts verify the signature on the passed certificate using this
   * certificate's public key.
   *
   * @param child the certificate to verify.
   *
   * @return true if verified, false if not.
   */cert.verify=function(child){var rval=false;if(!cert.issued(child)){var issuer=child.issuer;var subject=cert.subject;var error=new Error('The parent certificate did not issue the given child '+'certificate; the child certificate\'s issuer does not match the '+'parent\'s subject.');error.expectedIssuer=issuer.attributes;error.actualIssuer=subject.attributes;throw error;}var md=child.md;if(md===null){// check signature OID for supported signature types
if(child.signatureOid in oids){var oid=oids[child.signatureOid];switch(oid){case'sha1WithRSAEncryption':md=forge.md.sha1.create();break;case'md5WithRSAEncryption':md=forge.md.md5.create();break;case'sha256WithRSAEncryption':md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':md=forge.md.sha512.create();break;case'RSASSA-PSS':md=forge.md.sha256.create();break;}}if(md===null){var error=new Error('Could not compute certificate digest. '+'Unknown signature OID.');error.signatureOid=child.signatureOid;throw error;}// produce DER formatted TBSCertificate and digest it
var tbsCertificate=child.tbsCertificate||pki.getTBSCertificate(child);var bytes=asn1.toDer(tbsCertificate);md.update(bytes.getBytes());}if(md!==null){var scheme;switch(child.signatureOid){case oids.sha1WithRSAEncryption:scheme=undefined;/* use PKCS#1 v1.5 padding scheme */break;case oids['RSASSA-PSS']:var hash,mgf;/* initialize mgf */hash=oids[child.signatureParameters.mgf.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported MGF hash function.');error.oid=child.signatureParameters.mgf.hash.algorithmOid;error.name=hash;throw error;}mgf=oids[child.signatureParameters.mgf.algorithmOid];if(mgf===undefined||forge.mgf[mgf]===undefined){var error=new Error('Unsupported MGF function.');error.oid=child.signatureParameters.mgf.algorithmOid;error.name=mgf;throw error;}mgf=forge.mgf[mgf].create(forge.md[hash].create());/* initialize hash function */hash=oids[child.signatureParameters.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){throw{message:'Unsupported RSASSA-PSS hash function.',oid:child.signatureParameters.hash.algorithmOid,name:hash};}scheme=forge.pss.create(forge.md[hash].create(),mgf,child.signatureParameters.saltLength);break;}// verify signature on cert using public key
rval=cert.publicKey.verify(md.digest().getBytes(),child.signature,scheme);}return rval;};/**
   * Returns true if this certificate's issuer matches the passed
   * certificate's subject. Note that no signature check is performed.
   *
   * @param parent the certificate to check.
   *
   * @return true if this certificate's issuer matches the passed certificate's
   *         subject.
   */cert.isIssuer=function(parent){var rval=false;var i=cert.issuer;var s=parent.subject;// compare hashes if present
if(i.hash&&s.hash){rval=i.hash===s.hash;}else if(i.attributes.length===s.attributes.length){// all attributes are the same so issuer matches subject
rval=true;var iattr,sattr;for(var n=0;rval&&n<i.attributes.length;++n){iattr=i.attributes[n];sattr=s.attributes[n];if(iattr.type!==sattr.type||iattr.value!==sattr.value){// attribute mismatch
rval=false;}}}return rval;};/**
   * Returns true if this certificate's subject matches the issuer of the
   * given certificate). Note that not signature check is performed.
   *
   * @param child the certificate to check.
   *
   * @return true if this certificate's subject matches the passed
   *         certificate's issuer.
   */cert.issued=function(child){return child.isIssuer(cert);};/**
   * Generates the subjectKeyIdentifier for this certificate as byte buffer.
   *
   * @return the subjectKeyIdentifier for this certificate as byte buffer.
   */cert.generateSubjectKeyIdentifier=function(){/* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:

      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
        value of the BIT STRING subjectPublicKey (excluding the tag,
        length, and number of unused bits).

      (2) The keyIdentifier is composed of a four bit type field with
        the value 0100 followed by the least significant 60 bits of the
        SHA-1 hash of the value of the BIT STRING subjectPublicKey
        (excluding the tag, length, and number of unused bit string bits).
    */ // skipping the tag, length, and number of unused bits is the same
// as just using the RSAPublicKey (for RSA keys, which are the
// only ones supported)
return pki.getPublicKeyFingerprint(cert.publicKey,{type:'RSAPublicKey'});};/**
   * Verifies the subjectKeyIdentifier extension value for this certificate
   * against its public key. If no extension is found, false will be
   * returned.
   *
   * @return true if verified, false if not.
   */cert.verifySubjectKeyIdentifier=function(){var oid=oids['subjectKeyIdentifier'];for(var i=0;i<cert.extensions.length;++i){var ext=cert.extensions[i];if(ext.id===oid){var ski=cert.generateSubjectKeyIdentifier().getBytes();return forge.util.hexToBytes(ext.subjectKeyIdentifier)===ski;}}return false;};return cert;};/**
 * Converts an X.509v3 RSA certificate from an ASN.1 object.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
 * object needs to be scanned before the cert object is created.
 *
 * @param obj the asn1 representation of an X.509v3 RSA certificate.
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certificate.
 */pki.certificateFromAsn1=function(obj,computeHash){// validate certificate and capture data
var capture={};var errors=[];if(!asn1.validate(obj,x509CertificateValidator,capture,errors)){var error=new Error('Cannot read X.509 certificate. '+'ASN.1 object is not an X509v3 Certificate.');error.errors=errors;throw error;}// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){throw new Error('Cannot read public key. OID is not RSA.');}// create certificate
var cert=pki.createCertificate();cert.version=capture.certVersion?capture.certVersion.charCodeAt(0):0;var serial=forge.util.createBuffer(capture.certSerialNumber);cert.serialNumber=serial.toHex();cert.signatureOid=forge.asn1.derToOid(capture.certSignatureOid);cert.signatureParameters=_readSignatureParameters(cert.signatureOid,capture.certSignatureParams,true);cert.siginfo.algorithmOid=forge.asn1.derToOid(capture.certinfoSignatureOid);cert.siginfo.parameters=_readSignatureParameters(cert.siginfo.algorithmOid,capture.certinfoSignatureParams,false);cert.signature=capture.certSignature;var validity=[];if(capture.certValidity1UTCTime!==undefined){validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));}if(capture.certValidity2GeneralizedTime!==undefined){validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));}if(capture.certValidity3UTCTime!==undefined){validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));}if(capture.certValidity4GeneralizedTime!==undefined){validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));}if(validity.length>2){throw new Error('Cannot read notBefore/notAfter validity times; more '+'than two times were provided in the certificate.');}if(validity.length<2){throw new Error('Cannot read notBefore/notAfter validity times; they '+'were not provided as either UTCTime or GeneralizedTime.');}cert.validity.notBefore=validity[0];cert.validity.notAfter=validity[1];// keep TBSCertificate to preserve signature when exporting
cert.tbsCertificate=capture.tbsCertificate;if(computeHash){// check signature OID for supported signature types
cert.md=null;if(cert.signatureOid in oids){var oid=oids[cert.signatureOid];switch(oid){case'sha1WithRSAEncryption':cert.md=forge.md.sha1.create();break;case'md5WithRSAEncryption':cert.md=forge.md.md5.create();break;case'sha256WithRSAEncryption':cert.md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':cert.md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':cert.md=forge.md.sha512.create();break;case'RSASSA-PSS':cert.md=forge.md.sha256.create();break;}}if(cert.md===null){var error=new Error('Could not compute certificate digest. '+'Unknown signature OID.');error.signatureOid=cert.signatureOid;throw error;}// produce DER formatted TBSCertificate and digest it
var bytes=asn1.toDer(cert.tbsCertificate);cert.md.update(bytes.getBytes());}// handle issuer, build issuer message digest
var imd=forge.md.sha1.create();cert.issuer.getField=function(sn){return _getAttribute(cert.issuer,sn);};cert.issuer.addField=function(attr){_fillMissingFields([attr]);cert.issuer.attributes.push(attr);};cert.issuer.attributes=pki.RDNAttributesAsArray(capture.certIssuer,imd);if(capture.certIssuerUniqueId){cert.issuer.uniqueId=capture.certIssuerUniqueId;}cert.issuer.hash=imd.digest().toHex();// handle subject, build subject message digest
var smd=forge.md.sha1.create();cert.subject.getField=function(sn){return _getAttribute(cert.subject,sn);};cert.subject.addField=function(attr){_fillMissingFields([attr]);cert.subject.attributes.push(attr);};cert.subject.attributes=pki.RDNAttributesAsArray(capture.certSubject,smd);if(capture.certSubjectUniqueId){cert.subject.uniqueId=capture.certSubjectUniqueId;}cert.subject.hash=smd.digest().toHex();// handle extensions
if(capture.certExtensions){cert.extensions=pki.certificateExtensionsFromAsn1(capture.certExtensions);}else{cert.extensions=[];}// convert RSA public key from ASN.1
cert.publicKey=pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);return cert;};/**
 * Converts an ASN.1 extensions object (with extension sequences as its
 * values) into an array of extension objects with types and values.
 *
 * Supported extensions:
 *
 * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 * KeyUsage ::= BIT STRING {
 *   digitalSignature        (0),
 *   nonRepudiation          (1),
 *   keyEncipherment         (2),
 *   dataEncipherment        (3),
 *   keyAgreement            (4),
 *   keyCertSign             (5),
 *   cRLSign                 (6),
 *   encipherOnly            (7),
 *   decipherOnly            (8)
 * }
 *
 * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
 * BasicConstraints ::= SEQUENCE {
 *   cA                      BOOLEAN DEFAULT FALSE,
 *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
 * }
 *
 * subjectAltName EXTENSION ::= {
 *   SYNTAX GeneralNames
 *   IDENTIFIED BY id-ce-subjectAltName
 * }
 *
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 *
 * GeneralName ::= CHOICE {
 *   otherName      [0] INSTANCE OF OTHER-NAME,
 *   rfc822Name     [1] IA5String,
 *   dNSName        [2] IA5String,
 *   x400Address    [3] ORAddress,
 *   directoryName  [4] Name,
 *   ediPartyName   [5] EDIPartyName,
 *   uniformResourceIdentifier [6] IA5String,
 *   IPAddress      [7] OCTET STRING,
 *   registeredID   [8] OBJECT IDENTIFIER
 * }
 *
 * OTHER-NAME ::= TYPE-IDENTIFIER
 *
 * EDIPartyName ::= SEQUENCE {
 *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
 *   partyName    [1] DirectoryString {ub-name}
 * }
 *
 * @param exts the extensions ASN.1 with extension sequences to parse.
 *
 * @return the array.
 */pki.certificateExtensionsFromAsn1=function(exts){var rval=[];for(var i=0;i<exts.value.length;++i){// get extension sequence
var extseq=exts.value[i];for(var ei=0;ei<extseq.value.length;++ei){rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));}}return rval;};/**
 * Parses a single certificate extension from ASN.1.
 *
 * @param ext the extension in ASN.1 format.
 *
 * @return the parsed extension as an object.
 */pki.certificateExtensionFromAsn1=function(ext){// an extension has:
// [0] extnID      OBJECT IDENTIFIER
// [1] critical    BOOLEAN DEFAULT FALSE
// [2] extnValue   OCTET STRING
var e={};e.id=asn1.derToOid(ext.value[0].value);e.critical=false;if(ext.value[1].type===asn1.Type.BOOLEAN){e.critical=ext.value[1].value.charCodeAt(0)!==0x00;e.value=ext.value[2].value;}else{e.value=ext.value[1].value;}// if the oid is known, get its name
if(e.id in oids){e.name=oids[e.id];// handle key usage
if(e.name==='keyUsage'){// get value as BIT STRING
var ev=asn1.fromDer(e.value);var b2=0x00;var b3=0x00;if(ev.value.length>1){// skip first byte, just indicates unused bits which
// will be padded with 0s anyway
// get bytes with flag bits
b2=ev.value.charCodeAt(1);b3=ev.value.length>2?ev.value.charCodeAt(2):0;}// set flags
e.digitalSignature=(b2&0x80)===0x80;e.nonRepudiation=(b2&0x40)===0x40;e.keyEncipherment=(b2&0x20)===0x20;e.dataEncipherment=(b2&0x10)===0x10;e.keyAgreement=(b2&0x08)===0x08;e.keyCertSign=(b2&0x04)===0x04;e.cRLSign=(b2&0x02)===0x02;e.encipherOnly=(b2&0x01)===0x01;e.decipherOnly=(b3&0x80)===0x80;}else if(e.name==='basicConstraints'){// handle basic constraints
// get value as SEQUENCE
var ev=asn1.fromDer(e.value);// get cA BOOLEAN flag (defaults to false)
if(ev.value.length>0&&ev.value[0].type===asn1.Type.BOOLEAN){e.cA=ev.value[0].value.charCodeAt(0)!==0x00;}else{e.cA=false;}// get path length constraint
var value=null;if(ev.value.length>0&&ev.value[0].type===asn1.Type.INTEGER){value=ev.value[0].value;}else if(ev.value.length>1){value=ev.value[1].value;}if(value!==null){e.pathLenConstraint=asn1.derToInteger(value);}}else if(e.name==='extKeyUsage'){// handle extKeyUsage
// value is a SEQUENCE of OIDs
var ev=asn1.fromDer(e.value);for(var vi=0;vi<ev.value.length;++vi){var oid=asn1.derToOid(ev.value[vi].value);if(oid in oids){e[oids[oid]]=true;}else{e[oid]=true;}}}else if(e.name==='nsCertType'){// handle nsCertType
// get value as BIT STRING
var ev=asn1.fromDer(e.value);var b2=0x00;if(ev.value.length>1){// skip first byte, just indicates unused bits which
// will be padded with 0s anyway
// get bytes with flag bits
b2=ev.value.charCodeAt(1);}// set flags
e.client=(b2&0x80)===0x80;e.server=(b2&0x40)===0x40;e.email=(b2&0x20)===0x20;e.objsign=(b2&0x10)===0x10;e.reserved=(b2&0x08)===0x08;e.sslCA=(b2&0x04)===0x04;e.emailCA=(b2&0x02)===0x02;e.objCA=(b2&0x01)===0x01;}else if(e.name==='subjectAltName'||e.name==='issuerAltName'){// handle subjectAltName/issuerAltName
e.altNames=[];// ev is a SYNTAX SEQUENCE
var gn;var ev=asn1.fromDer(e.value);for(var n=0;n<ev.value.length;++n){// get GeneralName
gn=ev.value[n];var altName={type:gn.type,value:gn.value};e.altNames.push(altName);// Note: Support for types 1,2,6,7,8
switch(gn.type){// rfc822Name
case 1:// dNSName
case 2:// uniformResourceIdentifier (URI)
case 6:break;// IPAddress
case 7:// convert to IPv4/IPv6 string representation
altName.ip=forge.util.bytesToIP(gn.value);break;// registeredID
case 8:altName.oid=asn1.derToOid(gn.value);break;default:// unsupported
}}}else if(e.name==='subjectKeyIdentifier'){// value is an OCTETSTRING w/the hash of the key-type specific
// public key structure (eg: RSAPublicKey)
var ev=asn1.fromDer(e.value);e.subjectKeyIdentifier=forge.util.bytesToHex(ev.value);}}return e;};/**
 * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the CertificationRequestInfo part of the
 * ASN.1 object needs to be scanned before the csr object is created.
 *
 * @param obj the asn1 representation of a PKCS#10 certification request (CSR).
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certification request (CSR).
 */pki.certificationRequestFromAsn1=function(obj,computeHash){// validate certification request and capture data
var capture={};var errors=[];if(!asn1.validate(obj,certificationRequestValidator,capture,errors)){var error=new Error('Cannot read PKCS#10 certificate request. '+'ASN.1 object is not a PKCS#10 CertificationRequest.');error.errors=errors;throw error;}// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){throw new Error('Cannot read public key. OID is not RSA.');}// create certification request
var csr=pki.createCertificationRequest();csr.version=capture.csrVersion?capture.csrVersion.charCodeAt(0):0;csr.signatureOid=forge.asn1.derToOid(capture.csrSignatureOid);csr.signatureParameters=_readSignatureParameters(csr.signatureOid,capture.csrSignatureParams,true);csr.siginfo.algorithmOid=forge.asn1.derToOid(capture.csrSignatureOid);csr.siginfo.parameters=_readSignatureParameters(csr.siginfo.algorithmOid,capture.csrSignatureParams,false);csr.signature=capture.csrSignature;// keep CertificationRequestInfo to preserve signature when exporting
csr.certificationRequestInfo=capture.certificationRequestInfo;if(computeHash){// check signature OID for supported signature types
csr.md=null;if(csr.signatureOid in oids){var oid=oids[csr.signatureOid];switch(oid){case'sha1WithRSAEncryption':csr.md=forge.md.sha1.create();break;case'md5WithRSAEncryption':csr.md=forge.md.md5.create();break;case'sha256WithRSAEncryption':csr.md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':csr.md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':csr.md=forge.md.sha512.create();break;case'RSASSA-PSS':csr.md=forge.md.sha256.create();break;}}if(csr.md===null){var error=new Error('Could not compute certification request digest. '+'Unknown signature OID.');error.signatureOid=csr.signatureOid;throw error;}// produce DER formatted CertificationRequestInfo and digest it
var bytes=asn1.toDer(csr.certificationRequestInfo);csr.md.update(bytes.getBytes());}// handle subject, build subject message digest
var smd=forge.md.sha1.create();csr.subject.getField=function(sn){return _getAttribute(csr.subject,sn);};csr.subject.addField=function(attr){_fillMissingFields([attr]);csr.subject.attributes.push(attr);};csr.subject.attributes=pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject,smd);csr.subject.hash=smd.digest().toHex();// convert RSA public key from ASN.1
csr.publicKey=pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);// convert attributes from ASN.1
csr.getAttribute=function(sn){return _getAttribute(csr,sn);};csr.addAttribute=function(attr){_fillMissingFields([attr]);csr.attributes.push(attr);};csr.attributes=pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes||[]);return csr;};/**
 * Creates an empty certification request (a CSR or certificate signing
 * request). Once created, its public key and attributes can be set and then
 * it can be signed.
 *
 * @return the empty certification request.
 */pki.createCertificationRequest=function(){var csr={};csr.version=0x00;csr.signatureOid=null;csr.signature=null;csr.siginfo={};csr.siginfo.algorithmOid=null;csr.subject={};csr.subject.getField=function(sn){return _getAttribute(csr.subject,sn);};csr.subject.addField=function(attr){_fillMissingFields([attr]);csr.subject.attributes.push(attr);};csr.subject.attributes=[];csr.subject.hash=null;csr.publicKey=null;csr.attributes=[];csr.getAttribute=function(sn){return _getAttribute(csr,sn);};csr.addAttribute=function(attr){_fillMissingFields([attr]);csr.attributes.push(attr);};csr.md=null;/**
   * Sets the subject of this certification request.
   *
   * @param attrs the array of subject attributes to use.
   */csr.setSubject=function(attrs){// set new attributes
_fillMissingFields(attrs);csr.subject.attributes=attrs;csr.subject.hash=null;};/**
   * Sets the attributes of this certification request.
   *
   * @param attrs the array of attributes to use.
   */csr.setAttributes=function(attrs){// set new attributes
_fillMissingFields(attrs);csr.attributes=attrs;};/**
   * Signs this certification request using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */csr.sign=function(key,md){// TODO: get signature OID from private key
csr.md=md||forge.md.sha1.create();var algorithmOid=oids[csr.md.algorithm+'WithRSAEncryption'];if(!algorithmOid){var error=new Error('Could not compute certification request digest. '+'Unknown message digest algorithm OID.');error.algorithm=csr.md.algorithm;throw error;}csr.signatureOid=csr.siginfo.algorithmOid=algorithmOid;// get CertificationRequestInfo, convert to DER
csr.certificationRequestInfo=pki.getCertificationRequestInfo(csr);var bytes=asn1.toDer(csr.certificationRequestInfo);// digest and sign
csr.md.update(bytes.getBytes());csr.signature=key.sign(csr.md);};/**
   * Attempts verify the signature on the passed certification request using
   * its public key.
   *
   * A CSR that has been exported to a file in PEM format can be verified using
   * OpenSSL using this command:
   *
   * openssl req -in <the-csr-pem-file> -verify -noout -text
   *
   * @return true if verified, false if not.
   */csr.verify=function(){var rval=false;var md=csr.md;if(md===null){// check signature OID for supported signature types
if(csr.signatureOid in oids){// TODO: create DRY `OID to md` function
var oid=oids[csr.signatureOid];switch(oid){case'sha1WithRSAEncryption':md=forge.md.sha1.create();break;case'md5WithRSAEncryption':md=forge.md.md5.create();break;case'sha256WithRSAEncryption':md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':md=forge.md.sha512.create();break;case'RSASSA-PSS':md=forge.md.sha256.create();break;}}if(md===null){var error=new Error('Could not compute certification request digest. '+'Unknown signature OID.');error.signatureOid=csr.signatureOid;throw error;}// produce DER formatted CertificationRequestInfo and digest it
var cri=csr.certificationRequestInfo||pki.getCertificationRequestInfo(csr);var bytes=asn1.toDer(cri);md.update(bytes.getBytes());}if(md!==null){var scheme;switch(csr.signatureOid){case oids.sha1WithRSAEncryption:/* use PKCS#1 v1.5 padding scheme */break;case oids['RSASSA-PSS']:var hash,mgf;/* initialize mgf */hash=oids[csr.signatureParameters.mgf.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported MGF hash function.');error.oid=csr.signatureParameters.mgf.hash.algorithmOid;error.name=hash;throw error;}mgf=oids[csr.signatureParameters.mgf.algorithmOid];if(mgf===undefined||forge.mgf[mgf]===undefined){var error=new Error('Unsupported MGF function.');error.oid=csr.signatureParameters.mgf.algorithmOid;error.name=mgf;throw error;}mgf=forge.mgf[mgf].create(forge.md[hash].create());/* initialize hash function */hash=oids[csr.signatureParameters.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported RSASSA-PSS hash function.');error.oid=csr.signatureParameters.hash.algorithmOid;error.name=hash;throw error;}scheme=forge.pss.create(forge.md[hash].create(),mgf,csr.signatureParameters.saltLength);break;}// verify signature on csr using its public key
rval=csr.publicKey.verify(md.digest().getBytes(),csr.signature,scheme);}return rval;};return csr;};/**
 * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
 *
 * @param obj the subject or issuer (distinguished name).
 *
 * @return the ASN.1 RDNSequence.
 */function _dnToAsn1(obj){// create an empty RDNSequence
var rval=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// iterate over attributes
var attr,set;var attrs=obj.attributes;for(var i=0;i<attrs.length;++i){attr=attrs[i];var value=attr.value;// reuse tag class for attribute value if available
var valueTagClass=asn1.Type.PRINTABLESTRING;if('valueTagClass'in attr){valueTagClass=attr.valueTagClass;if(valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(value);}// FIXME: handle more encodings
}// create a RelativeDistinguishedName set
// each value in the set is an AttributeTypeAndValue first
// containing the type (an OID) and second the value
set=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AttributeType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(attr.type).getBytes()),// AttributeValue
asn1.create(asn1.Class.UNIVERSAL,valueTagClass,false,value)])]);rval.value.push(set);}return rval;}/**
 * Gets all printable attributes (typically of an issuer or subject) in a
 * simplified JSON format for display.
 *
 * @param attrs the attributes.
 *
 * @return the JSON for display.
 */function _getAttributesAsJson(attrs){var rval={};for(var i=0;i<attrs.length;++i){var attr=attrs[i];if(attr.shortName&&(attr.valueTagClass===asn1.Type.UTF8||attr.valueTagClass===asn1.Type.PRINTABLESTRING||attr.valueTagClass===asn1.Type.IA5STRING)){var value=attr.value;if(attr.valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(attr.value);}if(!(attr.shortName in rval)){rval[attr.shortName]=value;}else if(forge.util.isArray(rval[attr.shortName])){rval[attr.shortName].push(value);}else{rval[attr.shortName]=[rval[attr.shortName],value];}}}return rval;}/**
 * Fills in missing fields in attributes.
 *
 * @param attrs the attributes to fill missing fields in.
 */function _fillMissingFields(attrs){var attr;for(var i=0;i<attrs.length;++i){attr=attrs[i];// populate missing name
if(typeof attr.name==='undefined'){if(attr.type&&attr.type in pki.oids){attr.name=pki.oids[attr.type];}else if(attr.shortName&&attr.shortName in _shortNames){attr.name=pki.oids[_shortNames[attr.shortName]];}}// populate missing type (OID)
if(typeof attr.type==='undefined'){if(attr.name&&attr.name in pki.oids){attr.type=pki.oids[attr.name];}else{var error=new Error('Attribute type not specified.');error.attribute=attr;throw error;}}// populate missing shortname
if(typeof attr.shortName==='undefined'){if(attr.name&&attr.name in _shortNames){attr.shortName=_shortNames[attr.name];}}// convert extensions to value
if(attr.type===oids.extensionRequest){attr.valueConstructed=true;attr.valueTagClass=asn1.Type.SEQUENCE;if(!attr.value&&attr.extensions){attr.value=[];for(var ei=0;ei<attr.extensions.length;++ei){attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));}}}if(typeof attr.value==='undefined'){var error=new Error('Attribute value not specified.');error.attribute=attr;throw error;}}}/**
 * Fills in missing fields in certificate extensions.
 *
 * @param e the extension.
 * @param [options] the options to use.
 *          [cert] the certificate the extensions are for.
 *
 * @return the extension.
 */function _fillMissingExtensionFields(e,options){options=options||{};// populate missing name
if(typeof e.name==='undefined'){if(e.id&&e.id in pki.oids){e.name=pki.oids[e.id];}}// populate missing id
if(typeof e.id==='undefined'){if(e.name&&e.name in pki.oids){e.id=pki.oids[e.name];}else{var error=new Error('Extension ID not specified.');error.extension=e;throw error;}}if(typeof e.value!=='undefined'){return e;}// handle missing value:
// value is a BIT STRING
if(e.name==='keyUsage'){// build flags
var unused=0;var b2=0x00;var b3=0x00;if(e.digitalSignature){b2|=0x80;unused=7;}if(e.nonRepudiation){b2|=0x40;unused=6;}if(e.keyEncipherment){b2|=0x20;unused=5;}if(e.dataEncipherment){b2|=0x10;unused=4;}if(e.keyAgreement){b2|=0x08;unused=3;}if(e.keyCertSign){b2|=0x04;unused=2;}if(e.cRLSign){b2|=0x02;unused=1;}if(e.encipherOnly){b2|=0x01;unused=0;}if(e.decipherOnly){b3|=0x80;unused=7;}// create bit string
var value=String.fromCharCode(unused);if(b3!==0){value+=String.fromCharCode(b2)+String.fromCharCode(b3);}else if(b2!==0){value+=String.fromCharCode(b2);}e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,value);}else if(e.name==='basicConstraints'){// basicConstraints is a SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// cA BOOLEAN flag defaults to false
if(e.cA){e.value.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BOOLEAN,false,String.fromCharCode(0xFF)));}if('pathLenConstraint'in e){e.value.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(e.pathLenConstraint).getBytes()));}}else if(e.name==='extKeyUsage'){// extKeyUsage is a SEQUENCE of OIDs
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;for(var key in e){if(e[key]!==true){continue;}// key is name in OID map
if(key in oids){seq.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids[key]).getBytes()));}else if(key.indexOf('.')!==-1){// assume key is an OID
seq.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(key).getBytes()));}}}else if(e.name==='nsCertType'){// nsCertType is a BIT STRING
// build flags
var unused=0;var b2=0x00;if(e.client){b2|=0x80;unused=7;}if(e.server){b2|=0x40;unused=6;}if(e.email){b2|=0x20;unused=5;}if(e.objsign){b2|=0x10;unused=4;}if(e.reserved){b2|=0x08;unused=3;}if(e.sslCA){b2|=0x04;unused=2;}if(e.emailCA){b2|=0x02;unused=1;}if(e.objCA){b2|=0x01;unused=0;}// create bit string
var value=String.fromCharCode(unused);if(b2!==0){value+=String.fromCharCode(b2);}e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,value);}else if(e.name==='subjectAltName'||e.name==='issuerAltName'){// SYNTAX SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var altName;for(var n=0;n<e.altNames.length;++n){altName=e.altNames[n];var value=altName.value;// handle IP
if(altName.type===7&&altName.ip){value=forge.util.bytesFromIP(altName.ip);if(value===null){var error=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');error.extension=e;throw error;}}else if(altName.type===8){// handle OID
if(altName.oid){value=asn1.oidToDer(asn1.oidToDer(altName.oid));}else{// deprecated ... convert value to OID
value=asn1.oidToDer(value);}}e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,altName.type,false,value));}}else if(e.name==='subjectKeyIdentifier'&&options.cert){var ski=options.cert.generateSubjectKeyIdentifier();e.subjectKeyIdentifier=ski.toHex();// OCTETSTRING w/digest
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,ski.getBytes());}else if(e.name==='authorityKeyIdentifier'&&options.cert){// SYNTAX SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;if(e.keyIdentifier){var keyIdentifier=e.keyIdentifier===true?options.cert.generateSubjectKeyIdentifier().getBytes():e.keyIdentifier;seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,false,keyIdentifier));}if(e.authorityCertIssuer){var authorityCertIssuer=[asn1.create(asn1.Class.CONTEXT_SPECIFIC,4,true,[_dnToAsn1(e.authorityCertIssuer===true?options.cert.issuer:e.authorityCertIssuer)])];seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,authorityCertIssuer));}if(e.serialNumber){var serialNumber=forge.util.hexToBytes(e.serialNumber===true?options.cert.serialNumber:e.serialNumber);seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,false,serialNumber));}}else if(e.name==='cRLDistributionPoints'){e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;// Create sub SEQUENCE of DistributionPointName
var subSeq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// Create fullName CHOICE
var fullNameGeneralNames=asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[]);var altName;for(var n=0;n<e.altNames.length;++n){altName=e.altNames[n];var value=altName.value;// handle IP
if(altName.type===7&&altName.ip){value=forge.util.bytesFromIP(altName.ip);if(value===null){var error=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');error.extension=e;throw error;}}else if(altName.type===8){// handle OID
if(altName.oid){value=asn1.oidToDer(asn1.oidToDer(altName.oid));}else{// deprecated ... convert value to OID
value=asn1.oidToDer(value);}}fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,altName.type,false,value));}// Add to the parent SEQUENCE
subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[fullNameGeneralNames]));seq.push(subSeq);}// ensure value has been defined by now
if(typeof e.value==='undefined'){var error=new Error('Extension value not specified.');error.extension=e;throw error;}return e;}/**
 * Convert signature parameters object to ASN.1
 *
 * @param {String} oid Signature algorithm OID
 * @param params The signature parametrs object
 * @return ASN.1 object representing signature parameters
 */function _signatureParametersToAsn1(oid,params){switch(oid){case oids['RSASSA-PSS']:var parts=[];if(params.hash.algorithmOid!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.hash.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')])]));}if(params.mgf.algorithmOid!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.mgf.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')])])]));}if(params.saltLength!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(params.saltLength).getBytes())]));}return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,parts);default:return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'');}}/**
 * Converts a certification request's attributes to an ASN.1 set of
 * CRIAttributes.
 *
 * @param csr certification request.
 *
 * @return the ASN.1 set of CRIAttributes.
 */function _CRIAttributesToAsn1(csr){// create an empty context-specific container
var rval=asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[]);// no attributes, return empty container
if(csr.attributes.length===0){return rval;}// each attribute has a sequence with a type and a set of values
var attrs=csr.attributes;for(var i=0;i<attrs.length;++i){var attr=attrs[i];var value=attr.value;// reuse tag class for attribute value if available
var valueTagClass=asn1.Type.UTF8;if('valueTagClass'in attr){valueTagClass=attr.valueTagClass;}if(valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(value);}var valueConstructed=false;if('valueConstructed'in attr){valueConstructed=attr.valueConstructed;}// FIXME: handle more encodings
// create a RelativeDistinguishedName set
// each value in the set is an AttributeTypeAndValue first
// containing the type (an OID) and second the value
var seq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AttributeType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(attr.type).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[// AttributeValue
asn1.create(asn1.Class.UNIVERSAL,valueTagClass,valueConstructed,value)])]);rval.value.push(seq);}return rval;}var jan_1_1950=new Date('1950-01-01T00:00:00Z');var jan_1_2050=new Date('2050-01-01T00:00:00Z');/**
 * Converts a Date object to ASN.1
 * Handles the different format before and after 1st January 2050
 *
 * @param date date object.
 *
 * @return the ASN.1 object representing the date.
 */function _dateToAsn1(date){if(date>=jan_1_1950&&date<jan_1_2050){return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.UTCTIME,false,asn1.dateToUtcTime(date));}else{return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.GENERALIZEDTIME,false,asn1.dateToGeneralizedTime(date));}}/**
 * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
 *
 * @param cert the certificate.
 *
 * @return the asn1 TBSCertificate.
 */pki.getTBSCertificate=function(cert){// TBSCertificate
var notBefore=_dateToAsn1(cert.validity.notBefore);var notAfter=_dateToAsn1(cert.validity.notAfter);var tbs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// integer
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(cert.version).getBytes())]),// serialNumber
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,forge.util.hexToBytes(cert.serialNumber)),// signature
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),// parameters
_signatureParametersToAsn1(cert.siginfo.algorithmOid,cert.siginfo.parameters)]),// issuer
_dnToAsn1(cert.issuer),// validity
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[notBefore,notAfter]),// subject
_dnToAsn1(cert.subject),// SubjectPublicKeyInfo
pki.publicKeyToAsn1(cert.publicKey)]);if(cert.issuer.uniqueId){// issuerUniqueID (optional)
tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,// TODO: support arbitrary bit length ids
String.fromCharCode(0x00)+cert.issuer.uniqueId)]));}if(cert.subject.uniqueId){// subjectUniqueID (optional)
tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,// TODO: support arbitrary bit length ids
String.fromCharCode(0x00)+cert.subject.uniqueId)]));}if(cert.extensions.length>0){// extensions (optional)
tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));}return tbs;};/**
 * Gets the ASN.1 CertificationRequestInfo part of a
 * PKCS#10 CertificationRequest.
 *
 * @param csr the certification request.
 *
 * @return the asn1 CertificationRequestInfo.
 */pki.getCertificationRequestInfo=function(csr){// CertificationRequestInfo
var cri=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(csr.version).getBytes()),// subject
_dnToAsn1(csr.subject),// SubjectPublicKeyInfo
pki.publicKeyToAsn1(csr.publicKey),// attributes
_CRIAttributesToAsn1(csr)]);return cri;};/**
 * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
 *
 * @param dn the DistinguishedName.
 *
 * @return the asn1 representation of a DistinguishedName.
 */pki.distinguishedNameToAsn1=function(dn){return _dnToAsn1(dn);};/**
 * Converts an X.509v3 RSA certificate to an ASN.1 object.
 *
 * @param cert the certificate.
 *
 * @return the asn1 representation of an X.509v3 RSA certificate.
 */pki.certificateToAsn1=function(cert){// prefer cached TBSCertificate over generating one
var tbsCertificate=cert.tbsCertificate||pki.getTBSCertificate(cert);// Certificate
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// TBSCertificate
tbsCertificate,// AlgorithmIdentifier (signature algorithm)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(cert.signatureOid).getBytes()),// parameters
_signatureParametersToAsn1(cert.signatureOid,cert.signatureParameters)]),// SignatureValue
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,String.fromCharCode(0x00)+cert.signature)]);};/**
 * Converts X.509v3 certificate extensions to ASN.1.
 *
 * @param exts the extensions to convert.
 *
 * @return the extensions in ASN.1 format.
 */pki.certificateExtensionsToAsn1=function(exts){// create top-level extension container
var rval=asn1.create(asn1.Class.CONTEXT_SPECIFIC,3,true,[]);// create extension sequence (stores a sequence for each extension)
var seq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);rval.value.push(seq);for(var i=0;i<exts.length;++i){seq.value.push(pki.certificateExtensionToAsn1(exts[i]));}return rval;};/**
 * Converts a single certificate extension to ASN.1.
 *
 * @param ext the extension to convert.
 *
 * @return the extension in ASN.1 format.
 */pki.certificateExtensionToAsn1=function(ext){// create a sequence for each extension
var extseq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// extnID (OID)
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(ext.id).getBytes()));// critical defaults to false
if(ext.critical){// critical BOOLEAN DEFAULT FALSE
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BOOLEAN,false,String.fromCharCode(0xFF)));}var value=ext.value;if(typeof ext.value!=='string'){// value is asn.1
value=asn1.toDer(value).getBytes();}// extnValue (OCTET STRING)
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,value));return extseq;};/**
 * Converts a PKCS#10 certification request to an ASN.1 object.
 *
 * @param csr the certification request.
 *
 * @return the asn1 representation of a certification request.
 */pki.certificationRequestToAsn1=function(csr){// prefer cached CertificationRequestInfo over generating one
var cri=csr.certificationRequestInfo||pki.getCertificationRequestInfo(csr);// Certificate
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// CertificationRequestInfo
cri,// AlgorithmIdentifier (signature algorithm)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(csr.signatureOid).getBytes()),// parameters
_signatureParametersToAsn1(csr.signatureOid,csr.signatureParameters)]),// signature
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,String.fromCharCode(0x00)+csr.signature)]);};/**
 * Creates a CA store.
 *
 * @param certs an optional array of certificate objects or PEM-formatted
 *          certificate strings to add to the CA store.
 *
 * @return the CA store.
 */pki.createCaStore=function(certs){// create CA store
var caStore={// stored certificates
certs:{}};/**
   * Gets the certificate that issued the passed certificate or its
   * 'parent'.
   *
   * @param cert the certificate to get the parent for.
   *
   * @return the parent certificate or null if none was found.
   */caStore.getIssuer=function(cert){var rval=getBySubject(cert.issuer);// see if there are multiple matches
/*if(forge.util.isArray(rval)) {
      // TODO: resolve multiple matches by checking
      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.
      // FIXME: or alternatively do authority key mapping
      // if possible (X.509v1 certs can't work?)
      throw new Error('Resolving multiple issuer matches not implemented yet.');
    }*/return rval;};/**
   * Adds a trusted certificate to the store.
   *
   * @param cert the certificate to add as a trusted certificate (either a
   *          pki.certificate object or a PEM-formatted certificate).
   */caStore.addCertificate=function(cert){// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}ensureSubjectHasHash(cert.subject);if(!caStore.hasCertificate(cert)){// avoid duplicate certificates in store
if(cert.subject.hash in caStore.certs){// subject hash already exists, append to array
var tmp=caStore.certs[cert.subject.hash];if(!forge.util.isArray(tmp)){tmp=[tmp];}tmp.push(cert);caStore.certs[cert.subject.hash]=tmp;}else{caStore.certs[cert.subject.hash]=cert;}}};/**
   * Checks to see if the given certificate is in the store.
   *
   * @param cert the certificate to check (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return true if the certificate is in the store, false if not.
   */caStore.hasCertificate=function(cert){// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}var match=getBySubject(cert.subject);if(!match){return false;}if(!forge.util.isArray(match)){match=[match];}// compare DER-encoding of certificates
var der1=asn1.toDer(pki.certificateToAsn1(cert)).getBytes();for(var i=0;i<match.length;++i){var der2=asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();if(der1===der2){return true;}}return false;};/**
   * Lists all of the certificates kept in the store.
   *
   * @return an array of all of the pki.certificate objects in the store.
   */caStore.listAllCertificates=function(){var certList=[];for(var hash in caStore.certs){if(caStore.certs.hasOwnProperty(hash)){var value=caStore.certs[hash];if(!forge.util.isArray(value)){certList.push(value);}else{for(var i=0;i<value.length;++i){certList.push(value[i]);}}}}return certList;};/**
   * Removes a certificate from the store.
   *
   * @param cert the certificate to remove (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return the certificate that was removed or null if the certificate
   *           wasn't in store.
   */caStore.removeCertificate=function(cert){var result;// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}ensureSubjectHasHash(cert.subject);if(!caStore.hasCertificate(cert)){return null;}var match=getBySubject(cert.subject);if(!forge.util.isArray(match)){result=caStore.certs[cert.subject.hash];delete caStore.certs[cert.subject.hash];return result;}// compare DER-encoding of certificates
var der1=asn1.toDer(pki.certificateToAsn1(cert)).getBytes();for(var i=0;i<match.length;++i){var der2=asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();if(der1===der2){result=match[i];match.splice(i,1);}}if(match.length===0){delete caStore.certs[cert.subject.hash];}return result;};function getBySubject(subject){ensureSubjectHasHash(subject);return caStore.certs[subject.hash]||null;}function ensureSubjectHasHash(subject){// produce subject hash if it doesn't exist
if(!subject.hash){var md=forge.md.sha1.create();subject.attributes=pki.RDNAttributesAsArray(_dnToAsn1(subject),md);subject.hash=md.digest().toHex();}}// auto-add passed in certs
if(certs){// parse PEM-formatted certificates as necessary
for(var i=0;i<certs.length;++i){var cert=certs[i];caStore.addCertificate(cert);}}return caStore;};/**
 * Certificate verification errors, based on TLS.
 */pki.certificateError={bad_certificate:'forge.pki.BadCertificate',unsupported_certificate:'forge.pki.UnsupportedCertificate',certificate_revoked:'forge.pki.CertificateRevoked',certificate_expired:'forge.pki.CertificateExpired',certificate_unknown:'forge.pki.CertificateUnknown',unknown_ca:'forge.pki.UnknownCertificateAuthority'};/**
 * Verifies a certificate chain against the given Certificate Authority store
 * with an optional custom verify callback.
 *
 * @param caStore a certificate store to verify against.
 * @param chain the certificate chain to verify, with the root or highest
 *          authority at the end (an array of certificates).
 * @param verify called for every certificate in the chain.
 *
 * The verify callback has the following signature:
 *
 * verified - Set to true if certificate was verified, otherwise the
 *   pki.certificateError for why the certificate failed.
 * depth - The current index in the chain, where 0 is the end point's cert.
 * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
 *   end point.
 *
 * The function returns true on success and on failure either the appropriate
 * pki.certificateError or an object with 'error' set to the appropriate
 * pki.certificateError and 'message' set to a custom error message.
 *
 * @return true if successful, error thrown if not.
 */pki.verifyCertificateChain=function(caStore,chain,verify){/* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate
    Section 6: Certification Path Validation
    See inline parentheticals related to this particular implementation.

    The primary goal of path validation is to verify the binding between
    a subject distinguished name or a subject alternative name and subject
    public key, as represented in the end entity certificate, based on the
    public key of the trust anchor. This requires obtaining a sequence of
    certificates that support that binding. That sequence should be provided
    in the passed 'chain'. The trust anchor should be in the given CA
    store. The 'end entity' certificate is the certificate provided by the
    end point (typically a server) and is the first in the chain.

    To meet this goal, the path validation process verifies, among other
    things, that a prospective certification path (a sequence of n
    certificates or a 'chain') satisfies the following conditions:

    (a) for all x in {1, ..., n-1}, the subject of certificate x is
          the issuer of certificate x+1;

    (b) certificate 1 is issued by the trust anchor;

    (c) certificate n is the certificate to be validated; and

    (d) for all x in {1, ..., n}, the certificate was valid at the
          time in question.

    Note that here 'n' is index 0 in the chain and 1 is the last certificate
    in the chain and it must be signed by a certificate in the connection's
    CA store.

    The path validation process also determines the set of certificate
    policies that are valid for this path, based on the certificate policies
    extension, policy mapping extension, policy constraints extension, and
    inhibit any-policy extension.

    Note: Policy mapping extension not supported (Not Required).

    Note: If the certificate has an unsupported critical extension, then it
    must be rejected.

    Note: A certificate is self-issued if the DNs that appear in the subject
    and issuer fields are identical and are not empty.

    The path validation algorithm assumes the following seven inputs are
    provided to the path processing logic. What this specific implementation
    will use is provided parenthetically:

    (a) a prospective certification path of length n (the 'chain')
    (b) the current date/time: ('now').
    (c) user-initial-policy-set: A set of certificate policy identifiers
          naming the policies that are acceptable to the certificate user.
          The user-initial-policy-set contains the special value any-policy
          if the user is not concerned about certificate policy
          (Not implemented. Any policy is accepted).
    (d) trust anchor information, describing a CA that serves as a trust
          anchor for the certification path. The trust anchor information
          includes:

      (1)  the trusted issuer name,
      (2)  the trusted public key algorithm,
      (3)  the trusted public key, and
      (4)  optionally, the trusted public key parameters associated
             with the public key.

      (Trust anchors are provided via certificates in the CA store).

      The trust anchor information may be provided to the path processing
      procedure in the form of a self-signed certificate. The trusted anchor
      information is trusted because it was delivered to the path processing
      procedure by some trustworthy out-of-band procedure. If the trusted
      public key algorithm requires parameters, then the parameters are
      provided along with the trusted public key (No parameters used in this
      implementation).

    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is
          allowed in the certification path.
          (Not implemented, no policy checking)

    (f) initial-explicit-policy, which indicates if the path must be valid
          for at least one of the certificate policies in the user-initial-
          policy-set.
          (Not implemented, no policy checking)

    (g) initial-any-policy-inhibit, which indicates whether the
          anyPolicy OID should be processed if it is included in a
          certificate.
          (Not implemented, so any policy is valid provided that it is
          not marked as critical) */ /* Basic Path Processing:

    For each certificate in the 'chain', the following is checked:

    1. The certificate validity period includes the current time.
    2. The certificate was signed by its parent (where the parent is either
       the next in the chain or from the CA store). Allow processing to
       continue to the next step if no parent is found but the certificate is
       in the CA store.
    3. TODO: The certificate has not been revoked.
    4. The certificate issuer name matches the parent's subject name.
    5. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is within one of the permitted subtrees of X.500 distinguished names
       and that each of the alternative names in the subjectAltName extension
       (critical or non-critical) is within one of the permitted subtrees for
       that name type.
    6. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is not within one of the excluded subtrees for X.500 distinguished
       names and none of the subjectAltName extension names are excluded for
       that name type.
    7. The other steps in the algorithm for basic path processing involve
       handling the policy extension which is not presently supported in this
       implementation. Instead, if a critical policy extension is found, the
       certificate is rejected as not supported.
    8. If the certificate is not the first or if its the only certificate in
       the chain (having no parent from the CA store or is self-signed) and it
       has a critical key usage extension, verify that the keyCertSign bit is
       set. If the key usage extension exists, verify that the basic
       constraints extension exists. If the basic constraints extension exists,
       verify that the cA flag is set. If pathLenConstraint is set, ensure that
       the number of certificates that precede in the chain (come earlier
       in the chain as implemented below), excluding the very first in the
       chain (typically the end-entity one), isn't greater than the
       pathLenConstraint. This constraint limits the number of intermediate
       CAs that may appear below a CA before only end-entity certificates
       may be issued. */ // copy cert chain references to another array to protect against changes
// in verify callback
chain=chain.slice(0);var certs=chain.slice(0);// get current date
var now=new Date();// verify each cert in the chain using its parent, where the parent
// is either the next in the chain or from the CA store
var first=true;var error=null;var depth=0;do{var cert=chain.shift();var parent=null;var selfSigned=false;// 1. check valid time
if(now<cert.validity.notBefore||now>cert.validity.notAfter){error={message:'Certificate is not valid yet or has expired.',error:pki.certificateError.certificate_expired,notBefore:cert.validity.notBefore,notAfter:cert.validity.notAfter,now:now};}// 2. verify with parent from chain or CA store
if(error===null){parent=chain[0]||caStore.getIssuer(cert);if(parent===null){// check for self-signed cert
if(cert.isIssuer(cert)){selfSigned=true;parent=cert;}}if(parent){// FIXME: current CA store implementation might have multiple
// certificates where the issuer can't be determined from the
// certificate (happens rarely with, eg: old certificates) so normalize
// by always putting parents into an array
// TODO: there's may be an extreme degenerate case currently uncovered
// where an old intermediate certificate seems to have a matching parent
// but none of the parents actually verify ... but the intermediate
// is in the CA and it should pass this check; needs investigation
var parents=parent;if(!forge.util.isArray(parents)){parents=[parents];}// try to verify with each possible parent (typically only one)
var verified=false;while(!verified&&parents.length>0){parent=parents.shift();try{verified=parent.verify(cert);}catch(ex){// failure to verify, don't care why, try next one
}}if(!verified){error={message:'Certificate signature is invalid.',error:pki.certificateError.bad_certificate};}}if(error===null&&(!parent||selfSigned)&&!caStore.hasCertificate(cert)){// no parent issuer and certificate itself is not trusted
error={message:'Certificate is not trusted.',error:pki.certificateError.unknown_ca};}}// TODO: 3. check revoked
// 4. check for matching issuer/subject
if(error===null&&parent&&!cert.isIssuer(parent)){// parent is not issuer
error={message:'Certificate issuer is invalid.',error:pki.certificateError.bad_certificate};}// 5. TODO: check names with permitted names tree
// 6. TODO: check names against excluded names tree
// 7. check for unsupported critical extensions
if(error===null){// supported extensions
var se={keyUsage:true,basicConstraints:true};for(var i=0;error===null&&i<cert.extensions.length;++i){var ext=cert.extensions[i];if(ext.critical&&!(ext.name in se)){error={message:'Certificate has an unsupported critical extension.',error:pki.certificateError.unsupported_certificate};}}}// 8. check for CA if cert is not first or is the only certificate
// remaining in chain with no parent or is self-signed
if(error===null&&(!first||chain.length===0&&(!parent||selfSigned))){// first check keyUsage extension and then basic constraints
var bcExt=cert.getExtension('basicConstraints');var keyUsageExt=cert.getExtension('keyUsage');if(keyUsageExt!==null){// keyCertSign must be true and there must be a basic
// constraints extension
if(!keyUsageExt.keyCertSign||bcExt===null){// bad certificate
error={message:'Certificate keyUsage or basicConstraints conflict '+'or indicate that the certificate is not a CA. '+'If the certificate is the only one in the chain or '+'isn\'t the first then the certificate must be a '+'valid CA.',error:pki.certificateError.bad_certificate};}}// basic constraints cA flag must be set
if(error===null&&bcExt!==null&&!bcExt.cA){// bad certificate
error={message:'Certificate basicConstraints indicates the certificate '+'is not a CA.',error:pki.certificateError.bad_certificate};}// if error is not null and keyUsage is available, then we know it
// has keyCertSign and there is a basic constraints extension too,
// which means we can check pathLenConstraint (if it exists)
if(error===null&&keyUsageExt!==null&&'pathLenConstraint'in bcExt){// pathLen is the maximum # of intermediate CA certs that can be
// found between the current certificate and the end-entity (depth 0)
// certificate; this number does not include the end-entity (depth 0,
// last in the chain) even if it happens to be a CA certificate itself
var pathLen=depth-1;if(pathLen>bcExt.pathLenConstraint){// pathLenConstraint violated, bad certificate
error={message:'Certificate basicConstraints pathLenConstraint violated.',error:pki.certificateError.bad_certificate};}}}// call application callback
var vfd=error===null?true:error.error;var ret=verify?verify(vfd,depth,certs):vfd;if(ret===true){// clear any set error
error=null;}else{// if passed basic tests, set default message and alert
if(vfd===true){error={message:'The application rejected the certificate.',error:pki.certificateError.bad_certificate};}// check for custom error info
if(ret||ret===0){// set custom message and error
if(_typeof(ret)==='object'&&!forge.util.isArray(ret)){if(ret.message){error.message=ret.message;}if(ret.error){error.error=ret.error;}}else if(typeof ret==='string'){// set custom error
error.error=ret;}}// throw error
throw error;}// no longer first cert in chain
first=false;++depth;}while(chain.length>0);return true;};/***/},/* 19 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of PKCS#1 PSS signature padding.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 */var forge=__webpack_require__(0);__webpack_require__(5);__webpack_require__(1);// shortcut for PSS API
var pss=module.exports=forge.pss=forge.pss||{};/**
 * Creates a PSS signature scheme object.
 *
 * There are several ways to provide a salt for encoding:
 *
 * 1. Specify the saltLength only and the built-in PRNG will generate it.
 * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
 *   will be used.
 * 3. Specify the salt itself as a forge.util.ByteBuffer.
 *
 * @param options the options to use:
 *          md the message digest object to use, a forge md instance.
 *          mgf the mask generation function to use, a forge mgf instance.
 *          [saltLength] the length of the salt in octets.
 *          [prng] the pseudo-random number generator to use to produce a salt.
 *          [salt] the salt to use when encoding.
 *
 * @return a signature scheme object.
 */pss.create=function(options){// backwards compatibility w/legacy args: hash, mgf, sLen
if(arguments.length===3){options={md:arguments[0],mgf:arguments[1],saltLength:arguments[2]};}var hash=options.md;var mgf=options.mgf;var hLen=hash.digestLength;var salt_=options.salt||null;if(typeof salt_==='string'){// assume binary-encoded string
salt_=forge.util.createBuffer(salt_);}var sLen;if('saltLength'in options){sLen=options.saltLength;}else if(salt_!==null){sLen=salt_.length();}else{throw new Error('Salt length not specified or specific salt not given.');}if(salt_!==null&&salt_.length()!==sLen){throw new Error('Given salt length does not match length of given salt.');}var prng=options.prng||forge.random;var pssobj={};/**
   * Encodes a PSS signature.
   *
   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
   *
   * @param md the message digest object with the hash to sign.
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return the encoded message as a binary-encoded string of length
   *           ceil((modBits - 1) / 8).
   */pssobj.encode=function(md,modBits){var i;var emBits=modBits-1;var emLen=Math.ceil(emBits/8);/* 2. Let mHash = Hash(M), an octet string of length hLen. */var mHash=md.digest().getBytes();/* 3. If emLen < hLen + sLen + 2, output "encoding error" and stop. */if(emLen<hLen+sLen+2){throw new Error('Message is too long to encrypt.');}/* 4. Generate a random octet string salt of length sLen; if sLen = 0,
     *    then salt is the empty string. */var salt;if(salt_===null){salt=prng.getBytesSync(sLen);}else{salt=salt_.bytes();}/* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */var m_=new forge.util.ByteBuffer();m_.fillWithByte(0,8);m_.putBytes(mHash);m_.putBytes(salt);/* 6. Let H = Hash(M'), an octet string of length hLen. */hash.start();hash.update(m_.getBytes());var h=hash.digest().getBytes();/* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
     *    zero octets.  The length of PS may be 0. */var ps=new forge.util.ByteBuffer();ps.fillWithByte(0,emLen-sLen-hLen-2);/* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length
     *    emLen - hLen - 1. */ps.putByte(0x01);ps.putBytes(salt);var db=ps.getBytes();/* 9. Let dbMask = MGF(H, emLen - hLen - 1). */var maskLen=emLen-hLen-1;var dbMask=mgf.generate(h,maskLen);/* 10. Let maskedDB = DB \xor dbMask. */var maskedDB='';for(i=0;i<maskLen;i++){maskedDB+=String.fromCharCode(db.charCodeAt(i)^dbMask.charCodeAt(i));}/* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
     *     maskedDB to zero. */var mask=0xFF00>>8*emLen-emBits&0xFF;maskedDB=String.fromCharCode(maskedDB.charCodeAt(0)&~mask)+maskedDB.substr(1);/* 12. Let EM = maskedDB || H || 0xbc.
     * 13. Output EM. */return maskedDB+h+String.fromCharCode(0xbc);};/**
   * Verifies a PSS signature.
   *
   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
   *
   * @param mHash the message digest hash, as a binary-encoded string, to
   *         compare against the signature.
   * @param em the encoded message, as a binary-encoded string
   *          (RSA decryption result).
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return true if the signature was verified, false if not.
   */pssobj.verify=function(mHash,em,modBits){var i;var emBits=modBits-1;var emLen=Math.ceil(emBits/8);/* c. Convert the message representative m to an encoded message EM
     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits
     *    is the length in bits of the RSA modulus n */em=em.substr(-emLen);/* 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop. */if(emLen<hLen+sLen+2){throw new Error('Inconsistent parameters to PSS signature verification.');}/* 4. If the rightmost octet of EM does not have hexadecimal value
     *    0xbc, output "inconsistent" and stop. */if(em.charCodeAt(emLen-1)!==0xbc){throw new Error('Encoded message does not end in 0xBC.');}/* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
     *    let H be the next hLen octets. */var maskLen=emLen-hLen-1;var maskedDB=em.substr(0,maskLen);var h=em.substr(maskLen,hLen);/* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
     *    maskedDB are not all equal to zero, output "inconsistent" and stop. */var mask=0xFF00>>8*emLen-emBits&0xFF;if((maskedDB.charCodeAt(0)&mask)!==0){throw new Error('Bits beyond keysize not zero as expected.');}/* 7. Let dbMask = MGF(H, emLen - hLen - 1). */var dbMask=mgf.generate(h,maskLen);/* 8. Let DB = maskedDB \xor dbMask. */var db='';for(i=0;i<maskLen;i++){db+=String.fromCharCode(maskedDB.charCodeAt(i)^dbMask.charCodeAt(i));}/* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
     * in DB to zero. */db=String.fromCharCode(db.charCodeAt(0)&~mask)+db.substr(1);/* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
     * position is "position 1") does not have hexadecimal value 0x01,
     * output "inconsistent" and stop. */var checkLen=emLen-hLen-sLen-2;for(i=0;i<checkLen;i++){if(db.charCodeAt(i)!==0x00){throw new Error('Leftmost octets not zero as expected');}}if(db.charCodeAt(checkLen)!==0x01){throw new Error('Inconsistent PSS signature, 0x01 marker not found');}/* 11. Let salt be the last sLen octets of DB. */var salt=db.substr(-sLen);/* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */var m_=new forge.util.ByteBuffer();m_.fillWithByte(0,8);m_.putBytes(mHash);m_.putBytes(salt);/* 13. Let H' = Hash(M'), an octet string of length hLen. */hash.start();hash.update(m_.getBytes());var h_=hash.digest().getBytes();/* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */return h===h_;};return pssobj;};/***/},/* 20 */ /***/function(module,exports,__webpack_require__){__webpack_require__(21);module.exports=__webpack_require__(0);/***/},/* 21 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of a basic Public Key Infrastructure, including
 * support for RSA public and private keys.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(3);__webpack_require__(9);__webpack_require__(8);__webpack_require__(13);__webpack_require__(28);__webpack_require__(19);__webpack_require__(6);__webpack_require__(1);__webpack_require__(18);// shortcut for asn.1 API
var asn1=forge.asn1;/* Public Key Infrastructure (PKI) implementation. */var pki=module.exports=forge.pki=forge.pki||{};/**
 * NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.
 *
 * Converts PEM-formatted data to DER.
 *
 * @param pem the PEM-formatted data.
 *
 * @return the DER-formatted data.
 */pki.pemToDer=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert PEM to DER; PEM is encrypted.');}return forge.util.createBuffer(msg.body);};/**
 * Converts an RSA private key from PEM format.
 *
 * @param pem the PEM-formatted private key.
 *
 * @return the private key.
 */pki.privateKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='PRIVATE KEY'&&msg.type!=='RSA PRIVATE KEY'){var error=new Error('Could not convert private key from PEM; PEM '+'header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert private key from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body);return pki.privateKeyFromAsn1(obj);};/**
 * Converts an RSA private key to PEM format.
 *
 * @param key the private key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */pki.privateKeyToPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'RSA PRIVATE KEY',body:asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts a PrivateKeyInfo to PEM format.
 *
 * @param pki the PrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */pki.privateKeyInfoToPem=function(pki,maxline){// convert to DER, then PEM-encode
var msg={type:'PRIVATE KEY',body:asn1.toDer(pki).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/***/},/* 22 */ /***/function(module,exports){/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */var api={};module.exports=api;// baseN alphabet indexes
var _reverseAlphabets={};/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */api.encode=function(input,alphabet,maxline){if(typeof alphabet!=='string'){throw new TypeError('"alphabet" must be a string.');}if(maxline!==undefined&&typeof maxline!=='number'){throw new TypeError('"maxline" must be a number.');}var output='';if(!(input instanceof Uint8Array)){// assume forge byte buffer
output=_encodeWithByteBuffer(input,alphabet);}else{var i=0;var base=alphabet.length;var first=alphabet.charAt(0);var digits=[0];for(i=0;i<input.length;++i){for(var j=0,carry=input[i];j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%base;carry=carry/base|0;}while(carry>0){digits.push(carry%base);carry=carry/base|0;}}// deal with leading zeros
for(i=0;input[i]===0&&i<input.length-1;++i){output+=first;}// convert digits to a string
for(i=digits.length-1;i>=0;--i){output+=alphabet[digits[i]];}}if(maxline){var regex=new RegExp('.{1,'+maxline+'}','g');output=output.match(regex).join('\r\n');}return output;};/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */api.decode=function(input,alphabet){if(typeof input!=='string'){throw new TypeError('"input" must be a string.');}if(typeof alphabet!=='string'){throw new TypeError('"alphabet" must be a string.');}var table=_reverseAlphabets[alphabet];if(!table){// compute reverse alphabet
table=_reverseAlphabets[alphabet]=[];for(var i=0;i<alphabet.length;++i){table[alphabet.charCodeAt(i)]=i;}}// remove whitespace characters
input=input.replace(/\s/g,'');var base=alphabet.length;var first=alphabet.charAt(0);var bytes=[0];for(var i=0;i<input.length;i++){var value=table[input.charCodeAt(i)];if(value===undefined){return;}for(var j=0,carry=value;j<bytes.length;++j){carry+=bytes[j]*base;bytes[j]=carry&0xff;carry>>=8;}while(carry>0){bytes.push(carry&0xff);carry>>=8;}}// deal with leading zeros
for(var k=0;input[k]===first&&k<input.length-1;++k){bytes.push(0);}if(typeof Buffer!=='undefined'){return Buffer.from(bytes.reverse());}return new Uint8Array(bytes.reverse());};function _encodeWithByteBuffer(input,alphabet){var i=0;var base=alphabet.length;var first=alphabet.charAt(0);var digits=[0];for(i=0;i<input.length();++i){for(var j=0,carry=input.at(i);j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%base;carry=carry/base|0;}while(carry>0){digits.push(carry%base);carry=carry/base|0;}}var output='';// deal with leading zeros
for(i=0;input.at(i)===0&&i<input.length()-1;++i){output+=first;}// convert digits to a string
for(i=digits.length-1;i>=0;--i){output+=alphabet[digits[i]];}return output;}/***/},/* 23 */ /***/function(module,exports,__webpack_require__){/**
 * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
 *
 * See FIPS 180-2 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);var sha256=module.exports=forge.sha256=forge.sha256||{};forge.md.sha256=forge.md.algorithms.sha256=sha256;/**
 * Creates a SHA-256 message digest object.
 *
 * @return a message digest object.
 */sha256.create=function(){// do initialization as necessary
if(!_initialized){_init();}// SHA-256 state contains eight 32-bit integers
var _state=null;// input buffer
var _input=forge.util.createBuffer();// used for word storage
var _w=new Array(64);// message digest object
var md={algorithm:'sha256',blockLength:64,digestLength:32,// 56-bit length of message so far (does not including padding)
messageLength:0,// true message length
fullMessageLength:null,// size of message length in bytes
messageLengthSize:8};/**
   * Starts the digest.
   *
   * @return this digest object.
   */md.start=function(){// up to 56-bit message length for convenience
md.messageLength=0;// full message length (set md.messageLength64 for backwards-compatibility)
md.fullMessageLength=md.messageLength64=[];var int32s=md.messageLengthSize/4;for(var i=0;i<int32s;++i){md.fullMessageLength.push(0);}_input=forge.util.createBuffer();_state={h0:0x6A09E667,h1:0xBB67AE85,h2:0x3C6EF372,h3:0xA54FF53A,h4:0x510E527F,h5:0x9B05688C,h6:0x1F83D9AB,h7:0x5BE0CD19};return md;};// start digest automatically for first time
md.start();/**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */md.update=function(msg,encoding){if(encoding==='utf8'){msg=forge.util.encodeUtf8(msg);}// update message length
var len=msg.length;md.messageLength+=len;len=[len/0x100000000>>>0,len>>>0];for(var i=md.fullMessageLength.length-1;i>=0;--i){md.fullMessageLength[i]+=len[1];len[1]=len[0]+(md.fullMessageLength[i]/0x100000000>>>0);md.fullMessageLength[i]=md.fullMessageLength[i]>>>0;len[0]=len[1]/0x100000000>>>0;}// add bytes to input buffer
_input.putBytes(msg);// process bytes
_update(_state,_w,_input);// compact input buffer every 2K or if empty
if(_input.read>2048||_input.length()===0){_input.compact();}return md;};/**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */md.digest=function(){/* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */var finalBlock=forge.util.createBuffer();finalBlock.putBytes(_input.bytes());// compute remaining size to be digested (include message length size)
var remaining=md.fullMessageLength[md.fullMessageLength.length-1]+md.messageLengthSize;// add padding for overflow blockSize - overflow
// _padding starts with 1 byte with first bit is set (byte value 128), then
// there may be up to (blockSize - 1) other pad bytes
var overflow=remaining&md.blockLength-1;finalBlock.putBytes(_padding.substr(0,md.blockLength-overflow));// serialize message length in bits in big-endian order; since length
// is stored in bytes we multiply by 8 and add carry from next int
var next,carry;var bits=md.fullMessageLength[0]*8;for(var i=0;i<md.fullMessageLength.length-1;++i){next=md.fullMessageLength[i+1]*8;carry=next/0x100000000>>>0;bits+=carry;finalBlock.putInt32(bits>>>0);bits=next>>>0;}finalBlock.putInt32(bits);var s2={h0:_state.h0,h1:_state.h1,h2:_state.h2,h3:_state.h3,h4:_state.h4,h5:_state.h5,h6:_state.h6,h7:_state.h7};_update(s2,_w,finalBlock);var rval=forge.util.createBuffer();rval.putInt32(s2.h0);rval.putInt32(s2.h1);rval.putInt32(s2.h2);rval.putInt32(s2.h3);rval.putInt32(s2.h4);rval.putInt32(s2.h5);rval.putInt32(s2.h6);rval.putInt32(s2.h7);return rval;};return md;};// sha-256 padding bytes not initialized yet
var _padding=null;var _initialized=false;// table of constants
var _k=null;/**
 * Initializes the constant tables.
 */function _init(){// create padding
_padding=String.fromCharCode(128);_padding+=forge.util.fillString(String.fromCharCode(0x00),64);// create K table for SHA-256
_k=[0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2];// now initialized
_initialized=true;}/**
 * Updates a SHA-256 state with the given byte buffer.
 *
 * @param s the SHA-256 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */function _update(s,w,bytes){// consume 512 bit (64 byte) chunks
var t1,t2,s0,s1,ch,maj,i,a,b,c,d,e,f,g,h;var len=bytes.length();while(len>=64){// the w array will be populated with sixteen 32-bit big-endian words
// and then extended into 64 32-bit words according to SHA-256
for(i=0;i<16;++i){w[i]=bytes.getInt32();}for(;i<64;++i){// XOR word 2 words ago rot right 17, rot right 19, shft right 10
t1=w[i-2];t1=(t1>>>17|t1<<15)^(t1>>>19|t1<<13)^t1>>>10;// XOR word 15 words ago rot right 7, rot right 18, shft right 3
t2=w[i-15];t2=(t2>>>7|t2<<25)^(t2>>>18|t2<<14)^t2>>>3;// sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32
w[i]=t1+w[i-7]+t2+w[i-16]|0;}// initialize hash value for this chunk
a=s.h0;b=s.h1;c=s.h2;d=s.h3;e=s.h4;f=s.h5;g=s.h6;h=s.h7;// round function
for(i=0;i<64;++i){// Sum1(e)
s1=(e>>>6|e<<26)^(e>>>11|e<<21)^(e>>>25|e<<7);// Ch(e, f, g) (optimized the same way as SHA-1)
ch=g^e&(f^g);// Sum0(a)
s0=(a>>>2|a<<30)^(a>>>13|a<<19)^(a>>>22|a<<10);// Maj(a, b, c) (optimized the same way as SHA-1)
maj=a&b|c&(a^b);// main algorithm
t1=h+s1+ch+_k[i]+w[i];t2=s0+maj;h=g;g=f;f=e;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
// can't truncate with `| 0`
e=d+t1>>>0;d=c;c=b;b=a;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
// can't truncate with `| 0`
a=t1+t2>>>0;}// update hash state
s.h0=s.h0+a|0;s.h1=s.h1+b|0;s.h2=s.h2+c|0;s.h3=s.h3+d|0;s.h4=s.h4+e|0;s.h5=s.h5+f|0;s.h6=s.h6+g|0;s.h7=s.h7+h|0;len-=64;}}/***/},/* 24 */ /***/function(module,exports,__webpack_require__){/**
 * A javascript implementation of a cryptographically-secure
 * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
 * here though the use of SHA-256 is not enforced; when generating an
 * a PRNG context, the hashing algorithm and block cipher used for
 * the generator are specified via a plugin.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);var _crypto=null;if(forge.util.isNodejs&&!forge.options.usePureJavaScript&&!process.versions['node-webkit']){_crypto=__webpack_require__(15);}/* PRNG API */var prng=module.exports=forge.prng=forge.prng||{};/**
 * Creates a new PRNG context.
 *
 * A PRNG plugin must be passed in that will provide:
 *
 * 1. A function that initializes the key and seed of a PRNG context. It
 *   will be given a 16 byte key and a 16 byte seed. Any key expansion
 *   or transformation of the seed from a byte string into an array of
 *   integers (or similar) should be performed.
 * 2. The cryptographic function used by the generator. It takes a key and
 *   a seed.
 * 3. A seed increment function. It takes the seed and returns seed + 1.
 * 4. An api to create a message digest.
 *
 * For an example, see random.js.
 *
 * @param plugin the PRNG plugin to use.
 */prng.create=function(plugin){var ctx={plugin:plugin,key:null,seed:null,time:null,// number of reseeds so far
reseeds:0,// amount of data generated so far
generated:0,// no initial key bytes
keyBytes:''};// create 32 entropy pools (each is a message digest)
var md=plugin.md;var pools=new Array(32);for(var i=0;i<32;++i){pools[i]=md.create();}ctx.pools=pools;// entropy pools are written to cyclically, starting at index 0
ctx.pool=0;/**
   * Generates random bytes. The bytes may be generated synchronously or
   * asynchronously. Web workers must use the asynchronous interface or
   * else the behavior is undefined.
   *
   * @param count the number of random bytes to generate.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */ctx.generate=function(count,callback){// do synchronously
if(!callback){return ctx.generateSync(count);}// simple generator using counter-based CBC
var cipher=ctx.plugin.cipher;var increment=ctx.plugin.increment;var formatKey=ctx.plugin.formatKey;var formatSeed=ctx.plugin.formatSeed;var b=forge.util.createBuffer();// paranoid deviation from Fortuna:
// reset key for every request to protect previously
// generated random bytes should the key be discovered;
// there is no 100ms based reseeding because of this
// forced reseed for every `generate` call
ctx.key=null;generate();function generate(err){if(err){return callback(err);}// sufficient bytes generated
if(b.length()>=count){return callback(null,b.getBytes(count));}// if amount of data generated is greater than 1 MiB, trigger reseed
if(ctx.generated>0xfffff){ctx.key=null;}if(ctx.key===null){// prevent stack overflow
return forge.util.nextTick(function(){_reseed(generate);});}// generate the random bytes
var bytes=cipher(ctx.key,ctx.seed);ctx.generated+=bytes.length;b.putBytes(bytes);// generate bytes for a new key and seed
ctx.key=formatKey(cipher(ctx.key,increment(ctx.seed)));ctx.seed=formatSeed(cipher(ctx.key,ctx.seed));forge.util.setImmediate(generate);}};/**
   * Generates random bytes synchronously.
   *
   * @param count the number of random bytes to generate.
   *
   * @return count random bytes as a string.
   */ctx.generateSync=function(count){// simple generator using counter-based CBC
var cipher=ctx.plugin.cipher;var increment=ctx.plugin.increment;var formatKey=ctx.plugin.formatKey;var formatSeed=ctx.plugin.formatSeed;// paranoid deviation from Fortuna:
// reset key for every request to protect previously
// generated random bytes should the key be discovered;
// there is no 100ms based reseeding because of this
// forced reseed for every `generateSync` call
ctx.key=null;var b=forge.util.createBuffer();while(b.length()<count){// if amount of data generated is greater than 1 MiB, trigger reseed
if(ctx.generated>0xfffff){ctx.key=null;}if(ctx.key===null){_reseedSync();}// generate the random bytes
var bytes=cipher(ctx.key,ctx.seed);ctx.generated+=bytes.length;b.putBytes(bytes);// generate bytes for a new key and seed
ctx.key=formatKey(cipher(ctx.key,increment(ctx.seed)));ctx.seed=formatSeed(cipher(ctx.key,ctx.seed));}return b.getBytes(count);};/**
   * Private function that asynchronously reseeds a generator.
   *
   * @param callback(err) called once the operation completes.
   */function _reseed(callback){if(ctx.pools[0].messageLength>=32){_seed();return callback();}// not enough seed data...
var needed=32-ctx.pools[0].messageLength<<5;ctx.seedFile(needed,function(err,bytes){if(err){return callback(err);}ctx.collect(bytes);_seed();callback();});}/**
   * Private function that synchronously reseeds a generator.
   */function _reseedSync(){if(ctx.pools[0].messageLength>=32){return _seed();}// not enough seed data...
var needed=32-ctx.pools[0].messageLength<<5;ctx.collect(ctx.seedFileSync(needed));_seed();}/**
   * Private function that seeds a generator once enough bytes are available.
   */function _seed(){// update reseed count
ctx.reseeds=ctx.reseeds===0xffffffff?0:ctx.reseeds+1;// goal is to update `key` via:
// key = hash(key + s)
//   where 's' is all collected entropy from selected pools, then...
// create a plugin-based message digest
var md=ctx.plugin.md.create();// consume current key bytes
md.update(ctx.keyBytes);// digest the entropy of pools whose index k meet the
// condition 'n mod 2^k == 0' where n is the number of reseeds
var _2powK=1;for(var k=0;k<32;++k){if(ctx.reseeds%_2powK===0){md.update(ctx.pools[k].digest().getBytes());ctx.pools[k].start();}_2powK=_2powK<<1;}// get digest for key bytes
ctx.keyBytes=md.digest().getBytes();// paranoid deviation from Fortuna:
// update `seed` via `seed = hash(key)`
// instead of initializing to zero once and only
// ever incrementing it
md.start();md.update(ctx.keyBytes);var seedBytes=md.digest().getBytes();// update state
ctx.key=ctx.plugin.formatKey(ctx.keyBytes);ctx.seed=ctx.plugin.formatSeed(seedBytes);ctx.generated=0;}/**
   * The built-in default seedFile. This seedFile is used when entropy
   * is needed immediately.
   *
   * @param needed the number of bytes that are needed.
   *
   * @return the random bytes.
   */function defaultSeedFile(needed){// use window.crypto.getRandomValues strong source of entropy if available
var getRandomValues=null;if(typeof window!=='undefined'){var _crypto=window.crypto||window.msCrypto;if(_crypto&&_crypto.getRandomValues){getRandomValues=function getRandomValues(arr){return _crypto.getRandomValues(arr);};}}var b=forge.util.createBuffer();if(getRandomValues){while(b.length()<needed){// max byte length is 65536 before QuotaExceededError is thrown
// http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues
var count=Math.max(1,Math.min(needed-b.length(),65536)/4);var entropy=new Uint32Array(Math.floor(count));try{getRandomValues(entropy);for(var i=0;i<entropy.length;++i){b.putInt32(entropy[i]);}}catch(e){/* only ignore QuotaExceededError */if(!(typeof QuotaExceededError!=='undefined'&&e instanceof QuotaExceededError)){throw e;}}}}// be sad and add some weak random data
if(b.length()<needed){/* Draws from Park-Miller "minimal standard" 31 bit PRNG,
      implemented with David G. Carta's optimization: with 32 bit math
      and without division (Public Domain). */var hi,lo,next;var seed=Math.floor(Math.random()*0x010000);while(b.length()<needed){lo=16807*(seed&0xFFFF);hi=16807*(seed>>16);lo+=(hi&0x7FFF)<<16;lo+=hi>>15;lo=(lo&0x7FFFFFFF)+(lo>>31);seed=lo&0xFFFFFFFF;// consume lower 3 bytes of seed
for(var i=0;i<3;++i){// throw in more pseudo random
next=seed>>>(i<<3);next^=Math.floor(Math.random()*0x0100);b.putByte(String.fromCharCode(next&0xFF));}}}return b.getBytes(needed);}// initialize seed file APIs
if(_crypto){// use nodejs async API
ctx.seedFile=function(needed,callback){_crypto.randomBytes(needed,function(err,bytes){if(err){return callback(err);}callback(null,bytes.toString());});};// use nodejs sync API
ctx.seedFileSync=function(needed){return _crypto.randomBytes(needed).toString();};}else{ctx.seedFile=function(needed,callback){try{callback(null,defaultSeedFile(needed));}catch(e){callback(e);}};ctx.seedFileSync=defaultSeedFile;}/**
   * Adds entropy to a prng ctx's accumulator.
   *
   * @param bytes the bytes of entropy as a string.
   */ctx.collect=function(bytes){// iterate over pools distributing entropy cyclically
var count=bytes.length;for(var i=0;i<count;++i){ctx.pools[ctx.pool].update(bytes.substr(i,1));ctx.pool=ctx.pool===31?0:ctx.pool+1;}};/**
   * Collects an integer of n bits.
   *
   * @param i the integer entropy.
   * @param n the number of bits in the integer.
   */ctx.collectInt=function(i,n){var bytes='';for(var x=0;x<n;x+=8){bytes+=String.fromCharCode(i>>x&0xFF);}ctx.collect(bytes);};/**
   * Registers a Web Worker to receive immediate entropy from the main thread.
   * This method is required until Web Workers can access the native crypto
   * API. This method should be called twice for each created worker, once in
   * the main thread, and once in the worker itself.
   *
   * @param worker the worker to register.
   */ctx.registerWorker=function(worker){// worker receives random bytes
if(worker===self){ctx.seedFile=function(needed,callback){function listener(e){var data=e.data;if(data.forge&&data.forge.prng){self.removeEventListener('message',listener);callback(data.forge.prng.err,data.forge.prng.bytes);}}self.addEventListener('message',listener);self.postMessage({forge:{prng:{needed:needed}}});};}else{// main thread sends random bytes upon request
var listener=function listener(e){var data=e.data;if(data.forge&&data.forge.prng){ctx.seedFile(data.forge.prng.needed,function(err,bytes){worker.postMessage({forge:{prng:{err:err,bytes:bytes}}});});}};// TODO: do we need to remove the event listener when the worker dies?
worker.addEventListener('message',listener);}};return ctx;};/***/},/* 25 */ /***/function(module,exports,__webpack_require__){/**
 * RC2 implementation.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * Information on the RC2 cipher is available from RFC #2268,
 * http://www.ietf.org/rfc/rfc2268.txt
 */var forge=__webpack_require__(0);__webpack_require__(1);var piTable=[0xd9,0x78,0xf9,0xc4,0x19,0xdd,0xb5,0xed,0x28,0xe9,0xfd,0x79,0x4a,0xa0,0xd8,0x9d,0xc6,0x7e,0x37,0x83,0x2b,0x76,0x53,0x8e,0x62,0x4c,0x64,0x88,0x44,0x8b,0xfb,0xa2,0x17,0x9a,0x59,0xf5,0x87,0xb3,0x4f,0x13,0x61,0x45,0x6d,0x8d,0x09,0x81,0x7d,0x32,0xbd,0x8f,0x40,0xeb,0x86,0xb7,0x7b,0x0b,0xf0,0x95,0x21,0x22,0x5c,0x6b,0x4e,0x82,0x54,0xd6,0x65,0x93,0xce,0x60,0xb2,0x1c,0x73,0x56,0xc0,0x14,0xa7,0x8c,0xf1,0xdc,0x12,0x75,0xca,0x1f,0x3b,0xbe,0xe4,0xd1,0x42,0x3d,0xd4,0x30,0xa3,0x3c,0xb6,0x26,0x6f,0xbf,0x0e,0xda,0x46,0x69,0x07,0x57,0x27,0xf2,0x1d,0x9b,0xbc,0x94,0x43,0x03,0xf8,0x11,0xc7,0xf6,0x90,0xef,0x3e,0xe7,0x06,0xc3,0xd5,0x2f,0xc8,0x66,0x1e,0xd7,0x08,0xe8,0xea,0xde,0x80,0x52,0xee,0xf7,0x84,0xaa,0x72,0xac,0x35,0x4d,0x6a,0x2a,0x96,0x1a,0xd2,0x71,0x5a,0x15,0x49,0x74,0x4b,0x9f,0xd0,0x5e,0x04,0x18,0xa4,0xec,0xc2,0xe0,0x41,0x6e,0x0f,0x51,0xcb,0xcc,0x24,0x91,0xaf,0x50,0xa1,0xf4,0x70,0x39,0x99,0x7c,0x3a,0x85,0x23,0xb8,0xb4,0x7a,0xfc,0x02,0x36,0x5b,0x25,0x55,0x97,0x31,0x2d,0x5d,0xfa,0x98,0xe3,0x8a,0x92,0xae,0x05,0xdf,0x29,0x10,0x67,0x6c,0xba,0xc9,0xd3,0x00,0xe6,0xcf,0xe1,0x9e,0xa8,0x2c,0x63,0x16,0x01,0x3f,0x58,0xe2,0x89,0xa9,0x0d,0x38,0x34,0x1b,0xab,0x33,0xff,0xb0,0xbb,0x48,0x0c,0x5f,0xb9,0xb1,0xcd,0x2e,0xc5,0xf3,0xdb,0x47,0xe5,0xa5,0x9c,0x77,0x0a,0xa6,0x20,0x68,0xfe,0x7f,0xc1,0xad];var s=[1,2,3,5];/**
 * Rotate a word left by given number of bits.
 *
 * Bits that are shifted out on the left are put back in on the right
 * hand side.
 *
 * @param word The word to shift left.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */var rol=function rol(word,bits){return word<<bits&0xffff|(word&0xffff)>>16-bits;};/**
 * Rotate a word right by given number of bits.
 *
 * Bits that are shifted out on the right are put back in on the left
 * hand side.
 *
 * @param word The word to shift right.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */var ror=function ror(word,bits){return(word&0xffff)>>bits|word<<16-bits&0xffff;};/* RC2 API */module.exports=forge.rc2=forge.rc2||{};/**
 * Perform RC2 key expansion as per RFC #2268, section 2.
 *
 * @param key variable-length user key (between 1 and 128 bytes)
 * @param effKeyBits number of effective key bits (default: 128)
 * @return the expanded RC2 key (ByteBuffer of 128 bytes)
 */forge.rc2.expandKey=function(key,effKeyBits){if(typeof key==='string'){key=forge.util.createBuffer(key);}effKeyBits=effKeyBits||128;/* introduce variables that match the names used in RFC #2268 */var L=key;var T=key.length();var T1=effKeyBits;var T8=Math.ceil(T1/8);var TM=0xff>>(T1&0x07);var i;for(i=T;i<128;i++){L.putByte(piTable[L.at(i-1)+L.at(i-T)&0xff]);}L.setAt(128-T8,piTable[L.at(128-T8)&TM]);for(i=127-T8;i>=0;i--){L.setAt(i,piTable[L.at(i+1)^L.at(i+T8)]);}return L;};/**
 * Creates a RC2 cipher object.
 *
 * @param key the symmetric key to use (as base for key generation).
 * @param bits the number of effective key bits.
 * @param encrypt false for decryption, true for encryption.
 *
 * @return the cipher.
 */var createCipher=function createCipher(key,bits,encrypt){var _finish=false,_input=null,_output=null,_iv=null;var mixRound,mashRound;var i,j,K=[];/* Expand key and fill into K[] Array */key=forge.rc2.expandKey(key,bits);for(i=0;i<64;i++){K.push(key.getInt16Le());}if(encrypt){/**
     * Perform one mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */mixRound=function mixRound(R){for(i=0;i<4;i++){R[i]+=K[j]+(R[(i+3)%4]&R[(i+2)%4])+(~R[(i+3)%4]&R[(i+1)%4]);R[i]=rol(R[i],s[i]);j++;}};/**
     * Perform one mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */mashRound=function mashRound(R){for(i=0;i<4;i++){R[i]+=K[R[(i+3)%4]&63];}};}else{/**
     * Perform one r-mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */mixRound=function mixRound(R){for(i=3;i>=0;i--){R[i]=ror(R[i],s[i]);R[i]-=K[j]+(R[(i+3)%4]&R[(i+2)%4])+(~R[(i+3)%4]&R[(i+1)%4]);j--;}};/**
     * Perform one r-mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */mashRound=function mashRound(R){for(i=3;i>=0;i--){R[i]-=K[R[(i+3)%4]&63];}};}/**
   * Run the specified cipher execution plan.
   *
   * This function takes four words from the input buffer, applies the IV on
   * it (if requested) and runs the provided execution plan.
   *
   * The plan must be put together in form of a array of arrays.  Where the
   * outer one is simply a list of steps to perform and the inner one needs
   * to have two elements: the first one telling how many rounds to perform,
   * the second one telling what to do (i.e. the function to call).
   *
   * @param {Array} plan The plan to execute.
   */var runPlan=function runPlan(plan){var R=[];/* Get data from input buffer and fill the four words into R */for(i=0;i<4;i++){var val=_input.getInt16Le();if(_iv!==null){if(encrypt){/* We're encrypting, apply the IV first. */val^=_iv.getInt16Le();}else{/* We're decryption, keep cipher text for next block. */_iv.putInt16Le(val);}}R.push(val&0xffff);}/* Reset global "j" variable as per spec. */j=encrypt?0:63;/* Run execution plan. */for(var ptr=0;ptr<plan.length;ptr++){for(var ctr=0;ctr<plan[ptr][0];ctr++){plan[ptr][1](R);}}/* Write back result to output buffer. */for(i=0;i<4;i++){if(_iv!==null){if(encrypt){/* We're encrypting in CBC-mode, feed back encrypted bytes into
             IV buffer to carry it forward to next block. */_iv.putInt16Le(R[i]);}else{R[i]^=_iv.getInt16Le();}}_output.putInt16Le(R[i]);}};/* Create cipher object */var cipher=null;cipher={/**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */start:function start(iv,output){if(iv){/* CBC mode */if(typeof iv==='string'){iv=forge.util.createBuffer(iv);}}_finish=false;_input=forge.util.createBuffer();_output=output||new forge.util.createBuffer();_iv=iv;cipher.output=_output;},/**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */update:function update(input){if(!_finish){// not finishing, so fill the input buffer with more input
_input.putBuffer(input);}while(_input.length()>=8){runPlan([[5,mixRound],[1,mashRound],[6,mixRound],[1,mashRound],[5,mixRound]]);}},/**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */finish:function finish(pad){var rval=true;if(encrypt){if(pad){rval=pad(8,_input,!encrypt);}else{// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=_input.length()===8?8:8-_input.length();_input.fillWithByte(padding,padding);}}if(rval){// do final update
_finish=true;cipher.update();}if(!encrypt){// check for error: input data not a multiple of block size
rval=_input.length()===0;if(rval){if(pad){rval=pad(8,_output,!encrypt);}else{// ensure padding byte count is valid
var len=_output.length();var count=_output.at(len-1);if(count>len){rval=false;}else{// trim off padding bytes
_output.truncate(count);}}}}return rval;}};return cipher;};/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */forge.rc2.startEncrypting=function(key,iv,output){var cipher=forge.rc2.createEncryptionCipher(key,128);cipher.start(iv,output);return cipher;};/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start encrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */forge.rc2.createEncryptionCipher=function(key,bits){return createCipher(key,bits,true);};/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */forge.rc2.startDecrypting=function(key,iv,output){var cipher=forge.rc2.createDecryptionCipher(key,128);cipher.start(iv,output);return cipher;};/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start decrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */forge.rc2.createDecryptionCipher=function(key,bits){return createCipher(key,bits,false);};/***/},/* 26 */ /***/function(module,exports,__webpack_require__){/**
 * Partial implementation of PKCS#1 v2.2: RSA-OEAP
 *
 * Modified but based on the following MIT and BSD licensed code:
 *
 * https://github.com/kjur/jsjws/blob/master/rsa.js:
 *
 * The 'jsjws'(JSON Web Signature JavaScript Library) License
 *
 * Copyright (c) 2012 Kenji Urushima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:
 *
 * RSAES-OAEP.js
 * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $
 * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)
 * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.
 * Contact: ellis@nukinetics.com
 * Distributed under the BSD License.
 *
 * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125
 *
 * @author Evan Jones (http://evanjones.ca/)
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(5);__webpack_require__(17);// shortcut for PKCS#1 API
var pkcs1=module.exports=forge.pkcs1=forge.pkcs1||{};/**
 * Encode the given RSAES-OAEP message (M) using key, with optional label (L)
 * and seed.
 *
 * This method does not perform RSA encryption, it only encodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param message the message to encode.
 * @param options the options to use:
 *          label an optional label to use.
 *          seed the seed to use.
 *          md the message digest object to use, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the encoded message bytes.
 */pkcs1.encode_rsa_oaep=function(key,message,options){// parse arguments
var label;var seed;var md;var mgf1Md;// legacy args (label, seed, md)
if(typeof options==='string'){label=options;seed=arguments[3]||undefined;md=arguments[4]||undefined;}else if(options){label=options.label||undefined;seed=options.seed||undefined;md=options.md||undefined;if(options.mgf1&&options.mgf1.md){mgf1Md=options.mgf1.md;}}// default OAEP to SHA-1 message digest
if(!md){md=forge.md.sha1.create();}else{md.start();}// default MGF-1 to same as OAEP
if(!mgf1Md){mgf1Md=md;}// compute length in bytes and check output
var keyLength=Math.ceil(key.n.bitLength()/8);var maxLength=keyLength-2*md.digestLength-2;if(message.length>maxLength){var error=new Error('RSAES-OAEP input message length is too long.');error.length=message.length;error.maxLength=maxLength;throw error;}if(!label){label='';}md.update(label,'raw');var lHash=md.digest();var PS='';var PS_length=maxLength-message.length;for(var i=0;i<PS_length;i++){PS+='\x00';}var DB=lHash.getBytes()+PS+'\x01'+message;if(!seed){seed=forge.random.getBytes(md.digestLength);}else if(seed.length!==md.digestLength){var error=new Error('Invalid RSAES-OAEP seed. The seed length must '+'match the digest length.');error.seedLength=seed.length;error.digestLength=md.digestLength;throw error;}var dbMask=rsa_mgf1(seed,keyLength-md.digestLength-1,mgf1Md);var maskedDB=forge.util.xorBytes(DB,dbMask,DB.length);var seedMask=rsa_mgf1(maskedDB,md.digestLength,mgf1Md);var maskedSeed=forge.util.xorBytes(seed,seedMask,seed.length);// return encoded message
return'\x00'+maskedSeed+maskedDB;};/**
 * Decode the given RSAES-OAEP encoded message (EM) using key, with optional
 * label (L).
 *
 * This method does not perform RSA decryption, it only decodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param em the encoded message to decode.
 * @param options the options to use:
 *          label an optional label to use.
 *          md the message digest object to use for OAEP, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the decoded message bytes.
 */pkcs1.decode_rsa_oaep=function(key,em,options){// parse args
var label;var md;var mgf1Md;// legacy args
if(typeof options==='string'){label=options;md=arguments[3]||undefined;}else if(options){label=options.label||undefined;md=options.md||undefined;if(options.mgf1&&options.mgf1.md){mgf1Md=options.mgf1.md;}}// compute length in bytes
var keyLength=Math.ceil(key.n.bitLength()/8);if(em.length!==keyLength){var error=new Error('RSAES-OAEP encoded message length is invalid.');error.length=em.length;error.expectedLength=keyLength;throw error;}// default OAEP to SHA-1 message digest
if(md===undefined){md=forge.md.sha1.create();}else{md.start();}// default MGF-1 to same as OAEP
if(!mgf1Md){mgf1Md=md;}if(keyLength<2*md.digestLength+2){throw new Error('RSAES-OAEP key is too short for the hash function.');}if(!label){label='';}md.update(label,'raw');var lHash=md.digest().getBytes();// split the message into its parts
var y=em.charAt(0);var maskedSeed=em.substring(1,md.digestLength+1);var maskedDB=em.substring(1+md.digestLength);var seedMask=rsa_mgf1(maskedDB,md.digestLength,mgf1Md);var seed=forge.util.xorBytes(maskedSeed,seedMask,maskedSeed.length);var dbMask=rsa_mgf1(seed,keyLength-md.digestLength-1,mgf1Md);var db=forge.util.xorBytes(maskedDB,dbMask,maskedDB.length);var lHashPrime=db.substring(0,md.digestLength);// constant time check that all values match what is expected
var error=y!=='\x00';// constant time check lHash vs lHashPrime
for(var i=0;i<md.digestLength;++i){error|=lHash.charAt(i)!==lHashPrime.charAt(i);}// "constant time" find the 0x1 byte separating the padding (zeros) from the
// message
// TODO: It must be possible to do this in a better/smarter way?
var in_ps=1;var index=md.digestLength;for(var j=md.digestLength;j<db.length;j++){var code=db.charCodeAt(j);var is_0=code&0x1^0x1;// non-zero if not 0 or 1 in the ps section
var error_mask=in_ps?0xfffe:0x0000;error|=code&error_mask;// latch in_ps to zero after we find 0x1
in_ps=in_ps&is_0;index+=in_ps;}if(error||db.charCodeAt(index)!==0x1){throw new Error('Invalid RSAES-OAEP padding.');}return db.substring(index+1);};function rsa_mgf1(seed,maskLength,hash){// default to SHA-1 message digest
if(!hash){hash=forge.md.sha1.create();}var t='';var count=Math.ceil(maskLength/hash.digestLength);for(var i=0;i<count;++i){var c=String.fromCharCode(i>>24&0xFF,i>>16&0xFF,i>>8&0xFF,i&0xFF);hash.start();hash.update(seed+c);t+=hash.digest().getBytes();}return t.substring(0,maskLength);}/***/},/* 27 */ /***/function(module,exports,__webpack_require__){/**
 * Prime number generation API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(16);__webpack_require__(5);(function(){// forge.prime already defined
if(forge.prime){module.exports=forge.prime;return;}/* PRIME API */var prime=module.exports=forge.prime=forge.prime||{};var BigInteger=forge.jsbn.BigInteger;// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA=[6,4,2,4,2,4,6,2];var THIRTY=new BigInteger(null);THIRTY.fromInt(30);var op_or=function op_or(x,y){return x|y;};/**
 * Generates a random probable prime with the given number of bits.
 *
 * Alternative algorithms can be specified by name as a string or as an
 * object with custom options like so:
 *
 * {
 *   name: 'PRIMEINC',
 *   options: {
 *     maxBlockTime: <the maximum amount of time to block the main
 *       thread before allowing I/O other JS to run>,
 *     millerRabinTests: <the number of miller-rabin tests to run>,
 *     workerScript: <the worker script URL>,
 *     workers: <the number of web workers (if supported) to use,
 *       -1 to use estimated cores minus one>.
 *     workLoad: the size of the work load, ie: number of possible prime
 *       numbers for each web worker to check per work assignment,
 *       (default: 100).
 *   }
 * }
 *
 * @param bits the number of bits for the prime number.
 * @param options the options to use.
 *          [algorithm] the algorithm to use (default: 'PRIMEINC').
 *          [prng] a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *
 * @return callback(err, num) called once the operation completes.
 */prime.generateProbablePrime=function(bits,options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};// default to PRIMEINC algorithm
var algorithm=options.algorithm||'PRIMEINC';if(typeof algorithm==='string'){algorithm={name:algorithm};}algorithm.options=algorithm.options||{};// create prng with api that matches BigInteger secure random
var prng=options.prng||forge.random;var rng={// x is an array to fill with bytes
nextBytes:function nextBytes(x){var b=prng.getBytesSync(x.length);for(var i=0;i<x.length;++i){x[i]=b.charCodeAt(i);}}};if(algorithm.name==='PRIMEINC'){return primeincFindPrime(bits,rng,algorithm.options,callback);}throw new Error('Invalid prime generation algorithm: '+algorithm.name);};function primeincFindPrime(bits,rng,options,callback){if('workers'in options){return primeincFindPrimeWithWorkers(bits,rng,options,callback);}return primeincFindPrimeWithoutWorkers(bits,rng,options,callback);}function primeincFindPrimeWithoutWorkers(bits,rng,options,callback){// initialize random number
var num=generateRandom(bits,rng);/* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The
  number we are given is always aligned at 30k + 1. Each time the number is
  determined not to be prime we add to get to the next 'i', eg: if the number
  was at 30k + 1 we add 6. */var deltaIdx=0;// get required number of MR tests
var mrTests=getMillerRabinTests(num.bitLength());if('millerRabinTests'in options){mrTests=options.millerRabinTests;}// find prime nearest to 'num' for maxBlockTime ms
// 10 ms gives 5ms of leeway for other calculations before dropping
// below 60fps (1000/60 == 16.67), but in reality, the number will
// likely be higher due to an 'atomic' big int modPow
var maxBlockTime=10;if('maxBlockTime'in options){maxBlockTime=options.maxBlockTime;}_primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback);}function _primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback){var start=+new Date();do{// overflow, regenerate random number
if(num.bitLength()>bits){num=generateRandom(bits,rng);}// do primality test
if(num.isProbablePrime(mrTests)){return callback(null,num);}// get next potential prime
num.dAddOffset(GCD_30_DELTA[deltaIdx++%8],0);}while(maxBlockTime<0||+new Date()-start<maxBlockTime);// keep trying later
forge.util.setImmediate(function(){_primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback);});}// NOTE: This algorithm is indeterminate in nature because workers
// run in parallel looking at different segments of numbers. Even if this
// algorithm is run twice with the same input from a predictable RNG, it
// may produce different outputs.
function primeincFindPrimeWithWorkers(bits,rng,options,callback){// web workers unavailable
if(typeof Worker==='undefined'){return primeincFindPrimeWithoutWorkers(bits,rng,options,callback);}// initialize random number
var num=generateRandom(bits,rng);// use web workers to generate keys
var numWorkers=options.workers;var workLoad=options.workLoad||100;var range=workLoad*30/8;var workerScript=options.workerScript||'forge/prime.worker.js';if(numWorkers===-1){return forge.util.estimateCores(function(err,cores){if(err){// default to 2
cores=2;}numWorkers=cores-1;generate();});}generate();function generate(){// require at least 1 worker
numWorkers=Math.max(1,numWorkers);// TODO: consider optimizing by starting workers outside getPrime() ...
// note that in order to clean up they will have to be made internally
// asynchronous which may actually be slower
// start workers immediately
var workers=[];for(var i=0;i<numWorkers;++i){// FIXME: fix path or use blob URLs
workers[i]=new Worker(workerScript);}var running=numWorkers;// listen for requests from workers and assign ranges to find prime
for(var i=0;i<numWorkers;++i){workers[i].addEventListener('message',workerMessage);}/* Note: The distribution of random numbers is unknown. Therefore, each
    web worker is continuously allocated a range of numbers to check for a
    random number until one is found.

    Every 30 numbers will be checked just 8 times, because prime numbers
    have the form:

    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)

    Therefore, if we want a web worker to run N checks before asking for
    a new range of numbers, each range must contain N*30/8 numbers.

    For 100 checks (workLoad), this is a range of 375. */var found=false;function workerMessage(e){// ignore message, prime already found
if(found){return;}--running;var data=e.data;if(data.found){// terminate all workers
for(var i=0;i<workers.length;++i){workers[i].terminate();}found=true;return callback(null,new BigInteger(data.prime,16));}// overflow, regenerate random number
if(num.bitLength()>bits){num=generateRandom(bits,rng);}// assign new range to check
var hex=num.toString(16);// start prime search
e.target.postMessage({hex:hex,workLoad:workLoad});num.dAddOffset(range,0);}}}/**
 * Generates a random number using the given number of bits and RNG.
 *
 * @param bits the number of bits for the number.
 * @param rng the random number generator to use.
 *
 * @return the random number.
 */function generateRandom(bits,rng){var num=new BigInteger(bits,rng);// force MSB set
var bits1=bits-1;if(!num.testBit(bits1)){num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1),op_or,num);}// align number on 30k+1 boundary
num.dAddOffset(31-num.mod(THIRTY).byteValue(),0);return num;}/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */function getMillerRabinTests(bits){if(bits<=100)return 27;if(bits<=150)return 18;if(bits<=200)return 15;if(bits<=250)return 12;if(bits<=300)return 9;if(bits<=350)return 8;if(bits<=400)return 7;if(bits<=500)return 6;if(bits<=600)return 5;if(bits<=800)return 4;if(bits<=1250)return 3;return 2;}})();/***/},/* 28 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of PKCS#12.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#12 is as follows
 * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)
 *
 * PFX ::= SEQUENCE {
 *   version  INTEGER {v3(3)}(v3,...),
 *   authSafe ContentInfo,
 *   macData  MacData OPTIONAL
 * }
 *
 * MacData ::= SEQUENCE {
 *   mac DigestInfo,
 *   macSalt OCTET STRING,
 *   iterations INTEGER DEFAULT 1
 * }
 * Note: The iterations default is for historical reasons and its use is
 * deprecated. A higher value, like 1024, is recommended.
 *
 * DigestInfo is defined in PKCS#7 as follows:
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of SHA1 there is none.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * Digest ::= OCTET STRING
 *
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType ContentType,
 *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * AuthenticatedSafe ::= SEQUENCE OF ContentInfo
 * -- Data if unencrypted
 * -- EncryptedData if password-encrypted
 * -- EnvelopedData if public key-encrypted
 *
 *
 * SafeContents ::= SEQUENCE OF SafeBag
 *
 * SafeBag ::= SEQUENCE {
 *   bagId     BAG-TYPE.&id ({PKCS12BagSet})
 *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),
 *   bagAttributes SET OF PKCS12Attribute OPTIONAL
 * }
 *
 * PKCS12Attribute ::= SEQUENCE {
 *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),
 *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})
 * } -- This type is compatible with the X.500 type Attribute
 *
 * PKCS12AttrSet ATTRIBUTE ::= {
 *   friendlyName | -- from PKCS #9
 *   localKeyId, -- from PKCS #9
 *   ... -- Other attributes are allowed
 * }
 *
 * CertBag ::= SEQUENCE {
 *   certId    BAG-TYPE.&id   ({CertTypes}),
 *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})
 * }
 *
 * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}
 *   -- DER-encoded X.509 certificate stored in OCTET STRING
 *
 * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}
 * -- Base64-encoded SDSI certificate stored in IA5String
 *
 * CertTypes BAG-TYPE ::= {
 *   x509Certificate |
 *   sdsiCertificate,
 *   ... -- For future extensions
 * }
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(14);__webpack_require__(3);__webpack_require__(29);__webpack_require__(9);__webpack_require__(5);__webpack_require__(6);__webpack_require__(17);__webpack_require__(1);__webpack_require__(18);// shortcut for asn.1 & PKI API
var asn1=forge.asn1;var pki=forge.pki;// shortcut for PKCS#12 API
var p12=module.exports=forge.pkcs12=forge.pkcs12||{};var contentInfoValidator={name:'ContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// a ContentInfo
constructed:true,value:[{name:'ContentInfo.contentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'ContentInfo.content',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,captureAsn1:'content'}]};var pfxValidator={name:'PFX',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PFX.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},contentInfoValidator,{name:'PFX.macData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,captureAsn1:'mac',value:[{name:'PFX.macData.mac',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// DigestInfo
constructed:true,value:[{name:'PFX.macData.mac.digestAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// DigestAlgorithmIdentifier
constructed:true,value:[{name:'PFX.macData.mac.digestAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'macAlgorithm'},{name:'PFX.macData.mac.digestAlgorithm.parameters',tagClass:asn1.Class.UNIVERSAL,captureAsn1:'macAlgorithmParameters'}]},{name:'PFX.macData.mac.digest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'macDigest'}]},{name:'PFX.macData.macSalt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'macSalt'},{name:'PFX.macData.iterations',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,optional:true,capture:'macIterations'}]}]};var safeBagValidator={name:'SafeBag',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SafeBag.bagId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'bagId'},{name:'SafeBag.bagValue',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,captureAsn1:'bagValue'},{name:'SafeBag.bagAttributes',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,optional:true,capture:'bagAttributes'}]};var attributeValidator={name:'Attribute',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Attribute.attrId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'oid'},{name:'Attribute.attrValues',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,capture:'values'}]};var certBagValidator={name:'CertBag',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'CertBag.certId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certId'},{name:'CertBag.certValue',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,/* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */value:[{name:'CertBag.certValue[0]',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.OCTETSTRING,constructed:false,capture:'cert'}]}]};/**
 * Search SafeContents structure for bags with matching attributes.
 *
 * The search can optionally be narrowed by a certain bag type.
 *
 * @param safeContents the SafeContents structure to search in.
 * @param attrName the name of the attribute to compare against.
 * @param attrValue the attribute value to search for.
 * @param [bagType] bag type to narrow search by.
 *
 * @return an array of matching bags.
 */function _getBagsByAttribute(safeContents,attrName,attrValue,bagType){var result=[];for(var i=0;i<safeContents.length;i++){for(var j=0;j<safeContents[i].safeBags.length;j++){var bag=safeContents[i].safeBags[j];if(bagType!==undefined&&bag.type!==bagType){continue;}// only filter by bag type, no attribute specified
if(attrName===null){result.push(bag);continue;}if(bag.attributes[attrName]!==undefined&&bag.attributes[attrName].indexOf(attrValue)>=0){result.push(bag);}}}return result;}/**
 * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.
 *
 * @param obj The PKCS#12 PFX in ASN.1 notation.
 * @param strict true to use strict DER decoding, false not to (default: true).
 * @param {String} password Password to decrypt with (optional).
 *
 * @return PKCS#12 PFX object.
 */p12.pkcs12FromAsn1=function(obj,strict,password){// handle args
if(typeof strict==='string'){password=strict;strict=true;}else if(strict===undefined){strict=true;}// validate PFX and capture data
var capture={};var errors=[];if(!asn1.validate(obj,pfxValidator,capture,errors)){var error=new Error('Cannot read PKCS#12 PFX. '+'ASN.1 object is not an PKCS#12 PFX.');error.errors=error;throw error;}var pfx={version:capture.version.charCodeAt(0),safeContents:[],/**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */getBags:function getBags(filter){var rval={};var localKeyId;if('localKeyId'in filter){localKeyId=filter.localKeyId;}else if('localKeyIdHex'in filter){localKeyId=forge.util.hexToBytes(filter.localKeyIdHex);}// filter on bagType only
if(localKeyId===undefined&&!('friendlyName'in filter)&&'bagType'in filter){rval[filter.bagType]=_getBagsByAttribute(pfx.safeContents,null,null,filter.bagType);}if(localKeyId!==undefined){rval.localKeyId=_getBagsByAttribute(pfx.safeContents,'localKeyId',localKeyId,filter.bagType);}if('friendlyName'in filter){rval.friendlyName=_getBagsByAttribute(pfx.safeContents,'friendlyName',filter.friendlyName,filter.bagType);}return rval;},/**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */getBagsByFriendlyName:function getBagsByFriendlyName(friendlyName,bagType){return _getBagsByAttribute(pfx.safeContents,'friendlyName',friendlyName,bagType);},/**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */getBagsByLocalKeyId:function getBagsByLocalKeyId(localKeyId,bagType){return _getBagsByAttribute(pfx.safeContents,'localKeyId',localKeyId,bagType);}};if(capture.version.charCodeAt(0)!==3){var error=new Error('PKCS#12 PFX of version other than 3 not supported.');error.version=capture.version.charCodeAt(0);throw error;}if(asn1.derToOid(capture.contentType)!==pki.oids.data){var error=new Error('Only PKCS#12 PFX in password integrity mode supported.');error.oid=asn1.derToOid(capture.contentType);throw error;}var data=capture.content.value[0];if(data.tagClass!==asn1.Class.UNIVERSAL||data.type!==asn1.Type.OCTETSTRING){throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');}data=_decodePkcs7Data(data);// check for MAC
if(capture.mac){var md=null;var macKeyBytes=0;var macAlgorithm=asn1.derToOid(capture.macAlgorithm);switch(macAlgorithm){case pki.oids.sha1:md=forge.md.sha1.create();macKeyBytes=20;break;case pki.oids.sha256:md=forge.md.sha256.create();macKeyBytes=32;break;case pki.oids.sha384:md=forge.md.sha384.create();macKeyBytes=48;break;case pki.oids.sha512:md=forge.md.sha512.create();macKeyBytes=64;break;case pki.oids.md5:md=forge.md.md5.create();macKeyBytes=16;break;}if(md===null){throw new Error('PKCS#12 uses unsupported MAC algorithm: '+macAlgorithm);}// verify MAC (iterations default to 1)
var macSalt=new forge.util.ByteBuffer(capture.macSalt);var macIterations='macIterations'in capture?parseInt(forge.util.bytesToHex(capture.macIterations),16):1;var macKey=p12.generateKey(password,macSalt,3,macIterations,macKeyBytes,md);var mac=forge.hmac.create();mac.start(md,macKey);mac.update(data.value);var macValue=mac.getMac();if(macValue.getBytes()!==capture.macDigest){throw new Error('PKCS#12 MAC could not be verified. Invalid password?');}}_decodeAuthenticatedSafe(pfx,data.value,strict,password);return pfx;};/**
 * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines "Data" as an OCTET STRING,
 * but it is sometimes an OCTET STRING that is composed/constructed of chunks,
 * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This
 * function transforms this corner-case into the usual simple,
 * non-composed/constructed OCTET STRING.
 *
 * This function may be moved to ASN.1 at some point to better deal with
 * more BER-encoding issues, should they arise.
 *
 * @param data the ASN.1 Data object to transform.
 */function _decodePkcs7Data(data){// handle special case of "chunked" data content: an octet string composed
// of other octet strings
if(data.composed||data.constructed){var value=forge.util.createBuffer();for(var i=0;i<data.value.length;++i){value.putBytes(data.value[i].value);}data.composed=data.constructed=false;data.value=value.getBytes();}return data;}/**
 * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.
 *
 * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.
 *
 * @param pfx The PKCS#12 PFX object to fill.
 * @param {String} authSafe BER-encoded AuthenticatedSafe.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 */function _decodeAuthenticatedSafe(pfx,authSafe,strict,password){authSafe=asn1.fromDer(authSafe,strict);/* actually it's BER encoded */if(authSafe.tagClass!==asn1.Class.UNIVERSAL||authSafe.type!==asn1.Type.SEQUENCE||authSafe.constructed!==true){throw new Error('PKCS#12 AuthenticatedSafe expected to be a '+'SEQUENCE OF ContentInfo');}for(var i=0;i<authSafe.value.length;i++){var contentInfo=authSafe.value[i];// validate contentInfo and capture data
var capture={};var errors=[];if(!asn1.validate(contentInfo,contentInfoValidator,capture,errors)){var error=new Error('Cannot read ContentInfo.');error.errors=errors;throw error;}var obj={encrypted:false};var safeContents=null;var data=capture.content.value[0];switch(asn1.derToOid(capture.contentType)){case pki.oids.data:if(data.tagClass!==asn1.Class.UNIVERSAL||data.type!==asn1.Type.OCTETSTRING){throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');}safeContents=_decodePkcs7Data(data).value;break;case pki.oids.encryptedData:safeContents=_decryptSafeContents(data,password);obj.encrypted=true;break;default:var error=new Error('Unsupported PKCS#12 contentType.');error.contentType=asn1.derToOid(capture.contentType);throw error;}obj.safeBags=_decodeSafeContents(safeContents,strict,password);pfx.safeContents.push(obj);}}/**
 * Decrypt PKCS#7 EncryptedData structure.
 *
 * @param data ASN.1 encoded EncryptedContentInfo object.
 * @param password The user-provided password.
 *
 * @return The decrypted SafeContents (ASN.1 object).
 */function _decryptSafeContents(data,password){var capture={};var errors=[];if(!asn1.validate(data,forge.pkcs7.asn1.encryptedDataValidator,capture,errors)){var error=new Error('Cannot read EncryptedContentInfo.');error.errors=errors;throw error;}var oid=asn1.derToOid(capture.contentType);if(oid!==pki.oids.data){var error=new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');error.oid=oid;throw error;}// get cipher
oid=asn1.derToOid(capture.encAlgorithm);var cipher=pki.pbe.getCipher(oid,capture.encParameter,password);// get encrypted data
var encryptedContentAsn1=_decodePkcs7Data(capture.encryptedContentAsn1);var encrypted=forge.util.createBuffer(encryptedContentAsn1.value);cipher.update(encrypted);if(!cipher.finish()){throw new Error('Failed to decrypt PKCS#12 SafeContents.');}return cipher.output.getBytes();}/**
 * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.
 *
 * The safeContents is a BER-encoded SEQUENCE OF SafeBag.
 *
 * @param {String} safeContents BER-encoded safeContents.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 *
 * @return {Array} Array of Bag objects.
 */function _decodeSafeContents(safeContents,strict,password){// if strict and no safe contents, return empty safes
if(!strict&&safeContents.length===0){return[];}// actually it's BER-encoded
safeContents=asn1.fromDer(safeContents,strict);if(safeContents.tagClass!==asn1.Class.UNIVERSAL||safeContents.type!==asn1.Type.SEQUENCE||safeContents.constructed!==true){throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');}var res=[];for(var i=0;i<safeContents.value.length;i++){var safeBag=safeContents.value[i];// validate SafeBag and capture data
var capture={};var errors=[];if(!asn1.validate(safeBag,safeBagValidator,capture,errors)){var error=new Error('Cannot read SafeBag.');error.errors=errors;throw error;}/* Create bag object and push to result array. */var bag={type:asn1.derToOid(capture.bagId),attributes:_decodeBagAttributes(capture.bagAttributes)};res.push(bag);var validator,decoder;var bagAsn1=capture.bagValue.value[0];switch(bag.type){case pki.oids.pkcs8ShroudedKeyBag:/* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.
           Afterwards we can handle it like a keyBag,
           which is a PrivateKeyInfo. */bagAsn1=pki.decryptPrivateKeyInfo(bagAsn1,password);if(bagAsn1===null){throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');}/* fall through */case pki.oids.keyBag:/* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our
           PKI module, hence we don't have to do validation/capturing here,
           just pass what we already got. */try{bag.key=pki.privateKeyFromAsn1(bagAsn1);}catch(e){// ignore unknown key type, pass asn1 value
bag.key=null;bag.asn1=bagAsn1;}continue;/* Nothing more to do. */case pki.oids.certBag:/* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.
           Therefore put the SafeBag content through another validator to
           capture the fields.  Afterwards check & store the results. */validator=certBagValidator;decoder=function decoder(){if(asn1.derToOid(capture.certId)!==pki.oids.x509Certificate){var error=new Error('Unsupported certificate type, only X.509 supported.');error.oid=asn1.derToOid(capture.certId);throw error;}// true=produce cert hash
var certAsn1=asn1.fromDer(capture.cert,strict);try{bag.cert=pki.certificateFromAsn1(certAsn1,true);}catch(e){// ignore unknown cert type, pass asn1 value
bag.cert=null;bag.asn1=certAsn1;}};break;default:var error=new Error('Unsupported PKCS#12 SafeBag type.');error.oid=bag.type;throw error;}/* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */if(validator!==undefined&&!asn1.validate(bagAsn1,validator,capture,errors)){var error=new Error('Cannot read PKCS#12 '+validator.name);error.errors=errors;throw error;}/* Call decoder function from above to store the results. */decoder();}return res;}/**
 * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.
 *
 * @param attributes SET OF PKCS12Attribute (ASN.1 object).
 *
 * @return the decoded attributes.
 */function _decodeBagAttributes(attributes){var decodedAttrs={};if(attributes!==undefined){for(var i=0;i<attributes.length;++i){var capture={};var errors=[];if(!asn1.validate(attributes[i],attributeValidator,capture,errors)){var error=new Error('Cannot read PKCS#12 BagAttribute.');error.errors=errors;throw error;}var oid=asn1.derToOid(capture.oid);if(pki.oids[oid]===undefined){// unsupported attribute type, ignore.
continue;}decodedAttrs[pki.oids[oid]]=[];for(var j=0;j<capture.values.length;++j){decodedAttrs[pki.oids[oid]].push(capture.values[j].value);}}}return decodedAttrs;}/**
 * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a
 * password is provided then the private key will be encrypted.
 *
 * An entire certificate chain may also be included. To do this, pass
 * an array for the "cert" parameter where the first certificate is
 * the one that is paired with the private key and each subsequent one
 * verifies the previous one. The certificates may be in PEM format or
 * have been already parsed by Forge.
 *
 * @todo implement password-based-encryption for the whole package
 *
 * @param key the private key.
 * @param cert the certificate (may be an array of certificates in order
 *          to specify a certificate chain).
 * @param password the password to use, null for none.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          useMac true to include a MAC, false not to, defaults to true.
 *          localKeyId the local key ID to use, in hex.
 *          friendlyName the friendly name to use.
 *          generateLocalKeyId true to generate a random local key ID,
 *            false not to, defaults to true.
 *
 * @return the PKCS#12 PFX ASN.1 object.
 */p12.toPkcs12Asn1=function(key,cert,password,options){// set default options
options=options||{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||options.encAlgorithm||'aes128';if(!('useMac'in options)){options.useMac=true;}if(!('localKeyId'in options)){options.localKeyId=null;}if(!('generateLocalKeyId'in options)){options.generateLocalKeyId=true;}var localKeyId=options.localKeyId;var bagAttrs;if(localKeyId!==null){localKeyId=forge.util.hexToBytes(localKeyId);}else if(options.generateLocalKeyId){// use SHA-1 of paired cert, if available
if(cert){var pairedCert=forge.util.isArray(cert)?cert[0]:cert;if(typeof pairedCert==='string'){pairedCert=pki.certificateFromPem(pairedCert);}var sha1=forge.md.sha1.create();sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());localKeyId=sha1.digest().getBytes();}else{// FIXME: consider using SHA-1 of public key (which can be generated
// from private key components), see: cert.generateSubjectKeyIdentifier
// generate random bytes
localKeyId=forge.random.getBytes(20);}}var attrs=[];if(localKeyId!==null){attrs.push(// localKeyID
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// attrId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.localKeyId).getBytes()),// attrValues
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,localKeyId)])]));}if('friendlyName'in options){attrs.push(// friendlyName
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// attrId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.friendlyName).getBytes()),// attrValues
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BMPSTRING,false,options.friendlyName)])]));}if(attrs.length>0){bagAttrs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,attrs);}// collect contents for AuthenticatedSafe
var contents=[];// create safe bag(s) for certificate chain
var chain=[];if(cert!==null){if(forge.util.isArray(cert)){chain=cert;}else{chain=[cert];}}var certSafeBags=[];for(var i=0;i<chain.length;++i){// convert cert from PEM as necessary
cert=chain[i];if(typeof cert==='string'){cert=pki.certificateFromPem(cert);}// SafeBag
var certBagAttrs=i===0?bagAttrs:undefined;var certAsn1=pki.certificateToAsn1(cert);var certSafeBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.certBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// CertBag
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// certId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.x509Certificate).getBytes()),// certValue (x509Certificate)
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(certAsn1).getBytes())])])]),// bagAttributes (OPTIONAL)
certBagAttrs]);certSafeBags.push(certSafeBag);}if(certSafeBags.length>0){// SafeContents
var certSafeContents=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,certSafeBags);// ContentInfo
var certCI=// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(certSafeContents).getBytes())])]);contents.push(certCI);}// create safe contents for private key
var keyBag=null;if(key!==null){// SafeBag
var pkAsn1=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));if(password===null){// no encryption
keyBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.keyBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// PrivateKeyInfo
pkAsn1]),// bagAttributes (OPTIONAL)
bagAttrs]);}else{// encrypted PrivateKeyInfo
keyBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// EncryptedPrivateKeyInfo
pki.encryptPrivateKeyInfo(pkAsn1,password,options)]),// bagAttributes (OPTIONAL)
bagAttrs]);}// SafeContents
var keySafeContents=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[keyBag]);// ContentInfo
var keyCI=// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(keySafeContents).getBytes())])]);contents.push(keyCI);}// create AuthenticatedSafe by stringing together the contents
var safe=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,contents);var macData;if(options.useMac){// MacData
var sha1=forge.md.sha1.create();var macSalt=new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));var count=options.count;// 160-bit key
var key=p12.generateKey(password,macSalt,3,count,20);var mac=forge.hmac.create();mac.start(sha1,key);mac.update(asn1.toDer(safe).getBytes());var macValue=mac.getMac();macData=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// mac DigestInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// digestAlgorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm = SHA-1
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.sha1).getBytes()),// parameters = Null
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// digest
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,macValue.getBytes())]),// macSalt OCTET STRING
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,macSalt.getBytes()),// iterations INTEGER (XXX: Only support count < 65536)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(count).getBytes())]);}// PFX
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (3)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(3).getBytes()),// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(safe).getBytes())])]),macData]);};/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */p12.generateKey=forge.pbe.generatePkcs12Key;/***/},/* 29 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
 *
 * @author Dave Longley
 * @author Stefan Siegl
 *
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#7 is as follows
 * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
 *
 * A PKCS#7 message consists of a ContentInfo on root level, which may
 * contain any number of further ContentInfo nested into it.
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType                ContentType,
 *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * EnvelopedData ::= SEQUENCE {
 *   version                    Version,
 *   recipientInfos             RecipientInfos,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * EncryptedData ::= SEQUENCE {
 *   version                    Version,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
 *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
 *
 * SignedData ::= SEQUENCE {
 *   version           INTEGER,
 *   digestAlgorithms  DigestAlgorithmIdentifiers,
 *   contentInfo       ContentInfo,
 *   certificates      [0] IMPLICIT Certificates OPTIONAL,
 *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos       SignerInfos
 * }
 *
 * SignerInfos ::= SET OF SignerInfo
 *
 * SignerInfo ::= SEQUENCE {
 *   version                    Version,
 *   issuerAndSerialNumber      IssuerAndSerialNumber,
 *   digestAlgorithm            DigestAlgorithmIdentifier,
 *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
 *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
 *   encryptedDigest            EncryptedDigest,
 *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
 * }
 *
 * EncryptedDigest ::= OCTET STRING
 *
 * Attributes ::= SET OF Attribute
 *
 * Attribute ::= SEQUENCE {
 *   attrType    OBJECT IDENTIFIER,
 *   attrValues  SET OF AttributeValue
 * }
 *
 * AttributeValue ::= ANY
 *
 * Version ::= INTEGER
 *
 * RecipientInfos ::= SET OF RecipientInfo
 *
 * EncryptedContentInfo ::= SEQUENCE {
 *   contentType                 ContentType,
 *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
 *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
 * }
 *
 * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of AES and DES3, there is only one,
 * the IV.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * EncryptedContent ::= OCTET STRING
 *
 * RecipientInfo ::= SEQUENCE {
 *   version                     Version,
 *   issuerAndSerialNumber       IssuerAndSerialNumber,
 *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
 *   encryptedKey                EncryptedKey
 * }
 *
 * IssuerAndSerialNumber ::= SEQUENCE {
 *   issuer                      Name,
 *   serialNumber                CertificateSerialNumber
 * }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedKey ::= OCTET STRING
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(1);// shortcut for ASN.1 API
var asn1=forge.asn1;// shortcut for PKCS#7 API
var p7v=module.exports=forge.pkcs7asn1=forge.pkcs7asn1||{};forge.pkcs7=forge.pkcs7||{};forge.pkcs7.asn1=p7v;var contentInfoValidator={name:'ContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'ContentInfo.ContentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'ContentInfo.content',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,captureAsn1:'content'}]};p7v.contentInfoValidator=contentInfoValidator;var encryptedContentInfoValidator={name:'EncryptedContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedContentInfo.contentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'EncryptedContentInfo.contentEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encAlgorithm'},{name:'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,captureAsn1:'encParameter'}]},{name:'EncryptedContentInfo.encryptedContent',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,/* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */capture:'encryptedContent',captureAsn1:'encryptedContentAsn1'}]};p7v.envelopedDataValidator={name:'EnvelopedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EnvelopedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'EnvelopedData.RecipientInfos',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,captureAsn1:'recipientInfos'}].concat(encryptedContentInfoValidator)};p7v.encryptedDataValidator={name:'EncryptedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'}].concat(encryptedContentInfoValidator)};var signerValidator={name:'SignerInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false},{name:'SignerInfo.issuerAndSerialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.issuerAndSerialNumber.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'issuer'},{name:'SignerInfo.issuerAndSerialNumber.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'serial'}]},{name:'SignerInfo.digestAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.digestAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'digestAlgorithm'},{name:'SignerInfo.digestAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,constructed:false,captureAsn1:'digestParameter',optional:true}]},{name:'SignerInfo.authenticatedAttributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,capture:'authenticatedAttributes'},{name:'SignerInfo.digestEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,capture:'signatureAlgorithm'},{name:'SignerInfo.encryptedDigest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'signature'},{name:'SignerInfo.unauthenticatedAttributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,optional:true,capture:'unauthenticatedAttributes'}]};p7v.signedDataValidator={name:'SignedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'SignedData.DigestAlgorithms',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,captureAsn1:'digestAlgorithms'},contentInfoValidator,{name:'SignedData.Certificates',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,optional:true,captureAsn1:'certificates'},{name:'SignedData.CertificateRevocationLists',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,optional:true,captureAsn1:'crls'},{name:'SignedData.SignerInfos',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,capture:'signerInfos',optional:true,value:[signerValidator]}]};p7v.recipientInfoValidator={name:'RecipientInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'RecipientInfo.issuerAndSerial',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.issuerAndSerial.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'issuer'},{name:'RecipientInfo.issuerAndSerial.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'serial'}]},{name:'RecipientInfo.keyEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.keyEncryptionAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encAlgorithm'},{name:'RecipientInfo.keyEncryptionAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,constructed:false,captureAsn1:'encParameter'}]},{name:'RecipientInfo.encryptedKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encKey'}]};/***/},/* 30 */ /***/function(module,exports,__webpack_require__){/**
 * Node.js module for Forge mask generation functions.
 *
 * @author Stefan Siegl
 *
 * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
 */var forge=__webpack_require__(0);__webpack_require__(31);module.exports=forge.mgf=forge.mgf||{};forge.mgf.mgf1=forge.mgf1;/***/},/* 31 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of mask generation function MGF1.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);forge.mgf=forge.mgf||{};var mgf1=module.exports=forge.mgf.mgf1=forge.mgf1=forge.mgf1||{};/**
 * Creates a MGF1 mask generation function object.
 *
 * @param md the message digest API to use (eg: forge.md.sha1.create()).
 *
 * @return a mask generation function object.
 */mgf1.create=function(md){var mgf={/**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */generate:function generate(seed,maskLen){/* 2. Let T be the empty octet string. */var t=new forge.util.ByteBuffer();/* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */var len=Math.ceil(maskLen/md.digestLength);for(var i=0;i<len;i++){/* a. Convert counter to an octet string C of length 4 octets */var c=new forge.util.ByteBuffer();c.putInt32(i);/* b. Concatenate the hash of the seed mgfSeed and C to the octet
         * string T: */md.start();md.update(seed+c.getBytes());t.putBuffer(md.digest());}/* Output the leading maskLen octets of T as the octet string mask. */t.truncate(t.length()-maskLen);return t.getBytes();}};return mgf;};/***/}]));});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHVuZ2FwL3VybC1zZWFyY2gtcGFyYW1zL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zLWV4dGVuc2lvbnMvZXNtL2NhY2hlQWRhcHRlckVuaGFuY2VyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MtZXh0ZW5zaW9ucy9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy1leHRlbnNpb25zL2VzbS90aHJvdHRsZUFkYXB0ZXJFbmhhbmNlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zLWV4dGVuc2lvbnMvZXNtL3V0aWxzL2J1aWxkU29ydGVkVVJMLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MtZXh0ZW5zaW9ucy9lc20vdXRpbHMvaXNDYWNoZUxpa2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191c2VyLWFnZW50LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvanNlbmNyeXB0L2Jpbi9qc2VuY3J5cHQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9wcm9taXNlLXdpbmRvdy9kaXN0L3Byb21pc2Utd2luZG93LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHNldWRvbWFwL21hcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3BzZXVkb21hcC9wc2V1ZG9tYXAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL3NyYy9kaXNjb3Vyc2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL3NyYy9kaXNjb3Vyc2VBcGkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL3NyYy9kaXNjb3Vyc2VBdXRoLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9zcmMva2V5R2VuZXJhdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9zcmMva2V5TWFuYWdlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL3ZlbmRvci9mb3JnZS1wa2kuanMiXSwibmFtZXMiOlsiRGlzY291cnNlQ2xpZW50Iiwib3B0aW9ucyIsIl9yZXF1aXJlT3B0aW9ucyIsIl9mb3JtYXRPcHRpb25zIiwiYXV0aCIsIkRpc2NvdXJzZUF1dGgiLCJhcGkiLCJEaXNjb3Vyc2VBcGkiLCJhcGlCYXNlVXJsIiwiaW5pdCIsIkVycm9yIiwiYXBwTmFtZSIsImxlbmd0aCIsInNjb3BlcyIsIkFycmF5IiwiZm9ybWF0dGVkT3B0aW9ucyIsInJlcGxhY2UiLCJqb2luIiwiX2hhc1VzZXJBcGlLZXkiLCJfcmVmcmVzaEN1cnJlbnRVc2VyIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImdldEN1cnJlbnRVc2VyIiwic2l6ZSIsImdldEN1cnJlbnRVc2VyTmFtZSIsImdldEN1cnJlbnRTZXNzaW9uVXNlciIsInN0cmluZ2lmeSIsInNldEl0ZW0iLCJsb2dvdXQiLCJpc0xvZ2dlZEluIiwiUHJvbWlzZVdpbmRvdyIsIl9nZXRMb2dpblVybCIsIndpZHRoIiwiaGVpZ2h0Iiwib3JpZ2luUmVnZXhwIiwiUmVnRXhwIiwibG9jYXRpb24iLCJvcmlnaW4iLCJkYXRhIiwiX3NldFVzZXJBcGlLZXkiLCJyZXN1bHQiLCJrZXkiLCJlcnJvciIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsIm9wZW4iLCJ0aGVuIiwiX2NsZWFyQXV0aERhdGEiLCJheGlvcyIsImNyZWF0ZSIsImJhc2VVUkwiLCJoZWFkZXJzIiwiYWRhcHRlciIsImRlZmF1bHRzIiwidGhyZXNob2xkIiwiZW5kcG9pbnQiLCJwcm9wIiwibm9jYWNoZSIsImdldCIsImZvcmNlVXBkYXRlIiwicmVzcG9uc2UiLCJzcGxpdCIsInJlZHVjZSIsInJldHVybmVkUmVzcG9uc2UiLCJjdXJyZW50UHJvcCIsInBheWxvYWQiLCJwb3N0IiwidXNlckFwaUtleSIsImNvbW1vbiIsIl9zZXRDc3JmVG9rZW4iLCJfZ2V0Q2FsbFJlc3VsdCIsImRlc2NlbmRpbmciLCJwb3N0cyIsInJldmVyc2UiLCJmaWx0ZXIiLCJwb3N0X3R5cGUiLCJ0b3BpY0lkIiwidG9waWMiLCJwb3N0X3N0cmVhbSIsInVzZXJuYW1lIiwiZmllbGQiLCJnZXRQdWJsaWNVc2VyRmllbGRzIiwidXNlckZpZWxkcyIsIm1lc3NhZ2UiLCJfZW5mb3JjZVVzZXJBcGlLZXkiLCJfcG9zdENhbGxSZXN1bHQiLCJ0b3BpY19pZCIsInJhdyIsImhpZGRlbiIsIlByb21pc2UiLCJyZWplY3QiLCJoaWRkZW5fcmVhc29uX2lkIiwiY2F0Y2giLCJlcnJvcnMiLCJhcHBJZCIsIl9zbHVnaWZ5Iiwia20iLCJLZXlNYW5hZ2VyIiwiZ2V0S2V5cyIsIl9tYW5hZ2VQYXlsb2FkIiwiZ2V0UHVibGljS2V5IiwiX2dlbmVyYXRlU3RvcmVkUmFuZG9tIiwiX2dldFN0b3JlZFJhbmRvbSIsImhyZWYiLCJwYXJhbXMiLCJhcHBsaWNhdGlvbl9uYW1lIiwicHVibGljX2tleSIsIm5vbmNlIiwiY2xpZW50X2lkIiwiYXV0aF9yZWRpcmVjdCIsIl9zZXJpYWxpemVQYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiayIsImVuY29kZVVSSUNvbXBvbmVudCIsIm5hbWUiLCJzdG9yZWRSYW5kb20iLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJyZW1vdmVJdGVtIiwiX3JlbW92ZVN0b3JlZFJhbmRvbSIsInVybCIsIlVSTFNlYXJjaFBhcmFtcyIsIndpbmRvdyIsInNlYXJjaCIsImhhc2giLCJoYXMiLCJvcGVuZXIiLCJkZWNyeXB0UGF5bG9hZCIsInBheWxvYWRPYmplY3QiLCJwb3N0TWVzc2FnZSIsInRleHQiLCJ0b0xvd2VyQ2FzZSIsImZvcmdlIiwicmVxdWlyZSIsImdlbmVyYXRlIiwicmVzb2x2ZSIsInJzYSIsImdlbmVyYXRlS2V5UGFpciIsIndvcmtlclNjcmlwdCIsImdlbmVyYXRlZEtleXBhaXIiLCJrZXlwYWlyIiwicHVibGljIiwicGtpIiwicHVibGljS2V5VG9QZW0iLCJwdWJsaWNLZXkiLCJwcml2YXRlIiwicHJpdmF0ZUtleVRvUGVtIiwicHJpdmF0ZUtleSIsImtleUdlbmVyYXRvciIsImRlZmF1bHQiLCJyZWFkS2V5c0Zyb21TdG9yYWdlIiwiZ2VuZXJhdGVOZXdLZXlwYWlyIiwiZ2V0UHJpdmF0ZUtleSIsIkpzZW5jcnlwdCIsImpzZW5jcnlwdCIsInNldFByaXZhdGVLZXkiLCJkZWNyeXB0Iiwid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJzZWxmIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJnZXR0ZXIiLCJvIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwibiIsIl9fZXNNb2R1bGUiLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsInVzZVB1cmVKYXZhU2NyaXB0IiwiYmFzZU4iLCJ1dGlsIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiYnJvd3NlciIsInNldEltbWVkaWF0ZSIsImFwcGx5IiwidW5kZWZpbmVkIiwiYXJndW1lbnRzIiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0IiwiaGFuZGxlciIsImV2ZW50Iiwic291cmNlIiwibXNnIiwic3RvcFByb3BhZ2F0aW9uIiwiY29weSIsImNhbGxiYWNrcyIsInNsaWNlIiwiZm9yRWFjaCIsInB1c2giLCJhZGRFdmVudExpc3RlbmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm5vdyIsIkRhdGUiLCJhdHRyIiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJvbGRTZXRJbW1lZGlhdGUiLCJzZXRBdHRyaWJ1dGUiLCJpc05vZGVqcyIsInZlcnNpb25zIiwibm9kZSIsImlzQXJyYXkiLCJ4IiwiaXNBcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJidWZmZXIiLCJieXRlTGVuZ3RoIiwiX2NoZWNrQml0c1BhcmFtIiwiQnl0ZUJ1ZmZlciIsIkJ5dGVTdHJpbmdCdWZmZXIiLCJiIiwicmVhZCIsIkJ1ZmZlciIsImFyciIsIlVpbnQ4QXJyYXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJlIiwicHV0Qnl0ZSIsIl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCIsIl9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCIsIl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nIiwiaXNFbXB0eSIsInB1dEJ5dGVzIiwiZmlsbFdpdGhCeXRlIiwiYnl0ZXMiLCJwdXRTdHJpbmciLCJzdHIiLCJlbmNvZGVVdGY4IiwicHV0SW50MTYiLCJwdXRJbnQyNCIsInB1dEludDMyIiwicHV0SW50MTZMZSIsInB1dEludDI0TGUiLCJwdXRJbnQzMkxlIiwicHV0SW50IiwicHV0U2lnbmVkSW50IiwicHV0QnVmZmVyIiwiZ2V0Qnl0ZXMiLCJnZXRCeXRlIiwiY2hhckNvZGVBdCIsImdldEludDE2IiwicnZhbCIsImdldEludDI0IiwiZ2V0SW50MzIiLCJnZXRJbnQxNkxlIiwiZ2V0SW50MjRMZSIsImdldEludDMyTGUiLCJnZXRJbnQiLCJnZXRTaWduZWRJbnQiLCJtYXgiLCJjb3VudCIsIm1pbiIsImNsZWFyIiwiYXQiLCJzZXRBdCIsImxhc3QiLCJjcmVhdGVCdWZmZXIiLCJjb21wYWN0IiwidHJ1bmNhdGUiLCJsZW4iLCJ0b0hleCIsImRlY29kZVV0ZjgiLCJEYXRhQnVmZmVyIiwicmVhZE9mZnNldCIsImdyb3dTaXplIiwiRGF0YVZpZXciLCJieXRlT2Zmc2V0Iiwid3JpdGUiLCJ3cml0ZU9mZnNldCIsImFjY29tbW9kYXRlIiwiYW1vdW50Iiwic3JjIiwiZHN0Iiwic2V0Iiwic2V0VWludDgiLCJlbmNvZGluZyIsInZpZXciLCJjZWlsIiwiYmluYXJ5IiwiaGV4IiwiZGVjb2RlIiwiYmFzZTY0IiwiVWludDE2QXJyYXkiLCJ1dGYxNiIsImVuY29kZSIsInNldEludDE2Iiwic2V0SW50OCIsInNldEludDMyIiwiZ2V0SW50OCIsImdldFVpbnQ4IiwidXRmOCIsImlucHV0IiwiZmlsbFN0cmluZyIsInhvckJ5dGVzIiwiczEiLCJzMiIsInMzIiwidCIsImhleFRvQnl0ZXMiLCJwYXJzZUludCIsImJ5dGVzVG9IZXgiLCJpbnQzMlRvQnl0ZXMiLCJfYmFzZTY0IiwiX2Jhc2U2NElkeCIsIl9iYXNlNTgiLCJlbmNvZGU2NCIsIm1heGxpbmUiLCJsaW5lIiwib3V0cHV0IiwiY2hyMSIsImNocjIiLCJjaHIzIiwiY2hhckF0IiwiaXNOYU4iLCJkZWNvZGU2NCIsImVuYzEiLCJlbmMyIiwiZW5jMyIsImVuYzQiLCJ1bmVzY2FwZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZSIsImJhc2U1OCIsIm9mZnNldCIsIm91dCIsImoiLCJzdWJhcnJheSIsImRlZmxhdGUiLCJzdGFydCIsImZsZyIsInN1YnN0cmluZyIsImluZmxhdGUiLCJfc2V0U3RvcmFnZU9iamVjdCIsImlkIiwib2JqIiwiX2dldFN0b3JhZ2VPYmplY3QiLCJfc2V0SXRlbSIsIl9nZXRJdGVtIiwiX3JlbW92ZUl0ZW0iLCJlbXB0eSIsIl9jbGVhckl0ZW1zIiwiX2NhbGxTdG9yYWdlRnVuY3Rpb24iLCJmdW5jIiwiYXJncyIsInR5cGUiLCJkb25lIiwiZXhjZXB0aW9uIiwiaWR4IiwiZXgiLCJjbGVhckl0ZW1zIiwicGFyc2VVcmwiLCJyZWdleCIsImxhc3RJbmRleCIsImV4ZWMiLCJmdWxsIiwic2NoZW1lIiwiaG9zdCIsInBvcnQiLCJwYXRoIiwiZnVsbEhvc3QiLCJfcXVlcnlWYXJpYWJsZXMiLCJnZXRRdWVyeVZhcmlhYmxlcyIsInF1ZXJ5IiwicSIsImt2cGFpcnMiLCJwb3MiLCJpbmRleE9mIiwidmFsIiwicGFyc2VGcmFnbWVudCIsImZyYWdtZW50IiwiZnAiLCJmcSIsInNoaWZ0IiwicGF0aFN0cmluZyIsInF1ZXJ5U3RyaW5nIiwibWFrZVJlcXVlc3QiLCJyZXFTdHJpbmciLCJmcmFnIiwicmVxIiwiZ2V0UGF0aCIsImdldFF1ZXJ5IiwiZ2V0UXVlcnlMYXN0IiwiX2RlZmF1bHQiLCJ2YWxzIiwibWFrZUxpbmsiLCJqUXVlcnkiLCJxc3RyIiwicGFyYW0iLCJzZXRQYXRoIiwidmFsdWUiLCJuZXh0IiwiaGFzTmV4dCIsImRlbGV0ZVBhdGgiLCJmb3JtYXQiLCJyZSIsIm1hdGNoIiwicGFydCIsImFyZ2kiLCJwYXJ0cyIsImNvZGUiLCJmb3JtYXROdW1iZXIiLCJudW1iZXIiLCJkZWNpbWFscyIsImRlY19wb2ludCIsInRob3VzYW5kc19zZXAiLCJhYnMiLCJ0b0ZpeGVkIiwiZm9ybWF0U2l6ZSIsImJ5dGVzRnJvbUlQIiwiaXAiLCJieXRlc0Zyb21JUHY0IiwiYnl0ZXNGcm9tSVB2NiIsIm51bSIsImJsYW5rcyIsInplcm9zIiwiYnl0ZXNUb0lQIiwiYnl0ZXNUb0lQdjQiLCJieXRlc1RvSVB2NiIsInplcm9Hcm91cHMiLCJ6ZXJvTWF4R3JvdXAiLCJlbmQiLCJncm91cCIsInNwbGljZSIsInVuc2hpZnQiLCJlc3RpbWF0ZUNvcmVzIiwidXBkYXRlIiwiY29yZXMiLCJuYXZpZ2F0b3IiLCJoYXJkd2FyZUNvbmN1cnJlbmN5IiwiV29ya2VyIiwiQmxvYiIsImJsb2JVcmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJzdCIsImV0Iiwic2FtcGxlIiwic2FtcGxlcyIsIm51bVdvcmtlcnMiLCJhdmciLCJmbG9vciIsInJldm9rZU9iamVjdFVSTCIsImVyciIsInJlc3VsdHMiLCJ3b3JrZXJzIiwid29ya2VyIiwidGVybWluYXRlIiwib3ZlcmxhcHMiLCJyMSIsIm92ZXJsYXAiLCJyMiIsImFzbjEiLCJDbGFzcyIsIlVOSVZFUlNBTCIsIkFQUExJQ0FUSU9OIiwiQ09OVEVYVF9TUEVDSUZJQyIsIlBSSVZBVEUiLCJUeXBlIiwiTk9ORSIsIkJPT0xFQU4iLCJJTlRFR0VSIiwiQklUU1RSSU5HIiwiT0NURVRTVFJJTkciLCJOVUxMIiwiT0lEIiwiT0RFU0MiLCJFWFRFUk5BTCIsIlJFQUwiLCJFTlVNRVJBVEVEIiwiRU1CRURERUQiLCJVVEY4IiwiUk9JRCIsIlNFUVVFTkNFIiwiU0VUIiwiUFJJTlRBQkxFU1RSSU5HIiwiSUE1U1RSSU5HIiwiVVRDVElNRSIsIkdFTkVSQUxJWkVEVElNRSIsIkJNUFNUUklORyIsInRhZ0NsYXNzIiwiY29uc3RydWN0ZWQiLCJ0bXAiLCJjb21wb3NlZCIsImJpdFN0cmluZ0NvbnRlbnRzIiwib3JpZ2luYWwiLCJleGNsdWRlQml0U3RyaW5nQ29udGVudHMiLCJlcXVhbHMiLCJvYmoxIiwib2JqMiIsImVxdWFsIiwiaW5jbHVkZUJpdFN0cmluZ0NvbnRlbnRzIiwiZ2V0QmVyVmFsdWVMZW5ndGgiLCJiMiIsImxvbmdGb3JtIiwiX2NoZWNrQnVmZmVyTGVuZ3RoIiwicmVtYWluaW5nIiwiYXZhaWxhYmxlIiwicmVxdWVzdGVkIiwiX2dldFZhbHVlTGVuZ3RoIiwibG9uZ0Zvcm1CeXRlcyIsImZyb21EZXIiLCJzdHJpY3QiLCJkZWNvZGVCaXRTdHJpbmdzIiwiX2Zyb21EZXIiLCJkZXB0aCIsImIxIiwic2F2ZWRSZWFkIiwic2F2ZWRSZW1haW5pbmciLCJ1bnVzZWQiLCJzdWJPcHRpb25zIiwidmVyYm9zZSIsInVzZWQiLCJ0YyIsImFzbjFPcHRpb25zIiwidG9EZXIiLCJ1c2VCaXRTdHJpbmdDb250ZW50cyIsImxlbkJ5dGVzIiwib2lkVG9EZXIiLCJvaWQiLCJ2YWx1ZXMiLCJ2YWx1ZUJ5dGVzIiwiZGVyVG9PaWQiLCJ1dGNUaW1lVG9EYXRlIiwidXRjIiwiZGF0ZSIsInllYXIiLCJNTSIsIkREIiwiaGgiLCJtbSIsInNzIiwic2V0VVRDRnVsbFllYXIiLCJzZXRVVENIb3VycyIsImhob2Zmc2V0IiwibW1vZmZzZXQiLCJzZXRUaW1lIiwiZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlIiwiZ2VudGltZSIsIllZWVkiLCJmZmYiLCJpc1VUQyIsInBhcnNlRmxvYXQiLCJzZXRGdWxsWWVhciIsInNldEhvdXJzIiwiZGF0ZVRvVXRjVGltZSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImRhdGVUb0dlbmVyYWxpemVkVGltZSIsImludGVnZXJUb0RlciIsImludGVnZXIiLCJkZXJUb0ludGVnZXIiLCJ2YWxpZGF0ZSIsInYiLCJjYXB0dXJlIiwib3B0aW9uYWwiLCJjYXB0dXJlQXNuMSIsImNhcHR1cmVCaXRTdHJpbmdDb250ZW50cyIsImNhcHR1cmVCaXRTdHJpbmdWYWx1ZSIsIl9ub25MYXRpblJlZ2V4IiwicHJldHR5UHJpbnQiLCJsZXZlbCIsImluZGVudGF0aW9uIiwiaW5kZW50IiwiSUE1U3RyaW5nIiwic3VidmFsdWVzIiwic3ViIiwib2lkcyIsInRlc3QiLCJfSU4iLCJfSV8iLCJtZCIsImFsZ29yaXRobXMiLCJwcm5nX2FlcyIsIl9wcm5nX2Flc19vdXRwdXQiLCJfcHJuZ19hZXNfYnVmZmVyIiwiZm9ybWF0S2V5IiwiYWVzIiwiX2V4cGFuZEtleSIsImZvcm1hdFNlZWQiLCJzZWVkIiwiY2lwaGVyIiwiX3VwZGF0ZUJsb2NrIiwiaW5jcmVtZW50Iiwic2hhMjU2Iiwic3Bhd25Qcm5nIiwiY3R4IiwicHJuZyIsImdldEJ5dGVzU3luYyIsIl9jdHgiLCJnZXRSYW5kb21WYWx1ZXMiLCJfY3J5cHRvIiwiY3J5cHRvIiwibXNDcnlwdG8iLCJjb2xsZWN0SW50IiwiX25hdkJ5dGVzIiwiY29sbGVjdCIsIm1vdXNlbW92ZSIsImNsaWVudFgiLCJjbGllbnRZIiwia2V5cHJlc3MiLCJjaGFyQ29kZSIsImNyZWF0ZUluc3RhbmNlIiwiQmlnSW50ZWdlciIsImpzYm4iLCJHQ0RfMzBfREVMVEEiLCJwcml2YXRlS2V5VmFsaWRhdG9yIiwicnNhUHJpdmF0ZUtleVZhbGlkYXRvciIsInJzYVB1YmxpY0tleVZhbGlkYXRvciIsInB1YmxpY0tleVZhbGlkYXRvciIsImVtc2FQa2NzMXYxNWVuY29kZSIsImFsZ29yaXRobSIsIm9pZEJ5dGVzIiwiZGlnZXN0SW5mbyIsImRpZ2VzdEFsZ29yaXRobSIsImRpZ2VzdCIsIl9tb2RQb3ciLCJwdWIiLCJtb2RQb3ciLCJkUCIsIm1vZCIsInN1YnRyYWN0IiwiT05FIiwiZFEiLCJxSW52IiwibW9kSW52ZXJzZSIsInIiLCJiaXRMZW5ndGgiLCJjb21wYXJlVG8iLCJnY2QiLCJtdWx0aXBseSIsInhwIiwieHEiLCJhZGQiLCJ5IiwiZW5jcnlwdCIsImJ0IiwiZWIiLCJfZW5jb2RlUGtjczFfdjFfNSIsInloZXgiLCJlZCIsIm1sIiwiZXhwZWN0ZWQiLCJ4aGV4IiwiX2RlY29kZVBrY3MxX3YxXzUiLCJjcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlIiwiYml0cyIsInJuZyIsIm5leHRCeXRlcyIsInN0YXRlIiwiZUludCIsInFCaXRzIiwicEJpdHMiLCJwcVN0YXRlIiwiZnJvbUludCIsInN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlIiwiVEhJUlRZIiwiZGVsdGFJZHgiLCJvcF9vciIsInQxIiwidDIiLCJ0b3RhbCIsImJpdHMxIiwidGVzdEJpdCIsImJpdHdpc2VUbyIsInNoaWZ0TGVmdCIsImRBZGRPZmZzZXQiLCJieXRlVmFsdWUiLCJpc1Byb2JhYmxlUHJpbWUiLCJfZ2V0TWlsbGVyUmFiaW5UZXN0cyIsInAxIiwicTEiLCJwaGkiLCJzZXRQdWJsaWNLZXkiLCJfZGV0ZWN0U3VidGxlQ3J5cHRvIiwic3VidGxlIiwiZ2VuZXJhdGVLZXkiLCJtb2R1bHVzTGVuZ3RoIiwicHVibGljRXhwb25lbnQiLCJfaW50VG9VaW50OEFycmF5IiwicGFpciIsImV4cG9ydEtleSIsInBrY3M4IiwicHJpdmF0ZUtleUZyb21Bc24xIiwic2V0UnNhUHVibGljS2V5IiwiX2RldGVjdFN1YnRsZU1zQ3J5cHRvIiwiZ2VuT3AiLCJvbmNvbXBsZXRlIiwidGFyZ2V0IiwiZXhwb3J0T3AiLCJvbmVycm9yIiwiX2dlbmVyYXRlS2V5UGFpciIsInNjaGVtZU9wdGlvbnMiLCJ0b1VwcGVyQ2FzZSIsInBrY3MxIiwiZW5jb2RlX3JzYV9vYWVwIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwic2V0UnNhUHJpdmF0ZUtleSIsImRlY29kZV9yc2Ffb2FlcCIsInNpZ24iLCJ3cmFwUnNhUHJpdmF0ZUtleSIsInJzYUtleSIsInJzYUVuY3J5cHRpb24iLCJwcml2YXRlS2V5TW9kdWx1cyIsInByaXZhdGVLZXlQdWJsaWNFeHBvbmVudCIsInByaXZhdGVLZXlQcml2YXRlRXhwb25lbnQiLCJwcml2YXRlS2V5UHJpbWUxIiwicHJpdmF0ZUtleVByaW1lMiIsInByaXZhdGVLZXlFeHBvbmVudDEiLCJwcml2YXRlS2V5RXhwb25lbnQyIiwicHJpdmF0ZUtleUNvZWZmaWNpZW50IiwicHJpdmF0ZUtleVRvQXNuMSIsInByaXZhdGVLZXlUb1JTQVByaXZhdGVLZXkiLCJfYm5Ub0J5dGVzIiwicHVibGljS2V5RnJvbUFzbjEiLCJwdWJsaWNLZXlPaWQiLCJyc2FQdWJsaWNLZXkiLCJwdWJsaWNLZXlNb2R1bHVzIiwicHVibGljS2V5RXhwb25lbnQiLCJwdWJsaWNLZXlUb0FzbjEiLCJwdWJsaWNLZXlUb1N1YmplY3RQdWJsaWNLZXlJbmZvIiwicHVibGljS2V5VG9SU0FQdWJsaWNLZXkiLCJwYWROdW0iLCJwYWRCeXRlIiwibnVtWmVyb3MiLCJwYWRCeXRlcyIsImVtIiwiZmlyc3QiLCJ6ZXJvIiwib3B0cyIsIndvcmtMb2FkIiwiZ2V0UHJpbWUiLCJmaW5pc2giLCJwcmltZSIsImdlbmVyYXRlUHJvYmFibGVQcmltZSIsImZuIiwiX3ByaXZhdGVLZXlGcm9tSndrIiwiandrIiwia3R5IiwiX2Jhc2U2NFRvQmlnSW50IiwiZHAiLCJkcSIsInFpIiwiX3B1YmxpY0tleUZyb21Kd2siLCJiNjQiLCJzdGFydEVuY3J5cHRpbmciLCJpdiIsIm1vZGUiLCJfY3JlYXRlQ2lwaGVyIiwiY3JlYXRlRW5jcnlwdGlvbkNpcGhlciIsInN0YXJ0RGVjcnlwdGluZyIsImNyZWF0ZURlY3J5cHRpb25DaXBoZXIiLCJBbGdvcml0aG0iLCJpbml0aWFsaXplIiwiYmxvY2tTaXplIiwiaW5CbG9jayIsIm91dEJsb2NrIiwiX3ciLCJfaW5pdCIsImVuY3J5cHRPcCIsInJlZ2lzdGVyQWxnb3JpdGhtIiwibW9kZXMiLCJlY2IiLCJjYmMiLCJjZmIiLCJvZmIiLCJjdHIiLCJnY20iLCJOYiIsInNib3giLCJpc2JveCIsInJjb24iLCJtaXgiLCJpbWl4IiwieHRpbWUiLCJlaSIsImUyIiwiZTQiLCJlOCIsInN4Iiwic3gyIiwibWUiLCJpbWUiLCJ3IiwidGVtcCIsImlOayIsIk5rIiwiTnIxIiwibTAiLCJtMSIsIm0yIiwibTMiLCJ3bmV3Iiwid2kiLCJOciIsImEiLCJhMiIsImMyIiwicm91bmQiLCJjcmVhdGVEZWNpcGhlciIsImNyZWF0ZUNpcGhlciIsInBlbSIsImhlYWRlciIsInByb2NUeXBlIiwidmVyc2lvbiIsImZvbGRIZWFkZXIiLCJjb250ZW50RG9tYWluIiwiZGVrSW5mbyIsInBhcmFtZXRlcnMiLCJib2R5Iiwick1lc3NhZ2UiLCJySGVhZGVyIiwickNSTEYiLCJsaW5lcyIsImxpIiwibmwiLCJ2aSIsImx0cmltIiwiaW5zZXJ0U3BhY2UiLCIkMSIsImNhbmRpZGF0ZSIsImluc2VydCIsInBiZSIsImVuY3J5cHRlZFByaXZhdGVLZXlWYWxpZGF0b3IiLCJQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IiLCJwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IiLCJlbmNyeXB0UHJpdmF0ZUtleUluZm8iLCJwYXNzd29yZCIsInNhbHRTaXplIiwicHJmQWxnb3JpdGhtIiwic2FsdCIsImNvdW50Qnl0ZXMiLCJka0xlbiIsImVuY3J5cHRpb25BbGdvcml0aG0iLCJlbmNyeXB0ZWREYXRhIiwiaXZMZW4iLCJlbmNPaWQiLCJjaXBoZXJGbiIsImRlcyIsInByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdCIsImRrIiwicGtjczUiLCJwYmtkZjIiLCJjcmVhdGVQYmtkZjJQYXJhbXMiLCJzYWx0Qnl0ZXMiLCJnZW5lcmF0ZVBrY3MxMktleSIsImRlY3J5cHRQcml2YXRlS2V5SW5mbyIsImVuY3J5cHRpb25PaWQiLCJnZXRDaXBoZXIiLCJlbmNyeXB0aW9uUGFyYW1zIiwiZW5jcnlwdGVkIiwiZW5jcnlwdGVkUHJpdmF0ZUtleVRvUGVtIiwiZXBraSIsImVuY3J5cHRlZFByaXZhdGVLZXlGcm9tUGVtIiwiaGVhZGVyVHlwZSIsImVuY3J5cHRSc2FQcml2YXRlS2V5IiwibGVnYWN5Iiwib3BlbnNzbERlcml2ZUJ5dGVzIiwiZGVjcnlwdFJzYVByaXZhdGVLZXkiLCJyYzIiLCJpdGVyIiwic2hhMSIsInUiLCJkaWdlc3RMZW5ndGgiLCJibG9ja0xlbmd0aCIsInBhc3NCdWYiLCJEIiwiU2xlbiIsIlMiLCJQbGVuIiwiUCIsIkkiLCJidWYiLCJCIiwiSW5ldyIsImNodW5rIiwiZ2V0Q2lwaGVyRm9yUEJFUzIiLCJnZXRDaXBoZXJGb3JQS0NTMTJQQkUiLCJzdXBwb3J0ZWRPaWRzIiwia2RmT2lkIiwia2RmU2FsdCIsImtkZkl0ZXJhdGlvbkNvdW50IiwicHJmT2lkVG9NZXNzYWdlRGlnZXN0IiwicHJmT2lkIiwiZW5jSXYiLCJpdGVyYXRpb25zIiwiZEl2TGVuIiwibWQ1IiwiZGlnZXN0cyIsInN1cHBvcnRlZCIsInNoYTUxMiIsImdldEFsZ29yaXRobSIsIkJsb2NrQ2lwaGVyIiwiX2ZpbmlzaCIsIl9pbnB1dCIsIl9vcCIsIl9kZWNyeXB0IiwicGFkIiwidW5wYWQiLCJvdmVyZmxvdyIsImFmdGVyRmluaXNoIiwiX2ludHMiLCJfaW5CbG9jayIsIl9vdXRCbG9jayIsInBhZGRpbmciLCJfcHJldiIsIl9pdiIsInRyYW5zZm9ybUlWIiwiX3BhcnRpYWxCbG9jayIsIl9wYXJ0aWFsT3V0cHV0IiwiX3BhcnRpYWxCeXRlcyIsImlucHV0TGVuZ3RoIiwicGFydGlhbEJ5dGVzIiwiaW5jMzIiLCJfUiIsIl9jaXBoZXJMZW5ndGgiLCJhZGRpdGlvbmFsRGF0YSIsIl90YWdMZW5ndGgiLCJ0YWdMZW5ndGgiLCJfdGFnIiwidGFnIiwiX2hhc2hCbG9jayIsIl9oYXNoU3Via2V5IiwiY29tcG9uZW50Qml0cyIsIl9tIiwiZ2VuZXJhdGVIYXNoVGFibGUiLCJpdkxlbmd0aCIsIl9qMCIsImdoYXNoIiwiY29uY2F0IiwiZnJvbTY0VG8zMiIsIl9hRGF0YUxlbmd0aCIsIl9zIiwibGVuZ3RocyIsInpfaSIsInZfaSIsInhfaSIsInBvdyIsImxzYiIsInRhYmxlTXVsdGlwbHkiLCJ6IiwiYWgiLCJoIiwibXVsdGlwbGllciIsInBlckludCIsInNoZnQiLCJnZW5lcmF0ZVN1Ykhhc2hUYWJsZSIsIm1pZCIsImhhbGYiLCJtX2kiLCJtX2oiLCJibG9jayIsIl9rZXlzIiwiX2NyZWF0ZUtleXMiLCJzcGZ1bmN0aW9uMSIsInNwZnVuY3Rpb24yIiwic3BmdW5jdGlvbjMiLCJzcGZ1bmN0aW9uNCIsInNwZnVuY3Rpb241Iiwic3BmdW5jdGlvbjYiLCJzcGZ1bmN0aW9uNyIsInNwZnVuY3Rpb244IiwicGMyYnl0ZXMwIiwicGMyYnl0ZXMxIiwicGMyYnl0ZXMyIiwicGMyYnl0ZXMzIiwicGMyYnl0ZXM0IiwicGMyYnl0ZXM1IiwicGMyYnl0ZXM2IiwicGMyYnl0ZXM3IiwicGMyYnl0ZXM4IiwicGMyYnl0ZXM5IiwicGMyYnl0ZXMxMCIsInBjMmJ5dGVzMTEiLCJwYzJieXRlczEyIiwicGMyYnl0ZXMxMyIsInNoaWZ0cyIsImxlZnQiLCJyaWdodCIsImxlZnR0bXAiLCJyaWdodHRtcCIsImxvb3BpbmciLCJlbmRsb29wIiwibG9vcGluYyIsInJpZ2h0MSIsInJpZ2h0MiIsInBia2RmMlN5bmMiLCJoTGVuIiwicHJmIiwiaG1hYyIsInhvciIsInVfYyIsInVfYzEiLCJvdXRlciIsImlubmVyIiwiX2tleSIsIl9tZCIsIl9pcGFkZGluZyIsIl9vcGFkZGluZyIsImtleWxlbiIsImdldE1hYyIsImRiaXRzIiwiY2FuYXJ5Iiwial9sbSIsImZyb21OdW1iZXIiLCJmcm9tU3RyaW5nIiwibmJpIiwiYW0xIiwiYW0yIiwieGwiLCJ4aCIsImFtMyIsImFtIiwiREIiLCJETSIsIkRWIiwiQklfRlAiLCJGViIsIkYxIiwiRjIiLCJCSV9STSIsIkJJX1JDIiwicnIiLCJ2diIsImludDJjaGFyIiwiaW50QXQiLCJibnBDb3B5VG8iLCJibnBGcm9tSW50IiwibmJ2IiwiYm5wRnJvbVN0cmluZyIsImZyb21SYWRpeCIsIm1pIiwic2giLCJjbGFtcCIsIlpFUk8iLCJzdWJUbyIsImJucENsYW1wIiwiYm5Ub1N0cmluZyIsIm5lZ2F0ZSIsInRvUmFkaXgiLCJibk5lZ2F0ZSIsImJuQWJzIiwiYm5Db21wYXJlVG8iLCJuYml0cyIsImJuQml0TGVuZ3RoIiwiYm5wRExTaGlmdFRvIiwiYm5wRFJTaGlmdFRvIiwiYm5wTFNoaWZ0VG8iLCJicyIsImNicyIsImJtIiwiZHMiLCJibnBSU2hpZnRUbyIsImJucFN1YlRvIiwiYm5wTXVsdGlwbHlUbyIsImJucFNxdWFyZVRvIiwiYm5wRGl2UmVtVG8iLCJwbSIsInB0IiwiY29weVRvIiwidHMiLCJtcyIsIm5zaCIsImxTaGlmdFRvIiwieXMiLCJ5MCIsInl0IiwiZDEiLCJkMiIsImRsU2hpZnRUbyIsInFkIiwiZHJTaGlmdFRvIiwiclNoaWZ0VG8iLCJibk1vZCIsImRpdlJlbVRvIiwiQ2xhc3NpYyIsImNDb252ZXJ0IiwiY1JldmVydCIsImNSZWR1Y2UiLCJjTXVsVG8iLCJtdWx0aXBseVRvIiwiY1NxclRvIiwic3F1YXJlVG8iLCJjb252ZXJ0IiwicmV2ZXJ0IiwibXVsVG8iLCJzcXJUbyIsImJucEludkRpZ2l0IiwiTW9udGdvbWVyeSIsIm1wIiwiaW52RGlnaXQiLCJtcGwiLCJtcGgiLCJ1bSIsIm10MiIsIm1vbnRDb252ZXJ0IiwibW9udFJldmVydCIsIm1vbnRSZWR1Y2UiLCJ1MCIsIm1vbnRTcXJUbyIsIm1vbnRNdWxUbyIsImJucElzRXZlbiIsImJucEV4cCIsImciLCJibk1vZFBvd0ludCIsImlzRXZlbiIsImV4cCIsIm1vZFBvd0ludCIsImJuQ2xvbmUiLCJibkludFZhbHVlIiwiYm5CeXRlVmFsdWUiLCJiblNob3J0VmFsdWUiLCJibnBDaHVua1NpemUiLCJMTjIiLCJsb2ciLCJiblNpZ051bSIsImJucFRvUmFkaXgiLCJzaWdudW0iLCJjcyIsImNodW5rU2l6ZSIsImludFZhbHVlIiwiYm5wRnJvbVJhZGl4IiwiZE11bHRpcGx5IiwiYm5wRnJvbU51bWJlciIsImJuVG9CeXRlQXJyYXkiLCJibkVxdWFscyIsImJuTWluIiwiYm5NYXgiLCJibnBCaXR3aXNlVG8iLCJvcCIsImYiLCJvcF9hbmQiLCJibkFuZCIsImJuT3IiLCJvcF94b3IiLCJiblhvciIsIm9wX2FuZG5vdCIsImJuQW5kTm90IiwiYm5Ob3QiLCJiblNoaWZ0TGVmdCIsImJuU2hpZnRSaWdodCIsImxiaXQiLCJibkdldExvd2VzdFNldEJpdCIsImNiaXQiLCJibkJpdENvdW50IiwiYm5UZXN0Qml0IiwiYm5wQ2hhbmdlQml0IiwiYm5TZXRCaXQiLCJjaGFuZ2VCaXQiLCJibkNsZWFyQml0IiwiYm5GbGlwQml0IiwiYm5wQWRkVG8iLCJibkFkZCIsImFkZFRvIiwiYm5TdWJ0cmFjdCIsImJuTXVsdGlwbHkiLCJibkRpdmlkZSIsImJuUmVtYWluZGVyIiwiYm5EaXZpZGVBbmRSZW1haW5kZXIiLCJibnBETXVsdGlwbHkiLCJibnBEQWRkT2Zmc2V0IiwiTnVsbEV4cCIsIm5Ob3AiLCJuTXVsVG8iLCJuU3FyVG8iLCJiblBvdyIsImJucE11bHRpcGx5TG93ZXJUbyIsImJucE11bHRpcGx5VXBwZXJUbyIsIkJhcnJldHQiLCJxMyIsIm11IiwiZGl2aWRlIiwiYmFycmV0dENvbnZlcnQiLCJiYXJyZXR0UmV2ZXJ0IiwiYmFycmV0dFJlZHVjZSIsIm11bHRpcGx5VXBwZXJUbyIsIm11bHRpcGx5TG93ZXJUbyIsImJhcnJldHRTcXJUbyIsImJhcnJldHRNdWxUbyIsImJuTW9kUG93IiwiazEiLCJnMiIsImlzMSIsImJuR0NEIiwiY2xvbmUiLCJnZXRMb3dlc3RTZXRCaXQiLCJibnBNb2RJbnQiLCJibk1vZEludmVyc2UiLCJhYyIsImxvd3ByaW1lcyIsImxwbGltIiwiYm5Jc1Byb2JhYmxlUHJpbWUiLCJtb2RJbnQiLCJtaWxsZXJSYWJpbiIsImJucE1pbGxlclJhYmluIiwibjEiLCJzaGlmdFJpZ2h0IiwiYm5HZXRQcm5nIiwic2hvcnRWYWx1ZSIsInRvQnl0ZUFycmF5IiwiYW5kIiwib3IiLCJhbmROb3QiLCJub3QiLCJiaXRDb3VudCIsInNldEJpdCIsImNsZWFyQml0IiwiZmxpcEJpdCIsInJlbWFpbmRlciIsImRpdmlkZUFuZFJlbWFpbmRlciIsIl9pbml0aWFsaXplZCIsIl9zdGF0ZSIsIm1lc3NhZ2VMZW5ndGgiLCJmdWxsTWVzc2FnZUxlbmd0aCIsIm1lc3NhZ2VMZW5ndGhTaXplIiwibWVzc2FnZUxlbmd0aDY0IiwiaW50MzJzIiwiaDAiLCJoMSIsImgyIiwiaDMiLCJoNCIsIl91cGRhdGUiLCJmaW5hbEJsb2NrIiwiX3BhZGRpbmciLCJjYXJyeSIsIl9zaG9ydE5hbWVzIiwieDUwOUNlcnRpZmljYXRlVmFsaWRhdG9yIiwicnNhc3NhUHNzUGFyYW1ldGVyVmFsaWRhdG9yIiwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmFsaWRhdG9yIiwiY2VydGlmaWNhdGlvblJlcXVlc3RWYWxpZGF0b3IiLCJSRE5BdHRyaWJ1dGVzQXNBcnJheSIsInJkbiIsInNpIiwidmFsdWVUYWdDbGFzcyIsInNob3J0TmFtZSIsIkNSSUF0dHJpYnV0ZXNBc0FycmF5Iiwic2VxIiwiZXh0ZW5zaW9uUmVxdWVzdCIsImV4dGVuc2lvbnMiLCJjZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xIiwiX2dldEF0dHJpYnV0ZSIsIl9yZWFkU2lnbmF0dXJlUGFyYW1ldGVycyIsImZpbGxEZWZhdWx0cyIsImFsZ29yaXRobU9pZCIsIm1nZiIsInNhbHRMZW5ndGgiLCJoYXNoT2lkIiwibWFza0dlbk9pZCIsIm1hc2tHZW5IYXNoT2lkIiwiY2VydGlmaWNhdGVGcm9tUGVtIiwiY29tcHV0ZUhhc2giLCJjZXJ0aWZpY2F0ZUZyb21Bc24xIiwiY2VydGlmaWNhdGVUb1BlbSIsImNlcnQiLCJjZXJ0aWZpY2F0ZVRvQXNuMSIsInB1YmxpY0tleUZyb21QZW0iLCJwdWJsaWNLZXlUb1JTQVB1YmxpY0tleVBlbSIsImdldFB1YmxpY0tleUZpbmdlcnByaW50IiwiZGVsaW1pdGVyIiwiY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tUGVtIiwiY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMSIsImNlcnRpZmljYXRpb25SZXF1ZXN0VG9QZW0iLCJjc3IiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSIsImNyZWF0ZUNlcnRpZmljYXRlIiwic2VyaWFsTnVtYmVyIiwic2lnbmF0dXJlT2lkIiwic2lnaW5mbyIsInZhbGlkaXR5Iiwibm90QmVmb3JlIiwibm90QWZ0ZXIiLCJpc3N1ZXIiLCJnZXRGaWVsZCIsInNuIiwiYWRkRmllbGQiLCJfZmlsbE1pc3NpbmdGaWVsZHMiLCJzdWJqZWN0Iiwic2V0U3ViamVjdCIsImF0dHJzIiwidW5pcXVlSWQiLCJzZXRJc3N1ZXIiLCJzZXRFeHRlbnNpb25zIiwiZXh0cyIsIl9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyIsImdldEV4dGVuc2lvbiIsImV4dCIsInRic0NlcnRpZmljYXRlIiwiZ2V0VEJTQ2VydGlmaWNhdGUiLCJjaGlsZCIsImlzc3VlZCIsImV4cGVjdGVkSXNzdWVyIiwiYWN0dWFsSXNzdWVyIiwic2hhMzg0Iiwic2hhMVdpdGhSU0FFbmNyeXB0aW9uIiwic2lnbmF0dXJlUGFyYW1ldGVycyIsInBzcyIsImlzSXNzdWVyIiwicGFyZW50IiwiaWF0dHIiLCJzYXR0ciIsImdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIiLCJ2ZXJpZnlTdWJqZWN0S2V5SWRlbnRpZmllciIsInNraSIsInN1YmplY3RLZXlJZGVudGlmaWVyIiwiY2VydFZlcnNpb24iLCJzZXJpYWwiLCJjZXJ0U2VyaWFsTnVtYmVyIiwiY2VydFNpZ25hdHVyZU9pZCIsImNlcnRTaWduYXR1cmVQYXJhbXMiLCJjZXJ0aW5mb1NpZ25hdHVyZU9pZCIsImNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zIiwiY2VydFNpZ25hdHVyZSIsImNlcnRWYWxpZGl0eTFVVENUaW1lIiwiY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZSIsImNlcnRWYWxpZGl0eTNVVENUaW1lIiwiY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSIsImltZCIsImNlcnRJc3N1ZXIiLCJjZXJ0SXNzdWVyVW5pcXVlSWQiLCJzbWQiLCJjZXJ0U3ViamVjdCIsImNlcnRTdWJqZWN0VW5pcXVlSWQiLCJjZXJ0RXh0ZW5zaW9ucyIsImNlcnRpZmljYXRlRXh0ZW5zaW9uc0Zyb21Bc24xIiwic3ViamVjdFB1YmxpY0tleUluZm8iLCJleHRzZXEiLCJjcml0aWNhbCIsImV2IiwiYjMiLCJkaWdpdGFsU2lnbmF0dXJlIiwibm9uUmVwdWRpYXRpb24iLCJrZXlFbmNpcGhlcm1lbnQiLCJkYXRhRW5jaXBoZXJtZW50Iiwia2V5QWdyZWVtZW50Iiwia2V5Q2VydFNpZ24iLCJjUkxTaWduIiwiZW5jaXBoZXJPbmx5IiwiZGVjaXBoZXJPbmx5IiwiY0EiLCJwYXRoTGVuQ29uc3RyYWludCIsImNsaWVudCIsInNlcnZlciIsImVtYWlsIiwib2Jqc2lnbiIsInJlc2VydmVkIiwic3NsQ0EiLCJlbWFpbENBIiwib2JqQ0EiLCJhbHROYW1lcyIsImduIiwiYWx0TmFtZSIsImNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0IiwiY3NyVmVyc2lvbiIsImNzclNpZ25hdHVyZU9pZCIsImNzclNpZ25hdHVyZVBhcmFtcyIsImNzclNpZ25hdHVyZSIsImNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyIsImNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1N1YmplY3QiLCJnZXRBdHRyaWJ1dGUiLCJhZGRBdHRyaWJ1dGUiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9BdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlcyIsImdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyIsImNyaSIsIl9kblRvQXNuMSIsIl9nZXRBdHRyaWJ1dGVzQXNKc29uIiwiYXR0cmlidXRlIiwidmFsdWVDb25zdHJ1Y3RlZCIsImNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xIiwiZXh0ZW5zaW9uIiwia2V5SWRlbnRpZmllciIsImF1dGhvcml0eUNlcnRJc3N1ZXIiLCJzdWJTZXEiLCJmdWxsTmFtZUdlbmVyYWxOYW1lcyIsIl9zaWduYXR1cmVQYXJhbWV0ZXJzVG9Bc24xIiwiX0NSSUF0dHJpYnV0ZXNUb0FzbjEiLCJqYW5fMV8xOTUwIiwiamFuXzFfMjA1MCIsIl9kYXRlVG9Bc24xIiwidGJzIiwiY2VydGlmaWNhdGVFeHRlbnNpb25zVG9Bc24xIiwiZGlzdGluZ3Vpc2hlZE5hbWVUb0FzbjEiLCJkbiIsImNyZWF0ZUNhU3RvcmUiLCJjZXJ0cyIsImNhU3RvcmUiLCJnZXRJc3N1ZXIiLCJnZXRCeVN1YmplY3QiLCJhZGRDZXJ0aWZpY2F0ZSIsImVuc3VyZVN1YmplY3RIYXNIYXNoIiwiaGFzQ2VydGlmaWNhdGUiLCJkZXIxIiwiZGVyMiIsImxpc3RBbGxDZXJ0aWZpY2F0ZXMiLCJjZXJ0TGlzdCIsInJlbW92ZUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVFcnJvciIsImJhZF9jZXJ0aWZpY2F0ZSIsInVuc3VwcG9ydGVkX2NlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVfcmV2b2tlZCIsImNlcnRpZmljYXRlX2V4cGlyZWQiLCJjZXJ0aWZpY2F0ZV91bmtub3duIiwidW5rbm93bl9jYSIsInZlcmlmeUNlcnRpZmljYXRlQ2hhaW4iLCJjaGFpbiIsInNlbGZTaWduZWQiLCJwYXJlbnRzIiwidmVyaWZpZWQiLCJzZSIsImtleVVzYWdlIiwiYmFzaWNDb25zdHJhaW50cyIsImJjRXh0Iiwia2V5VXNhZ2VFeHQiLCJwYXRoTGVuIiwidmZkIiwicmV0Iiwic2FsdF8iLCJzTGVuIiwicHNzb2JqIiwibW9kQml0cyIsImVtQml0cyIsImVtTGVuIiwibUhhc2giLCJtXyIsInBzIiwiZGIiLCJtYXNrTGVuIiwiZGJNYXNrIiwibWFza2VkREIiLCJtYXNrIiwiY2hlY2tMZW4iLCJoXyIsInBlbVRvRGVyIiwicHJpdmF0ZUtleUZyb21QZW0iLCJwcml2YXRlS2V5SW5mb1RvUGVtIiwiX3JldmVyc2VBbHBoYWJldHMiLCJhbHBoYWJldCIsIlR5cGVFcnJvciIsIl9lbmNvZGVXaXRoQnl0ZUJ1ZmZlciIsImJhc2UiLCJkaWdpdHMiLCJ0YWJsZSIsImZyb20iLCJoNSIsImg2IiwiaDciLCJfayIsInMwIiwiY2giLCJtYWoiLCJwbHVnaW4iLCJ0aW1lIiwicmVzZWVkcyIsImdlbmVyYXRlZCIsImtleUJ5dGVzIiwicG9vbHMiLCJwb29sIiwiZ2VuZXJhdGVTeW5jIiwiX3Jlc2VlZCIsIl9yZXNlZWRTeW5jIiwiX3NlZWQiLCJuZWVkZWQiLCJzZWVkRmlsZSIsInNlZWRGaWxlU3luYyIsIl8ycG93SyIsInNlZWRCeXRlcyIsImRlZmF1bHRTZWVkRmlsZSIsImVudHJvcHkiLCJVaW50MzJBcnJheSIsIlF1b3RhRXhjZWVkZWRFcnJvciIsImhpIiwibG8iLCJyYW5kb21CeXRlcyIsInJlZ2lzdGVyV29ya2VyIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGlUYWJsZSIsInJvbCIsIndvcmQiLCJyb3IiLCJleHBhbmRLZXkiLCJlZmZLZXlCaXRzIiwiTCIsIlQiLCJUMSIsIlQ4IiwiVE0iLCJfb3V0cHV0IiwibWl4Um91bmQiLCJtYXNoUm91bmQiLCJLIiwiUiIsInJ1blBsYW4iLCJwbGFuIiwicHRyIiwibGFiZWwiLCJtZ2YxTWQiLCJtZ2YxIiwia2V5TGVuZ3RoIiwibWF4TGVuZ3RoIiwibEhhc2giLCJQUyIsIlBTX2xlbmd0aCIsInNlZWRMZW5ndGgiLCJyc2FfbWdmMSIsInNlZWRNYXNrIiwibWFza2VkU2VlZCIsImV4cGVjdGVkTGVuZ3RoIiwibEhhc2hQcmltZSIsImluX3BzIiwiaW5kZXgiLCJpc18wIiwiZXJyb3JfbWFzayIsIm1hc2tMZW5ndGgiLCJwcmltZWluY0ZpbmRQcmltZSIsInByaW1laW5jRmluZFByaW1lV2l0aFdvcmtlcnMiLCJwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzIiwiZ2VuZXJhdGVSYW5kb20iLCJtclRlc3RzIiwiZ2V0TWlsbGVyUmFiaW5UZXN0cyIsIm1pbGxlclJhYmluVGVzdHMiLCJtYXhCbG9ja1RpbWUiLCJfcHJpbWVpbmMiLCJyYW5nZSIsInJ1bm5pbmciLCJ3b3JrZXJNZXNzYWdlIiwiZm91bmQiLCJwMTIiLCJwa2NzMTIiLCJjb250ZW50SW5mb1ZhbGlkYXRvciIsInBmeFZhbGlkYXRvciIsInNhZmVCYWdWYWxpZGF0b3IiLCJhdHRyaWJ1dGVWYWxpZGF0b3IiLCJjZXJ0QmFnVmFsaWRhdG9yIiwiX2dldEJhZ3NCeUF0dHJpYnV0ZSIsInNhZmVDb250ZW50cyIsImF0dHJOYW1lIiwiYXR0clZhbHVlIiwiYmFnVHlwZSIsInNhZmVCYWdzIiwiYmFnIiwicGtjczEyRnJvbUFzbjEiLCJwZngiLCJnZXRCYWdzIiwibG9jYWxLZXlJZCIsImxvY2FsS2V5SWRIZXgiLCJmcmllbmRseU5hbWUiLCJnZXRCYWdzQnlGcmllbmRseU5hbWUiLCJnZXRCYWdzQnlMb2NhbEtleUlkIiwiY29udGVudFR5cGUiLCJjb250ZW50IiwiX2RlY29kZVBrY3M3RGF0YSIsIm1hYyIsIm1hY0tleUJ5dGVzIiwibWFjQWxnb3JpdGhtIiwibWFjU2FsdCIsIm1hY0l0ZXJhdGlvbnMiLCJtYWNLZXkiLCJtYWNWYWx1ZSIsIm1hY0RpZ2VzdCIsIl9kZWNvZGVBdXRoZW50aWNhdGVkU2FmZSIsImF1dGhTYWZlIiwiY29udGVudEluZm8iLCJfZGVjcnlwdFNhZmVDb250ZW50cyIsIl9kZWNvZGVTYWZlQ29udGVudHMiLCJwa2NzNyIsImVuY3J5cHRlZERhdGFWYWxpZGF0b3IiLCJlbmNBbGdvcml0aG0iLCJlbmNQYXJhbWV0ZXIiLCJlbmNyeXB0ZWRDb250ZW50QXNuMSIsInJlcyIsInNhZmVCYWciLCJiYWdJZCIsIl9kZWNvZGVCYWdBdHRyaWJ1dGVzIiwiYmFnQXR0cmlidXRlcyIsInZhbGlkYXRvciIsImRlY29kZXIiLCJiYWdBc24xIiwiYmFnVmFsdWUiLCJwa2NzOFNocm91ZGVkS2V5QmFnIiwia2V5QmFnIiwiY2VydEJhZyIsImNlcnRJZCIsIng1MDlDZXJ0aWZpY2F0ZSIsImNlcnRBc24xIiwiZGVjb2RlZEF0dHJzIiwidG9Qa2NzMTJBc24xIiwidXNlTWFjIiwiZ2VuZXJhdGVMb2NhbEtleUlkIiwiYmFnQXR0cnMiLCJwYWlyZWRDZXJ0IiwiY29udGVudHMiLCJjZXJ0U2FmZUJhZ3MiLCJjZXJ0QmFnQXR0cnMiLCJjZXJ0U2FmZUJhZyIsImNlcnRTYWZlQ29udGVudHMiLCJjZXJ0Q0kiLCJwa0FzbjEiLCJrZXlTYWZlQ29udGVudHMiLCJrZXlDSSIsInNhZmUiLCJtYWNEYXRhIiwicDd2IiwicGtjczdhc24xIiwiZW5jcnlwdGVkQ29udGVudEluZm9WYWxpZGF0b3IiLCJlbnZlbG9wZWREYXRhVmFsaWRhdG9yIiwic2lnbmVyVmFsaWRhdG9yIiwic2lnbmVkRGF0YVZhbGlkYXRvciIsInJlY2lwaWVudEluZm9WYWxpZGF0b3IiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGdCQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxrREFBMEM7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBLGtEQUEwQyxvQkFBb0IsV0FBVzs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0IsdUJBQXVCO0FBQ3ZDOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUlBO0FBQUE7QUFDQSxXQUFXLFNBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSxPQUFPLDhCQUE4QixFQUFFOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCLEVBQUU7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCLEVBQUU7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseUJBQXlCLEVBQUU7QUFDN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSCxDQUFDO0FBQ2MsbUZBQW9CLEVBQUM7Ozs7Ozs7Ozs7Ozs7QUNwWHBDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQztBQUNBO0FBQ21CO0FBQ047QUFDOUM7QUFDQTtBQUNlO0FBQ2Y7QUFDQSw2QkFBNkIsY0FBYztBQUMzQyxxTkFBcU4sZ0RBQVEsRUFBRSxzQ0FBc0M7QUFDclE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrRUFBVztBQUNyQztBQUNBLDBCQUEwQixxRUFBYztBQUN4QztBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsK0NBQWlCO0FBQ3pFO0FBQ0EsMkJBQTJCLGlEQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQixFQUFFLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEOzs7Ozs7Ozs7Ozs7O0FDdkRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QjtBQUM0QjtBQUNNO0FBQ0M7QUFDakUsaUM7Ozs7Ozs7Ozs7OztBQ1RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUM7QUFDQTtBQUNtQjtBQUNyQztBQUNmO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0MsdUhBQXVILGdEQUFRLEVBQUUsVUFBVTtBQUMzSTtBQUNBLDRDQUE0QyxRQUFRLCtDQUFpQjtBQUNyRTtBQUNBLG1CQUFtQixpREFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVMsRUFBRSxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFFQUFjO0FBQ2xDO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRDs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0Q7QUFDbkM7QUFDZjtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLG1CQUFtQixpRUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLHVDOzs7Ozs7Ozs7OztBQ1RBLGlCQUFpQixtQkFBTyxDQUFDLHNEQUFhLEU7Ozs7Ozs7Ozs7OztBQ0F6Qjs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGlFQUFrQjtBQUN2QyxlQUFlLG1CQUFPLENBQUMsMkVBQXVCO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDNUQsa0JBQWtCLG1CQUFPLENBQUMseUVBQXFCO0FBQy9DLHlGQUF5RixtQkFBTyxDQUFDLG1FQUFtQjs7QUFFcEg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBK0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7O0FDbkxhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3QixXQUFXLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyw0REFBYztBQUNsQyxlQUFlLG1CQUFPLENBQUMsd0RBQVk7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGtFQUFpQjtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQW1COztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvRUFBa0I7O0FBRXpDOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbEJhOztBQUViLGFBQWEsbUJBQU8sQ0FBQywyREFBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDeERhOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0phOztBQUViLGVBQWUsbUJBQU8sQ0FBQywyREFBZTtBQUN0QyxZQUFZLG1CQUFPLENBQUMscURBQVk7QUFDaEMseUJBQXlCLG1CQUFPLENBQUMsaUZBQXNCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDJFQUFtQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGtDQUFrQyxjQUFjO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7Ozs7Ozs7OztBQzlFYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNuRGE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMscUVBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakJhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxREFBWTtBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHVFQUFvQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMseURBQWE7QUFDcEMsb0JBQW9CLG1CQUFPLENBQUMscUZBQTRCO0FBQ3hELGtCQUFrQixtQkFBTyxDQUFDLGlGQUEwQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7OztBQ3JGYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBZTs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE1BQU07QUFDakIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkEsK0NBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGtEQUFTO0FBQzdCLDBCQUEwQixtQkFBTyxDQUFDLDhGQUErQjs7QUFFakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxpRUFBaUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFlBQVk7QUFDbkI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FDL0ZhOztBQUViO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNuQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsT0FBTzs7QUFFUDtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsNkJBQTZCLGFBQWEsRUFBRTtBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7O0FDcERhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYixZQUFZLG1CQUFPLENBQUMscURBQVk7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7O0FDbkVhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxtREFBVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7O0FDWGE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHFEQUFZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGVBQWU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQmE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGdFQUFnQjtBQUNuQyxlQUFlLG1CQUFPLENBQUMsb0RBQVc7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVMsR0FBRyxTQUFTO0FBQzVDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlTWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxvREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYSxFQUFFLEtBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWSxFQUFFLEtBQUs7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuZEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFD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QUFzQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsS0FBSzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFvQjs7QUFFL0M7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLDZEQUFVOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RCwyQkFBMkIsbURBQW1EO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlyQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyQkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZCQUE2QjtBQUNsRTtBQUNBO0FBQ0EsUUFBUSwyQkFBMkI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkJBQTJCO0FBQzFFO0FBQ0E7QUFDQSxRQUFRLDZCQUE2QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDalhBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVxQkEsZTs7O0FBQ25CLDJCQUFZQyxPQUFaLEVBQXFCO0FBQUE7O0FBQ25CLFNBQUtDLGVBQUwsQ0FBcUJELE9BQXJCOztBQUNBLFNBQUtBLE9BQUwsR0FBZSxLQUFLRSxjQUFMLENBQW9CRixPQUFwQixDQUFmO0FBQ0EsU0FBS0csSUFBTCxHQUFZLElBQUlDLHNCQUFKLENBQWtCLEtBQUtKLE9BQXZCLENBQVo7QUFDQSxTQUFLSyxHQUFMLEdBQVcsSUFBSUMscUJBQUosQ0FBaUIsS0FBS04sT0FBTCxDQUFhTyxVQUE5QixDQUFYO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7dUJBR08sS0FBS0osSUFBTCxDQUFVSyxJQUFWLEU7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQ0FHUVIsTyxFQUFTO0FBQ3RCQSxhQUFPLElBQUksUUFBT0EsT0FBUCxNQUFtQixRQUEvQjtBQUFBO0FBQUEsUUFDUSxJQUFJUyxLQUFKLENBQVUsMkJBQVYsQ0FEUjtBQUVDLGFBQU9ULE9BQU8sQ0FBQ1UsT0FBZixLQUEyQixRQUEzQixJQUF1Q1YsT0FBTyxDQUFDVSxPQUFSLENBQWdCQyxNQUFoQixHQUF5QixDQUFqRTtBQUFBO0FBQUEsUUFDUSxJQUFJRixLQUFKLENBQVUsNENBQVYsQ0FEUjtBQUVDLGFBQU9ULE9BQU8sQ0FBQ08sVUFBZixLQUE4QixRQUE5QixJQUEwQ1AsT0FBTyxDQUFDTyxVQUFSLENBQW1CSSxNQUFuQixHQUE0QixDQUF2RTtBQUFBO0FBQUEsUUFDUSxJQUFJRixLQUFKLENBQVUsK0NBQVYsQ0FEUjtBQUVDVCxhQUFPLENBQUNZLE1BQVIsWUFBMEJDLEtBQTFCLElBQW1DYixPQUFPLENBQUNZLE1BQVIsQ0FBZUQsTUFBZixHQUF3QixDQUE1RDtBQUFBO0FBQUEsUUFDUSxJQUFJRixLQUFKLENBQVUsMENBQVYsQ0FEUjtBQUVEOzs7bUNBRWNULE8sRUFBUztBQUN0QixVQUFNYyxnQkFBZ0IscUJBQVFkLE9BQVIsQ0FBdEIsQ0FEc0IsQ0FHdEI7OztBQUNBYyxzQkFBZ0IsQ0FBQ1AsVUFBakIsR0FBOEJQLE9BQU8sQ0FBQ08sVUFBUixDQUFtQlEsT0FBbkIsQ0FBMkIsS0FBM0IsRUFBa0MsRUFBbEMsQ0FBOUI7QUFDQUQsc0JBQWdCLENBQUNGLE1BQWpCLEdBQTBCWixPQUFPLENBQUNZLE1BQVIsQ0FBZUksSUFBZixDQUFvQixHQUFwQixDQUExQjtBQUNBLGFBQU9GLGdCQUFQO0FBQ0Q7OztvQ0FFZTtBQUNkLGFBQU8sS0FBS2QsT0FBTCxDQUFhTyxVQUFwQjtBQUNEOzs7Ozs7Ozs7OztvQkFHTSxLQUFLSixJQUFMLENBQVVjLGNBQVYsRTs7Ozs7a0RBQ0ksSzs7Ozs7dUJBSUQsS0FBS0MsbUJBQUwsRTs7O2tEQUNDLEk7Ozs7O2tEQUVBLEs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQ0FJTTtBQUNmLGFBQU9DLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxZQUFZLENBQUNDLE9BQWIsQ0FBcUIsYUFBckIsQ0FBWCxDQUFQO0FBQ0Q7Ozt5Q0FFb0I7QUFDbkIsYUFBTyxLQUFLQyxjQUFMLEdBQXNCLFVBQXRCLENBQVA7QUFDRDs7O2dEQUUyQjtBQUMxQixhQUFPLEtBQUtBLGNBQUwsR0FBc0IsTUFBdEIsQ0FBUDtBQUNEOzs7NENBRXVCO0FBQ3RCLGFBQU8sQ0FBQyxLQUFLQSxjQUFMLEdBQXNCLGtCQUF0QixDQUFSO0FBQ0Q7Ozs0Q0FFdUJDLEksRUFBTTtBQUM1QixhQUFPLENBQ0wsS0FBS3hCLE9BQUwsQ0FBYU8sVUFEUixFQUVMLEtBQUtnQixjQUFMLEdBQXNCLGlCQUF0QixFQUF5Q1IsT0FBekMsQ0FBaUQsUUFBakQsRUFBNERTLElBQUksSUFBSSxHQUFwRSxDQUZLLEVBR0xSLElBSEssQ0FHQSxHQUhBLENBQVA7QUFJRDs7O3FEQUVnQztBQUMvQixhQUFPLENBQ0wsS0FBS2hCLE9BQUwsQ0FBYU8sVUFEUixFQUVMLEdBRkssRUFHTCxLQUFLa0Isa0JBQUwsRUFISyxFQUlMLGVBSkssRUFLTFQsSUFMSyxDQUtBLEdBTEEsQ0FBUDtBQU1EOzs7Ozs7Ozs7Ozs7K0JBSUdLLFk7K0JBQW9DRixJOzt1QkFBcUIsS0FBS2QsR0FBTCxDQUFTcUIscUJBQVQsRTs7Ozs0Q0FBaEJDLFM7OzZCQUE1QkMsTyxvQkFBUSxhOzs7Ozs7Ozs7dUJBRWYsS0FBS0MsTUFBTCxFOzs7c0JBQ0EsSUFBSXBCLEtBQUosQ0FBVSxnQkFBVixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFLRSxLQUFLcUIsVUFBTCxFOzs7Ozs7Ozs7OzsrQkFJSkMsc0I7O3VCQUF5QixLQUFLNUIsSUFBTCxDQUFVNkIsWUFBVixFOzs7OytCQUEwQjtBQUN2REMsdUJBQUssRUFBRSxHQURnRDtBQUV2REMsd0JBQU0sRUFBRSxHQUYrQztBQUd2REMsOEJBQVksRUFBRSxJQUFJQyxNQUFKLENBQVcsTUFBTUMsUUFBUSxDQUFDQyxNQUExQjtBQUh5QyxpQjs7Ozs7OzswQ0FJakQsa0JBQU1DLElBQU47QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUNBQ0EsS0FBSSxDQUFDbEMsR0FBTCxDQUFTbUMsY0FBVCxDQUF3QkQsSUFBSSxDQUFDRSxNQUFMLENBQVlDLEdBQXBDLENBREE7O0FBQUE7QUFBQTtBQUFBLG1DQUVBLEtBQUksQ0FBQ3hCLG1CQUFMLEVBRkE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUI7Ozs7Ozs7K0JBS1I7QUFDQSwwQkFBQ3lCLEtBQUQsRUFBVztBQUNULDBCQUFRQSxLQUFSO0FBQ0UseUJBQUssUUFBTDtBQUNFQyxtQ0FBYSxDQUFDLElBQUlDLEtBQUosQ0FBVSx3QkFBVixDQUFELENBQWI7QUFDQSw0QkFBTSxJQUFJcEMsS0FBSixDQUFVLGdEQUFWLENBQU47O0FBQ0YseUJBQUssU0FBTDtBQUNFbUMsbUNBQWEsQ0FBQyxJQUFJQyxLQUFKLENBQVUsdUJBQVYsQ0FBRCxDQUFiO0FBQ0EsNEJBQU0sSUFBSXBDLEtBQUosQ0FBVSxvREFBVixDQUFOOztBQUNGO0FBQ0UsNEJBQU0sSUFBSUEsS0FBSixDQUFVLGlEQUFWLEVBQTZEa0MsS0FBN0QsQ0FBTjtBQVJKO0FBVUQsaUI7OytCQUFPO0FBQUEseUJBQU1DLGFBQWEsQ0FBQyxJQUFJQyxLQUFKLENBQVUsbUJBQVYsQ0FBRCxDQUFuQjtBQUFBLGlCOzs7b0NBckJZQyxJLGdEQUlqQkMsSSw2QkFpQkFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFJRyxLQUFLMUMsR0FBTCxDQUFTd0IsTUFBVCxDQUFnQixLQUFLSixrQkFBTCxFQUFoQixDOzs7QUFDTixxQkFBS3RCLElBQUwsQ0FBVTZDLGNBQVY7O0FBQ0FKLDZCQUFhLENBQUMsSUFBSUMsS0FBSixDQUFVLG9CQUFWLENBQUQsQ0FBYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlISjs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFFcUJ2QyxZOzs7QUFDbkIsd0JBQVlDLFVBQVosRUFBd0I7QUFBQTs7QUFDdEIsU0FBS0EsVUFBTCxHQUFrQkEsVUFBbEI7QUFDQSxTQUFLRixHQUFMLEdBQVc0QyxlQUFNQyxNQUFOLENBQWE7QUFDdEJDLGFBQU8sRUFBRSxLQUFLNUMsVUFEUTtBQUV0QjZDLGFBQU8sRUFBRTtBQUNQLDRCQUFvQixnQkFEYjtBQUVQLHlCQUFpQixVQUZWO0FBR1Asd0JBQWdCO0FBSFQsT0FGYTtBQU90QkMsYUFBTyxFQUFFLDhDQUNQLDJDQUFxQkosZUFBTUssUUFBTixDQUFlRCxPQUFwQyxDQURPLEVBRVA7QUFBRUUsaUJBQVMsRUFBRSxHQUFiLENBQW1COztBQUFuQixPQUZPO0FBUGEsS0FBYixDQUFYOztBQWFBLFNBQUtmLGNBQUwsQ0FBb0JuQixZQUFZLENBQUNDLE9BQWIsQ0FBcUIsY0FBckIsQ0FBcEI7QUFDRDs7Ozs7OzsrQ0FFb0JrQyxRLEVBQVVDLEk7Ozs7Ozs7O0FBQU1DLHVCLDJEQUFVLEs7Ozt1QkFJekIsS0FBS3JELEdBQUwsQ0FBU3NELEdBQVQsQ0FBYUgsUUFBYixFQUF1QjtBQUFFSSw2QkFBVyxFQUFFRjtBQUFmLGlCQUF2QixDOzs7QUFBbEJHLHdCLGlCQUFvRXRCLEk7Ozs7Ozs7c0JBRTlELElBQUk5QixLQUFKLGE7OztBQUdSLG9CQUFJZ0QsSUFBSixFQUFVO0FBQ1JJLDBCQUFRLEdBQUdKLElBQUksQ0FBQ0ssS0FBTCxDQUFXLEdBQVgsRUFBZ0JDLE1BQWhCLENBQXVCLFVBQUNDLGdCQUFELEVBQW1CQyxXQUFuQjtBQUFBLDJCQUNoQ0QsZ0JBQWdCLENBQUNDLFdBQUQsQ0FEZ0I7QUFBQSxtQkFBdkIsRUFDc0JKLFFBRHRCLENBQVg7QUFFRDs7aURBRU1BLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFHYUwsUSxFQUFVVSxPOzs7Ozs7dUJBQ2hCLEtBQUs3RCxHQUFMLENBQVM4RCxJQUFULENBQWNYLFFBQWQsRUFBd0JVLE9BQXhCLEM7OztpRUFBa0MzQixJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBRzdCNkIsVTs7Ozs7b0JBQ2RBLFU7Ozs7Ozs7O0FBR0wscUJBQUsvRCxHQUFMLENBQVNpRCxRQUFULENBQWtCRixPQUFsQixDQUEwQmlCLE1BQTFCLENBQWlDLGNBQWpDLElBQW1ERCxVQUFuRDs7dUJBQ00sS0FBS0UsYUFBTCxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJBSW1ELEtBQUtDLGNBQUwsQ0FBb0Isb0JBQXBCLEVBQTBDLE1BQTFDLEM7OztBQUF6RCxxQkFBS2xFLEdBQUwsQ0FBU2lELFFBQVQsQ0FBa0JGLE9BQWxCLENBQTBCaUIsTUFBMUIsQ0FBaUMsY0FBakMsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lDQUdtQjtBQUNuQixXQUFLaEUsR0FBTCxDQUFTaUQsUUFBVCxDQUFrQkYsT0FBbEIsQ0FBMEJpQixNQUExQixDQUFpQyxjQUFqQztBQUFBO0FBQUEsUUFBMEQsSUFBSTVELEtBQUosQ0FBVSxzQkFBVixDQUExRDtBQUNEOzs7Ozs7Ozs7Ozs7dUJBR2MsS0FBSzhELGNBQUwsQ0FBb0IsdUJBQXBCLEVBQTZDLGNBQTdDLEVBQTZELElBQTdELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFHTUMsVTs7Ozs7Ozs7dUJBSUgsS0FBS0QsY0FBTCxDQUFvQixhQUFwQixFQUFtQyxjQUFuQyxDOzs7QUFBZEUscUI7Ozs7Ozs7c0JBRU0sSUFBSWhFLEtBQUosYzs7O0FBR1Isb0JBQUkrRCxVQUFKLEVBQWdCO0FBQ2RDLHVCQUFLLEdBQUdBLEtBQUssQ0FBQ0MsT0FBTixFQUFSO0FBQ0Q7O2tEQUVNRCxLQUFLLENBQUNFLE1BQU4sQ0FBYSxVQUFBUixJQUFJO0FBQUEseUJBQUlBLElBQUksQ0FBQ1MsU0FBTCxLQUFtQixDQUF2QjtBQUFBLGlCQUFqQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBR2FDLE8sRUFBU0wsVSxFQUFZZCxPOzs7Ozs7O3VCQUN2QixLQUFLYSxjQUFMLENBQW9CLFFBQVFNLE9BQVIsR0FBa0IsOEJBQXRDLEVBQ2hCLG1CQURnQixFQUNLbkIsT0FETCxDOzs7QUFBZGUscUI7O0FBR0osb0JBQUlELFVBQUosRUFBZ0I7QUFDZEMsdUJBQUssR0FBR0EsS0FBSyxDQUFDQyxPQUFOLEVBQVI7QUFDRDs7a0RBRU1ELEtBQUssQ0FBQ0UsTUFBTixDQUFhLFVBQUFSLElBQUk7QUFBQSx5QkFBSUEsSUFBSSxDQUFDUyxTQUFMLEtBQW1CLENBQXZCO0FBQUEsaUJBQWpCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFHTUMsTyxFQUFTTCxVOzs7Ozs7O3VCQUNKLEtBQUtELGNBQUwsQ0FBb0IsUUFBUU0sT0FBUixHQUFrQix3QkFBdEMsQzs7O0FBQWRDLHFCO0FBRUpBLHFCQUFLLENBQUNDLFdBQU4sQ0FBa0JOLEtBQWxCLEdBQTBCSyxLQUFLLENBQUNDLFdBQU4sQ0FBa0JOLEtBQWxCLENBQXdCRSxNQUF4QixDQUErQixVQUFBUixJQUFJO0FBQUEseUJBQUlBLElBQUksQ0FBQ1MsU0FBTCxLQUFtQixDQUF2QjtBQUFBLGlCQUFuQyxDQUExQjs7QUFFQSxvQkFBSUosVUFBSixFQUFnQjtBQUNkTSx1QkFBSyxDQUFDQyxXQUFOLENBQWtCTixLQUFsQixHQUEwQkssS0FBSyxDQUFDQyxXQUFOLENBQWtCTixLQUFsQixDQUF3QkMsT0FBeEIsRUFBMUI7QUFDRDs7a0RBRU1JLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFHaUJFLFE7Ozs7Ozt1QkFDWCxLQUFLVCxjQUFMLENBQW9CLFFBQVFTLFFBQVIsR0FBbUIsbUJBQXZDLEVBQTRELGtCQUE1RCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aURBR1VBLFEsRUFBVUMsSzs7Ozs7Ozt1QkFDUixLQUFLQyxtQkFBTCxDQUF5QkYsUUFBekIsQzs7O0FBQW5CRywwQjttREFFQ0EsVUFBVSxJQUFJQSxVQUFVLENBQUNGLEtBQUQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lEQUdmSixPLEVBQVNPLE87Ozs7O0FBQ3pCLHFCQUFLQyxrQkFBTDs7O3VCQUNhLEtBQUtDLGVBQUwsQ0FBcUIsYUFBckIsRUFBb0M7QUFDL0M7QUFDQUMsMEJBQVEsRUFBRVYsT0FGcUM7QUFHL0NXLHFCQUFHLEVBQUVKO0FBQ0w7O0FBSitDLGlCQUFwQyxFQUtWckMsSUFMVSxDQUtMLFVBQUFjLFFBQVEsRUFBSTtBQUNsQkEsMEJBQVEsQ0FBQzRCLE1BQVQsSUFBbUJDLE9BQU8sQ0FBQ0MsTUFBUixDQUFlOUIsUUFBUSxDQUFDK0IsZ0JBQXhCLENBQW5CO0FBQ0EseUJBQU8vQixRQUFQO0FBQ0QsaUJBUlksRUFRVmdDLEtBUlUsQ0FRSixVQUFBbEQsS0FBSztBQUFBLHlCQUFJK0MsT0FBTyxDQUFDQyxNQUFSLENBQWVoRCxLQUFLLENBQUNrQixRQUFOLENBQWV0QixJQUFmLENBQW9CdUQsTUFBbkMsQ0FBSjtBQUFBLGlCQVJELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpREFXRmQsUTs7Ozs7QUFDWCxxQkFBS0ssa0JBQUwsRyxDQUNBOzs7O3VCQUNNLEtBQUtoRixHQUFMLENBQVM4RCxJQUFULENBQWMsc0JBQWQsQzs7O0FBQ04sdUJBQU8sS0FBSzlELEdBQUwsQ0FBU2lELFFBQVQsQ0FBa0JGLE9BQWxCLENBQTBCaUIsTUFBMUIsQ0FBaUMsY0FBakMsQ0FBUDtBQUNBLHVCQUFPLEtBQUtoRSxHQUFMLENBQVNpRCxRQUFULENBQWtCRixPQUFsQixDQUEwQmlCLE1BQTFCLENBQWlDLGNBQWpDLENBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsSUo7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ3hEO0lBRXFCakUsYTs7O0FBQ25CLHlCQUFZSixPQUFaLEVBQXFCO0FBQUE7O0FBQ25CLFNBQUsrRixLQUFMLEdBQWEsS0FBS0MsUUFBTCxDQUFjaEcsT0FBTyxDQUFDVSxPQUF0QixDQUFiO0FBQ0EsU0FBS3VGLEVBQUwsR0FBVSxJQUFJQyxtQkFBSixDQUFlLEtBQUtILEtBQXBCLENBQVY7QUFDQSxTQUFLL0YsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7dUJBR08sS0FBS2lHLEVBQUwsQ0FBUUUsT0FBUixFOzs7QUFDTixxQkFBS2xGLGNBQUwsTUFBeUIsS0FBS21GLGNBQUwsRUFBekI7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQ0FHZTtBQUNmLGFBQU8vRSxZQUFZLENBQUNDLE9BQWIsQ0FBcUIsY0FBckIsTUFBeUMsSUFBaEQ7QUFDRDs7Ozs7Ozs7Ozs7OytCQUtxQixLQUFLdEIsT0FBTCxDQUFhVSxPOzt1QkFDYixLQUFLdUYsRUFBTCxDQUFRSSxZQUFSLEU7Ozs7K0JBQ1gsS0FBS0MscUJBQUwsQ0FBMkIsT0FBM0IsQzsrQkFDSSxLQUFLQyxnQkFBTCxDQUFzQixVQUF0QixLQUFxQyxLQUFLRCxxQkFBTCxDQUEyQixVQUEzQixDOytCQUNqQ2pFLFFBQVEsQ0FBQ21FLEk7K0JBQ2hCLEtBQUt4RyxPQUFMLENBQWFZLE07QUFQakI2RixzQjtBQUVKQyxrQztBQUNBQyw0QjtBQUNBQyx1QjtBQUNBQywyQjtBQUNBQywrQjtBQUNBbEcsd0I7O2tEQUlLLEtBQUtaLE9BQUwsQ0FBYU8sVUFBYixHQUEwQixvQkFBMUIsR0FBaUQsS0FBS3dHLGdCQUFMLENBQXNCTixNQUF0QixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7cUNBR3pDQSxNLEVBQVE7QUFDdkIsYUFBT08sTUFBTSxDQUFDQyxJQUFQLENBQVlSLE1BQVosRUFDSlMsR0FESSxDQUNBLFVBQUNDLENBQUQ7QUFBQSxlQUFPQyxrQkFBa0IsQ0FBQ0QsQ0FBRCxDQUFsQixHQUF3QixHQUF4QixHQUE4QkMsa0JBQWtCLENBQUNYLE1BQU0sQ0FBQ1UsQ0FBRCxDQUFQLENBQXZEO0FBQUEsT0FEQSxFQUVKbkcsSUFGSSxDQUVDLEdBRkQsQ0FBUDtBQUdEOzs7MENBRXFCcUcsSSxFQUFNO0FBQzFCLFVBQU1DLFlBQVksR0FBR0MsSUFBSSxDQUFDQyxNQUFMLEdBQWNDLFFBQWQsQ0FBdUIsRUFBdkIsRUFBMkJDLE1BQTNCLENBQWtDLENBQWxDLENBQXJCO0FBRUFyRyxrQkFBWSxDQUFDTyxPQUFiLENBQXFCLEtBQUttRSxLQUFMLEdBQWEsR0FBYixHQUFtQnNCLElBQXhDLEVBQThDQyxZQUE5QztBQUNBLGFBQU9BLFlBQVA7QUFDRDs7O3FDQUVnQkQsSSxFQUFNO0FBQ3JCLFVBQU1DLFlBQVksR0FBR2pHLFlBQVksQ0FBQ0MsT0FBYixDQUFxQixLQUFLeUUsS0FBTCxHQUFhLEdBQWIsR0FBbUJzQixJQUF4QyxDQUFyQjtBQUVBLGFBQU9DLFlBQVA7QUFDRDs7O3dDQUVtQkQsSSxFQUFNO0FBQ3hCaEcsa0JBQVksQ0FBQ3NHLFVBQWIsQ0FBd0IsS0FBSzVCLEtBQUwsR0FBYSxHQUFiLEdBQW1Cc0IsSUFBM0M7QUFDRDs7O3FDQUVnQjtBQUNmLGFBQU9oRyxZQUFZLENBQUNDLE9BQWIsQ0FBcUIsY0FBckIsQ0FBUDtBQUNEOzs7cUNBRWdCO0FBQ2ZELGtCQUFZLENBQUNzRyxVQUFiLENBQXdCLGNBQXhCO0FBQ0F0RyxrQkFBWSxDQUFDc0csVUFBYixDQUF3QixhQUF4Qjs7QUFDQSxXQUFLQyxtQkFBTCxDQUF5QixVQUF6QjtBQUNEOzs7cUNBRWdCO0FBQUE7O0FBQ2YsVUFBTUMsR0FBRyxHQUFHLElBQUlDLHdCQUFKLENBQW9CQyxNQUFNLENBQUMxRixRQUFQLENBQWdCMkYsTUFBaEIsSUFBMEJELE1BQU0sQ0FBQzFGLFFBQVAsQ0FBZ0I0RixJQUFoQixDQUFxQm5FLEtBQXJCLENBQTJCLEdBQTNCLEVBQWdDLENBQWhDLENBQTlDLENBQVo7O0FBRUEsVUFBSStELEdBQUcsQ0FBQ0ssR0FBSixDQUFRLFNBQVIsS0FBc0JDLE1BQTFCLEVBQWtDO0FBQ2hDLGFBQUtsQyxFQUFMLENBQVFtQyxjQUFSLENBQXVCUCxHQUFHLENBQUNsRSxHQUFKLENBQVEsU0FBUixDQUF2QixFQUEyQ1osSUFBM0MsQ0FBZ0QsVUFBQXNGLGFBQWEsRUFBSTtBQUMvREEsdUJBQWEsQ0FBQ3pCLEtBQWQsS0FBd0IsS0FBSSxDQUFDTCxnQkFBTCxDQUFzQixPQUF0QixDQUF4QjtBQUFBO0FBQUEsWUFDUSxJQUFJOUYsS0FBSixDQUFVLGtDQUFWLENBRFI7QUFFQTRILHVCQUFhLENBQUNoSSxHQUFkLEtBQXNCLENBQXRCO0FBQUE7QUFBQSxZQUNRLElBQUlJLEtBQUosQ0FBVSx3QkFBd0I0SCxhQUFhLENBQUNoSSxHQUF0QyxHQUE0QywwQ0FBdEQsQ0FEUjtBQUVBZ0Isc0JBQVksQ0FBQ08sT0FBYixDQUFxQixjQUFyQixFQUFxQ3lHLGFBQWEsQ0FBQzNGLEdBQW5EOztBQUNBLGVBQUksQ0FBQ2tGLG1CQUFMLENBQXlCLE9BQXpCOztBQUNBTyxnQkFBTSxDQUFDRyxXQUFQLENBQW1CO0FBQUU3RixrQkFBTSxFQUFFNEY7QUFBVixXQUFuQixFQUE4Q2hHLFFBQVEsQ0FBQ0MsTUFBdkQ7QUFDRCxTQVJEO0FBU0QsT0FiYyxDQWNmOztBQUNEOzs7NkJBRVFpRyxJLEVBQU07QUFDYixhQUFPQSxJQUFJLENBQUNkLFFBQUwsR0FBZ0JlLFdBQWhCLEdBQ0p6SCxPQURJLENBQ0ksTUFESixFQUNZLEdBRFosRUFFSkEsT0FGSSxDQUVJLFdBRkosRUFFaUIsRUFGakIsRUFHSkEsT0FISSxDQUdJLFFBSEosRUFHYyxHQUhkLEVBSUpBLE9BSkksQ0FJSSxLQUpKLEVBSVcsRUFKWCxFQUtKQSxPQUxJLENBS0ksS0FMSixFQUtXLEVBTFgsQ0FBUDtBQU1EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUZILElBQUkwSCxLQUFLLEdBQUdDLG1CQUFPLENBQUMscURBQUQsQ0FBbkI7O2VBRWdCLFlBQU07QUFDcEIsTUFBTUMsUUFBUSxHQUFHLFNBQVhBLFFBQVcsQ0FBQzVDLEtBQUQsRUFBVztBQUMxQixXQUFPLElBQUlMLE9BQUosQ0FBWSxVQUFDa0QsT0FBRCxFQUFVakQsTUFBVixFQUFxQjtBQUN0QzhDLFdBQUssQ0FBQ0ksR0FBTixDQUFVQyxlQUFWLENBQTBCO0FBQ3hCQyxvQkFBWSxFQUFFO0FBRFUsT0FBMUIsRUFHQSxVQUFDcEcsS0FBRCxFQUFRcUcsZ0JBQVIsRUFBNkI7QUFDM0JBLHdCQUFnQixHQUFJLFlBQU07QUFDeEIsY0FBTUMsT0FBTyxHQUFHO0FBQ2RDLGtCQUFNLEVBQUVULEtBQUssQ0FBQ1UsR0FBTixDQUFVQyxjQUFWLENBQXlCSixnQkFBZ0IsQ0FBQ0ssU0FBMUMsRUFBcUQsRUFBckQsRUFBeUR0SSxPQUF6RCxDQUFpRSxLQUFqRSxFQUF3RSxFQUF4RSxDQURNO0FBRWR1SSxtQkFBTyxFQUFFYixLQUFLLENBQUNVLEdBQU4sQ0FBVUksZUFBVixDQUEwQlAsZ0JBQWdCLENBQUNRLFVBQTNDLEVBQXVELEVBQXZELEVBQTJEekksT0FBM0QsQ0FBbUUsS0FBbkUsRUFBMEUsRUFBMUU7QUFGSyxXQUFoQjtBQUtBTSxzQkFBWSxDQUFDTyxPQUFiLENBQXFCbUUsS0FBSyxHQUFHLFlBQTdCLEVBQTJDa0QsT0FBTyxDQUFDQyxNQUFuRDtBQUNBN0gsc0JBQVksQ0FBQ08sT0FBYixDQUFxQm1FLEtBQUssR0FBRyxhQUE3QixFQUE0Q2tELE9BQU8sQ0FBQ0ssT0FBcEQ7QUFDQVYsaUJBQU8sQ0FBQ0ssT0FBRCxDQUFQO0FBQ0QsU0FUa0IsRUFBSCxHQVNUdEQsTUFBTSxDQUFDaEQsS0FBRCxDQVRiO0FBVUQsT0FkRDtBQWVELEtBaEJNLENBQVA7QUFpQkQsR0FsQkQ7O0FBb0JBLFNBQU87QUFBRWdHLFlBQVEsRUFBUkE7QUFBRixHQUFQO0FBQ0QsQ0F0QmMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ0ZNekMsVTs7O0FBQ25CLHNCQUFZSCxLQUFaLEVBQW1CO0FBQUE7O0FBQ2pCLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNEOzs7Ozs7Ozs7Ozs7OztpREFHUSx5SUFLYWhELElBTGIsQ0FLa0IsZ0JBQStCO0FBQUEsc0JBQW5CMEcsWUFBbUIsUUFBNUJDLE9BQTRCO0FBQ3RELHlCQUFPRCxZQUFZLENBQUNkLFFBQWIsQ0FBc0IsS0FBSSxDQUFDNUMsS0FBM0IsRUFBa0NoRCxJQUFsQyxDQUF1QyxVQUFDa0csT0FBRCxFQUFhO0FBQ3pELDJCQUFPQSxPQUFQO0FBQ0QsbUJBRk0sQ0FBUDtBQUdELGlCQVRNLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQWFBLEtBQUtVLG1CQUFMLEU7Ozs7Ozs7O3VCQUFvQyxLQUFLQyxrQkFBTCxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBR3ZCO0FBQ3BCLFVBQU1QLFNBQVMsR0FBR2hJLFlBQVksQ0FBQ0MsT0FBYixDQUFxQixLQUFLeUUsS0FBTCxHQUFhLFlBQWxDLENBQWxCO0FBQ0EsVUFBTXlELFVBQVUsR0FBR25JLFlBQVksQ0FBQ0MsT0FBYixDQUFxQixLQUFLeUUsS0FBTCxHQUFhLGFBQWxDLENBQW5CO0FBRUEsYUFBUXNELFNBQVMsSUFBSUcsVUFBZCxHQUNMO0FBQ0VOLGNBQU0sRUFBRUcsU0FEVjtBQUVFQyxlQUFPLEVBQUVFO0FBRlgsT0FESyxHQUlELElBSk47QUFLRDs7Ozs7Ozs7Ozs7O3VCQUdlLEtBQUtyRCxPQUFMLEU7OztpRUFBZ0IsUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VCQUloQixLQUFLQSxPQUFMLEU7OztpRUFBZ0IsUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQUdYakMsTzs7Ozs7a0RBQ1osS0FBSzJGLGFBQUwsR0FBcUI5RyxJQUFyQixDQUEwQixVQUFBeUcsVUFBVSxFQUFJO0FBQzdDLHlCQUFPLHFKQUtRekcsSUFMUixDQUthLGlCQUE0QjtBQUFBLHdCQUFoQitHLFNBQWdCLFNBQXpCSixPQUF5QjtBQUM5Qyx3QkFBTUssU0FBUyxHQUFHLElBQUlELFNBQUosRUFBbEI7QUFFQUMsNkJBQVMsQ0FBQ0MsYUFBVixDQUF3QlIsVUFBeEI7QUFDQSwyQkFBT3JJLElBQUksQ0FBQ0MsS0FBTCxDQUFXMkksU0FBUyxDQUFDRSxPQUFWLENBQWtCL0YsT0FBbEIsQ0FBWCxDQUFQO0FBQ0QsbUJBVk0sQ0FBUDtBQVdELGlCQVpNLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjVixDOzs7Ozs7Ozs7Ozs7d29HQ3hERCxDQUFDLFFBQVNnRyxpQ0FBVCxDQUEwQ0MsSUFBMUMsQ0FBZ0RDLE9BQWhELENBQXlELENBQ3pELEdBQUcsMEJBQU9DLE9BQVAsS0FBbUIsUUFBbkIsRUFBK0IsMEJBQU9DLE1BQVAsS0FBa0IsUUFBcEQsQ0FDQ0EsTUFBTSxDQUFDRCxPQUFQLENBQWlCRCxPQUFPLEVBQXhCLENBREQsSUFFSyxJQUFHLElBQUgsQ0FDSkcsaUNBQU8sRUFBRCxvQ0FBS0gsT0FBTDtBQUFBO0FBQUE7QUFBQSxvR0FBTixDQURJLElBRUEsR0FJTCxDQVRELEVBU0csTUFBT0ksS0FBUCxHQUFnQixXQUFoQixDQUE4QkEsSUFBOUIsT0FUSCxDQVM4QyxVQUFXLENBQ3pELE1BQU8sU0FBVSxTQUFTQyxPQUFULENBQWtCLENBQUU7QUFDckMsUUFEbUMsQ0FDekI7QUFDVixRQUFVLEdBQUlDLGlCQUFnQixDQUFHLEVBQXZCLENBQ1YsUUFIbUMsQ0FJbkMsUUFKbUMsQ0FJekI7QUFDVixRQUFVLFFBQVNDLG9CQUFULENBQTZCQyxRQUE3QixDQUF1QyxDQUNqRCxRQURpRCxDQUVqRCxRQUZpRCxDQUV0QztBQUNYLFFBQVcsR0FBR0YsZ0JBQWdCLENBQUNFLFFBQUQsQ0FBbkIsQ0FBK0IsQ0FDMUMsUUFBWSxNQUFPRixpQkFBZ0IsQ0FBQ0UsUUFBRCxDQUFoQixDQUEyQlAsT0FBbEMsQ0FDWixRQUFZLENBQ1osUUFOaUQsQ0FNdEM7QUFDWCxRQUFXLEdBQUlDLE9BQU0sQ0FBR0ksZ0JBQWdCLENBQUNFLFFBQUQsQ0FBaEIsQ0FBNkIsQ0FDckQsUUFBWUMsQ0FBQyxDQUFFRCxRQURzQyxDQUVyRCxRQUFZRSxDQUFDLENBQUUsS0FGc0MsQ0FHckQsUUFBWVQsT0FBTyxDQUFFLEVBQ3JCLFFBSnFELENBQTFDLENBS1gsUUFaaUQsQ0FhakQsUUFiaUQsQ0FhdEM7QUFDWCxRQUFXSSxPQUFPLENBQUNHLFFBQUQsQ0FBUCxDQUFrQkcsSUFBbEIsQ0FBdUJULE1BQU0sQ0FBQ0QsT0FBOUIsQ0FBdUNDLE1BQXZDLENBQStDQSxNQUFNLENBQUNELE9BQXRELENBQStETSxtQkFBL0QsRUFDWCxRQWZpRCxDQWdCakQsUUFoQmlELENBZ0J0QztBQUNYLFFBQVdMLE1BQU0sQ0FBQ1EsQ0FBUCxDQUFXLElBQVgsQ0FDWCxRQWxCaUQsQ0FtQmpELFFBbkJpRCxDQW1CdEM7QUFDWCxRQUFXLE1BQU9SLE9BQU0sQ0FBQ0QsT0FBZCxDQUNYLFFBQVcsQ0FDWCxRQTNCbUMsQ0E0Qm5DLFFBNUJtQyxDQTZCbkMsUUE3Qm1DLENBNkJ6QjtBQUNWLFFBQVVNLG1CQUFtQixDQUFDSyxDQUFwQixDQUF3QlAsT0FBeEIsQ0FDVixRQS9CbUMsQ0FnQ25DLFFBaENtQyxDQWdDekI7QUFDVixRQUFVRSxtQkFBbUIsQ0FBQ00sQ0FBcEIsQ0FBd0JQLGdCQUF4QixDQUNWLFFBbENtQyxDQW1DbkMsUUFuQ21DLENBbUN6QjtBQUNWLFFBQVVDLG1CQUFtQixDQUFDTyxDQUFwQixDQUF3QixTQUFTYixPQUFULENBQWtCaEQsSUFBbEIsQ0FBd0I4RCxNQUF4QixDQUFnQyxDQUNsRSxRQUFXLEdBQUcsQ0FBQ1IsbUJBQW1CLENBQUNTLENBQXBCLENBQXNCZixPQUF0QixDQUErQmhELElBQS9CLENBQUosQ0FBMEMsQ0FDckQsUUFBWUwsTUFBTSxDQUFDcUUsY0FBUCxDQUFzQmhCLE9BQXRCLENBQStCaEQsSUFBL0IsQ0FBcUMsQ0FDakQsUUFBYWlFLFlBQVksQ0FBRSxLQURzQixDQUVqRCxRQUFhQyxVQUFVLENBQUUsSUFGd0IsQ0FHakQsUUFBYTVILEdBQUcsQ0FBRXdILE1BQ2xCLFFBSmlELENBQXJDLEVBS1osUUFBWSxDQUNaLFFBQVcsQ0FSRCxDQVNWLFFBN0NtQyxDQThDbkMsUUE5Q21DLENBOEN6QjtBQUNWLFFBQVVSLG1CQUFtQixDQUFDYSxDQUFwQixDQUF3QixTQUFTbEIsTUFBVCxDQUFpQixDQUNuRCxRQUFXLEdBQUlhLE9BQU0sQ0FBR2IsTUFBTSxFQUFJQSxNQUFNLENBQUNtQixVQUFqQixDQUN4QixRQUFZLFFBQVNDLFdBQVQsRUFBc0IsQ0FBRSxNQUFPcEIsT0FBTSxDQUFDLFNBQUQsQ0FBYixDQUEyQixDQUR2QyxDQUV4QixRQUFZLFFBQVNxQixpQkFBVCxFQUE0QixDQUFFLE1BQU9yQixPQUFQLENBQWdCLENBRi9DLENBR1gsUUFBV0ssbUJBQW1CLENBQUNPLENBQXBCLENBQXNCQyxNQUF0QixDQUE4QixHQUE5QixDQUFtQ0EsTUFBbkMsRUFDWCxRQUFXLE1BQU9BLE9BQVAsQ0FDWCxRQUFXLENBTkQsQ0FPVixRQXREbUMsQ0F1RG5DLFFBdkRtQyxDQXVEekI7QUFDVixRQUFVUixtQkFBbUIsQ0FBQ1MsQ0FBcEIsQ0FBd0IsU0FBU1EsTUFBVCxDQUFpQkMsUUFBakIsQ0FBMkIsQ0FBRSxNQUFPN0UsT0FBTSxDQUFDOEUsU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0NoQixJQUFoQyxDQUFxQ2EsTUFBckMsQ0FBNkNDLFFBQTdDLENBQVAsQ0FBZ0UsQ0FBckgsQ0FDVixRQXpEbUMsQ0EwRG5DLFFBMURtQyxDQTBEekI7QUFDVixRQUFVbEIsbUJBQW1CLENBQUNxQixDQUFwQixDQUF3QixFQUF4QixDQUNWLFFBNURtQyxDQTZEbkMsUUE3RG1DLENBNkR6QjtBQUNWLFFBQVUsTUFBT3JCLG9CQUFtQixDQUFDQSxtQkFBbUIsQ0FBQ3NCLENBQXBCLENBQXdCLEVBQXpCLENBQTFCLENBQ1YsUUFBVSxDQS9ETSxDQWdFaEIsMEVBaEVnQixDQWlFaEIsUUFBVSxDQUNWLE9BRFUsQ0FFVixLQUFPLFNBQVMzQixNQUFULENBQWlCRCxPQUFqQixDQUEwQixDQUVqQzs7Ozs7O0dBT0FDLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQixDQUNmO0FBQ0FySyxPQUFPLENBQUUsQ0FDUGtNLGlCQUFpQixDQUFFLEtBRFosQ0FGTSxDQUFqQixDQVFBLEtBQU8sQ0FuQkcsQ0FvQlYsT0FwQlUsQ0FxQlYsS0FBTyxTQUFTNUIsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7O0dBT0EsR0FBSWxDLE1BQUssQ0FBR2tDLG1CQUFtQixDQUFDLENBQUQsQ0FBL0IsQ0FDQSxHQUFJd0IsTUFBSyxDQUFHeEIsbUJBQW1CLENBQUMsRUFBRCxDQUEvQixDQUVBLG1CQUNBLEdBQUl5QixLQUFJLENBQUc5QixNQUFNLENBQUNELE9BQVAsQ0FBaUI1QixLQUFLLENBQUMyRCxJQUFOLENBQWEzRCxLQUFLLENBQUMyRCxJQUFOLEVBQWMsRUFBdkQsQ0FFQTtBQUNBLENBQUMsVUFBVyxDQUNWO0FBQ0E7QUFDQTtBQUNBLEdBQUcsTUFBT0MsUUFBUCxHQUFtQixXQUFuQixFQUFrQ0EsT0FBTyxDQUFDQyxRQUExQyxFQUFzRCxDQUFDRCxPQUFPLENBQUNFLE9BQWxFLENBQTJFLENBQ3pFSCxJQUFJLENBQUNFLFFBQUwsQ0FBZ0JELE9BQU8sQ0FBQ0MsUUFBeEIsQ0FDQSxHQUFHLE1BQU9FLGFBQVAsR0FBd0IsVUFBM0IsQ0FBdUMsQ0FDckNKLElBQUksQ0FBQ0ksWUFBTCxDQUFvQkEsWUFBcEIsQ0FDRCxDQUZELElBRU8sQ0FDTDtBQUNBO0FBQ0FKLElBQUksQ0FBQ0ksWUFBTCxDQUFvQkosSUFBSSxDQUFDRSxRQUF6QixDQUNELENBQ0QsT0FDRCxDQUVEO0FBQ0EsR0FBRyxNQUFPRSxhQUFQLEdBQXdCLFVBQTNCLENBQXVDLENBQ3JDSixJQUFJLENBQUNJLFlBQUwsQ0FBb0IsVUFBVyxDQUFFLE1BQU9BLGFBQVksQ0FBQ0MsS0FBYixDQUFtQkMsU0FBbkIsQ0FBOEJDLFNBQTlCLENBQVAsQ0FBa0QsQ0FBbkYsQ0FDQVAsSUFBSSxDQUFDRSxRQUFMLENBQWdCLFNBQVNNLFFBQVQsQ0FBbUIsQ0FDakMsTUFBT0osYUFBWSxDQUFDSSxRQUFELENBQW5CLENBQ0QsQ0FGRCxDQUdBLE9BQ0QsQ0FFRDs7OytCQXpCVSxDQThCVjtBQUNBUixJQUFJLENBQUNJLFlBQUwsQ0FBb0IsU0FBU0ksUUFBVCxDQUFtQixDQUNyQ0MsVUFBVSxDQUFDRCxRQUFELENBQVcsQ0FBWCxDQUFWLENBQ0QsQ0FGRCxDQUlBO0FBQ0EsR0FBRyxNQUFPN0UsT0FBUCxHQUFrQixXQUFsQixFQUNELE1BQU9BLE9BQU0sQ0FBQ08sV0FBZCxHQUE4QixVQURoQyxDQUM0QyxJQVdqQ3dFLFFBWGlDLENBVzFDLFFBQVNBLFFBQVQsQ0FBaUJDLEtBQWpCLENBQXdCLENBQ3RCLEdBQUdBLEtBQUssQ0FBQ0MsTUFBTixHQUFpQmpGLE1BQWpCLEVBQTJCZ0YsS0FBSyxDQUFDeEssSUFBTixHQUFlMEssR0FBN0MsQ0FBa0QsQ0FDaERGLEtBQUssQ0FBQ0csZUFBTixHQUNBLEdBQUlDLEtBQUksQ0FBR0MsU0FBUyxDQUFDQyxLQUFWLEVBQVgsQ0FDQUQsU0FBUyxDQUFDek0sTUFBVixDQUFtQixDQUFuQixDQUNBd00sSUFBSSxDQUFDRyxPQUFMLENBQWEsU0FBU1YsUUFBVCxDQUFtQixDQUM5QkEsUUFBUSxHQUNULENBRkQsRUFHRCxDQUNGLENBcEJ5QyxDQUMxQyxHQUFJSyxJQUFHLENBQUcsb0JBQVYsQ0FDQSxHQUFJRyxVQUFTLENBQUcsRUFBaEIsQ0FDQWhCLElBQUksQ0FBQ0ksWUFBTCxDQUFvQixTQUFTSSxRQUFULENBQW1CLENBQ3JDUSxTQUFTLENBQUNHLElBQVYsQ0FBZVgsUUFBZixFQUNBO0FBQ0E7QUFDQSxHQUFHUSxTQUFTLENBQUN6TSxNQUFWLEdBQXFCLENBQXhCLENBQTJCLENBQ3pCb0gsTUFBTSxDQUFDTyxXQUFQLENBQW1CMkUsR0FBbkIsQ0FBd0IsR0FBeEIsRUFDRCxDQUNGLENBUEQsQ0FrQkFsRixNQUFNLENBQUN5RixnQkFBUCxDQUF3QixTQUF4QixDQUFtQ1YsT0FBbkMsQ0FBNEMsSUFBNUMsRUFDRCxDQUVEO0FBQ0EsR0FBRyxNQUFPVyxpQkFBUCxHQUE0QixXQUEvQixDQUE0QyxDQUMxQztBQUNBLEdBQUlDLElBQUcsQ0FBR0MsSUFBSSxDQUFDRCxHQUFMLEVBQVYsQ0FDQSxHQUFJRSxLQUFJLENBQUcsSUFBWCxDQUNBLEdBQUlDLElBQUcsQ0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQVYsQ0FDQSxHQUFJWCxVQUFTLENBQUcsRUFBaEIsQ0FDQSxHQUFJSyxpQkFBSixDQUFxQixVQUFXLENBQzlCLEdBQUlOLEtBQUksQ0FBR0MsU0FBUyxDQUFDQyxLQUFWLEVBQVgsQ0FDQUQsU0FBUyxDQUFDek0sTUFBVixDQUFtQixDQUFuQixDQUNBd00sSUFBSSxDQUFDRyxPQUFMLENBQWEsU0FBU1YsUUFBVCxDQUFtQixDQUM5QkEsUUFBUSxHQUNULENBRkQsRUFHRCxDQU5ELEVBTUdvQixPQU5ILENBTVdILEdBTlgsQ0FNZ0IsQ0FBQ0ksVUFBVSxDQUFFLElBQWIsQ0FOaEIsRUFPQSxHQUFJQyxnQkFBZSxDQUFHOUIsSUFBSSxDQUFDSSxZQUEzQixDQUNBSixJQUFJLENBQUNJLFlBQUwsQ0FBb0IsU0FBU0ksUUFBVCxDQUFtQixDQUNyQyxHQUFHZSxJQUFJLENBQUNELEdBQUwsR0FBYUEsR0FBYixDQUFtQixFQUF0QixDQUEwQixDQUN4QkEsR0FBRyxDQUFHQyxJQUFJLENBQUNELEdBQUwsRUFBTixDQUNBUSxlQUFlLENBQUN0QixRQUFELENBQWYsQ0FDRCxDQUhELElBR08sQ0FDTFEsU0FBUyxDQUFDRyxJQUFWLENBQWVYLFFBQWYsRUFDQTtBQUNBO0FBQ0EsR0FBR1EsU0FBUyxDQUFDek0sTUFBVixHQUFxQixDQUF4QixDQUEyQixDQUN6QmtOLEdBQUcsQ0FBQ00sWUFBSixDQUFpQixHQUFqQixDQUFzQlAsSUFBSSxDQUFHLENBQUNBLElBQTlCLEVBQ0QsQ0FDRixDQUNGLENBWkQsQ0FhRCxDQUVEeEIsSUFBSSxDQUFDRSxRQUFMLENBQWdCRixJQUFJLENBQUNJLFlBQXJCLENBQ0QsQ0E1RkQsSUE4RkE7QUFDQUosSUFBSSxDQUFDZ0MsUUFBTCxDQUNFLE1BQU8vQixRQUFQLEdBQW1CLFdBQW5CLEVBQWtDQSxPQUFPLENBQUNnQyxRQUExQyxFQUFzRGhDLE9BQU8sQ0FBQ2dDLFFBQVIsQ0FBaUJDLElBRHpFLENBR0E7QUFDQWxDLElBQUksQ0FBQ21DLE9BQUwsQ0FBZTFOLEtBQUssQ0FBQzBOLE9BQU4sRUFBaUIsU0FBU0MsQ0FBVCxDQUFZLENBQzFDLE1BQU94SCxPQUFNLENBQUM4RSxTQUFQLENBQWlCckUsUUFBakIsQ0FBMEJzRCxJQUExQixDQUErQnlELENBQS9CLElBQXNDLGdCQUE3QyxDQUNELENBRkQsQ0FJQTtBQUNBcEMsSUFBSSxDQUFDcUMsYUFBTCxDQUFxQixTQUFTRCxDQUFULENBQVksQ0FDL0IsTUFBTyxPQUFPRSxZQUFQLEdBQXVCLFdBQXZCLEVBQXNDRixDQUFDLFdBQVlFLFlBQTFELENBQ0QsQ0FGRCxDQUlBO0FBQ0F0QyxJQUFJLENBQUN1QyxpQkFBTCxDQUF5QixTQUFTSCxDQUFULENBQVksQ0FDbkMsTUFBT0EsRUFBQyxFQUFJcEMsSUFBSSxDQUFDcUMsYUFBTCxDQUFtQkQsQ0FBQyxDQUFDSSxNQUFyQixDQUFMLEVBQXFDSixDQUFDLENBQUNLLFVBQUYsR0FBaUJuQyxTQUE3RCxDQUNELENBRkQsQ0FJQTs7Ozs7Ozs7R0FTQSxRQUFTb0MsZ0JBQVQsQ0FBeUJ0RCxDQUF6QixDQUE0QixDQUMxQixHQUFHLEVBQUVBLENBQUMsR0FBSyxDQUFOLEVBQVdBLENBQUMsR0FBSyxFQUFqQixFQUF1QkEsQ0FBQyxHQUFLLEVBQTdCLEVBQW1DQSxDQUFDLEdBQUssRUFBM0MsQ0FBSCxDQUFtRCxDQUNqRCxLQUFNLElBQUkvSyxNQUFKLENBQVUseUNBQTJDK0ssQ0FBckQsQ0FBTixDQUNELENBQ0YsQ0FFRDtBQUNBWSxJQUFJLENBQUMyQyxVQUFMLENBQWtCQyxnQkFBbEIsQ0FFQSxvQ0FuSnNELENBcUp0RDs7Ozs7R0FNQSxRQUFTQSxpQkFBVCxDQUEwQkMsQ0FBMUIsQ0FBNkIsQ0FDM0I7QUFFQTtBQUNBLEtBQUsxTSxJQUFMLENBQVksRUFBWixDQUNBO0FBQ0EsS0FBSzJNLElBQUwsQ0FBWSxDQUFaLENBRUEsR0FBRyxNQUFPRCxFQUFQLEdBQWEsUUFBaEIsQ0FBMEIsQ0FDeEIsS0FBSzFNLElBQUwsQ0FBWTBNLENBQVosQ0FDRCxDQUZELElBRU8sSUFBRzdDLElBQUksQ0FBQ3FDLGFBQUwsQ0FBbUJRLENBQW5CLEdBQXlCN0MsSUFBSSxDQUFDdUMsaUJBQUwsQ0FBdUJNLENBQXZCLENBQTVCLENBQXVELENBQzVELEdBQUcsTUFBT0UsT0FBUCxHQUFrQixXQUFsQixFQUFpQ0YsQ0FBQyxXQUFZRSxPQUFqRCxDQUF5RCxDQUN2RCxLQUFLNU0sSUFBTCxDQUFZME0sQ0FBQyxDQUFDeEgsUUFBRixDQUFXLFFBQVgsQ0FBWixDQUNELENBRkQsSUFFTyxDQUNMO0FBQ0E7QUFDQSxHQUFJMkgsSUFBRyxDQUFHLEdBQUlDLFdBQUosQ0FBZUosQ0FBZixDQUFWLENBQ0EsR0FBSSxDQUNGLEtBQUsxTSxJQUFMLENBQVkrTSxNQUFNLENBQUNDLFlBQVAsQ0FBb0I5QyxLQUFwQixDQUEwQixJQUExQixDQUFnQzJDLEdBQWhDLENBQVosQ0FDRCxDQUFDLE1BQU1JLENBQU4sQ0FBUyxDQUNULElBQUksR0FBSTNFLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3VFLEdBQUcsQ0FBQ3pPLE1BQXZCLENBQStCLEVBQUVrSyxDQUFqQyxDQUFvQyxDQUNsQyxLQUFLNEUsT0FBTCxDQUFhTCxHQUFHLENBQUN2RSxDQUFELENBQWhCLEVBQ0QsQ0FDRixDQUNGLENBQ0YsQ0FmTSxJQWVBLElBQUdvRSxDQUFDLFdBQVlELGlCQUFiLEVBQ1AsUUFBT0MsQ0FBUCxJQUFhLFFBQWIsRUFBeUIsTUFBT0EsRUFBQyxDQUFDMU0sSUFBVCxHQUFrQixRQUEzQyxFQUNELE1BQU8wTSxFQUFDLENBQUNDLElBQVQsR0FBa0IsUUFGYixDQUV3QixDQUM3QjtBQUNBLEtBQUszTSxJQUFMLENBQVkwTSxDQUFDLENBQUMxTSxJQUFkLENBQ0EsS0FBSzJNLElBQUwsQ0FBWUQsQ0FBQyxDQUFDQyxJQUFkLENBQ0QsQ0FFRDtBQUNBLEtBQUtRLHdCQUFMLENBQWdDLENBQWhDLENBQ0QsQ0FDRHRELElBQUksQ0FBQzRDLGdCQUFMLENBQXdCQSxnQkFBeEIsQ0FFQTs7Ozs7Ozs7O2VBVUEsR0FBSVcsK0JBQThCLENBQUcsSUFBckMsQ0FDQXZELElBQUksQ0FBQzRDLGdCQUFMLENBQXNCbEQsU0FBdEIsQ0FBZ0M4RCwwQkFBaEMsQ0FBNkQsU0FBU3BCLENBQVQsQ0FBWSxDQUN2RSxLQUFLa0Isd0JBQUwsRUFBaUNsQixDQUFqQyxDQUNBLEdBQUcsS0FBS2tCLHdCQUFMLENBQWdDQyw4QkFBbkMsQ0FBbUUsQ0FDakU7QUFDQSxLQUFLcE4sSUFBTCxDQUFVbUYsTUFBVixDQUFpQixDQUFqQixDQUFvQixDQUFwQixFQUNBLEtBQUtnSSx3QkFBTCxDQUFnQyxDQUFoQyxDQUNELENBQ0YsQ0FQRCxDQVNBOzs7O0dBS0F0RCxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDbkwsTUFBaEMsQ0FBeUMsVUFBVyxDQUNsRCxNQUFPLE1BQUs0QixJQUFMLENBQVU1QixNQUFWLENBQW1CLEtBQUt1TyxJQUEvQixDQUNELENBRkQsQ0FJQTs7OztHQUtBOUMsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQytELE9BQWhDLENBQTBDLFVBQVcsQ0FDbkQsTUFBTyxNQUFLbFAsTUFBTCxJQUFpQixDQUF4QixDQUNELENBRkQsQ0FJQTs7Ozs7O0dBT0F5TCxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDMkQsT0FBaEMsQ0FBMEMsU0FBU1IsQ0FBVCxDQUFZLENBQ3BELE1BQU8sTUFBS2EsUUFBTCxDQUFjUixNQUFNLENBQUNDLFlBQVAsQ0FBb0JOLENBQXBCLENBQWQsQ0FBUCxDQUNELENBRkQsQ0FJQTs7Ozs7OztHQVFBN0MsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ2lFLFlBQWhDLENBQStDLFNBQVNkLENBQVQsQ0FBWXpELENBQVosQ0FBZSxDQUM1RHlELENBQUMsQ0FBR0ssTUFBTSxDQUFDQyxZQUFQLENBQW9CTixDQUFwQixDQUFKLENBQ0EsR0FBSS9ELEVBQUMsQ0FBRyxLQUFLM0ksSUFBYixDQUNBLE1BQU1pSixDQUFDLENBQUcsQ0FBVixDQUFhLENBQ1gsR0FBR0EsQ0FBQyxDQUFHLENBQVAsQ0FBVSxDQUNSTixDQUFDLEVBQUkrRCxDQUFMLENBQ0QsQ0FDRHpELENBQUMsSUFBTSxDQUFQLENBQ0EsR0FBR0EsQ0FBQyxDQUFHLENBQVAsQ0FBVSxDQUNSeUQsQ0FBQyxFQUFJQSxDQUFMLENBQ0QsQ0FDRixDQUNELEtBQUsxTSxJQUFMLENBQVkySSxDQUFaLENBQ0EsS0FBSzBFLDBCQUFMLENBQWdDcEUsQ0FBaEMsRUFDQSxNQUFPLEtBQVAsQ0FDRCxDQWZELENBaUJBOzs7Ozs7R0FPQVksSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ2dFLFFBQWhDLENBQTJDLFNBQVNFLEtBQVQsQ0FBZ0IsQ0FDekQsS0FBS3pOLElBQUwsRUFBYXlOLEtBQWIsQ0FDQSxLQUFLSiwwQkFBTCxDQUFnQ0ksS0FBSyxDQUFDclAsTUFBdEMsRUFDQSxNQUFPLEtBQVAsQ0FDRCxDQUpELENBTUE7Ozs7OztHQU9BeUwsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ21FLFNBQWhDLENBQTRDLFNBQVNDLEdBQVQsQ0FBYyxDQUN4RCxNQUFPLE1BQUtKLFFBQUwsQ0FBYzFELElBQUksQ0FBQytELFVBQUwsQ0FBZ0JELEdBQWhCLENBQWQsQ0FBUCxDQUNELENBRkQsQ0FJQTs7Ozs7O0dBT0E5RCxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDc0UsUUFBaEMsQ0FBMkMsU0FBU3ZGLENBQVQsQ0FBWSxDQUNyRCxNQUFPLE1BQUtpRixRQUFMLENBQ0xSLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjFFLENBQUMsRUFBSSxDQUFMLENBQVMsSUFBN0IsRUFDQXlFLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjFFLENBQUMsQ0FBRyxJQUF4QixDQUZLLENBQVAsQ0FHRCxDQUpELENBTUE7Ozs7OztHQU9BdUIsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ3VFLFFBQWhDLENBQTJDLFNBQVN4RixDQUFULENBQVksQ0FDckQsTUFBTyxNQUFLaUYsUUFBTCxDQUNMUixNQUFNLENBQUNDLFlBQVAsQ0FBb0IxRSxDQUFDLEVBQUksRUFBTCxDQUFVLElBQTlCLEVBQ0F5RSxNQUFNLENBQUNDLFlBQVAsQ0FBb0IxRSxDQUFDLEVBQUksQ0FBTCxDQUFTLElBQTdCLENBREEsQ0FFQXlFLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjFFLENBQUMsQ0FBRyxJQUF4QixDQUhLLENBQVAsQ0FJRCxDQUxELENBT0E7Ozs7OztHQU9BdUIsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ3dFLFFBQWhDLENBQTJDLFNBQVN6RixDQUFULENBQVksQ0FDckQsTUFBTyxNQUFLaUYsUUFBTCxDQUNMUixNQUFNLENBQUNDLFlBQVAsQ0FBb0IxRSxDQUFDLEVBQUksRUFBTCxDQUFVLElBQTlCLEVBQ0F5RSxNQUFNLENBQUNDLFlBQVAsQ0FBb0IxRSxDQUFDLEVBQUksRUFBTCxDQUFVLElBQTlCLENBREEsQ0FFQXlFLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjFFLENBQUMsRUFBSSxDQUFMLENBQVMsSUFBN0IsQ0FGQSxDQUdBeUUsTUFBTSxDQUFDQyxZQUFQLENBQW9CMUUsQ0FBQyxDQUFHLElBQXhCLENBSkssQ0FBUCxDQUtELENBTkQsQ0FRQTs7Ozs7O0dBT0F1QixJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDeUUsVUFBaEMsQ0FBNkMsU0FBUzFGLENBQVQsQ0FBWSxDQUN2RCxNQUFPLE1BQUtpRixRQUFMLENBQ0xSLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjFFLENBQUMsQ0FBRyxJQUF4QixFQUNBeUUsTUFBTSxDQUFDQyxZQUFQLENBQW9CMUUsQ0FBQyxFQUFJLENBQUwsQ0FBUyxJQUE3QixDQUZLLENBQVAsQ0FHRCxDQUpELENBTUE7Ozs7OztHQU9BdUIsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQzBFLFVBQWhDLENBQTZDLFNBQVMzRixDQUFULENBQVksQ0FDdkQsTUFBTyxNQUFLaUYsUUFBTCxDQUNMUixNQUFNLENBQUNDLFlBQVAsQ0FBb0IxRSxDQUFDLENBQUcsSUFBeEIsRUFDQXlFLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjFFLENBQUMsRUFBSSxDQUFMLENBQVMsSUFBN0IsQ0FEQSxDQUVBeUUsTUFBTSxDQUFDQyxZQUFQLENBQW9CMUUsQ0FBQyxFQUFJLEVBQUwsQ0FBVSxJQUE5QixDQUhLLENBQVAsQ0FJRCxDQUxELENBT0E7Ozs7OztHQU9BdUIsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQzJFLFVBQWhDLENBQTZDLFNBQVM1RixDQUFULENBQVksQ0FDdkQsTUFBTyxNQUFLaUYsUUFBTCxDQUNMUixNQUFNLENBQUNDLFlBQVAsQ0FBb0IxRSxDQUFDLENBQUcsSUFBeEIsRUFDQXlFLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjFFLENBQUMsRUFBSSxDQUFMLENBQVMsSUFBN0IsQ0FEQSxDQUVBeUUsTUFBTSxDQUFDQyxZQUFQLENBQW9CMUUsQ0FBQyxFQUFJLEVBQUwsQ0FBVSxJQUE5QixDQUZBLENBR0F5RSxNQUFNLENBQUNDLFlBQVAsQ0FBb0IxRSxDQUFDLEVBQUksRUFBTCxDQUFVLElBQTlCLENBSkssQ0FBUCxDQUtELENBTkQsQ0FRQTs7Ozs7OztHQVFBdUIsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQzRFLE1BQWhDLENBQXlDLFNBQVM3RixDQUFULENBQVlXLENBQVosQ0FBZSxDQUN0RHNELGVBQWUsQ0FBQ3RELENBQUQsQ0FBZixDQUNBLEdBQUl3RSxNQUFLLENBQUcsRUFBWixDQUNBLEVBQUcsQ0FDRHhFLENBQUMsRUFBSSxDQUFMLENBQ0F3RSxLQUFLLEVBQUlWLE1BQU0sQ0FBQ0MsWUFBUCxDQUFxQjFFLENBQUMsRUFBSVcsQ0FBTixDQUFXLElBQS9CLENBQVQsQ0FDRCxDQUhELE1BR1FBLENBQUMsQ0FBRyxDQUhaLEVBSUEsTUFBTyxNQUFLc0UsUUFBTCxDQUFjRSxLQUFkLENBQVAsQ0FDRCxDQVJELENBVUE7Ozs7Ozs7O0dBU0E1RCxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDNkUsWUFBaEMsQ0FBK0MsU0FBUzlGLENBQVQsQ0FBWVcsQ0FBWixDQUFlLENBQzVEO0FBQ0EsR0FBR1gsQ0FBQyxDQUFHLENBQVAsQ0FBVSxDQUNSQSxDQUFDLEVBQUksR0FBTVcsQ0FBQyxDQUFHLENBQWYsQ0FDRCxDQUNELE1BQU8sTUFBS2tGLE1BQUwsQ0FBWTdGLENBQVosQ0FBZVcsQ0FBZixDQUFQLENBQ0QsQ0FORCxDQVFBOzs7Ozs7R0FPQVksSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQzhFLFNBQWhDLENBQTRDLFNBQVNoQyxNQUFULENBQWlCLENBQzNELE1BQU8sTUFBS2tCLFFBQUwsQ0FBY2xCLE1BQU0sQ0FBQ2lDLFFBQVAsRUFBZCxDQUFQLENBQ0QsQ0FGRCxDQUlBOzs7O0dBS0F6RSxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDZ0YsT0FBaEMsQ0FBMEMsVUFBVyxDQUNuRCxNQUFPLE1BQUt2TyxJQUFMLENBQVV3TyxVQUFWLENBQXFCLEtBQUs3QixJQUFMLEVBQXJCLENBQVAsQ0FDRCxDQUZELENBSUE7Ozs7O0dBTUE5QyxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDa0YsUUFBaEMsQ0FBMkMsVUFBVyxDQUNwRCxHQUFJQyxLQUFJLENBQ04sS0FBSzFPLElBQUwsQ0FBVXdPLFVBQVYsQ0FBcUIsS0FBSzdCLElBQTFCLEdBQW1DLENBQW5DLENBQ0EsS0FBSzNNLElBQUwsQ0FBVXdPLFVBQVYsQ0FBcUIsS0FBSzdCLElBQUwsQ0FBWSxDQUFqQyxDQUZGLENBR0EsS0FBS0EsSUFBTCxFQUFhLENBQWIsQ0FDQSxNQUFPK0IsS0FBUCxDQUNELENBTkQsQ0FRQTs7Ozs7R0FNQTdFLElBQUksQ0FBQzRDLGdCQUFMLENBQXNCbEQsU0FBdEIsQ0FBZ0NvRixRQUFoQyxDQUEyQyxVQUFXLENBQ3BELEdBQUlELEtBQUksQ0FDTixLQUFLMU8sSUFBTCxDQUFVd08sVUFBVixDQUFxQixLQUFLN0IsSUFBMUIsR0FBbUMsRUFBbkMsQ0FDQSxLQUFLM00sSUFBTCxDQUFVd08sVUFBVixDQUFxQixLQUFLN0IsSUFBTCxDQUFZLENBQWpDLEdBQXVDLENBRHZDLENBRUEsS0FBSzNNLElBQUwsQ0FBVXdPLFVBQVYsQ0FBcUIsS0FBSzdCLElBQUwsQ0FBWSxDQUFqQyxDQUhGLENBSUEsS0FBS0EsSUFBTCxFQUFhLENBQWIsQ0FDQSxNQUFPK0IsS0FBUCxDQUNELENBUEQsQ0FTQTs7Ozs7R0FNQTdFLElBQUksQ0FBQzRDLGdCQUFMLENBQXNCbEQsU0FBdEIsQ0FBZ0NxRixRQUFoQyxDQUEyQyxVQUFXLENBQ3BELEdBQUlGLEtBQUksQ0FDTixLQUFLMU8sSUFBTCxDQUFVd08sVUFBVixDQUFxQixLQUFLN0IsSUFBMUIsR0FBbUMsRUFBbkMsQ0FDQSxLQUFLM00sSUFBTCxDQUFVd08sVUFBVixDQUFxQixLQUFLN0IsSUFBTCxDQUFZLENBQWpDLEdBQXVDLEVBRHZDLENBRUEsS0FBSzNNLElBQUwsQ0FBVXdPLFVBQVYsQ0FBcUIsS0FBSzdCLElBQUwsQ0FBWSxDQUFqQyxHQUF1QyxDQUZ2QyxDQUdBLEtBQUszTSxJQUFMLENBQVV3TyxVQUFWLENBQXFCLEtBQUs3QixJQUFMLENBQVksQ0FBakMsQ0FKRixDQUtBLEtBQUtBLElBQUwsRUFBYSxDQUFiLENBQ0EsTUFBTytCLEtBQVAsQ0FDRCxDQVJELENBVUE7Ozs7O0dBTUE3RSxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDc0YsVUFBaEMsQ0FBNkMsVUFBVyxDQUN0RCxHQUFJSCxLQUFJLENBQ04sS0FBSzFPLElBQUwsQ0FBVXdPLFVBQVYsQ0FBcUIsS0FBSzdCLElBQTFCLEVBQ0EsS0FBSzNNLElBQUwsQ0FBVXdPLFVBQVYsQ0FBcUIsS0FBSzdCLElBQUwsQ0FBWSxDQUFqQyxHQUF1QyxDQUZ6QyxDQUdBLEtBQUtBLElBQUwsRUFBYSxDQUFiLENBQ0EsTUFBTytCLEtBQVAsQ0FDRCxDQU5ELENBUUE7Ozs7O0dBTUE3RSxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDdUYsVUFBaEMsQ0FBNkMsVUFBVyxDQUN0RCxHQUFJSixLQUFJLENBQ04sS0FBSzFPLElBQUwsQ0FBVXdPLFVBQVYsQ0FBcUIsS0FBSzdCLElBQTFCLEVBQ0EsS0FBSzNNLElBQUwsQ0FBVXdPLFVBQVYsQ0FBcUIsS0FBSzdCLElBQUwsQ0FBWSxDQUFqQyxHQUF1QyxDQUR2QyxDQUVBLEtBQUszTSxJQUFMLENBQVV3TyxVQUFWLENBQXFCLEtBQUs3QixJQUFMLENBQVksQ0FBakMsR0FBdUMsRUFIekMsQ0FJQSxLQUFLQSxJQUFMLEVBQWEsQ0FBYixDQUNBLE1BQU8rQixLQUFQLENBQ0QsQ0FQRCxDQVNBOzs7OztHQU1BN0UsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ3dGLFVBQWhDLENBQTZDLFVBQVcsQ0FDdEQsR0FBSUwsS0FBSSxDQUNOLEtBQUsxTyxJQUFMLENBQVV3TyxVQUFWLENBQXFCLEtBQUs3QixJQUExQixFQUNBLEtBQUszTSxJQUFMLENBQVV3TyxVQUFWLENBQXFCLEtBQUs3QixJQUFMLENBQVksQ0FBakMsR0FBdUMsQ0FEdkMsQ0FFQSxLQUFLM00sSUFBTCxDQUFVd08sVUFBVixDQUFxQixLQUFLN0IsSUFBTCxDQUFZLENBQWpDLEdBQXVDLEVBRnZDLENBR0EsS0FBSzNNLElBQUwsQ0FBVXdPLFVBQVYsQ0FBcUIsS0FBSzdCLElBQUwsQ0FBWSxDQUFqQyxHQUF1QyxFQUp6QyxDQUtBLEtBQUtBLElBQUwsRUFBYSxDQUFiLENBQ0EsTUFBTytCLEtBQVAsQ0FDRCxDQVJELENBVUE7Ozs7Ozs7R0FRQTdFLElBQUksQ0FBQzRDLGdCQUFMLENBQXNCbEQsU0FBdEIsQ0FBZ0N5RixNQUFoQyxDQUF5QyxTQUFTL0YsQ0FBVCxDQUFZLENBQ25Ec0QsZUFBZSxDQUFDdEQsQ0FBRCxDQUFmLENBQ0EsR0FBSXlGLEtBQUksQ0FBRyxDQUFYLENBQ0EsRUFBRyxDQUNEO0FBQ0FBLElBQUksQ0FBRyxDQUFDQSxJQUFJLEVBQUksQ0FBVCxFQUFjLEtBQUsxTyxJQUFMLENBQVV3TyxVQUFWLENBQXFCLEtBQUs3QixJQUFMLEVBQXJCLENBQXJCLENBQ0ExRCxDQUFDLEVBQUksQ0FBTCxDQUNELENBSkQsTUFJUUEsQ0FBQyxDQUFHLENBSlosRUFLQSxNQUFPeUYsS0FBUCxDQUNELENBVEQsQ0FXQTs7Ozs7OztHQVFBN0UsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQzBGLFlBQWhDLENBQStDLFNBQVNoRyxDQUFULENBQVksQ0FDekQ7QUFDQSxHQUFJZ0QsRUFBQyxDQUFHLEtBQUsrQyxNQUFMLENBQVkvRixDQUFaLENBQVIsQ0FDQSxHQUFJaUcsSUFBRyxDQUFHLEdBQU1qRyxDQUFDLENBQUcsQ0FBcEIsQ0FDQSxHQUFHZ0QsQ0FBQyxFQUFJaUQsR0FBUixDQUFhLENBQ1hqRCxDQUFDLEVBQUlpRCxHQUFHLEVBQUksQ0FBWixDQUNELENBQ0QsTUFBT2pELEVBQVAsQ0FDRCxDQVJELENBVUE7Ozs7OztHQU9BcEMsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQytFLFFBQWhDLENBQTJDLFNBQVNhLEtBQVQsQ0FBZ0IsQ0FDekQsR0FBSVQsS0FBSixDQUNBLEdBQUdTLEtBQUgsQ0FBVSxDQUNSO0FBQ0FBLEtBQUssQ0FBR25LLElBQUksQ0FBQ29LLEdBQUwsQ0FBUyxLQUFLaFIsTUFBTCxFQUFULENBQXdCK1EsS0FBeEIsQ0FBUixDQUNBVCxJQUFJLENBQUcsS0FBSzFPLElBQUwsQ0FBVThLLEtBQVYsQ0FBZ0IsS0FBSzZCLElBQXJCLENBQTJCLEtBQUtBLElBQUwsQ0FBWXdDLEtBQXZDLENBQVAsQ0FDQSxLQUFLeEMsSUFBTCxFQUFhd0MsS0FBYixDQUNELENBTEQsSUFLTyxJQUFHQSxLQUFLLEdBQUssQ0FBYixDQUFnQixDQUNyQlQsSUFBSSxDQUFHLEVBQVAsQ0FDRCxDQUZNLElBRUEsQ0FDTDtBQUNBQSxJQUFJLENBQUksS0FBSy9CLElBQUwsR0FBYyxDQUFmLENBQW9CLEtBQUszTSxJQUF6QixDQUFnQyxLQUFLQSxJQUFMLENBQVU4SyxLQUFWLENBQWdCLEtBQUs2QixJQUFyQixDQUF2QyxDQUNBLEtBQUswQyxLQUFMLEdBQ0QsQ0FDRCxNQUFPWCxLQUFQLENBQ0QsQ0FmRCxDQWlCQTs7Ozs7OztHQVFBN0UsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ2tFLEtBQWhDLENBQXdDLFNBQVMwQixLQUFULENBQWdCLENBQ3RELE1BQVEsT0FBT0EsTUFBUCxHQUFrQixXQUFsQixDQUNOLEtBQUtuUCxJQUFMLENBQVU4SyxLQUFWLENBQWdCLEtBQUs2QixJQUFyQixDQURNLENBRU4sS0FBSzNNLElBQUwsQ0FBVThLLEtBQVYsQ0FBZ0IsS0FBSzZCLElBQXJCLENBQTJCLEtBQUtBLElBQUwsQ0FBWXdDLEtBQXZDLENBRkYsQ0FHRCxDQUpELENBTUE7Ozs7OztHQU9BdEYsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQytGLEVBQWhDLENBQXFDLFNBQVNoSCxDQUFULENBQVksQ0FDL0MsTUFBTyxNQUFLdEksSUFBTCxDQUFVd08sVUFBVixDQUFxQixLQUFLN0IsSUFBTCxDQUFZckUsQ0FBakMsQ0FBUCxDQUNELENBRkQsQ0FJQTs7Ozs7OztHQVFBdUIsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ2dHLEtBQWhDLENBQXdDLFNBQVNqSCxDQUFULENBQVlvRSxDQUFaLENBQWUsQ0FDckQsS0FBSzFNLElBQUwsQ0FBWSxLQUFLQSxJQUFMLENBQVVtRixNQUFWLENBQWlCLENBQWpCLENBQW9CLEtBQUt3SCxJQUFMLENBQVlyRSxDQUFoQyxFQUNWeUUsTUFBTSxDQUFDQyxZQUFQLENBQW9CTixDQUFwQixDQURVLENBRVYsS0FBSzFNLElBQUwsQ0FBVW1GLE1BQVYsQ0FBaUIsS0FBS3dILElBQUwsQ0FBWXJFLENBQVosQ0FBZ0IsQ0FBakMsQ0FGRixDQUdBLE1BQU8sS0FBUCxDQUNELENBTEQsQ0FPQTs7OztHQUtBdUIsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ2lHLElBQWhDLENBQXVDLFVBQVcsQ0FDaEQsTUFBTyxNQUFLeFAsSUFBTCxDQUFVd08sVUFBVixDQUFxQixLQUFLeE8sSUFBTCxDQUFVNUIsTUFBVixDQUFtQixDQUF4QyxDQUFQLENBQ0QsQ0FGRCxDQUlBOzs7O0dBS0F5TCxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDcUIsSUFBaEMsQ0FBdUMsVUFBVyxDQUNoRCxHQUFJbEMsRUFBQyxDQUFHbUIsSUFBSSxDQUFDNEYsWUFBTCxDQUFrQixLQUFLelAsSUFBdkIsQ0FBUixDQUNBMEksQ0FBQyxDQUFDaUUsSUFBRixDQUFTLEtBQUtBLElBQWQsQ0FDQSxNQUFPakUsRUFBUCxDQUNELENBSkQsQ0FNQTs7OztHQUtBbUIsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQ21HLE9BQWhDLENBQTBDLFVBQVcsQ0FDbkQsR0FBRyxLQUFLL0MsSUFBTCxDQUFZLENBQWYsQ0FBa0IsQ0FDaEIsS0FBSzNNLElBQUwsQ0FBWSxLQUFLQSxJQUFMLENBQVU4SyxLQUFWLENBQWdCLEtBQUs2QixJQUFyQixDQUFaLENBQ0EsS0FBS0EsSUFBTCxDQUFZLENBQVosQ0FDRCxDQUNELE1BQU8sS0FBUCxDQUNELENBTkQsQ0FRQTs7OztHQUtBOUMsSUFBSSxDQUFDNEMsZ0JBQUwsQ0FBc0JsRCxTQUF0QixDQUFnQzhGLEtBQWhDLENBQXdDLFVBQVcsQ0FDakQsS0FBS3JQLElBQUwsQ0FBWSxFQUFaLENBQ0EsS0FBSzJNLElBQUwsQ0FBWSxDQUFaLENBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FKRCxDQU1BOzs7Ozs7R0FPQTlDLElBQUksQ0FBQzRDLGdCQUFMLENBQXNCbEQsU0FBdEIsQ0FBZ0NvRyxRQUFoQyxDQUEyQyxTQUFTUixLQUFULENBQWdCLENBQ3pELEdBQUlTLElBQUcsQ0FBRzVLLElBQUksQ0FBQ2tLLEdBQUwsQ0FBUyxDQUFULENBQVksS0FBSzlRLE1BQUwsR0FBZ0IrUSxLQUE1QixDQUFWLENBQ0EsS0FBS25QLElBQUwsQ0FBWSxLQUFLQSxJQUFMLENBQVVtRixNQUFWLENBQWlCLEtBQUt3SCxJQUF0QixDQUE0QmlELEdBQTVCLENBQVosQ0FDQSxLQUFLakQsSUFBTCxDQUFZLENBQVosQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUxELENBT0E7Ozs7R0FLQTlDLElBQUksQ0FBQzRDLGdCQUFMLENBQXNCbEQsU0FBdEIsQ0FBZ0NzRyxLQUFoQyxDQUF3QyxVQUFXLENBQ2pELEdBQUluQixLQUFJLENBQUcsRUFBWCxDQUNBLElBQUksR0FBSXBHLEVBQUMsQ0FBRyxLQUFLcUUsSUFBakIsQ0FBdUJyRSxDQUFDLENBQUcsS0FBS3RJLElBQUwsQ0FBVTVCLE1BQXJDLENBQTZDLEVBQUVrSyxDQUEvQyxDQUFrRCxDQUNoRCxHQUFJb0UsRUFBQyxDQUFHLEtBQUsxTSxJQUFMLENBQVV3TyxVQUFWLENBQXFCbEcsQ0FBckIsQ0FBUixDQUNBLEdBQUdvRSxDQUFDLENBQUcsRUFBUCxDQUFXLENBQ1RnQyxJQUFJLEVBQUksR0FBUixDQUNELENBQ0RBLElBQUksRUFBSWhDLENBQUMsQ0FBQ3hILFFBQUYsQ0FBVyxFQUFYLENBQVIsQ0FDRCxDQUNELE1BQU93SixLQUFQLENBQ0QsQ0FWRCxDQVlBOzs7O0dBS0E3RSxJQUFJLENBQUM0QyxnQkFBTCxDQUFzQmxELFNBQXRCLENBQWdDckUsUUFBaEMsQ0FBMkMsVUFBVyxDQUNwRCxNQUFPMkUsS0FBSSxDQUFDaUcsVUFBTCxDQUFnQixLQUFLckMsS0FBTCxFQUFoQixDQUFQLENBQ0QsQ0FGRCxDQUlBLHdDQWpzQnNELENBbXNCdEQsa0NBbnNCc0QsQ0Fxc0J0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNEJBLFFBQVNzQyxXQUFULENBQW9CckQsQ0FBcEIsQ0FBdUJqUCxPQUF2QixDQUFnQyxDQUM5QjtBQUNBQSxPQUFPLENBQUdBLE9BQU8sRUFBSSxFQUFyQixDQUVBO0FBQ0EsS0FBS2tQLElBQUwsQ0FBWWxQLE9BQU8sQ0FBQ3VTLFVBQVIsRUFBc0IsQ0FBbEMsQ0FDQSxLQUFLQyxRQUFMLENBQWdCeFMsT0FBTyxDQUFDd1MsUUFBUixFQUFvQixJQUFwQyxDQUVBLEdBQUkvRCxjQUFhLENBQUdyQyxJQUFJLENBQUNxQyxhQUFMLENBQW1CUSxDQUFuQixDQUFwQixDQUNBLEdBQUlOLGtCQUFpQixDQUFHdkMsSUFBSSxDQUFDdUMsaUJBQUwsQ0FBdUJNLENBQXZCLENBQXhCLENBQ0EsR0FBR1IsYUFBYSxFQUFJRSxpQkFBcEIsQ0FBdUMsQ0FDckM7QUFDQSxHQUFHRixhQUFILENBQWtCLENBQ2hCLEtBQUtsTSxJQUFMLENBQVksR0FBSWtRLFNBQUosQ0FBYXhELENBQWIsQ0FBWixDQUNELENBRkQsSUFFTyxDQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUsxTSxJQUFMLENBQVksR0FBSWtRLFNBQUosQ0FBYXhELENBQUMsQ0FBQ0wsTUFBZixDQUF1QkssQ0FBQyxDQUFDeUQsVUFBekIsQ0FBcUN6RCxDQUFDLENBQUNKLFVBQXZDLENBQVosQ0FDRCxDQUNELEtBQUs4RCxLQUFMLENBQWMsZUFBaUIzUyxRQUFqQixDQUNaQSxPQUFPLENBQUM0UyxXQURJLENBQ1UsS0FBS3JRLElBQUwsQ0FBVXNNLFVBRGxDLENBRUEsT0FDRCxDQUVEO0FBQ0EsS0FBS3RNLElBQUwsQ0FBWSxHQUFJa1EsU0FBSixDQUFhLEdBQUkvRCxZQUFKLENBQWdCLENBQWhCLENBQWIsQ0FBWixDQUNBLEtBQUtpRSxLQUFMLENBQWEsQ0FBYixDQUVBLEdBQUcxRCxDQUFDLEdBQUssSUFBTixFQUFjQSxDQUFDLEdBQUt2QyxTQUF2QixDQUFrQyxDQUNoQyxLQUFLb0QsUUFBTCxDQUFjYixDQUFkLEVBQ0QsQ0FFRCxHQUFHLGVBQWlCalAsUUFBcEIsQ0FBNkIsQ0FDM0IsS0FBSzJTLEtBQUwsQ0FBYTNTLE9BQU8sQ0FBQzRTLFdBQXJCLENBQ0QsQ0FDRixDQUNEeEcsSUFBSSxDQUFDa0csVUFBTCxDQUFrQkEsVUFBbEIsQ0FFQTs7OztHQUtBbEcsSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCbkwsTUFBMUIsQ0FBbUMsVUFBVyxDQUM1QyxNQUFPLE1BQUtnUyxLQUFMLENBQWEsS0FBS3pELElBQXpCLENBQ0QsQ0FGRCxDQUlBOzs7O0dBS0E5QyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEIrRCxPQUExQixDQUFvQyxVQUFXLENBQzdDLE1BQU8sTUFBS2xQLE1BQUwsSUFBaUIsQ0FBeEIsQ0FDRCxDQUZELENBSUE7Ozs7Ozs7Ozs7R0FXQXlMLElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQitHLFdBQTFCLENBQXdDLFNBQVNDLE1BQVQsQ0FBaUJOLFFBQWpCLENBQTJCLENBQ2pFLEdBQUcsS0FBSzdSLE1BQUwsSUFBaUJtUyxNQUFwQixDQUE0QixDQUMxQixNQUFPLEtBQVAsQ0FDRCxDQUNETixRQUFRLENBQUdqTCxJQUFJLENBQUNrSyxHQUFMLENBQVNlLFFBQVEsRUFBSSxLQUFLQSxRQUExQixDQUFvQ00sTUFBcEMsQ0FBWCxDQUVBO0FBQ0EsR0FBSUMsSUFBRyxDQUFHLEdBQUkxRCxXQUFKLENBQ1IsS0FBSzlNLElBQUwsQ0FBVXFNLE1BREYsQ0FDVSxLQUFLck0sSUFBTCxDQUFVbVEsVUFEcEIsQ0FDZ0MsS0FBS25RLElBQUwsQ0FBVXNNLFVBRDFDLENBQVYsQ0FFQSxHQUFJbUUsSUFBRyxDQUFHLEdBQUkzRCxXQUFKLENBQWUsS0FBSzFPLE1BQUwsR0FBZ0I2UixRQUEvQixDQUFWLENBQ0FRLEdBQUcsQ0FBQ0MsR0FBSixDQUFRRixHQUFSLEVBQ0EsS0FBS3hRLElBQUwsQ0FBWSxHQUFJa1EsU0FBSixDQUFhTyxHQUFHLENBQUNwRSxNQUFqQixDQUFaLENBRUEsTUFBTyxLQUFQLENBQ0QsQ0FkRCxDQWdCQTs7Ozs7O0dBT0F4QyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEIyRCxPQUExQixDQUFvQyxTQUFTUixDQUFULENBQVksQ0FDOUMsS0FBSzRELFdBQUwsQ0FBaUIsQ0FBakIsRUFDQSxLQUFLdFEsSUFBTCxDQUFVMlEsUUFBVixDQUFtQixLQUFLUCxLQUFMLEVBQW5CLENBQWlDMUQsQ0FBakMsRUFDQSxNQUFPLEtBQVAsQ0FDRCxDQUpELENBTUE7Ozs7Ozs7R0FRQTdDLElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQmlFLFlBQTFCLENBQXlDLFNBQVNkLENBQVQsQ0FBWXpELENBQVosQ0FBZSxDQUN0RCxLQUFLcUgsV0FBTCxDQUFpQnJILENBQWpCLEVBQ0EsSUFBSSxHQUFJWCxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdXLENBQW5CLENBQXNCLEVBQUVYLENBQXhCLENBQTJCLENBQ3pCLEtBQUt0SSxJQUFMLENBQVUyUSxRQUFWLENBQW1CakUsQ0FBbkIsRUFDRCxDQUNELE1BQU8sS0FBUCxDQUNELENBTkQsQ0FRQTs7Ozs7Ozs7O0dBVUE3QyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEJnRSxRQUExQixDQUFxQyxTQUFTRSxLQUFULENBQWdCbUQsUUFBaEIsQ0FBMEIsQ0FDN0QsR0FBRy9HLElBQUksQ0FBQ3VDLGlCQUFMLENBQXVCcUIsS0FBdkIsQ0FBSCxDQUFrQyxDQUNoQyxHQUFJK0MsSUFBRyxDQUFHLEdBQUkxRCxXQUFKLENBQWVXLEtBQUssQ0FBQ3BCLE1BQXJCLENBQTZCb0IsS0FBSyxDQUFDMEMsVUFBbkMsQ0FBK0MxQyxLQUFLLENBQUNuQixVQUFyRCxDQUFWLENBQ0EsR0FBSXNELElBQUcsQ0FBR1ksR0FBRyxDQUFDbEUsVUFBSixDQUFpQmtFLEdBQUcsQ0FBQ0wsVUFBL0IsQ0FDQSxLQUFLRyxXQUFMLENBQWlCVixHQUFqQixFQUNBLEdBQUlhLElBQUcsQ0FBRyxHQUFJM0QsV0FBSixDQUFlLEtBQUs5TSxJQUFMLENBQVVxTSxNQUF6QixDQUFpQyxLQUFLK0QsS0FBdEMsQ0FBVixDQUNBSyxHQUFHLENBQUNDLEdBQUosQ0FBUUYsR0FBUixFQUNBLEtBQUtKLEtBQUwsRUFBY1IsR0FBZCxDQUNBLE1BQU8sS0FBUCxDQUNELENBRUQsR0FBRy9GLElBQUksQ0FBQ3FDLGFBQUwsQ0FBbUJ1QixLQUFuQixDQUFILENBQThCLENBQzVCLEdBQUkrQyxJQUFHLENBQUcsR0FBSTFELFdBQUosQ0FBZVcsS0FBZixDQUFWLENBQ0EsS0FBSzZDLFdBQUwsQ0FBaUJFLEdBQUcsQ0FBQ2xFLFVBQXJCLEVBQ0EsR0FBSW1FLElBQUcsQ0FBRyxHQUFJM0QsV0FBSixDQUFlLEtBQUs5TSxJQUFMLENBQVVxTSxNQUF6QixDQUFWLENBQ0FvRSxHQUFHLENBQUNDLEdBQUosQ0FBUUYsR0FBUixDQUFhLEtBQUtKLEtBQWxCLEVBQ0EsS0FBS0EsS0FBTCxFQUFjSSxHQUFHLENBQUNsRSxVQUFsQixDQUNBLE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDQSxHQUFHbUIsS0FBSyxXQUFZNUQsS0FBSSxDQUFDa0csVUFBdEIsRUFDQSxRQUFPdEMsS0FBUCxJQUFpQixRQUFqQixFQUNELE1BQU9BLE1BQUssQ0FBQ2QsSUFBYixHQUFzQixRQURyQixFQUNpQyxNQUFPYyxNQUFLLENBQUMyQyxLQUFiLEdBQXVCLFFBRHhELEVBRUR2RyxJQUFJLENBQUN1QyxpQkFBTCxDQUF1QnFCLEtBQUssQ0FBQ3pOLElBQTdCLENBSEYsQ0FHdUMsQ0FDckMsR0FBSXdRLElBQUcsQ0FBRyxHQUFJMUQsV0FBSixDQUFlVyxLQUFLLENBQUN6TixJQUFOLENBQVdzTSxVQUExQixDQUFzQ21CLEtBQUssQ0FBQ2QsSUFBNUMsQ0FBa0RjLEtBQUssQ0FBQ3JQLE1BQU4sRUFBbEQsQ0FBVixDQUNBLEtBQUtrUyxXQUFMLENBQWlCRSxHQUFHLENBQUNsRSxVQUFyQixFQUNBLEdBQUltRSxJQUFHLENBQUcsR0FBSTNELFdBQUosQ0FBZVcsS0FBSyxDQUFDek4sSUFBTixDQUFXc00sVUFBMUIsQ0FBc0MsS0FBSzhELEtBQTNDLENBQVYsQ0FDQUssR0FBRyxDQUFDQyxHQUFKLENBQVFGLEdBQVIsRUFDQSxLQUFLSixLQUFMLEVBQWNJLEdBQUcsQ0FBQ2xFLFVBQWxCLENBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FFRCxHQUFHbUIsS0FBSyxXQUFZNUQsS0FBSSxDQUFDNEMsZ0JBQXpCLENBQTJDLENBQ3pDO0FBQ0FnQixLQUFLLENBQUdBLEtBQUssQ0FBQ3pOLElBQWQsQ0FDQTRRLFFBQVEsQ0FBRyxRQUFYLENBQ0QsQ0FFRDtBQUNBQSxRQUFRLENBQUdBLFFBQVEsRUFBSSxRQUF2QixDQUNBLEdBQUcsTUFBT25ELE1BQVAsR0FBaUIsUUFBcEIsQ0FBOEIsQ0FDNUIsR0FBSW9ELEtBQUosQ0FFQTtBQUNBLEdBQUdELFFBQVEsR0FBSyxLQUFoQixDQUF1QixDQUNyQixLQUFLTixXQUFMLENBQWlCdEwsSUFBSSxDQUFDOEwsSUFBTCxDQUFVckQsS0FBSyxDQUFDclAsTUFBTixDQUFlLENBQXpCLENBQWpCLEVBQ0F5UyxJQUFJLENBQUcsR0FBSS9ELFdBQUosQ0FBZSxLQUFLOU0sSUFBTCxDQUFVcU0sTUFBekIsQ0FBaUMsS0FBSytELEtBQXRDLENBQVAsQ0FDQSxLQUFLQSxLQUFMLEVBQWN2RyxJQUFJLENBQUNrSCxNQUFMLENBQVlDLEdBQVosQ0FBZ0JDLE1BQWhCLENBQXVCeEQsS0FBdkIsQ0FBOEJvRCxJQUE5QixDQUFvQyxLQUFLVCxLQUF6QyxDQUFkLENBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FDRCxHQUFHUSxRQUFRLEdBQUssUUFBaEIsQ0FBMEIsQ0FDeEIsS0FBS04sV0FBTCxDQUFpQnRMLElBQUksQ0FBQzhMLElBQUwsQ0FBVXJELEtBQUssQ0FBQ3JQLE1BQU4sQ0FBZSxDQUF6QixFQUE4QixDQUEvQyxFQUNBeVMsSUFBSSxDQUFHLEdBQUkvRCxXQUFKLENBQWUsS0FBSzlNLElBQUwsQ0FBVXFNLE1BQXpCLENBQWlDLEtBQUsrRCxLQUF0QyxDQUFQLENBQ0EsS0FBS0EsS0FBTCxFQUFjdkcsSUFBSSxDQUFDa0gsTUFBTCxDQUFZRyxNQUFaLENBQW1CRCxNQUFuQixDQUEwQnhELEtBQTFCLENBQWlDb0QsSUFBakMsQ0FBdUMsS0FBS1QsS0FBNUMsQ0FBZCxDQUNBLE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDQSxHQUFHUSxRQUFRLEdBQUssTUFBaEIsQ0FBd0IsQ0FDdEI7QUFDQW5ELEtBQUssQ0FBRzVELElBQUksQ0FBQytELFVBQUwsQ0FBZ0JILEtBQWhCLENBQVIsQ0FDQW1ELFFBQVEsQ0FBRyxRQUFYLENBQ0QsQ0FFRDtBQUNBLEdBQUdBLFFBQVEsR0FBSyxRQUFiLEVBQXlCQSxRQUFRLEdBQUssS0FBekMsQ0FBZ0QsQ0FDOUM7QUFDQSxLQUFLTixXQUFMLENBQWlCN0MsS0FBSyxDQUFDclAsTUFBdkIsRUFDQXlTLElBQUksQ0FBRyxHQUFJL0QsV0FBSixDQUFlLEtBQUs5TSxJQUFMLENBQVVxTSxNQUF6QixDQUFpQyxLQUFLK0QsS0FBdEMsQ0FBUCxDQUNBLEtBQUtBLEtBQUwsRUFBY3ZHLElBQUksQ0FBQ2tILE1BQUwsQ0FBWTlOLEdBQVosQ0FBZ0JnTyxNQUFoQixDQUF1QkosSUFBdkIsQ0FBZCxDQUNBLE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDQSxHQUFHRCxRQUFRLEdBQUssT0FBaEIsQ0FBeUIsQ0FDdkI7QUFDQSxLQUFLTixXQUFMLENBQWlCN0MsS0FBSyxDQUFDclAsTUFBTixDQUFlLENBQWhDLEVBQ0F5UyxJQUFJLENBQUcsR0FBSU0sWUFBSixDQUFnQixLQUFLblIsSUFBTCxDQUFVcU0sTUFBMUIsQ0FBa0MsS0FBSytELEtBQXZDLENBQVAsQ0FDQSxLQUFLQSxLQUFMLEVBQWN2RyxJQUFJLENBQUM3RCxJQUFMLENBQVVvTCxLQUFWLENBQWdCQyxNQUFoQixDQUF1QlIsSUFBdkIsQ0FBZCxDQUNBLE1BQU8sS0FBUCxDQUNELENBRUQsS0FBTSxJQUFJM1MsTUFBSixDQUFVLHFCQUF1QjBTLFFBQWpDLENBQU4sQ0FDRCxDQUVELEtBQU0xUyxNQUFLLENBQUMsc0JBQXdCdVAsS0FBekIsQ0FBWCxDQUNELENBdkZELENBeUZBOzs7Ozs7R0FPQTVELElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQjhFLFNBQTFCLENBQXNDLFNBQVNoQyxNQUFULENBQWlCLENBQ3JELEtBQUtrQixRQUFMLENBQWNsQixNQUFkLEVBQ0FBLE1BQU0sQ0FBQ2dELEtBQVAsR0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUpELENBTUE7Ozs7Ozs7R0FRQXhGLElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQm1FLFNBQTFCLENBQXNDLFNBQVNDLEdBQVQsQ0FBYyxDQUNsRCxNQUFPLE1BQUtKLFFBQUwsQ0FBY0ksR0FBZCxDQUFtQixPQUFuQixDQUFQLENBQ0QsQ0FGRCxDQUlBOzs7Ozs7R0FPQTlELElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQnNFLFFBQTFCLENBQXFDLFNBQVN2RixDQUFULENBQVksQ0FDL0MsS0FBS2dJLFdBQUwsQ0FBaUIsQ0FBakIsRUFDQSxLQUFLdFEsSUFBTCxDQUFVc1IsUUFBVixDQUFtQixLQUFLbEIsS0FBeEIsQ0FBK0I5SCxDQUEvQixFQUNBLEtBQUs4SCxLQUFMLEVBQWMsQ0FBZCxDQUNBLE1BQU8sS0FBUCxDQUNELENBTEQsQ0FPQTs7Ozs7O0dBT0F2RyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEJ1RSxRQUExQixDQUFxQyxTQUFTeEYsQ0FBVCxDQUFZLENBQy9DLEtBQUtnSSxXQUFMLENBQWlCLENBQWpCLEVBQ0EsS0FBS3RRLElBQUwsQ0FBVXNSLFFBQVYsQ0FBbUIsS0FBS2xCLEtBQXhCLENBQStCOUgsQ0FBQyxFQUFJLENBQUwsQ0FBUyxNQUF4QyxFQUNBLEtBQUt0SSxJQUFMLENBQVV1UixPQUFWLENBQWtCLEtBQUtuQixLQUF2QixDQUE4QjlILENBQUMsRUFBSSxFQUFMLENBQVUsSUFBeEMsRUFDQSxLQUFLOEgsS0FBTCxFQUFjLENBQWQsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQU5ELENBUUE7Ozs7OztHQU9BdkcsSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCd0UsUUFBMUIsQ0FBcUMsU0FBU3pGLENBQVQsQ0FBWSxDQUMvQyxLQUFLZ0ksV0FBTCxDQUFpQixDQUFqQixFQUNBLEtBQUt0USxJQUFMLENBQVV3UixRQUFWLENBQW1CLEtBQUtwQixLQUF4QixDQUErQjlILENBQS9CLEVBQ0EsS0FBSzhILEtBQUwsRUFBYyxDQUFkLENBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FMRCxDQU9BOzs7Ozs7R0FPQXZHLElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQnlFLFVBQTFCLENBQXVDLFNBQVMxRixDQUFULENBQVksQ0FDakQsS0FBS2dJLFdBQUwsQ0FBaUIsQ0FBakIsRUFDQSxLQUFLdFEsSUFBTCxDQUFVc1IsUUFBVixDQUFtQixLQUFLbEIsS0FBeEIsQ0FBK0I5SCxDQUEvQixDQUFrQyxJQUFsQyxFQUNBLEtBQUs4SCxLQUFMLEVBQWMsQ0FBZCxDQUNBLE1BQU8sS0FBUCxDQUNELENBTEQsQ0FPQTs7Ozs7O0dBT0F2RyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEIwRSxVQUExQixDQUF1QyxTQUFTM0YsQ0FBVCxDQUFZLENBQ2pELEtBQUtnSSxXQUFMLENBQWlCLENBQWpCLEVBQ0EsS0FBS3RRLElBQUwsQ0FBVXVSLE9BQVYsQ0FBa0IsS0FBS25CLEtBQXZCLENBQThCOUgsQ0FBQyxFQUFJLEVBQUwsQ0FBVSxJQUF4QyxFQUNBLEtBQUt0SSxJQUFMLENBQVVzUixRQUFWLENBQW1CLEtBQUtsQixLQUF4QixDQUErQjlILENBQUMsRUFBSSxDQUFMLENBQVMsTUFBeEMsQ0FBZ0QsSUFBaEQsRUFDQSxLQUFLOEgsS0FBTCxFQUFjLENBQWQsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQU5ELENBUUE7Ozs7OztHQU9BdkcsSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCMkUsVUFBMUIsQ0FBdUMsU0FBUzVGLENBQVQsQ0FBWSxDQUNqRCxLQUFLZ0ksV0FBTCxDQUFpQixDQUFqQixFQUNBLEtBQUt0USxJQUFMLENBQVV3UixRQUFWLENBQW1CLEtBQUtwQixLQUF4QixDQUErQjlILENBQS9CLENBQWtDLElBQWxDLEVBQ0EsS0FBSzhILEtBQUwsRUFBYyxDQUFkLENBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FMRCxDQU9BOzs7Ozs7O0dBUUF2RyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEI0RSxNQUExQixDQUFtQyxTQUFTN0YsQ0FBVCxDQUFZVyxDQUFaLENBQWUsQ0FDaERzRCxlQUFlLENBQUN0RCxDQUFELENBQWYsQ0FDQSxLQUFLcUgsV0FBTCxDQUFpQnJILENBQUMsQ0FBRyxDQUFyQixFQUNBLEVBQUcsQ0FDREEsQ0FBQyxFQUFJLENBQUwsQ0FDQSxLQUFLakosSUFBTCxDQUFVdVIsT0FBVixDQUFrQixLQUFLbkIsS0FBTCxFQUFsQixDQUFpQzlILENBQUMsRUFBSVcsQ0FBTixDQUFXLElBQTNDLEVBQ0QsQ0FIRCxNQUdRQSxDQUFDLENBQUcsQ0FIWixFQUlBLE1BQU8sS0FBUCxDQUNELENBUkQsQ0FVQTs7Ozs7Ozs7R0FTQVksSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCNkUsWUFBMUIsQ0FBeUMsU0FBUzlGLENBQVQsQ0FBWVcsQ0FBWixDQUFlLENBQ3REc0QsZUFBZSxDQUFDdEQsQ0FBRCxDQUFmLENBQ0EsS0FBS3FILFdBQUwsQ0FBaUJySCxDQUFDLENBQUcsQ0FBckIsRUFDQSxHQUFHWCxDQUFDLENBQUcsQ0FBUCxDQUFVLENBQ1JBLENBQUMsRUFBSSxHQUFNVyxDQUFDLENBQUcsQ0FBZixDQUNELENBQ0QsTUFBTyxNQUFLa0YsTUFBTCxDQUFZN0YsQ0FBWixDQUFlVyxDQUFmLENBQVAsQ0FDRCxDQVBELENBU0E7Ozs7R0FLQVksSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCZ0YsT0FBMUIsQ0FBb0MsVUFBVyxDQUM3QyxNQUFPLE1BQUt2TyxJQUFMLENBQVV5UixPQUFWLENBQWtCLEtBQUs5RSxJQUFMLEVBQWxCLENBQVAsQ0FDRCxDQUZELENBSUE7Ozs7O0dBTUE5QyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEJrRixRQUExQixDQUFxQyxVQUFXLENBQzlDLEdBQUlDLEtBQUksQ0FBRyxLQUFLMU8sSUFBTCxDQUFVeU8sUUFBVixDQUFtQixLQUFLOUIsSUFBeEIsQ0FBWCxDQUNBLEtBQUtBLElBQUwsRUFBYSxDQUFiLENBQ0EsTUFBTytCLEtBQVAsQ0FDRCxDQUpELENBTUE7Ozs7O0dBTUE3RSxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEJvRixRQUExQixDQUFxQyxVQUFXLENBQzlDLEdBQUlELEtBQUksQ0FDTixLQUFLMU8sSUFBTCxDQUFVeU8sUUFBVixDQUFtQixLQUFLOUIsSUFBeEIsR0FBaUMsQ0FBakMsQ0FDQSxLQUFLM00sSUFBTCxDQUFVeVIsT0FBVixDQUFrQixLQUFLOUUsSUFBTCxDQUFZLENBQTlCLENBRkYsQ0FHQSxLQUFLQSxJQUFMLEVBQWEsQ0FBYixDQUNBLE1BQU8rQixLQUFQLENBQ0QsQ0FORCxDQVFBOzs7OztHQU1BN0UsSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCcUYsUUFBMUIsQ0FBcUMsVUFBVyxDQUM5QyxHQUFJRixLQUFJLENBQUcsS0FBSzFPLElBQUwsQ0FBVTRPLFFBQVYsQ0FBbUIsS0FBS2pDLElBQXhCLENBQVgsQ0FDQSxLQUFLQSxJQUFMLEVBQWEsQ0FBYixDQUNBLE1BQU8rQixLQUFQLENBQ0QsQ0FKRCxDQU1BOzs7OztHQU1BN0UsSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCc0YsVUFBMUIsQ0FBdUMsVUFBVyxDQUNoRCxHQUFJSCxLQUFJLENBQUcsS0FBSzFPLElBQUwsQ0FBVXlPLFFBQVYsQ0FBbUIsS0FBSzlCLElBQXhCLENBQThCLElBQTlCLENBQVgsQ0FDQSxLQUFLQSxJQUFMLEVBQWEsQ0FBYixDQUNBLE1BQU8rQixLQUFQLENBQ0QsQ0FKRCxDQU1BOzs7OztHQU1BN0UsSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCdUYsVUFBMUIsQ0FBdUMsVUFBVyxDQUNoRCxHQUFJSixLQUFJLENBQ04sS0FBSzFPLElBQUwsQ0FBVXlSLE9BQVYsQ0FBa0IsS0FBSzlFLElBQXZCLEVBQ0EsS0FBSzNNLElBQUwsQ0FBVXlPLFFBQVYsQ0FBbUIsS0FBSzlCLElBQUwsQ0FBWSxDQUEvQixDQUFrQyxJQUFsQyxHQUEyQyxDQUY3QyxDQUdBLEtBQUtBLElBQUwsRUFBYSxDQUFiLENBQ0EsTUFBTytCLEtBQVAsQ0FDRCxDQU5ELENBUUE7Ozs7O0dBTUE3RSxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEJ3RixVQUExQixDQUF1QyxVQUFXLENBQ2hELEdBQUlMLEtBQUksQ0FBRyxLQUFLMU8sSUFBTCxDQUFVNE8sUUFBVixDQUFtQixLQUFLakMsSUFBeEIsQ0FBOEIsSUFBOUIsQ0FBWCxDQUNBLEtBQUtBLElBQUwsRUFBYSxDQUFiLENBQ0EsTUFBTytCLEtBQVAsQ0FDRCxDQUpELENBTUE7Ozs7Ozs7R0FRQTdFLElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQnlGLE1BQTFCLENBQW1DLFNBQVMvRixDQUFULENBQVksQ0FDN0NzRCxlQUFlLENBQUN0RCxDQUFELENBQWYsQ0FDQSxHQUFJeUYsS0FBSSxDQUFHLENBQVgsQ0FDQSxFQUFHLENBQ0Q7QUFDQUEsSUFBSSxDQUFHLENBQUNBLElBQUksRUFBSSxDQUFULEVBQWMsS0FBSzFPLElBQUwsQ0FBVXlSLE9BQVYsQ0FBa0IsS0FBSzlFLElBQUwsRUFBbEIsQ0FBckIsQ0FDQTFELENBQUMsRUFBSSxDQUFMLENBQ0QsQ0FKRCxNQUlRQSxDQUFDLENBQUcsQ0FKWixFQUtBLE1BQU95RixLQUFQLENBQ0QsQ0FURCxDQVdBOzs7Ozs7O0dBUUE3RSxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEIwRixZQUExQixDQUF5QyxTQUFTaEcsQ0FBVCxDQUFZLENBQ25EO0FBQ0EsR0FBSWdELEVBQUMsQ0FBRyxLQUFLK0MsTUFBTCxDQUFZL0YsQ0FBWixDQUFSLENBQ0EsR0FBSWlHLElBQUcsQ0FBRyxHQUFNakcsQ0FBQyxDQUFHLENBQXBCLENBQ0EsR0FBR2dELENBQUMsRUFBSWlELEdBQVIsQ0FBYSxDQUNYakQsQ0FBQyxFQUFJaUQsR0FBRyxFQUFJLENBQVosQ0FDRCxDQUNELE1BQU9qRCxFQUFQLENBQ0QsQ0FSRCxDQVVBOzs7Ozs7R0FPQXBDLElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQitFLFFBQTFCLENBQXFDLFNBQVNhLEtBQVQsQ0FBZ0IsQ0FDbkQ7QUFDQTtBQUNBO0FBQ0EsR0FBSVQsS0FBSixDQUNBLEdBQUdTLEtBQUgsQ0FBVSxDQUNSO0FBQ0FBLEtBQUssQ0FBR25LLElBQUksQ0FBQ29LLEdBQUwsQ0FBUyxLQUFLaFIsTUFBTCxFQUFULENBQXdCK1EsS0FBeEIsQ0FBUixDQUNBVCxJQUFJLENBQUcsS0FBSzFPLElBQUwsQ0FBVThLLEtBQVYsQ0FBZ0IsS0FBSzZCLElBQXJCLENBQTJCLEtBQUtBLElBQUwsQ0FBWXdDLEtBQXZDLENBQVAsQ0FDQSxLQUFLeEMsSUFBTCxFQUFhd0MsS0FBYixDQUNELENBTEQsSUFLTyxJQUFHQSxLQUFLLEdBQUssQ0FBYixDQUFnQixDQUNyQlQsSUFBSSxDQUFHLEVBQVAsQ0FDRCxDQUZNLElBRUEsQ0FDTDtBQUNBQSxJQUFJLENBQUksS0FBSy9CLElBQUwsR0FBYyxDQUFmLENBQW9CLEtBQUszTSxJQUF6QixDQUFnQyxLQUFLQSxJQUFMLENBQVU4SyxLQUFWLENBQWdCLEtBQUs2QixJQUFyQixDQUF2QyxDQUNBLEtBQUswQyxLQUFMLEdBQ0QsQ0FDRCxNQUFPWCxLQUFQLENBQ0QsQ0FsQkQsQ0FvQkE7Ozs7Ozs7R0FRQTdFLElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQmtFLEtBQTFCLENBQWtDLFNBQVMwQixLQUFULENBQWdCLENBQ2hEO0FBQ0EsTUFBUSxPQUFPQSxNQUFQLEdBQWtCLFdBQWxCLENBQ04sS0FBS25QLElBQUwsQ0FBVThLLEtBQVYsQ0FBZ0IsS0FBSzZCLElBQXJCLENBRE0sQ0FFTixLQUFLM00sSUFBTCxDQUFVOEssS0FBVixDQUFnQixLQUFLNkIsSUFBckIsQ0FBMkIsS0FBS0EsSUFBTCxDQUFZd0MsS0FBdkMsQ0FGRixDQUdELENBTEQsQ0FPQTs7Ozs7O0dBT0F0RixJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEIrRixFQUExQixDQUErQixTQUFTaEgsQ0FBVCxDQUFZLENBQ3pDLE1BQU8sTUFBS3RJLElBQUwsQ0FBVTBSLFFBQVYsQ0FBbUIsS0FBSy9FLElBQUwsQ0FBWXJFLENBQS9CLENBQVAsQ0FDRCxDQUZELENBSUE7Ozs7Ozs7R0FRQXVCLElBQUksQ0FBQ2tHLFVBQUwsQ0FBZ0J4RyxTQUFoQixDQUEwQmdHLEtBQTFCLENBQWtDLFNBQVNqSCxDQUFULENBQVlvRSxDQUFaLENBQWUsQ0FDL0MsS0FBSzFNLElBQUwsQ0FBVTJRLFFBQVYsQ0FBbUJySSxDQUFuQixDQUFzQm9FLENBQXRCLEVBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FIRCxDQUtBOzs7O0dBS0E3QyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEJpRyxJQUExQixDQUFpQyxVQUFXLENBQzFDLE1BQU8sTUFBS3hQLElBQUwsQ0FBVTBSLFFBQVYsQ0FBbUIsS0FBS3RCLEtBQUwsQ0FBYSxDQUFoQyxDQUFQLENBQ0QsQ0FGRCxDQUlBOzs7O0dBS0F2RyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEJxQixJQUExQixDQUFpQyxVQUFXLENBQzFDLE1BQU8sSUFBSWYsS0FBSSxDQUFDa0csVUFBVCxDQUFvQixJQUFwQixDQUFQLENBQ0QsQ0FGRCxDQUlBOzs7O0dBS0FsRyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEJtRyxPQUExQixDQUFvQyxVQUFXLENBQzdDLEdBQUcsS0FBSy9DLElBQUwsQ0FBWSxDQUFmLENBQWtCLENBQ2hCLEdBQUk2RCxJQUFHLENBQUcsR0FBSTFELFdBQUosQ0FBZSxLQUFLOU0sSUFBTCxDQUFVcU0sTUFBekIsQ0FBaUMsS0FBS00sSUFBdEMsQ0FBVixDQUNBLEdBQUk4RCxJQUFHLENBQUcsR0FBSTNELFdBQUosQ0FBZTBELEdBQUcsQ0FBQ2xFLFVBQW5CLENBQVYsQ0FDQW1FLEdBQUcsQ0FBQ0MsR0FBSixDQUFRRixHQUFSLEVBQ0EsS0FBS3hRLElBQUwsQ0FBWSxHQUFJa1EsU0FBSixDQUFhTyxHQUFiLENBQVosQ0FDQSxLQUFLTCxLQUFMLEVBQWMsS0FBS3pELElBQW5CLENBQ0EsS0FBS0EsSUFBTCxDQUFZLENBQVosQ0FDRCxDQUNELE1BQU8sS0FBUCxDQUNELENBVkQsQ0FZQTs7OztHQUtBOUMsSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCOEYsS0FBMUIsQ0FBa0MsVUFBVyxDQUMzQyxLQUFLclAsSUFBTCxDQUFZLEdBQUlrUSxTQUFKLENBQWEsR0FBSS9ELFlBQUosQ0FBZ0IsQ0FBaEIsQ0FBYixDQUFaLENBQ0EsS0FBS1EsSUFBTCxDQUFZLEtBQUt5RCxLQUFMLENBQWEsQ0FBekIsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUpELENBTUE7Ozs7OztHQU9BdkcsSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCb0csUUFBMUIsQ0FBcUMsU0FBU1IsS0FBVCxDQUFnQixDQUNuRCxLQUFLaUIsS0FBTCxDQUFhcEwsSUFBSSxDQUFDa0ssR0FBTCxDQUFTLENBQVQsQ0FBWSxLQUFLOVEsTUFBTCxHQUFnQitRLEtBQTVCLENBQWIsQ0FDQSxLQUFLeEMsSUFBTCxDQUFZM0gsSUFBSSxDQUFDb0ssR0FBTCxDQUFTLEtBQUt6QyxJQUFkLENBQW9CLEtBQUt5RCxLQUF6QixDQUFaLENBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FKRCxDQU1BOzs7O0dBS0F2RyxJQUFJLENBQUNrRyxVQUFMLENBQWdCeEcsU0FBaEIsQ0FBMEJzRyxLQUExQixDQUFrQyxVQUFXLENBQzNDLEdBQUluQixLQUFJLENBQUcsRUFBWCxDQUNBLElBQUksR0FBSXBHLEVBQUMsQ0FBRyxLQUFLcUUsSUFBakIsQ0FBdUJyRSxDQUFDLENBQUcsS0FBS3RJLElBQUwsQ0FBVXNNLFVBQXJDLENBQWlELEVBQUVoRSxDQUFuRCxDQUFzRCxDQUNwRCxHQUFJb0UsRUFBQyxDQUFHLEtBQUsxTSxJQUFMLENBQVUwUixRQUFWLENBQW1CcEosQ0FBbkIsQ0FBUixDQUNBLEdBQUdvRSxDQUFDLENBQUcsRUFBUCxDQUFXLENBQ1RnQyxJQUFJLEVBQUksR0FBUixDQUNELENBQ0RBLElBQUksRUFBSWhDLENBQUMsQ0FBQ3hILFFBQUYsQ0FBVyxFQUFYLENBQVIsQ0FDRCxDQUNELE1BQU93SixLQUFQLENBQ0QsQ0FWRCxDQVlBOzs7Ozs7OztHQVNBN0UsSUFBSSxDQUFDa0csVUFBTCxDQUFnQnhHLFNBQWhCLENBQTBCckUsUUFBMUIsQ0FBcUMsU0FBUzBMLFFBQVQsQ0FBbUIsQ0FDdEQsR0FBSUMsS0FBSSxDQUFHLEdBQUkvRCxXQUFKLENBQWUsS0FBSzlNLElBQXBCLENBQTBCLEtBQUsyTSxJQUEvQixDQUFxQyxLQUFLdk8sTUFBTCxFQUFyQyxDQUFYLENBQ0F3UyxRQUFRLENBQUdBLFFBQVEsRUFBSSxNQUF2QixDQUVBO0FBQ0EsR0FBR0EsUUFBUSxHQUFLLFFBQWIsRUFBeUJBLFFBQVEsR0FBSyxLQUF6QyxDQUFnRCxDQUM5QyxNQUFPL0csS0FBSSxDQUFDa0gsTUFBTCxDQUFZOU4sR0FBWixDQUFnQm9PLE1BQWhCLENBQXVCUixJQUF2QixDQUFQLENBQ0QsQ0FDRCxHQUFHRCxRQUFRLEdBQUssS0FBaEIsQ0FBdUIsQ0FDckIsTUFBTy9HLEtBQUksQ0FBQ2tILE1BQUwsQ0FBWUMsR0FBWixDQUFnQkssTUFBaEIsQ0FBdUJSLElBQXZCLENBQVAsQ0FDRCxDQUNELEdBQUdELFFBQVEsR0FBSyxRQUFoQixDQUEwQixDQUN4QixNQUFPL0csS0FBSSxDQUFDa0gsTUFBTCxDQUFZRyxNQUFaLENBQW1CRyxNQUFuQixDQUEwQlIsSUFBMUIsQ0FBUCxDQUNELENBRUQ7QUFDQSxHQUFHRCxRQUFRLEdBQUssTUFBaEIsQ0FBd0IsQ0FDdEIsTUFBTy9HLEtBQUksQ0FBQzdELElBQUwsQ0FBVTJMLElBQVYsQ0FBZVYsTUFBZixDQUFzQkosSUFBdEIsQ0FBUCxDQUNELENBQ0QsR0FBR0QsUUFBUSxHQUFLLE9BQWhCLENBQXlCLENBQ3ZCLE1BQU8vRyxLQUFJLENBQUM3RCxJQUFMLENBQVVvTCxLQUFWLENBQWdCSCxNQUFoQixDQUF1QkosSUFBdkIsQ0FBUCxDQUNELENBRUQsS0FBTSxJQUFJM1MsTUFBSixDQUFVLHFCQUF1QjBTLFFBQWpDLENBQU4sQ0FDRCxDQXhCRCxDQTBCQSxzQ0FuM0NzRCxDQXEzQ3REOzs7Ozs7OztHQVNBL0csSUFBSSxDQUFDNEYsWUFBTCxDQUFvQixTQUFTbUMsS0FBVCxDQUFnQmhCLFFBQWhCLENBQTBCLENBQzVDO0FBQ0FBLFFBQVEsQ0FBR0EsUUFBUSxFQUFJLEtBQXZCLENBQ0EsR0FBR2dCLEtBQUssR0FBS3pILFNBQVYsRUFBdUJ5RyxRQUFRLEdBQUssTUFBdkMsQ0FBK0MsQ0FDN0NnQixLQUFLLENBQUcvSCxJQUFJLENBQUMrRCxVQUFMLENBQWdCZ0UsS0FBaEIsQ0FBUixDQUNELENBQ0QsTUFBTyxJQUFJL0gsS0FBSSxDQUFDMkMsVUFBVCxDQUFvQm9GLEtBQXBCLENBQVAsQ0FDRCxDQVBELENBU0E7Ozs7Ozs7OztHQVVBL0gsSUFBSSxDQUFDZ0ksVUFBTCxDQUFrQixTQUFTbkosQ0FBVCxDQUFZTyxDQUFaLENBQWUsQ0FDL0IsR0FBSVMsRUFBQyxDQUFHLEVBQVIsQ0FDQSxNQUFNVCxDQUFDLENBQUcsQ0FBVixDQUFhLENBQ1gsR0FBR0EsQ0FBQyxDQUFHLENBQVAsQ0FBVSxDQUNSUyxDQUFDLEVBQUloQixDQUFMLENBQ0QsQ0FDRE8sQ0FBQyxJQUFNLENBQVAsQ0FDQSxHQUFHQSxDQUFDLENBQUcsQ0FBUCxDQUFVLENBQ1JQLENBQUMsRUFBSUEsQ0FBTCxDQUNELENBQ0YsQ0FDRCxNQUFPZ0IsRUFBUCxDQUNELENBWkQsQ0FjQTs7Ozs7Ozs7O0dBVUFHLElBQUksQ0FBQ2lJLFFBQUwsQ0FBZ0IsU0FBU0MsRUFBVCxDQUFhQyxFQUFiLENBQWlCL0ksQ0FBakIsQ0FBb0IsQ0FDbEMsR0FBSWdKLEdBQUUsQ0FBRyxFQUFULENBQ0EsR0FBSXZGLEVBQUMsQ0FBRyxFQUFSLENBQ0EsR0FBSXdGLEVBQUMsQ0FBRyxFQUFSLENBQ0EsR0FBSTVKLEVBQUMsQ0FBRyxDQUFSLENBQ0EsR0FBSUksRUFBQyxDQUFHLENBQVIsQ0FDQSxLQUFNTyxDQUFDLENBQUcsQ0FBVixDQUFhLEVBQUVBLENBQUYsQ0FBSyxFQUFFWCxDQUFwQixDQUF1QixDQUNyQm9FLENBQUMsQ0FBR3FGLEVBQUUsQ0FBQ3ZELFVBQUgsQ0FBY2xHLENBQWQsRUFBbUIwSixFQUFFLENBQUN4RCxVQUFILENBQWNsRyxDQUFkLENBQXZCLENBQ0EsR0FBR0ksQ0FBQyxFQUFJLEVBQVIsQ0FBWSxDQUNWdUosRUFBRSxFQUFJQyxDQUFOLENBQ0FBLENBQUMsQ0FBRyxFQUFKLENBQ0F4SixDQUFDLENBQUcsQ0FBSixDQUNELENBQ0R3SixDQUFDLEVBQUluRixNQUFNLENBQUNDLFlBQVAsQ0FBb0JOLENBQXBCLENBQUwsQ0FDQSxFQUFFaEUsQ0FBRixDQUNELENBQ0R1SixFQUFFLEVBQUlDLENBQU4sQ0FDQSxNQUFPRCxHQUFQLENBQ0QsQ0FsQkQsQ0FvQkE7Ozs7OztHQU9BcEksSUFBSSxDQUFDc0ksVUFBTCxDQUFrQixTQUFTbkIsR0FBVCxDQUFjLENBQzlCO0FBQ0EsR0FBSXRDLEtBQUksQ0FBRyxFQUFYLENBQ0EsR0FBSXBHLEVBQUMsQ0FBRyxDQUFSLENBQ0EsR0FBRzBJLEdBQUcsQ0FBQzVTLE1BQUosQ0FBYSxHQUFLLENBQXJCLENBQXdCLENBQ3RCO0FBQ0FrSyxDQUFDLENBQUcsQ0FBSixDQUNBb0csSUFBSSxFQUFJM0IsTUFBTSxDQUFDQyxZQUFQLENBQW9Cb0YsUUFBUSxDQUFDcEIsR0FBRyxDQUFDLENBQUQsQ0FBSixDQUFTLEVBQVQsQ0FBNUIsQ0FBUixDQUNELENBQ0Q7QUFDQSxLQUFNMUksQ0FBQyxDQUFHMEksR0FBRyxDQUFDNVMsTUFBZCxDQUFzQmtLLENBQUMsRUFBSSxDQUEzQixDQUE4QixDQUM1Qm9HLElBQUksRUFBSTNCLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQm9GLFFBQVEsQ0FBQ3BCLEdBQUcsQ0FBQzdMLE1BQUosQ0FBV21ELENBQVgsQ0FBYyxDQUFkLENBQUQsQ0FBbUIsRUFBbkIsQ0FBNUIsQ0FBUixDQUNELENBQ0QsTUFBT29HLEtBQVAsQ0FDRCxDQWRELENBZ0JBOzs7Ozs7R0FPQTdFLElBQUksQ0FBQ3dJLFVBQUwsQ0FBa0IsU0FBUzVFLEtBQVQsQ0FBZ0IsQ0FDaEM7QUFDQSxNQUFPNUQsS0FBSSxDQUFDNEYsWUFBTCxDQUFrQmhDLEtBQWxCLEVBQXlCb0MsS0FBekIsRUFBUCxDQUNELENBSEQsQ0FLQTs7Ozs7O0dBT0FoRyxJQUFJLENBQUN5SSxZQUFMLENBQW9CLFNBQVNoSyxDQUFULENBQVksQ0FDOUIsTUFDRXlFLE9BQU0sQ0FBQ0MsWUFBUCxDQUFvQjFFLENBQUMsRUFBSSxFQUFMLENBQVUsSUFBOUIsRUFDQXlFLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjFFLENBQUMsRUFBSSxFQUFMLENBQVUsSUFBOUIsQ0FEQSxDQUVBeUUsTUFBTSxDQUFDQyxZQUFQLENBQW9CMUUsQ0FBQyxFQUFJLENBQUwsQ0FBUyxJQUE3QixDQUZBLENBR0F5RSxNQUFNLENBQUNDLFlBQVAsQ0FBb0IxRSxDQUFDLENBQUcsSUFBeEIsQ0FKRixDQUtELENBTkQsQ0FRQTtBQUNBLEdBQUlpSyxRQUFPLENBQ1QsbUVBREYsQ0FFQSxHQUFJQyxXQUFVLENBQUcsQ0FDakIsY0FEaUIsQ0FFakIsd0JBQ0csRUFIYyxDQUdWLENBQUMsQ0FIUyxDQUdOLENBQUMsQ0FISyxDQUdGLENBQUMsQ0FIQyxDQUdFLEVBSEYsQ0FLakIsNENBQ0csRUFOYyxDQU1WLEVBTlUsQ0FNTixFQU5NLENBTUYsRUFORSxDQU1FLEVBTkYsQ0FNTSxFQU5OLENBTVUsRUFOVixDQU1jLEVBTmQsQ0FNa0IsRUFObEIsQ0FNc0IsRUFOdEIsQ0FRakIsK0JBQ0UsQ0FBQyxDQVRjLENBU1gsQ0FBQyxDQVRVLENBU1AsQ0FBQyxDQVRNLENBU0gsRUFURyxDQVNDLENBQUMsQ0FURixDQVNLLENBQUMsQ0FUTixDQVNTLENBQUMsQ0FUVixDQVdqQixnQkFYaUIsQ0FZakIseURBQ0csQ0FiYyxDQWFWLENBYlUsQ0FhTixDQWJNLENBYUYsQ0FiRSxDQWFFLENBYkYsQ0FhTSxDQWJOLENBYVUsQ0FiVixDQWFjLENBYmQsQ0Fha0IsQ0FibEIsQ0Fhc0IsQ0FidEIsQ0FheUIsRUFiekIsQ0FhNkIsRUFiN0IsQ0FhaUMsRUFiakMsQ0FlakIsd0RBQ0csRUFoQmMsQ0FnQlYsRUFoQlUsQ0FnQk4sRUFoQk0sQ0FnQkYsRUFoQkUsQ0FnQkUsRUFoQkYsQ0FnQk0sRUFoQk4sQ0FnQlUsRUFoQlYsQ0FnQmMsRUFoQmQsQ0FnQmtCLEVBaEJsQixDQWdCc0IsRUFoQnRCLENBZ0IwQixFQWhCMUIsQ0FnQjhCLEVBaEI5QixDQWdCa0MsRUFoQmxDLENBa0JqQixpQkFsQmlCLENBbUJqQiwyQkFDRSxDQUFDLENBcEJjLENBb0JYLENBQUMsQ0FwQlUsQ0FvQlAsQ0FBQyxDQXBCTSxDQW9CSCxDQUFDLENBcEJFLENBb0JDLENBQUMsQ0FwQkYsQ0FvQkssQ0FBQyxDQXBCTixDQXNCakIsZ0JBdEJpQixDQXVCakIsd0RBQ0csRUF4QmMsQ0F3QlYsRUF4QlUsQ0F3Qk4sRUF4Qk0sQ0F3QkYsRUF4QkUsQ0F3QkUsRUF4QkYsQ0F3Qk0sRUF4Qk4sQ0F3QlUsRUF4QlYsQ0F3QmMsRUF4QmQsQ0F3QmtCLEVBeEJsQixDQXdCc0IsRUF4QnRCLENBd0IwQixFQXhCMUIsQ0F3QjhCLEVBeEI5QixDQXdCa0MsRUF4QmxDLENBMEJqQix3REFDRyxFQTNCYyxDQTJCVixFQTNCVSxDQTJCTixFQTNCTSxDQTJCRixFQTNCRSxDQTJCRSxFQTNCRixDQTJCTSxFQTNCTixDQTJCVSxFQTNCVixDQTJCYyxFQTNCZCxDQTJCa0IsRUEzQmxCLENBMkJzQixFQTNCdEIsQ0EyQjBCLEVBM0IxQixDQTJCOEIsRUEzQjlCLENBMkJrQyxFQTNCbEMsQ0FBakIsQ0E4QkE7QUFDQSxHQUFJQyxRQUFPLENBQUcsNERBQWQsQ0FFQTs7Ozs7Ozs7R0FTQTVJLElBQUksQ0FBQzZJLFFBQUwsQ0FBZ0IsU0FBU2QsS0FBVCxDQUFnQmUsT0FBaEIsQ0FBeUIsQ0FDdkM7QUFDQSxHQUFJQyxLQUFJLENBQUcsRUFBWCxDQUNBLEdBQUlDLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBSUMsS0FBSixDQUFVQyxJQUFWLENBQWdCQyxJQUFoQixDQUNBLEdBQUkxSyxFQUFDLENBQUcsQ0FBUixDQUNBLE1BQU1BLENBQUMsQ0FBR3NKLEtBQUssQ0FBQ3hULE1BQWhCLENBQXdCLENBQ3RCMFUsSUFBSSxDQUFHbEIsS0FBSyxDQUFDcEQsVUFBTixDQUFpQmxHLENBQUMsRUFBbEIsQ0FBUCxDQUNBeUssSUFBSSxDQUFHbkIsS0FBSyxDQUFDcEQsVUFBTixDQUFpQmxHLENBQUMsRUFBbEIsQ0FBUCxDQUNBMEssSUFBSSxDQUFHcEIsS0FBSyxDQUFDcEQsVUFBTixDQUFpQmxHLENBQUMsRUFBbEIsQ0FBUCxDQUVBO0FBQ0FzSyxJQUFJLEVBQUlMLE9BQU8sQ0FBQ1UsTUFBUixDQUFlSCxJQUFJLEVBQUksQ0FBdkIsQ0FBUixDQUNBRixJQUFJLEVBQUlMLE9BQU8sQ0FBQ1UsTUFBUixDQUFnQixDQUFDSCxJQUFJLENBQUcsQ0FBUixHQUFjLENBQWYsQ0FBcUJDLElBQUksRUFBSSxDQUE1QyxDQUFSLENBQ0EsR0FBR0csS0FBSyxDQUFDSCxJQUFELENBQVIsQ0FBZ0IsQ0FDZEgsSUFBSSxFQUFJLElBQVIsQ0FDRCxDQUZELElBRU8sQ0FDTEEsSUFBSSxFQUFJTCxPQUFPLENBQUNVLE1BQVIsQ0FBZ0IsQ0FBQ0YsSUFBSSxDQUFHLEVBQVIsR0FBZSxDQUFoQixDQUFzQkMsSUFBSSxFQUFJLENBQTdDLENBQVIsQ0FDQUosSUFBSSxFQUFJTSxLQUFLLENBQUNGLElBQUQsQ0FBTCxDQUFjLEdBQWQsQ0FBb0JULE9BQU8sQ0FBQ1UsTUFBUixDQUFlRCxJQUFJLENBQUcsRUFBdEIsQ0FBNUIsQ0FDRCxDQUVELEdBQUdMLE9BQU8sRUFBSUMsSUFBSSxDQUFDeFUsTUFBTCxDQUFjdVUsT0FBNUIsQ0FBcUMsQ0FDbkNFLE1BQU0sRUFBSUQsSUFBSSxDQUFDek4sTUFBTCxDQUFZLENBQVosQ0FBZXdOLE9BQWYsRUFBMEIsTUFBcEMsQ0FDQUMsSUFBSSxDQUFHQSxJQUFJLENBQUN6TixNQUFMLENBQVl3TixPQUFaLENBQVAsQ0FDRCxDQUNGLENBQ0RFLE1BQU0sRUFBSUQsSUFBVixDQUNBLE1BQU9DLE9BQVAsQ0FDRCxDQTVCRCxDQThCQTs7Ozs7O0dBT0FoSixJQUFJLENBQUNzSixRQUFMLENBQWdCLFNBQVN2QixLQUFULENBQWdCLENBQzlCO0FBRUE7QUFDQUEsS0FBSyxDQUFHQSxLQUFLLENBQUNwVCxPQUFOLENBQWMscUJBQWQsQ0FBcUMsRUFBckMsQ0FBUixDQUVBLEdBQUlxVSxPQUFNLENBQUcsRUFBYixDQUNBLEdBQUlPLEtBQUosQ0FBVUMsSUFBVixDQUFnQkMsSUFBaEIsQ0FBc0JDLElBQXRCLENBQ0EsR0FBSWpMLEVBQUMsQ0FBRyxDQUFSLENBRUEsTUFBTUEsQ0FBQyxDQUFHc0osS0FBSyxDQUFDeFQsTUFBaEIsQ0FBd0IsQ0FDdEJnVixJQUFJLENBQUdaLFVBQVUsQ0FBQ1osS0FBSyxDQUFDcEQsVUFBTixDQUFpQmxHLENBQUMsRUFBbEIsRUFBd0IsRUFBekIsQ0FBakIsQ0FDQStLLElBQUksQ0FBR2IsVUFBVSxDQUFDWixLQUFLLENBQUNwRCxVQUFOLENBQWlCbEcsQ0FBQyxFQUFsQixFQUF3QixFQUF6QixDQUFqQixDQUNBZ0wsSUFBSSxDQUFHZCxVQUFVLENBQUNaLEtBQUssQ0FBQ3BELFVBQU4sQ0FBaUJsRyxDQUFDLEVBQWxCLEVBQXdCLEVBQXpCLENBQWpCLENBQ0FpTCxJQUFJLENBQUdmLFVBQVUsQ0FBQ1osS0FBSyxDQUFDcEQsVUFBTixDQUFpQmxHLENBQUMsRUFBbEIsRUFBd0IsRUFBekIsQ0FBakIsQ0FFQXVLLE1BQU0sRUFBSTlGLE1BQU0sQ0FBQ0MsWUFBUCxDQUFxQm9HLElBQUksRUFBSSxDQUFULENBQWVDLElBQUksRUFBSSxDQUEzQyxDQUFWLENBQ0EsR0FBR0MsSUFBSSxHQUFLLEVBQVosQ0FBZ0IsQ0FDZDtBQUNBVCxNQUFNLEVBQUk5RixNQUFNLENBQUNDLFlBQVAsQ0FBcUIsQ0FBQ3FHLElBQUksQ0FBRyxFQUFSLEdBQWUsQ0FBaEIsQ0FBc0JDLElBQUksRUFBSSxDQUFsRCxDQUFWLENBQ0EsR0FBR0MsSUFBSSxHQUFLLEVBQVosQ0FBZ0IsQ0FDZDtBQUNBVixNQUFNLEVBQUk5RixNQUFNLENBQUNDLFlBQVAsQ0FBcUIsQ0FBQ3NHLElBQUksQ0FBRyxDQUFSLEdBQWMsQ0FBZixDQUFvQkMsSUFBeEMsQ0FBVixDQUNELENBQ0YsQ0FDRixDQUVELE1BQU9WLE9BQVAsQ0FDRCxDQTVCRCxDQThCQTs7Ozs7Ozs7R0FTQWhKLElBQUksQ0FBQytELFVBQUwsQ0FBa0IsU0FBU0QsR0FBVCxDQUFjLENBQzlCLE1BQU82RixTQUFRLENBQUMzTyxrQkFBa0IsQ0FBQzhJLEdBQUQsQ0FBbkIsQ0FBZixDQUNELENBRkQsQ0FJQTs7Ozs7O0dBT0E5RCxJQUFJLENBQUNpRyxVQUFMLENBQWtCLFNBQVNuQyxHQUFULENBQWMsQ0FDOUIsTUFBTzhGLG1CQUFrQixDQUFDQyxNQUFNLENBQUMvRixHQUFELENBQVAsQ0FBekIsQ0FDRCxDQUZELENBSUE7QUFDQTtBQUNBOUQsSUFBSSxDQUFDa0gsTUFBTCxDQUFjLENBQ1o5TixHQUFHLENBQUUsRUFETyxDQUVaK04sR0FBRyxDQUFFLEVBRk8sQ0FHWkUsTUFBTSxDQUFFLEVBSEksQ0FJWnlDLE1BQU0sQ0FBRSxFQUpJLENBS1ovSixLQUFLLENBQUcsQ0FDTnlILE1BQU0sQ0FBRXpILEtBQUssQ0FBQ3lILE1BRFIsQ0FFTkosTUFBTSxDQUFFckgsS0FBSyxDQUFDcUgsTUFGUixDQUxJLENBQWQsQ0FXQTs7Ozs7OztHQVFBcEgsSUFBSSxDQUFDa0gsTUFBTCxDQUFZOU4sR0FBWixDQUFnQm9PLE1BQWhCLENBQXlCLFNBQVM1RCxLQUFULENBQWdCLENBQ3ZDLE1BQU9WLE9BQU0sQ0FBQ0MsWUFBUCxDQUFvQjlDLEtBQXBCLENBQTBCLElBQTFCLENBQWdDdUQsS0FBaEMsQ0FBUCxDQUNELENBRkQsQ0FJQTs7Ozs7Ozs7OztHQVdBNUQsSUFBSSxDQUFDa0gsTUFBTCxDQUFZOU4sR0FBWixDQUFnQmdPLE1BQWhCLENBQXlCLFNBQVN0RCxHQUFULENBQWNrRixNQUFkLENBQXNCZSxNQUF0QixDQUE4QixDQUNyRCxHQUFJQyxJQUFHLENBQUdoQixNQUFWLENBQ0EsR0FBRyxDQUFDZ0IsR0FBSixDQUFTLENBQ1BBLEdBQUcsQ0FBRyxHQUFJL0csV0FBSixDQUFlYSxHQUFHLENBQUN2UCxNQUFuQixDQUFOLENBQ0QsQ0FDRHdWLE1BQU0sQ0FBR0EsTUFBTSxFQUFJLENBQW5CLENBQ0EsR0FBSUUsRUFBQyxDQUFHRixNQUFSLENBQ0EsSUFBSSxHQUFJdEwsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHcUYsR0FBRyxDQUFDdlAsTUFBdkIsQ0FBK0IsRUFBRWtLLENBQWpDLENBQW9DLENBQ2xDdUwsR0FBRyxDQUFDQyxDQUFDLEVBQUYsQ0FBSCxDQUFXbkcsR0FBRyxDQUFDYSxVQUFKLENBQWVsRyxDQUFmLENBQVgsQ0FDRCxDQUNELE1BQU91SyxPQUFNLENBQUlpQixDQUFDLENBQUdGLE1BQVIsQ0FBa0JDLEdBQS9CLENBQ0QsQ0FYRCxDQWFBOzs7Ozs7O0dBUUFoSyxJQUFJLENBQUNrSCxNQUFMLENBQVlDLEdBQVosQ0FBZ0JLLE1BQWhCLENBQXlCeEgsSUFBSSxDQUFDd0ksVUFBOUIsQ0FFQTs7Ozs7Ozs7O0dBVUF4SSxJQUFJLENBQUNrSCxNQUFMLENBQVlDLEdBQVosQ0FBZ0JDLE1BQWhCLENBQXlCLFNBQVNELEdBQVQsQ0FBYzZCLE1BQWQsQ0FBc0JlLE1BQXRCLENBQThCLENBQ3JELEdBQUlDLElBQUcsQ0FBR2hCLE1BQVYsQ0FDQSxHQUFHLENBQUNnQixHQUFKLENBQVMsQ0FDUEEsR0FBRyxDQUFHLEdBQUkvRyxXQUFKLENBQWU5SCxJQUFJLENBQUM4TCxJQUFMLENBQVVFLEdBQUcsQ0FBQzVTLE1BQUosQ0FBYSxDQUF2QixDQUFmLENBQU4sQ0FDRCxDQUNEd1YsTUFBTSxDQUFHQSxNQUFNLEVBQUksQ0FBbkIsQ0FDQSxHQUFJdEwsRUFBQyxDQUFHLENBQVIsQ0FBV3dMLENBQUMsQ0FBR0YsTUFBZixDQUNBLEdBQUc1QyxHQUFHLENBQUM1UyxNQUFKLENBQWEsQ0FBaEIsQ0FBbUIsQ0FDakI7QUFDQWtLLENBQUMsQ0FBRyxDQUFKLENBQ0F1TCxHQUFHLENBQUNDLENBQUMsRUFBRixDQUFILENBQVcxQixRQUFRLENBQUNwQixHQUFHLENBQUMsQ0FBRCxDQUFKLENBQVMsRUFBVCxDQUFuQixDQUNELENBQ0Q7QUFDQSxLQUFNMUksQ0FBQyxDQUFHMEksR0FBRyxDQUFDNVMsTUFBZCxDQUFzQmtLLENBQUMsRUFBSSxDQUEzQixDQUE4QixDQUM1QnVMLEdBQUcsQ0FBQ0MsQ0FBQyxFQUFGLENBQUgsQ0FBVzFCLFFBQVEsQ0FBQ3BCLEdBQUcsQ0FBQzdMLE1BQUosQ0FBV21ELENBQVgsQ0FBYyxDQUFkLENBQUQsQ0FBbUIsRUFBbkIsQ0FBbkIsQ0FDRCxDQUNELE1BQU91SyxPQUFNLENBQUlpQixDQUFDLENBQUdGLE1BQVIsQ0FBa0JDLEdBQS9CLENBQ0QsQ0FqQkQsQ0FtQkE7Ozs7Ozs7O0dBU0FoSyxJQUFJLENBQUNrSCxNQUFMLENBQVlHLE1BQVosQ0FBbUJHLE1BQW5CLENBQTRCLFNBQVNPLEtBQVQsQ0FBZ0JlLE9BQWhCLENBQXlCLENBQ25ELEdBQUlDLEtBQUksQ0FBRyxFQUFYLENBQ0EsR0FBSUMsT0FBTSxDQUFHLEVBQWIsQ0FDQSxHQUFJQyxLQUFKLENBQVVDLElBQVYsQ0FBZ0JDLElBQWhCLENBQ0EsR0FBSTFLLEVBQUMsQ0FBRyxDQUFSLENBQ0EsTUFBTUEsQ0FBQyxDQUFHc0osS0FBSyxDQUFDdEYsVUFBaEIsQ0FBNEIsQ0FDMUJ3RyxJQUFJLENBQUdsQixLQUFLLENBQUN0SixDQUFDLEVBQUYsQ0FBWixDQUNBeUssSUFBSSxDQUFHbkIsS0FBSyxDQUFDdEosQ0FBQyxFQUFGLENBQVosQ0FDQTBLLElBQUksQ0FBR3BCLEtBQUssQ0FBQ3RKLENBQUMsRUFBRixDQUFaLENBRUE7QUFDQXNLLElBQUksRUFBSUwsT0FBTyxDQUFDVSxNQUFSLENBQWVILElBQUksRUFBSSxDQUF2QixDQUFSLENBQ0FGLElBQUksRUFBSUwsT0FBTyxDQUFDVSxNQUFSLENBQWdCLENBQUNILElBQUksQ0FBRyxDQUFSLEdBQWMsQ0FBZixDQUFxQkMsSUFBSSxFQUFJLENBQTVDLENBQVIsQ0FDQSxHQUFHRyxLQUFLLENBQUNILElBQUQsQ0FBUixDQUFnQixDQUNkSCxJQUFJLEVBQUksSUFBUixDQUNELENBRkQsSUFFTyxDQUNMQSxJQUFJLEVBQUlMLE9BQU8sQ0FBQ1UsTUFBUixDQUFnQixDQUFDRixJQUFJLENBQUcsRUFBUixHQUFlLENBQWhCLENBQXNCQyxJQUFJLEVBQUksQ0FBN0MsQ0FBUixDQUNBSixJQUFJLEVBQUlNLEtBQUssQ0FBQ0YsSUFBRCxDQUFMLENBQWMsR0FBZCxDQUFvQlQsT0FBTyxDQUFDVSxNQUFSLENBQWVELElBQUksQ0FBRyxFQUF0QixDQUE1QixDQUNELENBRUQsR0FBR0wsT0FBTyxFQUFJQyxJQUFJLENBQUN4VSxNQUFMLENBQWN1VSxPQUE1QixDQUFxQyxDQUNuQ0UsTUFBTSxFQUFJRCxJQUFJLENBQUN6TixNQUFMLENBQVksQ0FBWixDQUFld04sT0FBZixFQUEwQixNQUFwQyxDQUNBQyxJQUFJLENBQUdBLElBQUksQ0FBQ3pOLE1BQUwsQ0FBWXdOLE9BQVosQ0FBUCxDQUNELENBQ0YsQ0FDREUsTUFBTSxFQUFJRCxJQUFWLENBQ0EsTUFBT0MsT0FBUCxDQUNELENBM0JELENBNkJBOzs7Ozs7Ozs7R0FVQWhKLElBQUksQ0FBQ2tILE1BQUwsQ0FBWUcsTUFBWixDQUFtQkQsTUFBbkIsQ0FBNEIsU0FBU1csS0FBVCxDQUFnQmlCLE1BQWhCLENBQXdCZSxNQUF4QixDQUFnQyxDQUMxRCxHQUFJQyxJQUFHLENBQUdoQixNQUFWLENBQ0EsR0FBRyxDQUFDZ0IsR0FBSixDQUFTLENBQ1BBLEdBQUcsQ0FBRyxHQUFJL0csV0FBSixDQUFlOUgsSUFBSSxDQUFDOEwsSUFBTCxDQUFVYyxLQUFLLENBQUN4VCxNQUFOLENBQWUsQ0FBekIsRUFBOEIsQ0FBN0MsQ0FBTixDQUNELENBRUQ7QUFDQXdULEtBQUssQ0FBR0EsS0FBSyxDQUFDcFQsT0FBTixDQUFjLHFCQUFkLENBQXFDLEVBQXJDLENBQVIsQ0FFQW9WLE1BQU0sQ0FBR0EsTUFBTSxFQUFJLENBQW5CLENBQ0EsR0FBSVIsS0FBSixDQUFVQyxJQUFWLENBQWdCQyxJQUFoQixDQUFzQkMsSUFBdEIsQ0FDQSxHQUFJakwsRUFBQyxDQUFHLENBQVIsQ0FBV3dMLENBQUMsQ0FBR0YsTUFBZixDQUVBLE1BQU10TCxDQUFDLENBQUdzSixLQUFLLENBQUN4VCxNQUFoQixDQUF3QixDQUN0QmdWLElBQUksQ0FBR1osVUFBVSxDQUFDWixLQUFLLENBQUNwRCxVQUFOLENBQWlCbEcsQ0FBQyxFQUFsQixFQUF3QixFQUF6QixDQUFqQixDQUNBK0ssSUFBSSxDQUFHYixVQUFVLENBQUNaLEtBQUssQ0FBQ3BELFVBQU4sQ0FBaUJsRyxDQUFDLEVBQWxCLEVBQXdCLEVBQXpCLENBQWpCLENBQ0FnTCxJQUFJLENBQUdkLFVBQVUsQ0FBQ1osS0FBSyxDQUFDcEQsVUFBTixDQUFpQmxHLENBQUMsRUFBbEIsRUFBd0IsRUFBekIsQ0FBakIsQ0FDQWlMLElBQUksQ0FBR2YsVUFBVSxDQUFDWixLQUFLLENBQUNwRCxVQUFOLENBQWlCbEcsQ0FBQyxFQUFsQixFQUF3QixFQUF6QixDQUFqQixDQUVBdUwsR0FBRyxDQUFDQyxDQUFDLEVBQUYsQ0FBSCxDQUFZVixJQUFJLEVBQUksQ0FBVCxDQUFlQyxJQUFJLEVBQUksQ0FBbEMsQ0FDQSxHQUFHQyxJQUFJLEdBQUssRUFBWixDQUFnQixDQUNkO0FBQ0FPLEdBQUcsQ0FBQ0MsQ0FBQyxFQUFGLENBQUgsQ0FBWSxDQUFDVCxJQUFJLENBQUcsRUFBUixHQUFlLENBQWhCLENBQXNCQyxJQUFJLEVBQUksQ0FBekMsQ0FDQSxHQUFHQyxJQUFJLEdBQUssRUFBWixDQUFnQixDQUNkO0FBQ0FNLEdBQUcsQ0FBQ0MsQ0FBQyxFQUFGLENBQUgsQ0FBWSxDQUFDUixJQUFJLENBQUcsQ0FBUixHQUFjLENBQWYsQ0FBb0JDLElBQS9CLENBQ0QsQ0FDRixDQUNGLENBRUQ7QUFDQSxNQUFPVixPQUFNLENBQUlpQixDQUFDLENBQUdGLE1BQVIsQ0FBa0JDLEdBQUcsQ0FBQ0UsUUFBSixDQUFhLENBQWIsQ0FBZ0JELENBQWhCLENBQS9CLENBQ0QsQ0FoQ0QsQ0FrQ0E7QUFDQWpLLElBQUksQ0FBQ2tILE1BQUwsQ0FBWTRDLE1BQVosQ0FBbUJ0QyxNQUFuQixDQUE0QixTQUFTTyxLQUFULENBQWdCZSxPQUFoQixDQUF5QixDQUNuRCxNQUFPOUksS0FBSSxDQUFDa0gsTUFBTCxDQUFZbkgsS0FBWixDQUFrQnlILE1BQWxCLENBQXlCTyxLQUF6QixDQUFnQ2EsT0FBaEMsQ0FBeUNFLE9BQXpDLENBQVAsQ0FDRCxDQUZELENBR0E5SSxJQUFJLENBQUNrSCxNQUFMLENBQVk0QyxNQUFaLENBQW1CMUMsTUFBbkIsQ0FBNEIsU0FBU1csS0FBVCxDQUFnQmUsT0FBaEIsQ0FBeUIsQ0FDbkQsTUFBTzlJLEtBQUksQ0FBQ2tILE1BQUwsQ0FBWW5ILEtBQVosQ0FBa0JxSCxNQUFsQixDQUF5QlcsS0FBekIsQ0FBZ0NhLE9BQWhDLENBQXlDRSxPQUF6QyxDQUFQLENBQ0QsQ0FGRCxDQUlBO0FBQ0E7QUFDQTlJLElBQUksQ0FBQzdELElBQUwsQ0FBWSxDQUNWMkwsSUFBSSxDQUFFLEVBREksQ0FFVlAsS0FBSyxDQUFFLEVBRkcsQ0FBWixDQUtBOzs7Ozs7Ozs7R0FVQXZILElBQUksQ0FBQzdELElBQUwsQ0FBVTJMLElBQVYsQ0FBZU4sTUFBZixDQUF3QixTQUFTMUQsR0FBVCxDQUFja0YsTUFBZCxDQUFzQmUsTUFBdEIsQ0FBOEIsQ0FDcERqRyxHQUFHLENBQUc5RCxJQUFJLENBQUMrRCxVQUFMLENBQWdCRCxHQUFoQixDQUFOLENBQ0EsR0FBSWtHLElBQUcsQ0FBR2hCLE1BQVYsQ0FDQSxHQUFHLENBQUNnQixHQUFKLENBQVMsQ0FDUEEsR0FBRyxDQUFHLEdBQUkvRyxXQUFKLENBQWVhLEdBQUcsQ0FBQ3ZQLE1BQW5CLENBQU4sQ0FDRCxDQUNEd1YsTUFBTSxDQUFHQSxNQUFNLEVBQUksQ0FBbkIsQ0FDQSxHQUFJRSxFQUFDLENBQUdGLE1BQVIsQ0FDQSxJQUFJLEdBQUl0TCxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdxRixHQUFHLENBQUN2UCxNQUF2QixDQUErQixFQUFFa0ssQ0FBakMsQ0FBb0MsQ0FDbEN1TCxHQUFHLENBQUNDLENBQUMsRUFBRixDQUFILENBQVduRyxHQUFHLENBQUNhLFVBQUosQ0FBZWxHLENBQWYsQ0FBWCxDQUNELENBQ0QsTUFBT3VLLE9BQU0sQ0FBSWlCLENBQUMsQ0FBR0YsTUFBUixDQUFrQkMsR0FBL0IsQ0FDRCxDQVpELENBY0E7Ozs7OztHQU9BaEssSUFBSSxDQUFDN0QsSUFBTCxDQUFVMkwsSUFBVixDQUFlVixNQUFmLENBQXdCLFNBQVN4RCxLQUFULENBQWdCLENBQ3RDLE1BQU81RCxLQUFJLENBQUNpRyxVQUFMLENBQWdCL0MsTUFBTSxDQUFDQyxZQUFQLENBQW9COUMsS0FBcEIsQ0FBMEIsSUFBMUIsQ0FBZ0N1RCxLQUFoQyxDQUFoQixDQUFQLENBQ0QsQ0FGRCxDQUlBOzs7Ozs7Ozs7R0FVQTVELElBQUksQ0FBQzdELElBQUwsQ0FBVW9MLEtBQVYsQ0FBZ0JDLE1BQWhCLENBQXlCLFNBQVMxRCxHQUFULENBQWNrRixNQUFkLENBQXNCZSxNQUF0QixDQUE4QixDQUNyRCxHQUFJQyxJQUFHLENBQUdoQixNQUFWLENBQ0EsR0FBRyxDQUFDZ0IsR0FBSixDQUFTLENBQ1BBLEdBQUcsQ0FBRyxHQUFJL0csV0FBSixDQUFlYSxHQUFHLENBQUN2UCxNQUFKLENBQWEsQ0FBNUIsQ0FBTixDQUNELENBQ0QsR0FBSXlTLEtBQUksQ0FBRyxHQUFJTSxZQUFKLENBQWdCMEMsR0FBRyxDQUFDeEgsTUFBcEIsQ0FBWCxDQUNBdUgsTUFBTSxDQUFHQSxNQUFNLEVBQUksQ0FBbkIsQ0FDQSxHQUFJRSxFQUFDLENBQUdGLE1BQVIsQ0FDQSxHQUFJaFAsRUFBQyxDQUFHZ1AsTUFBUixDQUNBLElBQUksR0FBSXRMLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3FGLEdBQUcsQ0FBQ3ZQLE1BQXZCLENBQStCLEVBQUVrSyxDQUFqQyxDQUFvQyxDQUNsQ3VJLElBQUksQ0FBQ2pNLENBQUMsRUFBRixDQUFKLENBQVkrSSxHQUFHLENBQUNhLFVBQUosQ0FBZWxHLENBQWYsQ0FBWixDQUNBd0wsQ0FBQyxFQUFJLENBQUwsQ0FDRCxDQUNELE1BQU9qQixPQUFNLENBQUlpQixDQUFDLENBQUdGLE1BQVIsQ0FBa0JDLEdBQS9CLENBQ0QsQ0FkRCxDQWdCQTs7Ozs7O0dBT0FoSyxJQUFJLENBQUM3RCxJQUFMLENBQVVvTCxLQUFWLENBQWdCSCxNQUFoQixDQUF5QixTQUFTeEQsS0FBVCxDQUFnQixDQUN2QyxNQUFPVixPQUFNLENBQUNDLFlBQVAsQ0FBb0I5QyxLQUFwQixDQUEwQixJQUExQixDQUFnQyxHQUFJaUgsWUFBSixDQUFnQjFELEtBQUssQ0FBQ3BCLE1BQXRCLENBQWhDLENBQVAsQ0FDRCxDQUZELENBSUE7Ozs7Ozs7OztHQVVBeEMsSUFBSSxDQUFDbUssT0FBTCxDQUFlLFNBQVNsVyxHQUFULENBQWMyUCxLQUFkLENBQXFCeEssR0FBckIsQ0FBMEIsQ0FDdkN3SyxLQUFLLENBQUc1RCxJQUFJLENBQUNzSixRQUFMLENBQWNyVixHQUFHLENBQUNrVyxPQUFKLENBQVluSyxJQUFJLENBQUM2SSxRQUFMLENBQWNqRixLQUFkLENBQVosRUFBa0NpQixJQUFoRCxDQUFSLENBRUE7QUFDQSxHQUFHekwsR0FBSCxDQUFRLENBQ047QUFDQTtBQUNBO0FBQ0EsR0FBSWdSLE1BQUssQ0FBRyxDQUFaLENBQ0EsR0FBSUMsSUFBRyxDQUFHekcsS0FBSyxDQUFDZSxVQUFOLENBQWlCLENBQWpCLENBQVYsQ0FDQSxHQUFHMEYsR0FBRyxDQUFHLElBQVQsQ0FBZSxDQUNiRCxLQUFLLENBQUcsQ0FBUixDQUNELENBQ0Q7QUFDQXhHLEtBQUssQ0FBR0EsS0FBSyxDQUFDMEcsU0FBTixDQUFnQkYsS0FBaEIsQ0FBdUJ4RyxLQUFLLENBQUNyUCxNQUFOLENBQWUsQ0FBdEMsQ0FBUixDQUNELENBRUQsTUFBT3FQLE1BQVAsQ0FDRCxDQWxCRCxDQW9CQTs7Ozs7Ozs7O0dBVUE1RCxJQUFJLENBQUN1SyxPQUFMLENBQWUsU0FBU3RXLEdBQVQsQ0FBYzJQLEtBQWQsQ0FBcUJ4SyxHQUFyQixDQUEwQixDQUN2QztBQUNBLEdBQUl5TCxLQUFJLENBQUc1USxHQUFHLENBQUNzVyxPQUFKLENBQVl2SyxJQUFJLENBQUM2SSxRQUFMLENBQWNqRixLQUFkLENBQVosRUFBa0NpQixJQUE3QyxDQUNBLE1BQVFBLEtBQUksR0FBSyxJQUFWLENBQWtCLElBQWxCLENBQXlCN0UsSUFBSSxDQUFDc0osUUFBTCxDQUFjekUsSUFBZCxDQUFoQyxDQUNELENBSkQsQ0FNQTs7Ozs7O0dBT0EsR0FBSTJGLGtCQUFpQixDQUFHLFFBQXBCQSxrQkFBb0IsQ0FBU3ZXLEdBQVQsQ0FBY3dXLEVBQWQsQ0FBa0JDLEdBQWxCLENBQXVCLENBQzdDLEdBQUcsQ0FBQ3pXLEdBQUosQ0FBUyxDQUNQLEtBQU0sSUFBSUksTUFBSixDQUFVLDJCQUFWLENBQU4sQ0FDRCxDQUVELEdBQUl3USxLQUFKLENBQ0EsR0FBRzZGLEdBQUcsR0FBSyxJQUFYLENBQWlCLENBQ2Y3RixJQUFJLENBQUc1USxHQUFHLENBQUNzSCxVQUFKLENBQWVrUCxFQUFmLENBQVAsQ0FDRCxDQUZELElBRU8sQ0FDTDtBQUNBQyxHQUFHLENBQUcxSyxJQUFJLENBQUM2SSxRQUFMLENBQWM5VCxJQUFJLENBQUNRLFNBQUwsQ0FBZW1WLEdBQWYsQ0FBZCxDQUFOLENBQ0E3RixJQUFJLENBQUc1USxHQUFHLENBQUN1QixPQUFKLENBQVlpVixFQUFaLENBQWdCQyxHQUFoQixDQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUcsTUFBTzdGLEtBQVAsR0FBaUIsV0FBakIsRUFBZ0NBLElBQUksQ0FBQ0EsSUFBTCxHQUFjLElBQWpELENBQXVELENBQ3JELEdBQUl0TyxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVXdRLElBQUksQ0FBQ3RPLEtBQUwsQ0FBV3lDLE9BQXJCLENBQVosQ0FDQXpDLEtBQUssQ0FBQ2tVLEVBQU4sQ0FBVzVGLElBQUksQ0FBQ3RPLEtBQUwsQ0FBV2tVLEVBQXRCLENBQ0FsVSxLQUFLLENBQUMwRSxJQUFOLENBQWE0SixJQUFJLENBQUN0TyxLQUFMLENBQVcwRSxJQUF4QixDQUNBLEtBQU0xRSxNQUFOLENBQ0QsQ0FDRixDQXJCRCxDQXVCQTs7Ozs7OztHQVFBLEdBQUlvVSxrQkFBaUIsQ0FBRyxRQUFwQkEsa0JBQW9CLENBQVMxVyxHQUFULENBQWN3VyxFQUFkLENBQWtCLENBQ3hDLEdBQUcsQ0FBQ3hXLEdBQUosQ0FBUyxDQUNQLEtBQU0sSUFBSUksTUFBSixDQUFVLDJCQUFWLENBQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSXdRLEtBQUksQ0FBRzVRLEdBQUcsQ0FBQ2lCLE9BQUosQ0FBWXVWLEVBQVosQ0FBWCxDQUVBOzs7cUNBUndDLENBYXhDO0FBQ0EsR0FBR3hXLEdBQUcsQ0FBQ0csSUFBUCxDQUFhLENBQ1gsR0FBR3lRLElBQUksQ0FBQ0EsSUFBTCxHQUFjLElBQWpCLENBQXVCLENBQ3JCLEdBQUdBLElBQUksQ0FBQ3RPLEtBQVIsQ0FBZSxDQUNiLEdBQUlBLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVd1EsSUFBSSxDQUFDdE8sS0FBTCxDQUFXeUMsT0FBckIsQ0FBWixDQUNBekMsS0FBSyxDQUFDa1UsRUFBTixDQUFXNUYsSUFBSSxDQUFDdE8sS0FBTCxDQUFXa1UsRUFBdEIsQ0FDQWxVLEtBQUssQ0FBQzBFLElBQU4sQ0FBYTRKLElBQUksQ0FBQ3RPLEtBQUwsQ0FBVzBFLElBQXhCLENBQ0EsS0FBTTFFLE1BQU4sQ0FDRCxDQUNEO0FBQ0FzTyxJQUFJLENBQUcsSUFBUCxDQUNELENBVEQsSUFTTyxDQUNMQSxJQUFJLENBQUdBLElBQUksQ0FBQ0EsSUFBWixDQUNELENBQ0YsQ0FFRDtBQUNBLEdBQUdBLElBQUksR0FBSyxJQUFaLENBQWtCLENBQ2hCO0FBQ0FBLElBQUksQ0FBRzlQLElBQUksQ0FBQ0MsS0FBTCxDQUFXZ0wsSUFBSSxDQUFDc0osUUFBTCxDQUFjekUsSUFBZCxDQUFYLENBQVAsQ0FDRCxDQUVELE1BQU9BLEtBQVAsQ0FDRCxDQXBDRCxDQXNDQTs7Ozs7OztHQVFBLEdBQUkrRixTQUFRLENBQUcsUUFBWEEsU0FBVyxDQUFTM1csR0FBVCxDQUFjd1csRUFBZCxDQUFrQm5VLEdBQWxCLENBQXVCSCxJQUF2QixDQUE2QixDQUMxQztBQUNBLEdBQUl1VSxJQUFHLENBQUdDLGlCQUFpQixDQUFDMVcsR0FBRCxDQUFNd1csRUFBTixDQUEzQixDQUNBLEdBQUdDLEdBQUcsR0FBSyxJQUFYLENBQWlCLENBQ2Y7QUFDQUEsR0FBRyxDQUFHLEVBQU4sQ0FDRCxDQUNEO0FBQ0FBLEdBQUcsQ0FBQ3BVLEdBQUQsQ0FBSCxDQUFXSCxJQUFYLENBRUE7QUFDQXFVLGlCQUFpQixDQUFDdlcsR0FBRCxDQUFNd1csRUFBTixDQUFVQyxHQUFWLENBQWpCLENBQ0QsQ0FaRCxDQWNBOzs7Ozs7OztHQVNBLEdBQUlHLFNBQVEsQ0FBRyxRQUFYQSxTQUFXLENBQVM1VyxHQUFULENBQWN3VyxFQUFkLENBQWtCblUsR0FBbEIsQ0FBdUIsQ0FDcEM7QUFDQSxHQUFJdU8sS0FBSSxDQUFHOEYsaUJBQWlCLENBQUMxVyxHQUFELENBQU13VyxFQUFOLENBQTVCLENBQ0EsR0FBRzVGLElBQUksR0FBSyxJQUFaLENBQWtCLENBQ2hCO0FBQ0FBLElBQUksQ0FBSXZPLEdBQUcsR0FBSXVPLEtBQVIsQ0FBZ0JBLElBQUksQ0FBQ3ZPLEdBQUQsQ0FBcEIsQ0FBNEIsSUFBbkMsQ0FDRCxDQUVELE1BQU91TyxLQUFQLENBQ0QsQ0FURCxDQVdBOzs7Ozs7R0FPQSxHQUFJaUcsWUFBVyxDQUFHLFFBQWRBLFlBQWMsQ0FBUzdXLEdBQVQsQ0FBY3dXLEVBQWQsQ0FBa0JuVSxHQUFsQixDQUF1QixDQUN2QztBQUNBLEdBQUlvVSxJQUFHLENBQUdDLGlCQUFpQixDQUFDMVcsR0FBRCxDQUFNd1csRUFBTixDQUEzQixDQUNBLEdBQUdDLEdBQUcsR0FBSyxJQUFSLEVBQWdCcFUsR0FBRyxHQUFJb1UsSUFBMUIsQ0FBK0IsQ0FDN0I7QUFDQSxNQUFPQSxJQUFHLENBQUNwVSxHQUFELENBQVYsQ0FFQTtBQUNBLEdBQUl5VSxNQUFLLENBQUcsSUFBWixDQUNBLElBQUksR0FBSTFULEtBQVIsR0FBZ0JxVCxJQUFoQixDQUFxQixDQUNuQkssS0FBSyxDQUFHLEtBQVIsQ0FDQSxNQUNELENBQ0QsR0FBR0EsS0FBSCxDQUFVLENBQ1I7QUFDQUwsR0FBRyxDQUFHLElBQU4sQ0FDRCxDQUVEO0FBQ0FGLGlCQUFpQixDQUFDdlcsR0FBRCxDQUFNd1csRUFBTixDQUFVQyxHQUFWLENBQWpCLENBQ0QsQ0FDRixDQXJCRCxDQXVCQTs7Ozs7R0FNQSxHQUFJTSxZQUFXLENBQUcsUUFBZEEsWUFBYyxDQUFTL1csR0FBVCxDQUFjd1csRUFBZCxDQUFrQixDQUNsQ0QsaUJBQWlCLENBQUN2VyxHQUFELENBQU13VyxFQUFOLENBQVUsSUFBVixDQUFqQixDQUNELENBRkQsQ0FJQTs7Ozs7Ozs7R0FTQSxHQUFJUSxxQkFBb0IsQ0FBRyxRQUF2QkEscUJBQXVCLENBQVNDLElBQVQsQ0FBZUMsSUFBZixDQUFxQmxWLFFBQXJCLENBQStCLENBQ3hELEdBQUk0TyxLQUFJLENBQUcsSUFBWCxDQUVBO0FBQ0EsR0FBRyxNQUFPNU8sU0FBUCxHQUFxQixXQUF4QixDQUFxQyxDQUNuQ0EsUUFBUSxDQUFHLENBQUMsS0FBRCxDQUFRLE9BQVIsQ0FBWCxDQUNELENBRUQ7QUFDQSxHQUFJbVYsS0FBSixDQUNBLEdBQUlDLEtBQUksQ0FBRyxLQUFYLENBQ0EsR0FBSUMsVUFBUyxDQUFHLElBQWhCLENBQ0EsSUFBSSxHQUFJQyxJQUFSLEdBQWV0VixTQUFmLENBQXlCLENBQ3ZCbVYsSUFBSSxDQUFHblYsUUFBUSxDQUFDc1YsR0FBRCxDQUFmLENBQ0EsR0FBSSxDQUNGLEdBQUdILElBQUksR0FBSyxPQUFULEVBQW9CQSxJQUFJLEdBQUssTUFBaEMsQ0FBd0MsQ0FDdEMsR0FBR0QsSUFBSSxDQUFDLENBQUQsQ0FBSixHQUFZLElBQWYsQ0FBcUIsQ0FDbkIsS0FBTSxJQUFJOVcsTUFBSixDQUFVLG9DQUFWLENBQU4sQ0FDRCxDQUNEd1EsSUFBSSxDQUFHcUcsSUFBSSxDQUFDN0ssS0FBTCxDQUFXLElBQVgsQ0FBaUI4SyxJQUFqQixDQUFQLENBQ0FFLElBQUksQ0FBSUQsSUFBSSxHQUFLLE9BQWpCLENBQ0QsQ0FDRCxHQUFHQSxJQUFJLEdBQUssS0FBVCxFQUFrQkEsSUFBSSxHQUFLLE1BQTlCLENBQXNDLENBQ3BDRCxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVVsVyxZQUFWLENBQ0E0UCxJQUFJLENBQUdxRyxJQUFJLENBQUM3SyxLQUFMLENBQVcsSUFBWCxDQUFpQjhLLElBQWpCLENBQVAsQ0FDQUUsSUFBSSxDQUFHLElBQVAsQ0FDRCxDQUNGLENBQUMsTUFBTUcsRUFBTixDQUFVLENBQ1ZGLFNBQVMsQ0FBR0UsRUFBWixDQUNELENBQ0QsR0FBR0gsSUFBSCxDQUFTLENBQ1AsTUFDRCxDQUNGLENBRUQsR0FBRyxDQUFDQSxJQUFKLENBQVUsQ0FDUixLQUFNQyxVQUFOLENBQ0QsQ0FFRCxNQUFPekcsS0FBUCxDQUNELENBeENELENBMENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0QkE3RSxJQUFJLENBQUN4SyxPQUFMLENBQWUsU0FBU3ZCLEdBQVQsQ0FBY3dXLEVBQWQsQ0FBa0JuVSxHQUFsQixDQUF1QkgsSUFBdkIsQ0FBNkJGLFFBQTdCLENBQXVDLENBQ3BEZ1Ysb0JBQW9CLENBQUNMLFFBQUQsQ0FBV3JLLFNBQVgsQ0FBc0J0SyxRQUF0QixDQUFwQixDQUNELENBRkQsQ0FJQTs7Ozs7Ozs7Ozs7R0FZQStKLElBQUksQ0FBQzlLLE9BQUwsQ0FBZSxTQUFTakIsR0FBVCxDQUFjd1csRUFBZCxDQUFrQm5VLEdBQWxCLENBQXVCTCxRQUF2QixDQUFpQyxDQUM5QyxNQUFPZ1YscUJBQW9CLENBQUNKLFFBQUQsQ0FBV3RLLFNBQVgsQ0FBc0J0SyxRQUF0QixDQUEzQixDQUNELENBRkQsQ0FJQTs7Ozs7Ozs7O0dBVUErSixJQUFJLENBQUN6RSxVQUFMLENBQWtCLFNBQVN0SCxHQUFULENBQWN3VyxFQUFkLENBQWtCblUsR0FBbEIsQ0FBdUJMLFFBQXZCLENBQWlDLENBQ2pEZ1Ysb0JBQW9CLENBQUNILFdBQUQsQ0FBY3ZLLFNBQWQsQ0FBeUJ0SyxRQUF6QixDQUFwQixDQUNELENBRkQsQ0FJQTs7Ozs7Ozs7R0FTQStKLElBQUksQ0FBQ3lMLFVBQUwsQ0FBa0IsU0FBU3hYLEdBQVQsQ0FBY3dXLEVBQWQsQ0FBa0J4VSxRQUFsQixDQUE0QixDQUM1Q2dWLG9CQUFvQixDQUFDRCxXQUFELENBQWN6SyxTQUFkLENBQXlCdEssUUFBekIsQ0FBcEIsQ0FDRCxDQUZELENBSUE7Ozs7OztHQU9BK0osSUFBSSxDQUFDMEwsUUFBTCxDQUFnQixTQUFTNUgsR0FBVCxDQUFjLENBQzVCO0FBQ0EsR0FBSTZILE1BQUssQ0FBRyx3Q0FBWixDQUNBQSxLQUFLLENBQUNDLFNBQU4sQ0FBa0IsQ0FBbEIsQ0FDQSxHQUFJaE4sRUFBQyxDQUFHK00sS0FBSyxDQUFDRSxJQUFOLENBQVcvSCxHQUFYLENBQVIsQ0FDQSxHQUFJckksSUFBRyxDQUFJbUQsQ0FBQyxHQUFLLElBQVAsQ0FBZSxJQUFmLENBQXNCLENBQzlCa04sSUFBSSxDQUFFaEksR0FEd0IsQ0FFOUJpSSxNQUFNLENBQUVuTixDQUFDLENBQUMsQ0FBRCxDQUZxQixDQUc5Qm9OLElBQUksQ0FBRXBOLENBQUMsQ0FBQyxDQUFELENBSHVCLENBSTlCcU4sSUFBSSxDQUFFck4sQ0FBQyxDQUFDLENBQUQsQ0FKdUIsQ0FLOUJzTixJQUFJLENBQUV0TixDQUFDLENBQUMsQ0FBRCxDQUx1QixDQUFoQyxDQU9BLEdBQUduRCxHQUFILENBQVEsQ0FDTkEsR0FBRyxDQUFDMFEsUUFBSixDQUFlMVEsR0FBRyxDQUFDdVEsSUFBbkIsQ0FDQSxHQUFHdlEsR0FBRyxDQUFDd1EsSUFBUCxDQUFhLENBQ1gsR0FBR3hRLEdBQUcsQ0FBQ3dRLElBQUosR0FBYSxFQUFiLEVBQW1CeFEsR0FBRyxDQUFDc1EsTUFBSixHQUFlLE1BQXJDLENBQTZDLENBQzNDdFEsR0FBRyxDQUFDMFEsUUFBSixFQUFnQixJQUFNMVEsR0FBRyxDQUFDd1EsSUFBMUIsQ0FDRCxDQUZELElBRU8sSUFBR3hRLEdBQUcsQ0FBQ3dRLElBQUosR0FBYSxHQUFiLEVBQW9CeFEsR0FBRyxDQUFDc1EsTUFBSixHQUFlLE9BQXRDLENBQStDLENBQ3BEdFEsR0FBRyxDQUFDMFEsUUFBSixFQUFnQixJQUFNMVEsR0FBRyxDQUFDd1EsSUFBMUIsQ0FDRCxDQUNGLENBTkQsSUFNTyxJQUFHeFEsR0FBRyxDQUFDc1EsTUFBSixHQUFlLE1BQWxCLENBQTBCLENBQy9CdFEsR0FBRyxDQUFDd1EsSUFBSixDQUFXLEVBQVgsQ0FDRCxDQUZNLElBRUEsSUFBR3hRLEdBQUcsQ0FBQ3NRLE1BQUosR0FBZSxPQUFsQixDQUEyQixDQUNoQ3RRLEdBQUcsQ0FBQ3dRLElBQUosQ0FBVyxHQUFYLENBQ0QsQ0FDRHhRLEdBQUcsQ0FBQ3FRLElBQUosQ0FBV3JRLEdBQUcsQ0FBQ3NRLE1BQUosQ0FBYSxLQUFiLENBQXFCdFEsR0FBRyxDQUFDMFEsUUFBcEMsQ0FDRCxDQUNELE1BQU8xUSxJQUFQLENBQ0QsQ0E1QkQsQ0E4QkEsaUNBQ0EsR0FBSTJRLGdCQUFlLENBQUcsSUFBdEIsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1Q0FwTSxJQUFJLENBQUNxTSxpQkFBTCxDQUF5QixTQUFTQyxLQUFULENBQWdCLENBQ3ZDLEdBQUl0WCxNQUFLLENBQUcsUUFBUkEsTUFBUSxDQUFTdVgsQ0FBVCxDQUFZLENBQ3RCLEdBQUkxSCxLQUFJLENBQUcsRUFBWCxDQUNBLEdBQUkySCxRQUFPLENBQUdELENBQUMsQ0FBQzdVLEtBQUYsQ0FBUSxHQUFSLENBQWQsQ0FDQSxJQUFJLEdBQUkrRyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcrTixPQUFPLENBQUNqWSxNQUEzQixDQUFtQ2tLLENBQUMsRUFBcEMsQ0FBd0MsQ0FDdEMsR0FBSWdPLElBQUcsQ0FBR0QsT0FBTyxDQUFDL04sQ0FBRCxDQUFQLENBQVdpTyxPQUFYLENBQW1CLEdBQW5CLENBQVYsQ0FDQSxHQUFJcFcsSUFBSixDQUNBLEdBQUlxVyxJQUFKLENBQ0EsR0FBR0YsR0FBRyxDQUFHLENBQVQsQ0FBWSxDQUNWblcsR0FBRyxDQUFHa1csT0FBTyxDQUFDL04sQ0FBRCxDQUFQLENBQVc2TCxTQUFYLENBQXFCLENBQXJCLENBQXdCbUMsR0FBeEIsQ0FBTixDQUNBRSxHQUFHLENBQUdILE9BQU8sQ0FBQy9OLENBQUQsQ0FBUCxDQUFXNkwsU0FBWCxDQUFxQm1DLEdBQUcsQ0FBRyxDQUEzQixDQUFOLENBQ0QsQ0FIRCxJQUdPLENBQ0xuVyxHQUFHLENBQUdrVyxPQUFPLENBQUMvTixDQUFELENBQWIsQ0FDQWtPLEdBQUcsQ0FBRyxJQUFOLENBQ0QsQ0FDRCxHQUFHLEVBQUVyVyxHQUFHLEdBQUl1TyxLQUFULENBQUgsQ0FBbUIsQ0FDakJBLElBQUksQ0FBQ3ZPLEdBQUQsQ0FBSixDQUFZLEVBQVosQ0FDRCxDQUNEO0FBQ0EsR0FBRyxFQUFFQSxHQUFHLEdBQUlzRSxPQUFNLENBQUM4RSxTQUFoQixHQUE4QmlOLEdBQUcsR0FBSyxJQUF6QyxDQUErQyxDQUM3QzlILElBQUksQ0FBQ3ZPLEdBQUQsQ0FBSixDQUFVNkssSUFBVixDQUFld0ksUUFBUSxDQUFDZ0QsR0FBRCxDQUF2QixFQUNELENBQ0YsQ0FDRCxNQUFPOUgsS0FBUCxDQUNELENBdkJELENBeUJDLEdBQUlBLEtBQUosQ0FDQSxHQUFHLE1BQU95SCxNQUFQLEdBQWtCLFdBQXJCLENBQWtDLENBQ2hDO0FBQ0EsR0FBR0YsZUFBZSxHQUFLLElBQXZCLENBQTZCLENBQzNCLEdBQUcsTUFBT3pRLE9BQVAsR0FBbUIsV0FBbkIsRUFBa0NBLE1BQU0sQ0FBQzFGLFFBQXpDLEVBQXFEMEYsTUFBTSxDQUFDMUYsUUFBUCxDQUFnQjJGLE1BQXhFLENBQWdGLENBQzdFO0FBQ0F3USxlQUFlLENBQUdwWCxLQUFLLENBQUMyRyxNQUFNLENBQUMxRixRQUFQLENBQWdCMkYsTUFBaEIsQ0FBdUIwTyxTQUF2QixDQUFpQyxDQUFqQyxDQUFELENBQXZCLENBQ0YsQ0FIRCxJQUdPLENBQ0o7QUFDQThCLGVBQWUsQ0FBRyxFQUFsQixDQUNGLENBQ0YsQ0FDRHZILElBQUksQ0FBR3VILGVBQVAsQ0FDRCxDQVpELElBWU8sQ0FDTDtBQUNBdkgsSUFBSSxDQUFHN1AsS0FBSyxDQUFDc1gsS0FBRCxDQUFaLENBQ0QsQ0FDRCxNQUFPekgsS0FBUCxDQUNGLENBNUNELENBOENBOzs7Ozs7Ozs7OztHQVlBN0UsSUFBSSxDQUFDNE0sYUFBTCxDQUFxQixTQUFTQyxRQUFULENBQW1CLENBQ3RDO0FBQ0EsR0FBSUMsR0FBRSxDQUFHRCxRQUFULENBQ0EsR0FBSUUsR0FBRSxDQUFHLEVBQVQsQ0FDQTtBQUNBLEdBQUlOLElBQUcsQ0FBR0ksUUFBUSxDQUFDSCxPQUFULENBQWlCLEdBQWpCLENBQVYsQ0FDQSxHQUFHRCxHQUFHLENBQUcsQ0FBVCxDQUFZLENBQ1ZLLEVBQUUsQ0FBR0QsUUFBUSxDQUFDdkMsU0FBVCxDQUFtQixDQUFuQixDQUFzQm1DLEdBQXRCLENBQUwsQ0FDQU0sRUFBRSxDQUFHRixRQUFRLENBQUN2QyxTQUFULENBQW1CbUMsR0FBRyxDQUFHLENBQXpCLENBQUwsQ0FDRCxDQUNEO0FBQ0EsR0FBSVAsS0FBSSxDQUFHWSxFQUFFLENBQUNwVixLQUFILENBQVMsR0FBVCxDQUFYLENBQ0EsR0FBR3dVLElBQUksQ0FBQzNYLE1BQUwsQ0FBYyxDQUFkLEVBQW1CMlgsSUFBSSxDQUFDLENBQUQsQ0FBSixHQUFZLEVBQWxDLENBQXNDLENBQ3BDQSxJQUFJLENBQUNjLEtBQUwsR0FDRCxDQUNEO0FBQ0EsR0FBSVYsTUFBSyxDQUFJUyxFQUFFLEdBQUssRUFBUixDQUFjLEVBQWQsQ0FBbUIvTSxJQUFJLENBQUNxTSxpQkFBTCxDQUF1QlUsRUFBdkIsQ0FBL0IsQ0FFQSxNQUFPLENBQ0xFLFVBQVUsQ0FBRUgsRUFEUCxDQUVMSSxXQUFXLENBQUVILEVBRlIsQ0FHTGIsSUFBSSxDQUFFQSxJQUhELENBSUxJLEtBQUssQ0FBRUEsS0FKRixDQUFQLENBTUQsQ0F4QkQsQ0EwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1CQXRNLElBQUksQ0FBQ21OLFdBQUwsQ0FBbUIsU0FBU0MsU0FBVCxDQUFvQixDQUNyQyxHQUFJQyxLQUFJLENBQUdyTixJQUFJLENBQUM0TSxhQUFMLENBQW1CUSxTQUFuQixDQUFYLENBQ0EsR0FBSUUsSUFBRyxDQUFHLENBQ1I7QUFDQXBCLElBQUksQ0FBRW1CLElBQUksQ0FBQ0osVUFGSCxDQUdSO0FBQ0FYLEtBQUssQ0FBRWUsSUFBSSxDQUFDSCxXQUpKLENBS1I7Ozs7OztPQU9BSyxPQUFPLENBQUUsaUJBQVM5TyxDQUFULENBQVksQ0FDbkIsTUFBUSxPQUFPQSxFQUFQLEdBQWMsV0FBZixDQUE4QjRPLElBQUksQ0FBQ25CLElBQW5DLENBQTBDbUIsSUFBSSxDQUFDbkIsSUFBTCxDQUFVek4sQ0FBVixDQUFqRCxDQUNELENBZE8sQ0FlUjs7Ozs7OztPQVFBK08sUUFBUSxDQUFFLGtCQUFTelMsQ0FBVCxDQUFZMEQsQ0FBWixDQUFlLENBQ3ZCLEdBQUlvRyxLQUFKLENBQ0EsR0FBRyxNQUFPOUosRUFBUCxHQUFjLFdBQWpCLENBQThCLENBQzVCOEosSUFBSSxDQUFHd0ksSUFBSSxDQUFDZixLQUFaLENBQ0QsQ0FGRCxJQUVPLENBQ0x6SCxJQUFJLENBQUd3SSxJQUFJLENBQUNmLEtBQUwsQ0FBV3ZSLENBQVgsQ0FBUCxDQUNBLEdBQUc4SixJQUFJLEVBQUksTUFBT3BHLEVBQVAsR0FBYyxXQUF6QixDQUFzQyxDQUNuQ29HLElBQUksQ0FBR0EsSUFBSSxDQUFDcEcsQ0FBRCxDQUFYLENBQ0YsQ0FDRixDQUNELE1BQU9vRyxLQUFQLENBQ0QsQ0FsQ08sQ0FtQ1I0SSxZQUFZLENBQUUsc0JBQVMxUyxDQUFULENBQVkyUyxRQUFaLENBQXNCLENBQ2xDLEdBQUk3SSxLQUFKLENBQ0EsR0FBSThJLEtBQUksQ0FBR0wsR0FBRyxDQUFDRSxRQUFKLENBQWF6UyxDQUFiLENBQVgsQ0FDQSxHQUFHNFMsSUFBSCxDQUFTLENBQ1A5SSxJQUFJLENBQUc4SSxJQUFJLENBQUNBLElBQUksQ0FBQ3BaLE1BQUwsQ0FBYyxDQUFmLENBQVgsQ0FDRCxDQUZELElBRU8sQ0FDTHNRLElBQUksQ0FBRzZJLFFBQVAsQ0FDRCxDQUNELE1BQU83SSxLQUFQLENBQ0QsQ0E1Q08sQ0FBVixDQThDQSxNQUFPeUksSUFBUCxDQUNELENBakRELENBbURBOzs7Ozs7Ozs7O0dBV0F0TixJQUFJLENBQUM0TixRQUFMLENBQWdCLFNBQVMxQixJQUFULENBQWVJLEtBQWYsQ0FBc0JPLFFBQXRCLENBQWdDLENBQzlDO0FBQ0FYLElBQUksQ0FBRzJCLE1BQU0sQ0FBQzFMLE9BQVAsQ0FBZStKLElBQWYsRUFBdUJBLElBQUksQ0FBQ3RYLElBQUwsQ0FBVSxHQUFWLENBQXZCLENBQXdDc1gsSUFBL0MsQ0FFQSxHQUFJNEIsS0FBSSxDQUFHRCxNQUFNLENBQUNFLEtBQVAsQ0FBYXpCLEtBQUssRUFBSSxFQUF0QixDQUFYLENBQ0FPLFFBQVEsQ0FBR0EsUUFBUSxFQUFJLEVBQXZCLENBQ0EsTUFBT1gsS0FBSSxFQUNQNEIsSUFBSSxDQUFDdlosTUFBTCxDQUFjLENBQWYsQ0FBcUIsSUFBTXVaLElBQTNCLENBQW1DLEVBRDNCLENBQUosRUFFSGpCLFFBQVEsQ0FBQ3RZLE1BQVQsQ0FBa0IsQ0FBbkIsQ0FBeUIsSUFBTXNZLFFBQS9CLENBQTJDLEVBRnZDLENBQVAsQ0FHRCxDQVRELENBV0E7Ozs7Ozs7Ozs7R0FXQTdNLElBQUksQ0FBQ2dPLE9BQUwsQ0FBZSxTQUFTeE8sTUFBVCxDQUFpQjNFLElBQWpCLENBQXVCb1QsS0FBdkIsQ0FBOEIsQ0FDM0M7QUFDQSxHQUFHLFFBQU96TyxNQUFQLElBQW1CLFFBQW5CLEVBQStCQSxNQUFNLEdBQUssSUFBN0MsQ0FBbUQsQ0FDakQsR0FBSWYsRUFBQyxDQUFHLENBQVIsQ0FDQSxHQUFJc0gsSUFBRyxDQUFHbEwsSUFBSSxDQUFDdEcsTUFBZixDQUNBLE1BQU1rSyxDQUFDLENBQUdzSCxHQUFWLENBQWUsQ0FDYixHQUFJbUksS0FBSSxDQUFHclQsSUFBSSxDQUFDNEQsQ0FBQyxFQUFGLENBQWYsQ0FDQSxHQUFHQSxDQUFDLEVBQUlzSCxHQUFSLENBQWEsQ0FDWDtBQUNBdkcsTUFBTSxDQUFDME8sSUFBRCxDQUFOLENBQWVELEtBQWYsQ0FDRCxDQUhELElBR08sQ0FDTDtBQUNBLEdBQUlFLFFBQU8sQ0FBSUQsSUFBSSxHQUFJMU8sT0FBdkIsQ0FDQSxHQUFHLENBQUMyTyxPQUFELEVBQ0FBLE9BQU8sRUFBSSxRQUFPM08sTUFBTSxDQUFDME8sSUFBRCxDQUFiLElBQXlCLFFBRHBDLEVBRUFDLE9BQU8sRUFBSTNPLE1BQU0sQ0FBQzBPLElBQUQsQ0FBTixHQUFpQixJQUYvQixDQUVzQyxDQUNwQzFPLE1BQU0sQ0FBQzBPLElBQUQsQ0FBTixDQUFlLEVBQWYsQ0FDRCxDQUNEMU8sTUFBTSxDQUFHQSxNQUFNLENBQUMwTyxJQUFELENBQWYsQ0FDRCxDQUNGLENBQ0YsQ0FDRixDQXRCRCxDQXdCQTs7Ozs7Ozs7Ozs7R0FZQWxPLElBQUksQ0FBQ3VOLE9BQUwsQ0FBZSxTQUFTL04sTUFBVCxDQUFpQjNFLElBQWpCLENBQXVCNlMsUUFBdkIsQ0FBaUMsQ0FDOUMsR0FBSWpQLEVBQUMsQ0FBRyxDQUFSLENBQ0EsR0FBSXNILElBQUcsQ0FBR2xMLElBQUksQ0FBQ3RHLE1BQWYsQ0FDQSxHQUFJNFosUUFBTyxDQUFHLElBQWQsQ0FDQSxNQUFNQSxPQUFPLEVBQUkxUCxDQUFDLENBQUdzSCxHQUFmLEVBQ0osUUFBT3ZHLE1BQVAsSUFBbUIsUUFEZixFQUMyQkEsTUFBTSxHQUFLLElBRDVDLENBQ2tELENBQ2hELEdBQUkwTyxLQUFJLENBQUdyVCxJQUFJLENBQUM0RCxDQUFDLEVBQUYsQ0FBZixDQUNBMFAsT0FBTyxDQUFHRCxJQUFJLEdBQUkxTyxPQUFsQixDQUNBLEdBQUcyTyxPQUFILENBQVksQ0FDVjNPLE1BQU0sQ0FBR0EsTUFBTSxDQUFDME8sSUFBRCxDQUFmLENBQ0QsQ0FDRixDQUNELE1BQVFDLFFBQU8sQ0FBRzNPLE1BQUgsQ0FBWWtPLFFBQTNCLENBQ0QsQ0FiRCxDQWVBOzs7Ozs7O0dBUUExTixJQUFJLENBQUNvTyxVQUFMLENBQWtCLFNBQVM1TyxNQUFULENBQWlCM0UsSUFBakIsQ0FBdUIsQ0FDdkM7QUFDQSxHQUFHLFFBQU8yRSxNQUFQLElBQW1CLFFBQW5CLEVBQStCQSxNQUFNLEdBQUssSUFBN0MsQ0FBbUQsQ0FDakQsR0FBSWYsRUFBQyxDQUFHLENBQVIsQ0FDQSxHQUFJc0gsSUFBRyxDQUFHbEwsSUFBSSxDQUFDdEcsTUFBZixDQUNBLE1BQU1rSyxDQUFDLENBQUdzSCxHQUFWLENBQWUsQ0FDYixHQUFJbUksS0FBSSxDQUFHclQsSUFBSSxDQUFDNEQsQ0FBQyxFQUFGLENBQWYsQ0FDQSxHQUFHQSxDQUFDLEVBQUlzSCxHQUFSLENBQWEsQ0FDWDtBQUNBLE1BQU92RyxPQUFNLENBQUMwTyxJQUFELENBQWIsQ0FDRCxDQUhELElBR08sQ0FDTDtBQUNBLEdBQUcsRUFBRUEsSUFBSSxHQUFJMU8sT0FBVixHQUNBLFFBQU9BLE1BQU0sQ0FBQzBPLElBQUQsQ0FBYixJQUF5QixRQUR6QixFQUVBMU8sTUFBTSxDQUFDME8sSUFBRCxDQUFOLEdBQWlCLElBRnBCLENBRTJCLENBQ3hCLE1BQ0YsQ0FDRDFPLE1BQU0sQ0FBR0EsTUFBTSxDQUFDME8sSUFBRCxDQUFmLENBQ0QsQ0FDRixDQUNGLENBQ0YsQ0FyQkQsQ0F1QkE7Ozs7Ozs7R0FRQWxPLElBQUksQ0FBQ3lELE9BQUwsQ0FBZSxTQUFTaUgsR0FBVCxDQUFjLENBQzNCLElBQUksR0FBSXJULEtBQVIsR0FBZ0JxVCxJQUFoQixDQUFxQixDQUNuQixHQUFHQSxHQUFHLENBQUMvSyxjQUFKLENBQW1CdEksSUFBbkIsQ0FBSCxDQUE2QixDQUMzQixNQUFPLE1BQVAsQ0FDRCxDQUNGLENBQ0QsTUFBTyxLQUFQLENBQ0QsQ0FQRCxDQVNBOzs7Ozs7OztHQVNBMkksSUFBSSxDQUFDcU8sTUFBTCxDQUFjLFNBQVNBLE1BQVQsQ0FBaUIsQ0FDN0IsR0FBSUMsR0FBRSxDQUFHLEtBQVQsQ0FDQTtBQUNBLEdBQUlDLE1BQUosQ0FDQTtBQUNBLEdBQUlDLEtBQUosQ0FDQTtBQUNBLEdBQUlDLEtBQUksQ0FBRyxDQUFYLENBQ0E7QUFDQSxHQUFJQyxNQUFLLENBQUcsRUFBWixDQUNBO0FBQ0EsR0FBSS9JLEtBQUksQ0FBRyxDQUFYLENBQ0E7QUFDQSxNQUFPNEksS0FBSyxDQUFHRCxFQUFFLENBQUN6QyxJQUFILENBQVF3QyxNQUFSLENBQWYsQ0FBaUMsQ0FDL0JHLElBQUksQ0FBR0gsTUFBTSxDQUFDL0QsU0FBUCxDQUFpQjNFLElBQWpCLENBQXVCMkksRUFBRSxDQUFDMUMsU0FBSCxDQUFlLENBQXRDLENBQVAsQ0FDQTtBQUNBLEdBQUc0QyxJQUFJLENBQUNqYSxNQUFMLENBQWMsQ0FBakIsQ0FBb0IsQ0FDbEJtYSxLQUFLLENBQUN2TixJQUFOLENBQVdxTixJQUFYLEVBQ0QsQ0FDRDdJLElBQUksQ0FBRzJJLEVBQUUsQ0FBQzFDLFNBQVYsQ0FDQTtBQUNBLEdBQUkrQyxLQUFJLENBQUdKLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUyxDQUFULENBQVgsQ0FDQSxPQUFPSSxJQUFQLEVBQ0EsSUFBSyxHQUFMLENBQ0EsSUFBSyxHQUFMLENBQ0U7QUFDQSxHQUFHRixJQUFJLENBQUdsTyxTQUFTLENBQUNoTSxNQUFwQixDQUE0QixDQUMxQm1hLEtBQUssQ0FBQ3ZOLElBQU4sQ0FBV1osU0FBUyxDQUFDa08sSUFBSSxJQUFLLENBQVYsQ0FBcEIsRUFDRCxDQUZELElBRU8sQ0FDTEMsS0FBSyxDQUFDdk4sSUFBTixDQUFXLEtBQVgsRUFDRCxDQUNELE1BQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSyxHQUFMLENBQ0V1TixLQUFLLENBQUN2TixJQUFOLENBQVcsR0FBWCxFQUNBLE1BQ0YsUUFDRXVOLEtBQUssQ0FBQ3ZOLElBQU4sQ0FBVyxLQUFPd04sSUFBUCxDQUFjLElBQXpCLEVBakJGLENBbUJELENBQ0Q7QUFDQUQsS0FBSyxDQUFDdk4sSUFBTixDQUFXa04sTUFBTSxDQUFDL0QsU0FBUCxDQUFpQjNFLElBQWpCLENBQVgsRUFDQSxNQUFPK0ksTUFBSyxDQUFDOVosSUFBTixDQUFXLEVBQVgsQ0FBUCxDQUNELENBN0NELENBK0NBOzs7O0dBS0FvTCxJQUFJLENBQUM0TyxZQUFMLENBQW9CLFNBQVNDLE1BQVQsQ0FBaUJDLFFBQWpCLENBQTJCQyxTQUEzQixDQUFzQ0MsYUFBdEMsQ0FBcUQsQ0FDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsR0FBSTVQLEVBQUMsQ0FBR3lQLE1BQVIsQ0FBZ0JoUSxDQUFDLENBQUd3SyxLQUFLLENBQUN5RixRQUFRLENBQUczVCxJQUFJLENBQUM4VCxHQUFMLENBQVNILFFBQVQsQ0FBWixDQUFMLENBQXVDLENBQXZDLENBQTJDQSxRQUEvRCxDQUNBLEdBQUloUSxFQUFDLENBQUdpUSxTQUFTLEdBQUt6TyxTQUFkLENBQTBCLEdBQTFCLENBQWdDeU8sU0FBeEMsQ0FDQSxHQUFJMUcsRUFBQyxDQUFHMkcsYUFBYSxHQUFLMU8sU0FBbEIsQ0FDUCxHQURPLENBQ0QwTyxhQURQLENBQ3NCblAsQ0FBQyxDQUFHVCxDQUFDLENBQUcsQ0FBSixDQUFRLEdBQVIsQ0FBYyxFQUR4QyxDQUVBLEdBQUlYLEVBQUMsQ0FBRzhKLFFBQVEsQ0FBRW5KLENBQUMsQ0FBR2pFLElBQUksQ0FBQzhULEdBQUwsQ0FBUyxDQUFDN1AsQ0FBRCxFQUFNLENBQWYsRUFBa0I4UCxPQUFsQixDQUEwQnJRLENBQTFCLENBQU4sQ0FBcUMsRUFBckMsQ0FBUixDQUFtRCxFQUEzRCxDQUNBLEdBQUlvTCxFQUFDLENBQUl4TCxDQUFDLENBQUNsSyxNQUFGLENBQVcsQ0FBWixDQUFpQmtLLENBQUMsQ0FBQ2xLLE1BQUYsQ0FBVyxDQUE1QixDQUFnQyxDQUF4QyxDQUNBLE1BQU9zTCxFQUFDLEVBQUlvSyxDQUFDLENBQUd4TCxDQUFDLENBQUNuRCxNQUFGLENBQVMsQ0FBVCxDQUFZMk8sQ0FBWixFQUFpQjVCLENBQXBCLENBQXdCLEVBQTdCLENBQUQsQ0FDTDVKLENBQUMsQ0FBQ25ELE1BQUYsQ0FBUzJPLENBQVQsRUFBWXRWLE9BQVosQ0FBb0IsZ0JBQXBCLENBQXNDLEtBQU8wVCxDQUE3QyxDQURLLEVBRUp4SixDQUFDLENBQUdDLENBQUMsQ0FBRzNELElBQUksQ0FBQzhULEdBQUwsQ0FBUzdQLENBQUMsQ0FBR1gsQ0FBYixFQUFnQnlRLE9BQWhCLENBQXdCclEsQ0FBeEIsRUFBMkJvQyxLQUEzQixDQUFpQyxDQUFqQyxDQUFQLENBQTZDLEVBRjFDLENBQVAsQ0FHRCxDQXBCRCxDQXNCQTs7OztHQUtBakIsSUFBSSxDQUFDbVAsVUFBTCxDQUFrQixTQUFTL1osSUFBVCxDQUFlLENBQy9CLEdBQUdBLElBQUksRUFBSSxVQUFYLENBQXVCLENBQ3JCQSxJQUFJLENBQUc0SyxJQUFJLENBQUM0TyxZQUFMLENBQWtCeFosSUFBSSxDQUFHLFVBQXpCLENBQXFDLENBQXJDLENBQXdDLEdBQXhDLENBQTZDLEVBQTdDLEVBQW1ELE1BQTFELENBQ0QsQ0FGRCxJQUVPLElBQUdBLElBQUksRUFBSSxPQUFYLENBQW9CLENBQ3pCQSxJQUFJLENBQUc0SyxJQUFJLENBQUM0TyxZQUFMLENBQWtCeFosSUFBSSxDQUFHLE9BQXpCLENBQWtDLENBQWxDLENBQXFDLEdBQXJDLENBQTBDLEVBQTFDLEVBQWdELE1BQXZELENBQ0QsQ0FGTSxJQUVBLElBQUdBLElBQUksRUFBSSxJQUFYLENBQWlCLENBQ3RCQSxJQUFJLENBQUc0SyxJQUFJLENBQUM0TyxZQUFMLENBQWtCeFosSUFBSSxDQUFHLElBQXpCLENBQStCLENBQS9CLEVBQW9DLE1BQTNDLENBQ0QsQ0FGTSxJQUVBLENBQ0xBLElBQUksQ0FBRzRLLElBQUksQ0FBQzRPLFlBQUwsQ0FBa0J4WixJQUFsQixDQUF3QixDQUF4QixFQUE2QixRQUFwQyxDQUNELENBQ0QsTUFBT0EsS0FBUCxDQUNELENBWEQsQ0FhQTs7Ozs7OztHQVFBNEssSUFBSSxDQUFDb1AsV0FBTCxDQUFtQixTQUFTQyxFQUFULENBQWEsQ0FDOUIsR0FBR0EsRUFBRSxDQUFDM0MsT0FBSCxDQUFXLEdBQVgsSUFBb0IsQ0FBQyxDQUF4QixDQUEyQixDQUN6QixNQUFPMU0sS0FBSSxDQUFDc1AsYUFBTCxDQUFtQkQsRUFBbkIsQ0FBUCxDQUNELENBQ0QsR0FBR0EsRUFBRSxDQUFDM0MsT0FBSCxDQUFXLEdBQVgsSUFBb0IsQ0FBQyxDQUF4QixDQUEyQixDQUN6QixNQUFPMU0sS0FBSSxDQUFDdVAsYUFBTCxDQUFtQkYsRUFBbkIsQ0FBUCxDQUNELENBQ0QsTUFBTyxLQUFQLENBQ0QsQ0FSRCxDQVVBOzs7Ozs7R0FPQXJQLElBQUksQ0FBQ3NQLGFBQUwsQ0FBcUIsU0FBU0QsRUFBVCxDQUFhLENBQ2hDQSxFQUFFLENBQUdBLEVBQUUsQ0FBQzNYLEtBQUgsQ0FBUyxHQUFULENBQUwsQ0FDQSxHQUFHMlgsRUFBRSxDQUFDOWEsTUFBSCxHQUFjLENBQWpCLENBQW9CLENBQ2xCLE1BQU8sS0FBUCxDQUNELENBQ0QsR0FBSXNPLEVBQUMsQ0FBRzdDLElBQUksQ0FBQzRGLFlBQUwsRUFBUixDQUNBLElBQUksR0FBSW5ILEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzRRLEVBQUUsQ0FBQzlhLE1BQXRCLENBQThCLEVBQUVrSyxDQUFoQyxDQUFtQyxDQUNqQyxHQUFJK1EsSUFBRyxDQUFHakgsUUFBUSxDQUFDOEcsRUFBRSxDQUFDNVEsQ0FBRCxDQUFILENBQVEsRUFBUixDQUFsQixDQUNBLEdBQUc0SyxLQUFLLENBQUNtRyxHQUFELENBQVIsQ0FBZSxDQUNiLE1BQU8sS0FBUCxDQUNELENBQ0QzTSxDQUFDLENBQUNRLE9BQUYsQ0FBVW1NLEdBQVYsRUFDRCxDQUNELE1BQU8zTSxFQUFDLENBQUM0QixRQUFGLEVBQVAsQ0FDRCxDQWRELENBZ0JBOzs7Ozs7R0FPQXpFLElBQUksQ0FBQ3VQLGFBQUwsQ0FBcUIsU0FBU0YsRUFBVCxDQUFhLENBQ2hDLEdBQUlJLE9BQU0sQ0FBRyxDQUFiLENBQ0FKLEVBQUUsQ0FBR0EsRUFBRSxDQUFDM1gsS0FBSCxDQUFTLEdBQVQsRUFBY2EsTUFBZCxDQUFxQixTQUFTNkssQ0FBVCxDQUFZLENBQ3BDLEdBQUdBLENBQUMsQ0FBQzdPLE1BQUYsR0FBYSxDQUFoQixDQUFtQixFQUFFa2IsTUFBRixDQUNuQixNQUFPLEtBQVAsQ0FDRCxDQUhJLENBQUwsQ0FJQSxHQUFJQyxNQUFLLENBQUcsQ0FBQyxFQUFJTCxFQUFFLENBQUM5YSxNQUFQLENBQWdCa2IsTUFBakIsRUFBMkIsQ0FBdkMsQ0FDQSxHQUFJNU0sRUFBQyxDQUFHN0MsSUFBSSxDQUFDNEYsWUFBTCxFQUFSLENBQ0EsSUFBSSxHQUFJbkgsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLENBQW5CLENBQXNCLEVBQUVBLENBQXhCLENBQTJCLENBQ3pCLEdBQUcsQ0FBQzRRLEVBQUUsQ0FBQzVRLENBQUQsQ0FBSCxFQUFVNFEsRUFBRSxDQUFDNVEsQ0FBRCxDQUFGLENBQU1sSyxNQUFOLEdBQWlCLENBQTlCLENBQWlDLENBQy9Cc08sQ0FBQyxDQUFDYyxZQUFGLENBQWUsQ0FBZixDQUFrQitMLEtBQWxCLEVBQ0FBLEtBQUssQ0FBRyxDQUFSLENBQ0EsU0FDRCxDQUNELEdBQUk5TCxNQUFLLENBQUc1RCxJQUFJLENBQUNzSSxVQUFMLENBQWdCK0csRUFBRSxDQUFDNVEsQ0FBRCxDQUFsQixDQUFaLENBQ0EsR0FBR21GLEtBQUssQ0FBQ3JQLE1BQU4sQ0FBZSxDQUFsQixDQUFxQixDQUNuQnNPLENBQUMsQ0FBQ1EsT0FBRixDQUFVLENBQVYsRUFDRCxDQUNEUixDQUFDLENBQUNhLFFBQUYsQ0FBV0UsS0FBWCxFQUNELENBQ0QsTUFBT2YsRUFBQyxDQUFDNEIsUUFBRixFQUFQLENBQ0QsQ0FyQkQsQ0F1QkE7Ozs7Ozs7O0dBU0F6RSxJQUFJLENBQUMyUCxTQUFMLENBQWlCLFNBQVMvTCxLQUFULENBQWdCLENBQy9CLEdBQUdBLEtBQUssQ0FBQ3JQLE1BQU4sR0FBaUIsQ0FBcEIsQ0FBdUIsQ0FDckIsTUFBT3lMLEtBQUksQ0FBQzRQLFdBQUwsQ0FBaUJoTSxLQUFqQixDQUFQLENBQ0QsQ0FDRCxHQUFHQSxLQUFLLENBQUNyUCxNQUFOLEdBQWlCLEVBQXBCLENBQXdCLENBQ3RCLE1BQU95TCxLQUFJLENBQUM2UCxXQUFMLENBQWlCak0sS0FBakIsQ0FBUCxDQUNELENBQ0QsTUFBTyxLQUFQLENBQ0QsQ0FSRCxDQVVBOzs7Ozs7O0dBUUE1RCxJQUFJLENBQUM0UCxXQUFMLENBQW1CLFNBQVNoTSxLQUFULENBQWdCLENBQ2pDLEdBQUdBLEtBQUssQ0FBQ3JQLE1BQU4sR0FBaUIsQ0FBcEIsQ0FBdUIsQ0FDckIsTUFBTyxLQUFQLENBQ0QsQ0FDRCxHQUFJOGEsR0FBRSxDQUFHLEVBQVQsQ0FDQSxJQUFJLEdBQUk1USxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdtRixLQUFLLENBQUNyUCxNQUF6QixDQUFpQyxFQUFFa0ssQ0FBbkMsQ0FBc0MsQ0FDcEM0USxFQUFFLENBQUNsTyxJQUFILENBQVF5QyxLQUFLLENBQUNlLFVBQU4sQ0FBaUJsRyxDQUFqQixDQUFSLEVBQ0QsQ0FDRCxNQUFPNFEsR0FBRSxDQUFDemEsSUFBSCxDQUFRLEdBQVIsQ0FBUCxDQUNELENBVEQsQ0FXQTs7Ozs7OztHQVFBb0wsSUFBSSxDQUFDNlAsV0FBTCxDQUFtQixTQUFTak0sS0FBVCxDQUFnQixDQUNqQyxHQUFHQSxLQUFLLENBQUNyUCxNQUFOLEdBQWlCLEVBQXBCLENBQXdCLENBQ3RCLE1BQU8sS0FBUCxDQUNELENBQ0QsR0FBSThhLEdBQUUsQ0FBRyxFQUFULENBQ0EsR0FBSVMsV0FBVSxDQUFHLEVBQWpCLENBQ0EsR0FBSUMsYUFBWSxDQUFHLENBQW5CLENBQ0EsSUFBSSxHQUFJdFIsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHbUYsS0FBSyxDQUFDclAsTUFBekIsQ0FBaUNrSyxDQUFDLEVBQUksQ0FBdEMsQ0FBeUMsQ0FDdkMsR0FBSTBJLElBQUcsQ0FBR25ILElBQUksQ0FBQ3dJLFVBQUwsQ0FBZ0I1RSxLQUFLLENBQUNuRixDQUFELENBQUwsQ0FBV21GLEtBQUssQ0FBQ25GLENBQUMsQ0FBRyxDQUFMLENBQWhDLENBQVYsQ0FDQTtBQUNBLE1BQU0wSSxHQUFHLENBQUMsQ0FBRCxDQUFILEdBQVcsR0FBWCxFQUFrQkEsR0FBRyxHQUFLLEdBQWhDLENBQXFDLENBQ25DQSxHQUFHLENBQUdBLEdBQUcsQ0FBQzdMLE1BQUosQ0FBVyxDQUFYLENBQU4sQ0FDRCxDQUNELEdBQUc2TCxHQUFHLEdBQUssR0FBWCxDQUFnQixDQUNkLEdBQUl4QixLQUFJLENBQUdtSyxVQUFVLENBQUNBLFVBQVUsQ0FBQ3ZiLE1BQVgsQ0FBb0IsQ0FBckIsQ0FBckIsQ0FDQSxHQUFJZ1gsSUFBRyxDQUFHOEQsRUFBRSxDQUFDOWEsTUFBYixDQUNBLEdBQUcsQ0FBQ29SLElBQUQsRUFBUzRGLEdBQUcsR0FBSzVGLElBQUksQ0FBQ3FLLEdBQUwsQ0FBVyxDQUEvQixDQUFrQyxDQUNoQ0YsVUFBVSxDQUFDM08sSUFBWCxDQUFnQixDQUFDaUosS0FBSyxDQUFFbUIsR0FBUixDQUFheUUsR0FBRyxDQUFFekUsR0FBbEIsQ0FBaEIsRUFDRCxDQUZELElBRU8sQ0FDTDVGLElBQUksQ0FBQ3FLLEdBQUwsQ0FBV3pFLEdBQVgsQ0FDQSxHQUFJNUYsSUFBSSxDQUFDcUssR0FBTCxDQUFXckssSUFBSSxDQUFDeUUsS0FBakIsQ0FDQTBGLFVBQVUsQ0FBQ0MsWUFBRCxDQUFWLENBQXlCQyxHQUF6QixDQUErQkYsVUFBVSxDQUFDQyxZQUFELENBQVYsQ0FBeUIzRixLQUQzRCxDQUNtRSxDQUNqRTJGLFlBQVksQ0FBR0QsVUFBVSxDQUFDdmIsTUFBWCxDQUFvQixDQUFuQyxDQUNELENBQ0YsQ0FDRixDQUNEOGEsRUFBRSxDQUFDbE8sSUFBSCxDQUFRZ0csR0FBUixFQUNELENBQ0QsR0FBRzJJLFVBQVUsQ0FBQ3ZiLE1BQVgsQ0FBb0IsQ0FBdkIsQ0FBMEIsQ0FDeEIsR0FBSTBiLE1BQUssQ0FBR0gsVUFBVSxDQUFDQyxZQUFELENBQXRCLENBQ0E7QUFDQSxHQUFHRSxLQUFLLENBQUNELEdBQU4sQ0FBWUMsS0FBSyxDQUFDN0YsS0FBbEIsQ0FBMEIsQ0FBN0IsQ0FBZ0MsQ0FDOUJpRixFQUFFLENBQUNhLE1BQUgsQ0FBVUQsS0FBSyxDQUFDN0YsS0FBaEIsQ0FBdUI2RixLQUFLLENBQUNELEdBQU4sQ0FBWUMsS0FBSyxDQUFDN0YsS0FBbEIsQ0FBMEIsQ0FBakQsQ0FBb0QsRUFBcEQsRUFDQSxHQUFHNkYsS0FBSyxDQUFDN0YsS0FBTixHQUFnQixDQUFuQixDQUFzQixDQUNwQmlGLEVBQUUsQ0FBQ2MsT0FBSCxDQUFXLEVBQVgsRUFDRCxDQUNELEdBQUdGLEtBQUssQ0FBQ0QsR0FBTixHQUFjLENBQWpCLENBQW9CLENBQ2xCWCxFQUFFLENBQUNsTyxJQUFILENBQVEsRUFBUixFQUNELENBQ0YsQ0FDRixDQUNELE1BQU9rTyxHQUFFLENBQUN6YSxJQUFILENBQVEsR0FBUixDQUFQLENBQ0QsQ0ExQ0QsQ0E0Q0E7Ozs7Ozs7O0dBU0FvTCxJQUFJLENBQUNvUSxhQUFMLENBQXFCLFNBQVN4YyxPQUFULENBQWtCNE0sUUFBbEIsQ0FBNEIsQ0FDL0MsR0FBRyxNQUFPNU0sUUFBUCxHQUFtQixVQUF0QixDQUFrQyxDQUNoQzRNLFFBQVEsQ0FBRzVNLE9BQVgsQ0FDQUEsT0FBTyxDQUFHLEVBQVYsQ0FDRCxDQUNEQSxPQUFPLENBQUdBLE9BQU8sRUFBSSxFQUFyQixDQUNBLEdBQUcsU0FBV29NLEtBQVgsRUFBbUIsQ0FBQ3BNLE9BQU8sQ0FBQ3ljLE1BQS9CLENBQXVDLENBQ3JDLE1BQU83UCxTQUFRLENBQUMsSUFBRCxDQUFPUixJQUFJLENBQUNzUSxLQUFaLENBQWYsQ0FDRCxDQUNELEdBQUcsTUFBT0MsVUFBUCxHQUFxQixXQUFyQixFQUNELHVCQUF5QkEsVUFEeEIsRUFFREEsU0FBUyxDQUFDQyxtQkFBVixDQUFnQyxDQUZsQyxDQUVxQyxDQUNuQ3hRLElBQUksQ0FBQ3NRLEtBQUwsQ0FBYUMsU0FBUyxDQUFDQyxtQkFBdkIsQ0FDQSxNQUFPaFEsU0FBUSxDQUFDLElBQUQsQ0FBT1IsSUFBSSxDQUFDc1EsS0FBWixDQUFmLENBQ0QsQ0FDRCxHQUFHLE1BQU9HLE9BQVAsR0FBa0IsV0FBckIsQ0FBa0MsQ0FDaEM7QUFDQXpRLElBQUksQ0FBQ3NRLEtBQUwsQ0FBYSxDQUFiLENBQ0EsTUFBTzlQLFNBQVEsQ0FBQyxJQUFELENBQU9SLElBQUksQ0FBQ3NRLEtBQVosQ0FBZixDQUNELENBQ0QsR0FBRyxNQUFPSSxLQUFQLEdBQWdCLFdBQW5CLENBQWdDLENBQzlCO0FBQ0ExUSxJQUFJLENBQUNzUSxLQUFMLENBQWEsQ0FBYixDQUNBLE1BQU85UCxTQUFRLENBQUMsSUFBRCxDQUFPUixJQUFJLENBQUNzUSxLQUFaLENBQWYsQ0FDRCxDQUVEO0FBQ0EsR0FBSUssUUFBTyxDQUFHQyxHQUFHLENBQUNDLGVBQUosQ0FBb0IsR0FBSUgsS0FBSixDQUFTLENBQUMsR0FBRCxDQUN6QyxVQUFXLENBQ1R0UyxJQUFJLENBQUNnRCxnQkFBTCxDQUFzQixTQUF0QixDQUFpQyxTQUFTZ0MsQ0FBVCxDQUFZLENBQzNDO0FBQ0EsR0FBSTBOLEdBQUUsQ0FBR3ZQLElBQUksQ0FBQ0QsR0FBTCxFQUFULENBQ0EsR0FBSXlQLEdBQUUsQ0FBR0QsRUFBRSxDQUFHLENBQWQsQ0FDQSxNQUFNdlAsSUFBSSxDQUFDRCxHQUFMLEdBQWF5UCxFQUFuQixFQUFzQixDQUF0QixDQUNBM1MsSUFBSSxDQUFDbEMsV0FBTCxDQUFpQixDQUFDNFUsRUFBRSxDQUFFQSxFQUFMLENBQVNDLEVBQUUsQ0FBRUEsRUFBYixDQUFqQixFQUNELENBTkQsRUFPRCxDQVJELENBUUUxVixRQVJGLEVBRHlDLENBVTNDLEtBVjJDLENBQVQsQ0FVMUIsQ0FBQytQLElBQUksQ0FBRSx3QkFBUCxDQVYwQixDQUFwQixDQUFkLENBWUE7QUFDQTRGLE1BQU0sQ0FBQyxFQUFELENBQUssQ0FBTCxDQUFRLEVBQVIsQ0FBTixDQUVBLFFBQVNBLE9BQVQsQ0FBZ0IzTCxHQUFoQixDQUFxQjRMLE9BQXJCLENBQThCQyxVQUE5QixDQUEwQyxDQUN4QyxHQUFHRCxPQUFPLEdBQUssQ0FBZixDQUFrQixDQUNoQjtBQUNBLEdBQUlFLElBQUcsQ0FBR2hXLElBQUksQ0FBQ2lXLEtBQUwsQ0FBVy9MLEdBQUcsQ0FBQzFOLE1BQUosQ0FBVyxTQUFTd1osR0FBVCxDQUFjL08sQ0FBZCxDQUFpQixDQUMvQyxNQUFPK08sSUFBRyxDQUFHL08sQ0FBYixDQUNELENBRm9CLENBRWxCLENBRmtCLEVBRWJpRCxHQUFHLENBQUM5USxNQUZGLENBQVYsQ0FHQXlMLElBQUksQ0FBQ3NRLEtBQUwsQ0FBYW5WLElBQUksQ0FBQ2tLLEdBQUwsQ0FBUyxDQUFULENBQVk4TCxHQUFaLENBQWIsQ0FDQVAsR0FBRyxDQUFDUyxlQUFKLENBQW9CVixPQUFwQixFQUNBLE1BQU9uUSxTQUFRLENBQUMsSUFBRCxDQUFPUixJQUFJLENBQUNzUSxLQUFaLENBQWYsQ0FDRCxDQUNEeFYsR0FBRyxDQUFDb1csVUFBRCxDQUFhLFNBQVNJLEdBQVQsQ0FBY0MsT0FBZCxDQUF1QixDQUNyQ2xNLEdBQUcsQ0FBQ2xFLElBQUosQ0FBU3hKLE1BQU0sQ0FBQ3VaLFVBQUQsQ0FBYUssT0FBYixDQUFmLEVBQ0FQLE1BQU0sQ0FBQzNMLEdBQUQsQ0FBTTRMLE9BQU8sQ0FBRyxDQUFoQixDQUFtQkMsVUFBbkIsQ0FBTixDQUNELENBSEUsQ0FBSCxDQUlELENBRUQsUUFBU3BXLElBQVQsQ0FBYW9XLFVBQWIsQ0FBeUIxUSxRQUF6QixDQUFtQyxDQUNqQyxHQUFJZ1IsUUFBTyxDQUFHLEVBQWQsQ0FDQSxHQUFJRCxRQUFPLENBQUcsRUFBZCxDQUNBLElBQUksR0FBSTlTLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3lTLFVBQW5CLENBQStCLEVBQUV6UyxDQUFqQyxDQUFvQyxDQUNsQyxHQUFJZ1QsT0FBTSxDQUFHLEdBQUloQixPQUFKLENBQVdFLE9BQVgsQ0FBYixDQUNBYyxNQUFNLENBQUNyUSxnQkFBUCxDQUF3QixTQUF4QixDQUFtQyxTQUFTZ0MsQ0FBVCxDQUFZLENBQzdDbU8sT0FBTyxDQUFDcFEsSUFBUixDQUFhaUMsQ0FBQyxDQUFDak4sSUFBZixFQUNBLEdBQUdvYixPQUFPLENBQUNoZCxNQUFSLEdBQW1CMmMsVUFBdEIsQ0FBa0MsQ0FDaEMsSUFBSSxHQUFJelMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHeVMsVUFBbkIsQ0FBK0IsRUFBRXpTLENBQWpDLENBQW9DLENBQ2xDK1MsT0FBTyxDQUFDL1MsQ0FBRCxDQUFQLENBQVdpVCxTQUFYLEdBQ0QsQ0FDRGxSLFFBQVEsQ0FBQyxJQUFELENBQU8rUSxPQUFQLENBQVIsQ0FDRCxDQUNGLENBUkQsRUFTQUMsT0FBTyxDQUFDclEsSUFBUixDQUFhc1EsTUFBYixFQUNELENBQ0QsSUFBSSxHQUFJaFQsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHeVMsVUFBbkIsQ0FBK0IsRUFBRXpTLENBQWpDLENBQW9DLENBQ2xDK1MsT0FBTyxDQUFDL1MsQ0FBRCxDQUFQLENBQVd2QyxXQUFYLENBQXVCdUMsQ0FBdkIsRUFDRCxDQUNGLENBRUQsUUFBUzlHLE9BQVQsQ0FBZ0J1WixVQUFoQixDQUE0QkssT0FBNUIsQ0FBcUMsQ0FDbkM7QUFDQSxHQUFJSSxTQUFRLENBQUcsRUFBZixDQUNBLElBQUksR0FBSXZTLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzhSLFVBQW5CLENBQStCLEVBQUU5UixDQUFqQyxDQUFvQyxDQUNsQyxHQUFJd1MsR0FBRSxDQUFHTCxPQUFPLENBQUNuUyxDQUFELENBQWhCLENBQ0EsR0FBSXlTLFFBQU8sQ0FBR0YsUUFBUSxDQUFDdlMsQ0FBRCxDQUFSLENBQWMsRUFBNUIsQ0FDQSxJQUFJLEdBQUlYLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3lTLFVBQW5CLENBQStCLEVBQUV6UyxDQUFqQyxDQUFvQyxDQUNsQyxHQUFHVyxDQUFDLEdBQUtYLENBQVQsQ0FBWSxDQUNWLFNBQ0QsQ0FDRCxHQUFJcVQsR0FBRSxDQUFHUCxPQUFPLENBQUM5UyxDQUFELENBQWhCLENBQ0EsR0FBSW1ULEVBQUUsQ0FBQ2QsRUFBSCxDQUFRZ0IsRUFBRSxDQUFDaEIsRUFBWCxFQUFpQmMsRUFBRSxDQUFDZCxFQUFILENBQVFnQixFQUFFLENBQUNmLEVBQTdCLEVBQ0FlLEVBQUUsQ0FBQ2hCLEVBQUgsQ0FBUWMsRUFBRSxDQUFDZCxFQUFYLEVBQWlCZ0IsRUFBRSxDQUFDaEIsRUFBSCxDQUFRYyxFQUFFLENBQUNiLEVBRC9CLENBQ29DLENBQ2xDYyxPQUFPLENBQUMxUSxJQUFSLENBQWExQyxDQUFiLEVBQ0QsQ0FDRixDQUNGLENBQ0Q7QUFDQTtBQUNBO0FBQ0EsTUFBT2tULFNBQVEsQ0FBQ2hhLE1BQVQsQ0FBZ0IsU0FBUzBOLEdBQVQsQ0FBY3dNLE9BQWQsQ0FBdUIsQ0FDNUMsTUFBTzFXLEtBQUksQ0FBQ2tLLEdBQUwsQ0FBU0EsR0FBVCxDQUFjd00sT0FBTyxDQUFDdGQsTUFBdEIsQ0FBUCxDQUNELENBRk0sQ0FFSixDQUZJLENBQVAsQ0FHRCxDQUNGLENBdkdELENBMEdBLEtBQU8sQ0E3N0ZHLENBODdGVixPQTk3RlUsQ0ErN0ZWLEtBQU8sU0FBUzJKLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUlBLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUVBLGVBQ0EsR0FBSXdULEtBQUksQ0FBRzdULE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVCLEtBQUssQ0FBQzBWLElBQU4sQ0FBYTFWLEtBQUssQ0FBQzBWLElBQU4sRUFBYyxFQUF2RCxDQUVBOztHQUdBQSxJQUFJLENBQUNDLEtBQUwsQ0FBYSxDQUNYQyxTQUFTLENBQVMsSUFEUCxDQUVYQyxXQUFXLENBQU8sSUFGUCxDQUdYQyxnQkFBZ0IsQ0FBRSxJQUhQLENBSVhDLE9BQU8sQ0FBVyxJQUpQLENBQWIsQ0FPQTs7O0dBSUFMLElBQUksQ0FBQ00sSUFBTCxDQUFZLENBQ1ZDLElBQUksQ0FBYyxDQURSLENBRVZDLE9BQU8sQ0FBVyxDQUZSLENBR1ZDLE9BQU8sQ0FBVyxDQUhSLENBSVZDLFNBQVMsQ0FBUyxDQUpSLENBS1ZDLFdBQVcsQ0FBTyxDQUxSLENBTVZDLElBQUksQ0FBYyxDQU5SLENBT1ZDLEdBQUcsQ0FBZSxDQVBSLENBUVZDLEtBQUssQ0FBYSxDQVJSLENBU1ZDLFFBQVEsQ0FBVSxDQVRSLENBVVZDLElBQUksQ0FBYyxDQVZSLENBV1ZDLFVBQVUsQ0FBTyxFQVhQLENBWVZDLFFBQVEsQ0FBUyxFQVpQLENBYVZDLElBQUksQ0FBYSxFQWJQLENBY1ZDLElBQUksQ0FBYSxFQWRQLENBZVZDLFFBQVEsQ0FBUyxFQWZQLENBZ0JWQyxHQUFHLENBQWMsRUFoQlAsQ0FpQlZDLGVBQWUsQ0FBRSxFQWpCUCxDQWtCVkMsU0FBUyxDQUFRLEVBbEJQLENBbUJWQyxPQUFPLENBQVUsRUFuQlAsQ0FvQlZDLGVBQWUsQ0FBRSxFQXBCUCxDQXFCVkMsU0FBUyxDQUFRLEVBckJQLENBQVosQ0F3QkE7Ozs7Ozs7Ozs7OztHQWFBM0IsSUFBSSxDQUFDamIsTUFBTCxDQUFjLFNBQVM2YyxRQUFULENBQW1CdkksSUFBbkIsQ0FBeUJ3SSxXQUF6QixDQUFzQzNGLEtBQXRDLENBQTZDcmEsT0FBN0MsQ0FBc0QsQ0FDbEU7Ozs7d0NBRGtFLENBT2xFO0FBQ0EsR0FBR3lJLEtBQUssQ0FBQzJELElBQU4sQ0FBV21DLE9BQVgsQ0FBbUI4TCxLQUFuQixDQUFILENBQThCLENBQzVCLEdBQUk0RixJQUFHLENBQUcsRUFBVixDQUNBLElBQUksR0FBSXBWLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3dQLEtBQUssQ0FBQzFaLE1BQXpCLENBQWlDLEVBQUVrSyxDQUFuQyxDQUFzQyxDQUNwQyxHQUFHd1AsS0FBSyxDQUFDeFAsQ0FBRCxDQUFMLEdBQWE2QixTQUFoQixDQUEyQixDQUN6QnVULEdBQUcsQ0FBQzFTLElBQUosQ0FBUzhNLEtBQUssQ0FBQ3hQLENBQUQsQ0FBZCxFQUNELENBQ0YsQ0FDRHdQLEtBQUssQ0FBRzRGLEdBQVIsQ0FDRCxDQUVELEdBQUluSixJQUFHLENBQUcsQ0FDUmlKLFFBQVEsQ0FBRUEsUUFERixDQUVSdkksSUFBSSxDQUFFQSxJQUZFLENBR1J3SSxXQUFXLENBQUVBLFdBSEwsQ0FJUkUsUUFBUSxDQUFFRixXQUFXLEVBQUl2WCxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1COEwsS0FBbkIsQ0FKakIsQ0FLUkEsS0FBSyxDQUFFQSxLQUxDLENBQVYsQ0FPQSxHQUFHcmEsT0FBTyxFQUFJLHFCQUF1QkEsUUFBckMsQ0FBOEMsQ0FDNUM7QUFDQThXLEdBQUcsQ0FBQ3FKLGlCQUFKLENBQXdCbmdCLE9BQU8sQ0FBQ21nQixpQkFBaEMsQ0FDQTtBQUNBO0FBQ0FySixHQUFHLENBQUNzSixRQUFKLENBQWVqQyxJQUFJLENBQUNoUixJQUFMLENBQVUySixHQUFWLENBQWYsQ0FDRCxDQUNELE1BQU9BLElBQVAsQ0FDRCxDQWpDRCxDQW1DQTs7Ozs7Ozs7R0FTQXFILElBQUksQ0FBQ2hSLElBQUwsQ0FBWSxTQUFTMkosR0FBVCxDQUFjOVcsT0FBZCxDQUF1QixDQUNqQyxHQUFJbU4sS0FBSixDQUVBLEdBQUcxRSxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1CdUksR0FBbkIsQ0FBSCxDQUE0QixDQUMxQjNKLElBQUksQ0FBRyxFQUFQLENBQ0EsSUFBSSxHQUFJdEMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHaU0sR0FBRyxDQUFDblcsTUFBdkIsQ0FBK0IsRUFBRWtLLENBQWpDLENBQW9DLENBQ2xDc0MsSUFBSSxDQUFDSSxJQUFMLENBQVU0USxJQUFJLENBQUNoUixJQUFMLENBQVUySixHQUFHLENBQUNqTSxDQUFELENBQWIsQ0FBa0I3SyxPQUFsQixDQUFWLEVBQ0QsQ0FDRCxNQUFPbU4sS0FBUCxDQUNELENBRUQsR0FBRyxNQUFPMkosSUFBUCxHQUFlLFFBQWxCLENBQTRCLENBQzFCO0FBQ0EsTUFBT0EsSUFBUCxDQUNELENBRUQzSixJQUFJLENBQUcsQ0FDTDRTLFFBQVEsQ0FBRWpKLEdBQUcsQ0FBQ2lKLFFBRFQsQ0FFTHZJLElBQUksQ0FBRVYsR0FBRyxDQUFDVSxJQUZMLENBR0x3SSxXQUFXLENBQUVsSixHQUFHLENBQUNrSixXQUhaLENBSUxFLFFBQVEsQ0FBRXBKLEdBQUcsQ0FBQ29KLFFBSlQsQ0FLTDdGLEtBQUssQ0FBRThELElBQUksQ0FBQ2hSLElBQUwsQ0FBVTJKLEdBQUcsQ0FBQ3VELEtBQWQsQ0FBcUJyYSxPQUFyQixDQUxGLENBQVAsQ0FPQSxHQUFHQSxPQUFPLEVBQUksQ0FBQ0EsT0FBTyxDQUFDcWdCLHdCQUF2QixDQUFpRCxDQUMvQztBQUNBbFQsSUFBSSxDQUFDZ1QsaUJBQUwsQ0FBeUJySixHQUFHLENBQUNxSixpQkFBN0IsQ0FDRCxDQUNELE1BQU9oVCxLQUFQLENBQ0QsQ0E1QkQsQ0E4QkE7Ozs7Ozs7Ozs7O0dBWUFnUixJQUFJLENBQUNtQyxNQUFMLENBQWMsU0FBU0MsSUFBVCxDQUFlQyxJQUFmLENBQXFCeGdCLE9BQXJCLENBQThCLENBQzFDLEdBQUd5SSxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1CZ1MsSUFBbkIsQ0FBSCxDQUE2QixDQUMzQixHQUFHLENBQUM5WCxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1CaVMsSUFBbkIsQ0FBSixDQUE4QixDQUM1QixNQUFPLE1BQVAsQ0FDRCxDQUNELEdBQUdELElBQUksQ0FBQzVmLE1BQUwsR0FBZ0I2ZixJQUFJLENBQUM3ZixNQUF4QixDQUFnQyxDQUM5QixNQUFPLE1BQVAsQ0FDRCxDQUNELElBQUksR0FBSWtLLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzBWLElBQUksQ0FBQzVmLE1BQXhCLENBQWdDLEVBQUVrSyxDQUFsQyxDQUFxQyxDQUNuQyxHQUFHLENBQUNzVCxJQUFJLENBQUNtQyxNQUFMLENBQVlDLElBQUksQ0FBQzFWLENBQUQsQ0FBaEIsQ0FBcUIyVixJQUFJLENBQUMzVixDQUFELENBQXpCLENBQUosQ0FBbUMsQ0FDakMsTUFBTyxNQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sS0FBUCxDQUNELENBRUQsR0FBRyxRQUFPMFYsSUFBUCxZQUF1QkMsSUFBdkIsQ0FBSCxDQUFnQyxDQUM5QixNQUFPLE1BQVAsQ0FDRCxDQUVELEdBQUcsTUFBT0QsS0FBUCxHQUFnQixRQUFuQixDQUE2QixDQUMzQixNQUFPQSxLQUFJLEdBQUtDLElBQWhCLENBQ0QsQ0FFRCxHQUFJQyxNQUFLLENBQUdGLElBQUksQ0FBQ1IsUUFBTCxHQUFrQlMsSUFBSSxDQUFDVCxRQUF2QixFQUNWUSxJQUFJLENBQUMvSSxJQUFMLEdBQWNnSixJQUFJLENBQUNoSixJQURULEVBRVYrSSxJQUFJLENBQUNQLFdBQUwsR0FBcUJRLElBQUksQ0FBQ1IsV0FGaEIsRUFHVk8sSUFBSSxDQUFDTCxRQUFMLEdBQWtCTSxJQUFJLENBQUNOLFFBSGIsRUFJVi9CLElBQUksQ0FBQ21DLE1BQUwsQ0FBWUMsSUFBSSxDQUFDbEcsS0FBakIsQ0FBd0JtRyxJQUFJLENBQUNuRyxLQUE3QixDQUpGLENBS0EsR0FBR3JhLE9BQU8sRUFBSUEsT0FBTyxDQUFDMGdCLHdCQUF0QixDQUFnRCxDQUM5Q0QsS0FBSyxDQUFHQSxLQUFLLEVBQUtGLElBQUksQ0FBQ0osaUJBQUwsR0FBMkJLLElBQUksQ0FBQ0wsaUJBQWxELENBQ0QsQ0FFRCxNQUFPTSxNQUFQLENBQ0QsQ0FsQ0QsQ0FvQ0E7Ozs7Ozs7OztHQVVBdEMsSUFBSSxDQUFDd0MsaUJBQUwsQ0FBeUIsU0FBUzFSLENBQVQsQ0FBWSxDQUNuQztBQUNBO0FBQ0EsR0FBSTJSLEdBQUUsQ0FBRzNSLENBQUMsQ0FBQzZCLE9BQUYsRUFBVCxDQUNBLEdBQUc4UCxFQUFFLEdBQUssSUFBVixDQUFnQixDQUNkLE1BQU9sVSxVQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUkvTCxPQUFKLENBQ0EsR0FBSWtnQixTQUFRLENBQUdELEVBQUUsQ0FBRyxJQUFwQixDQUNBLEdBQUcsQ0FBQ0MsUUFBSixDQUFjLENBQ1o7QUFDQWxnQixNQUFNLENBQUdpZ0IsRUFBVCxDQUNELENBSEQsSUFHTyxDQUNMO0FBQ0E7QUFDQWpnQixNQUFNLENBQUdzTyxDQUFDLENBQUNzQyxNQUFGLENBQVMsQ0FBQ3FQLEVBQUUsQ0FBRyxJQUFOLEdBQWUsQ0FBeEIsQ0FBVCxDQUNELENBQ0QsTUFBT2pnQixPQUFQLENBQ0QsQ0FwQkQsQ0FzQkE7Ozs7OztHQU9BLFFBQVNtZ0IsbUJBQVQsQ0FBNEI5USxLQUE1QixDQUFtQytRLFNBQW5DLENBQThDdlYsQ0FBOUMsQ0FBaUQsQ0FDL0MsR0FBR0EsQ0FBQyxDQUFHdVYsU0FBUCxDQUFrQixDQUNoQixHQUFJcGUsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsNkJBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDcWUsU0FBTixDQUFrQmhSLEtBQUssQ0FBQ3JQLE1BQU4sRUFBbEIsQ0FDQWdDLEtBQUssQ0FBQ29lLFNBQU4sQ0FBa0JBLFNBQWxCLENBQ0FwZSxLQUFLLENBQUNzZSxTQUFOLENBQWtCelYsQ0FBbEIsQ0FDQSxLQUFNN0ksTUFBTixDQUNELENBQ0YsQ0FFRDs7Ozs7Ozs7O0dBVUEsR0FBSXVlLGdCQUFlLENBQUcsUUFBbEJBLGdCQUFrQixDQUFTbFIsS0FBVCxDQUFnQitRLFNBQWhCLENBQTJCLENBQy9DO0FBQ0E7QUFDQTtBQUNBLEdBQUlILEdBQUUsQ0FBRzVRLEtBQUssQ0FBQ2MsT0FBTixFQUFULENBQ0FpUSxTQUFTLEdBQ1QsR0FBR0gsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDZCxNQUFPbFUsVUFBUCxDQUNELENBRUQ7QUFDQSxHQUFJL0wsT0FBSixDQUNBLEdBQUlrZ0IsU0FBUSxDQUFHRCxFQUFFLENBQUcsSUFBcEIsQ0FDQSxHQUFHLENBQUNDLFFBQUosQ0FBYyxDQUNaO0FBQ0FsZ0IsTUFBTSxDQUFHaWdCLEVBQVQsQ0FDRCxDQUhELElBR08sQ0FDTDtBQUNBO0FBQ0EsR0FBSU8sY0FBYSxDQUFHUCxFQUFFLENBQUcsSUFBekIsQ0FDQUUsa0JBQWtCLENBQUM5USxLQUFELENBQVErUSxTQUFSLENBQW1CSSxhQUFuQixDQUFsQixDQUNBeGdCLE1BQU0sQ0FBR3FQLEtBQUssQ0FBQ3VCLE1BQU4sQ0FBYTRQLGFBQWEsRUFBSSxDQUE5QixDQUFULENBQ0QsQ0FDRDtBQUNBLEdBQUd4Z0IsTUFBTSxDQUFHLENBQVosQ0FBZSxDQUNiLEtBQU0sSUFBSUYsTUFBSixDQUFVLG9CQUFzQkUsTUFBaEMsQ0FBTixDQUNELENBQ0QsTUFBT0EsT0FBUCxDQUNELENBNUJELENBOEJBOzs7Ozs7Ozs7Ozs7Ozs7OztHQWtCQXdkLElBQUksQ0FBQ2lELE9BQUwsQ0FBZSxTQUFTcFIsS0FBVCxDQUFnQmhRLE9BQWhCLENBQXlCLENBQ3RDLEdBQUdBLE9BQU8sR0FBSzBNLFNBQWYsQ0FBMEIsQ0FDeEIxTSxPQUFPLENBQUcsQ0FDUnFoQixNQUFNLENBQUUsSUFEQSxDQUVSQyxnQkFBZ0IsQ0FBRSxJQUZWLENBQVYsQ0FJRCxDQUNELEdBQUcsTUFBT3RoQixRQUFQLEdBQW1CLFNBQXRCLENBQWlDLENBQy9CQSxPQUFPLENBQUcsQ0FDUnFoQixNQUFNLENBQUVyaEIsT0FEQSxDQUVSc2hCLGdCQUFnQixDQUFFLElBRlYsQ0FBVixDQUlELENBQ0QsR0FBRyxFQUFFLFVBQVl0aEIsUUFBZCxDQUFILENBQTJCLENBQ3pCQSxPQUFPLENBQUNxaEIsTUFBUixDQUFpQixJQUFqQixDQUNELENBQ0QsR0FBRyxFQUFFLG9CQUFzQnJoQixRQUF4QixDQUFILENBQXFDLENBQ25DQSxPQUFPLENBQUNzaEIsZ0JBQVIsQ0FBMkIsSUFBM0IsQ0FDRCxDQUVEO0FBQ0EsR0FBRyxNQUFPdFIsTUFBUCxHQUFpQixRQUFwQixDQUE4QixDQUM1QkEsS0FBSyxDQUFHdkgsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QmhDLEtBQXhCLENBQVIsQ0FDRCxDQUVELE1BQU91UixTQUFRLENBQUN2UixLQUFELENBQVFBLEtBQUssQ0FBQ3JQLE1BQU4sRUFBUixDQUF3QixDQUF4QixDQUEyQlgsT0FBM0IsQ0FBZixDQUNELENBMUJELENBNEJBOzs7Ozs7Ozs7R0FVQSxRQUFTdWhCLFNBQVQsQ0FBa0J2UixLQUFsQixDQUF5QitRLFNBQXpCLENBQW9DUyxLQUFwQyxDQUEyQ3hoQixPQUEzQyxDQUFvRCxDQUNsRDtBQUNBLEdBQUl3VyxNQUFKLENBRUE7QUFDQXNLLGtCQUFrQixDQUFDOVEsS0FBRCxDQUFRK1EsU0FBUixDQUFtQixDQUFuQixDQUFsQixDQUVBO0FBQ0EsR0FBSVUsR0FBRSxDQUFHelIsS0FBSyxDQUFDYyxPQUFOLEVBQVQsQ0FDQTtBQUNBaVEsU0FBUyxHQUVUO0FBQ0EsR0FBSWhCLFNBQVEsQ0FBSTBCLEVBQUUsQ0FBRyxJQUFyQixDQUVBO0FBQ0EsR0FBSWpLLEtBQUksQ0FBR2lLLEVBQUUsQ0FBRyxJQUFoQixDQUVBO0FBQ0FqTCxLQUFLLENBQUd4RyxLQUFLLENBQUNyUCxNQUFOLEVBQVIsQ0FDQSxHQUFJQSxPQUFNLENBQUd1Z0IsZUFBZSxDQUFDbFIsS0FBRCxDQUFRK1EsU0FBUixDQUE1QixDQUNBQSxTQUFTLEVBQUl2SyxLQUFLLENBQUd4RyxLQUFLLENBQUNyUCxNQUFOLEVBQXJCLENBRUE7QUFDQSxHQUFHQSxNQUFNLEdBQUsrTCxTQUFYLEVBQXdCL0wsTUFBTSxDQUFHb2dCLFNBQXBDLENBQStDLENBQzdDLEdBQUcvZ0IsT0FBTyxDQUFDcWhCLE1BQVgsQ0FBbUIsQ0FDakIsR0FBSTFlLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLG9DQUFWLENBQVosQ0FDQWtDLEtBQUssQ0FBQ3FlLFNBQU4sQ0FBa0JoUixLQUFLLENBQUNyUCxNQUFOLEVBQWxCLENBQ0FnQyxLQUFLLENBQUNvZSxTQUFOLENBQWtCQSxTQUFsQixDQUNBcGUsS0FBSyxDQUFDc2UsU0FBTixDQUFrQnRnQixNQUFsQixDQUNBLEtBQU1nQyxNQUFOLENBQ0QsQ0FDRDtBQUNBaEMsTUFBTSxDQUFHb2dCLFNBQVQsQ0FDRCxDQUVEO0FBQ0EsR0FBSTFHLE1BQUosQ0FDQTtBQUNBLEdBQUk4RixrQkFBSixDQUVBO0FBQ0EsR0FBSUgsWUFBVyxDQUFJLENBQUN5QixFQUFFLENBQUcsSUFBTixJQUFnQixJQUFuQyxDQUNBLEdBQUd6QixXQUFILENBQWdCLENBQ2Q7QUFDQTNGLEtBQUssQ0FBRyxFQUFSLENBQ0EsR0FBRzFaLE1BQU0sR0FBSytMLFNBQWQsQ0FBeUIsQ0FDdkI7QUFDQSxPQUFRLENBQ05vVSxrQkFBa0IsQ0FBQzlRLEtBQUQsQ0FBUStRLFNBQVIsQ0FBbUIsQ0FBbkIsQ0FBbEIsQ0FDQSxHQUFHL1EsS0FBSyxDQUFDQSxLQUFOLENBQVksQ0FBWixJQUFtQlYsTUFBTSxDQUFDQyxZQUFQLENBQW9CLENBQXBCLENBQXVCLENBQXZCLENBQXRCLENBQWlELENBQy9DUyxLQUFLLENBQUNhLFFBQU4sQ0FBZSxDQUFmLEVBQ0FrUSxTQUFTLEVBQUksQ0FBYixDQUNBLE1BQ0QsQ0FDRHZLLEtBQUssQ0FBR3hHLEtBQUssQ0FBQ3JQLE1BQU4sRUFBUixDQUNBMFosS0FBSyxDQUFDOU0sSUFBTixDQUFXZ1UsUUFBUSxDQUFDdlIsS0FBRCxDQUFRK1EsU0FBUixDQUFtQlMsS0FBSyxDQUFHLENBQTNCLENBQThCeGhCLE9BQTlCLENBQW5CLEVBQ0ErZ0IsU0FBUyxFQUFJdkssS0FBSyxDQUFHeEcsS0FBSyxDQUFDclAsTUFBTixFQUFyQixDQUNELENBQ0YsQ0FiRCxJQWFPLENBQ0w7QUFDQSxNQUFNQSxNQUFNLENBQUcsQ0FBZixDQUFrQixDQUNoQjZWLEtBQUssQ0FBR3hHLEtBQUssQ0FBQ3JQLE1BQU4sRUFBUixDQUNBMFosS0FBSyxDQUFDOU0sSUFBTixDQUFXZ1UsUUFBUSxDQUFDdlIsS0FBRCxDQUFRclAsTUFBUixDQUFnQjZnQixLQUFLLENBQUcsQ0FBeEIsQ0FBMkJ4aEIsT0FBM0IsQ0FBbkIsRUFDQStnQixTQUFTLEVBQUl2SyxLQUFLLENBQUd4RyxLQUFLLENBQUNyUCxNQUFOLEVBQXJCLENBQ0FBLE1BQU0sRUFBSTZWLEtBQUssQ0FBR3hHLEtBQUssQ0FBQ3JQLE1BQU4sRUFBbEIsQ0FDRCxDQUNGLENBQ0YsQ0FFRDtBQUNBLEdBQUcwWixLQUFLLEdBQUszTixTQUFWLEVBQXVCcVQsUUFBUSxHQUFLNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQS9DLEVBQ0Q3RyxJQUFJLEdBQUsyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FEckIsQ0FDZ0MsQ0FDOUJzQixpQkFBaUIsQ0FBR25RLEtBQUssQ0FBQ0EsS0FBTixDQUFZclAsTUFBWixDQUFwQixDQUNELENBRUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzBaLEtBQUssR0FBSzNOLFNBQVYsRUFBdUIxTSxPQUFPLENBQUNzaEIsZ0JBQS9CLEVBQ0R2QixRQUFRLEdBQUs1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEdkIsRUFFRDtBQUNBO0FBQ0M3RyxJQUFJLEdBQUsyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FBVSxxQ0FKN0IsRUFLRGxlLE1BQU0sQ0FBRyxDQUxYLENBS2MsQ0FDWjtBQUNBLEdBQUkrZ0IsVUFBUyxDQUFHMVIsS0FBSyxDQUFDZCxJQUF0QixDQUNBLEdBQUl5UyxlQUFjLENBQUdaLFNBQXJCLENBQ0EsR0FBSWEsT0FBTSxDQUFHLENBQWIsQ0FDQSxHQUFHcEssSUFBSSxHQUFLMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVJLFNBQXRCLENBQWlDLENBQy9COzs7Ozt3Q0FNQWlDLGtCQUFrQixDQUFDOVEsS0FBRCxDQUFRK1EsU0FBUixDQUFtQixDQUFuQixDQUFsQixDQUNBYSxNQUFNLENBQUc1UixLQUFLLENBQUNjLE9BQU4sRUFBVCxDQUNBaVEsU0FBUyxHQUNWLENBQ0Q7QUFDQSxHQUFHYSxNQUFNLEdBQUssQ0FBZCxDQUFpQixDQUNmLEdBQUksQ0FDRjtBQUNBO0FBQ0FwTCxLQUFLLENBQUd4RyxLQUFLLENBQUNyUCxNQUFOLEVBQVIsQ0FDQSxHQUFJa2hCLFdBQVUsQ0FBRyxDQUNmO0FBQ0FDLE9BQU8sQ0FBRTloQixPQUFPLENBQUM4aEIsT0FGRixDQUdmVCxNQUFNLENBQUUsSUFITyxDQUlmQyxnQkFBZ0IsQ0FBRSxJQUpILENBQWpCLENBTUEsR0FBSXBCLFNBQVEsQ0FBR3FCLFFBQVEsQ0FBQ3ZSLEtBQUQsQ0FBUStRLFNBQVIsQ0FBbUJTLEtBQUssQ0FBRyxDQUEzQixDQUE4QkssVUFBOUIsQ0FBdkIsQ0FDQSxHQUFJRSxLQUFJLENBQUd2TCxLQUFLLENBQUd4RyxLQUFLLENBQUNyUCxNQUFOLEVBQW5CLENBQ0FvZ0IsU0FBUyxFQUFJZ0IsSUFBYixDQUNBLEdBQUd2SyxJQUFJLEVBQUkyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FBckIsQ0FBZ0MsQ0FDOUJrRCxJQUFJLEdBQ0wsQ0FFRDtBQUNBO0FBQ0EsR0FBSUMsR0FBRSxDQUFHOUIsUUFBUSxDQUFDSCxRQUFsQixDQUNBLEdBQUdnQyxJQUFJLEdBQUtwaEIsTUFBVCxHQUNBcWhCLEVBQUUsR0FBSzdELElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUFsQixFQUErQjJELEVBQUUsR0FBSzdELElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFEakQsQ0FBSCxDQUN1RSxDQUNyRWxFLEtBQUssQ0FBRyxDQUFDNkYsUUFBRCxDQUFSLENBQ0QsQ0FDRixDQUFDLE1BQU10SSxFQUFOLENBQVUsQ0FDWCxDQUNGLENBQ0QsR0FBR3lDLEtBQUssR0FBSzNOLFNBQWIsQ0FBd0IsQ0FDdEI7QUFDQXNELEtBQUssQ0FBQ2QsSUFBTixDQUFhd1MsU0FBYixDQUNBWCxTQUFTLENBQUdZLGNBQVosQ0FDRCxDQUNGLENBRUQsR0FBR3RILEtBQUssR0FBSzNOLFNBQWIsQ0FBd0IsQ0FDdEI7QUFDQTtBQUVBLEdBQUcvTCxNQUFNLEdBQUsrTCxTQUFkLENBQXlCLENBQ3ZCLEdBQUcxTSxPQUFPLENBQUNxaEIsTUFBWCxDQUFtQixDQUNqQixLQUFNLElBQUk1Z0IsTUFBSixDQUFVLG9EQUFWLENBQU4sQ0FDRCxDQUNEO0FBQ0FFLE1BQU0sQ0FBR29nQixTQUFULENBQ0QsQ0FFRCxHQUFHdkosSUFBSSxHQUFLMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVxQixTQUF0QixDQUFpQyxDQUMvQnpGLEtBQUssQ0FBRyxFQUFSLENBQ0EsS0FBTTFaLE1BQU0sQ0FBRyxDQUFmLENBQWtCQSxNQUFNLEVBQUksQ0FBNUIsQ0FBK0IsQ0FDN0JtZ0Isa0JBQWtCLENBQUM5USxLQUFELENBQVErUSxTQUFSLENBQW1CLENBQW5CLENBQWxCLENBQ0ExRyxLQUFLLEVBQUkvSyxNQUFNLENBQUNDLFlBQVAsQ0FBb0JTLEtBQUssQ0FBQ2dCLFFBQU4sRUFBcEIsQ0FBVCxDQUNBK1AsU0FBUyxFQUFJLENBQWIsQ0FDRCxDQUNGLENBUEQsSUFPTyxDQUNMMUcsS0FBSyxDQUFHckssS0FBSyxDQUFDYSxRQUFOLENBQWVsUSxNQUFmLENBQVIsQ0FDRCxDQUNGLENBRUQ7QUFDQSxHQUFJc2hCLFlBQVcsQ0FBRzlCLGlCQUFpQixHQUFLelQsU0FBdEIsQ0FBbUMsSUFBbkMsQ0FBMEMsQ0FDMUR5VCxpQkFBaUIsQ0FBRUEsaUJBRHVDLENBQTVELENBSUE7QUFDQSxNQUFPaEMsS0FBSSxDQUFDamIsTUFBTCxDQUFZNmMsUUFBWixDQUFzQnZJLElBQXRCLENBQTRCd0ksV0FBNUIsQ0FBeUMzRixLQUF6QyxDQUFnRDRILFdBQWhELENBQVAsQ0FDRCxDQUVEOzs7Ozs7R0FPQTlELElBQUksQ0FBQytELEtBQUwsQ0FBYSxTQUFTcEwsR0FBVCxDQUFjLENBQ3pCLEdBQUk5RyxNQUFLLENBQUd2SCxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQVosQ0FFQTtBQUNBLEdBQUl5UCxHQUFFLENBQUczSyxHQUFHLENBQUNpSixRQUFKLENBQWVqSixHQUFHLENBQUNVLElBQTVCLENBRUE7QUFDQSxHQUFJNkMsTUFBSyxDQUFHNVIsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUFaLENBRUE7QUFDQSxHQUFJbVEscUJBQW9CLENBQUcsS0FBM0IsQ0FDQSxHQUFHLHFCQUF1QnJMLElBQTFCLENBQStCLENBQzdCcUwsb0JBQW9CLENBQUcsSUFBdkIsQ0FDQSxHQUFHckwsR0FBRyxDQUFDc0osUUFBUCxDQUFpQixDQUNmK0Isb0JBQW9CLENBQUdoRSxJQUFJLENBQUNtQyxNQUFMLENBQVl4SixHQUFaLENBQWlCQSxHQUFHLENBQUNzSixRQUFyQixDQUF2QixDQUNELENBQ0YsQ0FFRCxHQUFHK0Isb0JBQUgsQ0FBeUIsQ0FDdkI5SCxLQUFLLENBQUN2SyxRQUFOLENBQWVnSCxHQUFHLENBQUNxSixpQkFBbkIsRUFDRCxDQUZELElBRU8sSUFBR3JKLEdBQUcsQ0FBQ29KLFFBQVAsQ0FBaUIsQ0FDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBR3BKLEdBQUcsQ0FBQ2tKLFdBQVAsQ0FBb0IsQ0FDbEJ5QixFQUFFLEVBQUksSUFBTixDQUNELENBRkQsSUFFTyxDQUNMO0FBQ0FwSCxLQUFLLENBQUM1SyxPQUFOLENBQWMsSUFBZCxFQUNELENBRUQ7QUFDQSxJQUFJLEdBQUk1RSxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdpTSxHQUFHLENBQUN1RCxLQUFKLENBQVUxWixNQUE3QixDQUFxQyxFQUFFa0ssQ0FBdkMsQ0FBMEMsQ0FDeEMsR0FBR2lNLEdBQUcsQ0FBQ3VELEtBQUosQ0FBVXhQLENBQVYsSUFBaUI2QixTQUFwQixDQUErQixDQUM3QjJOLEtBQUssQ0FBQ3pKLFNBQU4sQ0FBZ0J1TixJQUFJLENBQUMrRCxLQUFMLENBQVdwTCxHQUFHLENBQUN1RCxLQUFKLENBQVV4UCxDQUFWLENBQVgsQ0FBaEIsRUFDRCxDQUNGLENBQ0YsQ0FqQk0sSUFpQkEsQ0FDTDtBQUNBLEdBQUdpTSxHQUFHLENBQUNVLElBQUosR0FBYTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVcUIsU0FBMUIsQ0FBcUMsQ0FDbkMsSUFBSSxHQUFJalYsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHaU0sR0FBRyxDQUFDdUQsS0FBSixDQUFVMVosTUFBN0IsQ0FBcUMsRUFBRWtLLENBQXZDLENBQTBDLENBQ3hDd1AsS0FBSyxDQUFDakssUUFBTixDQUFlMEcsR0FBRyxDQUFDdUQsS0FBSixDQUFVdEosVUFBVixDQUFxQmxHLENBQXJCLENBQWYsRUFDRCxDQUNGLENBSkQsSUFJTyxDQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUdpTSxHQUFHLENBQUNVLElBQUosR0FBYTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUF2QixFQUNEOUgsR0FBRyxDQUFDdUQsS0FBSixDQUFVMVosTUFBVixDQUFtQixDQURsQixHQUVEO0FBQ0VtVyxHQUFHLENBQUN1RCxLQUFKLENBQVV0SixVQUFWLENBQXFCLENBQXJCLElBQTRCLENBQTVCLEVBQ0YsQ0FBQytGLEdBQUcsQ0FBQ3VELEtBQUosQ0FBVXRKLFVBQVYsQ0FBcUIsQ0FBckIsRUFBMEIsSUFBM0IsSUFBcUMsQ0FEcEMsRUFFRDtBQUNDK0YsR0FBRyxDQUFDdUQsS0FBSixDQUFVdEosVUFBVixDQUFxQixDQUFyQixJQUE0QixJQUE1QixFQUNELENBQUMrRixHQUFHLENBQUN1RCxLQUFKLENBQVV0SixVQUFWLENBQXFCLENBQXJCLEVBQTBCLElBQTNCLElBQXFDLElBUHBDLENBQUgsQ0FPK0MsQ0FDN0NzSixLQUFLLENBQUN2SyxRQUFOLENBQWVnSCxHQUFHLENBQUN1RCxLQUFKLENBQVUzUyxNQUFWLENBQWlCLENBQWpCLENBQWYsRUFDRCxDQVRELElBU08sQ0FDTDJTLEtBQUssQ0FBQ3ZLLFFBQU4sQ0FBZWdILEdBQUcsQ0FBQ3VELEtBQW5CLEVBQ0QsQ0FDRixDQUNGLENBRUQ7QUFDQXJLLEtBQUssQ0FBQ1AsT0FBTixDQUFjZ1MsRUFBZCxFQUVBO0FBQ0EsR0FBR3BILEtBQUssQ0FBQzFaLE1BQU4sSUFBa0IsR0FBckIsQ0FBMEIsQ0FDeEI7QUFDQTtBQUNBcVAsS0FBSyxDQUFDUCxPQUFOLENBQWM0SyxLQUFLLENBQUMxWixNQUFOLEdBQWlCLElBQS9CLEVBQ0QsQ0FKRCxJQUlPLENBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFJd1IsSUFBRyxDQUFHa0ksS0FBSyxDQUFDMVosTUFBTixFQUFWLENBQ0EsR0FBSXloQixTQUFRLENBQUcsRUFBZixDQUNBLEVBQUcsQ0FDREEsUUFBUSxFQUFJOVMsTUFBTSxDQUFDQyxZQUFQLENBQW9CNEMsR0FBRyxDQUFHLElBQTFCLENBQVosQ0FDQUEsR0FBRyxDQUFHQSxHQUFHLEdBQUssQ0FBZCxDQUNELENBSEQsTUFHUUEsR0FBRyxDQUFHLENBSGQsRUFLQTtBQUNBO0FBQ0FuQyxLQUFLLENBQUNQLE9BQU4sQ0FBYzJTLFFBQVEsQ0FBQ3poQixNQUFULENBQWtCLElBQWhDLEVBRUE7QUFDQTtBQUNBLElBQUksR0FBSWtLLEVBQUMsQ0FBR3VYLFFBQVEsQ0FBQ3poQixNQUFULENBQWtCLENBQTlCLENBQWlDa0ssQ0FBQyxFQUFJLENBQXRDLENBQXlDLEVBQUVBLENBQTNDLENBQThDLENBQzVDbUYsS0FBSyxDQUFDUCxPQUFOLENBQWMyUyxRQUFRLENBQUNyUixVQUFULENBQW9CbEcsQ0FBcEIsQ0FBZCxFQUNELENBQ0YsQ0FFRDtBQUNBbUYsS0FBSyxDQUFDWSxTQUFOLENBQWdCeUosS0FBaEIsRUFDQSxNQUFPckssTUFBUCxDQUNELENBaEdELENBa0dBOzs7Ozs7O0dBUUFtTyxJQUFJLENBQUNrRSxRQUFMLENBQWdCLFNBQVNDLEdBQVQsQ0FBYyxDQUM1QjtBQUNBLEdBQUlDLE9BQU0sQ0FBR0QsR0FBRyxDQUFDeGUsS0FBSixDQUFVLEdBQVYsQ0FBYixDQUNBLEdBQUlrTSxNQUFLLENBQUd2SCxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQVosQ0FFQTtBQUNBaEMsS0FBSyxDQUFDUCxPQUFOLENBQWMsR0FBS2tGLFFBQVEsQ0FBQzROLE1BQU0sQ0FBQyxDQUFELENBQVAsQ0FBWSxFQUFaLENBQWIsQ0FBK0I1TixRQUFRLENBQUM0TixNQUFNLENBQUMsQ0FBRCxDQUFQLENBQVksRUFBWixDQUFyRCxFQUNBO0FBQ0E7QUFDQSxHQUFJeFEsS0FBSixDQUFVeVEsVUFBVixDQUFzQm5JLEtBQXRCLENBQTZCcEwsQ0FBN0IsQ0FDQSxJQUFJLEdBQUlwRSxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcwWCxNQUFNLENBQUM1aEIsTUFBMUIsQ0FBa0MsRUFBRWtLLENBQXBDLENBQXVDLENBQ3JDO0FBQ0E7QUFDQWtILElBQUksQ0FBRyxJQUFQLENBQ0F5USxVQUFVLENBQUcsRUFBYixDQUNBbkksS0FBSyxDQUFHMUYsUUFBUSxDQUFDNE4sTUFBTSxDQUFDMVgsQ0FBRCxDQUFQLENBQVksRUFBWixDQUFoQixDQUNBLEVBQUcsQ0FDRG9FLENBQUMsQ0FBR29MLEtBQUssQ0FBRyxJQUFaLENBQ0FBLEtBQUssQ0FBR0EsS0FBSyxHQUFLLENBQWxCLENBQ0E7QUFDQSxHQUFHLENBQUN0SSxJQUFKLENBQVUsQ0FDUjlDLENBQUMsRUFBSSxJQUFMLENBQ0QsQ0FDRHVULFVBQVUsQ0FBQ2pWLElBQVgsQ0FBZ0IwQixDQUFoQixFQUNBOEMsSUFBSSxDQUFHLEtBQVAsQ0FDRCxDQVRELE1BU1FzSSxLQUFLLENBQUcsQ0FUaEIsRUFXQTtBQUNBLElBQUksR0FBSTdPLEVBQUMsQ0FBR2dYLFVBQVUsQ0FBQzdoQixNQUFYLENBQW9CLENBQWhDLENBQW1DNkssQ0FBQyxFQUFJLENBQXhDLENBQTJDLEVBQUVBLENBQTdDLENBQWdELENBQzlDd0UsS0FBSyxDQUFDUCxPQUFOLENBQWMrUyxVQUFVLENBQUNoWCxDQUFELENBQXhCLEVBQ0QsQ0FDRixDQUVELE1BQU93RSxNQUFQLENBQ0QsQ0FsQ0QsQ0FvQ0E7Ozs7Ozs7O0dBU0FtTyxJQUFJLENBQUNzRSxRQUFMLENBQWdCLFNBQVN6UyxLQUFULENBQWdCLENBQzlCLEdBQUlzUyxJQUFKLENBRUE7QUFDQSxHQUFHLE1BQU90UyxNQUFQLEdBQWlCLFFBQXBCLENBQThCLENBQzVCQSxLQUFLLENBQUd2SCxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCaEMsS0FBeEIsQ0FBUixDQUNELENBRUQ7QUFDQSxHQUFJZixFQUFDLENBQUdlLEtBQUssQ0FBQ2MsT0FBTixFQUFSLENBQ0F3UixHQUFHLENBQUcvYSxJQUFJLENBQUNpVyxLQUFMLENBQVd2TyxDQUFDLENBQUcsRUFBZixFQUFxQixHQUFyQixDQUE0QkEsQ0FBQyxDQUFHLEVBQXRDLENBRUE7QUFDQTtBQUNBLEdBQUlvTCxNQUFLLENBQUcsQ0FBWixDQUNBLE1BQU1ySyxLQUFLLENBQUNyUCxNQUFOLEdBQWlCLENBQXZCLENBQTBCLENBQ3hCc08sQ0FBQyxDQUFHZSxLQUFLLENBQUNjLE9BQU4sRUFBSixDQUNBdUosS0FBSyxDQUFHQSxLQUFLLEVBQUksQ0FBakIsQ0FDQTtBQUNBLEdBQUdwTCxDQUFDLENBQUcsSUFBUCxDQUFhLENBQ1hvTCxLQUFLLEVBQUlwTCxDQUFDLENBQUcsSUFBYixDQUNELENBRkQsSUFFTyxDQUNMO0FBQ0FxVCxHQUFHLEVBQUksS0FBT2pJLEtBQUssQ0FBR3BMLENBQWYsQ0FBUCxDQUNBb0wsS0FBSyxDQUFHLENBQVIsQ0FDRCxDQUNGLENBRUQsTUFBT2lJLElBQVAsQ0FDRCxDQTdCRCxDQStCQTs7Ozs7Ozs7O0dBVUFuRSxJQUFJLENBQUN1RSxhQUFMLENBQXFCLFNBQVNDLEdBQVQsQ0FBYyxDQUNqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0VBcUJBLEdBQUlDLEtBQUksQ0FBRyxHQUFJalYsS0FBSixFQUFYLENBRUE7QUFDQSxHQUFJa1YsS0FBSSxDQUFHbE8sUUFBUSxDQUFDZ08sR0FBRyxDQUFDamIsTUFBSixDQUFXLENBQVgsQ0FBYyxDQUFkLENBQUQsQ0FBbUIsRUFBbkIsQ0FBbkIsQ0FDQW1iLElBQUksQ0FBSUEsSUFBSSxFQUFJLEVBQVQsQ0FBZSxLQUFPQSxJQUF0QixDQUE2QixLQUFPQSxJQUEzQyxDQUNBLEdBQUlDLEdBQUUsQ0FBR25PLFFBQVEsQ0FBQ2dPLEdBQUcsQ0FBQ2piLE1BQUosQ0FBVyxDQUFYLENBQWMsQ0FBZCxDQUFELENBQW1CLEVBQW5CLENBQVIsQ0FBaUMsQ0FBMUMsQ0FBNkM7QUFDN0MsR0FBSXFiLEdBQUUsQ0FBR3BPLFFBQVEsQ0FBQ2dPLEdBQUcsQ0FBQ2piLE1BQUosQ0FBVyxDQUFYLENBQWMsQ0FBZCxDQUFELENBQW1CLEVBQW5CLENBQWpCLENBQ0EsR0FBSXNiLEdBQUUsQ0FBR3JPLFFBQVEsQ0FBQ2dPLEdBQUcsQ0FBQ2piLE1BQUosQ0FBVyxDQUFYLENBQWMsQ0FBZCxDQUFELENBQW1CLEVBQW5CLENBQWpCLENBQ0EsR0FBSXViLEdBQUUsQ0FBR3RPLFFBQVEsQ0FBQ2dPLEdBQUcsQ0FBQ2piLE1BQUosQ0FBVyxDQUFYLENBQWMsQ0FBZCxDQUFELENBQW1CLEVBQW5CLENBQWpCLENBQ0EsR0FBSXdiLEdBQUUsQ0FBRyxDQUFULENBRUE7QUFDQSxHQUFHUCxHQUFHLENBQUNoaUIsTUFBSixDQUFhLEVBQWhCLENBQW9CLENBQ2xCO0FBQ0EsR0FBSXNLLEVBQUMsQ0FBRzBYLEdBQUcsQ0FBQ25OLE1BQUosQ0FBVyxFQUFYLENBQVIsQ0FDQSxHQUFJNEcsSUFBRyxDQUFHLEVBQVYsQ0FFQTtBQUNBLEdBQUduUixDQUFDLEdBQUssR0FBTixFQUFhQSxDQUFDLEdBQUssR0FBdEIsQ0FBMkIsQ0FDekI7QUFDQWlZLEVBQUUsQ0FBR3ZPLFFBQVEsQ0FBQ2dPLEdBQUcsQ0FBQ2piLE1BQUosQ0FBVyxFQUFYLENBQWUsQ0FBZixDQUFELENBQW9CLEVBQXBCLENBQWIsQ0FDQTBVLEdBQUcsRUFBSSxDQUFQLENBQ0QsQ0FDRixDQUVEO0FBQ0F3RyxJQUFJLENBQUNPLGNBQUwsQ0FBb0JOLElBQXBCLENBQTBCQyxFQUExQixDQUE4QkMsRUFBOUIsRUFDQUgsSUFBSSxDQUFDUSxXQUFMLENBQWlCSixFQUFqQixDQUFxQkMsRUFBckIsQ0FBeUJDLEVBQXpCLENBQTZCLENBQTdCLEVBRUEsR0FBRzlHLEdBQUgsQ0FBUSxDQUNOO0FBQ0FuUixDQUFDLENBQUcwWCxHQUFHLENBQUNuTixNQUFKLENBQVc0RyxHQUFYLENBQUosQ0FDQSxHQUFHblIsQ0FBQyxHQUFLLEdBQU4sRUFBYUEsQ0FBQyxHQUFLLEdBQXRCLENBQTJCLENBQ3pCO0FBQ0EsR0FBSW9ZLFNBQVEsQ0FBRzFPLFFBQVEsQ0FBQ2dPLEdBQUcsQ0FBQ2piLE1BQUosQ0FBVzBVLEdBQUcsQ0FBRyxDQUFqQixDQUFvQixDQUFwQixDQUFELENBQXlCLEVBQXpCLENBQXZCLENBQ0EsR0FBSWtILFNBQVEsQ0FBRzNPLFFBQVEsQ0FBQ2dPLEdBQUcsQ0FBQ2piLE1BQUosQ0FBVzBVLEdBQUcsQ0FBRyxDQUFqQixDQUFvQixDQUFwQixDQUFELENBQXlCLEVBQXpCLENBQXZCLENBRUE7QUFDQSxHQUFJakcsT0FBTSxDQUFHa04sUUFBUSxDQUFHLEVBQVgsQ0FBZ0JDLFFBQTdCLENBQ0FuTixNQUFNLEVBQUksS0FBVixDQUVBO0FBQ0EsR0FBR2xMLENBQUMsR0FBSyxHQUFULENBQWMsQ0FDWjJYLElBQUksQ0FBQ1csT0FBTCxDQUFhLENBQUNYLElBQUQsQ0FBUXpNLE1BQXJCLEVBQ0QsQ0FGRCxJQUVPLENBQ0x5TSxJQUFJLENBQUNXLE9BQUwsQ0FBYSxDQUFDWCxJQUFELENBQVF6TSxNQUFyQixFQUNELENBQ0YsQ0FDRixDQUVELE1BQU95TSxLQUFQLENBQ0QsQ0F6RUQsQ0EyRUE7Ozs7OztHQU9BekUsSUFBSSxDQUFDcUYscUJBQUwsQ0FBNkIsU0FBU0MsT0FBVCxDQUFrQixDQUM3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0VBd0JBLEdBQUliLEtBQUksQ0FBRyxHQUFJalYsS0FBSixFQUFYLENBRUEsR0FBSStWLEtBQUksQ0FBRy9PLFFBQVEsQ0FBQzhPLE9BQU8sQ0FBQy9iLE1BQVIsQ0FBZSxDQUFmLENBQWtCLENBQWxCLENBQUQsQ0FBdUIsRUFBdkIsQ0FBbkIsQ0FDQSxHQUFJb2IsR0FBRSxDQUFHbk8sUUFBUSxDQUFDOE8sT0FBTyxDQUFDL2IsTUFBUixDQUFlLENBQWYsQ0FBa0IsQ0FBbEIsQ0FBRCxDQUF1QixFQUF2QixDQUFSLENBQXFDLENBQTlDLENBQWlEO0FBQ2pELEdBQUlxYixHQUFFLENBQUdwTyxRQUFRLENBQUM4TyxPQUFPLENBQUMvYixNQUFSLENBQWUsQ0FBZixDQUFrQixDQUFsQixDQUFELENBQXVCLEVBQXZCLENBQWpCLENBQ0EsR0FBSXNiLEdBQUUsQ0FBR3JPLFFBQVEsQ0FBQzhPLE9BQU8sQ0FBQy9iLE1BQVIsQ0FBZSxDQUFmLENBQWtCLENBQWxCLENBQUQsQ0FBdUIsRUFBdkIsQ0FBakIsQ0FDQSxHQUFJdWIsR0FBRSxDQUFHdE8sUUFBUSxDQUFDOE8sT0FBTyxDQUFDL2IsTUFBUixDQUFlLEVBQWYsQ0FBbUIsQ0FBbkIsQ0FBRCxDQUF3QixFQUF4QixDQUFqQixDQUNBLEdBQUl3YixHQUFFLENBQUd2TyxRQUFRLENBQUM4TyxPQUFPLENBQUMvYixNQUFSLENBQWUsRUFBZixDQUFtQixDQUFuQixDQUFELENBQXdCLEVBQXhCLENBQWpCLENBQ0EsR0FBSWljLElBQUcsQ0FBRyxDQUFWLENBQ0EsR0FBSXhOLE9BQU0sQ0FBRyxDQUFiLENBQ0EsR0FBSXlOLE1BQUssQ0FBRyxLQUFaLENBRUEsR0FBR0gsT0FBTyxDQUFDak8sTUFBUixDQUFlaU8sT0FBTyxDQUFDOWlCLE1BQVIsQ0FBaUIsQ0FBaEMsSUFBdUMsR0FBMUMsQ0FBK0MsQ0FDN0NpakIsS0FBSyxDQUFHLElBQVIsQ0FDRCxDQUVELEdBQUl4SCxJQUFHLENBQUdxSCxPQUFPLENBQUM5aUIsTUFBUixDQUFpQixDQUEzQixDQUE4QnNLLENBQUMsQ0FBR3dZLE9BQU8sQ0FBQ2pPLE1BQVIsQ0FBZTRHLEdBQWYsQ0FBbEMsQ0FDQSxHQUFHblIsQ0FBQyxHQUFLLEdBQU4sRUFBYUEsQ0FBQyxHQUFLLEdBQXRCLENBQTJCLENBQ3pCO0FBQ0EsR0FBSW9ZLFNBQVEsQ0FBRzFPLFFBQVEsQ0FBQzhPLE9BQU8sQ0FBQy9iLE1BQVIsQ0FBZTBVLEdBQUcsQ0FBRyxDQUFyQixDQUF3QixDQUF4QixDQUFELENBQTZCLEVBQTdCLENBQXZCLENBQ0EsR0FBSWtILFNBQVEsQ0FBRzNPLFFBQVEsQ0FBQzhPLE9BQU8sQ0FBQy9iLE1BQVIsQ0FBZTBVLEdBQUcsQ0FBRyxDQUFyQixDQUF3QixDQUF4QixDQUFELENBQTZCLEVBQTdCLENBQXZCLENBRUE7QUFDQWpHLE1BQU0sQ0FBR2tOLFFBQVEsQ0FBRyxFQUFYLENBQWdCQyxRQUF6QixDQUNBbk4sTUFBTSxFQUFJLEtBQVYsQ0FFQTtBQUNBLEdBQUdsTCxDQUFDLEdBQUssR0FBVCxDQUFjLENBQ1prTCxNQUFNLEVBQUksQ0FBQyxDQUFYLENBQ0QsQ0FFRHlOLEtBQUssQ0FBRyxJQUFSLENBQ0QsQ0FFRDtBQUNBLEdBQUdILE9BQU8sQ0FBQ2pPLE1BQVIsQ0FBZSxFQUFmLElBQXVCLEdBQTFCLENBQStCLENBQzdCbU8sR0FBRyxDQUFHRSxVQUFVLENBQUNKLE9BQU8sQ0FBQy9iLE1BQVIsQ0FBZSxFQUFmLENBQUQsQ0FBcUIsRUFBckIsQ0FBVixDQUFxQyxJQUEzQyxDQUNELENBRUQsR0FBR2tjLEtBQUgsQ0FBVSxDQUNSaEIsSUFBSSxDQUFDTyxjQUFMLENBQW9CTyxJQUFwQixDQUEwQlosRUFBMUIsQ0FBOEJDLEVBQTlCLEVBQ0FILElBQUksQ0FBQ1EsV0FBTCxDQUFpQkosRUFBakIsQ0FBcUJDLEVBQXJCLENBQXlCQyxFQUF6QixDQUE2QlMsR0FBN0IsRUFFQTtBQUNBZixJQUFJLENBQUNXLE9BQUwsQ0FBYSxDQUFDWCxJQUFELENBQVF6TSxNQUFyQixFQUNELENBTkQsSUFNTyxDQUNMeU0sSUFBSSxDQUFDa0IsV0FBTCxDQUFpQkosSUFBakIsQ0FBdUJaLEVBQXZCLENBQTJCQyxFQUEzQixFQUNBSCxJQUFJLENBQUNtQixRQUFMLENBQWNmLEVBQWQsQ0FBa0JDLEVBQWxCLENBQXNCQyxFQUF0QixDQUEwQlMsR0FBMUIsRUFDRCxDQUVELE1BQU9mLEtBQVAsQ0FDRCxDQTVFRCxDQThFQTs7Ozs7Ozs7OztHQVdBekUsSUFBSSxDQUFDNkYsYUFBTCxDQUFxQixTQUFTcEIsSUFBVCxDQUFlLENBQ2xDO0FBQ0EsR0FBRyxNQUFPQSxLQUFQLEdBQWdCLFFBQW5CLENBQTZCLENBQzNCLE1BQU9BLEtBQVAsQ0FDRCxDQUVELEdBQUkzUixLQUFJLENBQUcsRUFBWCxDQUVBO0FBQ0EsR0FBSXdKLE9BQU0sQ0FBRyxFQUFiLENBQ0FBLE1BQU0sQ0FBQ2xOLElBQVAsQ0FBWSxDQUFDLEdBQUtxVixJQUFJLENBQUNxQixjQUFMLEVBQU4sRUFBNkJ2YyxNQUE3QixDQUFvQyxDQUFwQyxDQUFaLEVBQ0ErUyxNQUFNLENBQUNsTixJQUFQLENBQVksSUFBTXFWLElBQUksQ0FBQ3NCLFdBQUwsR0FBcUIsQ0FBM0IsQ0FBWixFQUNBekosTUFBTSxDQUFDbE4sSUFBUCxDQUFZLEdBQUtxVixJQUFJLENBQUN1QixVQUFMLEVBQWpCLEVBQ0ExSixNQUFNLENBQUNsTixJQUFQLENBQVksR0FBS3FWLElBQUksQ0FBQ3dCLFdBQUwsRUFBakIsRUFDQTNKLE1BQU0sQ0FBQ2xOLElBQVAsQ0FBWSxHQUFLcVYsSUFBSSxDQUFDeUIsYUFBTCxFQUFqQixFQUNBNUosTUFBTSxDQUFDbE4sSUFBUCxDQUFZLEdBQUtxVixJQUFJLENBQUMwQixhQUFMLEVBQWpCLEVBRUE7QUFDQSxJQUFJLEdBQUl6WixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUc0UCxNQUFNLENBQUM5WixNQUExQixDQUFrQyxFQUFFa0ssQ0FBcEMsQ0FBdUMsQ0FDckMsR0FBRzRQLE1BQU0sQ0FBQzVQLENBQUQsQ0FBTixDQUFVbEssTUFBVixDQUFtQixDQUF0QixDQUF5QixDQUN2QnNRLElBQUksRUFBSSxHQUFSLENBQ0QsQ0FDREEsSUFBSSxFQUFJd0osTUFBTSxDQUFDNVAsQ0FBRCxDQUFkLENBQ0QsQ0FDRG9HLElBQUksRUFBSSxHQUFSLENBRUEsTUFBT0EsS0FBUCxDQUNELENBM0JELENBNkJBOzs7Ozs7R0FPQWtOLElBQUksQ0FBQ29HLHFCQUFMLENBQTZCLFNBQVMzQixJQUFULENBQWUsQ0FDMUM7QUFDQSxHQUFHLE1BQU9BLEtBQVAsR0FBZ0IsUUFBbkIsQ0FBNkIsQ0FDM0IsTUFBT0EsS0FBUCxDQUNELENBRUQsR0FBSTNSLEtBQUksQ0FBRyxFQUFYLENBRUE7QUFDQSxHQUFJd0osT0FBTSxDQUFHLEVBQWIsQ0FDQUEsTUFBTSxDQUFDbE4sSUFBUCxDQUFZLEdBQUtxVixJQUFJLENBQUNxQixjQUFMLEVBQWpCLEVBQ0F4SixNQUFNLENBQUNsTixJQUFQLENBQVksSUFBTXFWLElBQUksQ0FBQ3NCLFdBQUwsR0FBcUIsQ0FBM0IsQ0FBWixFQUNBekosTUFBTSxDQUFDbE4sSUFBUCxDQUFZLEdBQUtxVixJQUFJLENBQUN1QixVQUFMLEVBQWpCLEVBQ0ExSixNQUFNLENBQUNsTixJQUFQLENBQVksR0FBS3FWLElBQUksQ0FBQ3dCLFdBQUwsRUFBakIsRUFDQTNKLE1BQU0sQ0FBQ2xOLElBQVAsQ0FBWSxHQUFLcVYsSUFBSSxDQUFDeUIsYUFBTCxFQUFqQixFQUNBNUosTUFBTSxDQUFDbE4sSUFBUCxDQUFZLEdBQUtxVixJQUFJLENBQUMwQixhQUFMLEVBQWpCLEVBRUE7QUFDQSxJQUFJLEdBQUl6WixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUc0UCxNQUFNLENBQUM5WixNQUExQixDQUFrQyxFQUFFa0ssQ0FBcEMsQ0FBdUMsQ0FDckMsR0FBRzRQLE1BQU0sQ0FBQzVQLENBQUQsQ0FBTixDQUFVbEssTUFBVixDQUFtQixDQUF0QixDQUF5QixDQUN2QnNRLElBQUksRUFBSSxHQUFSLENBQ0QsQ0FDREEsSUFBSSxFQUFJd0osTUFBTSxDQUFDNVAsQ0FBRCxDQUFkLENBQ0QsQ0FDRG9HLElBQUksRUFBSSxHQUFSLENBRUEsTUFBT0EsS0FBUCxDQUNELENBM0JELENBNkJBOzs7Ozs7O0dBUUFrTixJQUFJLENBQUNxRyxZQUFMLENBQW9CLFNBQVNoVyxDQUFULENBQVksQ0FDOUIsR0FBSXlDLEtBQUksQ0FBR3hJLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBWCxDQUNBLEdBQUd4RCxDQUFDLEVBQUksQ0FBQyxJQUFOLEVBQWNBLENBQUMsQ0FBRyxJQUFyQixDQUEyQixDQUN6QixNQUFPeUMsS0FBSSxDQUFDTixZQUFMLENBQWtCbkMsQ0FBbEIsQ0FBcUIsQ0FBckIsQ0FBUCxDQUNELENBQ0QsR0FBR0EsQ0FBQyxFQUFJLENBQUMsTUFBTixFQUFnQkEsQ0FBQyxDQUFHLE1BQXZCLENBQStCLENBQzdCLE1BQU95QyxLQUFJLENBQUNOLFlBQUwsQ0FBa0JuQyxDQUFsQixDQUFxQixFQUFyQixDQUFQLENBQ0QsQ0FDRCxHQUFHQSxDQUFDLEVBQUksQ0FBQyxRQUFOLEVBQWtCQSxDQUFDLENBQUcsUUFBekIsQ0FBbUMsQ0FDakMsTUFBT3lDLEtBQUksQ0FBQ04sWUFBTCxDQUFrQm5DLENBQWxCLENBQXFCLEVBQXJCLENBQVAsQ0FDRCxDQUNELEdBQUdBLENBQUMsRUFBSSxDQUFDLFVBQU4sRUFBb0JBLENBQUMsQ0FBRyxVQUEzQixDQUF1QyxDQUNyQyxNQUFPeUMsS0FBSSxDQUFDTixZQUFMLENBQWtCbkMsQ0FBbEIsQ0FBcUIsRUFBckIsQ0FBUCxDQUNELENBQ0QsR0FBSTdMLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLG9DQUFWLENBQVosQ0FDQWtDLEtBQUssQ0FBQzhoQixPQUFOLENBQWdCalcsQ0FBaEIsQ0FDQSxLQUFNN0wsTUFBTixDQUNELENBakJELENBbUJBOzs7Ozs7O0dBUUF3YixJQUFJLENBQUN1RyxZQUFMLENBQW9CLFNBQVMxVSxLQUFULENBQWdCLENBQ2xDO0FBQ0EsR0FBRyxNQUFPQSxNQUFQLEdBQWlCLFFBQXBCLENBQThCLENBQzVCQSxLQUFLLENBQUd2SCxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCaEMsS0FBeEIsQ0FBUixDQUNELENBRUQsR0FBSXhFLEVBQUMsQ0FBR3dFLEtBQUssQ0FBQ3JQLE1BQU4sR0FBaUIsQ0FBekIsQ0FDQSxHQUFHNkssQ0FBQyxDQUFHLEVBQVAsQ0FBVyxDQUNULEtBQU0sSUFBSS9LLE1BQUosQ0FBVSxvQ0FBVixDQUFOLENBQ0QsQ0FDRCxNQUFPdVAsTUFBSyxDQUFDd0IsWUFBTixDQUFtQmhHLENBQW5CLENBQVAsQ0FDRCxDQVhELENBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1QkEyUyxJQUFJLENBQUN3RyxRQUFMLENBQWdCLFNBQVM3TixHQUFULENBQWM4TixDQUFkLENBQWlCQyxPQUFqQixDQUEwQi9lLE1BQTFCLENBQWtDLENBQ2hELEdBQUltTCxLQUFJLENBQUcsS0FBWCxDQUVBO0FBQ0EsR0FBRyxDQUFDNkYsR0FBRyxDQUFDaUosUUFBSixHQUFpQjZFLENBQUMsQ0FBQzdFLFFBQW5CLEVBQStCLE1BQU82RSxFQUFDLENBQUM3RSxRQUFULEdBQXVCLFdBQXZELElBQ0FqSixHQUFHLENBQUNVLElBQUosR0FBYW9OLENBQUMsQ0FBQ3BOLElBQWYsRUFBdUIsTUFBT29OLEVBQUMsQ0FBQ3BOLElBQVQsR0FBbUIsV0FEMUMsQ0FBSCxDQUMyRCxDQUN6RDtBQUNBLEdBQUdWLEdBQUcsQ0FBQ2tKLFdBQUosR0FBb0I0RSxDQUFDLENBQUM1RSxXQUF0QixFQUNELE1BQU80RSxFQUFDLENBQUM1RSxXQUFULEdBQTBCLFdBRDVCLENBQ3lDLENBQ3ZDL08sSUFBSSxDQUFHLElBQVAsQ0FFQTtBQUNBLEdBQUcyVCxDQUFDLENBQUN2SyxLQUFGLEVBQVc1UixLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1CcVcsQ0FBQyxDQUFDdkssS0FBckIsQ0FBZCxDQUEyQyxDQUN6QyxHQUFJaEUsRUFBQyxDQUFHLENBQVIsQ0FDQSxJQUFJLEdBQUl4TCxFQUFDLENBQUcsQ0FBWixDQUFlb0csSUFBSSxFQUFJcEcsQ0FBQyxDQUFHK1osQ0FBQyxDQUFDdkssS0FBRixDQUFRMVosTUFBbkMsQ0FBMkMsRUFBRWtLLENBQTdDLENBQWdELENBQzlDb0csSUFBSSxDQUFHMlQsQ0FBQyxDQUFDdkssS0FBRixDQUFReFAsQ0FBUixFQUFXaWEsUUFBWCxFQUF1QixLQUE5QixDQUNBLEdBQUdoTyxHQUFHLENBQUN1RCxLQUFKLENBQVVoRSxDQUFWLENBQUgsQ0FBaUIsQ0FDZnBGLElBQUksQ0FBR2tOLElBQUksQ0FBQ3dHLFFBQUwsQ0FBYzdOLEdBQUcsQ0FBQ3VELEtBQUosQ0FBVWhFLENBQVYsQ0FBZCxDQUE0QnVPLENBQUMsQ0FBQ3ZLLEtBQUYsQ0FBUXhQLENBQVIsQ0FBNUIsQ0FBd0NnYSxPQUF4QyxDQUFpRC9lLE1BQWpELENBQVAsQ0FDQSxHQUFHbUwsSUFBSCxDQUFTLENBQ1AsRUFBRW9GLENBQUYsQ0FDRCxDQUZELElBRU8sSUFBR3VPLENBQUMsQ0FBQ3ZLLEtBQUYsQ0FBUXhQLENBQVIsRUFBV2lhLFFBQWQsQ0FBd0IsQ0FDN0I3VCxJQUFJLENBQUcsSUFBUCxDQUNELENBQ0YsQ0FDRCxHQUFHLENBQUNBLElBQUQsRUFBU25MLE1BQVosQ0FBb0IsQ0FDbEJBLE1BQU0sQ0FBQ3lILElBQVAsQ0FDRSxJQUFNcVgsQ0FBQyxDQUFDdmQsSUFBUixDQUFlLElBQWYsQ0FDQSxhQURBLENBQ2dCdWQsQ0FBQyxDQUFDN0UsUUFEbEIsQ0FDNkIsV0FEN0IsQ0FFQTZFLENBQUMsQ0FBQ3BOLElBRkYsQ0FFUywyQkFGVCxDQUdBb04sQ0FBQyxDQUFDdkssS0FBRixDQUFRMVosTUFIUixDQUdpQixVQUhqQixDQUlBbVcsR0FBRyxDQUFDdUQsS0FBSixDQUFVMVosTUFKVixDQUltQixHQUxyQixFQU1ELENBQ0YsQ0FDRixDQUVELEdBQUdzUSxJQUFJLEVBQUk0VCxPQUFYLENBQW9CLENBQ2xCLEdBQUdELENBQUMsQ0FBQ0MsT0FBTCxDQUFjLENBQ1pBLE9BQU8sQ0FBQ0QsQ0FBQyxDQUFDQyxPQUFILENBQVAsQ0FBcUIvTixHQUFHLENBQUN1RCxLQUF6QixDQUNELENBQ0QsR0FBR3VLLENBQUMsQ0FBQ0csV0FBTCxDQUFrQixDQUNoQkYsT0FBTyxDQUFDRCxDQUFDLENBQUNHLFdBQUgsQ0FBUCxDQUF5QmpPLEdBQXpCLENBQ0QsQ0FDRCxHQUFHOE4sQ0FBQyxDQUFDSSx3QkFBRixFQUE4QixxQkFBdUJsTyxJQUF4RCxDQUE2RCxDQUMzRCtOLE9BQU8sQ0FBQ0QsQ0FBQyxDQUFDSSx3QkFBSCxDQUFQLENBQXNDbE8sR0FBRyxDQUFDcUosaUJBQTFDLENBQ0QsQ0FDRCxHQUFHeUUsQ0FBQyxDQUFDSyxxQkFBRixFQUEyQixxQkFBdUJuTyxJQUFyRCxDQUEwRCxDQUN4RCxHQUFJdUQsTUFBSixDQUNBLEdBQUd2RCxHQUFHLENBQUNxSixpQkFBSixDQUFzQnhmLE1BQXRCLENBQStCLENBQWxDLENBQXFDLENBQ25Da2tCLE9BQU8sQ0FBQ0QsQ0FBQyxDQUFDSyxxQkFBSCxDQUFQLENBQW1DLEVBQW5DLENBQ0QsQ0FGRCxJQUVPLENBQ0w7QUFDQSxHQUFJckQsT0FBTSxDQUFHOUssR0FBRyxDQUFDcUosaUJBQUosQ0FBc0JwUCxVQUF0QixDQUFpQyxDQUFqQyxDQUFiLENBQ0EsR0FBRzZRLE1BQU0sR0FBSyxDQUFkLENBQWlCLENBQ2YsS0FBTSxJQUFJbmhCLE1BQUosQ0FDSiwyREFESSxDQUFOLENBRUQsQ0FDRG9rQixPQUFPLENBQUNELENBQUMsQ0FBQ0sscUJBQUgsQ0FBUCxDQUFtQ25PLEdBQUcsQ0FBQ3FKLGlCQUFKLENBQXNCOVMsS0FBdEIsQ0FBNEIsQ0FBNUIsQ0FBbkMsQ0FDRCxDQUNGLENBQ0YsQ0FDRixDQXJERCxJQXFETyxJQUFHdkgsTUFBSCxDQUFXLENBQ2hCQSxNQUFNLENBQUN5SCxJQUFQLENBQ0UsSUFBTXFYLENBQUMsQ0FBQ3ZkLElBQVIsQ0FBZSxJQUFmLENBQ0Esd0JBREEsQ0FDMkJ1ZCxDQUFDLENBQUM1RSxXQUQ3QixDQUMyQyxVQUQzQyxDQUVBbEosR0FBRyxDQUFDa0osV0FGSixDQUVrQixHQUhwQixFQUlELENBQ0YsQ0E5REQsSUE4RE8sSUFBR2xhLE1BQUgsQ0FBVyxDQUNoQixHQUFHZ1IsR0FBRyxDQUFDaUosUUFBSixHQUFpQjZFLENBQUMsQ0FBQzdFLFFBQXRCLENBQWdDLENBQzlCamEsTUFBTSxDQUFDeUgsSUFBUCxDQUNFLElBQU1xWCxDQUFDLENBQUN2ZCxJQUFSLENBQWUsSUFBZixDQUNBLHNCQURBLENBQ3lCdWQsQ0FBQyxDQUFDN0UsUUFEM0IsQ0FDc0MsVUFEdEMsQ0FFQWpKLEdBQUcsQ0FBQ2lKLFFBRkosQ0FFZSxHQUhqQixFQUlELENBQ0QsR0FBR2pKLEdBQUcsQ0FBQ1UsSUFBSixHQUFhb04sQ0FBQyxDQUFDcE4sSUFBbEIsQ0FBd0IsQ0FDdEIxUixNQUFNLENBQUN5SCxJQUFQLENBQ0UsSUFBTXFYLENBQUMsQ0FBQ3ZkLElBQVIsQ0FBZSxJQUFmLENBQ0EsaUJBREEsQ0FDb0J1ZCxDQUFDLENBQUNwTixJQUR0QixDQUM2QixVQUQ3QixDQUMwQ1YsR0FBRyxDQUFDVSxJQUQ5QyxDQUNxRCxHQUZ2RCxFQUdELENBQ0YsQ0FDRCxNQUFPdkcsS0FBUCxDQUNELENBaEZELENBa0ZBO0FBQ0EsR0FBSWlVLGVBQWMsQ0FBRyxvQkFBckIsQ0FFQTs7Ozs7Ozs7R0FTQS9HLElBQUksQ0FBQ2dILFdBQUwsQ0FBbUIsU0FBU3JPLEdBQVQsQ0FBY3NPLEtBQWQsQ0FBcUJDLFdBQXJCLENBQWtDLENBQ25ELEdBQUlwVSxLQUFJLENBQUcsRUFBWCxDQUVBO0FBQ0FtVSxLQUFLLENBQUdBLEtBQUssRUFBSSxDQUFqQixDQUNBQyxXQUFXLENBQUdBLFdBQVcsRUFBSSxDQUE3QixDQUVBO0FBQ0EsR0FBR0QsS0FBSyxDQUFHLENBQVgsQ0FBYyxDQUNablUsSUFBSSxFQUFJLElBQVIsQ0FDRCxDQUVEO0FBQ0EsR0FBSXFVLE9BQU0sQ0FBRyxFQUFiLENBQ0EsSUFBSSxHQUFJemEsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHdWEsS0FBSyxDQUFHQyxXQUEzQixDQUF3QyxFQUFFeGEsQ0FBMUMsQ0FBNkMsQ0FDM0N5YSxNQUFNLEVBQUksR0FBVixDQUNELENBRUQ7QUFDQXJVLElBQUksRUFBSXFVLE1BQU0sQ0FBRyxPQUFqQixDQUNBLE9BQU94TyxHQUFHLENBQUNpSixRQUFYLEVBQ0EsSUFBSzVCLEtBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUFoQixDQUNFcE4sSUFBSSxFQUFJLFlBQVIsQ0FDQSxNQUNGLElBQUtrTixLQUFJLENBQUNDLEtBQUwsQ0FBV0UsV0FBaEIsQ0FDRXJOLElBQUksRUFBSSxjQUFSLENBQ0EsTUFDRixJQUFLa04sS0FBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUFoQixDQUNFdE4sSUFBSSxFQUFJLG1CQUFSLENBQ0EsTUFDRixJQUFLa04sS0FBSSxDQUFDQyxLQUFMLENBQVdJLE9BQWhCLENBQ0V2TixJQUFJLEVBQUksVUFBUixDQUNBLE1BWkYsQ0FlQSxHQUFHNkYsR0FBRyxDQUFDaUosUUFBSixHQUFpQjVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUEvQixDQUEwQyxDQUN4Q3BOLElBQUksRUFBSTZGLEdBQUcsQ0FBQ1UsSUFBWixDQUVBO0FBQ0EsT0FBT1YsR0FBRyxDQUFDVSxJQUFYLEVBQ0EsSUFBSzJHLEtBQUksQ0FBQ00sSUFBTCxDQUFVQyxJQUFmLENBQ0V6TixJQUFJLEVBQUksU0FBUixDQUNBLE1BQ0YsSUFBS2tOLEtBQUksQ0FBQ00sSUFBTCxDQUFVRSxPQUFmLENBQ0UxTixJQUFJLEVBQUksWUFBUixDQUNBLE1BQ0YsSUFBS2tOLEtBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUFmLENBQ0UzTixJQUFJLEVBQUksWUFBUixDQUNBLE1BQ0YsSUFBS2tOLEtBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUFmLENBQ0U1TixJQUFJLEVBQUksZUFBUixDQUNBLE1BQ0YsSUFBS2tOLEtBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUFmLENBQ0U3TixJQUFJLEVBQUksaUJBQVIsQ0FDQSxNQUNGLElBQUtrTixLQUFJLENBQUNNLElBQUwsQ0FBVU0sSUFBZixDQUNFOU4sSUFBSSxFQUFJLFNBQVIsQ0FDQSxNQUNGLElBQUtrTixLQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBZixDQUNFL04sSUFBSSxFQUFJLHNCQUFSLENBQ0EsTUFDRixJQUFLa04sS0FBSSxDQUFDTSxJQUFMLENBQVVRLEtBQWYsQ0FDRWhPLElBQUksRUFBSSxzQkFBUixDQUNBLE1BQ0YsSUFBS2tOLEtBQUksQ0FBQ00sSUFBTCxDQUFVUyxRQUFmLENBQ0VqTyxJQUFJLEVBQUksNEJBQVIsQ0FDQSxNQUNGLElBQUtrTixLQUFJLENBQUNNLElBQUwsQ0FBVVUsSUFBZixDQUNFbE8sSUFBSSxFQUFJLFNBQVIsQ0FDQSxNQUNGLElBQUtrTixLQUFJLENBQUNNLElBQUwsQ0FBVVcsVUFBZixDQUNFbk8sSUFBSSxFQUFJLGVBQVIsQ0FDQSxNQUNGLElBQUtrTixLQUFJLENBQUNNLElBQUwsQ0FBVVksUUFBZixDQUNFcE8sSUFBSSxFQUFJLGlCQUFSLENBQ0EsTUFDRixJQUFLa04sS0FBSSxDQUFDTSxJQUFMLENBQVVhLElBQWYsQ0FDRXJPLElBQUksRUFBSSxTQUFSLENBQ0EsTUFDRixJQUFLa04sS0FBSSxDQUFDTSxJQUFMLENBQVVjLElBQWYsQ0FDRXRPLElBQUksRUFBSSwrQkFBUixDQUNBLE1BQ0YsSUFBS2tOLEtBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUFmLENBQ0V2TyxJQUFJLEVBQUksYUFBUixDQUNBLE1BQ0YsSUFBS2tOLEtBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FBZixDQUNFeE8sSUFBSSxFQUFJLFFBQVIsQ0FDQSxNQUNGLElBQUtrTixLQUFJLENBQUNNLElBQUwsQ0FBVWlCLGVBQWYsQ0FDRXpPLElBQUksRUFBSSxxQkFBUixDQUNBLE1BQ0YsSUFBS2tOLEtBQUksQ0FBQ00sSUFBTCxDQUFVOEcsU0FBZixDQUNFdFUsSUFBSSxFQUFJLHNCQUFSLENBQ0EsTUFDRixJQUFLa04sS0FBSSxDQUFDTSxJQUFMLENBQVVtQixPQUFmLENBQ0UzTyxJQUFJLEVBQUksYUFBUixDQUNBLE1BQ0YsSUFBS2tOLEtBQUksQ0FBQ00sSUFBTCxDQUFVb0IsZUFBZixDQUNFNU8sSUFBSSxFQUFJLHFCQUFSLENBQ0EsTUFDRixJQUFLa04sS0FBSSxDQUFDTSxJQUFMLENBQVVxQixTQUFmLENBQ0U3TyxJQUFJLEVBQUksZUFBUixDQUNBLE1BL0RGLENBaUVELENBckVELElBcUVPLENBQ0xBLElBQUksRUFBSTZGLEdBQUcsQ0FBQ1UsSUFBWixDQUNELENBRUR2RyxJQUFJLEVBQUksSUFBUixDQUNBQSxJQUFJLEVBQUlxVSxNQUFNLENBQUcsZUFBVCxDQUEyQnhPLEdBQUcsQ0FBQ2tKLFdBQS9CLENBQTZDLElBQXJELENBRUEsR0FBR2xKLEdBQUcsQ0FBQ29KLFFBQVAsQ0FBaUIsQ0FDZixHQUFJc0YsVUFBUyxDQUFHLENBQWhCLENBQ0EsR0FBSUMsSUFBRyxDQUFHLEVBQVYsQ0FDQSxJQUFJLEdBQUk1YSxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdpTSxHQUFHLENBQUN1RCxLQUFKLENBQVUxWixNQUE3QixDQUFxQyxFQUFFa0ssQ0FBdkMsQ0FBMEMsQ0FDeEMsR0FBR2lNLEdBQUcsQ0FBQ3VELEtBQUosQ0FBVXhQLENBQVYsSUFBaUI2QixTQUFwQixDQUErQixDQUM3QjhZLFNBQVMsRUFBSSxDQUFiLENBQ0FDLEdBQUcsRUFBSXRILElBQUksQ0FBQ2dILFdBQUwsQ0FBaUJyTyxHQUFHLENBQUN1RCxLQUFKLENBQVV4UCxDQUFWLENBQWpCLENBQStCdWEsS0FBSyxDQUFHLENBQXZDLENBQTBDQyxXQUExQyxDQUFQLENBQ0EsR0FBSXhhLENBQUMsQ0FBRyxDQUFMLENBQVVpTSxHQUFHLENBQUN1RCxLQUFKLENBQVUxWixNQUF2QixDQUErQixDQUM3QjhrQixHQUFHLEVBQUksR0FBUCxDQUNELENBQ0YsQ0FDRixDQUNEeFUsSUFBSSxFQUFJcVUsTUFBTSxDQUFHLGNBQVQsQ0FBMEJFLFNBQTFCLENBQXNDQyxHQUE5QyxDQUNELENBYkQsSUFhTyxDQUNMeFUsSUFBSSxFQUFJcVUsTUFBTSxDQUFHLFNBQWpCLENBQ0EsR0FBR3hPLEdBQUcsQ0FBQ1UsSUFBSixHQUFhMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTFCLENBQStCLENBQzdCLEdBQUlzRCxJQUFHLENBQUduRSxJQUFJLENBQUNzRSxRQUFMLENBQWMzTCxHQUFHLENBQUN1RCxLQUFsQixDQUFWLENBQ0FwSixJQUFJLEVBQUlxUixHQUFSLENBQ0EsR0FBRzdaLEtBQUssQ0FBQ1UsR0FBTixFQUFhVixLQUFLLENBQUNVLEdBQU4sQ0FBVXVjLElBQTFCLENBQWdDLENBQzlCLEdBQUdwRCxHQUFHLEdBQUk3WixNQUFLLENBQUNVLEdBQU4sQ0FBVXVjLElBQXBCLENBQTBCLENBQ3hCelUsSUFBSSxFQUFJLEtBQU94SSxLQUFLLENBQUNVLEdBQU4sQ0FBVXVjLElBQVYsQ0FBZXBELEdBQWYsQ0FBUCxDQUE2QixJQUFyQyxDQUNELENBQ0YsQ0FDRixDQUNELEdBQUd4TCxHQUFHLENBQUNVLElBQUosR0FBYTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUExQixDQUFtQyxDQUNqQyxHQUFJLENBQ0YzTixJQUFJLEVBQUlrTixJQUFJLENBQUN1RyxZQUFMLENBQWtCNU4sR0FBRyxDQUFDdUQsS0FBdEIsQ0FBUixDQUNELENBQUMsTUFBTXpDLEVBQU4sQ0FBVSxDQUNWM0csSUFBSSxFQUFJLEtBQU94SSxLQUFLLENBQUMyRCxJQUFOLENBQVd3SSxVQUFYLENBQXNCa0MsR0FBRyxDQUFDdUQsS0FBMUIsQ0FBZixDQUNELENBQ0YsQ0FORCxJQU1PLElBQUd2RCxHQUFHLENBQUNVLElBQUosR0FBYTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUExQixDQUFxQyxDQUMxQztBQUNBLEdBQUcvSCxHQUFHLENBQUN1RCxLQUFKLENBQVUxWixNQUFWLENBQW1CLENBQXRCLENBQXlCLENBQ3ZCO0FBQ0FzUSxJQUFJLEVBQUksS0FBT3hJLEtBQUssQ0FBQzJELElBQU4sQ0FBV3dJLFVBQVgsQ0FBc0JrQyxHQUFHLENBQUN1RCxLQUFKLENBQVVoTixLQUFWLENBQWdCLENBQWhCLENBQXRCLENBQWYsQ0FDRCxDQUhELElBR08sQ0FDTDRELElBQUksRUFBSSxRQUFSLENBQ0QsQ0FDRDtBQUNBLEdBQUc2RixHQUFHLENBQUN1RCxLQUFKLENBQVUxWixNQUFWLENBQW1CLENBQXRCLENBQXlCLENBQ3ZCLEdBQUlpaEIsT0FBTSxDQUFHOUssR0FBRyxDQUFDdUQsS0FBSixDQUFVdEosVUFBVixDQUFxQixDQUFyQixDQUFiLENBQ0EsR0FBRzZRLE1BQU0sRUFBSSxDQUFiLENBQWdCLENBQ2QzUSxJQUFJLEVBQUksdUJBQVIsQ0FDRCxDQUZELElBRU8sSUFBRzJRLE1BQU0sQ0FBRyxDQUFaLENBQWUsQ0FDcEIzUSxJQUFJLEVBQUksS0FBTzJRLE1BQVAsQ0FBZ0IscUJBQXhCLENBQ0QsQ0FDRixDQUNGLENBakJNLElBaUJBLElBQUc5SyxHQUFHLENBQUNVLElBQUosR0FBYTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUExQixDQUF1QyxDQUM1QyxHQUFHLENBQUNvRyxjQUFjLENBQUNTLElBQWYsQ0FBb0I3TyxHQUFHLENBQUN1RCxLQUF4QixDQUFKLENBQW9DLENBQ2xDcEosSUFBSSxFQUFJLElBQU02RixHQUFHLENBQUN1RCxLQUFWLENBQWtCLElBQTFCLENBQ0QsQ0FDRHBKLElBQUksRUFBSSxLQUFPeEksS0FBSyxDQUFDMkQsSUFBTixDQUFXd0ksVUFBWCxDQUFzQmtDLEdBQUcsQ0FBQ3VELEtBQTFCLENBQWYsQ0FDRCxDQUxNLElBS0EsSUFBR3ZELEdBQUcsQ0FBQ1UsSUFBSixHQUFhMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVhLElBQTFCLENBQWdDLENBQ3JDck8sSUFBSSxFQUFJeEksS0FBSyxDQUFDMkQsSUFBTixDQUFXaUcsVUFBWCxDQUFzQnlFLEdBQUcsQ0FBQ3VELEtBQTFCLENBQVIsQ0FDRCxDQUZNLElBRUEsSUFBR3ZELEdBQUcsQ0FBQ1UsSUFBSixHQUFhMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVpQixlQUF2QixFQUNSNUksR0FBRyxDQUFDVSxJQUFKLEdBQWEyRyxJQUFJLENBQUNNLElBQUwsQ0FBVThHLFNBRGxCLENBQzZCLENBQ2xDdFUsSUFBSSxFQUFJNkYsR0FBRyxDQUFDdUQsS0FBWixDQUNELENBSE0sSUFHQSxJQUFHNkssY0FBYyxDQUFDUyxJQUFmLENBQW9CN08sR0FBRyxDQUFDdUQsS0FBeEIsQ0FBSCxDQUFtQyxDQUN4Q3BKLElBQUksRUFBSSxLQUFPeEksS0FBSyxDQUFDMkQsSUFBTixDQUFXd0ksVUFBWCxDQUFzQmtDLEdBQUcsQ0FBQ3VELEtBQTFCLENBQWYsQ0FDRCxDQUZNLElBRUEsSUFBR3ZELEdBQUcsQ0FBQ3VELEtBQUosQ0FBVTFaLE1BQVYsR0FBcUIsQ0FBeEIsQ0FBMkIsQ0FDaENzUSxJQUFJLEVBQUksUUFBUixDQUNELENBRk0sSUFFQSxDQUNMQSxJQUFJLEVBQUk2RixHQUFHLENBQUN1RCxLQUFaLENBQ0QsQ0FDRixDQUVELE1BQU9wSixLQUFQLENBQ0QsQ0FsTEQsQ0FxTEEsS0FBTyxDQW4wSUcsQ0FvMElWLE9BcDBJVSxDQXEwSVYsS0FBTyxTQUFTM0csTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7O0dBT0EsR0FBSWxDLE1BQUssQ0FBR2tDLG1CQUFtQixDQUFDLENBQUQsQ0FBL0IsQ0FFQWxDLEtBQUssQ0FBQ1UsR0FBTixDQUFZVixLQUFLLENBQUNVLEdBQU4sRUFBYSxFQUF6QixDQUNBLEdBQUl1YyxLQUFJLENBQUdwYixNQUFNLENBQUNELE9BQVAsQ0FBaUI1QixLQUFLLENBQUNVLEdBQU4sQ0FBVXVjLElBQVYsQ0FBaUJqZCxLQUFLLENBQUNpZCxJQUFOLENBQWFqZCxLQUFLLENBQUNpZCxJQUFOLEVBQWMsRUFBeEUsQ0FFQTtBQUNBLFFBQVNFLElBQVQsQ0FBYS9PLEVBQWIsQ0FBaUJ4UCxJQUFqQixDQUF1QixDQUNyQnFlLElBQUksQ0FBQzdPLEVBQUQsQ0FBSixDQUFXeFAsSUFBWCxDQUNBcWUsSUFBSSxDQUFDcmUsSUFBRCxDQUFKLENBQWF3UCxFQUFiLENBQ0QsQ0FDRDtBQUNBLFFBQVNnUCxJQUFULENBQWFoUCxFQUFiLENBQWlCeFAsSUFBakIsQ0FBdUIsQ0FDckJxZSxJQUFJLENBQUM3TyxFQUFELENBQUosQ0FBV3hQLElBQVgsQ0FDRCxDQUVEO0FBQ0F1ZSxHQUFHLENBQUMsc0JBQUQsQ0FBeUIsZUFBekIsQ0FBSCxDQUNBO0FBQ0E7QUFDQTtBQUNBQSxHQUFHLENBQUMsc0JBQUQsQ0FBeUIsc0JBQXpCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHNCQUFELENBQXlCLHVCQUF6QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5QixZQUF6QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5QixNQUF6QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5QixZQUF6QixDQUFILENBQ0FBLEdBQUcsQ0FBQyx1QkFBRCxDQUEwQixZQUExQixDQUFILENBQ0FBLEdBQUcsQ0FBQyx1QkFBRCxDQUEwQix5QkFBMUIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsdUJBQUQsQ0FBMEIseUJBQTFCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHVCQUFELENBQTBCLHlCQUExQixDQUFILENBRUFBLEdBQUcsQ0FBQyxtQkFBRCxDQUFzQixlQUF0QixDQUFILENBRUFBLEdBQUcsQ0FBQyxjQUFELENBQWlCLFFBQWpCLENBQUgsQ0FFQUEsR0FBRyxDQUFDLGVBQUQsQ0FBa0IsTUFBbEIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsd0JBQUQsQ0FBMkIsUUFBM0IsQ0FBSCxDQUNBQSxHQUFHLENBQUMsd0JBQUQsQ0FBMkIsUUFBM0IsQ0FBSCxDQUNBQSxHQUFHLENBQUMsd0JBQUQsQ0FBMkIsUUFBM0IsQ0FBSCxDQUNBQSxHQUFHLENBQUMsb0JBQUQsQ0FBdUIsS0FBdkIsQ0FBSCxDQUVBO0FBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5QixNQUF6QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5QixZQUF6QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5QixlQUF6QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5Qix3QkFBekIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsc0JBQUQsQ0FBeUIsY0FBekIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsc0JBQUQsQ0FBeUIsZUFBekIsQ0FBSCxDQUVBO0FBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5QixjQUF6QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5QixrQkFBekIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsc0JBQUQsQ0FBeUIsYUFBekIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsc0JBQUQsQ0FBeUIsZUFBekIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsc0JBQUQsQ0FBeUIsYUFBekIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsc0JBQUQsQ0FBeUIsa0JBQXpCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHNCQUFELENBQXlCLG1CQUF6QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxzQkFBRCxDQUF5QixxQkFBekIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsdUJBQUQsQ0FBMEIsa0JBQTFCLENBQUgsQ0FFQUEsR0FBRyxDQUFDLHVCQUFELENBQTBCLGNBQTFCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHVCQUFELENBQTBCLFlBQTFCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHlCQUFELENBQTRCLGlCQUE1QixDQUFILENBRUE7QUFDQUEsR0FBRyxDQUFDLDRCQUFELENBQStCLFFBQS9CLENBQUgsQ0FDQUEsR0FBRyxDQUFDLDRCQUFELENBQStCLHFCQUEvQixDQUFILENBQ0FBLEdBQUcsQ0FBQyw0QkFBRCxDQUErQixTQUEvQixDQUFILENBQ0FBLEdBQUcsQ0FBQyw0QkFBRCxDQUErQixRQUEvQixDQUFILENBQ0FBLEdBQUcsQ0FBQyw0QkFBRCxDQUErQixXQUEvQixDQUFILENBQ0FBLEdBQUcsQ0FBQyw0QkFBRCxDQUErQixpQkFBL0IsQ0FBSCxDQUVBO0FBQ0FBLEdBQUcsQ0FBQyx1QkFBRCxDQUEwQixZQUExQixDQUFILENBQ0FBLEdBQUcsQ0FBQyx1QkFBRCxDQUEwQixhQUExQixDQUFILENBRUFBLEdBQUcsQ0FBQyx5QkFBRCxDQUE0Qix3QkFBNUIsQ0FBSCxDQUNBQSxHQUFHLENBQUMseUJBQUQsQ0FBNEIsdUJBQTVCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHlCQUFELENBQTRCLGlDQUE1QixDQUFILENBQ0FBLEdBQUcsQ0FBQyx5QkFBRCxDQUE0QixpQ0FBNUIsQ0FBSCxDQUNBQSxHQUFHLENBQUMseUJBQUQsQ0FBNEIsNEJBQTVCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHlCQUFELENBQTRCLDJCQUE1QixDQUFILENBRUE7QUFDQUEsR0FBRyxDQUFDLG9CQUFELENBQXVCLGNBQXZCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLG9CQUFELENBQXVCLGdCQUF2QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxvQkFBRCxDQUF1QixnQkFBdkIsQ0FBSCxDQUNBQSxHQUFHLENBQUMscUJBQUQsQ0FBd0IsZ0JBQXhCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHFCQUFELENBQXdCLGdCQUF4QixDQUFILENBRUE7QUFDQUEsR0FBRyxDQUFDLG9CQUFELENBQXVCLGNBQXZCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHdCQUFELENBQTJCLFlBQTNCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHlCQUFELENBQTRCLFlBQTVCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLHlCQUFELENBQTRCLFlBQTVCLENBQUgsQ0FFQTtBQUNBQSxHQUFHLENBQUMsU0FBRCxDQUFZLFlBQVosQ0FBSCxDQUNBQSxHQUFHLENBQUMsU0FBRCxDQUFZLFlBQVosQ0FBSCxDQUNBQSxHQUFHLENBQUMsU0FBRCxDQUFZLGFBQVosQ0FBSCxDQUNBQSxHQUFHLENBQUMsU0FBRCxDQUFZLGNBQVosQ0FBSCxDQUNBQSxHQUFHLENBQUMsU0FBRCxDQUFZLHFCQUFaLENBQUgsQ0FDQUEsR0FBRyxDQUFDLFVBQUQsQ0FBYSxrQkFBYixDQUFILENBQ0FBLEdBQUcsQ0FBQyxVQUFELENBQWEsd0JBQWIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsVUFBRCxDQUFhLGFBQWIsQ0FBSCxDQUVBO0FBQ0FBLEdBQUcsQ0FBQyx1QkFBRCxDQUEwQixZQUExQixDQUFILENBQ0FDLEdBQUcsQ0FBQyxVQUFELENBQWEsd0JBQWIsQ0FBSCxDQUEyQztBQUMzQ0EsR0FBRyxDQUFDLFVBQUQsQ0FBYSxlQUFiLENBQUgsQ0FBa0M7QUFDbENBLEdBQUcsQ0FBQyxVQUFELENBQWEscUJBQWIsQ0FBSCxDQUF3QztBQUN4Q0EsR0FBRyxDQUFDLFVBQUQsQ0FBYSxxQkFBYixDQUFILENBQXdDO0FBQ3hDQSxHQUFHLENBQUMsVUFBRCxDQUFhLGVBQWIsQ0FBSCxDQUFrQztBQUNsQ0EsR0FBRyxDQUFDLFVBQUQsQ0FBYSxvQkFBYixDQUFILENBQXVDO0FBQ3ZDQSxHQUFHLENBQUMsVUFBRCxDQUFhLGdCQUFiLENBQUgsQ0FBbUM7QUFDbkNBLEdBQUcsQ0FBQyxVQUFELENBQWEsZUFBYixDQUFILENBQWtDO0FBQ2xDQSxHQUFHLENBQUMsVUFBRCxDQUFhLDRCQUFiLENBQUgsQ0FDQUEsR0FBRyxDQUFDLFdBQUQsQ0FBYyxrQkFBZCxDQUFILENBQXNDO0FBQ3RDQSxHQUFHLENBQUMsV0FBRCxDQUFjLGlCQUFkLENBQUgsQ0FBcUM7QUFDckNBLEdBQUcsQ0FBQyxXQUFELENBQWMsbUJBQWQsQ0FBSCxDQUF1QztBQUN2Q0EsR0FBRyxDQUFDLFdBQUQsQ0FBYyxrQkFBZCxDQUFILENBQXNDO0FBQ3RDRCxHQUFHLENBQUMsV0FBRCxDQUFjLHNCQUFkLENBQUgsQ0FDQUEsR0FBRyxDQUFDLFdBQUQsQ0FBYyxVQUFkLENBQUgsQ0FDQUMsR0FBRyxDQUFDLFdBQUQsQ0FBYyx1QkFBZCxDQUFILENBQ0FELEdBQUcsQ0FBQyxXQUFELENBQWMsZ0JBQWQsQ0FBSCxDQUNBQSxHQUFHLENBQUMsV0FBRCxDQUFjLGVBQWQsQ0FBSCxDQUNBQSxHQUFHLENBQUMsV0FBRCxDQUFjLGtCQUFkLENBQUgsQ0FDQUMsR0FBRyxDQUFDLFdBQUQsQ0FBYyxXQUFkLENBQUgsQ0FDQUEsR0FBRyxDQUFDLFdBQUQsQ0FBYyxXQUFkLENBQUgsQ0FDQUEsR0FBRyxDQUFDLFdBQUQsQ0FBYyxnQkFBZCxDQUFILENBQ0FBLEdBQUcsQ0FBQyxXQUFELENBQWMsaUJBQWQsQ0FBSCxDQUNBQSxHQUFHLENBQUMsV0FBRCxDQUFjLGdCQUFkLENBQUgsQ0FDQUEsR0FBRyxDQUFDLFdBQUQsQ0FBYyx1QkFBZCxDQUFILENBQTJDO0FBQzNDQSxHQUFHLENBQUMsV0FBRCxDQUFjLDBCQUFkLENBQUgsQ0FBOEM7QUFDOUNBLEdBQUcsQ0FBQyxXQUFELENBQWMsbUJBQWQsQ0FBSCxDQUNBQSxHQUFHLENBQUMsV0FBRCxDQUFjLDBCQUFkLENBQUgsQ0FDQUEsR0FBRyxDQUFDLFdBQUQsQ0FBYyxtQkFBZCxDQUFILENBQ0FBLEdBQUcsQ0FBQyxXQUFELENBQWMsaUJBQWQsQ0FBSCxDQUNBRCxHQUFHLENBQUMsV0FBRCxDQUFjLHVCQUFkLENBQUgsQ0FDQUEsR0FBRyxDQUFDLFdBQUQsQ0FBYyxxQkFBZCxDQUFILENBQ0FDLEdBQUcsQ0FBQyxXQUFELENBQWMsZ0JBQWQsQ0FBSCxDQUNBQSxHQUFHLENBQUMsV0FBRCxDQUFjLG1CQUFkLENBQUgsQ0FBdUM7QUFDdkNELEdBQUcsQ0FBQyxXQUFELENBQWMsd0JBQWQsQ0FBSCxDQUNBQyxHQUFHLENBQUMsV0FBRCxDQUFjLG1CQUFkLENBQUgsQ0FDQUQsR0FBRyxDQUFDLFdBQUQsQ0FBYyxhQUFkLENBQUgsQ0FDQUMsR0FBRyxDQUFDLFdBQUQsQ0FBYyxhQUFkLENBQUgsQ0FDQUEsR0FBRyxDQUFDLFdBQUQsQ0FBYyxrQkFBZCxDQUFILENBRUE7QUFDQUQsR0FBRyxDQUFDLHlCQUFELENBQTRCLGVBQTVCLENBQUgsQ0FDQUEsR0FBRyxDQUFDLG1CQUFELENBQXNCLHFCQUF0QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxtQkFBRCxDQUFzQixZQUF0QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxtQkFBRCxDQUFzQixZQUF0QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxtQkFBRCxDQUFzQixhQUF0QixDQUFILENBQ0FBLEdBQUcsQ0FBQyxtQkFBRCxDQUFzQixpQkFBdEIsQ0FBSCxDQUNBQSxHQUFHLENBQUMsbUJBQUQsQ0FBc0IsY0FBdEIsQ0FBSCxDQUdBLEtBQU8sQ0EzK0lHLENBNCtJVixPQTUrSVUsQ0E2K0lWLEtBQU8sU0FBU3RiLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7OztHQU9BLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBRUFMLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVCLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBV3JkLEtBQUssQ0FBQ3FkLEVBQU4sRUFBWSxFQUF4QyxDQUNBcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTQyxVQUFULENBQXNCdGQsS0FBSyxDQUFDcWQsRUFBTixDQUFTQyxVQUFULEVBQXVCLEVBQTdDLENBR0EsS0FBTyxDQTUvSUcsQ0E2L0lWLE9BNy9JVSxDQTgvSVYsS0FBTyxTQUFTemIsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7Ozs7Ozs7Ozs7R0FlQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBRUEsQ0FBQyxVQUFXLENBRVo7QUFDQSxHQUFHbEMsS0FBSyxDQUFDakIsTUFBTixFQUFnQmlCLEtBQUssQ0FBQ2pCLE1BQU4sQ0FBYXFKLFFBQWhDLENBQTBDLENBQ3hDdkcsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDakIsTUFBdkIsQ0FDQSxPQUNELENBRUQsQ0FBQyxTQUFTeVMsTUFBVCxDQUFpQixDQUVsQjtBQUNBLEdBQUkrTCxTQUFRLENBQUcsRUFBZixDQUNBLEdBQUlDLGlCQUFnQixDQUFHLEdBQUlwbEIsTUFBSixDQUFVLENBQVYsQ0FBdkIsQ0FDQSxHQUFJcWxCLGlCQUFnQixDQUFHemQsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUF2QixDQUNBZ1UsUUFBUSxDQUFDRyxTQUFULENBQXFCLFNBQVN6akIsR0FBVCxDQUFjLENBQ2pDO0FBQ0EsR0FBSXVkLElBQUcsQ0FBR3hYLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0J0UCxHQUF4QixDQUFWLENBQ0FBLEdBQUcsQ0FBRyxHQUFJN0IsTUFBSixDQUFVLENBQVYsQ0FBTixDQUNBNkIsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFTdWQsR0FBRyxDQUFDOU8sUUFBSixFQUFULENBQ0F6TyxHQUFHLENBQUMsQ0FBRCxDQUFILENBQVN1ZCxHQUFHLENBQUM5TyxRQUFKLEVBQVQsQ0FDQXpPLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBU3VkLEdBQUcsQ0FBQzlPLFFBQUosRUFBVCxDQUNBek8sR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFTdWQsR0FBRyxDQUFDOU8sUUFBSixFQUFULENBRUE7QUFDQSxNQUFPMUksTUFBSyxDQUFDMmQsR0FBTixDQUFVQyxVQUFWLENBQXFCM2pCLEdBQXJCLENBQTBCLEtBQTFCLENBQVAsQ0FDRCxDQVhELENBWUFzakIsUUFBUSxDQUFDTSxVQUFULENBQXNCLFNBQVNDLElBQVQsQ0FBZSxDQUNuQztBQUNBLEdBQUl0RyxJQUFHLENBQUd4WCxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCdVUsSUFBeEIsQ0FBVixDQUNBQSxJQUFJLENBQUcsR0FBSTFsQixNQUFKLENBQVUsQ0FBVixDQUFQLENBQ0EwbEIsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFVdEcsR0FBRyxDQUFDOU8sUUFBSixFQUFWLENBQ0FvVixJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVV0RyxHQUFHLENBQUM5TyxRQUFKLEVBQVYsQ0FDQW9WLElBQUksQ0FBQyxDQUFELENBQUosQ0FBVXRHLEdBQUcsQ0FBQzlPLFFBQUosRUFBVixDQUNBb1YsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFVdEcsR0FBRyxDQUFDOU8sUUFBSixFQUFWLENBQ0EsTUFBT29WLEtBQVAsQ0FDRCxDQVRELENBVUFQLFFBQVEsQ0FBQ1EsTUFBVCxDQUFrQixTQUFTOWpCLEdBQVQsQ0FBYzZqQixJQUFkLENBQW9CLENBQ3BDOWQsS0FBSyxDQUFDMmQsR0FBTixDQUFVSyxZQUFWLENBQXVCL2pCLEdBQXZCLENBQTRCNmpCLElBQTVCLENBQWtDTixnQkFBbEMsQ0FBb0QsS0FBcEQsRUFDQUMsZ0JBQWdCLENBQUM1VixRQUFqQixDQUEwQjJWLGdCQUFnQixDQUFDLENBQUQsQ0FBMUMsRUFDQUMsZ0JBQWdCLENBQUM1VixRQUFqQixDQUEwQjJWLGdCQUFnQixDQUFDLENBQUQsQ0FBMUMsRUFDQUMsZ0JBQWdCLENBQUM1VixRQUFqQixDQUEwQjJWLGdCQUFnQixDQUFDLENBQUQsQ0FBMUMsRUFDQUMsZ0JBQWdCLENBQUM1VixRQUFqQixDQUEwQjJWLGdCQUFnQixDQUFDLENBQUQsQ0FBMUMsRUFDQSxNQUFPQyxpQkFBZ0IsQ0FBQ3JWLFFBQWpCLEVBQVAsQ0FDRCxDQVBELENBUUFtVixRQUFRLENBQUNVLFNBQVQsQ0FBcUIsU0FBU0gsSUFBVCxDQUFlLENBQ2xDO0FBQ0EsRUFBRUEsSUFBSSxDQUFDLENBQUQsQ0FBTixDQUNBLE1BQU9BLEtBQVAsQ0FDRCxDQUpELENBS0FQLFFBQVEsQ0FBQ0YsRUFBVCxDQUFjcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTYSxNQUF2QixDQUVBOztHQUdBLFFBQVNDLFVBQVQsRUFBcUIsQ0FDbkIsR0FBSUMsSUFBRyxDQUFHcGUsS0FBSyxDQUFDcWUsSUFBTixDQUFXNWpCLE1BQVgsQ0FBa0I4aUIsUUFBbEIsQ0FBVixDQUVBOzs7Ozs7Ozs7OztLQVlBYSxHQUFHLENBQUNoVyxRQUFKLENBQWUsU0FBU2EsS0FBVCxDQUFnQjlFLFFBQWhCLENBQTBCLENBQ3ZDLE1BQU9pYSxJQUFHLENBQUNsZSxRQUFKLENBQWErSSxLQUFiLENBQW9COUUsUUFBcEIsQ0FBUCxDQUNELENBRkQsQ0FJQTs7Ozs7Ozs7O0tBVUFpYSxHQUFHLENBQUNFLFlBQUosQ0FBbUIsU0FBU3JWLEtBQVQsQ0FBZ0IsQ0FDakMsTUFBT21WLElBQUcsQ0FBQ2xlLFFBQUosQ0FBYStJLEtBQWIsQ0FBUCxDQUNELENBRkQsQ0FJQSxNQUFPbVYsSUFBUCxDQUNELENBRUQ7QUFDQSxHQUFJRyxLQUFJLENBQUdKLFNBQVMsRUFBcEIsQ0FFQTtBQUNBO0FBQ0EsR0FBSUssZ0JBQWUsQ0FBRyxJQUF0QixDQUNBLEdBQUcsTUFBT2xmLE9BQVAsR0FBa0IsV0FBckIsQ0FBa0MsQ0FDaEMsR0FBSW1mLFFBQU8sQ0FBR25mLE1BQU0sQ0FBQ29mLE1BQVAsRUFBaUJwZixNQUFNLENBQUNxZixRQUF0QyxDQUNBLEdBQUdGLE9BQU8sRUFBSUEsT0FBTyxDQUFDRCxlQUF0QixDQUF1QyxDQUNyQ0EsZUFBZSxDQUFHLHlCQUFTN1gsR0FBVCxDQUFjLENBQzlCLE1BQU84WCxRQUFPLENBQUNELGVBQVIsQ0FBd0I3WCxHQUF4QixDQUFQLENBQ0QsQ0FGRCxDQUdELENBQ0YsQ0FDRCxHQUFHM0csS0FBSyxDQUFDekksT0FBTixDQUFja00saUJBQWQsRUFDQSxDQUFDekQsS0FBSyxDQUFDMkQsSUFBTixDQUFXZ0MsUUFBWixFQUF3QixDQUFDNlksZUFENUIsQ0FDOEMsQ0FDNUM7QUFDQTtBQUNBLEdBQUcsTUFBT2xmLE9BQVAsR0FBa0IsV0FBbEIsRUFBaUNBLE1BQU0sQ0FBQytGLFFBQVAsR0FBb0JwQixTQUF4RCxDQUFtRSxDQUVsRSxDQURDO0FBR0Y7QUFDQXNhLElBQUksQ0FBQ0ssVUFBTCxDQUFnQixDQUFDLEdBQUkxWixLQUFKLEVBQWpCLENBQTZCLEVBQTdCLEVBRUE7QUFDQSxHQUFHLE1BQU9nUCxVQUFQLEdBQXNCLFdBQXpCLENBQXNDLENBQ3BDLEdBQUkySyxVQUFTLENBQUcsRUFBaEIsQ0FDQSxJQUFJLEdBQUk1a0IsSUFBUixHQUFlaWEsVUFBZixDQUEwQixDQUN4QixHQUFJLENBQ0YsR0FBRyxNQUFPQSxVQUFTLENBQUNqYSxHQUFELENBQWhCLEVBQTBCLFFBQTdCLENBQXVDLENBQ3JDNGtCLFNBQVMsRUFBSTNLLFNBQVMsQ0FBQ2phLEdBQUQsQ0FBdEIsQ0FDRCxDQUNGLENBQUMsTUFBTThNLENBQU4sQ0FBUyxDQUNUOzs7OztxQkFNRCxDQUNGLENBQ0R3WCxJQUFJLENBQUNPLE9BQUwsQ0FBYUQsU0FBYixFQUNBQSxTQUFTLENBQUcsSUFBWixDQUNELENBRUQ7QUFDQSxHQUFHck4sTUFBSCxDQUFXLENBQ1Q7QUFDQUEsTUFBTSxHQUFHdU4sU0FBVCxDQUFtQixTQUFTaFksQ0FBVCxDQUFZLENBQzdCO0FBQ0F3WCxJQUFJLENBQUNLLFVBQUwsQ0FBZ0I3WCxDQUFDLENBQUNpWSxPQUFsQixDQUEyQixFQUEzQixFQUNBVCxJQUFJLENBQUNLLFVBQUwsQ0FBZ0I3WCxDQUFDLENBQUNrWSxPQUFsQixDQUEyQixFQUEzQixFQUNELENBSkQsRUFNQTtBQUNBek4sTUFBTSxHQUFHME4sUUFBVCxDQUFrQixTQUFTblksQ0FBVCxDQUFZLENBQzVCd1gsSUFBSSxDQUFDSyxVQUFMLENBQWdCN1gsQ0FBQyxDQUFDb1ksUUFBbEIsQ0FBNEIsQ0FBNUIsRUFDRCxDQUZELEVBR0QsQ0FDRixDQUVELGdCQUNBLEdBQUcsQ0FBQ25mLEtBQUssQ0FBQ2pCLE1BQVYsQ0FBa0IsQ0FDaEJpQixLQUFLLENBQUNqQixNQUFOLENBQWV3ZixJQUFmLENBQ0QsQ0FGRCxJQUVPLENBQ0w7QUFDQSxJQUFJLEdBQUl0a0IsSUFBUixHQUFlc2tCLEtBQWYsQ0FBcUIsQ0FDbkJ2ZSxLQUFLLENBQUNqQixNQUFOLENBQWE5RSxHQUFiLEVBQW9Cc2tCLElBQUksQ0FBQ3RrQixHQUFELENBQXhCLENBQ0QsQ0FDRixDQUVEO0FBQ0ErRixLQUFLLENBQUNqQixNQUFOLENBQWFxZ0IsY0FBYixDQUE4QmpCLFNBQTlCLENBRUF0YyxNQUFNLENBQUNELE9BQVAsQ0FBaUI1QixLQUFLLENBQUNqQixNQUF2QixDQUVDLENBL0pELEVBK0pHLE1BQU95UyxPQUFQLEdBQW1CLFdBQW5CLENBQWlDQSxNQUFqQyxDQUEwQyxJQS9KN0MsRUFpS0MsQ0F6S0QsSUE0S0EsS0FBTyxDQWpzSkcsQ0Frc0pWLE9BbHNKVSxDQW1zSlYsS0FBTyxTQUFTM1AsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErREEsR0FBSWxDLE1BQUssQ0FBR2tDLG1CQUFtQixDQUFDLENBQUQsQ0FBL0IsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUVBLEdBQUcsTUFBT21kLFdBQVAsR0FBc0IsV0FBekIsQ0FBc0MsQ0FDcEMsR0FBSUEsV0FBVSxDQUFHcmYsS0FBSyxDQUFDc2YsSUFBTixDQUFXRCxVQUE1QixDQUNELENBRUQ7QUFDQSxHQUFJM0osS0FBSSxDQUFHMVYsS0FBSyxDQUFDMFYsSUFBakIsQ0FFQTs7R0FHQTFWLEtBQUssQ0FBQ1UsR0FBTixDQUFZVixLQUFLLENBQUNVLEdBQU4sRUFBYSxFQUF6QixDQUNBbUIsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDVSxHQUFOLENBQVVOLEdBQVYsQ0FBZ0JKLEtBQUssQ0FBQ0ksR0FBTixDQUFZSixLQUFLLENBQUNJLEdBQU4sRUFBYSxFQUExRCxDQUNBLEdBQUlNLElBQUcsQ0FBR1YsS0FBSyxDQUFDVSxHQUFoQixDQUVBO0FBQ0EsR0FBSTZlLGFBQVksQ0FBRyxDQUFDLENBQUQsQ0FBSSxDQUFKLENBQU8sQ0FBUCxDQUFVLENBQVYsQ0FBYSxDQUFiLENBQWdCLENBQWhCLENBQW1CLENBQW5CLENBQXNCLENBQXRCLENBQW5CLENBRUE7QUFDQSxHQUFJQyxvQkFBbUIsQ0FBRyxDQUN4QjtBQUNBNWdCLElBQUksQ0FBRSxnQkFGa0IsQ0FHeEIwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIRyxDQUl4QjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUpRLENBS3hCUSxXQUFXLENBQUUsSUFMVyxDQU14QjNGLEtBQUssQ0FBRSxDQUFDLENBQ047QUFDQWhULElBQUksQ0FBRSx3QkFGQSxDQUdOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSGYsQ0FJTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUpWLENBS05vQixXQUFXLENBQUUsS0FMUCxDQU1ONkUsT0FBTyxDQUFFLG1CQU5ILENBQUQsQ0FPSixDQUNEO0FBQ0F4ZCxJQUFJLENBQUUsb0NBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSmYsQ0FLRFEsV0FBVyxDQUFFLElBTFosQ0FNRDNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsK0JBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxlQUxILENBQUQsQ0FOTixDQVBJLENBb0JKLENBQ0Q7QUFDQXhkLElBQUksQ0FBRSxnQkFGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FKZixDQUtEa0IsV0FBVyxDQUFFLEtBTFosQ0FNRDZFLE9BQU8sQ0FBRSxZQU5SLENBcEJJLENBTmlCLENBQTFCLENBb0NBO0FBQ0EsR0FBSXFELHVCQUFzQixDQUFHLENBQzNCO0FBQ0E3Z0IsSUFBSSxDQUFFLGVBRnFCLENBRzNCMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSE0sQ0FJM0I3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFKVyxDQUszQlEsV0FBVyxDQUFFLElBTGMsQ0FNM0IzRixLQUFLLENBQUUsQ0FBQyxDQUNOO0FBQ0FoVCxJQUFJLENBQUUsdUJBRkEsQ0FHTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhmLENBSU43RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FKVixDQUtOb0IsV0FBVyxDQUFFLEtBTFAsQ0FNTjZFLE9BQU8sQ0FBRSxtQkFOSCxDQUFELENBT0osQ0FDRDtBQUNBeGQsSUFBSSxDQUFFLHVCQUZMLENBR0QwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIcEIsQ0FJRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUpmLENBS0RvQixXQUFXLENBQUUsS0FMWixDQU1ENkUsT0FBTyxDQUFFLG1CQU5SLENBUEksQ0FjSixDQUNEO0FBQ0F4ZCxJQUFJLENBQUUsOEJBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSmYsQ0FLRG9CLFdBQVcsQ0FBRSxLQUxaLENBTUQ2RSxPQUFPLENBQUUsMEJBTlIsQ0FkSSxDQXFCSixDQUNEO0FBQ0F4ZCxJQUFJLENBQUUsK0JBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSmYsQ0FLRG9CLFdBQVcsQ0FBRSxLQUxaLENBTUQ2RSxPQUFPLENBQUUsMkJBTlIsQ0FyQkksQ0E0QkosQ0FDRDtBQUNBeGQsSUFBSSxDQUFFLHNCQUZMLENBR0QwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIcEIsQ0FJRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUpmLENBS0RvQixXQUFXLENBQUUsS0FMWixDQU1ENkUsT0FBTyxDQUFFLGtCQU5SLENBNUJJLENBbUNKLENBQ0Q7QUFDQXhkLElBQUksQ0FBRSxzQkFGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FKZixDQUtEb0IsV0FBVyxDQUFFLEtBTFosQ0FNRDZFLE9BQU8sQ0FBRSxrQkFOUixDQW5DSSxDQTBDSixDQUNEO0FBQ0F4ZCxJQUFJLENBQUUseUJBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSmYsQ0FLRG9CLFdBQVcsQ0FBRSxLQUxaLENBTUQ2RSxPQUFPLENBQUUscUJBTlIsQ0ExQ0ksQ0FpREosQ0FDRDtBQUNBeGQsSUFBSSxDQUFFLHlCQUZMLENBR0QwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIcEIsQ0FJRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUpmLENBS0RvQixXQUFXLENBQUUsS0FMWixDQU1ENkUsT0FBTyxDQUFFLHFCQU5SLENBakRJLENBd0RKLENBQ0Q7QUFDQXhkLElBQUksQ0FBRSwyQkFGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FKZixDQUtEb0IsV0FBVyxDQUFFLEtBTFosQ0FNRDZFLE9BQU8sQ0FBRSx1QkFOUixDQXhESSxDQU5vQixDQUE3QixDQXdFQTtBQUNBLEdBQUlzRCxzQkFBcUIsQ0FBRyxDQUMxQjtBQUNBOWdCLElBQUksQ0FBRSxjQUZvQixDQUcxQjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhLLENBSTFCN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSlUsQ0FLMUJRLFdBQVcsQ0FBRSxJQUxhLENBTTFCM0YsS0FBSyxDQUFFLENBQUMsQ0FDTjtBQUNBaFQsSUFBSSxDQUFFLHNCQUZBLENBR04wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIZixDQUlON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSlYsQ0FLTm9CLFdBQVcsQ0FBRSxLQUxQLENBTU42RSxPQUFPLENBQUUsa0JBTkgsQ0FBRCxDQU9KLENBQ0Q7QUFDQXhkLElBQUksQ0FBRSx1QkFGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FKZixDQUtEb0IsV0FBVyxDQUFFLEtBTFosQ0FNRDZFLE9BQU8sQ0FBRSxtQkFOUixDQVBJLENBTm1CLENBQTVCLENBdUJBO0FBQ0E7QUFDQSxHQUFJdUQsbUJBQWtCLENBQUczZixLQUFLLENBQUNVLEdBQU4sQ0FBVU4sR0FBVixDQUFjdWYsa0JBQWQsQ0FBbUMsQ0FDMUQvZ0IsSUFBSSxDQUFFLHNCQURvRCxDQUUxRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZxQyxDQUcxRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUgwQyxDQUkxRFEsV0FBVyxDQUFFLElBSjZDLENBSzFEK0UsV0FBVyxDQUFFLHNCQUw2QyxDQU0xRDFLLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsMENBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIVixDQUlOUSxXQUFXLENBQUUsSUFKUCxDQUtOM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSwrQkFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGNBTEgsQ0FBRCxDQUxELENBQUQsQ0FZSixDQUNEO0FBQ0F4ZCxJQUFJLENBQUUsdUNBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVJLFNBSmYsQ0FLRG1CLFdBQVcsQ0FBRSxLQUxaLENBTUQzRixLQUFLLENBQUUsQ0FBQyxDQUNOO0FBQ0FoVCxJQUFJLENBQUUsb0RBRkEsQ0FHTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhmLENBSU43RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFKVixDQUtOUSxXQUFXLENBQUUsSUFMUCxDQU1OOEUsUUFBUSxDQUFFLElBTkosQ0FPTkMsV0FBVyxDQUFFLGNBUFAsQ0FBRCxDQU5OLENBWkksQ0FObUQsQ0FBNUQsQ0FvQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkEsR0FBSXNELG1CQUFrQixDQUFHLFFBQXJCQSxtQkFBcUIsQ0FBU3ZDLEVBQVQsQ0FBYSxDQUNwQztBQUNBLEdBQUl4RCxJQUFKLENBQ0EsR0FBR3dELEVBQUUsQ0FBQ3dDLFNBQUgsR0FBZ0JuZixJQUFHLENBQUN1YyxJQUF2QixDQUE2QixDQUMzQnBELEdBQUcsQ0FBR25aLEdBQUcsQ0FBQ3VjLElBQUosQ0FBU0ksRUFBRSxDQUFDd0MsU0FBWixDQUFOLENBQ0QsQ0FGRCxJQUVPLENBQ0wsR0FBSTNsQixNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxtQ0FBVixDQUFaLENBQ0FrQyxLQUFLLENBQUMybEIsU0FBTixDQUFrQnhDLEVBQUUsQ0FBQ3dDLFNBQXJCLENBQ0EsS0FBTTNsQixNQUFOLENBQ0QsQ0FDRCxHQUFJNGxCLFNBQVEsQ0FBR3BLLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY0MsR0FBZCxFQUFtQnpSLFFBQW5CLEVBQWYsQ0FFQTtBQUNBLEdBQUkyWCxXQUFVLENBQUdySyxJQUFJLENBQUNqYixNQUFMLENBQ2ZpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FESSxDQUNPRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFEakIsQ0FDMkIsSUFEM0IsQ0FDaUMsRUFEakMsQ0FBakIsQ0FFQSxHQUFJaUosZ0JBQWUsQ0FBR3RLLElBQUksQ0FBQ2piLE1BQUwsQ0FDcEJpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEUyxDQUNFRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFEWixDQUNzQixJQUR0QixDQUM0QixFQUQ1QixDQUF0QixDQUVBaUosZUFBZSxDQUFDcE8sS0FBaEIsQ0FBc0I5TSxJQUF0QixDQUEyQjRRLElBQUksQ0FBQ2piLE1BQUwsQ0FDekJpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEYyxDQUNIRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FEUCxDQUNZLEtBRFosQ0FDbUJ1SixRQURuQixDQUEzQixFQUVBRSxlQUFlLENBQUNwTyxLQUFoQixDQUFzQjlNLElBQXRCLENBQTJCNFEsSUFBSSxDQUFDamIsTUFBTCxDQUN6QmliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURjLENBQ0hGLElBQUksQ0FBQ00sSUFBTCxDQUFVTSxJQURQLENBQ2EsS0FEYixDQUNvQixFQURwQixDQUEzQixFQUVBLEdBQUkySixPQUFNLENBQUd2SyxJQUFJLENBQUNqYixNQUFMLENBQ1hpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEQSxDQUNXRixJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FEckIsQ0FFWCxLQUZXLENBRUpnSCxFQUFFLENBQUM0QyxNQUFILEdBQVk3WCxRQUFaLEVBRkksQ0FBYixDQUdBMlgsVUFBVSxDQUFDbk8sS0FBWCxDQUFpQjlNLElBQWpCLENBQXNCa2IsZUFBdEIsRUFDQUQsVUFBVSxDQUFDbk8sS0FBWCxDQUFpQjlNLElBQWpCLENBQXNCbWIsTUFBdEIsRUFFQTtBQUNBLE1BQU92SyxLQUFJLENBQUMrRCxLQUFMLENBQVdzRyxVQUFYLEVBQXVCM1gsUUFBdkIsRUFBUCxDQUNELENBN0JELENBK0JBOzs7Ozs7OztHQVNBLEdBQUk4WCxRQUFPLENBQUcsUUFBVkEsUUFBVSxDQUFTbmEsQ0FBVCxDQUFZOUwsR0FBWixDQUFpQmttQixHQUFqQixDQUFzQixDQUNsQyxHQUFHQSxHQUFILENBQVEsQ0FDTixNQUFPcGEsRUFBQyxDQUFDcWEsTUFBRixDQUFTbm1CLEdBQUcsQ0FBQzhNLENBQWIsQ0FBZ0I5TSxHQUFHLENBQUM4SSxDQUFwQixDQUFQLENBQ0QsQ0FFRCxHQUFHLENBQUM5SSxHQUFHLENBQUNzSixDQUFMLEVBQVUsQ0FBQ3RKLEdBQUcsQ0FBQ2lXLENBQWxCLENBQXFCLENBQ25CO0FBQ0EsTUFBT25LLEVBQUMsQ0FBQ3FhLE1BQUYsQ0FBU25tQixHQUFHLENBQUN3SSxDQUFiLENBQWdCeEksR0FBRyxDQUFDOEksQ0FBcEIsQ0FBUCxDQUNELENBRUQ7QUFDQSxHQUFHLENBQUM5SSxHQUFHLENBQUNvbUIsRUFBUixDQUFZLENBQ1ZwbUIsR0FBRyxDQUFDb21CLEVBQUosQ0FBU3BtQixHQUFHLENBQUN3SSxDQUFKLENBQU02ZCxHQUFOLENBQVVybUIsR0FBRyxDQUFDc0osQ0FBSixDQUFNZ2QsUUFBTixDQUFlbEIsVUFBVSxDQUFDbUIsR0FBMUIsQ0FBVixDQUFULENBQ0QsQ0FDRCxHQUFHLENBQUN2bUIsR0FBRyxDQUFDd21CLEVBQVIsQ0FBWSxDQUNWeG1CLEdBQUcsQ0FBQ3dtQixFQUFKLENBQVN4bUIsR0FBRyxDQUFDd0ksQ0FBSixDQUFNNmQsR0FBTixDQUFVcm1CLEdBQUcsQ0FBQ2lXLENBQUosQ0FBTXFRLFFBQU4sQ0FBZWxCLFVBQVUsQ0FBQ21CLEdBQTFCLENBQVYsQ0FBVCxDQUNELENBQ0QsR0FBRyxDQUFDdm1CLEdBQUcsQ0FBQ3ltQixJQUFSLENBQWMsQ0FDWnptQixHQUFHLENBQUN5bUIsSUFBSixDQUFXem1CLEdBQUcsQ0FBQ2lXLENBQUosQ0FBTXlRLFVBQU4sQ0FBaUIxbUIsR0FBRyxDQUFDc0osQ0FBckIsQ0FBWCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBckJrQyxDQXVHbEM7QUFDQSxHQUFJcWQsRUFBSixDQUNBLEVBQUcsQ0FDREEsQ0FBQyxDQUFHLEdBQUl2QixXQUFKLENBQ0ZyZixLQUFLLENBQUMyRCxJQUFOLENBQVd3SSxVQUFYLENBQXNCbk0sS0FBSyxDQUFDakIsTUFBTixDQUFhcUosUUFBYixDQUFzQm5PLEdBQUcsQ0FBQzhJLENBQUosQ0FBTThkLFNBQU4sR0FBb0IsQ0FBMUMsQ0FBdEIsQ0FERSxDQUVGLEVBRkUsQ0FBSixDQUdELENBSkQsTUFJUUQsQ0FBQyxDQUFDRSxTQUFGLENBQVk3bUIsR0FBRyxDQUFDOEksQ0FBaEIsR0FBc0IsQ0FBdEIsRUFBMkIsQ0FBQzZkLENBQUMsQ0FBQ0csR0FBRixDQUFNOW1CLEdBQUcsQ0FBQzhJLENBQVYsRUFBYThVLE1BQWIsQ0FBb0J3SCxVQUFVLENBQUNtQixHQUEvQixDQUpwQyxFQUtBemEsQ0FBQyxDQUFHQSxDQUFDLENBQUNpYixRQUFGLENBQVdKLENBQUMsQ0FBQ1IsTUFBRixDQUFTbm1CLEdBQUcsQ0FBQzhNLENBQWIsQ0FBZ0I5TSxHQUFHLENBQUM4SSxDQUFwQixDQUFYLEVBQW1DdWQsR0FBbkMsQ0FBdUNybUIsR0FBRyxDQUFDOEksQ0FBM0MsQ0FBSixDQUVBO0FBQ0EsR0FBSWtlLEdBQUUsQ0FBR2xiLENBQUMsQ0FBQ3VhLEdBQUYsQ0FBTXJtQixHQUFHLENBQUNzSixDQUFWLEVBQWE2YyxNQUFiLENBQW9Cbm1CLEdBQUcsQ0FBQ29tQixFQUF4QixDQUE0QnBtQixHQUFHLENBQUNzSixDQUFoQyxDQUFULENBQ0EsR0FBSTJkLEdBQUUsQ0FBR25iLENBQUMsQ0FBQ3VhLEdBQUYsQ0FBTXJtQixHQUFHLENBQUNpVyxDQUFWLEVBQWFrUSxNQUFiLENBQW9Cbm1CLEdBQUcsQ0FBQ3dtQixFQUF4QixDQUE0QnhtQixHQUFHLENBQUNpVyxDQUFoQyxDQUFULENBRUE7QUFDQSxNQUFNK1EsRUFBRSxDQUFDSCxTQUFILENBQWFJLEVBQWIsRUFBbUIsQ0FBekIsQ0FBNEIsQ0FDMUJELEVBQUUsQ0FBR0EsRUFBRSxDQUFDRSxHQUFILENBQU9sbkIsR0FBRyxDQUFDc0osQ0FBWCxDQUFMLENBQ0QsQ0FFRDtBQUNBLEdBQUk2ZCxFQUFDLENBQUdILEVBQUUsQ0FBQ1YsUUFBSCxDQUFZVyxFQUFaLEVBQ0xGLFFBREssQ0FDSS9tQixHQUFHLENBQUN5bUIsSUFEUixFQUNjSixHQURkLENBQ2tCcm1CLEdBQUcsQ0FBQ3NKLENBRHRCLEVBRUx5ZCxRQUZLLENBRUkvbUIsR0FBRyxDQUFDaVcsQ0FGUixFQUVXaVIsR0FGWCxDQUVlRCxFQUZmLENBQVIsQ0FJQTtBQUNBRSxDQUFDLENBQUdBLENBQUMsQ0FBQ0osUUFBRixDQUFXSixDQUFDLENBQUNELFVBQUYsQ0FBYTFtQixHQUFHLENBQUM4SSxDQUFqQixDQUFYLEVBQWdDdWQsR0FBaEMsQ0FBb0NybUIsR0FBRyxDQUFDOEksQ0FBeEMsQ0FBSixDQUVBLE1BQU9xZSxFQUFQLENBQ0QsQ0FsSUQsQ0FvSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0JBMWdCLEdBQUcsQ0FBQ04sR0FBSixDQUFRaWhCLE9BQVIsQ0FBa0IsU0FBUzllLENBQVQsQ0FBWXRJLEdBQVosQ0FBaUJxbkIsRUFBakIsQ0FBcUIsQ0FDckMsR0FBSW5CLElBQUcsQ0FBR21CLEVBQVYsQ0FDQSxHQUFJQyxHQUFKLENBRUE7QUFDQSxHQUFJN2lCLEVBQUMsQ0FBR0ksSUFBSSxDQUFDOEwsSUFBTCxDQUFVM1EsR0FBRyxDQUFDOEksQ0FBSixDQUFNOGQsU0FBTixHQUFvQixDQUE5QixDQUFSLENBRUEsR0FBR1MsRUFBRSxHQUFLLEtBQVAsRUFBZ0JBLEVBQUUsR0FBSyxJQUExQixDQUFnQyxDQUM5QjtBQUNBbkIsR0FBRyxDQUFJbUIsRUFBRSxHQUFLLElBQWQsQ0FDQUMsRUFBRSxDQUFHQyxpQkFBaUIsQ0FBQ2pmLENBQUQsQ0FBSXRJLEdBQUosQ0FBU3FuQixFQUFULENBQXRCLENBQ0QsQ0FKRCxJQUlPLENBQ0xDLEVBQUUsQ0FBR3ZoQixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQUwsQ0FDQWdZLEVBQUUsQ0FBQ2xhLFFBQUgsQ0FBWTlFLENBQVosRUFDRCxDQUVEO0FBQ0E7QUFDQSxHQUFJd0QsRUFBQyxDQUFHLEdBQUlzWixXQUFKLENBQWVrQyxFQUFFLENBQUM1WCxLQUFILEVBQWYsQ0FBMkIsRUFBM0IsQ0FBUixDQUVBO0FBQ0EsR0FBSXlYLEVBQUMsQ0FBR2xCLE9BQU8sQ0FBQ25hLENBQUQsQ0FBSTlMLEdBQUosQ0FBU2ttQixHQUFULENBQWYsQ0FFQTtBQUNBO0FBQ0E7QUFDQSxHQUFJc0IsS0FBSSxDQUFHTCxDQUFDLENBQUNwaUIsUUFBRixDQUFXLEVBQVgsQ0FBWCxDQUNBLEdBQUkwaUIsR0FBRSxDQUFHMWhCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBVCxDQUNBLEdBQUk4SixNQUFLLENBQUczVSxDQUFDLENBQUdJLElBQUksQ0FBQzhMLElBQUwsQ0FBVTZXLElBQUksQ0FBQ3ZwQixNQUFMLENBQWMsQ0FBeEIsQ0FBaEIsQ0FDQSxNQUFNbWIsS0FBSyxDQUFHLENBQWQsQ0FBaUIsQ0FDZnFPLEVBQUUsQ0FBQzFhLE9BQUgsQ0FBVyxJQUFYLEVBQ0EsRUFBRXFNLEtBQUYsQ0FDRCxDQUNEcU8sRUFBRSxDQUFDcmEsUUFBSCxDQUFZckgsS0FBSyxDQUFDMkQsSUFBTixDQUFXc0ksVUFBWCxDQUFzQndWLElBQXRCLENBQVosRUFDQSxNQUFPQyxHQUFFLENBQUN0WixRQUFILEVBQVAsQ0FDRCxDQW5DRCxDQXFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkExSCxHQUFHLENBQUNOLEdBQUosQ0FBUW9CLE9BQVIsQ0FBa0IsU0FBU2tnQixFQUFULENBQWF6bkIsR0FBYixDQUFrQmttQixHQUFsQixDQUF1QndCLEVBQXZCLENBQTJCLENBQzNDO0FBQ0EsR0FBSWpqQixFQUFDLENBQUdJLElBQUksQ0FBQzhMLElBQUwsQ0FBVTNRLEdBQUcsQ0FBQzhJLENBQUosQ0FBTThkLFNBQU4sR0FBb0IsQ0FBOUIsQ0FBUixDQUVBO0FBQ0EsR0FBR2EsRUFBRSxDQUFDeHBCLE1BQUgsR0FBY3dHLENBQWpCLENBQW9CLENBQ2xCLEdBQUl4RSxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxzQ0FBVixDQUFaLENBQ0FrQyxLQUFLLENBQUNoQyxNQUFOLENBQWV3cEIsRUFBRSxDQUFDeHBCLE1BQWxCLENBQ0FnQyxLQUFLLENBQUMwbkIsUUFBTixDQUFpQmxqQixDQUFqQixDQUNBLEtBQU14RSxNQUFOLENBQ0QsQ0FFRDtBQUNBO0FBQ0EsR0FBSWtuQixFQUFDLENBQUcsR0FBSS9CLFdBQUosQ0FBZXJmLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0JtWSxFQUF4QixFQUE0Qi9YLEtBQTVCLEVBQWYsQ0FBb0QsRUFBcEQsQ0FBUixDQUVBO0FBQ0E7QUFDQSxHQUFHeVgsQ0FBQyxDQUFDTixTQUFGLENBQVk3bUIsR0FBRyxDQUFDOEksQ0FBaEIsR0FBc0IsQ0FBekIsQ0FBNEIsQ0FDMUIsS0FBTSxJQUFJL0ssTUFBSixDQUFVLCtCQUFWLENBQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSStOLEVBQUMsQ0FBR21hLE9BQU8sQ0FBQ2tCLENBQUQsQ0FBSW5uQixHQUFKLENBQVNrbUIsR0FBVCxDQUFmLENBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBSTBCLEtBQUksQ0FBRzliLENBQUMsQ0FBQy9HLFFBQUYsQ0FBVyxFQUFYLENBQVgsQ0FDQSxHQUFJdWlCLEdBQUUsQ0FBR3ZoQixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQVQsQ0FDQSxHQUFJOEosTUFBSyxDQUFHM1UsQ0FBQyxDQUFHSSxJQUFJLENBQUM4TCxJQUFMLENBQVVpWCxJQUFJLENBQUMzcEIsTUFBTCxDQUFjLENBQXhCLENBQWhCLENBQ0EsTUFBTW1iLEtBQUssQ0FBRyxDQUFkLENBQWlCLENBQ2ZrTyxFQUFFLENBQUN2YSxPQUFILENBQVcsSUFBWCxFQUNBLEVBQUVxTSxLQUFGLENBQ0QsQ0FDRGtPLEVBQUUsQ0FBQ2xhLFFBQUgsQ0FBWXJILEtBQUssQ0FBQzJELElBQU4sQ0FBV3NJLFVBQVgsQ0FBc0I0VixJQUF0QixDQUFaLEVBRUEsR0FBR0YsRUFBRSxHQUFLLEtBQVYsQ0FBaUIsQ0FDZjtBQUNBLE1BQU9HLGtCQUFpQixDQUFDUCxFQUFFLENBQUNuWixRQUFILEVBQUQsQ0FBZ0JuTyxHQUFoQixDQUFxQmttQixHQUFyQixDQUF4QixDQUNELENBRUQ7QUFDQSxNQUFPb0IsR0FBRSxDQUFDblosUUFBSCxFQUFQLENBQ0QsQ0E1Q0QsQ0E4Q0E7Ozs7Ozs7Ozs7Ozs7R0FjQTFILEdBQUcsQ0FBQ04sR0FBSixDQUFRMmhCLDRCQUFSLENBQXVDLFNBQVNDLElBQVQsQ0FBZWpiLENBQWYsQ0FBa0J4UCxPQUFsQixDQUEyQixDQUNoRTtBQUVBO0FBQ0EsR0FBRyxNQUFPeXFCLEtBQVAsR0FBaUIsUUFBcEIsQ0FBOEIsQ0FDNUJBLElBQUksQ0FBRzlWLFFBQVEsQ0FBQzhWLElBQUQsQ0FBTyxFQUFQLENBQWYsQ0FDRCxDQUNEQSxJQUFJLENBQUdBLElBQUksRUFBSSxJQUFmLENBRUE7QUFDQXpxQixPQUFPLENBQUdBLE9BQU8sRUFBSSxFQUFyQixDQUNBLEdBQUk4bUIsS0FBSSxDQUFHOW1CLE9BQU8sQ0FBQzhtQixJQUFSLEVBQWdCcmUsS0FBSyxDQUFDakIsTUFBakMsQ0FDQSxHQUFJa2pCLElBQUcsQ0FBRyxDQUNSO0FBQ0FDLFNBQVMsQ0FBRSxtQkFBU25jLENBQVQsQ0FBWSxDQUNyQixHQUFJUyxFQUFDLENBQUc2WCxJQUFJLENBQUNDLFlBQUwsQ0FBa0J2WSxDQUFDLENBQUM3TixNQUFwQixDQUFSLENBQ0EsSUFBSSxHQUFJa0ssRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHMkQsQ0FBQyxDQUFDN04sTUFBckIsQ0FBNkIsRUFBRWtLLENBQS9CLENBQWtDLENBQ2hDMkQsQ0FBQyxDQUFDM0QsQ0FBRCxDQUFELENBQU9vRSxDQUFDLENBQUM4QixVQUFGLENBQWFsRyxDQUFiLENBQVAsQ0FDRCxDQUNGLENBUE8sQ0FBVixDQVVBLEdBQUl5ZCxVQUFTLENBQUd0b0IsT0FBTyxDQUFDc29CLFNBQVIsRUFBcUIsVUFBckMsQ0FFQTtBQUNBLEdBQUlyWCxLQUFKLENBQ0EsR0FBR3FYLFNBQVMsR0FBSyxVQUFqQixDQUE2QixDQUMzQnJYLElBQUksQ0FBRyxDQUNMcVgsU0FBUyxDQUFFQSxTQUROLENBRUxzQyxLQUFLLENBQUUsQ0FGRixDQUdMSCxJQUFJLENBQUVBLElBSEQsQ0FJTEMsR0FBRyxDQUFFQSxHQUpBLENBS0xHLElBQUksQ0FBRXJiLENBQUMsRUFBSSxLQUxOLENBTUxBLENBQUMsQ0FBRSxHQUFJc1ksV0FBSixDQUFlLElBQWYsQ0FORSxDQU9MOWIsQ0FBQyxDQUFFLElBUEUsQ0FRTDJNLENBQUMsQ0FBRSxJQVJFLENBU0xtUyxLQUFLLENBQUVMLElBQUksRUFBSSxDQVRWLENBVUxNLEtBQUssQ0FBRU4sSUFBSSxFQUFJQSxJQUFJLEVBQUksQ0FBWixDQVZOLENBV0xPLE9BQU8sQ0FBRSxDQVhKLENBWUxwUCxHQUFHLENBQUUsSUFaQSxDQWFMM1UsSUFBSSxDQUFFLElBYkQsQ0FBUCxDQWVBZ0ssSUFBSSxDQUFDekIsQ0FBTCxDQUFPeWIsT0FBUCxDQUFlaGEsSUFBSSxDQUFDNFosSUFBcEIsRUFDRCxDQWpCRCxJQWlCTyxDQUNMLEtBQU0sSUFBSXBxQixNQUFKLENBQVUscUNBQXVDNm5CLFNBQWpELENBQU4sQ0FDRCxDQUVELE1BQU9yWCxLQUFQLENBQ0QsQ0FoREQsQ0FrREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2QkE5SCxHQUFHLENBQUNOLEdBQUosQ0FBUXFpQiwwQkFBUixDQUFxQyxTQUFTTixLQUFULENBQWdCcGYsQ0FBaEIsQ0FBbUIsQ0FDdEQ7QUFDQSxHQUFHLEVBQUUsYUFBZW9mLE1BQWpCLENBQUgsQ0FBNEIsQ0FDMUJBLEtBQUssQ0FBQ3RDLFNBQU4sQ0FBa0IsVUFBbEIsQ0FDRCxDQUVEO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQSxHQUFJNkMsT0FBTSxDQUFHLEdBQUlyRCxXQUFKLENBQWUsSUFBZixDQUFiLENBQ0FxRCxNQUFNLENBQUNGLE9BQVAsQ0FBZSxFQUFmLEVBQ0EsR0FBSUcsU0FBUSxDQUFHLENBQWYsQ0FDQSxHQUFJQyxNQUFLLENBQUcsUUFBUkEsTUFBUSxDQUFTN2MsQ0FBVCxDQUFZcWIsQ0FBWixDQUFlLENBQUUsTUFBT3JiLEVBQUMsQ0FBQ3FiLENBQVQsQ0FBYSxDQUExQyxDQUVBO0FBQ0EsR0FBSXlCLEdBQUUsQ0FBRyxDQUFDLEdBQUkzZCxLQUFKLEVBQVYsQ0FDQSxHQUFJNGQsR0FBSixDQUNBLEdBQUlDLE1BQUssQ0FBRyxDQUFaLENBQ0EsTUFBTVosS0FBSyxDQUFDM2pCLElBQU4sR0FBZSxJQUFmLEdBQXdCdUUsQ0FBQyxFQUFJLENBQUwsRUFBVWdnQixLQUFLLENBQUdoZ0IsQ0FBMUMsQ0FBTixDQUFvRCxDQUNsRDtBQUNBLEdBQUdvZixLQUFLLENBQUNBLEtBQU4sR0FBZ0IsQ0FBbkIsQ0FBc0IsQ0FDcEI7Ozs7OzsrREFPQSxHQUFJSCxLQUFJLENBQUlHLEtBQUssQ0FBQzVlLENBQU4sR0FBWSxJQUFiLENBQXFCNGUsS0FBSyxDQUFDRyxLQUEzQixDQUFtQ0gsS0FBSyxDQUFDRSxLQUFwRCxDQUNBLEdBQUlXLE1BQUssQ0FBR2hCLElBQUksQ0FBRyxDQUFuQixDQUVBO0FBQ0EsR0FBR0csS0FBSyxDQUFDSSxPQUFOLEdBQWtCLENBQXJCLENBQXdCLENBQ3RCSixLQUFLLENBQUNoUCxHQUFOLENBQVksR0FBSWtNLFdBQUosQ0FBZTJDLElBQWYsQ0FBcUJHLEtBQUssQ0FBQ0YsR0FBM0IsQ0FBWixDQUNBO0FBQ0EsR0FBRyxDQUFDRSxLQUFLLENBQUNoUCxHQUFOLENBQVU4UCxPQUFWLENBQWtCRCxLQUFsQixDQUFKLENBQThCLENBQzVCYixLQUFLLENBQUNoUCxHQUFOLENBQVUrUCxTQUFWLENBQ0U3RCxVQUFVLENBQUNtQixHQUFYLENBQWUyQyxTQUFmLENBQXlCSCxLQUF6QixDQURGLENBQ21DSixLQURuQyxDQUMwQ1QsS0FBSyxDQUFDaFAsR0FEaEQsRUFFRCxDQUNEO0FBQ0FnUCxLQUFLLENBQUNoUCxHQUFOLENBQVVpUSxVQUFWLENBQXFCLEdBQUtqQixLQUFLLENBQUNoUCxHQUFOLENBQVVtTixHQUFWLENBQWNvQyxNQUFkLEVBQXNCVyxTQUF0QixFQUExQixDQUE2RCxDQUE3RCxFQUNBVixRQUFRLENBQUcsQ0FBWCxDQUVBLEVBQUVSLEtBQUssQ0FBQ0ksT0FBUixDQUNELENBWkQsSUFZTyxJQUFHSixLQUFLLENBQUNJLE9BQU4sR0FBa0IsQ0FBckIsQ0FBd0IsQ0FDN0I7QUFDQSxHQUFHSixLQUFLLENBQUNoUCxHQUFOLENBQVUwTixTQUFWLEdBQXdCbUIsSUFBM0IsQ0FBaUMsQ0FDL0I7QUFDQUcsS0FBSyxDQUFDSSxPQUFOLENBQWdCLENBQWhCLENBQ0E7QUFDRCxDQUpELElBSU8sSUFBR0osS0FBSyxDQUFDaFAsR0FBTixDQUFVbVEsZUFBVixDQUNSQyxvQkFBb0IsQ0FBQ3BCLEtBQUssQ0FBQ2hQLEdBQU4sQ0FBVTBOLFNBQVYsRUFBRCxDQURaLENBQUgsQ0FDeUMsQ0FDOUMsRUFBRXNCLEtBQUssQ0FBQ0ksT0FBUixDQUNELENBSE0sSUFHQSxDQUNMO0FBQ0FKLEtBQUssQ0FBQ2hQLEdBQU4sQ0FBVWlRLFVBQVYsQ0FBcUI3RCxZQUFZLENBQUNvRCxRQUFRLEdBQUssQ0FBZCxDQUFqQyxDQUFtRCxDQUFuRCxFQUNELENBQ0YsQ0FiTSxJQWFBLElBQUdSLEtBQUssQ0FBQ0ksT0FBTixHQUFrQixDQUFyQixDQUF3QixDQUM3QjtBQUNBSixLQUFLLENBQUNJLE9BQU4sQ0FDR0osS0FBSyxDQUFDaFAsR0FBTixDQUFVb04sUUFBVixDQUFtQmxCLFVBQVUsQ0FBQ21CLEdBQTlCLEVBQW1DTyxHQUFuQyxDQUF1Q29CLEtBQUssQ0FBQ3BiLENBQTdDLEVBQ0ErWixTQURBLENBQ1V6QixVQUFVLENBQUNtQixHQURyQixJQUM4QixDQUQvQixDQUNvQyxDQURwQyxDQUN3QyxDQUYxQyxDQUdELENBTE0sSUFLQSxJQUFHMkIsS0FBSyxDQUFDSSxPQUFOLEdBQWtCLENBQXJCLENBQXdCLENBQzdCO0FBQ0FKLEtBQUssQ0FBQ0ksT0FBTixDQUFnQixDQUFoQixDQUNBLEdBQUdKLEtBQUssQ0FBQzVlLENBQU4sR0FBWSxJQUFmLENBQXFCLENBQ25CNGUsS0FBSyxDQUFDNWUsQ0FBTixDQUFVNGUsS0FBSyxDQUFDaFAsR0FBaEIsQ0FDRCxDQUZELElBRU8sQ0FDTGdQLEtBQUssQ0FBQ2pTLENBQU4sQ0FBVWlTLEtBQUssQ0FBQ2hQLEdBQWhCLENBQ0QsQ0FFRDtBQUNBLEdBQUdnUCxLQUFLLENBQUM1ZSxDQUFOLEdBQVksSUFBWixFQUFvQjRlLEtBQUssQ0FBQ2pTLENBQU4sR0FBWSxJQUFuQyxDQUF5QyxDQUN2QyxFQUFFaVMsS0FBSyxDQUFDQSxLQUFSLENBQ0QsQ0FDREEsS0FBSyxDQUFDaFAsR0FBTixDQUFZLElBQVosQ0FDRCxDQUNGLENBekRELElBeURPLElBQUdnUCxLQUFLLENBQUNBLEtBQU4sR0FBZ0IsQ0FBbkIsQ0FBc0IsQ0FDM0I7QUFDQSxHQUFHQSxLQUFLLENBQUM1ZSxDQUFOLENBQVF1ZCxTQUFSLENBQWtCcUIsS0FBSyxDQUFDalMsQ0FBeEIsRUFBNkIsQ0FBaEMsQ0FBbUMsQ0FDakNpUyxLQUFLLENBQUNoUCxHQUFOLENBQVlnUCxLQUFLLENBQUM1ZSxDQUFsQixDQUNBNGUsS0FBSyxDQUFDNWUsQ0FBTixDQUFVNGUsS0FBSyxDQUFDalMsQ0FBaEIsQ0FDQWlTLEtBQUssQ0FBQ2pTLENBQU4sQ0FBVWlTLEtBQUssQ0FBQ2hQLEdBQWhCLENBQ0QsQ0FDRCxFQUFFZ1AsS0FBSyxDQUFDQSxLQUFSLENBQ0QsQ0FSTSxJQVFBLElBQUdBLEtBQUssQ0FBQ0EsS0FBTixHQUFnQixDQUFuQixDQUFzQixDQUMzQjtBQUNBQSxLQUFLLENBQUNxQixFQUFOLENBQVdyQixLQUFLLENBQUM1ZSxDQUFOLENBQVFnZCxRQUFSLENBQWlCbEIsVUFBVSxDQUFDbUIsR0FBNUIsQ0FBWCxDQUNBMkIsS0FBSyxDQUFDc0IsRUFBTixDQUFXdEIsS0FBSyxDQUFDalMsQ0FBTixDQUFRcVEsUUFBUixDQUFpQmxCLFVBQVUsQ0FBQ21CLEdBQTVCLENBQVgsQ0FDQTJCLEtBQUssQ0FBQ3VCLEdBQU4sQ0FBWXZCLEtBQUssQ0FBQ3FCLEVBQU4sQ0FBU3hDLFFBQVQsQ0FBa0JtQixLQUFLLENBQUNzQixFQUF4QixDQUFaLENBQ0EsRUFBRXRCLEtBQUssQ0FBQ0EsS0FBUixDQUNELENBTk0sSUFNQSxJQUFHQSxLQUFLLENBQUNBLEtBQU4sR0FBZ0IsQ0FBbkIsQ0FBc0IsQ0FDM0I7QUFDQSxHQUFHQSxLQUFLLENBQUN1QixHQUFOLENBQVUzQyxHQUFWLENBQWNvQixLQUFLLENBQUNwYixDQUFwQixFQUF1QitaLFNBQXZCLENBQWlDekIsVUFBVSxDQUFDbUIsR0FBNUMsSUFBcUQsQ0FBeEQsQ0FBMkQsQ0FDekQ7QUFDQSxFQUFFMkIsS0FBSyxDQUFDQSxLQUFSLENBQ0QsQ0FIRCxJQUdPLENBQ0w7QUFDQUEsS0FBSyxDQUFDNWUsQ0FBTixDQUFVLElBQVYsQ0FDQTRlLEtBQUssQ0FBQ2pTLENBQU4sQ0FBVSxJQUFWLENBQ0FpUyxLQUFLLENBQUNBLEtBQU4sQ0FBYyxDQUFkLENBQ0QsQ0FDRixDQVhNLElBV0EsSUFBR0EsS0FBSyxDQUFDQSxLQUFOLEdBQWdCLENBQW5CLENBQXNCLENBQzNCO0FBQ0FBLEtBQUssQ0FBQ3BmLENBQU4sQ0FBVW9mLEtBQUssQ0FBQzVlLENBQU4sQ0FBUXlkLFFBQVIsQ0FBaUJtQixLQUFLLENBQUNqUyxDQUF2QixDQUFWLENBRUE7QUFDQSxHQUFHaVMsS0FBSyxDQUFDcGYsQ0FBTixDQUFROGQsU0FBUixLQUF3QnNCLEtBQUssQ0FBQ0gsSUFBakMsQ0FBdUMsQ0FDckM7QUFDQSxFQUFFRyxLQUFLLENBQUNBLEtBQVIsQ0FDRCxDQUhELElBR08sQ0FDTDtBQUNBQSxLQUFLLENBQUNqUyxDQUFOLENBQVUsSUFBVixDQUNBaVMsS0FBSyxDQUFDQSxLQUFOLENBQWMsQ0FBZCxDQUNELENBQ0YsQ0FiTSxJQWFBLElBQUdBLEtBQUssQ0FBQ0EsS0FBTixHQUFnQixDQUFuQixDQUFzQixDQUMzQjtBQUNBLEdBQUkxZixFQUFDLENBQUcwZixLQUFLLENBQUNwYixDQUFOLENBQVE0WixVQUFSLENBQW1Cd0IsS0FBSyxDQUFDdUIsR0FBekIsQ0FBUixDQUNBdkIsS0FBSyxDQUFDM2pCLElBQU4sQ0FBYSxDQUNYdUMsVUFBVSxDQUFFTCxHQUFHLENBQUNOLEdBQUosQ0FBUW1CLGFBQVIsQ0FDVjRnQixLQUFLLENBQUNwZixDQURJLENBQ0RvZixLQUFLLENBQUNwYixDQURMLENBQ1F0RSxDQURSLENBQ1cwZixLQUFLLENBQUM1ZSxDQURqQixDQUNvQjRlLEtBQUssQ0FBQ2pTLENBRDFCLENBRVZ6TixDQUFDLENBQUM2ZCxHQUFGLENBQU02QixLQUFLLENBQUNxQixFQUFaLENBRlUsQ0FFTy9nQixDQUFDLENBQUM2ZCxHQUFGLENBQU02QixLQUFLLENBQUNzQixFQUFaLENBRlAsQ0FHVnRCLEtBQUssQ0FBQ2pTLENBQU4sQ0FBUXlRLFVBQVIsQ0FBbUJ3QixLQUFLLENBQUM1ZSxDQUF6QixDQUhVLENBREQsQ0FLWDNDLFNBQVMsQ0FBRUYsR0FBRyxDQUFDTixHQUFKLENBQVF1akIsWUFBUixDQUFxQnhCLEtBQUssQ0FBQ3BmLENBQTNCLENBQThCb2YsS0FBSyxDQUFDcGIsQ0FBcEMsQ0FMQSxDQUFiLENBT0QsQ0FFRDtBQUNBK2IsRUFBRSxDQUFHLENBQUMsR0FBSTVkLEtBQUosRUFBTixDQUNBNmQsS0FBSyxFQUFJRCxFQUFFLENBQUdELEVBQWQsQ0FDQUEsRUFBRSxDQUFHQyxFQUFMLENBQ0QsQ0FFRCxNQUFPWCxNQUFLLENBQUMzakIsSUFBTixHQUFlLElBQXRCLENBQ0QsQ0ExSUQsQ0E0SUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOEJBa0MsR0FBRyxDQUFDTixHQUFKLENBQVFDLGVBQVIsQ0FBMEIsU0FBUzJoQixJQUFULENBQWVqYixDQUFmLENBQWtCeFAsT0FBbEIsQ0FBMkI0TSxRQUEzQixDQUFxQyxDQUM3RDtBQUNBLEdBQUdELFNBQVMsQ0FBQ2hNLE1BQVYsR0FBcUIsQ0FBeEIsQ0FBMkIsQ0FDekIsR0FBRyxRQUFPOHBCLElBQVAsSUFBZ0IsUUFBbkIsQ0FBNkIsQ0FDM0J6cUIsT0FBTyxDQUFHeXFCLElBQVYsQ0FDQUEsSUFBSSxDQUFHL2QsU0FBUCxDQUNELENBSEQsSUFHTyxJQUFHLE1BQU8rZCxLQUFQLEdBQWdCLFVBQW5CLENBQStCLENBQ3BDN2QsUUFBUSxDQUFHNmQsSUFBWCxDQUNBQSxJQUFJLENBQUcvZCxTQUFQLENBQ0QsQ0FDRixDQVJELElBUU8sSUFBR0MsU0FBUyxDQUFDaE0sTUFBVixHQUFxQixDQUF4QixDQUEyQixDQUNoQztBQUNBLEdBQUcsTUFBTzhwQixLQUFQLEdBQWdCLFFBQW5CLENBQTZCLENBQzNCLEdBQUcsTUFBT2piLEVBQVAsR0FBYSxVQUFoQixDQUE0QixDQUMxQjVDLFFBQVEsQ0FBRzRDLENBQVgsQ0FDQUEsQ0FBQyxDQUFHOUMsU0FBSixDQUNELENBSEQsSUFHTyxJQUFHLE1BQU84QyxFQUFQLEdBQWEsUUFBaEIsQ0FBMEIsQ0FDL0J4UCxPQUFPLENBQUd3UCxDQUFWLENBQ0FBLENBQUMsQ0FBRzlDLFNBQUosQ0FDRCxDQUNGLENBUkQsSUFRTyxDQUNMMU0sT0FBTyxDQUFHeXFCLElBQVYsQ0FDQTdkLFFBQVEsQ0FBRzRDLENBQVgsQ0FDQWliLElBQUksQ0FBRy9kLFNBQVAsQ0FDQThDLENBQUMsQ0FBRzlDLFNBQUosQ0FDRCxDQUNGLENBaEJNLElBZ0JBLElBQUdDLFNBQVMsQ0FBQ2hNLE1BQVYsR0FBcUIsQ0FBeEIsQ0FBMkIsQ0FDaEM7QUFDQSxHQUFHLE1BQU82TyxFQUFQLEdBQWEsUUFBaEIsQ0FBMEIsQ0FDeEIsR0FBRyxNQUFPeFAsUUFBUCxHQUFtQixVQUF0QixDQUFrQyxDQUNoQzRNLFFBQVEsQ0FBRzVNLE9BQVgsQ0FDQUEsT0FBTyxDQUFHME0sU0FBVixDQUNELENBQ0YsQ0FMRCxJQUtPLENBQ0xFLFFBQVEsQ0FBRzVNLE9BQVgsQ0FDQUEsT0FBTyxDQUFHd1AsQ0FBVixDQUNBQSxDQUFDLENBQUc5QyxTQUFKLENBQ0QsQ0FDRixDQUNEMU0sT0FBTyxDQUFHQSxPQUFPLEVBQUksRUFBckIsQ0FDQSxHQUFHeXFCLElBQUksR0FBSy9kLFNBQVosQ0FBdUIsQ0FDckIrZCxJQUFJLENBQUd6cUIsT0FBTyxDQUFDeXFCLElBQVIsRUFBZ0IsSUFBdkIsQ0FDRCxDQUNELEdBQUdqYixDQUFDLEdBQUs5QyxTQUFULENBQW9CLENBQ2xCOEMsQ0FBQyxDQUFHeFAsT0FBTyxDQUFDd1AsQ0FBUixFQUFhLE9BQWpCLENBQ0QsQ0FFRDtBQUNBO0FBQ0EsR0FBRyxDQUFDL0csS0FBSyxDQUFDekksT0FBTixDQUFja00saUJBQWYsRUFBb0NVLFFBQXBDLEVBQ0Q2ZCxJQUFJLEVBQUksR0FEUCxFQUNjQSxJQUFJLEVBQUksS0FEdEIsR0FDZ0NqYixDQUFDLEdBQUssT0FBTixFQUFpQkEsQ0FBQyxHQUFLLENBRHZELENBQUgsQ0FDOEQsQ0FDNUQsR0FBRzZjLG1CQUFtQixDQUFDLGFBQUQsQ0FBbkIsRUFBc0NBLG1CQUFtQixDQUFDLFdBQUQsQ0FBNUQsQ0FBMkUsQ0FDekU7QUFDQSxNQUFPdGtCLE9BQU0sQ0FBQ29mLE1BQVAsQ0FBY21GLE1BQWQsQ0FBcUJDLFdBQXJCLENBQWlDLENBQ3RDbGxCLElBQUksQ0FBRSxtQkFEZ0MsQ0FFdENtbEIsYUFBYSxDQUFFL0IsSUFGdUIsQ0FHdENnQyxjQUFjLENBQUVDLGdCQUFnQixDQUFDbGQsQ0FBRCxDQUhNLENBSXRDdkgsSUFBSSxDQUFFLENBQUNaLElBQUksQ0FBRSxTQUFQLENBSmdDLENBQWpDLENBS0osSUFBSyx3QkFMRCxDQUsyQixDQUFDLE1BQUQsQ0FBUyxRQUFULENBTDNCLEVBTU50RSxJQU5NLENBTUQsU0FBUzRwQixJQUFULENBQWUsQ0FDbkIsTUFBTzVrQixPQUFNLENBQUNvZixNQUFQLENBQWNtRixNQUFkLENBQXFCTSxTQUFyQixDQUErQixPQUEvQixDQUF3Q0QsSUFBSSxDQUFDbmpCLFVBQTdDLENBQVAsQ0FDRjtBQUNDLENBVE0sRUFTSnpHLElBVEksQ0FTQzJKLFNBVEQsQ0FTWSxTQUFTZ1IsR0FBVCxDQUFjLENBQy9COVEsUUFBUSxDQUFDOFEsR0FBRCxDQUFSLENBQ0QsQ0FYTSxFQVdKM2EsSUFYSSxDQVdDLFNBQVM4cEIsS0FBVCxDQUFnQixDQUN0QixHQUFHQSxLQUFILENBQVUsQ0FDUixHQUFJcmpCLFdBQVUsQ0FBR0wsR0FBRyxDQUFDMmpCLGtCQUFKLENBQ2YzTyxJQUFJLENBQUNpRCxPQUFMLENBQWEzWSxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCNmEsS0FBeEIsQ0FBYixDQURlLENBQWpCLENBRUFqZ0IsUUFBUSxDQUFDLElBQUQsQ0FBTyxDQUNicEQsVUFBVSxDQUFFQSxVQURDLENBRWJILFNBQVMsQ0FBRUYsR0FBRyxDQUFDNGpCLGVBQUosQ0FBb0J2akIsVUFBVSxDQUFDZ0MsQ0FBL0IsQ0FBa0NoQyxVQUFVLENBQUNnRyxDQUE3QyxDQUZFLENBQVAsQ0FBUixDQUlELENBQ0YsQ0FwQk0sQ0FBUCxDQXFCRCxDQUNELEdBQUd3ZCxxQkFBcUIsQ0FBQyxhQUFELENBQXJCLEVBQ0RBLHFCQUFxQixDQUFDLFdBQUQsQ0FEdkIsQ0FDc0MsQ0FDcEMsR0FBSUMsTUFBSyxDQUFHbGxCLE1BQU0sQ0FBQ3FmLFFBQVAsQ0FBZ0JrRixNQUFoQixDQUF1QkMsV0FBdkIsQ0FBbUMsQ0FDN0NsbEIsSUFBSSxDQUFFLG1CQUR1QyxDQUU3Q21sQixhQUFhLENBQUUvQixJQUY4QixDQUc3Q2dDLGNBQWMsQ0FBRUMsZ0JBQWdCLENBQUNsZCxDQUFELENBSGEsQ0FJN0N2SCxJQUFJLENBQUUsQ0FBQ1osSUFBSSxDQUFFLFNBQVAsQ0FKdUMsQ0FBbkMsQ0FLVCxJQUFLLHdCQUxJLENBS3NCLENBQUMsTUFBRCxDQUFTLFFBQVQsQ0FMdEIsQ0FBWixDQU1BNGxCLEtBQUssQ0FBQ0MsVUFBTixDQUFtQixTQUFTMWQsQ0FBVCxDQUFZLENBQzdCLEdBQUltZCxLQUFJLENBQUduZCxDQUFDLENBQUMyZCxNQUFGLENBQVMxcUIsTUFBcEIsQ0FDQSxHQUFJMnFCLFNBQVEsQ0FBR3JsQixNQUFNLENBQUNxZixRQUFQLENBQWdCa0YsTUFBaEIsQ0FBdUJNLFNBQXZCLENBQ2IsT0FEYSxDQUNKRCxJQUFJLENBQUNuakIsVUFERCxDQUFmLENBRUE0akIsUUFBUSxDQUFDRixVQUFULENBQXNCLFNBQVMxZCxDQUFULENBQVksQ0FDaEMsR0FBSXFkLE1BQUssQ0FBR3JkLENBQUMsQ0FBQzJkLE1BQUYsQ0FBUzFxQixNQUFyQixDQUNBLEdBQUkrRyxXQUFVLENBQUdMLEdBQUcsQ0FBQzJqQixrQkFBSixDQUNmM08sSUFBSSxDQUFDaUQsT0FBTCxDQUFhM1ksS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QjZhLEtBQXhCLENBQWIsQ0FEZSxDQUFqQixDQUVBamdCLFFBQVEsQ0FBQyxJQUFELENBQU8sQ0FDYnBELFVBQVUsQ0FBRUEsVUFEQyxDQUViSCxTQUFTLENBQUVGLEdBQUcsQ0FBQzRqQixlQUFKLENBQW9CdmpCLFVBQVUsQ0FBQ2dDLENBQS9CLENBQWtDaEMsVUFBVSxDQUFDZ0csQ0FBN0MsQ0FGRSxDQUFQLENBQVIsQ0FJRCxDQVJELENBU0E0ZCxRQUFRLENBQUNDLE9BQVQsQ0FBbUIsU0FBUzNQLEdBQVQsQ0FBYyxDQUMvQjlRLFFBQVEsQ0FBQzhRLEdBQUQsQ0FBUixDQUNELENBRkQsQ0FHRCxDQWhCRCxDQWlCQXVQLEtBQUssQ0FBQ0ksT0FBTixDQUFnQixTQUFTM1AsR0FBVCxDQUFjLENBQzVCOVEsUUFBUSxDQUFDOFEsR0FBRCxDQUFSLENBQ0QsQ0FGRCxDQUdBLE9BQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBSWtOLE1BQUssQ0FBR3poQixHQUFHLENBQUNOLEdBQUosQ0FBUTJoQiw0QkFBUixDQUFxQ0MsSUFBckMsQ0FBMkNqYixDQUEzQyxDQUE4Q3hQLE9BQTlDLENBQVosQ0FDQSxHQUFHLENBQUM0TSxRQUFKLENBQWMsQ0FDWnpELEdBQUcsQ0FBQ04sR0FBSixDQUFRcWlCLDBCQUFSLENBQW1DTixLQUFuQyxDQUEwQyxDQUExQyxFQUNBLE1BQU9BLE1BQUssQ0FBQzNqQixJQUFiLENBQ0QsQ0FDRHFtQixnQkFBZ0IsQ0FBQzFDLEtBQUQsQ0FBUTVxQixPQUFSLENBQWlCNE0sUUFBakIsQ0FBaEIsQ0FDRCxDQWxIRCxDQW9IQTs7Ozs7OztHQVFBekQsR0FBRyxDQUFDNGpCLGVBQUosQ0FBc0I1akIsR0FBRyxDQUFDTixHQUFKLENBQVF1akIsWUFBUixDQUF1QixTQUFTNWdCLENBQVQsQ0FBWWdFLENBQVosQ0FBZSxDQUMxRCxHQUFJOU0sSUFBRyxDQUFHLENBQ1I4SSxDQUFDLENBQUVBLENBREssQ0FFUmdFLENBQUMsQ0FBRUEsQ0FGSyxDQUFWLENBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7S0FpQkE5TSxHQUFHLENBQUNvbkIsT0FBSixDQUFjLFNBQVN2bkIsSUFBVCxDQUFlNFYsTUFBZixDQUF1Qm9WLGFBQXZCLENBQXNDLENBQ2xELEdBQUcsTUFBT3BWLE9BQVAsR0FBa0IsUUFBckIsQ0FBK0IsQ0FDN0JBLE1BQU0sQ0FBR0EsTUFBTSxDQUFDcVYsV0FBUCxFQUFULENBQ0QsQ0FGRCxJQUVPLElBQUdyVixNQUFNLEdBQUt6TCxTQUFkLENBQXlCLENBQzlCeUwsTUFBTSxDQUFHLGtCQUFULENBQ0QsQ0FFRCxHQUFHQSxNQUFNLEdBQUssa0JBQWQsQ0FBa0MsQ0FDaENBLE1BQU0sQ0FBRyxDQUNQdkUsTUFBTSxDQUFFLGdCQUFTNUksQ0FBVCxDQUFZdEksR0FBWixDQUFpQmttQixHQUFqQixDQUFzQixDQUM1QixNQUFPcUIsa0JBQWlCLENBQUNqZixDQUFELENBQUl0SSxHQUFKLENBQVMsSUFBVCxDQUFqQixDQUFnQ21PLFFBQWhDLEVBQVAsQ0FDRCxDQUhNLENBQVQsQ0FLRCxDQU5ELElBTU8sSUFBR3NILE1BQU0sR0FBSyxVQUFYLEVBQXlCQSxNQUFNLEdBQUssWUFBdkMsQ0FBcUQsQ0FDMURBLE1BQU0sQ0FBRyxDQUNQdkUsTUFBTSxDQUFFLGdCQUFTNUksQ0FBVCxDQUFZdEksR0FBWixDQUFpQixDQUN2QixNQUFPK0YsTUFBSyxDQUFDZ2xCLEtBQU4sQ0FBWUMsZUFBWixDQUE0QmhyQixHQUE1QixDQUFpQ3NJLENBQWpDLENBQW9DdWlCLGFBQXBDLENBQVAsQ0FDRCxDQUhNLENBQVQsQ0FLRCxDQU5NLElBTUEsSUFBRyxDQUFDLEtBQUQsQ0FBUSxNQUFSLENBQWdCLE1BQWhCLENBQXdCLElBQXhCLEVBQThCelUsT0FBOUIsQ0FBc0NYLE1BQXRDLElBQWtELENBQUMsQ0FBdEQsQ0FBeUQsQ0FDOURBLE1BQU0sQ0FBRyxDQUFFdkUsTUFBTSxDQUFFLGdCQUFTcEUsQ0FBVCxDQUFZLENBQUUsTUFBT0EsRUFBUCxDQUFXLENBQW5DLENBQVQsQ0FDRCxDQUZNLElBRUEsSUFBRyxNQUFPMkksT0FBUCxHQUFrQixRQUFyQixDQUErQixDQUNwQyxLQUFNLElBQUkxWCxNQUFKLENBQVUsbUNBQXFDMFgsTUFBckMsQ0FBOEMsSUFBeEQsQ0FBTixDQUNELENBRUQ7QUFDQSxHQUFJM0ksRUFBQyxDQUFHMkksTUFBTSxDQUFDdkUsTUFBUCxDQUFjclIsSUFBZCxDQUFvQkcsR0FBcEIsQ0FBeUIsSUFBekIsQ0FBUixDQUNBLE1BQU95RyxJQUFHLENBQUNOLEdBQUosQ0FBUWloQixPQUFSLENBQWdCdGEsQ0FBaEIsQ0FBbUI5TSxHQUFuQixDQUF3QixJQUF4QixDQUFQLENBQ0QsQ0E1QkQsQ0E4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQStCQ0EsR0FBRyxDQUFDaXJCLE1BQUosQ0FBYSxTQUFTakYsTUFBVCxDQUFpQmtGLFNBQWpCLENBQTRCelYsTUFBNUIsQ0FBb0MsQ0FDL0MsR0FBRyxNQUFPQSxPQUFQLEdBQWtCLFFBQXJCLENBQStCLENBQzdCQSxNQUFNLENBQUdBLE1BQU0sQ0FBQ3FWLFdBQVAsRUFBVCxDQUNELENBRkQsSUFFTyxJQUFHclYsTUFBTSxHQUFLekwsU0FBZCxDQUF5QixDQUM5QnlMLE1BQU0sQ0FBRyxtQkFBVCxDQUNELENBRUQsR0FBR0EsTUFBTSxHQUFLLG1CQUFkLENBQW1DLENBQ2pDQSxNQUFNLENBQUcsQ0FDUHdWLE1BQU0sQ0FBRSxnQkFBU2pGLE1BQVQsQ0FBaUJ4ZCxDQUFqQixDQUFvQixDQUMxQjtBQUNBQSxDQUFDLENBQUdxZixpQkFBaUIsQ0FBQ3JmLENBQUQsQ0FBSXhJLEdBQUosQ0FBUyxJQUFULENBQXJCLENBQ0E7QUFDQSxHQUFJb1UsSUFBRyxDQUFHcUgsSUFBSSxDQUFDaUQsT0FBTCxDQUFhbFcsQ0FBYixDQUFWLENBQ0E7QUFDQSxNQUFPd2QsT0FBTSxHQUFLNVIsR0FBRyxDQUFDdUQsS0FBSixDQUFVLENBQVYsRUFBYUEsS0FBL0IsQ0FDRCxDQVJNLENBQVQsQ0FVRCxDQVhELElBV08sSUFBR2xDLE1BQU0sR0FBSyxNQUFYLEVBQXFCQSxNQUFNLEdBQUssTUFBaEMsRUFBMENBLE1BQU0sR0FBSyxJQUF4RCxDQUE4RCxDQUNuRUEsTUFBTSxDQUFHLENBQ1B3VixNQUFNLENBQUUsZ0JBQVNqRixNQUFULENBQWlCeGQsQ0FBakIsQ0FBb0IsQ0FDMUI7QUFDQUEsQ0FBQyxDQUFHcWYsaUJBQWlCLENBQUNyZixDQUFELENBQUl4SSxHQUFKLENBQVMsSUFBVCxDQUFyQixDQUNBLE1BQU9nbUIsT0FBTSxHQUFLeGQsQ0FBbEIsQ0FDRCxDQUxNLENBQVQsQ0FPRCxDQUVEO0FBQ0EsR0FBSUEsRUFBQyxDQUFHL0IsR0FBRyxDQUFDTixHQUFKLENBQVFvQixPQUFSLENBQWdCMmpCLFNBQWhCLENBQTJCbHJCLEdBQTNCLENBQWdDLElBQWhDLENBQXNDLEtBQXRDLENBQVIsQ0FDQSxNQUFPeVYsT0FBTSxDQUFDd1YsTUFBUCxDQUFjakYsTUFBZCxDQUFzQnhkLENBQXRCLENBQXlCeEksR0FBRyxDQUFDOEksQ0FBSixDQUFNOGQsU0FBTixFQUF6QixDQUFQLENBQ0YsQ0EvQkEsQ0FpQ0QsTUFBTzVtQixJQUFQLENBQ0QsQ0F0SEQsQ0F3SEE7Ozs7Ozs7Ozs7Ozs7O0dBZUF5RyxHQUFHLENBQUMwa0IsZ0JBQUosQ0FBdUIxa0IsR0FBRyxDQUFDTixHQUFKLENBQVFtQixhQUFSLENBQXdCLFNBQzdDd0IsQ0FENkMsQ0FDMUNnRSxDQUQwQyxDQUN2Q3RFLENBRHVDLENBQ3BDYyxDQURvQyxDQUNqQzJNLENBRGlDLENBQzlCbVEsRUFEOEIsQ0FDMUJJLEVBRDBCLENBQ3RCQyxJQURzQixDQUNoQixDQUM3QixHQUFJem1CLElBQUcsQ0FBRyxDQUNSOEksQ0FBQyxDQUFFQSxDQURLLENBRVJnRSxDQUFDLENBQUVBLENBRkssQ0FHUnRFLENBQUMsQ0FBRUEsQ0FISyxDQUlSYyxDQUFDLENBQUVBLENBSkssQ0FLUjJNLENBQUMsQ0FBRUEsQ0FMSyxDQU1SbVEsRUFBRSxDQUFFQSxFQU5JLENBT1JJLEVBQUUsQ0FBRUEsRUFQSSxDQVFSQyxJQUFJLENBQUVBLElBUkUsQ0FBVixDQVdBOzs7Ozs7Ozs7Ozs7S0FhQXptQixHQUFHLENBQUN1SCxPQUFKLENBQWMsU0FBUzFILElBQVQsQ0FBZTRWLE1BQWYsQ0FBdUJvVixhQUF2QixDQUFzQyxDQUNsRCxHQUFHLE1BQU9wVixPQUFQLEdBQWtCLFFBQXJCLENBQStCLENBQzdCQSxNQUFNLENBQUdBLE1BQU0sQ0FBQ3FWLFdBQVAsRUFBVCxDQUNELENBRkQsSUFFTyxJQUFHclYsTUFBTSxHQUFLekwsU0FBZCxDQUF5QixDQUM5QnlMLE1BQU0sQ0FBRyxrQkFBVCxDQUNELENBRUQ7QUFDQSxHQUFJak4sRUFBQyxDQUFHL0IsR0FBRyxDQUFDTixHQUFKLENBQVFvQixPQUFSLENBQWdCMUgsSUFBaEIsQ0FBc0JHLEdBQXRCLENBQTJCLEtBQTNCLENBQWtDLEtBQWxDLENBQVIsQ0FFQSxHQUFHeVYsTUFBTSxHQUFLLGtCQUFkLENBQWtDLENBQ2hDQSxNQUFNLENBQUcsQ0FBRTNFLE1BQU0sQ0FBRStXLGlCQUFWLENBQVQsQ0FDRCxDQUZELElBRU8sSUFBR3BTLE1BQU0sR0FBSyxVQUFYLEVBQXlCQSxNQUFNLEdBQUssWUFBdkMsQ0FBcUQsQ0FDMURBLE1BQU0sQ0FBRyxDQUNQM0UsTUFBTSxDQUFFLGdCQUFTdEksQ0FBVCxDQUFZeEksR0FBWixDQUFpQixDQUN2QixNQUFPK0YsTUFBSyxDQUFDZ2xCLEtBQU4sQ0FBWUssZUFBWixDQUE0QnByQixHQUE1QixDQUFpQ3dJLENBQWpDLENBQW9DcWlCLGFBQXBDLENBQVAsQ0FDRCxDQUhNLENBQVQsQ0FLRCxDQU5NLElBTUEsSUFBRyxDQUFDLEtBQUQsQ0FBUSxNQUFSLENBQWdCLE1BQWhCLENBQXdCLElBQXhCLEVBQThCelUsT0FBOUIsQ0FBc0NYLE1BQXRDLElBQWtELENBQUMsQ0FBdEQsQ0FBeUQsQ0FDOURBLE1BQU0sQ0FBRyxDQUFFM0UsTUFBTSxDQUFFLGdCQUFTdEksQ0FBVCxDQUFZLENBQUUsTUFBT0EsRUFBUCxDQUFXLENBQW5DLENBQVQsQ0FDRCxDQUZNLElBRUEsQ0FDTCxLQUFNLElBQUl6SyxNQUFKLENBQVUsbUNBQXFDMFgsTUFBckMsQ0FBOEMsSUFBeEQsQ0FBTixDQUNELENBRUQ7QUFDQSxNQUFPQSxPQUFNLENBQUMzRSxNQUFQLENBQWN0SSxDQUFkLENBQWlCeEksR0FBakIsQ0FBc0IsS0FBdEIsQ0FBUCxDQUNELENBMUJELENBNEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FtQkFBLEdBQUcsQ0FBQ3FyQixJQUFKLENBQVcsU0FBU2pJLEVBQVQsQ0FBYTNOLE1BQWIsQ0FBcUIsQ0FDOUI7OztvQkFEOEIsQ0FNOUI7QUFDQSxHQUFJNFIsR0FBRSxDQUFHLEtBQVQsQ0FFQSxHQUFHLE1BQU81UixPQUFQLEdBQWtCLFFBQXJCLENBQStCLENBQzdCQSxNQUFNLENBQUdBLE1BQU0sQ0FBQ3FWLFdBQVAsRUFBVCxDQUNELENBRUQsR0FBR3JWLE1BQU0sR0FBS3pMLFNBQVgsRUFBd0J5TCxNQUFNLEdBQUssbUJBQXRDLENBQTJELENBQ3pEQSxNQUFNLENBQUcsQ0FBRXZFLE1BQU0sQ0FBRXlVLGtCQUFWLENBQVQsQ0FDQTBCLEVBQUUsQ0FBRyxJQUFMLENBQ0QsQ0FIRCxJQUdPLElBQUc1UixNQUFNLEdBQUssTUFBWCxFQUFxQkEsTUFBTSxHQUFLLE1BQWhDLEVBQTBDQSxNQUFNLEdBQUssSUFBeEQsQ0FBOEQsQ0FDbkVBLE1BQU0sQ0FBRyxDQUFFdkUsTUFBTSxDQUFFLGlCQUFXLENBQUUsTUFBT2tTLEdBQVAsQ0FBWSxDQUFuQyxDQUFULENBQ0FpRSxFQUFFLENBQUcsSUFBTCxDQUNELENBRUQ7QUFDQSxHQUFJN2UsRUFBQyxDQUFHaU4sTUFBTSxDQUFDdkUsTUFBUCxDQUFja1MsRUFBZCxDQUFrQnBqQixHQUFHLENBQUM4SSxDQUFKLENBQU04ZCxTQUFOLEVBQWxCLENBQVIsQ0FDQSxNQUFPbmdCLElBQUcsQ0FBQ04sR0FBSixDQUFRaWhCLE9BQVIsQ0FBZ0I1ZSxDQUFoQixDQUFtQnhJLEdBQW5CLENBQXdCcW5CLEVBQXhCLENBQVAsQ0FDRCxDQXhCRCxDQTBCQSxNQUFPcm5CLElBQVAsQ0FDRCxDQXBHRCxDQXNHQTs7Ozs7O0dBT0F5RyxHQUFHLENBQUM2a0IsaUJBQUosQ0FBd0IsU0FBU0MsTUFBVCxDQUFpQixDQUN2QztBQUNBLE1BQU85UCxLQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUNqRTtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRVQsSUFBSSxDQUFDcUcsWUFBTCxDQUFrQixDQUFsQixFQUFxQjNULFFBQXJCLEVBREYsQ0FGaUUsQ0FJakU7QUFDQXNOLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEckIsSUFBSSxDQUFDamIsTUFBTCxDQUNFaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRGIsQ0FDd0JGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQURsQyxDQUN1QyxLQUR2QyxDQUVFYixJQUFJLENBQUNrRSxRQUFMLENBQWNsWixHQUFHLENBQUN1YyxJQUFKLENBQVN3SSxhQUF2QixFQUFzQ3JkLFFBQXRDLEVBRkYsQ0FEMEQsQ0FJMURzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTSxJQUE1QyxDQUFrRCxLQUFsRCxDQUF5RCxFQUF6RCxDQUowRCxDQUE1RCxDQUxpRSxDQVdqRTtBQUNBWixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUE1QyxDQUF5RCxLQUF6RCxDQUNFWCxJQUFJLENBQUMrRCxLQUFMLENBQVcrTCxNQUFYLEVBQW1CcGQsUUFBbkIsRUFERixDQVppRSxDQUE1RCxDQUFQLENBZUQsQ0FqQkQsQ0FtQkE7Ozs7Ozs7R0FRQTFILEdBQUcsQ0FBQzJqQixrQkFBSixDQUF5QixTQUFTaFcsR0FBVCxDQUFjLENBQ3JDO0FBQ0EsR0FBSStOLFFBQU8sQ0FBRyxFQUFkLENBQ0EsR0FBSS9lLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBR3FZLElBQUksQ0FBQ3dHLFFBQUwsQ0FBYzdOLEdBQWQsQ0FBbUJtUixtQkFBbkIsQ0FBd0NwRCxPQUF4QyxDQUFpRC9lLE1BQWpELENBQUgsQ0FBNkQsQ0FDM0RnUixHQUFHLENBQUdxSCxJQUFJLENBQUNpRCxPQUFMLENBQWEzWSxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCNlMsT0FBTyxDQUFDcmIsVUFBaEMsQ0FBYixDQUFOLENBQ0QsQ0FFRDtBQUNBcWIsT0FBTyxDQUFHLEVBQVYsQ0FDQS9lLE1BQU0sQ0FBRyxFQUFULENBQ0EsR0FBRyxDQUFDcVksSUFBSSxDQUFDd0csUUFBTCxDQUFjN04sR0FBZCxDQUFtQm9SLHNCQUFuQixDQUEyQ3JELE9BQTNDLENBQW9EL2UsTUFBcEQsQ0FBSixDQUFpRSxDQUMvRCxHQUFJbkQsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsNEJBQ3BCLGlEQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQ21ELE1BQU4sQ0FBZUEsTUFBZixDQUNBLEtBQU1uRCxNQUFOLENBQ0QsQ0FFRDtBQUNBO0FBQ0E7QUFDQSxHQUFJNkksRUFBSixDQUFPZ0UsQ0FBUCxDQUFVdEUsQ0FBVixDQUFhYyxDQUFiLENBQWdCMk0sQ0FBaEIsQ0FBbUJtUSxFQUFuQixDQUF1QkksRUFBdkIsQ0FBMkJDLElBQTNCLENBQ0EzZCxDQUFDLENBQUcvQyxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCNlMsT0FBTyxDQUFDc0osaUJBQWhDLEVBQW1EL2IsS0FBbkQsRUFBSixDQUNBNUMsQ0FBQyxDQUFHL0csS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QjZTLE9BQU8sQ0FBQ3VKLHdCQUFoQyxFQUEwRGhjLEtBQTFELEVBQUosQ0FDQWxILENBQUMsQ0FBR3pDLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0I2UyxPQUFPLENBQUN3Six5QkFBaEMsRUFBMkRqYyxLQUEzRCxFQUFKLENBQ0FwRyxDQUFDLENBQUd2RCxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCNlMsT0FBTyxDQUFDeUosZ0JBQWhDLEVBQWtEbGMsS0FBbEQsRUFBSixDQUNBdUcsQ0FBQyxDQUFHbFEsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QjZTLE9BQU8sQ0FBQzBKLGdCQUFoQyxFQUFrRG5jLEtBQWxELEVBQUosQ0FDQTBXLEVBQUUsQ0FBR3JnQixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCNlMsT0FBTyxDQUFDMkosbUJBQWhDLEVBQXFEcGMsS0FBckQsRUFBTCxDQUNBOFcsRUFBRSxDQUFHemdCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0I2UyxPQUFPLENBQUM0SixtQkFBaEMsRUFBcURyYyxLQUFyRCxFQUFMLENBQ0ErVyxJQUFJLENBQUcxZ0IsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QjZTLE9BQU8sQ0FBQzZKLHFCQUFoQyxFQUF1RHRjLEtBQXZELEVBQVAsQ0FFQTtBQUNBLE1BQU9qSixJQUFHLENBQUMwa0IsZ0JBQUosQ0FDTCxHQUFJL0YsV0FBSixDQUFldGMsQ0FBZixDQUFrQixFQUFsQixDQURLLENBRUwsR0FBSXNjLFdBQUosQ0FBZXRZLENBQWYsQ0FBa0IsRUFBbEIsQ0FGSyxDQUdMLEdBQUlzWSxXQUFKLENBQWU1YyxDQUFmLENBQWtCLEVBQWxCLENBSEssQ0FJTCxHQUFJNGMsV0FBSixDQUFlOWIsQ0FBZixDQUFrQixFQUFsQixDQUpLLENBS0wsR0FBSThiLFdBQUosQ0FBZW5QLENBQWYsQ0FBa0IsRUFBbEIsQ0FMSyxDQU1MLEdBQUltUCxXQUFKLENBQWVnQixFQUFmLENBQW1CLEVBQW5CLENBTkssQ0FPTCxHQUFJaEIsV0FBSixDQUFlb0IsRUFBZixDQUFtQixFQUFuQixDQVBLLENBUUwsR0FBSXBCLFdBQUosQ0FBZXFCLElBQWYsQ0FBcUIsRUFBckIsQ0FSSyxDQUFQLENBU0QsQ0F6Q0QsQ0EyQ0E7Ozs7OztHQU9BaGdCLEdBQUcsQ0FBQ3dsQixnQkFBSixDQUF1QnhsQixHQUFHLENBQUN5bEIseUJBQUosQ0FBZ0MsU0FBU2xzQixHQUFULENBQWMsQ0FDbkU7QUFDQSxNQUFPeWIsS0FBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDakU7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0VULElBQUksQ0FBQ3FHLFlBQUwsQ0FBa0IsQ0FBbEIsRUFBcUIzVCxRQUFyQixFQURGLENBRmlFLENBSWpFO0FBQ0FzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUE1QyxDQUFxRCxLQUFyRCxDQUNFaVEsVUFBVSxDQUFDbnNCLEdBQUcsQ0FBQzhJLENBQUwsQ0FEWixDQUxpRSxDQU9qRTtBQUNBMlMsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRWlRLFVBQVUsQ0FBQ25zQixHQUFHLENBQUM4TSxDQUFMLENBRFosQ0FSaUUsQ0FVakU7QUFDQTJPLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0VpUSxVQUFVLENBQUNuc0IsR0FBRyxDQUFDd0ksQ0FBTCxDQURaLENBWGlFLENBYWpFO0FBQ0FpVCxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUE1QyxDQUFxRCxLQUFyRCxDQUNFaVEsVUFBVSxDQUFDbnNCLEdBQUcsQ0FBQ3NKLENBQUwsQ0FEWixDQWRpRSxDQWdCakU7QUFDQW1TLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0VpUSxVQUFVLENBQUNuc0IsR0FBRyxDQUFDaVcsQ0FBTCxDQURaLENBakJpRSxDQW1CakU7QUFDQXdGLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0VpUSxVQUFVLENBQUNuc0IsR0FBRyxDQUFDb21CLEVBQUwsQ0FEWixDQXBCaUUsQ0FzQmpFO0FBQ0EzSyxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUE1QyxDQUFxRCxLQUFyRCxDQUNFaVEsVUFBVSxDQUFDbnNCLEdBQUcsQ0FBQ3dtQixFQUFMLENBRFosQ0F2QmlFLENBeUJqRTtBQUNBL0ssSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRWlRLFVBQVUsQ0FBQ25zQixHQUFHLENBQUN5bUIsSUFBTCxDQURaLENBMUJpRSxDQUE1RCxDQUFQLENBNkJELENBL0JELENBaUNBOzs7Ozs7R0FPQWhnQixHQUFHLENBQUMybEIsaUJBQUosQ0FBd0IsU0FBU2hZLEdBQVQsQ0FBYyxDQUNwQztBQUNBLEdBQUkrTixRQUFPLENBQUcsRUFBZCxDQUNBLEdBQUkvZSxPQUFNLENBQUcsRUFBYixDQUNBLEdBQUdxWSxJQUFJLENBQUN3RyxRQUFMLENBQWM3TixHQUFkLENBQW1Cc1Isa0JBQW5CLENBQXVDdkQsT0FBdkMsQ0FBZ0QvZSxNQUFoRCxDQUFILENBQTRELENBQzFEO0FBQ0EsR0FBSXdjLElBQUcsQ0FBR25FLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ2tLLFlBQXRCLENBQVYsQ0FDQSxHQUFHek0sR0FBRyxHQUFLblosR0FBRyxDQUFDdWMsSUFBSixDQUFTd0ksYUFBcEIsQ0FBbUMsQ0FDakMsR0FBSXZyQixNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxzQ0FBVixDQUFaLENBQ0FrQyxLQUFLLENBQUMyZixHQUFOLENBQVlBLEdBQVosQ0FDQSxLQUFNM2YsTUFBTixDQUNELENBQ0RtVSxHQUFHLENBQUcrTixPQUFPLENBQUNtSyxZQUFkLENBQ0QsQ0FFRDtBQUNBbHBCLE1BQU0sQ0FBRyxFQUFULENBQ0EsR0FBRyxDQUFDcVksSUFBSSxDQUFDd0csUUFBTCxDQUFjN04sR0FBZCxDQUFtQnFSLHFCQUFuQixDQUEwQ3RELE9BQTFDLENBQW1EL2UsTUFBbkQsQ0FBSixDQUFnRSxDQUM5RCxHQUFJbkQsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsMkJBQ3BCLGdEQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQ21ELE1BQU4sQ0FBZUEsTUFBZixDQUNBLEtBQU1uRCxNQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUk2SSxFQUFDLENBQUcvQyxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCNlMsT0FBTyxDQUFDb0ssZ0JBQWhDLEVBQWtEN2MsS0FBbEQsRUFBUixDQUNBLEdBQUk1QyxFQUFDLENBQUcvRyxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCNlMsT0FBTyxDQUFDcUssaUJBQWhDLEVBQW1EOWMsS0FBbkQsRUFBUixDQUVBO0FBQ0EsTUFBT2pKLElBQUcsQ0FBQzRqQixlQUFKLENBQ0wsR0FBSWpGLFdBQUosQ0FBZXRjLENBQWYsQ0FBa0IsRUFBbEIsQ0FESyxDQUVMLEdBQUlzYyxXQUFKLENBQWV0WSxDQUFmLENBQWtCLEVBQWxCLENBRkssQ0FBUCxDQUdELENBaENELENBa0NBOzs7Ozs7R0FPQXJHLEdBQUcsQ0FBQ2dtQixlQUFKLENBQXNCaG1CLEdBQUcsQ0FBQ2ltQiwrQkFBSixDQUFzQyxTQUFTMXNCLEdBQVQsQ0FBYyxDQUN4RTtBQUNBLE1BQU95YixLQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUNqRTtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY2xaLEdBQUcsQ0FBQ3VjLElBQUosQ0FBU3dJLGFBQXZCLEVBQXNDcmQsUUFBdEMsRUFERixDQUYwRCxDQUkxRDtBQUNBc04sSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU0sSUFBNUMsQ0FBa0QsS0FBbEQsQ0FBeUQsRUFBekQsQ0FMMEQsQ0FBNUQsQ0FGaUUsQ0FTakU7QUFDQVosSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FBNUMsQ0FBdUQsS0FBdkQsQ0FBOEQsQ0FDNUQxVixHQUFHLENBQUNrbUIsdUJBQUosQ0FBNEIzc0IsR0FBNUIsQ0FENEQsQ0FBOUQsQ0FWaUUsQ0FBNUQsQ0FBUCxDQWNELENBaEJELENBa0JBOzs7Ozs7R0FPQXlHLEdBQUcsQ0FBQ2ttQix1QkFBSixDQUE4QixTQUFTM3NCLEdBQVQsQ0FBYyxDQUMxQztBQUNBLE1BQU95YixLQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUNqRTtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRWlRLFVBQVUsQ0FBQ25zQixHQUFHLENBQUM4SSxDQUFMLENBRFosQ0FGaUUsQ0FJakU7QUFDQTJTLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0VpUSxVQUFVLENBQUNuc0IsR0FBRyxDQUFDOE0sQ0FBTCxDQURaLENBTGlFLENBQTVELENBQVAsQ0FRRCxDQVZELENBWUE7Ozs7Ozs7OztHQVVBLFFBQVN5YSxrQkFBVCxDQUEyQmpmLENBQTNCLENBQThCdEksR0FBOUIsQ0FBbUNxbkIsRUFBbkMsQ0FBdUMsQ0FDckMsR0FBSUMsR0FBRSxDQUFHdmhCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBVCxDQUVBO0FBQ0EsR0FBSTdLLEVBQUMsQ0FBR0ksSUFBSSxDQUFDOEwsSUFBTCxDQUFVM1EsR0FBRyxDQUFDOEksQ0FBSixDQUFNOGQsU0FBTixHQUFvQixDQUE5QixDQUFSLENBRUEsNkJBQ0EsR0FBR3RlLENBQUMsQ0FBQ3JLLE1BQUYsQ0FBWXdHLENBQUMsQ0FBRyxFQUFuQixDQUF3QixDQUN0QixHQUFJeEUsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsOENBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDaEMsTUFBTixDQUFlcUssQ0FBQyxDQUFDckssTUFBakIsQ0FDQWdDLEtBQUssQ0FBQzhPLEdBQU4sQ0FBWXRLLENBQUMsQ0FBRyxFQUFoQixDQUNBLEtBQU14RSxNQUFOLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7c0NBZHFDLENBOEJyQztBQUNBcW5CLEVBQUUsQ0FBQ3ZhLE9BQUgsQ0FBVyxJQUFYLEVBQ0F1YSxFQUFFLENBQUN2YSxPQUFILENBQVdzYSxFQUFYLEVBRUE7QUFDQSxHQUFJdUYsT0FBTSxDQUFHbm9CLENBQUMsQ0FBRyxDQUFKLENBQVE2RCxDQUFDLENBQUNySyxNQUF2QixDQUNBLEdBQUk0dUIsUUFBSixDQUNBO0FBQ0EsR0FBR3hGLEVBQUUsR0FBSyxJQUFQLEVBQWVBLEVBQUUsR0FBSyxJQUF6QixDQUErQixDQUM3QndGLE9BQU8sQ0FBSXhGLEVBQUUsR0FBSyxJQUFSLENBQWdCLElBQWhCLENBQXVCLElBQWpDLENBQ0EsSUFBSSxHQUFJbGYsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHeWtCLE1BQW5CLENBQTJCLEVBQUV6a0IsQ0FBN0IsQ0FBZ0MsQ0FDOUJtZixFQUFFLENBQUN2YSxPQUFILENBQVc4ZixPQUFYLEVBQ0QsQ0FDRixDQUxELElBS08sQ0FDTDtBQUNBO0FBQ0EsTUFBTUQsTUFBTSxDQUFHLENBQWYsQ0FBa0IsQ0FDaEIsR0FBSUUsU0FBUSxDQUFHLENBQWYsQ0FDQSxHQUFJQyxTQUFRLENBQUdobkIsS0FBSyxDQUFDakIsTUFBTixDQUFhcUosUUFBYixDQUFzQnllLE1BQXRCLENBQWYsQ0FDQSxJQUFJLEdBQUl6a0IsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHeWtCLE1BQW5CLENBQTJCLEVBQUV6a0IsQ0FBN0IsQ0FBZ0MsQ0FDOUIwa0IsT0FBTyxDQUFHRSxRQUFRLENBQUMxZSxVQUFULENBQW9CbEcsQ0FBcEIsQ0FBVixDQUNBLEdBQUcwa0IsT0FBTyxHQUFLLENBQWYsQ0FBa0IsQ0FDaEIsRUFBRUMsUUFBRixDQUNELENBRkQsSUFFTyxDQUNMeEYsRUFBRSxDQUFDdmEsT0FBSCxDQUFXOGYsT0FBWCxFQUNELENBQ0YsQ0FDREQsTUFBTSxDQUFHRSxRQUFULENBQ0QsQ0FDRixDQUVEO0FBQ0F4RixFQUFFLENBQUN2YSxPQUFILENBQVcsSUFBWCxFQUNBdWEsRUFBRSxDQUFDbGEsUUFBSCxDQUFZOUUsQ0FBWixFQUVBLE1BQU9nZixHQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7O0dBVUEsUUFBU08sa0JBQVQsQ0FBMkJtRixFQUEzQixDQUErQmh0QixHQUEvQixDQUFvQ2ttQixHQUFwQyxDQUF5Q3dCLEVBQXpDLENBQTZDLENBQzNDO0FBQ0EsR0FBSWpqQixFQUFDLENBQUdJLElBQUksQ0FBQzhMLElBQUwsQ0FBVTNRLEdBQUcsQ0FBQzhJLENBQUosQ0FBTThkLFNBQU4sR0FBb0IsQ0FBOUIsQ0FBUixDQUVBOzs7Ozs7OztLQUoyQyxDQWMzQztBQUNBLEdBQUlVLEdBQUUsQ0FBR3ZoQixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCMGQsRUFBeEIsQ0FBVCxDQUNBLEdBQUlDLE1BQUssQ0FBRzNGLEVBQUUsQ0FBQ2xaLE9BQUgsRUFBWixDQUNBLEdBQUlpWixHQUFFLENBQUdDLEVBQUUsQ0FBQ2xaLE9BQUgsRUFBVCxDQUNBLEdBQUc2ZSxLQUFLLEdBQUssSUFBVixFQUNBL0csR0FBRyxFQUFJbUIsRUFBRSxHQUFLLElBQWQsRUFBc0JBLEVBQUUsR0FBSyxJQUQ3QixFQUVBLENBQUNuQixHQUFELEVBQVFtQixFQUFFLEVBQUksSUFGZCxFQUdBbkIsR0FBRyxFQUFJbUIsRUFBRSxHQUFLLElBQWQsRUFBc0IsTUFBT0ssR0FBUCxHQUFlLFdBSHhDLENBR3NELENBQ3BELEtBQU0sSUFBSTNwQixNQUFKLENBQVUsOEJBQVYsQ0FBTixDQUNELENBRUQsR0FBSTZ1QixPQUFNLENBQUcsQ0FBYixDQUNBLEdBQUd2RixFQUFFLEdBQUssSUFBVixDQUFnQixDQUNkO0FBQ0F1RixNQUFNLENBQUdub0IsQ0FBQyxDQUFHLENBQUosQ0FBUWlqQixFQUFqQixDQUNBLElBQUksR0FBSXZmLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3lrQixNQUFuQixDQUEyQixFQUFFemtCLENBQTdCLENBQWdDLENBQzlCLEdBQUdtZixFQUFFLENBQUNsWixPQUFILEtBQWlCLElBQXBCLENBQTBCLENBQ3hCLEtBQU0sSUFBSXJRLE1BQUosQ0FBVSw4QkFBVixDQUFOLENBQ0QsQ0FDRixDQUNGLENBUkQsSUFRTyxJQUFHc3BCLEVBQUUsR0FBSyxJQUFWLENBQWdCLENBQ3JCO0FBQ0F1RixNQUFNLENBQUcsQ0FBVCxDQUNBLE1BQU10RixFQUFFLENBQUNycEIsTUFBSCxHQUFjLENBQXBCLENBQXVCLENBQ3JCLEdBQUdxcEIsRUFBRSxDQUFDbFosT0FBSCxLQUFpQixJQUFwQixDQUEwQixDQUN4QixFQUFFa1osRUFBRSxDQUFDOWEsSUFBTCxDQUNBLE1BQ0QsQ0FDRCxFQUFFb2dCLE1BQUYsQ0FDRCxDQUNGLENBVk0sSUFVQSxJQUFHdkYsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDckI7QUFDQXVGLE1BQU0sQ0FBRyxDQUFULENBQ0EsTUFBTXRGLEVBQUUsQ0FBQ3JwQixNQUFILEdBQWMsQ0FBcEIsQ0FBdUIsQ0FDckIsR0FBR3FwQixFQUFFLENBQUNsWixPQUFILEtBQWlCLElBQXBCLENBQTBCLENBQ3hCLEVBQUVrWixFQUFFLENBQUM5YSxJQUFMLENBQ0EsTUFDRCxDQUNELEVBQUVvZ0IsTUFBRixDQUNELENBQ0YsQ0FFRDtBQUNBLEdBQUlNLEtBQUksQ0FBRzVGLEVBQUUsQ0FBQ2xaLE9BQUgsRUFBWCxDQUNBLEdBQUc4ZSxJQUFJLEdBQUssSUFBVCxFQUFpQk4sTUFBTSxHQUFNbm9CLENBQUMsQ0FBRyxDQUFKLENBQVE2aUIsRUFBRSxDQUFDcnBCLE1BQUgsRUFBeEMsQ0FBc0QsQ0FDcEQsS0FBTSxJQUFJRixNQUFKLENBQVUsOEJBQVYsQ0FBTixDQUNELENBRUQsTUFBT3VwQixHQUFFLENBQUNuWixRQUFILEVBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7O0dBY0EsUUFBU3ljLGlCQUFULENBQTBCMUMsS0FBMUIsQ0FBaUM1cUIsT0FBakMsQ0FBMEM0TSxRQUExQyxDQUFvRCxDQUNsRCxHQUFHLE1BQU81TSxRQUFQLEdBQW1CLFVBQXRCLENBQWtDLENBQ2hDNE0sUUFBUSxDQUFHNU0sT0FBWCxDQUNBQSxPQUFPLENBQUcsRUFBVixDQUNELENBQ0RBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBRUEsR0FBSTZ2QixLQUFJLENBQUcsQ0FDVHZILFNBQVMsQ0FBRSxDQUNUamhCLElBQUksQ0FBRXJILE9BQU8sQ0FBQ3NvQixTQUFSLEVBQXFCLFVBRGxCLENBRVR0b0IsT0FBTyxDQUFFLENBQ1A0ZCxPQUFPLENBQUU1ZCxPQUFPLENBQUM0ZCxPQUFSLEVBQW1CLENBRHJCLENBRVBrUyxRQUFRLENBQUU5dkIsT0FBTyxDQUFDOHZCLFFBQVIsRUFBb0IsR0FGdkIsQ0FHUC9tQixZQUFZLENBQUUvSSxPQUFPLENBQUMrSSxZQUhmLENBRkEsQ0FERixDQUFYLENBVUEsR0FBRyxRQUFVL0ksUUFBYixDQUFzQixDQUNwQjZ2QixJQUFJLENBQUMvSSxJQUFMLENBQVk5bUIsT0FBTyxDQUFDOG1CLElBQXBCLENBQ0QsQ0FFRG5lLFFBQVEsR0FFUixRQUFTQSxTQUFULEVBQW9CLENBQ2xCO0FBQ0FvbkIsUUFBUSxDQUFDbkYsS0FBSyxDQUFDRyxLQUFQLENBQWMsU0FBU3JOLEdBQVQsQ0FBYzlCLEdBQWQsQ0FBbUIsQ0FDdkMsR0FBRzhCLEdBQUgsQ0FBUSxDQUNOLE1BQU85USxTQUFRLENBQUM4USxHQUFELENBQWYsQ0FDRCxDQUNEa04sS0FBSyxDQUFDNWUsQ0FBTixDQUFVNFAsR0FBVixDQUNBLEdBQUdnUCxLQUFLLENBQUNqUyxDQUFOLEdBQVksSUFBZixDQUFxQixDQUNuQixNQUFPcVgsT0FBTSxDQUFDdFMsR0FBRCxDQUFNa04sS0FBSyxDQUFDalMsQ0FBWixDQUFiLENBQ0QsQ0FDRG9YLFFBQVEsQ0FBQ25GLEtBQUssQ0FBQ0UsS0FBUCxDQUFja0YsTUFBZCxDQUFSLENBQ0QsQ0FUTyxDQUFSLENBVUQsQ0FFRCxRQUFTRCxTQUFULENBQWtCdEYsSUFBbEIsQ0FBd0I3ZCxRQUF4QixDQUFrQyxDQUNoQ25FLEtBQUssQ0FBQ3duQixLQUFOLENBQVlDLHFCQUFaLENBQWtDekYsSUFBbEMsQ0FBd0NvRixJQUF4QyxDQUE4Q2pqQixRQUE5QyxFQUNELENBRUQsUUFBU29qQixPQUFULENBQWdCdFMsR0FBaEIsQ0FBcUI5QixHQUFyQixDQUEwQixDQUN4QixHQUFHOEIsR0FBSCxDQUFRLENBQ04sTUFBTzlRLFNBQVEsQ0FBQzhRLEdBQUQsQ0FBZixDQUNELENBRUQ7QUFDQWtOLEtBQUssQ0FBQ2pTLENBQU4sQ0FBVWlELEdBQVYsQ0FFQTtBQUNBLEdBQUdnUCxLQUFLLENBQUM1ZSxDQUFOLENBQVF1ZCxTQUFSLENBQWtCcUIsS0FBSyxDQUFDalMsQ0FBeEIsRUFBNkIsQ0FBaEMsQ0FBbUMsQ0FDakMsR0FBSXNILElBQUcsQ0FBRzJLLEtBQUssQ0FBQzVlLENBQWhCLENBQ0E0ZSxLQUFLLENBQUM1ZSxDQUFOLENBQVU0ZSxLQUFLLENBQUNqUyxDQUFoQixDQUNBaVMsS0FBSyxDQUFDalMsQ0FBTixDQUFVc0gsR0FBVixDQUNELENBRUQ7QUFDQSxHQUFHMkssS0FBSyxDQUFDNWUsQ0FBTixDQUFRZ2QsUUFBUixDQUFpQmxCLFVBQVUsQ0FBQ21CLEdBQTVCLEVBQWlDTyxHQUFqQyxDQUFxQ29CLEtBQUssQ0FBQ3BiLENBQTNDLEVBQ0ErWixTQURBLENBQ1V6QixVQUFVLENBQUNtQixHQURyQixJQUM4QixDQURqQyxDQUNvQyxDQUNsQzJCLEtBQUssQ0FBQzVlLENBQU4sQ0FBVSxJQUFWLENBQ0FyRCxRQUFRLEdBQ1IsT0FDRCxDQUVEO0FBQ0EsR0FBR2lpQixLQUFLLENBQUNqUyxDQUFOLENBQVFxUSxRQUFSLENBQWlCbEIsVUFBVSxDQUFDbUIsR0FBNUIsRUFBaUNPLEdBQWpDLENBQXFDb0IsS0FBSyxDQUFDcGIsQ0FBM0MsRUFDQStaLFNBREEsQ0FDVXpCLFVBQVUsQ0FBQ21CLEdBRHJCLElBQzhCLENBRGpDLENBQ29DLENBQ2xDMkIsS0FBSyxDQUFDalMsQ0FBTixDQUFVLElBQVYsQ0FDQW9YLFFBQVEsQ0FBQ25GLEtBQUssQ0FBQ0UsS0FBUCxDQUFja0YsTUFBZCxDQUFSLENBQ0EsT0FDRCxDQUVEO0FBQ0FwRixLQUFLLENBQUNxQixFQUFOLENBQVdyQixLQUFLLENBQUM1ZSxDQUFOLENBQVFnZCxRQUFSLENBQWlCbEIsVUFBVSxDQUFDbUIsR0FBNUIsQ0FBWCxDQUNBMkIsS0FBSyxDQUFDc0IsRUFBTixDQUFXdEIsS0FBSyxDQUFDalMsQ0FBTixDQUFRcVEsUUFBUixDQUFpQmxCLFVBQVUsQ0FBQ21CLEdBQTVCLENBQVgsQ0FDQTJCLEtBQUssQ0FBQ3VCLEdBQU4sQ0FBWXZCLEtBQUssQ0FBQ3FCLEVBQU4sQ0FBU3hDLFFBQVQsQ0FBa0JtQixLQUFLLENBQUNzQixFQUF4QixDQUFaLENBRUE7QUFDQSxHQUFHdEIsS0FBSyxDQUFDdUIsR0FBTixDQUFVM0MsR0FBVixDQUFjb0IsS0FBSyxDQUFDcGIsQ0FBcEIsRUFBdUIrWixTQUF2QixDQUFpQ3pCLFVBQVUsQ0FBQ21CLEdBQTVDLElBQXFELENBQXhELENBQTJELENBQ3pEO0FBQ0EyQixLQUFLLENBQUM1ZSxDQUFOLENBQVU0ZSxLQUFLLENBQUNqUyxDQUFOLENBQVUsSUFBcEIsQ0FDQWhRLFFBQVEsR0FDUixPQUNELENBRUQ7QUFDQWlpQixLQUFLLENBQUNwZixDQUFOLENBQVVvZixLQUFLLENBQUM1ZSxDQUFOLENBQVF5ZCxRQUFSLENBQWlCbUIsS0FBSyxDQUFDalMsQ0FBdkIsQ0FBVixDQUNBLEdBQUdpUyxLQUFLLENBQUNwZixDQUFOLENBQVE4ZCxTQUFSLEtBQXdCc0IsS0FBSyxDQUFDSCxJQUFqQyxDQUF1QyxDQUNyQztBQUNBRyxLQUFLLENBQUNqUyxDQUFOLENBQVUsSUFBVixDQUNBb1gsUUFBUSxDQUFDbkYsS0FBSyxDQUFDRSxLQUFQLENBQWNrRixNQUFkLENBQVIsQ0FDQSxPQUNELENBRUQ7QUFDQSxHQUFJOWtCLEVBQUMsQ0FBRzBmLEtBQUssQ0FBQ3BiLENBQU4sQ0FBUTRaLFVBQVIsQ0FBbUJ3QixLQUFLLENBQUN1QixHQUF6QixDQUFSLENBQ0F2QixLQUFLLENBQUMzakIsSUFBTixDQUFhLENBQ1h1QyxVQUFVLENBQUVMLEdBQUcsQ0FBQ04sR0FBSixDQUFRbUIsYUFBUixDQUNWNGdCLEtBQUssQ0FBQ3BmLENBREksQ0FDRG9mLEtBQUssQ0FBQ3BiLENBREwsQ0FDUXRFLENBRFIsQ0FDVzBmLEtBQUssQ0FBQzVlLENBRGpCLENBQ29CNGUsS0FBSyxDQUFDalMsQ0FEMUIsQ0FFVnpOLENBQUMsQ0FBQzZkLEdBQUYsQ0FBTTZCLEtBQUssQ0FBQ3FCLEVBQVosQ0FGVSxDQUVPL2dCLENBQUMsQ0FBQzZkLEdBQUYsQ0FBTTZCLEtBQUssQ0FBQ3NCLEVBQVosQ0FGUCxDQUdWdEIsS0FBSyxDQUFDalMsQ0FBTixDQUFReVEsVUFBUixDQUFtQndCLEtBQUssQ0FBQzVlLENBQXpCLENBSFUsQ0FERCxDQUtYM0MsU0FBUyxDQUFFRixHQUFHLENBQUNOLEdBQUosQ0FBUXVqQixZQUFSLENBQXFCeEIsS0FBSyxDQUFDcGYsQ0FBM0IsQ0FBOEJvZixLQUFLLENBQUNwYixDQUFwQyxDQUxBLENBQWIsQ0FRQTVDLFFBQVEsQ0FBQyxJQUFELENBQU9nZSxLQUFLLENBQUMzakIsSUFBYixDQUFSLENBQ0QsQ0FDRixDQUVEOzs7Ozs7R0FPQSxRQUFTNG5CLFdBQVQsQ0FBb0I1ZixDQUFwQixDQUF1QixDQUNyQjtBQUNBLEdBQUlzRSxJQUFHLENBQUd0RSxDQUFDLENBQUN4SCxRQUFGLENBQVcsRUFBWCxDQUFWLENBQ0EsR0FBRzhMLEdBQUcsQ0FBQyxDQUFELENBQUgsRUFBVSxHQUFiLENBQWtCLENBQ2hCQSxHQUFHLENBQUcsS0FBT0EsR0FBYixDQUNELENBQ0QsR0FBSXZELE1BQUssQ0FBR3ZILEtBQUssQ0FBQzJELElBQU4sQ0FBV3NJLFVBQVgsQ0FBc0JuQixHQUF0QixDQUFaLENBRUE7QUFDQSxHQUFHdkQsS0FBSyxDQUFDclAsTUFBTixDQUFlLENBQWYsR0FDRDtBQUNFcVAsS0FBSyxDQUFDZSxVQUFOLENBQWlCLENBQWpCLElBQXdCLENBQXhCLEVBQ0YsQ0FBQ2YsS0FBSyxDQUFDZSxVQUFOLENBQWlCLENBQWpCLEVBQXNCLElBQXZCLElBQWlDLENBRGhDLEVBRUQ7QUFDQ2YsS0FBSyxDQUFDZSxVQUFOLENBQWlCLENBQWpCLElBQXdCLElBQXhCLEVBQ0QsQ0FBQ2YsS0FBSyxDQUFDZSxVQUFOLENBQWlCLENBQWpCLEVBQXNCLElBQXZCLElBQWlDLElBTmhDLENBQUgsQ0FNMkMsQ0FDekMsTUFBT2YsTUFBSyxDQUFDdEksTUFBTixDQUFhLENBQWIsQ0FBUCxDQUNELENBQ0QsTUFBT3NJLE1BQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7R0FVQSxRQUFTZ2MscUJBQVQsQ0FBOEJ2QixJQUE5QixDQUFvQyxDQUNsQyxHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEdBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxHQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxHQUFYLENBQWdCLE1BQU8sR0FBUCxDQUNoQixHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEdBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxFQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxHQUFYLENBQWdCLE1BQU8sRUFBUCxDQUNoQixHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEVBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxFQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxHQUFYLENBQWdCLE1BQU8sRUFBUCxDQUNoQixHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEVBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLElBQVgsQ0FBaUIsTUFBTyxFQUFQLENBQ2pCLE1BQU8sRUFBUCxDQUNELENBRUQ7Ozs7OztHQU9BLFFBQVM0QixvQkFBVCxDQUE2QjhELEVBQTdCLENBQWlDLENBQy9CLE1BQVEsT0FBT3BvQixPQUFQLEdBQWtCLFdBQWxCLEVBQ04sUUFBT0EsTUFBTSxDQUFDb2YsTUFBZCxJQUF5QixRQURuQixFQUVOLFFBQU9wZixNQUFNLENBQUNvZixNQUFQLENBQWNtRixNQUFyQixJQUFnQyxRQUYxQixFQUdOLE1BQU92a0IsT0FBTSxDQUFDb2YsTUFBUCxDQUFjbUYsTUFBZCxDQUFxQjZELEVBQXJCLENBQVAsR0FBb0MsVUFIdEMsQ0FJRCxDQUVEOzs7Ozs7OztHQVNBLFFBQVNuRCxzQkFBVCxDQUErQm1ELEVBQS9CLENBQW1DLENBQ2pDLE1BQVEsT0FBT3BvQixPQUFQLEdBQWtCLFdBQWxCLEVBQ04sUUFBT0EsTUFBTSxDQUFDcWYsUUFBZCxJQUEyQixRQURyQixFQUVOLFFBQU9yZixNQUFNLENBQUNxZixRQUFQLENBQWdCa0YsTUFBdkIsSUFBa0MsUUFGNUIsRUFHTixNQUFPdmtCLE9BQU0sQ0FBQ3FmLFFBQVAsQ0FBZ0JrRixNQUFoQixDQUF1QjZELEVBQXZCLENBQVAsR0FBc0MsVUFIeEMsQ0FJRCxDQUVELFFBQVN6RCxpQkFBVCxDQUEwQmxlLENBQTFCLENBQTZCLENBQzNCLEdBQUl3QixNQUFLLENBQUd2SCxLQUFLLENBQUMyRCxJQUFOLENBQVdzSSxVQUFYLENBQXNCbEcsQ0FBQyxDQUFDL0csUUFBRixDQUFXLEVBQVgsQ0FBdEIsQ0FBWixDQUNBLEdBQUltSCxPQUFNLENBQUcsR0FBSVMsV0FBSixDQUFlVyxLQUFLLENBQUNyUCxNQUFyQixDQUFiLENBQ0EsSUFBSSxHQUFJa0ssRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHbUYsS0FBSyxDQUFDclAsTUFBekIsQ0FBaUMsRUFBRWtLLENBQW5DLENBQXNDLENBQ3BDK0QsTUFBTSxDQUFDL0QsQ0FBRCxDQUFOLENBQVltRixLQUFLLENBQUNlLFVBQU4sQ0FBaUJsRyxDQUFqQixDQUFaLENBQ0QsQ0FDRCxNQUFPK0QsT0FBUCxDQUNELENBRUQsUUFBU3doQixtQkFBVCxDQUE0QkMsR0FBNUIsQ0FBaUMsQ0FDL0IsR0FBR0EsR0FBRyxDQUFDQyxHQUFKLEdBQVksS0FBZixDQUFzQixDQUNwQixLQUFNLElBQUk3dkIsTUFBSixDQUNKLDhCQUFnQzR2QixHQUFHLENBQUNDLEdBQXBDLENBQTBDLDZCQUR0QyxDQUFOLENBRUQsQ0FDRCxNQUFPbm5CLElBQUcsQ0FBQzBrQixnQkFBSixDQUNMMEMsZUFBZSxDQUFDRixHQUFHLENBQUM3a0IsQ0FBTCxDQURWLENBRUwra0IsZUFBZSxDQUFDRixHQUFHLENBQUM3Z0IsQ0FBTCxDQUZWLENBR0wrZ0IsZUFBZSxDQUFDRixHQUFHLENBQUNubEIsQ0FBTCxDQUhWLENBSUxxbEIsZUFBZSxDQUFDRixHQUFHLENBQUNya0IsQ0FBTCxDQUpWLENBS0x1a0IsZUFBZSxDQUFDRixHQUFHLENBQUMxWCxDQUFMLENBTFYsQ0FNTDRYLGVBQWUsQ0FBQ0YsR0FBRyxDQUFDRyxFQUFMLENBTlYsQ0FPTEQsZUFBZSxDQUFDRixHQUFHLENBQUNJLEVBQUwsQ0FQVixDQVFMRixlQUFlLENBQUNGLEdBQUcsQ0FBQ0ssRUFBTCxDQVJWLENBQVAsQ0FTRCxDQUVELFFBQVNDLGtCQUFULENBQTJCTixHQUEzQixDQUFnQyxDQUM5QixHQUFHQSxHQUFHLENBQUNDLEdBQUosR0FBWSxLQUFmLENBQXNCLENBQ3BCLEtBQU0sSUFBSTd2QixNQUFKLENBQVUsOEJBQVYsQ0FBTixDQUNELENBQ0QsTUFBTzBJLElBQUcsQ0FBQzRqQixlQUFKLENBQ0x3RCxlQUFlLENBQUNGLEdBQUcsQ0FBQzdrQixDQUFMLENBRFYsQ0FFTCtrQixlQUFlLENBQUNGLEdBQUcsQ0FBQzdnQixDQUFMLENBRlYsQ0FBUCxDQUdELENBRUQsUUFBUytnQixnQkFBVCxDQUF5QkssR0FBekIsQ0FBOEIsQ0FDNUIsTUFBTyxJQUFJOUksV0FBSixDQUFlcmYsS0FBSyxDQUFDMkQsSUFBTixDQUFXd0ksVUFBWCxDQUFzQm5NLEtBQUssQ0FBQzJELElBQU4sQ0FBV3NKLFFBQVgsQ0FBb0JrYixHQUFwQixDQUF0QixDQUFmLENBQWdFLEVBQWhFLENBQVAsQ0FDRCxDQUdELEtBQU8sQ0EzOE1HLENBNDhNVixPQTU4TVUsQ0E2OE1WLEtBQU8sU0FBU3RtQixNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7Ozs7Ozs7Ozs7O0dBaUJBLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBRUEsYUFDQUwsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDMmQsR0FBTixDQUFZM2QsS0FBSyxDQUFDMmQsR0FBTixFQUFhLEVBQTFDLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1CQTNkLEtBQUssQ0FBQzJkLEdBQU4sQ0FBVXlLLGVBQVYsQ0FBNEIsU0FBU251QixHQUFULENBQWNvdUIsRUFBZCxDQUFrQjFiLE1BQWxCLENBQTBCMmIsSUFBMUIsQ0FBZ0MsQ0FDMUQsR0FBSXZLLE9BQU0sQ0FBR3dLLGFBQWEsQ0FBQyxDQUN6QnR1QixHQUFHLENBQUVBLEdBRG9CLENBRXpCMFMsTUFBTSxDQUFFQSxNQUZpQixDQUd6Qm5MLE9BQU8sQ0FBRSxLQUhnQixDQUl6QjhtQixJQUFJLENBQUVBLElBSm1CLENBQUQsQ0FBMUIsQ0FNQXZLLE1BQU0sQ0FBQ2hRLEtBQVAsQ0FBYXNhLEVBQWIsRUFDQSxNQUFPdEssT0FBUCxDQUNELENBVEQsQ0FXQTs7Ozs7Ozs7Ozs7Ozs7R0FlQS9kLEtBQUssQ0FBQzJkLEdBQU4sQ0FBVTZLLHNCQUFWLENBQW1DLFNBQVN2dUIsR0FBVCxDQUFjcXVCLElBQWQsQ0FBb0IsQ0FDckQsTUFBT0MsY0FBYSxDQUFDLENBQ25CdHVCLEdBQUcsQ0FBRUEsR0FEYyxDQUVuQjBTLE1BQU0sQ0FBRSxJQUZXLENBR25CbkwsT0FBTyxDQUFFLEtBSFUsQ0FJbkI4bUIsSUFBSSxDQUFFQSxJQUphLENBQUQsQ0FBcEIsQ0FNRCxDQVBELENBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1CQXRvQixLQUFLLENBQUMyZCxHQUFOLENBQVU4SyxlQUFWLENBQTRCLFNBQVN4dUIsR0FBVCxDQUFjb3VCLEVBQWQsQ0FBa0IxYixNQUFsQixDQUEwQjJiLElBQTFCLENBQWdDLENBQzFELEdBQUl2SyxPQUFNLENBQUd3SyxhQUFhLENBQUMsQ0FDekJ0dUIsR0FBRyxDQUFFQSxHQURvQixDQUV6QjBTLE1BQU0sQ0FBRUEsTUFGaUIsQ0FHekJuTCxPQUFPLENBQUUsSUFIZ0IsQ0FJekI4bUIsSUFBSSxDQUFFQSxJQUptQixDQUFELENBQTFCLENBTUF2SyxNQUFNLENBQUNoUSxLQUFQLENBQWFzYSxFQUFiLEVBQ0EsTUFBT3RLLE9BQVAsQ0FDRCxDQVRELENBV0E7Ozs7Ozs7Ozs7Ozs7O0dBZUEvZCxLQUFLLENBQUMyZCxHQUFOLENBQVUrSyxzQkFBVixDQUFtQyxTQUFTenVCLEdBQVQsQ0FBY3F1QixJQUFkLENBQW9CLENBQ3JELE1BQU9DLGNBQWEsQ0FBQyxDQUNuQnR1QixHQUFHLENBQUVBLEdBRGMsQ0FFbkIwUyxNQUFNLENBQUUsSUFGVyxDQUduQm5MLE9BQU8sQ0FBRSxJQUhVLENBSW5COG1CLElBQUksQ0FBRUEsSUFKYSxDQUFELENBQXBCLENBTUQsQ0FQRCxDQVNBOzs7Ozs7O0dBUUF0b0IsS0FBSyxDQUFDMmQsR0FBTixDQUFVZ0wsU0FBVixDQUFzQixTQUFTL3BCLElBQVQsQ0FBZTBwQixJQUFmLENBQXFCLENBQ3pDLEdBQUcsQ0FBQ3Z3QixJQUFKLENBQVUsQ0FDUjZ3QixVQUFVLEdBQ1gsQ0FDRCxHQUFJN21CLEtBQUksQ0FBRyxJQUFYLENBQ0FBLElBQUksQ0FBQ25ELElBQUwsQ0FBWUEsSUFBWixDQUNBbUQsSUFBSSxDQUFDdW1CLElBQUwsQ0FBWSxHQUFJQSxLQUFKLENBQVMsQ0FDbkJPLFNBQVMsQ0FBRSxFQURRLENBRW5COUssTUFBTSxDQUFFLENBQ05zRCxPQUFPLENBQUUsaUJBQVN5SCxPQUFULENBQWtCQyxRQUFsQixDQUE0QixDQUNuQyxNQUFPL0ssYUFBWSxDQUFDamMsSUFBSSxDQUFDaW5CLEVBQU4sQ0FBVUYsT0FBVixDQUFtQkMsUUFBbkIsQ0FBNkIsS0FBN0IsQ0FBbkIsQ0FDRCxDQUhLLENBSU52bkIsT0FBTyxDQUFFLGlCQUFTc25CLE9BQVQsQ0FBa0JDLFFBQWxCLENBQTRCLENBQ25DLE1BQU8vSyxhQUFZLENBQUNqYyxJQUFJLENBQUNpbkIsRUFBTixDQUFVRixPQUFWLENBQW1CQyxRQUFuQixDQUE2QixJQUE3QixDQUFuQixDQUNELENBTkssQ0FGVyxDQUFULENBQVosQ0FXQWhuQixJQUFJLENBQUNrbkIsS0FBTCxDQUFhLEtBQWIsQ0FDRCxDQWxCRCxDQW9CQTs7Ozs7OztHQVFBanBCLEtBQUssQ0FBQzJkLEdBQU4sQ0FBVWdMLFNBQVYsQ0FBb0J0bEIsU0FBcEIsQ0FBOEJ1bEIsVUFBOUIsQ0FBMkMsU0FBU3J4QixPQUFULENBQWtCLENBQzNELEdBQUcsS0FBSzB4QixLQUFSLENBQWUsQ0FDYixPQUNELENBRUQsR0FBSWh2QixJQUFHLENBQUcxQyxPQUFPLENBQUMwQyxHQUFsQixDQUNBLEdBQUl1ZCxJQUFKLENBRUE7OztxREFLQSxHQUFHLE1BQU92ZCxJQUFQLEdBQWUsUUFBZixHQUNBQSxHQUFHLENBQUMvQixNQUFKLEdBQWUsRUFBZixFQUFxQitCLEdBQUcsQ0FBQy9CLE1BQUosR0FBZSxFQUFwQyxFQUEwQytCLEdBQUcsQ0FBQy9CLE1BQUosR0FBZSxFQUR6RCxDQUFILENBQ2lFLENBQy9EO0FBQ0ErQixHQUFHLENBQUcrRixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCdFAsR0FBeEIsQ0FBTixDQUNELENBSkQsSUFJTyxJQUFHK0YsS0FBSyxDQUFDMkQsSUFBTixDQUFXbUMsT0FBWCxDQUFtQjdMLEdBQW5CLElBQ1BBLEdBQUcsQ0FBQy9CLE1BQUosR0FBZSxFQUFmLEVBQXFCK0IsR0FBRyxDQUFDL0IsTUFBSixHQUFlLEVBQXBDLEVBQTBDK0IsR0FBRyxDQUFDL0IsTUFBSixHQUFlLEVBRGxELENBQUgsQ0FDMEQsQ0FDL0Q7QUFDQXNmLEdBQUcsQ0FBR3ZkLEdBQU4sQ0FDQUEsR0FBRyxDQUFHK0YsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUFOLENBQ0EsSUFBSSxHQUFJbkgsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHb1YsR0FBRyxDQUFDdGYsTUFBdkIsQ0FBK0IsRUFBRWtLLENBQWpDLENBQW9DLENBQ2xDbkksR0FBRyxDQUFDK00sT0FBSixDQUFZd1EsR0FBRyxDQUFDcFYsQ0FBRCxDQUFmLEVBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBRyxDQUFDcEMsS0FBSyxDQUFDMkQsSUFBTixDQUFXbUMsT0FBWCxDQUFtQjdMLEdBQW5CLENBQUosQ0FBNkIsQ0FDM0J1ZCxHQUFHLENBQUd2ZCxHQUFOLENBQ0FBLEdBQUcsQ0FBRyxFQUFOLENBRUE7QUFDQSxHQUFJeVAsSUFBRyxDQUFHOE4sR0FBRyxDQUFDdGYsTUFBSixFQUFWLENBQ0EsR0FBR3dSLEdBQUcsR0FBSyxFQUFSLEVBQWNBLEdBQUcsR0FBSyxFQUF0QixFQUE0QkEsR0FBRyxHQUFLLEVBQXZDLENBQTJDLENBQ3pDQSxHQUFHLENBQUdBLEdBQUcsR0FBSyxDQUFkLENBQ0EsSUFBSSxHQUFJdEgsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHc0gsR0FBbkIsQ0FBd0IsRUFBRXRILENBQTFCLENBQTZCLENBQzNCbkksR0FBRyxDQUFDNkssSUFBSixDQUFTMFMsR0FBRyxDQUFDOU8sUUFBSixFQUFULEVBQ0QsQ0FDRixDQUNGLENBRUQ7QUFDQSxHQUFHLENBQUMxSSxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1CN0wsR0FBbkIsQ0FBRCxFQUNELEVBQUVBLEdBQUcsQ0FBQy9CLE1BQUosR0FBZSxDQUFmLEVBQW9CK0IsR0FBRyxDQUFDL0IsTUFBSixHQUFlLENBQW5DLEVBQXdDK0IsR0FBRyxDQUFDL0IsTUFBSixHQUFlLENBQXpELENBREYsQ0FDK0QsQ0FDN0QsS0FBTSxJQUFJRixNQUFKLENBQVUsd0JBQVYsQ0FBTixDQUNELENBRUQ7QUFDQSxHQUFJc3dCLEtBQUksQ0FBRyxLQUFLQSxJQUFMLENBQVUxcEIsSUFBckIsQ0FDQSxHQUFJc3FCLFVBQVMsQ0FBSSxDQUFDLEtBQUQsQ0FBUSxLQUFSLENBQWUsS0FBZixDQUFzQixLQUF0QixFQUE2QjdZLE9BQTdCLENBQXFDaVksSUFBckMsSUFBK0MsQ0FBQyxDQUFqRSxDQUVBO0FBQ0EsS0FBS1UsRUFBTCxDQUFVcEwsVUFBVSxDQUFDM2pCLEdBQUQsQ0FBTTFDLE9BQU8sQ0FBQ2lLLE9BQVIsRUFBbUIsQ0FBQzBuQixTQUExQixDQUFwQixDQUNBLEtBQUtELEtBQUwsQ0FBYSxJQUFiLENBQ0QsQ0F2REQsQ0F5REE7Ozs7Ozs7R0FRQWpwQixLQUFLLENBQUMyZCxHQUFOLENBQVVDLFVBQVYsQ0FBdUIsU0FBUzNqQixHQUFULENBQWN1SCxPQUFkLENBQXVCLENBQzVDLEdBQUcsQ0FBQ3pKLElBQUosQ0FBVSxDQUNSNndCLFVBQVUsR0FDWCxDQUNELE1BQU9oTCxXQUFVLENBQUMzakIsR0FBRCxDQUFNdUgsT0FBTixDQUFqQixDQUNELENBTEQsQ0FPQTs7Ozs7OztHQVFBeEIsS0FBSyxDQUFDMmQsR0FBTixDQUFVSyxZQUFWLENBQXlCQSxZQUF6QixDQUVBLCtCQUVBbUwsaUJBQWlCLENBQUMsU0FBRCxDQUFZbnBCLEtBQUssQ0FBQytkLE1BQU4sQ0FBYXFMLEtBQWIsQ0FBbUJDLEdBQS9CLENBQWpCLENBQ0FGLGlCQUFpQixDQUFDLFNBQUQsQ0FBWW5wQixLQUFLLENBQUMrZCxNQUFOLENBQWFxTCxLQUFiLENBQW1CRSxHQUEvQixDQUFqQixDQUNBSCxpQkFBaUIsQ0FBQyxTQUFELENBQVlucEIsS0FBSyxDQUFDK2QsTUFBTixDQUFhcUwsS0FBYixDQUFtQkcsR0FBL0IsQ0FBakIsQ0FDQUosaUJBQWlCLENBQUMsU0FBRCxDQUFZbnBCLEtBQUssQ0FBQytkLE1BQU4sQ0FBYXFMLEtBQWIsQ0FBbUJJLEdBQS9CLENBQWpCLENBQ0FMLGlCQUFpQixDQUFDLFNBQUQsQ0FBWW5wQixLQUFLLENBQUMrZCxNQUFOLENBQWFxTCxLQUFiLENBQW1CSyxHQUEvQixDQUFqQixDQUNBTixpQkFBaUIsQ0FBQyxTQUFELENBQVlucEIsS0FBSyxDQUFDK2QsTUFBTixDQUFhcUwsS0FBYixDQUFtQk0sR0FBL0IsQ0FBakIsQ0FFQSxRQUFTUCxrQkFBVCxDQUEyQnZxQixJQUEzQixDQUFpQzBwQixJQUFqQyxDQUF1QyxDQUNyQyxHQUFJM21CLFFBQU8sQ0FBRyxRQUFWQSxRQUFVLEVBQVcsQ0FDdkIsTUFBTyxJQUFJM0IsTUFBSyxDQUFDMmQsR0FBTixDQUFVZ0wsU0FBZCxDQUF3Qi9wQixJQUF4QixDQUE4QjBwQixJQUE5QixDQUFQLENBQ0QsQ0FGRCxDQUdBdG9CLEtBQUssQ0FBQytkLE1BQU4sQ0FBYW9MLGlCQUFiLENBQStCdnFCLElBQS9CLENBQXFDK0MsT0FBckMsRUFDRCxDQUVELDBCQUVBLEdBQUk1SixLQUFJLENBQUcsS0FBWCxDQUFrQjtBQUNsQixHQUFJNHhCLEdBQUUsQ0FBRyxDQUFULENBQWtCO0FBQ2xCLEdBQUlDLEtBQUosQ0FBa0I7QUFDbEIsR0FBSUMsTUFBSixDQUFrQjtBQUNsQixHQUFJQyxLQUFKLENBQWtCO0FBQ2xCLEdBQUlDLElBQUosQ0FBa0I7QUFDbEIsR0FBSUMsS0FBSixDQUFrQjtBQUVsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUtBLFFBQVNwQixXQUFULEVBQXNCLENBQ3BCN3dCLElBQUksQ0FBRyxJQUFQLENBRUE7Ozs7Ozs7Ozs7OztJQWFBK3hCLElBQUksQ0FBRyxDQUFDLElBQUQsQ0FBTyxJQUFQLENBQWEsSUFBYixDQUFtQixJQUFuQixDQUF5QixJQUF6QixDQUErQixJQUEvQixDQUFxQyxJQUFyQyxDQUEyQyxJQUEzQyxDQUFpRCxJQUFqRCxDQUF1RCxJQUF2RCxDQUE2RCxJQUE3RCxDQUFQLENBRUE7QUFDQSxHQUFJRyxNQUFLLENBQUcsR0FBSTd4QixNQUFKLENBQVUsR0FBVixDQUFaLENBQ0EsSUFBSSxHQUFJZ0ssRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLEdBQW5CLENBQXdCLEVBQUVBLENBQTFCLENBQTZCLENBQzNCNm5CLEtBQUssQ0FBQzduQixDQUFELENBQUwsQ0FBV0EsQ0FBQyxFQUFJLENBQWhCLENBQ0E2bkIsS0FBSyxDQUFDN25CLENBQUMsQ0FBRyxHQUFMLENBQUwsQ0FBa0JBLENBQUMsQ0FBRyxHQUFMLEVBQWEsQ0FBYixDQUFpQixLQUFsQyxDQUNELENBRUQ7QUFDQXduQixJQUFJLENBQUcsR0FBSXh4QixNQUFKLENBQVUsR0FBVixDQUFQLENBQ0F5eEIsS0FBSyxDQUFHLEdBQUl6eEIsTUFBSixDQUFVLEdBQVYsQ0FBUixDQUNBMnhCLEdBQUcsQ0FBRyxHQUFJM3hCLE1BQUosQ0FBVSxDQUFWLENBQU4sQ0FDQTR4QixJQUFJLENBQUcsR0FBSTV4QixNQUFKLENBQVUsQ0FBVixDQUFQLENBQ0EsSUFBSSxHQUFJZ0ssRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLENBQW5CLENBQXNCLEVBQUVBLENBQXhCLENBQTJCLENBQ3pCMm5CLEdBQUcsQ0FBQzNuQixDQUFELENBQUgsQ0FBUyxHQUFJaEssTUFBSixDQUFVLEdBQVYsQ0FBVCxDQUNBNHhCLElBQUksQ0FBQzVuQixDQUFELENBQUosQ0FBVSxHQUFJaEssTUFBSixDQUFVLEdBQVYsQ0FBVixDQUNELENBQ0QsR0FBSTJPLEVBQUMsQ0FBRyxDQUFSLENBQVdtakIsRUFBRSxDQUFHLENBQWhCLENBQW1CQyxFQUFuQixDQUF1QkMsRUFBdkIsQ0FBMkJDLEVBQTNCLENBQStCQyxFQUEvQixDQUFtQ0MsR0FBbkMsQ0FBd0NDLEVBQXhDLENBQTRDQyxHQUE1QyxDQUNBLElBQUksR0FBSXJvQixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsR0FBbkIsQ0FBd0IsRUFBRUEsQ0FBMUIsQ0FBNkIsQ0FDM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQUQyQixDQTREM0I7QUFDQWtvQixFQUFFLENBQUdKLEVBQUUsQ0FBSUEsRUFBRSxFQUFJLENBQVosQ0FBa0JBLEVBQUUsRUFBSSxDQUF4QixDQUE4QkEsRUFBRSxFQUFJLENBQXBDLENBQTBDQSxFQUFFLEVBQUksQ0FBckQsQ0FDQUksRUFBRSxDQUFJQSxFQUFFLEVBQUksQ0FBUCxDQUFhQSxFQUFFLENBQUcsR0FBbEIsQ0FBeUIsSUFBOUIsQ0FFQTtBQUNBVixJQUFJLENBQUM3aUIsQ0FBRCxDQUFKLENBQVV1akIsRUFBVixDQUNBVCxLQUFLLENBQUNTLEVBQUQsQ0FBTCxDQUFZdmpCLENBQVosQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFwRTJCLENBaUkzQjtBQUNBd2pCLEdBQUcsQ0FBR04sS0FBSyxDQUFDSyxFQUFELENBQVgsQ0FDQUgsRUFBRSxDQUFHRixLQUFLLENBQUNsakIsQ0FBRCxDQUFWLENBQ0FxakIsRUFBRSxDQUFHSCxLQUFLLENBQUNFLEVBQUQsQ0FBVixDQUNBRSxFQUFFLENBQUdKLEtBQUssQ0FBQ0csRUFBRCxDQUFWLENBQ0FJLEVBQUUsQ0FDQ0QsR0FBRyxFQUFJLEVBQVIsQ0FBZTtBQUNkRCxFQUFFLEVBQUksRUFEUCxDQUNlO0FBQ2RBLEVBQUUsRUFBSSxDQUZQLEVBRWU7QUFDZEEsRUFBRSxDQUFHQyxHQUhOLENBREYsQ0FJaUI7QUFDakJFLEdBQUcsQ0FDRCxDQUFDTixFQUFFLENBQUdDLEVBQUwsQ0FBVUMsRUFBWCxHQUFrQixFQUFsQixDQUF3QjtBQUN4QixDQUFDdGpCLENBQUMsQ0FBR3NqQixFQUFMLEdBQVksRUFEWixDQUN3QjtBQUN4QixDQUFDdGpCLENBQUMsQ0FBR3FqQixFQUFKLENBQVNDLEVBQVYsR0FBaUIsQ0FGakIsRUFFd0I7QUFDdkJ0akIsQ0FBQyxDQUFHb2pCLEVBQUosQ0FBU0UsRUFIVixDQURGLENBSTBCO0FBQzFCO0FBQ0EsSUFBSSxHQUFJdG5CLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxDQUFuQixDQUFzQixFQUFFQSxDQUF4QixDQUEyQixDQUN6QmduQixHQUFHLENBQUNobkIsQ0FBRCxDQUFILENBQU9nRSxDQUFQLEVBQVl5akIsRUFBWixDQUNBUixJQUFJLENBQUNqbkIsQ0FBRCxDQUFKLENBQVF1bkIsRUFBUixFQUFjRyxHQUFkLENBQ0E7QUFDQTtBQUNBRCxFQUFFLENBQUdBLEVBQUUsRUFBSSxFQUFOLENBQVdBLEVBQUUsR0FBSyxDQUF2QixDQUNBQyxHQUFHLENBQUdBLEdBQUcsRUFBSSxFQUFQLENBQVlBLEdBQUcsR0FBSyxDQUExQixDQUNELENBRUQ7QUFDQSxHQUFHMWpCLENBQUMsR0FBSyxDQUFULENBQVksQ0FDVjtBQUNBQSxDQUFDLENBQUdtakIsRUFBRSxDQUFHLENBQVQsQ0FDRCxDQUhELElBR08sQ0FDTDtBQUNBO0FBQ0FuakIsQ0FBQyxDQUFHb2pCLEVBQUUsQ0FBR0YsS0FBSyxDQUFDQSxLQUFLLENBQUNBLEtBQUssQ0FBQ0UsRUFBRSxDQUFHRSxFQUFOLENBQU4sQ0FBTixDQUFkLENBQ0FILEVBQUUsRUFBSUQsS0FBSyxDQUFDQSxLQUFLLENBQUNDLEVBQUQsQ0FBTixDQUFYLENBQ0QsQ0FDRixDQUNGLENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0JBLFFBQVN0TSxXQUFULENBQW9CM2pCLEdBQXBCLENBQXlCdUgsT0FBekIsQ0FBa0MsQ0FDaEM7QUFDQSxHQUFJa3BCLEVBQUMsQ0FBR3p3QixHQUFHLENBQUMySyxLQUFKLENBQVUsQ0FBVixDQUFSLENBRUE7Ozs7Ozs7O0tBSmdDLENBY2hDO0FBQ0EsR0FBSStsQixLQUFKLENBQVVDLEdBQUcsQ0FBRyxDQUFoQixDQUNBLEdBQUlDLEdBQUUsQ0FBR0gsQ0FBQyxDQUFDeHlCLE1BQVgsQ0FDQSxHQUFJNHlCLElBQUcsQ0FBR0QsRUFBRSxDQUFHLENBQUwsQ0FBUyxDQUFuQixDQUNBLEdBQUlsWCxJQUFHLENBQUdnVyxFQUFFLENBQUdtQixHQUFmLENBQ0EsSUFBSSxHQUFJMW9CLEVBQUMsQ0FBR3lvQixFQUFaLENBQWdCem9CLENBQUMsQ0FBR3VSLEdBQXBCLENBQXlCLEVBQUV2UixDQUEzQixDQUE4QixDQUM1QnVvQixJQUFJLENBQUdELENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsQ0FBTCxDQUFSLENBQ0EsR0FBR0EsQ0FBQyxDQUFHeW9CLEVBQUosR0FBVyxDQUFkLENBQWlCLENBQ2Y7QUFDQUYsSUFBSSxDQUNGZixJQUFJLENBQUNlLElBQUksR0FBSyxFQUFULENBQWMsR0FBZixDQUFKLEVBQTJCLEVBQTNCLENBQ0FmLElBQUksQ0FBQ2UsSUFBSSxHQUFLLENBQVQsQ0FBYSxHQUFkLENBQUosRUFBMEIsRUFEMUIsQ0FFQWYsSUFBSSxDQUFDZSxJQUFJLENBQUcsR0FBUixDQUFKLEVBQW9CLENBRnBCLENBR0FmLElBQUksQ0FBQ2UsSUFBSSxHQUFLLEVBQVYsQ0FISixDQUdxQmIsSUFBSSxDQUFDYyxHQUFELENBQUosRUFBYSxFQUpwQyxDQUtBQSxHQUFHLEdBQ0osQ0FSRCxJQVFPLElBQUdDLEVBQUUsQ0FBRyxDQUFMLEVBQVd6b0IsQ0FBQyxDQUFHeW9CLEVBQUosR0FBVyxDQUF6QixDQUE2QixDQUNsQztBQUNBRixJQUFJLENBQ0ZmLElBQUksQ0FBQ2UsSUFBSSxHQUFLLEVBQVYsQ0FBSixFQUFxQixFQUFyQixDQUNBZixJQUFJLENBQUNlLElBQUksR0FBSyxFQUFULENBQWMsR0FBZixDQUFKLEVBQTJCLEVBRDNCLENBRUFmLElBQUksQ0FBQ2UsSUFBSSxHQUFLLENBQVQsQ0FBYSxHQUFkLENBQUosRUFBMEIsQ0FGMUIsQ0FHQWYsSUFBSSxDQUFDZSxJQUFJLENBQUcsR0FBUixDQUpOLENBS0QsQ0FDREQsQ0FBQyxDQUFDdG9CLENBQUQsQ0FBRCxDQUFPc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUd5b0IsRUFBTCxDQUFELENBQVlGLElBQW5CLENBQ0QsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQStDRCxHQUFHbnBCLE9BQUgsQ0FBWSxDQUNWLEdBQUlnVyxJQUFKLENBQ0EsR0FBSXVULEdBQUUsQ0FBR2YsSUFBSSxDQUFDLENBQUQsQ0FBYixDQUNBLEdBQUlnQixHQUFFLENBQUdoQixJQUFJLENBQUMsQ0FBRCxDQUFiLENBQ0EsR0FBSWlCLEdBQUUsQ0FBR2pCLElBQUksQ0FBQyxDQUFELENBQWIsQ0FDQSxHQUFJa0IsR0FBRSxDQUFHbEIsSUFBSSxDQUFDLENBQUQsQ0FBYixDQUNBLEdBQUltQixLQUFJLENBQUdULENBQUMsQ0FBQzlsQixLQUFGLENBQVEsQ0FBUixDQUFYLENBQ0ErTyxHQUFHLENBQUcrVyxDQUFDLENBQUN4eUIsTUFBUixDQUNBLElBQUksR0FBSWtLLEVBQUMsQ0FBRyxDQUFSLENBQVdncEIsRUFBRSxDQUFHelgsR0FBRyxDQUFHZ1csRUFBMUIsQ0FBOEJ2bkIsQ0FBQyxDQUFHdVIsR0FBbEMsQ0FBdUN2UixDQUFDLEVBQUl1bkIsRUFBTCxDQUFTeUIsRUFBRSxFQUFJekIsRUFBdEQsQ0FBMEQsQ0FDeEQ7QUFDQTtBQUNBO0FBQ0EsR0FBR3ZuQixDQUFDLEdBQUssQ0FBTixFQUFXQSxDQUFDLEdBQU11UixHQUFHLENBQUdnVyxFQUEzQixDQUFnQyxDQUM5QndCLElBQUksQ0FBQy9vQixDQUFELENBQUosQ0FBVXNvQixDQUFDLENBQUNVLEVBQUQsQ0FBWCxDQUNBRCxJQUFJLENBQUMvb0IsQ0FBQyxDQUFHLENBQUwsQ0FBSixDQUFjc29CLENBQUMsQ0FBQ1UsRUFBRSxDQUFHLENBQU4sQ0FBZixDQUNBRCxJQUFJLENBQUMvb0IsQ0FBQyxDQUFHLENBQUwsQ0FBSixDQUFjc29CLENBQUMsQ0FBQ1UsRUFBRSxDQUFHLENBQU4sQ0FBZixDQUNBRCxJQUFJLENBQUMvb0IsQ0FBQyxDQUFHLENBQUwsQ0FBSixDQUFjc29CLENBQUMsQ0FBQ1UsRUFBRSxDQUFHLENBQU4sQ0FBZixDQUNELENBTEQsSUFLTyxDQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxHQUFJcm9CLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzRtQixFQUFuQixDQUF1QixFQUFFNW1CLENBQXpCLENBQTRCLENBQzFCeVUsR0FBRyxDQUFHa1QsQ0FBQyxDQUFDVSxFQUFFLENBQUdyb0IsQ0FBTixDQUFQLENBQ0Fvb0IsSUFBSSxDQUFDL29CLENBQUMsRUFBSSxFQUFFLENBQUNXLENBQVAsQ0FBRixDQUFKLENBQ0Vnb0IsRUFBRSxDQUFDbkIsSUFBSSxDQUFDcFMsR0FBRyxHQUFLLEVBQVQsQ0FBTCxDQUFGLENBQ0F3VCxFQUFFLENBQUNwQixJQUFJLENBQUNwUyxHQUFHLEdBQUssRUFBUixDQUFhLEdBQWQsQ0FBTCxDQURGLENBRUF5VCxFQUFFLENBQUNyQixJQUFJLENBQUNwUyxHQUFHLEdBQUssQ0FBUixDQUFZLEdBQWIsQ0FBTCxDQUZGLENBR0EwVCxFQUFFLENBQUN0QixJQUFJLENBQUNwUyxHQUFHLENBQUcsR0FBUCxDQUFMLENBSkosQ0FLRCxDQUNGLENBQ0YsQ0FDRGtULENBQUMsQ0FBR1MsSUFBSixDQUNELENBRUQsTUFBT1QsRUFBUCxDQUNELENBRUQ7Ozs7Ozs7O0dBU0EsUUFBUzFNLGFBQVQsQ0FBc0IwTSxDQUF0QixDQUF5QmhmLEtBQXpCLENBQWdDaUIsTUFBaEMsQ0FBd0NuTCxPQUF4QyxDQUFpRCxDQUMvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUQrQyxDQXFDL0M7QUFDQTtBQUNBLEdBQUk2cEIsR0FBRSxDQUFHWCxDQUFDLENBQUN4eUIsTUFBRixDQUFXLENBQVgsQ0FBZSxDQUF4QixDQUNBLEdBQUk2eUIsR0FBSixDQUFRQyxFQUFSLENBQVlDLEVBQVosQ0FBZ0JDLEVBQWhCLENBQW9CbE8sR0FBcEIsQ0FDQSxHQUFHeGIsT0FBSCxDQUFZLENBQ1Z1cEIsRUFBRSxDQUFHZixJQUFJLENBQUMsQ0FBRCxDQUFULENBQ0FnQixFQUFFLENBQUdoQixJQUFJLENBQUMsQ0FBRCxDQUFULENBQ0FpQixFQUFFLENBQUdqQixJQUFJLENBQUMsQ0FBRCxDQUFULENBQ0FrQixFQUFFLENBQUdsQixJQUFJLENBQUMsQ0FBRCxDQUFULENBQ0FoTixHQUFHLENBQUc2TSxLQUFOLENBQ0QsQ0FORCxJQU1PLENBQ0xrQixFQUFFLENBQUdoQixHQUFHLENBQUMsQ0FBRCxDQUFSLENBQ0FpQixFQUFFLENBQUdqQixHQUFHLENBQUMsQ0FBRCxDQUFSLENBQ0FrQixFQUFFLENBQUdsQixHQUFHLENBQUMsQ0FBRCxDQUFSLENBQ0FtQixFQUFFLENBQUduQixHQUFHLENBQUMsQ0FBRCxDQUFSLENBQ0EvTSxHQUFHLENBQUc0TSxJQUFOLENBQ0QsQ0FDRCxHQUFJMEIsRUFBSixDQUFPOWtCLENBQVAsQ0FBVWhFLENBQVYsQ0FBYUMsQ0FBYixDQUFnQjhvQixFQUFoQixDQUFvQnBULEVBQXBCLENBQXdCcVQsRUFBeEIsQ0FDQUYsQ0FBQyxDQUFHNWYsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFXZ2YsQ0FBQyxDQUFDLENBQUQsQ0FBaEIsQ0FDQWxrQixDQUFDLENBQUdrRixLQUFLLENBQUNsSyxPQUFPLENBQUcsQ0FBSCxDQUFPLENBQWYsQ0FBTCxDQUF5QmtwQixDQUFDLENBQUMsQ0FBRCxDQUE5QixDQUNBbG9CLENBQUMsQ0FBR2tKLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBV2dmLENBQUMsQ0FBQyxDQUFELENBQWhCLENBQ0Fqb0IsQ0FBQyxDQUFHaUosS0FBSyxDQUFDbEssT0FBTyxDQUFHLENBQUgsQ0FBTyxDQUFmLENBQUwsQ0FBeUJrcEIsQ0FBQyxDQUFDLENBQUQsQ0FBOUIsQ0FDQSxHQUFJdG9CLEVBQUMsQ0FBRyxDQUFSLENBRUE7Ozs7OzREQU1BLElBQUksR0FBSXFwQixNQUFLLENBQUcsQ0FBaEIsQ0FBbUJBLEtBQUssQ0FBR0osRUFBM0IsQ0FBK0IsRUFBRUksS0FBakMsQ0FBd0MsQ0FDdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswRUFtSEFGLEVBQUUsQ0FDQVIsRUFBRSxDQUFDTyxDQUFDLEdBQUssRUFBUCxDQUFGLENBQ0FOLEVBQUUsQ0FBQ3hrQixDQUFDLEdBQUssRUFBTixDQUFXLEdBQVosQ0FERixDQUVBeWtCLEVBQUUsQ0FBQ3pvQixDQUFDLEdBQUssQ0FBTixDQUFVLEdBQVgsQ0FGRixDQUdBMG9CLEVBQUUsQ0FBQ3pvQixDQUFDLENBQUcsR0FBTCxDQUhGLENBR2Npb0IsQ0FBQyxDQUFDLEVBQUV0b0IsQ0FBSCxDQUpqQixDQUtBK1YsRUFBRSxDQUNBNFMsRUFBRSxDQUFDdmtCLENBQUMsR0FBSyxFQUFQLENBQUYsQ0FDQXdrQixFQUFFLENBQUN4b0IsQ0FBQyxHQUFLLEVBQU4sQ0FBVyxHQUFaLENBREYsQ0FFQXlvQixFQUFFLENBQUN4b0IsQ0FBQyxHQUFLLENBQU4sQ0FBVSxHQUFYLENBRkYsQ0FHQXlvQixFQUFFLENBQUNJLENBQUMsQ0FBRyxHQUFMLENBSEYsQ0FHY1osQ0FBQyxDQUFDLEVBQUV0b0IsQ0FBSCxDQUpqQixDQUtBb3BCLEVBQUUsQ0FDQVQsRUFBRSxDQUFDdm9CLENBQUMsR0FBSyxFQUFQLENBQUYsQ0FDQXdvQixFQUFFLENBQUN2b0IsQ0FBQyxHQUFLLEVBQU4sQ0FBVyxHQUFaLENBREYsQ0FFQXdvQixFQUFFLENBQUNLLENBQUMsR0FBSyxDQUFOLENBQVUsR0FBWCxDQUZGLENBR0FKLEVBQUUsQ0FBQzFrQixDQUFDLENBQUcsR0FBTCxDQUhGLENBR2Nra0IsQ0FBQyxDQUFDLEVBQUV0b0IsQ0FBSCxDQUpqQixDQUtBSyxDQUFDLENBQ0Nzb0IsRUFBRSxDQUFDdG9CLENBQUMsR0FBSyxFQUFQLENBQUYsQ0FDQXVvQixFQUFFLENBQUNNLENBQUMsR0FBSyxFQUFOLENBQVcsR0FBWixDQURGLENBRUFMLEVBQUUsQ0FBQ3prQixDQUFDLEdBQUssQ0FBTixDQUFVLEdBQVgsQ0FGRixDQUdBMGtCLEVBQUUsQ0FBQzFvQixDQUFDLENBQUcsR0FBTCxDQUhGLENBR2Nrb0IsQ0FBQyxDQUFDLEVBQUV0b0IsQ0FBSCxDQUpqQixDQUtBa3BCLENBQUMsQ0FBR0MsRUFBSixDQUNBL2tCLENBQUMsQ0FBRzJSLEVBQUosQ0FDQTNWLENBQUMsQ0FBR2dwQixFQUFKLENBQ0QsQ0FFRDs7Ozs7Ozs7OztLQWhOK0MsQ0EyTjlDO0FBQ0Q3ZSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQ0dxUSxHQUFHLENBQUNzTyxDQUFDLEdBQUssRUFBUCxDQUFILEVBQWlCLEVBQWxCLENBQ0N0TyxHQUFHLENBQUN4VyxDQUFDLEdBQUssRUFBTixDQUFXLEdBQVosQ0FBSCxFQUF1QixFQUR4QixDQUVDd1csR0FBRyxDQUFDeGEsQ0FBQyxHQUFLLENBQU4sQ0FBVSxHQUFYLENBQUgsRUFBc0IsQ0FGdkIsQ0FHQ3dhLEdBQUcsQ0FBQ3ZhLENBQUMsQ0FBRyxHQUFMLENBSEosQ0FHaUJpb0IsQ0FBQyxDQUFDLEVBQUV0b0IsQ0FBSCxDQUpwQixDQUtBdUssTUFBTSxDQUFDbkwsT0FBTyxDQUFHLENBQUgsQ0FBTyxDQUFmLENBQU4sQ0FDR3diLEdBQUcsQ0FBQ3hXLENBQUMsR0FBSyxFQUFQLENBQUgsRUFBaUIsRUFBbEIsQ0FDQ3dXLEdBQUcsQ0FBQ3hhLENBQUMsR0FBSyxFQUFOLENBQVcsR0FBWixDQUFILEVBQXVCLEVBRHhCLENBRUN3YSxHQUFHLENBQUN2YSxDQUFDLEdBQUssQ0FBTixDQUFVLEdBQVgsQ0FBSCxFQUFzQixDQUZ2QixDQUdDdWEsR0FBRyxDQUFDc08sQ0FBQyxDQUFHLEdBQUwsQ0FISixDQUdpQlosQ0FBQyxDQUFDLEVBQUV0b0IsQ0FBSCxDQUpwQixDQUtBdUssTUFBTSxDQUFDLENBQUQsQ0FBTixDQUNHcVEsR0FBRyxDQUFDeGEsQ0FBQyxHQUFLLEVBQVAsQ0FBSCxFQUFpQixFQUFsQixDQUNDd2EsR0FBRyxDQUFDdmEsQ0FBQyxHQUFLLEVBQU4sQ0FBVyxHQUFaLENBQUgsRUFBdUIsRUFEeEIsQ0FFQ3VhLEdBQUcsQ0FBQ3NPLENBQUMsR0FBSyxDQUFOLENBQVUsR0FBWCxDQUFILEVBQXNCLENBRnZCLENBR0N0TyxHQUFHLENBQUN4VyxDQUFDLENBQUcsR0FBTCxDQUhKLENBR2lCa2tCLENBQUMsQ0FBQyxFQUFFdG9CLENBQUgsQ0FKcEIsQ0FLQXVLLE1BQU0sQ0FBQ25MLE9BQU8sQ0FBRyxDQUFILENBQU8sQ0FBZixDQUFOLENBQ0d3YixHQUFHLENBQUN2YSxDQUFDLEdBQUssRUFBUCxDQUFILEVBQWlCLEVBQWxCLENBQ0N1YSxHQUFHLENBQUNzTyxDQUFDLEdBQUssRUFBTixDQUFXLEdBQVosQ0FBSCxFQUF1QixFQUR4QixDQUVDdE8sR0FBRyxDQUFDeFcsQ0FBQyxHQUFLLENBQU4sQ0FBVSxHQUFYLENBQUgsRUFBc0IsQ0FGdkIsQ0FHQ3dXLEdBQUcsQ0FBQ3hhLENBQUMsQ0FBRyxHQUFMLENBSEosQ0FHaUJrb0IsQ0FBQyxDQUFDLEVBQUV0b0IsQ0FBSCxDQUpwQixDQUtELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQkEsUUFBU21tQixjQUFULENBQXVCaHhCLE9BQXZCLENBQWdDLENBQzlCQSxPQUFPLENBQUdBLE9BQU8sRUFBSSxFQUFyQixDQUNBLEdBQUkrd0IsS0FBSSxDQUFHLENBQUMvd0IsT0FBTyxDQUFDK3dCLElBQVIsRUFBZ0IsS0FBakIsRUFBd0J2RCxXQUF4QixFQUFYLENBQ0EsR0FBSWxGLFVBQVMsQ0FBRyxPQUFTeUksSUFBekIsQ0FFQSxHQUFJdkssT0FBSixDQUNBLEdBQUd4bUIsT0FBTyxDQUFDaUssT0FBWCxDQUFvQixDQUNsQnVjLE1BQU0sQ0FBRy9kLEtBQUssQ0FBQytkLE1BQU4sQ0FBYTJOLGNBQWIsQ0FBNEI3TCxTQUE1QixDQUF1Q3RvQixPQUFPLENBQUMwQyxHQUEvQyxDQUFULENBQ0QsQ0FGRCxJQUVPLENBQ0w4akIsTUFBTSxDQUFHL2QsS0FBSyxDQUFDK2QsTUFBTixDQUFhNE4sWUFBYixDQUEwQjlMLFNBQTFCLENBQXFDdG9CLE9BQU8sQ0FBQzBDLEdBQTdDLENBQVQsQ0FDRCxDQUVEO0FBQ0EsR0FBSThULE1BQUssQ0FBR2dRLE1BQU0sQ0FBQ2hRLEtBQW5CLENBQ0FnUSxNQUFNLENBQUNoUSxLQUFQLENBQWUsU0FBU3NhLEVBQVQsQ0FBYTl3QixPQUFiLENBQXNCLENBQ25DO0FBQ0EsR0FBSW9WLE9BQU0sQ0FBRyxJQUFiLENBQ0EsR0FBR3BWLE9BQU8sV0FBWXlJLE1BQUssQ0FBQzJELElBQU4sQ0FBVzJDLFVBQWpDLENBQTZDLENBQzNDcUcsTUFBTSxDQUFHcFYsT0FBVCxDQUNBQSxPQUFPLENBQUcsRUFBVixDQUNELENBQ0RBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0FBLE9BQU8sQ0FBQ29WLE1BQVIsQ0FBaUJBLE1BQWpCLENBQ0FwVixPQUFPLENBQUM4d0IsRUFBUixDQUFhQSxFQUFiLENBQ0F0YSxLQUFLLENBQUN6TCxJQUFOLENBQVd5YixNQUFYLENBQW1CeG1CLE9BQW5CLEVBQ0QsQ0FYRCxDQWFBLE1BQU93bUIsT0FBUCxDQUNELENBR0QsS0FBTyxDQXBoUEcsQ0FxaFBWLE9BcmhQVSxDQXNoUFYsS0FBTyxTQUFTbGMsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNEJBLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQTtBQUNBLEdBQUkwcEIsSUFBRyxDQUFHL3BCLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVCLEtBQUssQ0FBQzRyQixHQUFOLENBQVk1ckIsS0FBSyxDQUFDNHJCLEdBQU4sRUFBYSxFQUFwRCxDQUVBOzs7Ozs7OztHQVNBQSxHQUFHLENBQUN6Z0IsTUFBSixDQUFhLFNBQVMzRyxHQUFULENBQWNqTixPQUFkLENBQXVCLENBQ2xDQSxPQUFPLENBQUdBLE9BQU8sRUFBSSxFQUFyQixDQUNBLEdBQUlpUixLQUFJLENBQUcsY0FBZ0JoRSxHQUFHLENBQUN1SyxJQUFwQixDQUEyQixXQUF0QyxDQUVBO0FBQ0EsR0FBSThjLE9BQUosQ0FDQSxHQUFHcm5CLEdBQUcsQ0FBQ3NuQixRQUFQLENBQWlCLENBQ2ZELE1BQU0sQ0FBRyxDQUNQanRCLElBQUksQ0FBRSxXQURDLENBRVBrYixNQUFNLENBQUUsQ0FBQ2pULE1BQU0sQ0FBQ3JDLEdBQUcsQ0FBQ3NuQixRQUFKLENBQWFDLE9BQWQsQ0FBUCxDQUErQnZuQixHQUFHLENBQUNzbkIsUUFBSixDQUFhL2MsSUFBNUMsQ0FGRCxDQUFULENBSUF2RyxJQUFJLEVBQUl3akIsVUFBVSxDQUFDSCxNQUFELENBQWxCLENBQ0QsQ0FDRCxHQUFHcm5CLEdBQUcsQ0FBQ3luQixhQUFQLENBQXNCLENBQ3BCSixNQUFNLENBQUcsQ0FBQ2p0QixJQUFJLENBQUUsZ0JBQVAsQ0FBeUJrYixNQUFNLENBQUUsQ0FBQ3RWLEdBQUcsQ0FBQ3luQixhQUFMLENBQWpDLENBQVQsQ0FDQXpqQixJQUFJLEVBQUl3akIsVUFBVSxDQUFDSCxNQUFELENBQWxCLENBQ0QsQ0FDRCxHQUFHcm5CLEdBQUcsQ0FBQzBuQixPQUFQLENBQWdCLENBQ2RMLE1BQU0sQ0FBRyxDQUFDanRCLElBQUksQ0FBRSxVQUFQLENBQW1Ca2IsTUFBTSxDQUFFLENBQUN0VixHQUFHLENBQUMwbkIsT0FBSixDQUFZck0sU0FBYixDQUEzQixDQUFULENBQ0EsR0FBR3JiLEdBQUcsQ0FBQzBuQixPQUFKLENBQVlDLFVBQWYsQ0FBMkIsQ0FDekJOLE1BQU0sQ0FBQy9SLE1BQVAsQ0FBY2hWLElBQWQsQ0FBbUJOLEdBQUcsQ0FBQzBuQixPQUFKLENBQVlDLFVBQS9CLEVBQ0QsQ0FDRDNqQixJQUFJLEVBQUl3akIsVUFBVSxDQUFDSCxNQUFELENBQWxCLENBQ0QsQ0FFRCxHQUFHcm5CLEdBQUcsQ0FBQzdKLE9BQVAsQ0FBZ0IsQ0FDZDtBQUNBLElBQUksR0FBSXlILEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR29DLEdBQUcsQ0FBQzdKLE9BQUosQ0FBWXpDLE1BQS9CLENBQXVDLEVBQUVrSyxDQUF6QyxDQUE0QyxDQUMxQ29HLElBQUksRUFBSXdqQixVQUFVLENBQUN4bkIsR0FBRyxDQUFDN0osT0FBSixDQUFZeUgsQ0FBWixDQUFELENBQWxCLENBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBR29DLEdBQUcsQ0FBQ3NuQixRQUFQLENBQWlCLENBQ2Z0akIsSUFBSSxFQUFJLE1BQVIsQ0FDRCxDQUVEO0FBQ0FBLElBQUksRUFBSXhJLEtBQUssQ0FBQzJELElBQU4sQ0FBVzZJLFFBQVgsQ0FBb0JoSSxHQUFHLENBQUM0bkIsSUFBeEIsQ0FBOEI3MEIsT0FBTyxDQUFDa1YsT0FBUixFQUFtQixFQUFqRCxFQUF1RCxNQUEvRCxDQUVBakUsSUFBSSxFQUFJLFlBQWNoRSxHQUFHLENBQUN1SyxJQUFsQixDQUF5QixXQUFqQyxDQUNBLE1BQU92RyxLQUFQLENBQ0QsQ0ExQ0QsQ0E0Q0E7Ozs7OztHQU9Bb2pCLEdBQUcsQ0FBQzdnQixNQUFKLENBQWEsU0FBU3RELEdBQVQsQ0FBYyxDQUN6QixHQUFJZSxLQUFJLENBQUcsRUFBWCxDQUVBO0FBQ0EsR0FBSTZqQixTQUFRLENBQUcsK0dBQWYsQ0FDQSxHQUFJQyxRQUFPLENBQUcsc0NBQWQsQ0FDQSxHQUFJQyxNQUFLLENBQUcsT0FBWixDQUNBLEdBQUlyYSxNQUFKLENBQ0EsTUFBTSxJQUFOLENBQVksQ0FDVkEsS0FBSyxDQUFHbWEsUUFBUSxDQUFDN2MsSUFBVCxDQUFjL0gsR0FBZCxDQUFSLENBQ0EsR0FBRyxDQUFDeUssS0FBSixDQUFXLENBQ1QsTUFDRCxDQUVELEdBQUkxTixJQUFHLENBQUcsQ0FDUnVLLElBQUksQ0FBRW1ELEtBQUssQ0FBQyxDQUFELENBREgsQ0FFUjRaLFFBQVEsQ0FBRSxJQUZGLENBR1JHLGFBQWEsQ0FBRSxJQUhQLENBSVJDLE9BQU8sQ0FBRSxJQUpELENBS1J2eEIsT0FBTyxDQUFFLEVBTEQsQ0FNUnl4QixJQUFJLENBQUVwc0IsS0FBSyxDQUFDMkQsSUFBTixDQUFXc0osUUFBWCxDQUFvQmlGLEtBQUssQ0FBQyxDQUFELENBQXpCLENBTkUsQ0FBVixDQVFBMUosSUFBSSxDQUFDMUQsSUFBTCxDQUFVTixHQUFWLEVBRUE7QUFDQSxHQUFHLENBQUMwTixLQUFLLENBQUMsQ0FBRCxDQUFULENBQWMsQ0FDWixTQUNELENBRUQ7QUFDQSxHQUFJc2EsTUFBSyxDQUFHdGEsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTN1csS0FBVCxDQUFla3hCLEtBQWYsQ0FBWixDQUNBLEdBQUlFLEdBQUUsQ0FBRyxDQUFULENBQ0EsTUFBTXZhLEtBQUssRUFBSXVhLEVBQUUsQ0FBR0QsS0FBSyxDQUFDdDBCLE1BQTFCLENBQWtDLENBQ2hDO0FBQ0EsR0FBSXdVLEtBQUksQ0FBRzhmLEtBQUssQ0FBQ0MsRUFBRCxDQUFMLENBQVVuMEIsT0FBVixDQUFrQixNQUFsQixDQUEwQixFQUExQixDQUFYLENBRUE7QUFDQSxJQUFJLEdBQUlvMEIsR0FBRSxDQUFHRCxFQUFFLENBQUcsQ0FBbEIsQ0FBcUJDLEVBQUUsQ0FBR0YsS0FBSyxDQUFDdDBCLE1BQWhDLENBQXdDLEVBQUV3MEIsRUFBMUMsQ0FBOEMsQ0FDNUMsR0FBSTdhLEtBQUksQ0FBRzJhLEtBQUssQ0FBQ0UsRUFBRCxDQUFoQixDQUNBLEdBQUcsQ0FBQyxLQUFLeFAsSUFBTCxDQUFVckwsSUFBSSxDQUFDLENBQUQsQ0FBZCxDQUFKLENBQXdCLENBQ3RCLE1BQ0QsQ0FDRG5GLElBQUksRUFBSW1GLElBQVIsQ0FDQTRhLEVBQUUsQ0FBR0MsRUFBTCxDQUNELENBRUQ7QUFDQXhhLEtBQUssQ0FBR3hGLElBQUksQ0FBQ3dGLEtBQUwsQ0FBV29hLE9BQVgsQ0FBUixDQUNBLEdBQUdwYSxLQUFILENBQVUsQ0FDUixHQUFJMlosT0FBTSxDQUFHLENBQUNqdEIsSUFBSSxDQUFFc1QsS0FBSyxDQUFDLENBQUQsQ0FBWixDQUFpQjRILE1BQU0sQ0FBRSxFQUF6QixDQUFiLENBQ0EsR0FBSUEsT0FBTSxDQUFHNUgsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTN1csS0FBVCxDQUFlLEdBQWYsQ0FBYixDQUNBLElBQUksR0FBSXN4QixHQUFFLENBQUcsQ0FBYixDQUFnQkEsRUFBRSxDQUFHN1MsTUFBTSxDQUFDNWhCLE1BQTVCLENBQW9DLEVBQUV5MEIsRUFBdEMsQ0FBMEMsQ0FDeENkLE1BQU0sQ0FBQy9SLE1BQVAsQ0FBY2hWLElBQWQsQ0FBbUI4bkIsS0FBSyxDQUFDOVMsTUFBTSxDQUFDNlMsRUFBRCxDQUFQLENBQXhCLEVBQ0QsQ0FFRDtBQUNBLEdBQUcsQ0FBQ25vQixHQUFHLENBQUNzbkIsUUFBUixDQUFrQixDQUNoQixHQUFHRCxNQUFNLENBQUNqdEIsSUFBUCxHQUFnQixXQUFuQixDQUFnQyxDQUM5QixLQUFNLElBQUk1RyxNQUFKLENBQVUsNENBQ2QsMENBREksQ0FBTixDQUVELENBSEQsSUFHTyxJQUFHNnpCLE1BQU0sQ0FBQy9SLE1BQVAsQ0FBYzVoQixNQUFkLEdBQXlCLENBQTVCLENBQStCLENBQ3BDLEtBQU0sSUFBSUYsTUFBSixDQUFVLGtEQUNkLGlDQURJLENBQU4sQ0FFRCxDQUNEd00sR0FBRyxDQUFDc25CLFFBQUosQ0FBZSxDQUFDQyxPQUFPLENBQUVqUyxNQUFNLENBQUMsQ0FBRCxDQUFoQixDQUFxQi9LLElBQUksQ0FBRStLLE1BQU0sQ0FBQyxDQUFELENBQWpDLENBQWYsQ0FDRCxDQVRELElBU08sSUFBRyxDQUFDdFYsR0FBRyxDQUFDeW5CLGFBQUwsRUFBc0JKLE1BQU0sQ0FBQ2p0QixJQUFQLEdBQWdCLGdCQUF6QyxDQUEyRCxDQUNoRTtBQUNBNEYsR0FBRyxDQUFDeW5CLGFBQUosQ0FBb0JuUyxNQUFNLENBQUMsQ0FBRCxDQUFOLEVBQWEsRUFBakMsQ0FDRCxDQUhNLElBR0EsSUFBRyxDQUFDdFYsR0FBRyxDQUFDMG5CLE9BQUwsRUFBZ0JMLE1BQU0sQ0FBQ2p0QixJQUFQLEdBQWdCLFVBQW5DLENBQStDLENBQ3BEO0FBQ0EsR0FBR2l0QixNQUFNLENBQUMvUixNQUFQLENBQWM1aEIsTUFBZCxHQUF5QixDQUE1QixDQUErQixDQUM3QixLQUFNLElBQUlGLE1BQUosQ0FBVSxpREFDZCx5Q0FESSxDQUFOLENBRUQsQ0FDRHdNLEdBQUcsQ0FBQzBuQixPQUFKLENBQWMsQ0FBQ3JNLFNBQVMsQ0FBRS9GLE1BQU0sQ0FBQyxDQUFELENBQWxCLENBQXVCcVMsVUFBVSxDQUFFclMsTUFBTSxDQUFDLENBQUQsQ0FBTixFQUFhLElBQWhELENBQWQsQ0FDRCxDQVBNLElBT0EsQ0FDTHRWLEdBQUcsQ0FBQzdKLE9BQUosQ0FBWW1LLElBQVosQ0FBaUIrbUIsTUFBakIsRUFDRCxDQUNGLENBRUQsRUFBRVksRUFBRixDQUNELENBRUQsR0FBR2pvQixHQUFHLENBQUNzbkIsUUFBSixHQUFpQixXQUFqQixFQUFnQyxDQUFDdG5CLEdBQUcsQ0FBQzBuQixPQUF4QyxDQUFpRCxDQUMvQyxLQUFNLElBQUlsMEIsTUFBSixDQUFVLGlEQUNkLHVEQURJLENBQU4sQ0FFRCxDQUNGLENBRUQsR0FBR3dRLElBQUksQ0FBQ3RRLE1BQUwsR0FBZ0IsQ0FBbkIsQ0FBc0IsQ0FDcEIsS0FBTSxJQUFJRixNQUFKLENBQVUsZ0NBQVYsQ0FBTixDQUNELENBRUQsTUFBT3dRLEtBQVAsQ0FDRCxDQTlGRCxDQWdHQSxRQUFTd2pCLFdBQVQsQ0FBb0JILE1BQXBCLENBQTRCLENBQzFCLEdBQUlyakIsS0FBSSxDQUFHcWpCLE1BQU0sQ0FBQ2p0QixJQUFQLENBQWMsSUFBekIsQ0FFQTtBQUNBLEdBQUlrYixPQUFNLENBQUcsRUFBYixDQUNBLEdBQUkrUyxZQUFXLENBQUcsUUFBZEEsWUFBYyxDQUFTM2EsS0FBVCxDQUFnQjRhLEVBQWhCLENBQW9CLENBQ3BDLE1BQU8sSUFBTUEsRUFBYixDQUNELENBRkQsQ0FHQSxJQUFJLEdBQUkxcUIsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHeXBCLE1BQU0sQ0FBQy9SLE1BQVAsQ0FBYzVoQixNQUFqQyxDQUF5QyxFQUFFa0ssQ0FBM0MsQ0FBOEMsQ0FDNUMwWCxNQUFNLENBQUNoVixJQUFQLENBQVkrbUIsTUFBTSxDQUFDL1IsTUFBUCxDQUFjMVgsQ0FBZCxFQUFpQjlKLE9BQWpCLENBQXlCLFlBQXpCLENBQXVDdTBCLFdBQXZDLENBQVosRUFDRCxDQUNEcmtCLElBQUksRUFBSXNSLE1BQU0sQ0FBQ3ZoQixJQUFQLENBQVksR0FBWixFQUFtQixNQUEzQixDQUVBO0FBQ0EsR0FBSUwsT0FBTSxDQUFHLENBQWIsQ0FDQSxHQUFJNjBCLFVBQVMsQ0FBRyxDQUFDLENBQWpCLENBQ0EsSUFBSSxHQUFJM3FCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR29HLElBQUksQ0FBQ3RRLE1BQXhCLENBQWdDLEVBQUVrSyxDQUFGLENBQUssRUFBRWxLLE1BQXZDLENBQStDLENBQzdDLEdBQUdBLE1BQU0sQ0FBRyxFQUFULEVBQWU2MEIsU0FBUyxHQUFLLENBQUMsQ0FBakMsQ0FBb0MsQ0FDbEMsR0FBSUMsT0FBTSxDQUFHeGtCLElBQUksQ0FBQ3VrQixTQUFELENBQWpCLENBQ0EsR0FBR0MsTUFBTSxHQUFLLEdBQWQsQ0FBbUIsQ0FDakIsRUFBRUQsU0FBRixDQUNBdmtCLElBQUksQ0FBR0EsSUFBSSxDQUFDdkosTUFBTCxDQUFZLENBQVosQ0FBZTh0QixTQUFmLEVBQTRCLE9BQTVCLENBQXNDdmtCLElBQUksQ0FBQ3ZKLE1BQUwsQ0FBWTh0QixTQUFaLENBQTdDLENBQ0QsQ0FIRCxJQUdPLENBQ0x2a0IsSUFBSSxDQUFHQSxJQUFJLENBQUN2SixNQUFMLENBQVksQ0FBWixDQUFlOHRCLFNBQWYsRUFDTCxNQURLLENBQ0lDLE1BREosQ0FDYXhrQixJQUFJLENBQUN2SixNQUFMLENBQVk4dEIsU0FBUyxDQUFHLENBQXhCLENBRHBCLENBRUQsQ0FDRDcwQixNQUFNLENBQUlrSyxDQUFDLENBQUcycUIsU0FBSixDQUFnQixDQUExQixDQUNBQSxTQUFTLENBQUcsQ0FBQyxDQUFiLENBQ0EsRUFBRTNxQixDQUFGLENBQ0QsQ0FaRCxJQVlPLElBQUdvRyxJQUFJLENBQUNwRyxDQUFELENBQUosR0FBWSxHQUFaLEVBQW1Cb0csSUFBSSxDQUFDcEcsQ0FBRCxDQUFKLEdBQVksSUFBL0IsRUFBdUNvRyxJQUFJLENBQUNwRyxDQUFELENBQUosR0FBWSxHQUF0RCxDQUEyRCxDQUNoRTJxQixTQUFTLENBQUczcUIsQ0FBWixDQUNELENBQ0YsQ0FFRCxNQUFPb0csS0FBUCxDQUNELENBRUQsUUFBU29rQixNQUFULENBQWVubEIsR0FBZixDQUFvQixDQUNsQixNQUFPQSxJQUFHLENBQUNuUCxPQUFKLENBQVksTUFBWixDQUFvQixFQUFwQixDQUFQLENBQ0QsQ0FHRCxLQUFPLENBaHdQRyxDQWl3UFYsT0Fqd1BVLENBa3dQVixLQUFPLFNBQVN1SixNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkEsR0FBSWxDLE1BQUssQ0FBR2tDLG1CQUFtQixDQUFDLENBQUQsQ0FBL0IsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBRUEsR0FBRyxNQUFPbWQsV0FBUCxHQUFzQixXQUF6QixDQUFzQyxDQUNwQyxHQUFJQSxXQUFVLENBQUdyZixLQUFLLENBQUNzZixJQUFOLENBQVdELFVBQTVCLENBQ0QsQ0FFRDtBQUNBLEdBQUkzSixLQUFJLENBQUcxVixLQUFLLENBQUMwVixJQUFqQixDQUVBLCtDQUNBLEdBQUloVixJQUFHLENBQUdWLEtBQUssQ0FBQ1UsR0FBTixDQUFZVixLQUFLLENBQUNVLEdBQU4sRUFBYSxFQUFuQyxDQUNBbUIsTUFBTSxDQUFDRCxPQUFQLENBQWlCbEIsR0FBRyxDQUFDdXNCLEdBQUosQ0FBVWp0QixLQUFLLENBQUNpdEIsR0FBTixDQUFZanRCLEtBQUssQ0FBQ2l0QixHQUFOLEVBQWEsRUFBcEQsQ0FDQSxHQUFJaFEsS0FBSSxDQUFHdmMsR0FBRyxDQUFDdWMsSUFBZixDQUVBO0FBQ0E7QUFDQSxHQUFJaVEsNkJBQTRCLENBQUcsQ0FDakN0dUIsSUFBSSxDQUFFLHlCQUQyQixDQUVqQzBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZZLENBR2pDN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGlCLENBSWpDUSxXQUFXLENBQUUsSUFKb0IsQ0FLakMzRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLDZDQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSFYsQ0FJTlEsV0FBVyxDQUFFLElBSlAsQ0FLTjNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsK0JBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxlQUxILENBQUQsQ0FNSixDQUNEeGQsSUFBSSxDQUFFLGdDQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhmLENBSURRLFdBQVcsQ0FBRSxJQUpaLENBS0QrRSxXQUFXLENBQUUsa0JBTFosQ0FOSSxDQUxELENBQUQsQ0FrQkosQ0FDRDtBQUNBMWQsSUFBSSxDQUFFLHVDQUZMLENBR0QwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIcEIsQ0FJRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUpmLENBS0RrQixXQUFXLENBQUUsS0FMWixDQU1ENkUsT0FBTyxDQUFFLGVBTlIsQ0FsQkksQ0FMMEIsQ0FBbkMsQ0FpQ0E7QUFDQTtBQUNBLEdBQUkrUSx5QkFBd0IsQ0FBRyxDQUM3QnZ1QixJQUFJLENBQUUsaUJBRHVCLENBRTdCMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRlEsQ0FHN0I3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIYSxDQUk3QlEsV0FBVyxDQUFFLElBSmdCLENBSzdCM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSxtQ0FEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhWLENBSU5RLFdBQVcsQ0FBRSxJQUpQLENBS04zRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLHVDQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsUUFMSCxDQUFELENBTUosQ0FDRHhkLElBQUksQ0FBRSx3QkFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIZixDQUlEUSxXQUFXLENBQUUsSUFKWixDQUtEM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSw2QkFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUhWLENBSU5rQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLFNBTEgsQ0FBRCxDQU1KLENBQ0R4ZCxJQUFJLENBQUUsdUNBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSGYsQ0FJRG9CLFdBQVcsQ0FBRSxLQUpaLENBS0Q2RSxPQUFPLENBQUUsbUJBTFIsQ0FOSSxDQVlKLENBQ0R4ZCxJQUFJLENBQUUsa0NBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSGYsQ0FJRG9CLFdBQVcsQ0FBRSxLQUpaLENBS0Q4RSxRQUFRLENBQUUsSUFMVCxDQU1ERCxPQUFPLENBQUUsV0FOUixDQVpJLENBbUJKLENBQ0Q7QUFDQXhkLElBQUksQ0FBRSw0QkFGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFKZixDQUtEUSxXQUFXLENBQUUsSUFMWixDQU1EOEUsUUFBUSxDQUFFLElBTlQsQ0FPRHpLLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsc0NBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxRQUxILENBQUQsQ0FQTixDQW5CSSxDQUxOLENBTkksQ0FMRCxDQUFELENBbURKLENBQ0R4ZCxJQUFJLENBQUUsa0NBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGYsQ0FJRFEsV0FBVyxDQUFFLElBSlosQ0FLRDNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsc0NBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxRQUxILENBQUQsQ0FNSixDQUNEeGQsSUFBSSxDQUFFLHFDQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUhmLENBSURrQixXQUFXLENBQUUsS0FKWixDQUtENkUsT0FBTyxDQUFFLE9BTFIsQ0FOSSxDQUxOLENBbkRJLENBTHNCLENBQS9CLENBNkVBLEdBQUlnUix5QkFBd0IsQ0FBRyxDQUM3Qnh1QixJQUFJLENBQUUsa0JBRHVCLENBRTdCMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRlEsQ0FHN0I3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIYSxDQUk3QlEsV0FBVyxDQUFFLElBSmdCLENBSzdCM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSx1QkFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUhWLENBSU5rQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLE1BTEgsQ0FBRCxDQU1KLENBQ0R4ZCxJQUFJLENBQUUsNkJBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSGYsQ0FJRG9CLFdBQVcsQ0FBRSxLQUpaLENBS0Q2RSxPQUFPLENBQUUsWUFMUixDQU5JLENBTHNCLENBQS9CLENBb0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F3Q0ExYixHQUFHLENBQUMyc0IscUJBQUosQ0FBNEIsU0FBU2hmLEdBQVQsQ0FBY2lmLFFBQWQsQ0FBd0IvMUIsT0FBeEIsQ0FBaUMsQ0FDM0Q7QUFDQUEsT0FBTyxDQUFHQSxPQUFPLEVBQUksRUFBckIsQ0FDQUEsT0FBTyxDQUFDZzJCLFFBQVIsQ0FBbUJoMkIsT0FBTyxDQUFDZzJCLFFBQVIsRUFBb0IsQ0FBdkMsQ0FDQWgyQixPQUFPLENBQUMwUixLQUFSLENBQWdCMVIsT0FBTyxDQUFDMFIsS0FBUixFQUFpQixJQUFqQyxDQUNBMVIsT0FBTyxDQUFDc29CLFNBQVIsQ0FBb0J0b0IsT0FBTyxDQUFDc29CLFNBQVIsRUFBcUIsUUFBekMsQ0FDQXRvQixPQUFPLENBQUNpMkIsWUFBUixDQUF1QmoyQixPQUFPLENBQUNpMkIsWUFBUixFQUF3QixNQUEvQyxDQUVBO0FBQ0EsR0FBSUMsS0FBSSxDQUFHenRCLEtBQUssQ0FBQ2pCLE1BQU4sQ0FBYXVmLFlBQWIsQ0FBMEIvbUIsT0FBTyxDQUFDZzJCLFFBQWxDLENBQVgsQ0FDQSxHQUFJdGtCLE1BQUssQ0FBRzFSLE9BQU8sQ0FBQzBSLEtBQXBCLENBQ0EsR0FBSXlrQixXQUFVLENBQUdoWSxJQUFJLENBQUNxRyxZQUFMLENBQWtCOVMsS0FBbEIsQ0FBakIsQ0FDQSxHQUFJMGtCLE1BQUosQ0FDQSxHQUFJQyxvQkFBSixDQUNBLEdBQUlDLGNBQUosQ0FDQSxHQUFHdDJCLE9BQU8sQ0FBQ3NvQixTQUFSLENBQWtCeFAsT0FBbEIsQ0FBMEIsS0FBMUIsSUFBcUMsQ0FBckMsRUFBMEM5WSxPQUFPLENBQUNzb0IsU0FBUixHQUFzQixLQUFuRSxDQUEwRSxDQUN4RTtBQUNBLEdBQUlpTyxNQUFKLENBQVdDLE1BQVgsQ0FBbUJDLFFBQW5CLENBQ0EsT0FBT3oyQixPQUFPLENBQUNzb0IsU0FBZixFQUNBLElBQUssUUFBTCxDQUNFOE4sS0FBSyxDQUFHLEVBQVIsQ0FDQUcsS0FBSyxDQUFHLEVBQVIsQ0FDQUMsTUFBTSxDQUFHOVEsSUFBSSxDQUFDLFlBQUQsQ0FBYixDQUNBK1EsUUFBUSxDQUFHaHVCLEtBQUssQ0FBQzJkLEdBQU4sQ0FBVTZLLHNCQUFyQixDQUNBLE1BQ0YsSUFBSyxRQUFMLENBQ0VtRixLQUFLLENBQUcsRUFBUixDQUNBRyxLQUFLLENBQUcsRUFBUixDQUNBQyxNQUFNLENBQUc5USxJQUFJLENBQUMsWUFBRCxDQUFiLENBQ0ErUSxRQUFRLENBQUdodUIsS0FBSyxDQUFDMmQsR0FBTixDQUFVNkssc0JBQXJCLENBQ0EsTUFDRixJQUFLLFFBQUwsQ0FDRW1GLEtBQUssQ0FBRyxFQUFSLENBQ0FHLEtBQUssQ0FBRyxFQUFSLENBQ0FDLE1BQU0sQ0FBRzlRLElBQUksQ0FBQyxZQUFELENBQWIsQ0FDQStRLFFBQVEsQ0FBR2h1QixLQUFLLENBQUMyZCxHQUFOLENBQVU2SyxzQkFBckIsQ0FDQSxNQUNGLElBQUssS0FBTCxDQUNFbUYsS0FBSyxDQUFHLENBQVIsQ0FDQUcsS0FBSyxDQUFHLENBQVIsQ0FDQUMsTUFBTSxDQUFHOVEsSUFBSSxDQUFDLFFBQUQsQ0FBYixDQUNBK1EsUUFBUSxDQUFHaHVCLEtBQUssQ0FBQ2l1QixHQUFOLENBQVV6RixzQkFBckIsQ0FDQSxNQUNGLFFBQ0UsR0FBSXR1QixNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSwyREFBVixDQUFaLENBQ0FrQyxLQUFLLENBQUMybEIsU0FBTixDQUFrQnRvQixPQUFPLENBQUNzb0IsU0FBMUIsQ0FDQSxLQUFNM2xCLE1BQU4sQ0E1QkYsQ0ErQkE7QUFDQSxHQUFJc3pCLGFBQVksQ0FBRyxXQUFhajJCLE9BQU8sQ0FBQ2kyQixZQUFSLENBQXFCekksV0FBckIsRUFBaEMsQ0FDQSxHQUFJMUgsR0FBRSxDQUFHNlEsMkJBQTJCLENBQUNWLFlBQUQsQ0FBcEMsQ0FFQTtBQUNBLEdBQUlXLEdBQUUsQ0FBR251QixLQUFLLENBQUNvdUIsS0FBTixDQUFZQyxNQUFaLENBQW1CZixRQUFuQixDQUE2QkcsSUFBN0IsQ0FBbUN4a0IsS0FBbkMsQ0FBMEMwa0IsS0FBMUMsQ0FBaUR0USxFQUFqRCxDQUFULENBQ0EsR0FBSWdMLEdBQUUsQ0FBR3JvQixLQUFLLENBQUNqQixNQUFOLENBQWF1ZixZQUFiLENBQTBCd1AsS0FBMUIsQ0FBVCxDQUNBLEdBQUkvUCxPQUFNLENBQUdpUSxRQUFRLENBQUNHLEVBQUQsQ0FBckIsQ0FDQXBRLE1BQU0sQ0FBQ2hRLEtBQVAsQ0FBYXNhLEVBQWIsRUFDQXRLLE1BQU0sQ0FBQy9KLE1BQVAsQ0FBYzBCLElBQUksQ0FBQytELEtBQUwsQ0FBV3BMLEdBQVgsQ0FBZCxFQUNBMFAsTUFBTSxDQUFDd0osTUFBUCxHQUNBc0csYUFBYSxDQUFHOVAsTUFBTSxDQUFDcFIsTUFBUCxDQUFjdkUsUUFBZCxFQUFoQixDQUVBO0FBQ0EsR0FBSXBLLE9BQU0sQ0FBR3N3QixrQkFBa0IsQ0FBQ2IsSUFBRCxDQUFPQyxVQUFQLENBQW1CQyxLQUFuQixDQUEwQkgsWUFBMUIsQ0FBL0IsQ0FFQUksbUJBQW1CLENBQUdsWSxJQUFJLENBQUNqYixNQUFMLENBQ3BCaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRFMsQ0FDRUYsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBRFosQ0FDc0IsSUFEdEIsQ0FDNEIsQ0FDaERyQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUFpRCxLQUFqRCxDQUNFYixJQUFJLENBQUNrRSxRQUFMLENBQWNxRCxJQUFJLENBQUMsWUFBRCxDQUFsQixFQUFrQzdVLFFBQWxDLEVBREYsQ0FEZ0QsQ0FHaERzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMURyQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUFpRCxLQUFqRCxDQUNFYixJQUFJLENBQUNrRSxRQUFMLENBQWNxRCxJQUFJLENBQUMsYUFBRCxDQUFsQixFQUFtQzdVLFFBQW5DLEVBREYsQ0FEMEQsQ0FHMUQ7QUFDQXBLLE1BSjBELENBQTVELENBRjBELENBUTFEO0FBQ0EwWCxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRHJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY21VLE1BQWQsRUFBc0IzbEIsUUFBdEIsRUFERixDQUQwRCxDQUcxRDtBQUNBc04sSUFBSSxDQUFDamIsTUFBTCxDQUNFaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRGIsQ0FDd0JGLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQURsQyxDQUMrQyxLQUQvQyxDQUNzRGdTLEVBRHRELENBSjBELENBQTVELENBVDBELENBQTVELENBSGdELENBRDVCLENBQXRCLENBc0JELENBeEVELElBd0VPLElBQUc5d0IsT0FBTyxDQUFDc29CLFNBQVIsR0FBc0IsTUFBekIsQ0FBaUMsQ0FDdEM7QUFDQThOLEtBQUssQ0FBRyxFQUFSLENBRUEsR0FBSVksVUFBUyxDQUFHLEdBQUl2dUIsTUFBSyxDQUFDMkQsSUFBTixDQUFXMkMsVUFBZixDQUEwQm1uQixJQUExQixDQUFoQixDQUNBLEdBQUlVLEdBQUUsQ0FBR3p0QixHQUFHLENBQUN1c0IsR0FBSixDQUFRdUIsaUJBQVIsQ0FBMEJsQixRQUExQixDQUFvQ2lCLFNBQXBDLENBQStDLENBQS9DLENBQWtEdGxCLEtBQWxELENBQXlEMGtCLEtBQXpELENBQVQsQ0FDQSxHQUFJdEYsR0FBRSxDQUFHM25CLEdBQUcsQ0FBQ3VzQixHQUFKLENBQVF1QixpQkFBUixDQUEwQmxCLFFBQTFCLENBQW9DaUIsU0FBcEMsQ0FBK0MsQ0FBL0MsQ0FBa0R0bEIsS0FBbEQsQ0FBeUQwa0IsS0FBekQsQ0FBVCxDQUNBLEdBQUk1UCxPQUFNLENBQUcvZCxLQUFLLENBQUNpdUIsR0FBTixDQUFVekYsc0JBQVYsQ0FBaUMyRixFQUFqQyxDQUFiLENBQ0FwUSxNQUFNLENBQUNoUSxLQUFQLENBQWFzYSxFQUFiLEVBQ0F0SyxNQUFNLENBQUMvSixNQUFQLENBQWMwQixJQUFJLENBQUMrRCxLQUFMLENBQVdwTCxHQUFYLENBQWQsRUFDQTBQLE1BQU0sQ0FBQ3dKLE1BQVAsR0FDQXNHLGFBQWEsQ0FBRzlQLE1BQU0sQ0FBQ3BSLE1BQVAsQ0FBY3ZFLFFBQWQsRUFBaEIsQ0FFQXdsQixtQkFBbUIsQ0FBR2xZLElBQUksQ0FBQ2piLE1BQUwsQ0FDcEJpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEUyxDQUNFRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFEWixDQUNzQixJQUR0QixDQUM0QixDQUNoRHJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY3FELElBQUksQ0FBQyxpQ0FBRCxDQUFsQixFQUF1RDdVLFFBQXZELEVBREYsQ0FEZ0QsQ0FHaEQ7QUFDQXNOLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEO0FBQ0FyQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUE1QyxDQUF5RCxLQUF6RCxDQUFnRW9YLElBQWhFLENBRjBELENBRzFEO0FBQ0EvWCxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUE1QyxDQUFxRCxLQUFyRCxDQUNFdVgsVUFBVSxDQUFDdGxCLFFBQVgsRUFERixDQUowRCxDQUE1RCxDQUpnRCxDQUQ1QixDQUF0QixDQWFELENBMUJNLElBMEJBLENBQ0wsR0FBSWxPLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLDJEQUFWLENBQVosQ0FDQWtDLEtBQUssQ0FBQzJsQixTQUFOLENBQWtCdG9CLE9BQU8sQ0FBQ3NvQixTQUExQixDQUNBLEtBQU0zbEIsTUFBTixDQUNELENBRUQ7QUFDQSxHQUFJc08sS0FBSSxDQUFHa04sSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDckU7QUFDQTZXLG1CQUZxRSxDQUdyRTtBQUNBbFksSUFBSSxDQUFDamIsTUFBTCxDQUNFaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRGIsQ0FDd0JGLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQURsQyxDQUMrQyxLQUQvQyxDQUNzRHdYLGFBRHRELENBSnFFLENBQTVELENBQVgsQ0FPQSxNQUFPcmxCLEtBQVAsQ0FDRCxDQWhJRCxDQWtJQTs7Ozs7OztHQVFBOUgsR0FBRyxDQUFDK3RCLHFCQUFKLENBQTRCLFNBQVNwZ0IsR0FBVCxDQUFjaWYsUUFBZCxDQUF3QixDQUNsRCxHQUFJOWtCLEtBQUksQ0FBRyxJQUFYLENBRUE7QUFDQSxHQUFJNFQsUUFBTyxDQUFHLEVBQWQsQ0FDQSxHQUFJL2UsT0FBTSxDQUFHLEVBQWIsQ0FDQSxHQUFHLENBQUNxWSxJQUFJLENBQUN3RyxRQUFMLENBQWM3TixHQUFkLENBQW1CNmUsNEJBQW5CLENBQWlEOVEsT0FBakQsQ0FBMEQvZSxNQUExRCxDQUFKLENBQXVFLENBQ3JFLEdBQUluRCxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxzQ0FDcEIsMERBRFUsQ0FBWixDQUVBa0MsS0FBSyxDQUFDbUQsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5ELE1BQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSTJmLElBQUcsQ0FBR25FLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ3NTLGFBQXRCLENBQVYsQ0FDQSxHQUFJM1EsT0FBTSxDQUFHcmQsR0FBRyxDQUFDdXNCLEdBQUosQ0FBUTBCLFNBQVIsQ0FBa0I5VSxHQUFsQixDQUF1QnVDLE9BQU8sQ0FBQ3dTLGdCQUEvQixDQUFpRHRCLFFBQWpELENBQWIsQ0FFQTtBQUNBLEdBQUl1QixVQUFTLENBQUc3dUIsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QjZTLE9BQU8sQ0FBQ3lSLGFBQWhDLENBQWhCLENBRUE5UCxNQUFNLENBQUMvSixNQUFQLENBQWM2YSxTQUFkLEVBQ0EsR0FBRzlRLE1BQU0sQ0FBQ3dKLE1BQVAsRUFBSCxDQUFvQixDQUNsQi9lLElBQUksQ0FBR2tOLElBQUksQ0FBQ2lELE9BQUwsQ0FBYW9GLE1BQU0sQ0FBQ3BSLE1BQXBCLENBQVAsQ0FDRCxDQUVELE1BQU9uRSxLQUFQLENBQ0QsQ0ExQkQsQ0E0QkE7Ozs7Ozs7R0FRQTlILEdBQUcsQ0FBQ291Qix3QkFBSixDQUErQixTQUFTQyxJQUFULENBQWV0aUIsT0FBZixDQUF3QixDQUNyRDtBQUNBLEdBQUlqSSxJQUFHLENBQUcsQ0FDUnVLLElBQUksQ0FBRSx1QkFERSxDQUVScWQsSUFBSSxDQUFFMVcsSUFBSSxDQUFDK0QsS0FBTCxDQUFXc1YsSUFBWCxFQUFpQjNtQixRQUFqQixFQUZFLENBQVYsQ0FJQSxNQUFPcEksTUFBSyxDQUFDNHJCLEdBQU4sQ0FBVXpnQixNQUFWLENBQWlCM0csR0FBakIsQ0FBc0IsQ0FBQ2lJLE9BQU8sQ0FBRUEsT0FBVixDQUF0QixDQUFQLENBQ0QsQ0FQRCxDQVNBOzs7Ozs7O0dBUUEvTCxHQUFHLENBQUNzdUIsMEJBQUosQ0FBaUMsU0FBU3BELEdBQVQsQ0FBYyxDQUM3QyxHQUFJcG5CLElBQUcsQ0FBR3hFLEtBQUssQ0FBQzRyQixHQUFOLENBQVU3Z0IsTUFBVixDQUFpQjZnQixHQUFqQixFQUFzQixDQUF0QixDQUFWLENBRUEsR0FBR3BuQixHQUFHLENBQUN1SyxJQUFKLEdBQWEsdUJBQWhCLENBQXlDLENBQ3ZDLEdBQUk3VSxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxxREFDcEIsNkNBRFUsQ0FBWixDQUVBa0MsS0FBSyxDQUFDKzBCLFVBQU4sQ0FBbUJ6cUIsR0FBRyxDQUFDdUssSUFBdkIsQ0FDQSxLQUFNN1UsTUFBTixDQUNELENBQ0QsR0FBR3NLLEdBQUcsQ0FBQ3NuQixRQUFKLEVBQWdCdG5CLEdBQUcsQ0FBQ3NuQixRQUFKLENBQWEvYyxJQUFiLEdBQXNCLFdBQXpDLENBQXNELENBQ3BELEtBQU0sSUFBSS9XLE1BQUosQ0FBVSxxREFDZCxtQkFESSxDQUFOLENBRUQsQ0FFRDtBQUNBLE1BQU8wZCxLQUFJLENBQUNpRCxPQUFMLENBQWFuVSxHQUFHLENBQUM0bkIsSUFBakIsQ0FBUCxDQUNELENBaEJELENBa0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMEJBMXJCLEdBQUcsQ0FBQ3d1QixvQkFBSixDQUEyQixTQUFTMUosTUFBVCxDQUFpQjhILFFBQWpCLENBQTJCLzFCLE9BQTNCLENBQW9DLENBQzdEO0FBQ0FBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0EsR0FBRyxDQUFDQSxPQUFPLENBQUM0M0IsTUFBWixDQUFvQixDQUNsQjtBQUNBLEdBQUkzbUIsS0FBSSxDQUFHOUgsR0FBRyxDQUFDNmtCLGlCQUFKLENBQXNCN2tCLEdBQUcsQ0FBQ3dsQixnQkFBSixDQUFxQlYsTUFBckIsQ0FBdEIsQ0FBWCxDQUNBaGQsSUFBSSxDQUFHOUgsR0FBRyxDQUFDMnNCLHFCQUFKLENBQTBCN2tCLElBQTFCLENBQWdDOGtCLFFBQWhDLENBQTBDLzFCLE9BQTFDLENBQVAsQ0FDQSxNQUFPbUosSUFBRyxDQUFDb3VCLHdCQUFKLENBQTZCdG1CLElBQTdCLENBQVAsQ0FDRCxDQUVEO0FBQ0EsR0FBSXFYLFVBQUosQ0FDQSxHQUFJd0ksR0FBSixDQUNBLEdBQUlzRixNQUFKLENBQ0EsR0FBSUssU0FBSixDQUNBLE9BQU96MkIsT0FBTyxDQUFDc29CLFNBQWYsRUFDQSxJQUFLLFFBQUwsQ0FDRUEsU0FBUyxDQUFHLGFBQVosQ0FDQThOLEtBQUssQ0FBRyxFQUFSLENBQ0F0RixFQUFFLENBQUdyb0IsS0FBSyxDQUFDakIsTUFBTixDQUFhdWYsWUFBYixDQUEwQixFQUExQixDQUFMLENBQ0EwUCxRQUFRLENBQUdodUIsS0FBSyxDQUFDMmQsR0FBTixDQUFVNkssc0JBQXJCLENBQ0EsTUFDRixJQUFLLFFBQUwsQ0FDRTNJLFNBQVMsQ0FBRyxhQUFaLENBQ0E4TixLQUFLLENBQUcsRUFBUixDQUNBdEYsRUFBRSxDQUFHcm9CLEtBQUssQ0FBQ2pCLE1BQU4sQ0FBYXVmLFlBQWIsQ0FBMEIsRUFBMUIsQ0FBTCxDQUNBMFAsUUFBUSxDQUFHaHVCLEtBQUssQ0FBQzJkLEdBQU4sQ0FBVTZLLHNCQUFyQixDQUNBLE1BQ0YsSUFBSyxRQUFMLENBQ0UzSSxTQUFTLENBQUcsYUFBWixDQUNBOE4sS0FBSyxDQUFHLEVBQVIsQ0FDQXRGLEVBQUUsQ0FBR3JvQixLQUFLLENBQUNqQixNQUFOLENBQWF1ZixZQUFiLENBQTBCLEVBQTFCLENBQUwsQ0FDQTBQLFFBQVEsQ0FBR2h1QixLQUFLLENBQUMyZCxHQUFOLENBQVU2SyxzQkFBckIsQ0FDQSxNQUNGLElBQUssTUFBTCxDQUNFM0ksU0FBUyxDQUFHLGNBQVosQ0FDQThOLEtBQUssQ0FBRyxFQUFSLENBQ0F0RixFQUFFLENBQUdyb0IsS0FBSyxDQUFDakIsTUFBTixDQUFhdWYsWUFBYixDQUEwQixDQUExQixDQUFMLENBQ0EwUCxRQUFRLENBQUdodUIsS0FBSyxDQUFDaXVCLEdBQU4sQ0FBVXpGLHNCQUFyQixDQUNBLE1BQ0YsSUFBSyxLQUFMLENBQ0UzSSxTQUFTLENBQUcsU0FBWixDQUNBOE4sS0FBSyxDQUFHLENBQVIsQ0FDQXRGLEVBQUUsQ0FBR3JvQixLQUFLLENBQUNqQixNQUFOLENBQWF1ZixZQUFiLENBQTBCLENBQTFCLENBQUwsQ0FDQTBQLFFBQVEsQ0FBR2h1QixLQUFLLENBQUNpdUIsR0FBTixDQUFVekYsc0JBQXJCLENBQ0EsTUFDRixRQUNFLEdBQUl0dUIsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsa0RBQ3BCLHdCQURvQixDQUNPVCxPQUFPLENBQUNzb0IsU0FEZixDQUMyQixJQURyQyxDQUFaLENBRUEzbEIsS0FBSyxDQUFDMmxCLFNBQU4sQ0FBa0J0b0IsT0FBTyxDQUFDc29CLFNBQTFCLENBQ0EsS0FBTTNsQixNQUFOLENBbkNGLENBc0NBO0FBQ0EsR0FBSWkwQixHQUFFLENBQUdudUIsS0FBSyxDQUFDaXRCLEdBQU4sQ0FBVW1DLGtCQUFWLENBQTZCOUIsUUFBN0IsQ0FBdUNqRixFQUFFLENBQUNwcEIsTUFBSCxDQUFVLENBQVYsQ0FBYSxDQUFiLENBQXZDLENBQXdEMHVCLEtBQXhELENBQVQsQ0FDQSxHQUFJNVAsT0FBTSxDQUFHaVEsUUFBUSxDQUFDRyxFQUFELENBQXJCLENBQ0FwUSxNQUFNLENBQUNoUSxLQUFQLENBQWFzYSxFQUFiLEVBQ0F0SyxNQUFNLENBQUMvSixNQUFQLENBQWMwQixJQUFJLENBQUMrRCxLQUFMLENBQVcvWSxHQUFHLENBQUN3bEIsZ0JBQUosQ0FBcUJWLE1BQXJCLENBQVgsQ0FBZCxFQUNBekgsTUFBTSxDQUFDd0osTUFBUCxHQUVBLEdBQUkvaUIsSUFBRyxDQUFHLENBQ1J1SyxJQUFJLENBQUUsaUJBREUsQ0FFUitjLFFBQVEsQ0FBRSxDQUNSQyxPQUFPLENBQUUsR0FERCxDQUVSaGQsSUFBSSxDQUFFLFdBRkUsQ0FGRixDQU1SbWQsT0FBTyxDQUFFLENBQ1ByTSxTQUFTLENBQUVBLFNBREosQ0FFUHNNLFVBQVUsQ0FBRW5zQixLQUFLLENBQUMyRCxJQUFOLENBQVd3SSxVQUFYLENBQXNCa2MsRUFBdEIsRUFBMEJ0RCxXQUExQixFQUZMLENBTkQsQ0FVUnFILElBQUksQ0FBRXJPLE1BQU0sQ0FBQ3BSLE1BQVAsQ0FBY3ZFLFFBQWQsRUFWRSxDQUFWLENBWUEsTUFBT3BJLE1BQUssQ0FBQzRyQixHQUFOLENBQVV6Z0IsTUFBVixDQUFpQjNHLEdBQWpCLENBQVAsQ0FDRCxDQXpFRCxDQTJFQTs7Ozs7OztHQVFBOUQsR0FBRyxDQUFDMnVCLG9CQUFKLENBQTJCLFNBQVN6RCxHQUFULENBQWMwQixRQUFkLENBQXdCLENBQ2pELEdBQUk5a0IsS0FBSSxDQUFHLElBQVgsQ0FFQSxHQUFJaEUsSUFBRyxDQUFHeEUsS0FBSyxDQUFDNHJCLEdBQU4sQ0FBVTdnQixNQUFWLENBQWlCNmdCLEdBQWpCLEVBQXNCLENBQXRCLENBQVYsQ0FFQSxHQUFHcG5CLEdBQUcsQ0FBQ3VLLElBQUosR0FBYSx1QkFBYixFQUNEdkssR0FBRyxDQUFDdUssSUFBSixHQUFhLGFBRFosRUFFRHZLLEdBQUcsQ0FBQ3VLLElBQUosR0FBYSxpQkFGZixDQUVrQyxDQUNoQyxHQUFJN1UsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsMkRBQ3BCLHNFQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQyswQixVQUFOLENBQW1CLzBCLEtBQW5CLENBQ0EsS0FBTUEsTUFBTixDQUNELENBRUQsR0FBR3NLLEdBQUcsQ0FBQ3NuQixRQUFKLEVBQWdCdG5CLEdBQUcsQ0FBQ3NuQixRQUFKLENBQWEvYyxJQUFiLEdBQXNCLFdBQXpDLENBQXNELENBQ3BELEdBQUk0ZSxNQUFKLENBQ0EsR0FBSUssU0FBSixDQUNBLE9BQU94cEIsR0FBRyxDQUFDMG5CLE9BQUosQ0FBWXJNLFNBQW5CLEVBQ0EsSUFBSyxTQUFMLENBQ0U4TixLQUFLLENBQUcsQ0FBUixDQUNBSyxRQUFRLENBQUdodUIsS0FBSyxDQUFDaXVCLEdBQU4sQ0FBVXZGLHNCQUFyQixDQUNBLE1BQ0YsSUFBSyxjQUFMLENBQ0VpRixLQUFLLENBQUcsRUFBUixDQUNBSyxRQUFRLENBQUdodUIsS0FBSyxDQUFDaXVCLEdBQU4sQ0FBVXZGLHNCQUFyQixDQUNBLE1BQ0YsSUFBSyxhQUFMLENBQ0VpRixLQUFLLENBQUcsRUFBUixDQUNBSyxRQUFRLENBQUdodUIsS0FBSyxDQUFDMmQsR0FBTixDQUFVK0ssc0JBQXJCLENBQ0EsTUFDRixJQUFLLGFBQUwsQ0FDRWlGLEtBQUssQ0FBRyxFQUFSLENBQ0FLLFFBQVEsQ0FBR2h1QixLQUFLLENBQUMyZCxHQUFOLENBQVUrSyxzQkFBckIsQ0FDQSxNQUNGLElBQUssYUFBTCxDQUNFaUYsS0FBSyxDQUFHLEVBQVIsQ0FDQUssUUFBUSxDQUFHaHVCLEtBQUssQ0FBQzJkLEdBQU4sQ0FBVStLLHNCQUFyQixDQUNBLE1BQ0YsSUFBSyxZQUFMLENBQ0VpRixLQUFLLENBQUcsQ0FBUixDQUNBSyxRQUFRLENBQUcsa0JBQVMvekIsR0FBVCxDQUFjLENBQ3ZCLE1BQU8rRixNQUFLLENBQUNzdkIsR0FBTixDQUFVNUcsc0JBQVYsQ0FBaUN6dUIsR0FBakMsQ0FBc0MsRUFBdEMsQ0FBUCxDQUNELENBRkQsQ0FHQSxNQUNGLElBQUssWUFBTCxDQUNFMHpCLEtBQUssQ0FBRyxDQUFSLENBQ0FLLFFBQVEsQ0FBRyxrQkFBUy96QixHQUFULENBQWMsQ0FDdkIsTUFBTytGLE1BQUssQ0FBQ3N2QixHQUFOLENBQVU1RyxzQkFBVixDQUFpQ3p1QixHQUFqQyxDQUFzQyxFQUF0QyxDQUFQLENBQ0QsQ0FGRCxDQUdBLE1BQ0YsSUFBSyxhQUFMLENBQ0UwekIsS0FBSyxDQUFHLEVBQVIsQ0FDQUssUUFBUSxDQUFHLGtCQUFTL3pCLEdBQVQsQ0FBYyxDQUN2QixNQUFPK0YsTUFBSyxDQUFDc3ZCLEdBQU4sQ0FBVTVHLHNCQUFWLENBQWlDenVCLEdBQWpDLENBQXNDLEdBQXRDLENBQVAsQ0FDRCxDQUZELENBR0EsTUFDRixRQUNFLEdBQUlDLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLDhDQUNwQix3QkFEb0IsQ0FDT3dNLEdBQUcsQ0FBQzBuQixPQUFKLENBQVlyTSxTQURuQixDQUMrQixJQUR6QyxDQUFaLENBRUEzbEIsS0FBSyxDQUFDMmxCLFNBQU4sQ0FBa0JyYixHQUFHLENBQUMwbkIsT0FBSixDQUFZck0sU0FBOUIsQ0FDQSxLQUFNM2xCLE1BQU4sQ0EzQ0YsQ0E4Q0E7QUFDQSxHQUFJbXVCLEdBQUUsQ0FBR3JvQixLQUFLLENBQUMyRCxJQUFOLENBQVdzSSxVQUFYLENBQXNCekgsR0FBRyxDQUFDMG5CLE9BQUosQ0FBWUMsVUFBbEMsQ0FBVCxDQUNBLEdBQUlnQyxHQUFFLENBQUdudUIsS0FBSyxDQUFDaXRCLEdBQU4sQ0FBVW1DLGtCQUFWLENBQTZCOUIsUUFBN0IsQ0FBdUNqRixFQUFFLENBQUNwcEIsTUFBSCxDQUFVLENBQVYsQ0FBYSxDQUFiLENBQXZDLENBQXdEMHVCLEtBQXhELENBQVQsQ0FDQSxHQUFJNVAsT0FBTSxDQUFHaVEsUUFBUSxDQUFDRyxFQUFELENBQXJCLENBQ0FwUSxNQUFNLENBQUNoUSxLQUFQLENBQWFzYSxFQUFiLEVBQ0F0SyxNQUFNLENBQUMvSixNQUFQLENBQWNoVSxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCL0UsR0FBRyxDQUFDNG5CLElBQTVCLENBQWQsRUFDQSxHQUFHck8sTUFBTSxDQUFDd0osTUFBUCxFQUFILENBQW9CLENBQ2xCL2UsSUFBSSxDQUFHdVYsTUFBTSxDQUFDcFIsTUFBUCxDQUFjdkUsUUFBZCxFQUFQLENBQ0QsQ0FGRCxJQUVPLENBQ0wsTUFBT0ksS0FBUCxDQUNELENBQ0YsQ0E1REQsSUE0RE8sQ0FDTEEsSUFBSSxDQUFHaEUsR0FBRyxDQUFDNG5CLElBQVgsQ0FDRCxDQUVELEdBQUc1bkIsR0FBRyxDQUFDdUssSUFBSixHQUFhLHVCQUFoQixDQUF5QyxDQUN2Q3ZHLElBQUksQ0FBRzlILEdBQUcsQ0FBQyt0QixxQkFBSixDQUEwQi9ZLElBQUksQ0FBQ2lELE9BQUwsQ0FBYW5RLElBQWIsQ0FBMUIsQ0FBOEM4a0IsUUFBOUMsQ0FBUCxDQUNELENBRkQsSUFFTyxDQUNMO0FBQ0E5a0IsSUFBSSxDQUFHa04sSUFBSSxDQUFDaUQsT0FBTCxDQUFhblEsSUFBYixDQUFQLENBQ0QsQ0FFRCxHQUFHQSxJQUFJLEdBQUssSUFBWixDQUFrQixDQUNoQkEsSUFBSSxDQUFHOUgsR0FBRyxDQUFDMmpCLGtCQUFKLENBQXVCN2IsSUFBdkIsQ0FBUCxDQUNELENBRUQsTUFBT0EsS0FBUCxDQUNELENBMUZELENBNEZBOzs7Ozs7Ozs7Ozs7R0FhQTlILEdBQUcsQ0FBQ3VzQixHQUFKLENBQVF1QixpQkFBUixDQUE0QixTQUFTbEIsUUFBVCxDQUFtQkcsSUFBbkIsQ0FBeUJyZixFQUF6QixDQUE2Qm1oQixJQUE3QixDQUFtQ3hzQixDQUFuQyxDQUFzQ3NhLEVBQXRDLENBQTBDLENBQ3BFLEdBQUl6UCxFQUFKLENBQU92TCxDQUFQLENBRUEsR0FBRyxNQUFPZ2IsR0FBUCxHQUFjLFdBQWQsRUFBNkJBLEVBQUUsR0FBSyxJQUF2QyxDQUE2QyxDQUMzQyxHQUFHLEVBQUUsUUFBVXJkLE1BQUssQ0FBQ3FkLEVBQWxCLENBQUgsQ0FBMEIsQ0FDeEIsS0FBTSxJQUFJcmxCLE1BQUosQ0FBVSxvQ0FBVixDQUFOLENBQ0QsQ0FDRHFsQixFQUFFLENBQUdyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNtUyxJQUFULENBQWMvMEIsTUFBZCxFQUFMLENBQ0QsQ0FFRCxHQUFJZzFCLEVBQUMsQ0FBR3BTLEVBQUUsQ0FBQ3FTLFlBQVgsQ0FDQSxHQUFJdlQsRUFBQyxDQUFHa0IsRUFBRSxDQUFDc1MsV0FBWCxDQUNBLEdBQUkzMUIsT0FBTSxDQUFHLEdBQUlnRyxNQUFLLENBQUMyRCxJQUFOLENBQVcyQyxVQUFmLEVBQWIsQ0FFQSxnRUFDQSxHQUFJc3BCLFFBQU8sQ0FBRyxHQUFJNXZCLE1BQUssQ0FBQzJELElBQU4sQ0FBVzJDLFVBQWYsRUFBZCxDQUNBLEdBQUdnbkIsUUFBUSxHQUFLLElBQWIsRUFBcUJBLFFBQVEsR0FBS3JwQixTQUFyQyxDQUFnRCxDQUM5QyxJQUFJNUIsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHaXJCLFFBQVEsQ0FBQ3AxQixNQUF4QixDQUFnQ21LLENBQUMsRUFBakMsQ0FBcUMsQ0FDbkN1dEIsT0FBTyxDQUFDam9CLFFBQVIsQ0FBaUIybEIsUUFBUSxDQUFDaGxCLFVBQVQsQ0FBb0JqRyxDQUFwQixDQUFqQixFQUNELENBQ0R1dEIsT0FBTyxDQUFDam9CLFFBQVIsQ0FBaUIsQ0FBakIsRUFDRCxDQUVELDJDQUNBLEdBQUlwRSxFQUFDLENBQUdxc0IsT0FBTyxDQUFDMTNCLE1BQVIsRUFBUixDQUNBLEdBQUlzTCxFQUFDLENBQUdpcUIsSUFBSSxDQUFDdjFCLE1BQUwsRUFBUixDQUVBOzBCQUVBLEdBQUkyM0IsRUFBQyxDQUFHLEdBQUk3dkIsTUFBSyxDQUFDMkQsSUFBTixDQUFXMkMsVUFBZixFQUFSLENBQ0F1cEIsQ0FBQyxDQUFDdm9CLFlBQUYsQ0FBZThHLEVBQWYsQ0FBbUIrTixDQUFuQixFQUVBOzs7bUVBSUEsR0FBSTJULEtBQUksQ0FBRzNULENBQUMsQ0FBR3JkLElBQUksQ0FBQzhMLElBQUwsQ0FBVXBILENBQUMsQ0FBRzJZLENBQWQsQ0FBZixDQUNBLEdBQUk0VCxFQUFDLENBQUcsR0FBSS92QixNQUFLLENBQUMyRCxJQUFOLENBQVcyQyxVQUFmLEVBQVIsQ0FDQSxJQUFJakUsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHeXRCLElBQWYsQ0FBcUJ6dEIsQ0FBQyxFQUF0QixDQUEwQixDQUN4QjB0QixDQUFDLENBQUMvb0IsT0FBRixDQUFVeW1CLElBQUksQ0FBQ3JrQixFQUFMLENBQVEvRyxDQUFDLENBQUdtQixDQUFaLENBQVYsRUFDRCxDQUVEOzs7dUVBSUEsR0FBSXdzQixLQUFJLENBQUc3VCxDQUFDLENBQUdyZCxJQUFJLENBQUM4TCxJQUFMLENBQVVySCxDQUFDLENBQUc0WSxDQUFkLENBQWYsQ0FDQSxHQUFJOFQsRUFBQyxDQUFHLEdBQUlqd0IsTUFBSyxDQUFDMkQsSUFBTixDQUFXMkMsVUFBZixFQUFSLENBQ0EsSUFBSWpFLENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsQ0FBRzJ0QixJQUFmLENBQXFCM3RCLENBQUMsRUFBdEIsQ0FBMEIsQ0FDeEI0dEIsQ0FBQyxDQUFDanBCLE9BQUYsQ0FBVTRvQixPQUFPLENBQUN4bUIsRUFBUixDQUFXL0csQ0FBQyxDQUFHa0IsQ0FBZixDQUFWLEVBQ0QsQ0FFRCx1REFDQSxHQUFJMnNCLEVBQUMsQ0FBR0gsQ0FBUixDQUNBRyxDQUFDLENBQUMvbkIsU0FBRixDQUFZOG5CLENBQVosRUFFQSwyQkFDQSxHQUFJenRCLEVBQUMsQ0FBRzFELElBQUksQ0FBQzhMLElBQUwsQ0FBVTdILENBQUMsQ0FBRzBzQixDQUFkLENBQVIsQ0FFQSw4Q0FDQSxJQUFJLEdBQUlydEIsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxFQUFJSSxDQUFwQixDQUF1QkosQ0FBQyxFQUF4QixDQUE0QixDQUMxQiwwRUFDQSxHQUFJK3RCLElBQUcsQ0FBRyxHQUFJbndCLE1BQUssQ0FBQzJELElBQU4sQ0FBVzJDLFVBQWYsRUFBVixDQUNBNnBCLEdBQUcsQ0FBQzlvQixRQUFKLENBQWF3b0IsQ0FBQyxDQUFDdG9CLEtBQUYsRUFBYixFQUNBNG9CLEdBQUcsQ0FBQzlvQixRQUFKLENBQWE2b0IsQ0FBQyxDQUFDM29CLEtBQUYsRUFBYixFQUNBLElBQUksR0FBSWtrQixNQUFLLENBQUcsQ0FBaEIsQ0FBbUJBLEtBQUssQ0FBRzhELElBQTNCLENBQWlDOUQsS0FBSyxFQUF0QyxDQUEwQyxDQUN4Q3BPLEVBQUUsQ0FBQ3RQLEtBQUgsR0FDQXNQLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVW1jLEdBQUcsQ0FBQy9uQixRQUFKLEVBQVYsRUFDQStuQixHQUFHLENBQUc5UyxFQUFFLENBQUM0QyxNQUFILEVBQU4sQ0FDRCxDQUVEOzREQUVBLEdBQUltUSxFQUFDLENBQUcsR0FBSXB3QixNQUFLLENBQUMyRCxJQUFOLENBQVcyQyxVQUFmLEVBQVIsQ0FDQSxJQUFJakUsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHOFosQ0FBZixDQUFrQjlaLENBQUMsRUFBbkIsQ0FBdUIsQ0FDckIrdEIsQ0FBQyxDQUFDcHBCLE9BQUYsQ0FBVW1wQixHQUFHLENBQUMvbUIsRUFBSixDQUFPL0csQ0FBQyxDQUFHb3RCLENBQVgsQ0FBVixFQUNELENBRUQ7OzRDQUdBLEdBQUkvd0IsRUFBQyxDQUFHSSxJQUFJLENBQUM4TCxJQUFMLENBQVVwSCxDQUFDLENBQUcyWSxDQUFkLEVBQW1CcmQsSUFBSSxDQUFDOEwsSUFBTCxDQUFVckgsQ0FBQyxDQUFHNFksQ0FBZCxDQUEzQixDQUNBLEdBQUlrVSxLQUFJLENBQUcsR0FBSXJ3QixNQUFLLENBQUMyRCxJQUFOLENBQVcyQyxVQUFmLEVBQVgsQ0FDQSxJQUFJc0gsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHbFAsQ0FBZixDQUFrQmtQLENBQUMsRUFBbkIsQ0FBdUIsQ0FDckIsR0FBSTBpQixNQUFLLENBQUcsR0FBSXR3QixNQUFLLENBQUMyRCxJQUFOLENBQVcyQyxVQUFmLENBQTBCNHBCLENBQUMsQ0FBQzluQixRQUFGLENBQVcrVCxDQUFYLENBQTFCLENBQVosQ0FDQSxHQUFJcFcsRUFBQyxDQUFHLEtBQVIsQ0FDQSxJQUFJMUQsQ0FBQyxDQUFHK3RCLENBQUMsQ0FBQ2w0QixNQUFGLEdBQWEsQ0FBckIsQ0FBd0JtSyxDQUFDLEVBQUksQ0FBN0IsQ0FBZ0NBLENBQUMsRUFBakMsQ0FBcUMsQ0FDbkMwRCxDQUFDLENBQUdBLENBQUMsRUFBSSxDQUFULENBQ0FBLENBQUMsRUFBSXFxQixDQUFDLENBQUNobkIsRUFBRixDQUFLL0csQ0FBTCxFQUFVaXVCLEtBQUssQ0FBQ2xuQixFQUFOLENBQVMvRyxDQUFULENBQWYsQ0FDQWl1QixLQUFLLENBQUNqbkIsS0FBTixDQUFZaEgsQ0FBWixDQUFlMEQsQ0FBQyxDQUFHLElBQW5CLEVBQ0QsQ0FDRHNxQixJQUFJLENBQUNsb0IsU0FBTCxDQUFlbW9CLEtBQWYsRUFDRCxDQUNESixDQUFDLENBQUdHLElBQUosQ0FFQSxrQkFDQXIyQixNQUFNLENBQUNtTyxTQUFQLENBQWlCZ29CLEdBQWpCLEVBQ0QsQ0FFRG4yQixNQUFNLENBQUN5UCxRQUFQLENBQWdCelAsTUFBTSxDQUFDOUIsTUFBUCxHQUFrQjZLLENBQWxDLEVBQ0EsTUFBTy9JLE9BQVAsQ0FDRCxDQXJHRCxDQXVHQTs7Ozs7Ozs7R0FTQTBHLEdBQUcsQ0FBQ3VzQixHQUFKLENBQVEwQixTQUFSLENBQW9CLFNBQVM5VSxHQUFULENBQWM3YixNQUFkLENBQXNCc3ZCLFFBQXRCLENBQWdDLENBQ2xELE9BQU96VCxHQUFQLEVBQ0EsSUFBS25aLElBQUcsQ0FBQ3VjLElBQUosQ0FBUyxZQUFULENBQUwsQ0FDRSxNQUFPdmMsSUFBRyxDQUFDdXNCLEdBQUosQ0FBUXNELGlCQUFSLENBQTBCMVcsR0FBMUIsQ0FBK0I3YixNQUEvQixDQUF1Q3N2QixRQUF2QyxDQUFQLENBRUYsSUFBSzVzQixJQUFHLENBQUN1YyxJQUFKLENBQVMsaUNBQVQsQ0FBTCxDQUNBLElBQUt2YyxJQUFHLENBQUN1YyxJQUFKLENBQVMsMkJBQVQsQ0FBTCxDQUNFLE1BQU92YyxJQUFHLENBQUN1c0IsR0FBSixDQUFRdUQscUJBQVIsQ0FBOEIzVyxHQUE5QixDQUFtQzdiLE1BQW5DLENBQTJDc3ZCLFFBQTNDLENBQVAsQ0FFRixRQUNFLEdBQUlwekIsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsd0RBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDMmYsR0FBTixDQUFZQSxHQUFaLENBQ0EzZixLQUFLLENBQUN1MkIsYUFBTixDQUFzQixDQUNwQixZQURvQixDQUVwQixpQ0FGb0IsQ0FHcEIsMkJBSG9CLENBQXRCLENBS0EsS0FBTXYyQixNQUFOLENBaEJGLENBa0JELENBbkJELENBcUJBOzs7Ozs7Ozs7OztHQVlBd0csR0FBRyxDQUFDdXNCLEdBQUosQ0FBUXNELGlCQUFSLENBQTRCLFNBQVMxVyxHQUFULENBQWM3YixNQUFkLENBQXNCc3ZCLFFBQXRCLENBQWdDLENBQzFEO0FBQ0EsR0FBSWxSLFFBQU8sQ0FBRyxFQUFkLENBQ0EsR0FBSS9lLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBRyxDQUFDcVksSUFBSSxDQUFDd0csUUFBTCxDQUFjbGUsTUFBZCxDQUFzQm12Qix3QkFBdEIsQ0FBZ0QvUSxPQUFoRCxDQUF5RC9lLE1BQXpELENBQUosQ0FBc0UsQ0FDcEUsR0FBSW5ELE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLG1EQUNwQixzRUFEVSxDQUFaLENBRUFrQyxLQUFLLENBQUNtRCxNQUFOLENBQWVBLE1BQWYsQ0FDQSxLQUFNbkQsTUFBTixDQUNELENBRUQ7QUFDQTJmLEdBQUcsQ0FBR25FLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ3NVLE1BQXRCLENBQU4sQ0FDQSxHQUFHN1csR0FBRyxHQUFLblosR0FBRyxDQUFDdWMsSUFBSixDQUFTLGFBQVQsQ0FBWCxDQUFvQyxDQUNsQyxHQUFJL2lCLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLHNDQUNwQiwwQ0FEVSxDQUFaLENBRUFrQyxLQUFLLENBQUMyZixHQUFOLENBQVlBLEdBQVosQ0FDQTNmLEtBQUssQ0FBQ3UyQixhQUFOLENBQXNCLENBQUMsYUFBRCxDQUF0QixDQUNBLEtBQU12MkIsTUFBTixDQUNELENBQ0QyZixHQUFHLENBQUduRSxJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUMyUixNQUF0QixDQUFOLENBQ0EsR0FBR2xVLEdBQUcsR0FBS25aLEdBQUcsQ0FBQ3VjLElBQUosQ0FBUyxZQUFULENBQVIsRUFDRHBELEdBQUcsR0FBS25aLEdBQUcsQ0FBQ3VjLElBQUosQ0FBUyxZQUFULENBRFAsRUFFRHBELEdBQUcsR0FBS25aLEdBQUcsQ0FBQ3VjLElBQUosQ0FBUyxZQUFULENBRlAsRUFHRHBELEdBQUcsR0FBS25aLEdBQUcsQ0FBQ3VjLElBQUosQ0FBUyxjQUFULENBSFAsRUFJRHBELEdBQUcsR0FBS25aLEdBQUcsQ0FBQ3VjLElBQUosQ0FBUyxRQUFULENBSlYsQ0FJOEIsQ0FDNUIsR0FBSS9pQixNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxzQ0FDcEIsb0NBRFUsQ0FBWixDQUVBa0MsS0FBSyxDQUFDMmYsR0FBTixDQUFZQSxHQUFaLENBQ0EzZixLQUFLLENBQUN1MkIsYUFBTixDQUFzQixDQUNwQixZQURvQixDQUNOLFlBRE0sQ0FDUSxZQURSLENBQ3NCLGNBRHRCLENBQ3NDLFFBRHRDLENBQXRCLENBRUEsS0FBTXYyQixNQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUl1ekIsS0FBSSxDQUFHclIsT0FBTyxDQUFDdVUsT0FBbkIsQ0FDQSxHQUFJMW5CLE1BQUssQ0FBR2pKLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0I2UyxPQUFPLENBQUN3VSxpQkFBaEMsQ0FBWixDQUNBM25CLEtBQUssQ0FBR0EsS0FBSyxDQUFDSCxNQUFOLENBQWFHLEtBQUssQ0FBQy9RLE1BQU4sSUFBa0IsQ0FBL0IsQ0FBUixDQUNBLEdBQUl5MUIsTUFBSixDQUNBLEdBQUlLLFNBQUosQ0FDQSxPQUFPdHRCLEdBQUcsQ0FBQ3VjLElBQUosQ0FBU3BELEdBQVQsQ0FBUCxFQUNBLElBQUssWUFBTCxDQUNFOFQsS0FBSyxDQUFHLEVBQVIsQ0FDQUssUUFBUSxDQUFHaHVCLEtBQUssQ0FBQzJkLEdBQU4sQ0FBVStLLHNCQUFyQixDQUNBLE1BQ0YsSUFBSyxZQUFMLENBQ0VpRixLQUFLLENBQUcsRUFBUixDQUNBSyxRQUFRLENBQUdodUIsS0FBSyxDQUFDMmQsR0FBTixDQUFVK0ssc0JBQXJCLENBQ0EsTUFDRixJQUFLLFlBQUwsQ0FDRWlGLEtBQUssQ0FBRyxFQUFSLENBQ0FLLFFBQVEsQ0FBR2h1QixLQUFLLENBQUMyZCxHQUFOLENBQVUrSyxzQkFBckIsQ0FDQSxNQUNGLElBQUssY0FBTCxDQUNFaUYsS0FBSyxDQUFHLEVBQVIsQ0FDQUssUUFBUSxDQUFHaHVCLEtBQUssQ0FBQ2l1QixHQUFOLENBQVV2RixzQkFBckIsQ0FDQSxNQUNGLElBQUssUUFBTCxDQUNFaUYsS0FBSyxDQUFHLENBQVIsQ0FDQUssUUFBUSxDQUFHaHVCLEtBQUssQ0FBQ2l1QixHQUFOLENBQVV2RixzQkFBckIsQ0FDQSxNQXBCRixDQXVCQTtBQUNBLEdBQUlyTCxHQUFFLENBQUd3VCxxQkFBcUIsQ0FBQ3pVLE9BQU8sQ0FBQzBVLE1BQVQsQ0FBOUIsQ0FFQTtBQUNBLEdBQUkzQyxHQUFFLENBQUdudUIsS0FBSyxDQUFDb3VCLEtBQU4sQ0FBWUMsTUFBWixDQUFtQmYsUUFBbkIsQ0FBNkJHLElBQTdCLENBQW1DeGtCLEtBQW5DLENBQTBDMGtCLEtBQTFDLENBQWlEdFEsRUFBakQsQ0FBVCxDQUNBLEdBQUlnTCxHQUFFLENBQUdqTSxPQUFPLENBQUMyVSxLQUFqQixDQUNBLEdBQUloVCxPQUFNLENBQUdpUSxRQUFRLENBQUNHLEVBQUQsQ0FBckIsQ0FDQXBRLE1BQU0sQ0FBQ2hRLEtBQVAsQ0FBYXNhLEVBQWIsRUFFQSxNQUFPdEssT0FBUCxDQUNELENBekVELENBMkVBOzs7Ozs7Ozs7OztHQVlBcmQsR0FBRyxDQUFDdXNCLEdBQUosQ0FBUXVELHFCQUFSLENBQWdDLFNBQVMzVyxHQUFULENBQWM3YixNQUFkLENBQXNCc3ZCLFFBQXRCLENBQWdDLENBQzlEO0FBQ0EsR0FBSWxSLFFBQU8sQ0FBRyxFQUFkLENBQ0EsR0FBSS9lLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBRyxDQUFDcVksSUFBSSxDQUFDd0csUUFBTCxDQUFjbGUsTUFBZCxDQUFzQm92Qix3QkFBdEIsQ0FBZ0RoUixPQUFoRCxDQUF5RC9lLE1BQXpELENBQUosQ0FBc0UsQ0FDcEUsR0FBSW5ELE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLG1EQUNwQixzRUFEVSxDQUFaLENBRUFrQyxLQUFLLENBQUNtRCxNQUFOLENBQWVBLE1BQWYsQ0FDQSxLQUFNbkQsTUFBTixDQUNELENBRUQsR0FBSXV6QixLQUFJLENBQUd6dEIsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QjZTLE9BQU8sQ0FBQ3FSLElBQWhDLENBQVgsQ0FDQSxHQUFJeGtCLE1BQUssQ0FBR2pKLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0I2UyxPQUFPLENBQUM0VSxVQUFoQyxDQUFaLENBQ0EvbkIsS0FBSyxDQUFHQSxLQUFLLENBQUNILE1BQU4sQ0FBYUcsS0FBSyxDQUFDL1EsTUFBTixJQUFrQixDQUEvQixDQUFSLENBRUEsR0FBSXkxQixNQUFKLENBQVdzRCxNQUFYLENBQW1CakQsUUFBbkIsQ0FDQSxPQUFPblUsR0FBUCxFQUNFLElBQUtuWixJQUFHLENBQUN1YyxJQUFKLENBQVMsaUNBQVQsQ0FBTCxDQUNFMFEsS0FBSyxDQUFHLEVBQVIsQ0FDQXNELE1BQU0sQ0FBRyxDQUFULENBQ0FqRCxRQUFRLENBQUdodUIsS0FBSyxDQUFDaXVCLEdBQU4sQ0FBVXhGLGVBQXJCLENBQ0EsTUFFRixJQUFLL25CLElBQUcsQ0FBQ3VjLElBQUosQ0FBUywyQkFBVCxDQUFMLENBQ0UwUSxLQUFLLENBQUcsQ0FBUixDQUNBc0QsTUFBTSxDQUFHLENBQVQsQ0FDQWpELFFBQVEsQ0FBRyxrQkFBUy96QixHQUFULENBQWNvdUIsRUFBZCxDQUFrQixDQUMzQixHQUFJdEssT0FBTSxDQUFHL2QsS0FBSyxDQUFDc3ZCLEdBQU4sQ0FBVTVHLHNCQUFWLENBQWlDenVCLEdBQWpDLENBQXNDLEVBQXRDLENBQWIsQ0FDQThqQixNQUFNLENBQUNoUSxLQUFQLENBQWFzYSxFQUFiLENBQWlCLElBQWpCLEVBQ0EsTUFBT3RLLE9BQVAsQ0FDRCxDQUpELENBS0EsTUFFRixRQUNFLEdBQUk3akIsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsdURBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDMmYsR0FBTixDQUFZQSxHQUFaLENBQ0EsS0FBTTNmLE1BQU4sQ0FwQkosQ0F1QkE7QUFDQSxHQUFJbWpCLEdBQUUsQ0FBR3dULHFCQUFxQixDQUFDelUsT0FBTyxDQUFDMFUsTUFBVCxDQUE5QixDQUNBLEdBQUk3MkIsSUFBRyxDQUFHeUcsR0FBRyxDQUFDdXNCLEdBQUosQ0FBUXVCLGlCQUFSLENBQTBCbEIsUUFBMUIsQ0FBb0NHLElBQXBDLENBQTBDLENBQTFDLENBQTZDeGtCLEtBQTdDLENBQW9EMGtCLEtBQXBELENBQTJEdFEsRUFBM0QsQ0FBVixDQUNBQSxFQUFFLENBQUN0UCxLQUFILEdBQ0EsR0FBSXNhLEdBQUUsQ0FBRzNuQixHQUFHLENBQUN1c0IsR0FBSixDQUFRdUIsaUJBQVIsQ0FBMEJsQixRQUExQixDQUFvQ0csSUFBcEMsQ0FBMEMsQ0FBMUMsQ0FBNkN4a0IsS0FBN0MsQ0FBb0Rnb0IsTUFBcEQsQ0FBNEQ1VCxFQUE1RCxDQUFULENBRUEsTUFBTzJRLFNBQVEsQ0FBQy96QixHQUFELENBQU1vdUIsRUFBTixDQUFmLENBQ0QsQ0E5Q0QsQ0FnREE7Ozs7Ozs7Ozs7R0FXQTNuQixHQUFHLENBQUN1c0IsR0FBSixDQUFRbUMsa0JBQVIsQ0FBNkIsU0FBUzlCLFFBQVQsQ0FBbUJHLElBQW5CLENBQXlCRSxLQUF6QixDQUFnQ3RRLEVBQWhDLENBQW9DLENBQy9ELEdBQUcsTUFBT0EsR0FBUCxHQUFjLFdBQWQsRUFBNkJBLEVBQUUsR0FBSyxJQUF2QyxDQUE2QyxDQUMzQyxHQUFHLEVBQUUsT0FBU3JkLE1BQUssQ0FBQ3FkLEVBQWpCLENBQUgsQ0FBeUIsQ0FDdkIsS0FBTSxJQUFJcmxCLE1BQUosQ0FBVSxtQ0FBVixDQUFOLENBQ0QsQ0FDRHFsQixFQUFFLENBQUdyZCxLQUFLLENBQUNxZCxFQUFOLENBQVM2VCxHQUFULENBQWF6MkIsTUFBYixFQUFMLENBQ0QsQ0FDRCxHQUFHZ3pCLElBQUksR0FBSyxJQUFaLENBQWtCLENBQ2hCQSxJQUFJLENBQUcsRUFBUCxDQUNELENBQ0QsR0FBSTBELFFBQU8sQ0FBRyxDQUFDM3hCLElBQUksQ0FBQzZkLEVBQUQsQ0FBS2lRLFFBQVEsQ0FBR0csSUFBaEIsQ0FBTCxDQUFkLENBQ0EsSUFBSSxHQUFJdjFCLE9BQU0sQ0FBRyxFQUFiLENBQWlCa0ssQ0FBQyxDQUFHLENBQXpCLENBQTRCbEssTUFBTSxDQUFHeTFCLEtBQXJDLENBQTRDLEVBQUV2ckIsQ0FBRixDQUFLbEssTUFBTSxFQUFJLEVBQTNELENBQStELENBQzdEaTVCLE9BQU8sQ0FBQ3JzQixJQUFSLENBQWF0RixJQUFJLENBQUM2ZCxFQUFELENBQUs4VCxPQUFPLENBQUMvdUIsQ0FBQyxDQUFHLENBQUwsQ0FBUCxDQUFpQmtyQixRQUFqQixDQUE0QkcsSUFBakMsQ0FBakIsRUFDRCxDQUNELE1BQU8wRCxRQUFPLENBQUM1NEIsSUFBUixDQUFhLEVBQWIsRUFBaUIwRyxNQUFqQixDQUF3QixDQUF4QixDQUEyQjB1QixLQUEzQixDQUFQLENBQ0QsQ0FmRCxDQWlCQSxRQUFTbnVCLEtBQVQsQ0FBYzZkLEVBQWQsQ0FBa0I5VixLQUFsQixDQUF5QixDQUN2QixNQUFPOFYsR0FBRSxDQUFDdFAsS0FBSCxHQUFXaUcsTUFBWCxDQUFrQnpNLEtBQWxCLEVBQXlCMFksTUFBekIsR0FBa0M3WCxRQUFsQyxFQUFQLENBQ0QsQ0FFRCxRQUFTeW9CLHNCQUFULENBQStCQyxNQUEvQixDQUF1QyxDQUNyQztBQUNBLEdBQUl0RCxhQUFKLENBQ0EsR0FBRyxDQUFDc0QsTUFBSixDQUFZLENBQ1Z0RCxZQUFZLENBQUcsY0FBZixDQUNELENBRkQsSUFFTyxDQUNMQSxZQUFZLENBQUc5c0IsR0FBRyxDQUFDdWMsSUFBSixDQUFTdkgsSUFBSSxDQUFDc0UsUUFBTCxDQUFjOFcsTUFBZCxDQUFULENBQWYsQ0FDQSxHQUFHLENBQUN0RCxZQUFKLENBQWtCLENBQ2hCLEdBQUl0ekIsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsc0JBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDMmYsR0FBTixDQUFZaVgsTUFBWixDQUNBNTJCLEtBQUssQ0FBQ2szQixTQUFOLENBQWtCLENBQ2hCLGNBRGdCLENBQ0EsZ0JBREEsQ0FDa0IsZ0JBRGxCLENBQ29DLGdCQURwQyxDQUVoQixnQkFGZ0IsQ0FBbEIsQ0FHQSxLQUFNbDNCLE1BQU4sQ0FDRCxDQUNGLENBQ0QsTUFBT2cwQiw0QkFBMkIsQ0FBQ1YsWUFBRCxDQUFsQyxDQUNELENBRUQsUUFBU1UsNEJBQVQsQ0FBcUNWLFlBQXJDLENBQW1ELENBQ2pELEdBQUk3ckIsUUFBTyxDQUFHM0IsS0FBSyxDQUFDcWQsRUFBcEIsQ0FDQSxPQUFPbVEsWUFBUCxFQUNBLElBQUssZ0JBQUwsQ0FDRTdyQixPQUFPLENBQUczQixLQUFLLENBQUNxZCxFQUFOLENBQVNnVSxNQUFuQixDQUNGLElBQUssY0FBTCxDQUNBLElBQUssZ0JBQUwsQ0FDQSxJQUFLLGdCQUFMLENBQ0EsSUFBSyxnQkFBTCxDQUNFN0QsWUFBWSxDQUFHQSxZQUFZLENBQUN2dUIsTUFBYixDQUFvQixDQUFwQixFQUF1QmMsV0FBdkIsRUFBZixDQUNBLE1BQ0YsUUFDRSxHQUFJN0YsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsNEJBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDMmxCLFNBQU4sQ0FBa0IyTixZQUFsQixDQUNBdHpCLEtBQUssQ0FBQ2szQixTQUFOLENBQWtCLENBQ2hCLGNBRGdCLENBQ0EsZ0JBREEsQ0FDa0IsZ0JBRGxCLENBQ29DLGdCQURwQyxDQUVoQixnQkFGZ0IsQ0FBbEIsQ0FHQSxLQUFNbDNCLE1BQU4sQ0FmRixDQWlCQSxHQUFHLENBQUN5SCxPQUFELEVBQVksRUFBRTZyQixZQUFZLEdBQUk3ckIsUUFBbEIsQ0FBZixDQUEyQyxDQUN6QyxLQUFNLElBQUkzSixNQUFKLENBQVUsMkJBQTZCdzFCLFlBQXZDLENBQU4sQ0FDRCxDQUNELE1BQU83ckIsUUFBTyxDQUFDNnJCLFlBQUQsQ0FBUCxDQUFzQi95QixNQUF0QixFQUFQLENBQ0QsQ0FFRCxRQUFTNnpCLG1CQUFULENBQTRCYixJQUE1QixDQUFrQ0MsVUFBbEMsQ0FBOENDLEtBQTlDLENBQXFESCxZQUFyRCxDQUFtRSxDQUNqRSxHQUFJeHZCLE9BQU0sQ0FBRzBYLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQ3ZFO0FBQ0FyQixJQUFJLENBQUNqYixNQUFMLENBQ0VpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEYixDQUN3QkYsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRGxDLENBQytDLEtBRC9DLENBQ3NEb1gsSUFEdEQsQ0FGdUUsQ0FJdkU7QUFDQS9YLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0V1WCxVQUFVLENBQUN0bEIsUUFBWCxFQURGLENBTHVFLENBQTVELENBQWIsQ0FRQTtBQUNBLEdBQUdvbEIsWUFBWSxHQUFLLGNBQXBCLENBQW9DLENBQ2xDeHZCLE1BQU0sQ0FBQzRULEtBQVAsQ0FBYTlNLElBQWIsQ0FDRTtBQUNBNFEsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRW5XLEtBQUssQ0FBQzJELElBQU4sQ0FBV3NJLFVBQVgsQ0FBc0IwaEIsS0FBSyxDQUFDM3VCLFFBQU4sQ0FBZSxFQUFmLENBQXRCLENBREYsQ0FGRixDQUlFO0FBQ0EwVyxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjbFosR0FBRyxDQUFDdWMsSUFBSixDQUFTdVEsWUFBVCxDQUFkLEVBQXNDcGxCLFFBQXRDLEVBREYsQ0FGMEQsQ0FJMUQ7QUFDQXNOLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVNLElBQTVDLENBQWtELEtBQWxELENBQXlELEVBQXpELENBTDBELENBQTVELENBTEYsRUFZRCxDQUNELE1BQU90WSxPQUFQLENBQ0QsQ0FHRCxLQUFPLENBcndSRyxDQXN3UlYsUUF0d1JVLENBdXdSVixLQUFPLFNBQVM2RCxNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7R0FPQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBRUFMLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVCLEtBQUssQ0FBQytkLE1BQU4sQ0FBZS9kLEtBQUssQ0FBQytkLE1BQU4sRUFBZ0IsRUFBaEQsQ0FFQTtBQUNBL2QsS0FBSyxDQUFDK2QsTUFBTixDQUFhVCxVQUFiLENBQTBCdGQsS0FBSyxDQUFDK2QsTUFBTixDQUFhVCxVQUFiLEVBQTJCLEVBQXJELENBRUE7Ozs7Ozs7Ozs7OztHQWFBdGQsS0FBSyxDQUFDK2QsTUFBTixDQUFhNE4sWUFBYixDQUE0QixTQUFTOUwsU0FBVCxDQUFvQjVsQixHQUFwQixDQUF5QixDQUNuRCxHQUFJckMsSUFBRyxDQUFHaW9CLFNBQVYsQ0FDQSxHQUFHLE1BQU9qb0IsSUFBUCxHQUFlLFFBQWxCLENBQTRCLENBQzFCQSxHQUFHLENBQUdvSSxLQUFLLENBQUMrZCxNQUFOLENBQWF1VCxZQUFiLENBQTBCMTVCLEdBQTFCLENBQU4sQ0FDQSxHQUFHQSxHQUFILENBQVEsQ0FDTkEsR0FBRyxDQUFHQSxHQUFHLEVBQVQsQ0FDRCxDQUNGLENBQ0QsR0FBRyxDQUFDQSxHQUFKLENBQVMsQ0FDUCxLQUFNLElBQUlJLE1BQUosQ0FBVSwwQkFBNEI2bkIsU0FBdEMsQ0FBTixDQUNELENBRUQ7QUFDQSxNQUFPLElBQUk3ZixNQUFLLENBQUMrZCxNQUFOLENBQWF3VCxXQUFqQixDQUE2QixDQUNsQzFSLFNBQVMsQ0FBRWpvQixHQUR1QixDQUVsQ3FDLEdBQUcsQ0FBRUEsR0FGNkIsQ0FHbEN1SCxPQUFPLENBQUUsS0FIeUIsQ0FBN0IsQ0FBUCxDQUtELENBbEJELENBb0JBOzs7Ozs7Ozs7Ozs7R0FhQXhCLEtBQUssQ0FBQytkLE1BQU4sQ0FBYTJOLGNBQWIsQ0FBOEIsU0FBUzdMLFNBQVQsQ0FBb0I1bEIsR0FBcEIsQ0FBeUIsQ0FDckQsR0FBSXJDLElBQUcsQ0FBR2lvQixTQUFWLENBQ0EsR0FBRyxNQUFPam9CLElBQVAsR0FBZSxRQUFsQixDQUE0QixDQUMxQkEsR0FBRyxDQUFHb0ksS0FBSyxDQUFDK2QsTUFBTixDQUFhdVQsWUFBYixDQUEwQjE1QixHQUExQixDQUFOLENBQ0EsR0FBR0EsR0FBSCxDQUFRLENBQ05BLEdBQUcsQ0FBR0EsR0FBRyxFQUFULENBQ0QsQ0FDRixDQUNELEdBQUcsQ0FBQ0EsR0FBSixDQUFTLENBQ1AsS0FBTSxJQUFJSSxNQUFKLENBQVUsMEJBQTRCNm5CLFNBQXRDLENBQU4sQ0FDRCxDQUVEO0FBQ0EsTUFBTyxJQUFJN2YsTUFBSyxDQUFDK2QsTUFBTixDQUFhd1QsV0FBakIsQ0FBNkIsQ0FDbEMxUixTQUFTLENBQUVqb0IsR0FEdUIsQ0FFbENxQyxHQUFHLENBQUVBLEdBRjZCLENBR2xDdUgsT0FBTyxDQUFFLElBSHlCLENBQTdCLENBQVAsQ0FLRCxDQWxCRCxDQW9CQTs7Ozs7O0dBT0F4QixLQUFLLENBQUMrZCxNQUFOLENBQWFvTCxpQkFBYixDQUFpQyxTQUFTdnFCLElBQVQsQ0FBZWloQixTQUFmLENBQTBCLENBQ3pEamhCLElBQUksQ0FBR0EsSUFBSSxDQUFDbW1CLFdBQUwsRUFBUCxDQUNBL2tCLEtBQUssQ0FBQytkLE1BQU4sQ0FBYVQsVUFBYixDQUF3QjFlLElBQXhCLEVBQWdDaWhCLFNBQWhDLENBQ0QsQ0FIRCxDQUtBOzs7Ozs7R0FPQTdmLEtBQUssQ0FBQytkLE1BQU4sQ0FBYXVULFlBQWIsQ0FBNEIsU0FBUzF5QixJQUFULENBQWUsQ0FDekNBLElBQUksQ0FBR0EsSUFBSSxDQUFDbW1CLFdBQUwsRUFBUCxDQUNBLEdBQUdubUIsSUFBSSxHQUFJb0IsTUFBSyxDQUFDK2QsTUFBTixDQUFhVCxVQUF4QixDQUFvQyxDQUNsQyxNQUFPdGQsTUFBSyxDQUFDK2QsTUFBTixDQUFhVCxVQUFiLENBQXdCMWUsSUFBeEIsQ0FBUCxDQUNELENBQ0QsTUFBTyxLQUFQLENBQ0QsQ0FORCxDQVFBLEdBQUkyeUIsWUFBVyxDQUFHdnhCLEtBQUssQ0FBQytkLE1BQU4sQ0FBYXdULFdBQWIsQ0FBMkIsU0FBU2g2QixPQUFULENBQWtCLENBQzdELEtBQUtzb0IsU0FBTCxDQUFpQnRvQixPQUFPLENBQUNzb0IsU0FBekIsQ0FDQSxLQUFLeUksSUFBTCxDQUFZLEtBQUt6SSxTQUFMLENBQWV5SSxJQUEzQixDQUNBLEtBQUtPLFNBQUwsQ0FBaUIsS0FBS1AsSUFBTCxDQUFVTyxTQUEzQixDQUNBLEtBQUsySSxPQUFMLENBQWUsS0FBZixDQUNBLEtBQUtDLE1BQUwsQ0FBYyxJQUFkLENBQ0EsS0FBSzlrQixNQUFMLENBQWMsSUFBZCxDQUNBLEtBQUsra0IsR0FBTCxDQUFXbjZCLE9BQU8sQ0FBQ2lLLE9BQVIsQ0FBa0IsS0FBSzhtQixJQUFMLENBQVU5bUIsT0FBNUIsQ0FBc0MsS0FBSzhtQixJQUFMLENBQVVqSCxPQUEzRCxDQUNBLEtBQUtzUSxRQUFMLENBQWdCcDZCLE9BQU8sQ0FBQ2lLLE9BQXhCLENBQ0EsS0FBS3FlLFNBQUwsQ0FBZStJLFVBQWYsQ0FBMEJyeEIsT0FBMUIsRUFDRCxDQVZELENBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkJBZzZCLFdBQVcsQ0FBQ2x1QixTQUFaLENBQXNCMEssS0FBdEIsQ0FBOEIsU0FBU3hXLE9BQVQsQ0FBa0IsQ0FDOUNBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0EsR0FBSTZ2QixLQUFJLENBQUcsRUFBWCxDQUNBLElBQUksR0FBSW50QixJQUFSLEdBQWUxQyxRQUFmLENBQXdCLENBQ3RCNnZCLElBQUksQ0FBQ250QixHQUFELENBQUosQ0FBWTFDLE9BQU8sQ0FBQzBDLEdBQUQsQ0FBbkIsQ0FDRCxDQUNEbXRCLElBQUksQ0FBQzVsQixPQUFMLENBQWUsS0FBS213QixRQUFwQixDQUNBLEtBQUtILE9BQUwsQ0FBZSxLQUFmLENBQ0EsS0FBS0MsTUFBTCxDQUFjenhCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBZCxDQUNBLEtBQUtvRCxNQUFMLENBQWNwVixPQUFPLENBQUNvVixNQUFSLEVBQWtCM00sS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUFoQyxDQUNBLEtBQUsrZSxJQUFMLENBQVV2YSxLQUFWLENBQWdCcVosSUFBaEIsRUFDRCxDQVhELENBYUE7Ozs7R0FLQW1LLFdBQVcsQ0FBQ2x1QixTQUFaLENBQXNCMlEsTUFBdEIsQ0FBK0IsU0FBU3RJLEtBQVQsQ0FBZ0IsQ0FDN0MsR0FBR0EsS0FBSCxDQUFVLENBQ1I7QUFDQSxLQUFLK2xCLE1BQUwsQ0FBWXRwQixTQUFaLENBQXNCdUQsS0FBdEIsRUFDRCxDQUVEO0FBQ0EsTUFBTSxDQUFDLEtBQUtnbUIsR0FBTCxDQUFTcHZCLElBQVQsQ0FBYyxLQUFLZ21CLElBQW5CLENBQXlCLEtBQUttSixNQUE5QixDQUFzQyxLQUFLOWtCLE1BQTNDLENBQW1ELEtBQUs2a0IsT0FBeEQsQ0FBRCxFQUNKLENBQUMsS0FBS0EsT0FEUixDQUNpQixDQUFFLENBRW5CO0FBQ0EsS0FBS0MsTUFBTCxDQUFZam9CLE9BQVosR0FDRCxDQVpELENBY0E7Ozs7Ozs7R0FRQStuQixXQUFXLENBQUNsdUIsU0FBWixDQUFzQmtrQixNQUF0QixDQUErQixTQUFTcUssR0FBVCxDQUFjLENBQzNDO0FBQ0E7QUFDQSxHQUFHQSxHQUFHLEdBQUssS0FBS3RKLElBQUwsQ0FBVTFwQixJQUFWLEdBQW1CLEtBQW5CLEVBQTRCLEtBQUswcEIsSUFBTCxDQUFVMXBCLElBQVYsR0FBbUIsS0FBcEQsQ0FBTixDQUFrRSxDQUNoRSxLQUFLMHBCLElBQUwsQ0FBVXNKLEdBQVYsQ0FBZ0IsU0FBU2xtQixLQUFULENBQWdCLENBQzlCLE1BQU9rbUIsSUFBRyxDQUFDLEtBQUsvSSxTQUFOLENBQWlCbmQsS0FBakIsQ0FBd0IsS0FBeEIsQ0FBVixDQUNELENBRkQsQ0FHQSxLQUFLNGMsSUFBTCxDQUFVdUosS0FBVixDQUFrQixTQUFTbGxCLE1BQVQsQ0FBaUIsQ0FDakMsTUFBT2lsQixJQUFHLENBQUMsS0FBSy9JLFNBQU4sQ0FBaUJsYyxNQUFqQixDQUF5QixJQUF6QixDQUFWLENBQ0QsQ0FGRCxDQUdELENBRUQ7QUFDQSxHQUFJcFYsUUFBTyxDQUFHLEVBQWQsQ0FDQUEsT0FBTyxDQUFDaUssT0FBUixDQUFrQixLQUFLbXdCLFFBQXZCLENBRUE7QUFDQXA2QixPQUFPLENBQUN1NkIsUUFBUixDQUFtQixLQUFLTCxNQUFMLENBQVl2NUIsTUFBWixHQUF1QixLQUFLMndCLFNBQS9DLENBRUEsR0FBRyxDQUFDLEtBQUs4SSxRQUFOLEVBQWtCLEtBQUtySixJQUFMLENBQVVzSixHQUEvQixDQUFvQyxDQUNsQyxHQUFHLENBQUMsS0FBS3RKLElBQUwsQ0FBVXNKLEdBQVYsQ0FBYyxLQUFLSCxNQUFuQixDQUEyQmw2QixPQUEzQixDQUFKLENBQXlDLENBQ3ZDLE1BQU8sTUFBUCxDQUNELENBQ0YsQ0FFRDtBQUNBLEtBQUtpNkIsT0FBTCxDQUFlLElBQWYsQ0FDQSxLQUFLeGQsTUFBTCxHQUVBLEdBQUcsS0FBSzJkLFFBQUwsRUFBaUIsS0FBS3JKLElBQUwsQ0FBVXVKLEtBQTlCLENBQXFDLENBQ25DLEdBQUcsQ0FBQyxLQUFLdkosSUFBTCxDQUFVdUosS0FBVixDQUFnQixLQUFLbGxCLE1BQXJCLENBQTZCcFYsT0FBN0IsQ0FBSixDQUEyQyxDQUN6QyxNQUFPLE1BQVAsQ0FDRCxDQUNGLENBRUQsR0FBRyxLQUFLK3dCLElBQUwsQ0FBVXlKLFdBQWIsQ0FBMEIsQ0FDeEIsR0FBRyxDQUFDLEtBQUt6SixJQUFMLENBQVV5SixXQUFWLENBQXNCLEtBQUtwbEIsTUFBM0IsQ0FBbUNwVixPQUFuQyxDQUFKLENBQWlELENBQy9DLE1BQU8sTUFBUCxDQUNELENBQ0YsQ0FFRCxNQUFPLEtBQVAsQ0FDRCxDQTFDRCxDQTZDQSxLQUFPLENBai9SRyxDQWsvUlYsUUFsL1JVLENBbS9SVixLQUFPLFNBQVNzSyxNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7R0FPQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBRUFsQyxLQUFLLENBQUMrZCxNQUFOLENBQWUvZCxLQUFLLENBQUMrZCxNQUFOLEVBQWdCLEVBQS9CLENBRUE7QUFDQSxHQUFJcUwsTUFBSyxDQUFHdm5CLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVCLEtBQUssQ0FBQytkLE1BQU4sQ0FBYXFMLEtBQWIsQ0FBcUJwcEIsS0FBSyxDQUFDK2QsTUFBTixDQUFhcUwsS0FBYixFQUFzQixFQUF4RSxDQUVBLG1FQUVBQSxLQUFLLENBQUNDLEdBQU4sQ0FBWSxTQUFTOXhCLE9BQVQsQ0FBa0IsQ0FDNUJBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0EsS0FBS3FILElBQUwsQ0FBWSxLQUFaLENBQ0EsS0FBS21mLE1BQUwsQ0FBY3htQixPQUFPLENBQUN3bUIsTUFBdEIsQ0FDQSxLQUFLOEssU0FBTCxDQUFpQnR4QixPQUFPLENBQUNzeEIsU0FBUixFQUFxQixFQUF0QyxDQUNBLEtBQUttSixLQUFMLENBQWEsS0FBS25KLFNBQUwsQ0FBaUIsQ0FBOUIsQ0FDQSxLQUFLb0osUUFBTCxDQUFnQixHQUFJNzVCLE1BQUosQ0FBVSxLQUFLNDVCLEtBQWYsQ0FBaEIsQ0FDQSxLQUFLRSxTQUFMLENBQWlCLEdBQUk5NUIsTUFBSixDQUFVLEtBQUs0NUIsS0FBZixDQUFqQixDQUNELENBUkQsQ0FVQTVJLEtBQUssQ0FBQ0MsR0FBTixDQUFVaG1CLFNBQVYsQ0FBb0IwSyxLQUFwQixDQUE0QixTQUFTeFcsT0FBVCxDQUFrQixDQUFFLENBQWhELENBRUE2eEIsS0FBSyxDQUFDQyxHQUFOLENBQVVobUIsU0FBVixDQUFvQmdlLE9BQXBCLENBQThCLFNBQVMzVixLQUFULENBQWdCaUIsTUFBaEIsQ0FBd0I0YSxNQUF4QixDQUFnQyxDQUM1RDtBQUNBLEdBQUc3YixLQUFLLENBQUN4VCxNQUFOLEdBQWlCLEtBQUsyd0IsU0FBdEIsRUFBbUMsRUFBRXRCLE1BQU0sRUFBSTdiLEtBQUssQ0FBQ3hULE1BQU4sR0FBaUIsQ0FBN0IsQ0FBdEMsQ0FBdUUsQ0FDckUsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBLElBQUksR0FBSWtLLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEMsS0FBSzZ2QixRQUFMLENBQWM3dkIsQ0FBZCxFQUFtQnNKLEtBQUssQ0FBQ2hELFFBQU4sRUFBbkIsQ0FDRCxDQUVEO0FBQ0EsS0FBS3FWLE1BQUwsQ0FBWXNELE9BQVosQ0FBb0IsS0FBSzRRLFFBQXpCLENBQW1DLEtBQUtDLFNBQXhDLEVBRUE7QUFDQSxJQUFJLEdBQUk5dkIsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLEtBQUs0dkIsS0FBeEIsQ0FBK0IsRUFBRTV2QixDQUFqQyxDQUFvQyxDQUNsQ3VLLE1BQU0sQ0FBQzlFLFFBQVAsQ0FBZ0IsS0FBS3FxQixTQUFMLENBQWU5dkIsQ0FBZixDQUFoQixFQUNELENBQ0YsQ0FsQkQsQ0FvQkFnbkIsS0FBSyxDQUFDQyxHQUFOLENBQVVobUIsU0FBVixDQUFvQjdCLE9BQXBCLENBQThCLFNBQVNrSyxLQUFULENBQWdCaUIsTUFBaEIsQ0FBd0I0YSxNQUF4QixDQUFnQyxDQUM1RDtBQUNBLEdBQUc3YixLQUFLLENBQUN4VCxNQUFOLEdBQWlCLEtBQUsyd0IsU0FBdEIsRUFBbUMsRUFBRXRCLE1BQU0sRUFBSTdiLEtBQUssQ0FBQ3hULE1BQU4sR0FBaUIsQ0FBN0IsQ0FBdEMsQ0FBdUUsQ0FDckUsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBLElBQUksR0FBSWtLLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEMsS0FBSzZ2QixRQUFMLENBQWM3dkIsQ0FBZCxFQUFtQnNKLEtBQUssQ0FBQ2hELFFBQU4sRUFBbkIsQ0FDRCxDQUVEO0FBQ0EsS0FBS3FWLE1BQUwsQ0FBWXZjLE9BQVosQ0FBb0IsS0FBS3l3QixRQUF6QixDQUFtQyxLQUFLQyxTQUF4QyxFQUVBO0FBQ0EsSUFBSSxHQUFJOXZCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEN1SyxNQUFNLENBQUM5RSxRQUFQLENBQWdCLEtBQUtxcUIsU0FBTCxDQUFlOXZCLENBQWYsQ0FBaEIsRUFDRCxDQUNGLENBbEJELENBb0JBZ25CLEtBQUssQ0FBQ0MsR0FBTixDQUFVaG1CLFNBQVYsQ0FBb0J1dUIsR0FBcEIsQ0FBMEIsU0FBU2xtQixLQUFULENBQWdCblUsT0FBaEIsQ0FBeUIsQ0FDakQ7QUFDQTtBQUNBLEdBQUk0NkIsUUFBTyxDQUFJem1CLEtBQUssQ0FBQ3hULE1BQU4sS0FBbUIsS0FBSzJ3QixTQUF4QixDQUNiLEtBQUtBLFNBRFEsQ0FDSyxLQUFLQSxTQUFMLENBQWlCbmQsS0FBSyxDQUFDeFQsTUFBTixFQURyQyxDQUVBd1QsS0FBSyxDQUFDcEUsWUFBTixDQUFtQjZxQixPQUFuQixDQUE0QkEsT0FBNUIsRUFDQSxNQUFPLEtBQVAsQ0FDRCxDQVBELENBU0EvSSxLQUFLLENBQUNDLEdBQU4sQ0FBVWhtQixTQUFWLENBQW9Cd3VCLEtBQXBCLENBQTRCLFNBQVNsbEIsTUFBVCxDQUFpQnBWLE9BQWpCLENBQTBCLENBQ3BEO0FBQ0EsR0FBR0EsT0FBTyxDQUFDdTZCLFFBQVIsQ0FBbUIsQ0FBdEIsQ0FBeUIsQ0FDdkIsTUFBTyxNQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUlwb0IsSUFBRyxDQUFHaUQsTUFBTSxDQUFDelUsTUFBUCxFQUFWLENBQ0EsR0FBSStRLE1BQUssQ0FBRzBELE1BQU0sQ0FBQ3ZELEVBQVAsQ0FBVU0sR0FBRyxDQUFHLENBQWhCLENBQVosQ0FDQSxHQUFHVCxLQUFLLENBQUksS0FBSzRmLFNBQUwsRUFBa0IsQ0FBOUIsQ0FBa0MsQ0FDaEMsTUFBTyxNQUFQLENBQ0QsQ0FFRDtBQUNBbGMsTUFBTSxDQUFDbEQsUUFBUCxDQUFnQlIsS0FBaEIsRUFDQSxNQUFPLEtBQVAsQ0FDRCxDQWhCRCxDQWtCQSxtQ0FFQW1nQixLQUFLLENBQUNFLEdBQU4sQ0FBWSxTQUFTL3hCLE9BQVQsQ0FBa0IsQ0FDNUJBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0EsS0FBS3FILElBQUwsQ0FBWSxLQUFaLENBQ0EsS0FBS21mLE1BQUwsQ0FBY3htQixPQUFPLENBQUN3bUIsTUFBdEIsQ0FDQSxLQUFLOEssU0FBTCxDQUFpQnR4QixPQUFPLENBQUNzeEIsU0FBUixFQUFxQixFQUF0QyxDQUNBLEtBQUttSixLQUFMLENBQWEsS0FBS25KLFNBQUwsQ0FBaUIsQ0FBOUIsQ0FDQSxLQUFLb0osUUFBTCxDQUFnQixHQUFJNzVCLE1BQUosQ0FBVSxLQUFLNDVCLEtBQWYsQ0FBaEIsQ0FDQSxLQUFLRSxTQUFMLENBQWlCLEdBQUk5NUIsTUFBSixDQUFVLEtBQUs0NUIsS0FBZixDQUFqQixDQUNELENBUkQsQ0FVQTVJLEtBQUssQ0FBQ0UsR0FBTixDQUFVam1CLFNBQVYsQ0FBb0IwSyxLQUFwQixDQUE0QixTQUFTeFcsT0FBVCxDQUFrQixDQUM1QztBQUNBO0FBQ0EsR0FBR0EsT0FBTyxDQUFDOHdCLEVBQVIsR0FBZSxJQUFsQixDQUF3QixDQUN0QjtBQUNBLEdBQUcsQ0FBQyxLQUFLK0osS0FBVCxDQUFnQixDQUNkLEtBQU0sSUFBSXA2QixNQUFKLENBQVUsdUJBQVYsQ0FBTixDQUNELENBQ0QsS0FBS3E2QixHQUFMLENBQVcsS0FBS0QsS0FBTCxDQUFXeHRCLEtBQVgsQ0FBaUIsQ0FBakIsQ0FBWCxDQUNELENBTkQsSUFNTyxJQUFHLEVBQUUsTUFBUXJOLFFBQVYsQ0FBSCxDQUF1QixDQUM1QixLQUFNLElBQUlTLE1BQUosQ0FBVSx1QkFBVixDQUFOLENBQ0QsQ0FGTSxJQUVBLENBQ0w7QUFDQSxLQUFLcTZCLEdBQUwsQ0FBV0MsV0FBVyxDQUFDLzZCLE9BQU8sQ0FBQzh3QixFQUFULENBQXRCLENBQ0EsS0FBSytKLEtBQUwsQ0FBYSxLQUFLQyxHQUFMLENBQVN6dEIsS0FBVCxDQUFlLENBQWYsQ0FBYixDQUNELENBQ0YsQ0FoQkQsQ0FrQkF3a0IsS0FBSyxDQUFDRSxHQUFOLENBQVVqbUIsU0FBVixDQUFvQmdlLE9BQXBCLENBQThCLFNBQVMzVixLQUFULENBQWdCaUIsTUFBaEIsQ0FBd0I0YSxNQUF4QixDQUFnQyxDQUM1RDtBQUNBLEdBQUc3YixLQUFLLENBQUN4VCxNQUFOLEdBQWlCLEtBQUsyd0IsU0FBdEIsRUFBbUMsRUFBRXRCLE1BQU0sRUFBSTdiLEtBQUssQ0FBQ3hULE1BQU4sR0FBaUIsQ0FBN0IsQ0FBdEMsQ0FBdUUsQ0FDckUsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBO0FBQ0EsSUFBSSxHQUFJa0ssRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLEtBQUs0dkIsS0FBeEIsQ0FBK0IsRUFBRTV2QixDQUFqQyxDQUFvQyxDQUNsQyxLQUFLNnZCLFFBQUwsQ0FBYzd2QixDQUFkLEVBQW1CLEtBQUtnd0IsS0FBTCxDQUFXaHdCLENBQVgsRUFBZ0JzSixLQUFLLENBQUNoRCxRQUFOLEVBQW5DLENBQ0QsQ0FFRDtBQUNBLEtBQUtxVixNQUFMLENBQVlzRCxPQUFaLENBQW9CLEtBQUs0USxRQUF6QixDQUFtQyxLQUFLQyxTQUF4QyxFQUVBO0FBQ0EsSUFBSSxHQUFJOXZCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEN1SyxNQUFNLENBQUM5RSxRQUFQLENBQWdCLEtBQUtxcUIsU0FBTCxDQUFlOXZCLENBQWYsQ0FBaEIsRUFDRCxDQUNELEtBQUtnd0IsS0FBTCxDQUFhLEtBQUtGLFNBQWxCLENBQ0QsQ0FwQkQsQ0FzQkE5SSxLQUFLLENBQUNFLEdBQU4sQ0FBVWptQixTQUFWLENBQW9CN0IsT0FBcEIsQ0FBOEIsU0FBU2tLLEtBQVQsQ0FBZ0JpQixNQUFoQixDQUF3QjRhLE1BQXhCLENBQWdDLENBQzVEO0FBQ0EsR0FBRzdiLEtBQUssQ0FBQ3hULE1BQU4sR0FBaUIsS0FBSzJ3QixTQUF0QixFQUFtQyxFQUFFdEIsTUFBTSxFQUFJN2IsS0FBSyxDQUFDeFQsTUFBTixHQUFpQixDQUE3QixDQUF0QyxDQUF1RSxDQUNyRSxNQUFPLEtBQVAsQ0FDRCxDQUVEO0FBQ0EsSUFBSSxHQUFJa0ssRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLEtBQUs0dkIsS0FBeEIsQ0FBK0IsRUFBRTV2QixDQUFqQyxDQUFvQyxDQUNsQyxLQUFLNnZCLFFBQUwsQ0FBYzd2QixDQUFkLEVBQW1Cc0osS0FBSyxDQUFDaEQsUUFBTixFQUFuQixDQUNELENBRUQ7QUFDQSxLQUFLcVYsTUFBTCxDQUFZdmMsT0FBWixDQUFvQixLQUFLeXdCLFFBQXpCLENBQW1DLEtBQUtDLFNBQXhDLEVBRUE7QUFDQTtBQUNBLElBQUksR0FBSTl2QixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsS0FBSzR2QixLQUF4QixDQUErQixFQUFFNXZCLENBQWpDLENBQW9DLENBQ2xDdUssTUFBTSxDQUFDOUUsUUFBUCxDQUFnQixLQUFLdXFCLEtBQUwsQ0FBV2h3QixDQUFYLEVBQWdCLEtBQUs4dkIsU0FBTCxDQUFlOXZCLENBQWYsQ0FBaEMsRUFDRCxDQUNELEtBQUtnd0IsS0FBTCxDQUFhLEtBQUtILFFBQUwsQ0FBY3J0QixLQUFkLENBQW9CLENBQXBCLENBQWIsQ0FDRCxDQXBCRCxDQXNCQXdrQixLQUFLLENBQUNFLEdBQU4sQ0FBVWptQixTQUFWLENBQW9CdXVCLEdBQXBCLENBQTBCLFNBQVNsbUIsS0FBVCxDQUFnQm5VLE9BQWhCLENBQXlCLENBQ2pEO0FBQ0E7QUFDQSxHQUFJNDZCLFFBQU8sQ0FBSXptQixLQUFLLENBQUN4VCxNQUFOLEtBQW1CLEtBQUsyd0IsU0FBeEIsQ0FDYixLQUFLQSxTQURRLENBQ0ssS0FBS0EsU0FBTCxDQUFpQm5kLEtBQUssQ0FBQ3hULE1BQU4sRUFEckMsQ0FFQXdULEtBQUssQ0FBQ3BFLFlBQU4sQ0FBbUI2cUIsT0FBbkIsQ0FBNEJBLE9BQTVCLEVBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FQRCxDQVNBL0ksS0FBSyxDQUFDRSxHQUFOLENBQVVqbUIsU0FBVixDQUFvQnd1QixLQUFwQixDQUE0QixTQUFTbGxCLE1BQVQsQ0FBaUJwVixPQUFqQixDQUEwQixDQUNwRDtBQUNBLEdBQUdBLE9BQU8sQ0FBQ3U2QixRQUFSLENBQW1CLENBQXRCLENBQXlCLENBQ3ZCLE1BQU8sTUFBUCxDQUNELENBRUQ7QUFDQSxHQUFJcG9CLElBQUcsQ0FBR2lELE1BQU0sQ0FBQ3pVLE1BQVAsRUFBVixDQUNBLEdBQUkrUSxNQUFLLENBQUcwRCxNQUFNLENBQUN2RCxFQUFQLENBQVVNLEdBQUcsQ0FBRyxDQUFoQixDQUFaLENBQ0EsR0FBR1QsS0FBSyxDQUFJLEtBQUs0ZixTQUFMLEVBQWtCLENBQTlCLENBQWtDLENBQ2hDLE1BQU8sTUFBUCxDQUNELENBRUQ7QUFDQWxjLE1BQU0sQ0FBQ2xELFFBQVAsQ0FBZ0JSLEtBQWhCLEVBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FoQkQsQ0FrQkEsNkJBRUFtZ0IsS0FBSyxDQUFDRyxHQUFOLENBQVksU0FBU2h5QixPQUFULENBQWtCLENBQzVCQSxPQUFPLENBQUdBLE9BQU8sRUFBSSxFQUFyQixDQUNBLEtBQUtxSCxJQUFMLENBQVksS0FBWixDQUNBLEtBQUttZixNQUFMLENBQWN4bUIsT0FBTyxDQUFDd21CLE1BQXRCLENBQ0EsS0FBSzhLLFNBQUwsQ0FBaUJ0eEIsT0FBTyxDQUFDc3hCLFNBQVIsRUFBcUIsRUFBdEMsQ0FDQSxLQUFLbUosS0FBTCxDQUFhLEtBQUtuSixTQUFMLENBQWlCLENBQTlCLENBQ0EsS0FBS29KLFFBQUwsQ0FBZ0IsSUFBaEIsQ0FDQSxLQUFLQyxTQUFMLENBQWlCLEdBQUk5NUIsTUFBSixDQUFVLEtBQUs0NUIsS0FBZixDQUFqQixDQUNBLEtBQUtPLGFBQUwsQ0FBcUIsR0FBSW42QixNQUFKLENBQVUsS0FBSzQ1QixLQUFmLENBQXJCLENBQ0EsS0FBS1EsY0FBTCxDQUFzQnh5QixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQXRCLENBQ0EsS0FBS2twQixhQUFMLENBQXFCLENBQXJCLENBQ0QsQ0FYRCxDQWFBckosS0FBSyxDQUFDRyxHQUFOLENBQVVsbUIsU0FBVixDQUFvQjBLLEtBQXBCLENBQTRCLFNBQVN4VyxPQUFULENBQWtCLENBQzVDLEdBQUcsRUFBRSxNQUFRQSxRQUFWLENBQUgsQ0FBdUIsQ0FDckIsS0FBTSxJQUFJUyxNQUFKLENBQVUsdUJBQVYsQ0FBTixDQUNELENBQ0Q7QUFDQSxLQUFLcTZCLEdBQUwsQ0FBV0MsV0FBVyxDQUFDLzZCLE9BQU8sQ0FBQzh3QixFQUFULENBQXRCLENBQ0EsS0FBSzRKLFFBQUwsQ0FBZ0IsS0FBS0ksR0FBTCxDQUFTenRCLEtBQVQsQ0FBZSxDQUFmLENBQWhCLENBQ0EsS0FBSzZ0QixhQUFMLENBQXFCLENBQXJCLENBQ0QsQ0FSRCxDQVVBckosS0FBSyxDQUFDRyxHQUFOLENBQVVsbUIsU0FBVixDQUFvQmdlLE9BQXBCLENBQThCLFNBQVMzVixLQUFULENBQWdCaUIsTUFBaEIsQ0FBd0I0YSxNQUF4QixDQUFnQyxDQUM1RDtBQUNBLEdBQUltTCxZQUFXLENBQUdobkIsS0FBSyxDQUFDeFQsTUFBTixFQUFsQixDQUNBLEdBQUd3NkIsV0FBVyxHQUFLLENBQW5CLENBQXNCLENBQ3BCLE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDQSxLQUFLM1UsTUFBTCxDQUFZc0QsT0FBWixDQUFvQixLQUFLNFEsUUFBekIsQ0FBbUMsS0FBS0MsU0FBeEMsRUFFQTtBQUNBLEdBQUcsS0FBS08sYUFBTCxHQUF1QixDQUF2QixFQUE0QkMsV0FBVyxFQUFJLEtBQUs3SixTQUFuRCxDQUE4RCxDQUM1RDtBQUNBLElBQUksR0FBSXptQixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsS0FBSzR2QixLQUF4QixDQUErQixFQUFFNXZCLENBQWpDLENBQW9DLENBQ2xDLEtBQUs2dkIsUUFBTCxDQUFjN3ZCLENBQWQsRUFBbUJzSixLQUFLLENBQUNoRCxRQUFOLEdBQW1CLEtBQUt3cEIsU0FBTCxDQUFlOXZCLENBQWYsQ0FBdEMsQ0FDQXVLLE1BQU0sQ0FBQzlFLFFBQVAsQ0FBZ0IsS0FBS29xQixRQUFMLENBQWM3dkIsQ0FBZCxDQUFoQixFQUNELENBQ0QsT0FDRCxDQUVEO0FBQ0EsR0FBSXV3QixhQUFZLENBQUcsQ0FBQyxLQUFLOUosU0FBTCxDQUFpQjZKLFdBQWxCLEVBQWlDLEtBQUs3SixTQUF6RCxDQUNBLEdBQUc4SixZQUFZLENBQUcsQ0FBbEIsQ0FBcUIsQ0FDbkJBLFlBQVksQ0FBRyxLQUFLOUosU0FBTCxDQUFpQjhKLFlBQWhDLENBQ0QsQ0FFRDtBQUNBLEtBQUtILGNBQUwsQ0FBb0JycEIsS0FBcEIsR0FDQSxJQUFJLEdBQUkvRyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsS0FBSzR2QixLQUF4QixDQUErQixFQUFFNXZCLENBQWpDLENBQW9DLENBQ2xDLEtBQUttd0IsYUFBTCxDQUFtQm53QixDQUFuQixFQUF3QnNKLEtBQUssQ0FBQ2hELFFBQU4sR0FBbUIsS0FBS3dwQixTQUFMLENBQWU5dkIsQ0FBZixDQUEzQyxDQUNBLEtBQUtvd0IsY0FBTCxDQUFvQjNxQixRQUFwQixDQUE2QixLQUFLMHFCLGFBQUwsQ0FBbUJud0IsQ0FBbkIsQ0FBN0IsRUFDRCxDQUVELEdBQUd1d0IsWUFBWSxDQUFHLENBQWxCLENBQXFCLENBQ25CO0FBQ0FqbkIsS0FBSyxDQUFDakYsSUFBTixFQUFjLEtBQUtvaUIsU0FBbkIsQ0FDRCxDQUhELElBR08sQ0FDTDtBQUNBLElBQUksR0FBSXptQixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsS0FBSzR2QixLQUF4QixDQUErQixFQUFFNXZCLENBQWpDLENBQW9DLENBQ2xDLEtBQUs2dkIsUUFBTCxDQUFjN3ZCLENBQWQsRUFBbUIsS0FBS213QixhQUFMLENBQW1CbndCLENBQW5CLENBQW5CLENBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBRyxLQUFLcXdCLGFBQUwsQ0FBcUIsQ0FBeEIsQ0FBMkIsQ0FDekIsS0FBS0QsY0FBTCxDQUFvQnBxQixRQUFwQixDQUE2QixLQUFLcXFCLGFBQWxDLEVBQ0QsQ0FFRCxHQUFHRSxZQUFZLENBQUcsQ0FBZixFQUFvQixDQUFDcEwsTUFBeEIsQ0FBZ0MsQ0FDOUI1YSxNQUFNLENBQUN0RixRQUFQLENBQWdCLEtBQUttckIsY0FBTCxDQUFvQnBxQixRQUFwQixDQUNkdXFCLFlBQVksQ0FBRyxLQUFLRixhQUROLENBQWhCLEVBRUEsS0FBS0EsYUFBTCxDQUFxQkUsWUFBckIsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUVEaG1CLE1BQU0sQ0FBQ3RGLFFBQVAsQ0FBZ0IsS0FBS21yQixjQUFMLENBQW9CcHFCLFFBQXBCLENBQ2RzcUIsV0FBVyxDQUFHLEtBQUtELGFBREwsQ0FBaEIsRUFFQSxLQUFLQSxhQUFMLENBQXFCLENBQXJCLENBQ0QsQ0ExREQsQ0E0REFySixLQUFLLENBQUNHLEdBQU4sQ0FBVWxtQixTQUFWLENBQW9CN0IsT0FBcEIsQ0FBOEIsU0FBU2tLLEtBQVQsQ0FBZ0JpQixNQUFoQixDQUF3QjRhLE1BQXhCLENBQWdDLENBQzVEO0FBQ0EsR0FBSW1MLFlBQVcsQ0FBR2huQixLQUFLLENBQUN4VCxNQUFOLEVBQWxCLENBQ0EsR0FBR3c2QixXQUFXLEdBQUssQ0FBbkIsQ0FBc0IsQ0FDcEIsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBLEtBQUszVSxNQUFMLENBQVlzRCxPQUFaLENBQW9CLEtBQUs0USxRQUF6QixDQUFtQyxLQUFLQyxTQUF4QyxFQUVBO0FBQ0EsR0FBRyxLQUFLTyxhQUFMLEdBQXVCLENBQXZCLEVBQTRCQyxXQUFXLEVBQUksS0FBSzdKLFNBQW5ELENBQThELENBQzVEO0FBQ0EsSUFBSSxHQUFJem1CLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEMsS0FBSzZ2QixRQUFMLENBQWM3dkIsQ0FBZCxFQUFtQnNKLEtBQUssQ0FBQ2hELFFBQU4sRUFBbkIsQ0FDQWlFLE1BQU0sQ0FBQzlFLFFBQVAsQ0FBZ0IsS0FBS29xQixRQUFMLENBQWM3dkIsQ0FBZCxFQUFtQixLQUFLOHZCLFNBQUwsQ0FBZTl2QixDQUFmLENBQW5DLEVBQ0QsQ0FDRCxPQUNELENBRUQ7QUFDQSxHQUFJdXdCLGFBQVksQ0FBRyxDQUFDLEtBQUs5SixTQUFMLENBQWlCNkosV0FBbEIsRUFBaUMsS0FBSzdKLFNBQXpELENBQ0EsR0FBRzhKLFlBQVksQ0FBRyxDQUFsQixDQUFxQixDQUNuQkEsWUFBWSxDQUFHLEtBQUs5SixTQUFMLENBQWlCOEosWUFBaEMsQ0FDRCxDQUVEO0FBQ0EsS0FBS0gsY0FBTCxDQUFvQnJwQixLQUFwQixHQUNBLElBQUksR0FBSS9HLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEMsS0FBS213QixhQUFMLENBQW1CbndCLENBQW5CLEVBQXdCc0osS0FBSyxDQUFDaEQsUUFBTixFQUF4QixDQUNBLEtBQUs4cEIsY0FBTCxDQUFvQjNxQixRQUFwQixDQUE2QixLQUFLMHFCLGFBQUwsQ0FBbUJud0IsQ0FBbkIsRUFBd0IsS0FBSzh2QixTQUFMLENBQWU5dkIsQ0FBZixDQUFyRCxFQUNELENBRUQsR0FBR3V3QixZQUFZLENBQUcsQ0FBbEIsQ0FBcUIsQ0FDbkI7QUFDQWpuQixLQUFLLENBQUNqRixJQUFOLEVBQWMsS0FBS29pQixTQUFuQixDQUNELENBSEQsSUFHTyxDQUNMO0FBQ0EsSUFBSSxHQUFJem1CLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEMsS0FBSzZ2QixRQUFMLENBQWM3dkIsQ0FBZCxFQUFtQixLQUFLbXdCLGFBQUwsQ0FBbUJud0IsQ0FBbkIsQ0FBbkIsQ0FDRCxDQUNGLENBRUQ7QUFDQSxHQUFHLEtBQUtxd0IsYUFBTCxDQUFxQixDQUF4QixDQUEyQixDQUN6QixLQUFLRCxjQUFMLENBQW9CcHFCLFFBQXBCLENBQTZCLEtBQUtxcUIsYUFBbEMsRUFDRCxDQUVELEdBQUdFLFlBQVksQ0FBRyxDQUFmLEVBQW9CLENBQUNwTCxNQUF4QixDQUFnQyxDQUM5QjVhLE1BQU0sQ0FBQ3RGLFFBQVAsQ0FBZ0IsS0FBS21yQixjQUFMLENBQW9CcHFCLFFBQXBCLENBQ2R1cUIsWUFBWSxDQUFHLEtBQUtGLGFBRE4sQ0FBaEIsRUFFQSxLQUFLQSxhQUFMLENBQXFCRSxZQUFyQixDQUNBLE1BQU8sS0FBUCxDQUNELENBRURobUIsTUFBTSxDQUFDdEYsUUFBUCxDQUFnQixLQUFLbXJCLGNBQUwsQ0FBb0JwcUIsUUFBcEIsQ0FDZHNxQixXQUFXLENBQUcsS0FBS0QsYUFETCxDQUFoQixFQUVBLEtBQUtBLGFBQUwsQ0FBcUIsQ0FBckIsQ0FDRCxDQTFERCxDQTREQSw2QkFFQXJKLEtBQUssQ0FBQ0ksR0FBTixDQUFZLFNBQVNqeUIsT0FBVCxDQUFrQixDQUM1QkEsT0FBTyxDQUFHQSxPQUFPLEVBQUksRUFBckIsQ0FDQSxLQUFLcUgsSUFBTCxDQUFZLEtBQVosQ0FDQSxLQUFLbWYsTUFBTCxDQUFjeG1CLE9BQU8sQ0FBQ3dtQixNQUF0QixDQUNBLEtBQUs4SyxTQUFMLENBQWlCdHhCLE9BQU8sQ0FBQ3N4QixTQUFSLEVBQXFCLEVBQXRDLENBQ0EsS0FBS21KLEtBQUwsQ0FBYSxLQUFLbkosU0FBTCxDQUFpQixDQUE5QixDQUNBLEtBQUtvSixRQUFMLENBQWdCLElBQWhCLENBQ0EsS0FBS0MsU0FBTCxDQUFpQixHQUFJOTVCLE1BQUosQ0FBVSxLQUFLNDVCLEtBQWYsQ0FBakIsQ0FDQSxLQUFLUSxjQUFMLENBQXNCeHlCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBdEIsQ0FDQSxLQUFLa3BCLGFBQUwsQ0FBcUIsQ0FBckIsQ0FDRCxDQVZELENBWUFySixLQUFLLENBQUNJLEdBQU4sQ0FBVW5tQixTQUFWLENBQW9CMEssS0FBcEIsQ0FBNEIsU0FBU3hXLE9BQVQsQ0FBa0IsQ0FDNUMsR0FBRyxFQUFFLE1BQVFBLFFBQVYsQ0FBSCxDQUF1QixDQUNyQixLQUFNLElBQUlTLE1BQUosQ0FBVSx1QkFBVixDQUFOLENBQ0QsQ0FDRDtBQUNBLEtBQUtxNkIsR0FBTCxDQUFXQyxXQUFXLENBQUMvNkIsT0FBTyxDQUFDOHdCLEVBQVQsQ0FBdEIsQ0FDQSxLQUFLNEosUUFBTCxDQUFnQixLQUFLSSxHQUFMLENBQVN6dEIsS0FBVCxDQUFlLENBQWYsQ0FBaEIsQ0FDQSxLQUFLNnRCLGFBQUwsQ0FBcUIsQ0FBckIsQ0FDRCxDQVJELENBVUFySixLQUFLLENBQUNJLEdBQU4sQ0FBVW5tQixTQUFWLENBQW9CZ2UsT0FBcEIsQ0FBOEIsU0FBUzNWLEtBQVQsQ0FBZ0JpQixNQUFoQixDQUF3QjRhLE1BQXhCLENBQWdDLENBQzVEO0FBQ0EsR0FBSW1MLFlBQVcsQ0FBR2huQixLQUFLLENBQUN4VCxNQUFOLEVBQWxCLENBQ0EsR0FBR3dULEtBQUssQ0FBQ3hULE1BQU4sS0FBbUIsQ0FBdEIsQ0FBeUIsQ0FDdkIsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBLEtBQUs2bEIsTUFBTCxDQUFZc0QsT0FBWixDQUFvQixLQUFLNFEsUUFBekIsQ0FBbUMsS0FBS0MsU0FBeEMsRUFFQTtBQUNBLEdBQUcsS0FBS08sYUFBTCxHQUF1QixDQUF2QixFQUE0QkMsV0FBVyxFQUFJLEtBQUs3SixTQUFuRCxDQUE4RCxDQUM1RDtBQUNBLElBQUksR0FBSXptQixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsS0FBSzR2QixLQUF4QixDQUErQixFQUFFNXZCLENBQWpDLENBQW9DLENBQ2xDdUssTUFBTSxDQUFDOUUsUUFBUCxDQUFnQjZELEtBQUssQ0FBQ2hELFFBQU4sR0FBbUIsS0FBS3dwQixTQUFMLENBQWU5dkIsQ0FBZixDQUFuQyxFQUNBLEtBQUs2dkIsUUFBTCxDQUFjN3ZCLENBQWQsRUFBbUIsS0FBSzh2QixTQUFMLENBQWU5dkIsQ0FBZixDQUFuQixDQUNELENBQ0QsT0FDRCxDQUVEO0FBQ0EsR0FBSXV3QixhQUFZLENBQUcsQ0FBQyxLQUFLOUosU0FBTCxDQUFpQjZKLFdBQWxCLEVBQWlDLEtBQUs3SixTQUF6RCxDQUNBLEdBQUc4SixZQUFZLENBQUcsQ0FBbEIsQ0FBcUIsQ0FDbkJBLFlBQVksQ0FBRyxLQUFLOUosU0FBTCxDQUFpQjhKLFlBQWhDLENBQ0QsQ0FFRDtBQUNBLEtBQUtILGNBQUwsQ0FBb0JycEIsS0FBcEIsR0FDQSxJQUFJLEdBQUkvRyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsS0FBSzR2QixLQUF4QixDQUErQixFQUFFNXZCLENBQWpDLENBQW9DLENBQ2xDLEtBQUtvd0IsY0FBTCxDQUFvQjNxQixRQUFwQixDQUE2QjZELEtBQUssQ0FBQ2hELFFBQU4sR0FBbUIsS0FBS3dwQixTQUFMLENBQWU5dkIsQ0FBZixDQUFoRCxFQUNELENBRUQsR0FBR3V3QixZQUFZLENBQUcsQ0FBbEIsQ0FBcUIsQ0FDbkI7QUFDQWpuQixLQUFLLENBQUNqRixJQUFOLEVBQWMsS0FBS29pQixTQUFuQixDQUNELENBSEQsSUFHTyxDQUNMO0FBQ0EsSUFBSSxHQUFJem1CLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEMsS0FBSzZ2QixRQUFMLENBQWM3dkIsQ0FBZCxFQUFtQixLQUFLOHZCLFNBQUwsQ0FBZTl2QixDQUFmLENBQW5CLENBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBRyxLQUFLcXdCLGFBQUwsQ0FBcUIsQ0FBeEIsQ0FBMkIsQ0FDekIsS0FBS0QsY0FBTCxDQUFvQnBxQixRQUFwQixDQUE2QixLQUFLcXFCLGFBQWxDLEVBQ0QsQ0FFRCxHQUFHRSxZQUFZLENBQUcsQ0FBZixFQUFvQixDQUFDcEwsTUFBeEIsQ0FBZ0MsQ0FDOUI1YSxNQUFNLENBQUN0RixRQUFQLENBQWdCLEtBQUttckIsY0FBTCxDQUFvQnBxQixRQUFwQixDQUNkdXFCLFlBQVksQ0FBRyxLQUFLRixhQUROLENBQWhCLEVBRUEsS0FBS0EsYUFBTCxDQUFxQkUsWUFBckIsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUVEaG1CLE1BQU0sQ0FBQ3RGLFFBQVAsQ0FBZ0IsS0FBS21yQixjQUFMLENBQW9CcHFCLFFBQXBCLENBQ2RzcUIsV0FBVyxDQUFHLEtBQUtELGFBREwsQ0FBaEIsRUFFQSxLQUFLQSxhQUFMLENBQXFCLENBQXJCLENBQ0QsQ0F6REQsQ0EyREFySixLQUFLLENBQUNJLEdBQU4sQ0FBVW5tQixTQUFWLENBQW9CN0IsT0FBcEIsQ0FBOEI0bkIsS0FBSyxDQUFDSSxHQUFOLENBQVVubUIsU0FBVixDQUFvQmdlLE9BQWxELENBRUEscUJBRUErSCxLQUFLLENBQUNLLEdBQU4sQ0FBWSxTQUFTbHlCLE9BQVQsQ0FBa0IsQ0FDNUJBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0EsS0FBS3FILElBQUwsQ0FBWSxLQUFaLENBQ0EsS0FBS21mLE1BQUwsQ0FBY3htQixPQUFPLENBQUN3bUIsTUFBdEIsQ0FDQSxLQUFLOEssU0FBTCxDQUFpQnR4QixPQUFPLENBQUNzeEIsU0FBUixFQUFxQixFQUF0QyxDQUNBLEtBQUttSixLQUFMLENBQWEsS0FBS25KLFNBQUwsQ0FBaUIsQ0FBOUIsQ0FDQSxLQUFLb0osUUFBTCxDQUFnQixJQUFoQixDQUNBLEtBQUtDLFNBQUwsQ0FBaUIsR0FBSTk1QixNQUFKLENBQVUsS0FBSzQ1QixLQUFmLENBQWpCLENBQ0EsS0FBS1EsY0FBTCxDQUFzQnh5QixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQXRCLENBQ0EsS0FBS2twQixhQUFMLENBQXFCLENBQXJCLENBQ0QsQ0FWRCxDQVlBckosS0FBSyxDQUFDSyxHQUFOLENBQVVwbUIsU0FBVixDQUFvQjBLLEtBQXBCLENBQTRCLFNBQVN4VyxPQUFULENBQWtCLENBQzVDLEdBQUcsRUFBRSxNQUFRQSxRQUFWLENBQUgsQ0FBdUIsQ0FDckIsS0FBTSxJQUFJUyxNQUFKLENBQVUsdUJBQVYsQ0FBTixDQUNELENBQ0Q7QUFDQSxLQUFLcTZCLEdBQUwsQ0FBV0MsV0FBVyxDQUFDLzZCLE9BQU8sQ0FBQzh3QixFQUFULENBQXRCLENBQ0EsS0FBSzRKLFFBQUwsQ0FBZ0IsS0FBS0ksR0FBTCxDQUFTenRCLEtBQVQsQ0FBZSxDQUFmLENBQWhCLENBQ0EsS0FBSzZ0QixhQUFMLENBQXFCLENBQXJCLENBQ0QsQ0FSRCxDQVVBckosS0FBSyxDQUFDSyxHQUFOLENBQVVwbUIsU0FBVixDQUFvQmdlLE9BQXBCLENBQThCLFNBQVMzVixLQUFULENBQWdCaUIsTUFBaEIsQ0FBd0I0YSxNQUF4QixDQUFnQyxDQUM1RDtBQUNBLEdBQUltTCxZQUFXLENBQUdobkIsS0FBSyxDQUFDeFQsTUFBTixFQUFsQixDQUNBLEdBQUd3NkIsV0FBVyxHQUFLLENBQW5CLENBQXNCLENBQ3BCLE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDQSxLQUFLM1UsTUFBTCxDQUFZc0QsT0FBWixDQUFvQixLQUFLNFEsUUFBekIsQ0FBbUMsS0FBS0MsU0FBeEMsRUFFQTtBQUNBLEdBQUcsS0FBS08sYUFBTCxHQUF1QixDQUF2QixFQUE0QkMsV0FBVyxFQUFJLEtBQUs3SixTQUFuRCxDQUE4RCxDQUM1RDtBQUNBLElBQUksR0FBSXptQixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsS0FBSzR2QixLQUF4QixDQUErQixFQUFFNXZCLENBQWpDLENBQW9DLENBQ2xDdUssTUFBTSxDQUFDOUUsUUFBUCxDQUFnQjZELEtBQUssQ0FBQ2hELFFBQU4sR0FBbUIsS0FBS3dwQixTQUFMLENBQWU5dkIsQ0FBZixDQUFuQyxFQUNELENBQ0YsQ0FMRCxJQUtPLENBQ0w7QUFDQSxHQUFJdXdCLGFBQVksQ0FBRyxDQUFDLEtBQUs5SixTQUFMLENBQWlCNkosV0FBbEIsRUFBaUMsS0FBSzdKLFNBQXpELENBQ0EsR0FBRzhKLFlBQVksQ0FBRyxDQUFsQixDQUFxQixDQUNuQkEsWUFBWSxDQUFHLEtBQUs5SixTQUFMLENBQWlCOEosWUFBaEMsQ0FDRCxDQUVEO0FBQ0EsS0FBS0gsY0FBTCxDQUFvQnJwQixLQUFwQixHQUNBLElBQUksR0FBSS9HLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEMsS0FBS293QixjQUFMLENBQW9CM3FCLFFBQXBCLENBQTZCNkQsS0FBSyxDQUFDaEQsUUFBTixHQUFtQixLQUFLd3BCLFNBQUwsQ0FBZTl2QixDQUFmLENBQWhELEVBQ0QsQ0FFRCxHQUFHdXdCLFlBQVksQ0FBRyxDQUFsQixDQUFxQixDQUNuQjtBQUNBam5CLEtBQUssQ0FBQ2pGLElBQU4sRUFBYyxLQUFLb2lCLFNBQW5CLENBQ0QsQ0FFRDtBQUNBLEdBQUcsS0FBSzRKLGFBQUwsQ0FBcUIsQ0FBeEIsQ0FBMkIsQ0FDekIsS0FBS0QsY0FBTCxDQUFvQnBxQixRQUFwQixDQUE2QixLQUFLcXFCLGFBQWxDLEVBQ0QsQ0FFRCxHQUFHRSxZQUFZLENBQUcsQ0FBZixFQUFvQixDQUFDcEwsTUFBeEIsQ0FBZ0MsQ0FDOUI1YSxNQUFNLENBQUN0RixRQUFQLENBQWdCLEtBQUttckIsY0FBTCxDQUFvQnBxQixRQUFwQixDQUNkdXFCLFlBQVksQ0FBRyxLQUFLRixhQUROLENBQWhCLEVBRUEsS0FBS0EsYUFBTCxDQUFxQkUsWUFBckIsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUVEaG1CLE1BQU0sQ0FBQ3RGLFFBQVAsQ0FBZ0IsS0FBS21yQixjQUFMLENBQW9CcHFCLFFBQXBCLENBQ2RzcUIsV0FBVyxDQUFHLEtBQUtELGFBREwsQ0FBaEIsRUFFQSxLQUFLQSxhQUFMLENBQXFCLENBQXJCLENBQ0QsQ0FFRDtBQUNBRyxLQUFLLENBQUMsS0FBS1gsUUFBTixDQUFMLENBQ0QsQ0FyREQsQ0F1REE3SSxLQUFLLENBQUNLLEdBQU4sQ0FBVXBtQixTQUFWLENBQW9CN0IsT0FBcEIsQ0FBOEI0bkIsS0FBSyxDQUFDSyxHQUFOLENBQVVwbUIsU0FBVixDQUFvQmdlLE9BQWxELENBRUEsaUNBRUErSCxLQUFLLENBQUNNLEdBQU4sQ0FBWSxTQUFTbnlCLE9BQVQsQ0FBa0IsQ0FDNUJBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0EsS0FBS3FILElBQUwsQ0FBWSxLQUFaLENBQ0EsS0FBS21mLE1BQUwsQ0FBY3htQixPQUFPLENBQUN3bUIsTUFBdEIsQ0FDQSxLQUFLOEssU0FBTCxDQUFpQnR4QixPQUFPLENBQUNzeEIsU0FBUixFQUFxQixFQUF0QyxDQUNBLEtBQUttSixLQUFMLENBQWEsS0FBS25KLFNBQUwsQ0FBaUIsQ0FBOUIsQ0FDQSxLQUFLb0osUUFBTCxDQUFnQixHQUFJNzVCLE1BQUosQ0FBVSxLQUFLNDVCLEtBQWYsQ0FBaEIsQ0FDQSxLQUFLRSxTQUFMLENBQWlCLEdBQUk5NUIsTUFBSixDQUFVLEtBQUs0NUIsS0FBZixDQUFqQixDQUNBLEtBQUtRLGNBQUwsQ0FBc0J4eUIsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUF0QixDQUNBLEtBQUtrcEIsYUFBTCxDQUFxQixDQUFyQixDQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUtJLEVBQUwsQ0FBVSxVQUFWLENBQ0QsQ0FmRCxDQWlCQXpKLEtBQUssQ0FBQ00sR0FBTixDQUFVcm1CLFNBQVYsQ0FBb0IwSyxLQUFwQixDQUE0QixTQUFTeFcsT0FBVCxDQUFrQixDQUM1QyxHQUFHLEVBQUUsTUFBUUEsUUFBVixDQUFILENBQXVCLENBQ3JCLEtBQU0sSUFBSVMsTUFBSixDQUFVLHVCQUFWLENBQU4sQ0FDRCxDQUNEO0FBQ0EsR0FBSXF3QixHQUFFLENBQUdyb0IsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QmhTLE9BQU8sQ0FBQzh3QixFQUFoQyxDQUFULENBRUE7QUFDQSxLQUFLeUssYUFBTCxDQUFxQixDQUFyQixDQUVBO0FBQ0EsR0FBSUMsZUFBSixDQUNBLEdBQUcsa0JBQW9CeDdCLFFBQXZCLENBQWdDLENBQzlCdzdCLGNBQWMsQ0FBRy95QixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCaFMsT0FBTyxDQUFDdzdCLGNBQWhDLENBQWpCLENBQ0QsQ0FGRCxJQUVPLENBQ0xBLGNBQWMsQ0FBRy95QixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQWpCLENBQ0QsQ0FFRDtBQUNBLEdBQUcsYUFBZWhTLFFBQWxCLENBQTJCLENBQ3pCLEtBQUt5N0IsVUFBTCxDQUFrQno3QixPQUFPLENBQUMwN0IsU0FBMUIsQ0FDRCxDQUZELElBRU8sQ0FDTCxLQUFLRCxVQUFMLENBQWtCLEdBQWxCLENBQ0QsQ0FFRDtBQUNBLEtBQUtFLElBQUwsQ0FBWSxJQUFaLENBQ0EsR0FBRzM3QixPQUFPLENBQUNpSyxPQUFYLENBQW9CLENBQ2xCO0FBQ0EsS0FBSzB4QixJQUFMLENBQVlsekIsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QmhTLE9BQU8sQ0FBQzQ3QixHQUFoQyxFQUFxQy9xQixRQUFyQyxFQUFaLENBQ0EsR0FBRyxLQUFLOHFCLElBQUwsQ0FBVWg3QixNQUFWLEdBQXNCLEtBQUs4NkIsVUFBTCxDQUFrQixDQUEzQyxDQUErQyxDQUM3QyxLQUFNLElBQUloN0IsTUFBSixDQUFVLCtDQUFWLENBQU4sQ0FDRCxDQUNGLENBRUQ7QUFDQSxLQUFLbzdCLFVBQUwsQ0FBa0IsR0FBSWg3QixNQUFKLENBQVUsS0FBSzQ1QixLQUFmLENBQWxCLENBRUE7QUFDQSxLQUFLbUIsR0FBTCxDQUFXLElBQVgsQ0FFQTtBQUNBO0FBQ0EsS0FBS0UsV0FBTCxDQUFtQixHQUFJajdCLE1BQUosQ0FBVSxLQUFLNDVCLEtBQWYsQ0FBbkIsQ0FDQSxLQUFLalUsTUFBTCxDQUFZc0QsT0FBWixDQUFvQixDQUFDLENBQUQsQ0FBSSxDQUFKLENBQU8sQ0FBUCxDQUFVLENBQVYsQ0FBcEIsQ0FBa0MsS0FBS2dTLFdBQXZDLEVBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLQyxhQUFMLENBQXFCLENBQXJCLENBQ0EsS0FBS0MsRUFBTCxDQUFVLEtBQUtDLGlCQUFMLENBQXVCLEtBQUtILFdBQTVCLENBQXlDLEtBQUtDLGFBQTlDLENBQVYsQ0FFQTtBQUNBO0FBQ0E7QUFDQSxHQUFJRyxTQUFRLENBQUdwTCxFQUFFLENBQUNud0IsTUFBSCxFQUFmLENBQ0EsR0FBR3U3QixRQUFRLEdBQUssRUFBaEIsQ0FBb0IsQ0FDbEI7QUFDQSxLQUFLQyxHQUFMLENBQVcsQ0FBQ3JMLEVBQUUsQ0FBQzNmLFFBQUgsRUFBRCxDQUFnQjJmLEVBQUUsQ0FBQzNmLFFBQUgsRUFBaEIsQ0FBK0IyZixFQUFFLENBQUMzZixRQUFILEVBQS9CLENBQThDLENBQTlDLENBQVgsQ0FDRCxDQUhELElBR08sQ0FDTDtBQUNBLEtBQUtnckIsR0FBTCxDQUFXLENBQUMsQ0FBRCxDQUFJLENBQUosQ0FBTyxDQUFQLENBQVUsQ0FBVixDQUFYLENBQ0EsTUFBTXJMLEVBQUUsQ0FBQ253QixNQUFILEdBQWMsQ0FBcEIsQ0FBdUIsQ0FDckIsS0FBS3c3QixHQUFMLENBQVcsS0FBS0MsS0FBTCxDQUNULEtBQUtOLFdBREksQ0FDUyxLQUFLSyxHQURkLENBRVQsQ0FBQ3JMLEVBQUUsQ0FBQzNmLFFBQUgsRUFBRCxDQUFnQjJmLEVBQUUsQ0FBQzNmLFFBQUgsRUFBaEIsQ0FBK0IyZixFQUFFLENBQUMzZixRQUFILEVBQS9CLENBQThDMmYsRUFBRSxDQUFDM2YsUUFBSCxFQUE5QyxDQUZTLENBQVgsQ0FHRCxDQUNELEtBQUtnckIsR0FBTCxDQUFXLEtBQUtDLEtBQUwsQ0FDVCxLQUFLTixXQURJLENBQ1MsS0FBS0ssR0FEZCxDQUNtQixDQUFDLENBQUQsQ0FBSSxDQUFKLEVBQU9FLE1BQVAsQ0FBY0MsVUFBVSxDQUFDSixRQUFRLENBQUcsQ0FBWixDQUF4QixDQURuQixDQUFYLENBRUQsQ0FFRDtBQUNBLEtBQUt4QixRQUFMLENBQWdCLEtBQUt5QixHQUFMLENBQVM5dUIsS0FBVCxDQUFlLENBQWYsQ0FBaEIsQ0FDQWd1QixLQUFLLENBQUMsS0FBS1gsUUFBTixDQUFMLENBQ0EsS0FBS1EsYUFBTCxDQUFxQixDQUFyQixDQUVBO0FBQ0FNLGNBQWMsQ0FBRy95QixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCd3BCLGNBQXhCLENBQWpCLENBQ0E7QUFDQSxLQUFLZSxZQUFMLENBQW9CRCxVQUFVLENBQUNkLGNBQWMsQ0FBQzc2QixNQUFmLEdBQTBCLENBQTNCLENBQTlCLENBQ0E7QUFDQSxHQUFJNDVCLFNBQVEsQ0FBR2lCLGNBQWMsQ0FBQzc2QixNQUFmLEdBQTBCLEtBQUsyd0IsU0FBOUMsQ0FDQSxHQUFHaUosUUFBSCxDQUFhLENBQ1hpQixjQUFjLENBQUN6ckIsWUFBZixDQUE0QixDQUE1QixDQUErQixLQUFLdWhCLFNBQUwsQ0FBaUJpSixRQUFoRCxFQUNELENBQ0QsS0FBS2lDLEVBQUwsQ0FBVSxDQUFDLENBQUQsQ0FBSSxDQUFKLENBQU8sQ0FBUCxDQUFVLENBQVYsQ0FBVixDQUNBLE1BQU1oQixjQUFjLENBQUM3NkIsTUFBZixHQUEwQixDQUFoQyxDQUFtQyxDQUNqQyxLQUFLNjdCLEVBQUwsQ0FBVSxLQUFLSixLQUFMLENBQVcsS0FBS04sV0FBaEIsQ0FBNkIsS0FBS1UsRUFBbEMsQ0FBc0MsQ0FDOUNoQixjQUFjLENBQUNycUIsUUFBZixFQUQ4QyxDQUU5Q3FxQixjQUFjLENBQUNycUIsUUFBZixFQUY4QyxDQUc5Q3FxQixjQUFjLENBQUNycUIsUUFBZixFQUg4QyxDQUk5Q3FxQixjQUFjLENBQUNycUIsUUFBZixFQUo4QyxDQUF0QyxDQUFWLENBTUQsQ0FDRixDQS9GRCxDQWlHQTBnQixLQUFLLENBQUNNLEdBQU4sQ0FBVXJtQixTQUFWLENBQW9CZ2UsT0FBcEIsQ0FBOEIsU0FBUzNWLEtBQVQsQ0FBZ0JpQixNQUFoQixDQUF3QjRhLE1BQXhCLENBQWdDLENBQzVEO0FBQ0EsR0FBSW1MLFlBQVcsQ0FBR2huQixLQUFLLENBQUN4VCxNQUFOLEVBQWxCLENBQ0EsR0FBR3c2QixXQUFXLEdBQUssQ0FBbkIsQ0FBc0IsQ0FDcEIsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBLEtBQUszVSxNQUFMLENBQVlzRCxPQUFaLENBQW9CLEtBQUs0USxRQUF6QixDQUFtQyxLQUFLQyxTQUF4QyxFQUVBO0FBQ0EsR0FBRyxLQUFLTyxhQUFMLEdBQXVCLENBQXZCLEVBQTRCQyxXQUFXLEVBQUksS0FBSzdKLFNBQW5ELENBQThELENBQzVEO0FBQ0EsSUFBSSxHQUFJem1CLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEN1SyxNQUFNLENBQUM5RSxRQUFQLENBQWdCLEtBQUtxcUIsU0FBTCxDQUFlOXZCLENBQWYsR0FBcUJzSixLQUFLLENBQUNoRCxRQUFOLEVBQXJDLEVBQ0QsQ0FDRCxLQUFLb3FCLGFBQUwsRUFBc0IsS0FBS2pLLFNBQTNCLENBQ0QsQ0FORCxJQU1PLENBQ0w7QUFDQSxHQUFJOEosYUFBWSxDQUFHLENBQUMsS0FBSzlKLFNBQUwsQ0FBaUI2SixXQUFsQixFQUFpQyxLQUFLN0osU0FBekQsQ0FDQSxHQUFHOEosWUFBWSxDQUFHLENBQWxCLENBQXFCLENBQ25CQSxZQUFZLENBQUcsS0FBSzlKLFNBQUwsQ0FBaUI4SixZQUFoQyxDQUNELENBRUQ7QUFDQSxLQUFLSCxjQUFMLENBQW9CcnBCLEtBQXBCLEdBQ0EsSUFBSSxHQUFJL0csRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLEtBQUs0dkIsS0FBeEIsQ0FBK0IsRUFBRTV2QixDQUFqQyxDQUFvQyxDQUNsQyxLQUFLb3dCLGNBQUwsQ0FBb0IzcUIsUUFBcEIsQ0FBNkI2RCxLQUFLLENBQUNoRCxRQUFOLEdBQW1CLEtBQUt3cEIsU0FBTCxDQUFlOXZCLENBQWYsQ0FBaEQsRUFDRCxDQUVELEdBQUd1d0IsWUFBWSxHQUFLLENBQWpCLEVBQXNCcEwsTUFBekIsQ0FBaUMsQ0FDL0I7QUFDQSxHQUFHQSxNQUFILENBQVcsQ0FDVDtBQUNBLEdBQUl1SyxTQUFRLENBQUdZLFdBQVcsQ0FBRyxLQUFLN0osU0FBbEMsQ0FDQSxLQUFLaUssYUFBTCxFQUFzQmhCLFFBQXRCLENBQ0E7QUFDQSxLQUFLVSxjQUFMLENBQW9CL29CLFFBQXBCLENBQTZCLEtBQUtvZixTQUFMLENBQWlCaUosUUFBOUMsRUFDRCxDQU5ELElBTU8sQ0FDTCxLQUFLZ0IsYUFBTCxFQUFzQixLQUFLakssU0FBM0IsQ0FDRCxDQUVEO0FBQ0EsSUFBSSxHQUFJem1CLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEMsS0FBSzh2QixTQUFMLENBQWU5dkIsQ0FBZixFQUFvQixLQUFLb3dCLGNBQUwsQ0FBb0I5cEIsUUFBcEIsRUFBcEIsQ0FDRCxDQUNELEtBQUs4cEIsY0FBTCxDQUFvQi9yQixJQUFwQixFQUE0QixLQUFLb2lCLFNBQWpDLENBQ0QsQ0FFRDtBQUNBLEdBQUcsS0FBSzRKLGFBQUwsQ0FBcUIsQ0FBeEIsQ0FBMkIsQ0FDekIsS0FBS0QsY0FBTCxDQUFvQnBxQixRQUFwQixDQUE2QixLQUFLcXFCLGFBQWxDLEVBQ0QsQ0FFRCxHQUFHRSxZQUFZLENBQUcsQ0FBZixFQUFvQixDQUFDcEwsTUFBeEIsQ0FBZ0MsQ0FDOUI7QUFDQTtBQUNBN2IsS0FBSyxDQUFDakYsSUFBTixFQUFjLEtBQUtvaUIsU0FBbkIsQ0FDQWxjLE1BQU0sQ0FBQ3RGLFFBQVAsQ0FBZ0IsS0FBS21yQixjQUFMLENBQW9CcHFCLFFBQXBCLENBQ2R1cUIsWUFBWSxDQUFHLEtBQUtGLGFBRE4sQ0FBaEIsRUFFQSxLQUFLQSxhQUFMLENBQXFCRSxZQUFyQixDQUNBLE1BQU8sS0FBUCxDQUNELENBRURobUIsTUFBTSxDQUFDdEYsUUFBUCxDQUFnQixLQUFLbXJCLGNBQUwsQ0FBb0JwcUIsUUFBcEIsQ0FDZHNxQixXQUFXLENBQUcsS0FBS0QsYUFETCxDQUFoQixFQUVBLEtBQUtBLGFBQUwsQ0FBcUIsQ0FBckIsQ0FDRCxDQUVEO0FBQ0EsS0FBS3NCLEVBQUwsQ0FBVSxLQUFLSixLQUFMLENBQVcsS0FBS04sV0FBaEIsQ0FBNkIsS0FBS1UsRUFBbEMsQ0FBc0MsS0FBSzdCLFNBQTNDLENBQVYsQ0FFQTtBQUNBVSxLQUFLLENBQUMsS0FBS1gsUUFBTixDQUFMLENBQ0QsQ0ExRUQsQ0E0RUE3SSxLQUFLLENBQUNNLEdBQU4sQ0FBVXJtQixTQUFWLENBQW9CN0IsT0FBcEIsQ0FBOEIsU0FBU2tLLEtBQVQsQ0FBZ0JpQixNQUFoQixDQUF3QjRhLE1BQXhCLENBQWdDLENBQzVEO0FBQ0EsR0FBSW1MLFlBQVcsQ0FBR2huQixLQUFLLENBQUN4VCxNQUFOLEVBQWxCLENBQ0EsR0FBR3c2QixXQUFXLENBQUcsS0FBSzdKLFNBQW5CLEVBQWdDLEVBQUV0QixNQUFNLEVBQUltTCxXQUFXLENBQUcsQ0FBMUIsQ0FBbkMsQ0FBaUUsQ0FDL0QsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBLEtBQUszVSxNQUFMLENBQVlzRCxPQUFaLENBQW9CLEtBQUs0USxRQUF6QixDQUFtQyxLQUFLQyxTQUF4QyxFQUVBO0FBQ0FVLEtBQUssQ0FBQyxLQUFLWCxRQUFOLENBQUwsQ0FFQTtBQUNBLEtBQUttQixVQUFMLENBQWdCLENBQWhCLEVBQXFCMW5CLEtBQUssQ0FBQ2hELFFBQU4sRUFBckIsQ0FDQSxLQUFLMHFCLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBcUIxbkIsS0FBSyxDQUFDaEQsUUFBTixFQUFyQixDQUNBLEtBQUswcUIsVUFBTCxDQUFnQixDQUFoQixFQUFxQjFuQixLQUFLLENBQUNoRCxRQUFOLEVBQXJCLENBQ0EsS0FBSzBxQixVQUFMLENBQWdCLENBQWhCLEVBQXFCMW5CLEtBQUssQ0FBQ2hELFFBQU4sRUFBckIsQ0FDQSxLQUFLcXJCLEVBQUwsQ0FBVSxLQUFLSixLQUFMLENBQVcsS0FBS04sV0FBaEIsQ0FBNkIsS0FBS1UsRUFBbEMsQ0FBc0MsS0FBS1gsVUFBM0MsQ0FBVixDQUVBO0FBQ0EsSUFBSSxHQUFJaHhCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNHZCLEtBQXhCLENBQStCLEVBQUU1dkIsQ0FBakMsQ0FBb0MsQ0FDbEN1SyxNQUFNLENBQUM5RSxRQUFQLENBQWdCLEtBQUtxcUIsU0FBTCxDQUFlOXZCLENBQWYsRUFBb0IsS0FBS2d4QixVQUFMLENBQWdCaHhCLENBQWhCLENBQXBDLEVBQ0QsQ0FFRDtBQUNBLEdBQUdzd0IsV0FBVyxDQUFHLEtBQUs3SixTQUF0QixDQUFpQyxDQUMvQixLQUFLaUssYUFBTCxFQUFzQkosV0FBVyxDQUFHLEtBQUs3SixTQUF6QyxDQUNELENBRkQsSUFFTyxDQUNMLEtBQUtpSyxhQUFMLEVBQXNCLEtBQUtqSyxTQUEzQixDQUNELENBQ0YsQ0EvQkQsQ0FpQ0FPLEtBQUssQ0FBQ00sR0FBTixDQUFVcm1CLFNBQVYsQ0FBb0IwdUIsV0FBcEIsQ0FBa0MsU0FBU3BsQixNQUFULENBQWlCcFYsT0FBakIsQ0FBMEIsQ0FDMUQsR0FBSWlSLEtBQUksQ0FBRyxJQUFYLENBRUE7QUFDQSxHQUFHalIsT0FBTyxDQUFDaUssT0FBUixFQUFtQmpLLE9BQU8sQ0FBQ3U2QixRQUE5QixDQUF3QyxDQUN0Q25sQixNQUFNLENBQUNsRCxRQUFQLENBQWdCLEtBQUtvZixTQUFMLENBQWlCdHhCLE9BQU8sQ0FBQ3U2QixRQUF6QyxFQUNELENBRUQ7QUFDQSxLQUFLcUIsR0FBTCxDQUFXbnpCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBWCxDQUVBO0FBQ0EsR0FBSXlxQixRQUFPLENBQUcsS0FBS0YsWUFBTCxDQUFrQkYsTUFBbEIsQ0FBeUJDLFVBQVUsQ0FBQyxLQUFLZixhQUFMLENBQXFCLENBQXRCLENBQW5DLENBQWQsQ0FFQTtBQUNBLEtBQUtpQixFQUFMLENBQVUsS0FBS0osS0FBTCxDQUFXLEtBQUtOLFdBQWhCLENBQTZCLEtBQUtVLEVBQWxDLENBQXNDQyxPQUF0QyxDQUFWLENBRUE7QUFDQSxHQUFJYixJQUFHLENBQUcsRUFBVixDQUNBLEtBQUtwVixNQUFMLENBQVlzRCxPQUFaLENBQW9CLEtBQUtxUyxHQUF6QixDQUE4QlAsR0FBOUIsRUFDQSxJQUFJLEdBQUkvd0IsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLEtBQUs0dkIsS0FBeEIsQ0FBK0IsRUFBRTV2QixDQUFqQyxDQUFvQyxDQUNsQyxLQUFLK3dCLEdBQUwsQ0FBU3RyQixRQUFULENBQWtCLEtBQUtrc0IsRUFBTCxDQUFRM3hCLENBQVIsRUFBYSt3QixHQUFHLENBQUMvd0IsQ0FBRCxDQUFsQyxFQUNELENBRUQ7QUFDQSxLQUFLK3dCLEdBQUwsQ0FBUzFwQixRQUFULENBQWtCLEtBQUswcEIsR0FBTCxDQUFTajdCLE1BQVQsSUFBcUIsS0FBSzg2QixVQUFMLENBQWtCLENBQXZDLENBQWxCLEVBRUE7QUFDQSxHQUFHejdCLE9BQU8sQ0FBQ2lLLE9BQVIsRUFBbUIsS0FBSzJ4QixHQUFMLENBQVM1ckIsS0FBVCxLQUFxQixLQUFLMnJCLElBQWhELENBQXNELENBQ3BEMXFCLElBQUksQ0FBRyxLQUFQLENBQ0QsQ0FFRCxNQUFPQSxLQUFQLENBQ0QsQ0FqQ0QsQ0FtQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCQTRnQixLQUFLLENBQUNNLEdBQU4sQ0FBVXJtQixTQUFWLENBQW9CMmQsUUFBcEIsQ0FBK0IsU0FBU2piLENBQVQsQ0FBWXFiLENBQVosQ0FBZSxDQUM1QyxHQUFJNlMsSUFBRyxDQUFHLENBQUMsQ0FBRCxDQUFJLENBQUosQ0FBTyxDQUFQLENBQVUsQ0FBVixDQUFWLENBQ0EsR0FBSUMsSUFBRyxDQUFHOVMsQ0FBQyxDQUFDeGMsS0FBRixDQUFRLENBQVIsQ0FBVixDQUVBO0FBQ0EsSUFBSSxHQUFJeEMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLEdBQW5CLENBQXdCLEVBQUVBLENBQTFCLENBQTZCLENBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUkreEIsSUFBRyxDQUFHcHVCLENBQUMsQ0FBRTNELENBQUMsQ0FBRyxFQUFMLENBQVcsQ0FBWixDQUFELENBQW1CLEdBQU0sR0FBS0EsQ0FBQyxDQUFHLEVBQTVDLENBQ0EsR0FBRyt4QixHQUFILENBQVEsQ0FDTkYsR0FBRyxDQUFDLENBQUQsQ0FBSCxFQUFVQyxHQUFHLENBQUMsQ0FBRCxDQUFiLENBQ0FELEdBQUcsQ0FBQyxDQUFELENBQUgsRUFBVUMsR0FBRyxDQUFDLENBQUQsQ0FBYixDQUNBRCxHQUFHLENBQUMsQ0FBRCxDQUFILEVBQVVDLEdBQUcsQ0FBQyxDQUFELENBQWIsQ0FDQUQsR0FBRyxDQUFDLENBQUQsQ0FBSCxFQUFVQyxHQUFHLENBQUMsQ0FBRCxDQUFiLENBQ0QsQ0FFRDtBQUNBO0FBQ0EsS0FBS0UsR0FBTCxDQUFTRixHQUFULENBQWNBLEdBQWQsRUFDRCxDQUVELE1BQU9ELElBQVAsQ0FDRCxDQXZCRCxDQXlCQTdLLEtBQUssQ0FBQ00sR0FBTixDQUFVcm1CLFNBQVYsQ0FBb0Ird0IsR0FBcEIsQ0FBMEIsU0FBU3J1QixDQUFULENBQVk0SCxHQUFaLENBQWlCLENBQ3pDO0FBQ0E7QUFDQSxHQUFJMG1CLElBQUcsQ0FBR3R1QixDQUFDLENBQUMsQ0FBRCxDQUFELENBQU8sQ0FBakIsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksR0FBSTNELEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxDQUFuQixDQUFzQixFQUFFQSxDQUF4QixDQUEyQixDQUN6QnVMLEdBQUcsQ0FBQ3ZMLENBQUQsQ0FBSCxDQUFVMkQsQ0FBQyxDQUFDM0QsQ0FBRCxDQUFELEdBQVMsQ0FBVixDQUFnQixDQUFDMkQsQ0FBQyxDQUFDM0QsQ0FBQyxDQUFHLENBQUwsQ0FBRCxDQUFXLENBQVosR0FBa0IsRUFBM0MsQ0FDRCxDQUNEO0FBQ0F1TCxHQUFHLENBQUMsQ0FBRCxDQUFILENBQVM1SCxDQUFDLENBQUMsQ0FBRCxDQUFELEdBQVMsQ0FBbEIsQ0FFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHc3VCLEdBQUgsQ0FBUSxDQUNOMW1CLEdBQUcsQ0FBQyxDQUFELENBQUgsRUFBVSxLQUFLa2xCLEVBQWYsQ0FDRCxDQUNGLENBckJELENBdUJBekosS0FBSyxDQUFDTSxHQUFOLENBQVVybUIsU0FBVixDQUFvQml4QixhQUFwQixDQUFvQyxTQUFTdnVCLENBQVQsQ0FBWSxDQUM5QztBQUNBLEdBQUl3dUIsRUFBQyxDQUFHLENBQUMsQ0FBRCxDQUFJLENBQUosQ0FBTyxDQUFQLENBQVUsQ0FBVixDQUFSLENBQ0EsSUFBSSxHQUFJbnlCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxFQUFuQixDQUF1QixFQUFFQSxDQUF6QixDQUE0QixDQUMxQixHQUFJOE0sSUFBRyxDQUFJOU0sQ0FBQyxDQUFHLENBQUwsQ0FBVSxDQUFwQixDQUNBLEdBQUkreEIsSUFBRyxDQUFJcHVCLENBQUMsQ0FBQ21KLEdBQUQsQ0FBRCxHQUFZLENBQUMsRUFBSzlNLENBQUMsQ0FBRyxDQUFWLEVBQWdCLENBQTdCLENBQW1DLEdBQTdDLENBQ0EsR0FBSW95QixHQUFFLENBQUcsS0FBS2pCLEVBQUwsQ0FBUW54QixDQUFSLEVBQVcreEIsR0FBWCxDQUFULENBQ0FJLENBQUMsQ0FBQyxDQUFELENBQUQsRUFBUUMsRUFBRSxDQUFDLENBQUQsQ0FBVixDQUNBRCxDQUFDLENBQUMsQ0FBRCxDQUFELEVBQVFDLEVBQUUsQ0FBQyxDQUFELENBQVYsQ0FDQUQsQ0FBQyxDQUFDLENBQUQsQ0FBRCxFQUFRQyxFQUFFLENBQUMsQ0FBRCxDQUFWLENBQ0FELENBQUMsQ0FBQyxDQUFELENBQUQsRUFBUUMsRUFBRSxDQUFDLENBQUQsQ0FBVixDQUNELENBQ0QsTUFBT0QsRUFBUCxDQUNELENBYkQsQ0FlQTs7Ozs7Ozs7OztHQVdBbkwsS0FBSyxDQUFDTSxHQUFOLENBQVVybUIsU0FBVixDQUFvQnN3QixLQUFwQixDQUE0QixTQUFTYyxDQUFULENBQVlyVCxDQUFaLENBQWVyYixDQUFmLENBQWtCLENBQzVDcWIsQ0FBQyxDQUFDLENBQUQsQ0FBRCxFQUFRcmIsQ0FBQyxDQUFDLENBQUQsQ0FBVCxDQUNBcWIsQ0FBQyxDQUFDLENBQUQsQ0FBRCxFQUFRcmIsQ0FBQyxDQUFDLENBQUQsQ0FBVCxDQUNBcWIsQ0FBQyxDQUFDLENBQUQsQ0FBRCxFQUFRcmIsQ0FBQyxDQUFDLENBQUQsQ0FBVCxDQUNBcWIsQ0FBQyxDQUFDLENBQUQsQ0FBRCxFQUFRcmIsQ0FBQyxDQUFDLENBQUQsQ0FBVCxDQUNBLE1BQU8sTUFBS3V1QixhQUFMLENBQW1CbFQsQ0FBbkIsQ0FBUCxDQUNBO0FBQ0QsQ0FQRCxDQVNBOzs7Ozs7Ozs7Ozs7OztHQWVBZ0ksS0FBSyxDQUFDTSxHQUFOLENBQVVybUIsU0FBVixDQUFvQm13QixpQkFBcEIsQ0FBd0MsU0FBU2lCLENBQVQsQ0FBWXpTLElBQVosQ0FBa0IsQ0FDeEQ7QUFDQTtBQUNBO0FBQ0EsR0FBSTBTLFdBQVUsQ0FBRyxFQUFJMVMsSUFBckIsQ0FDQSxHQUFJMlMsT0FBTSxDQUFHLEVBQUlELFVBQWpCLENBQ0EsR0FBSTM3QixLQUFJLENBQUcsR0FBSzI3QixVQUFoQixDQUNBLEdBQUlueUIsRUFBQyxDQUFHLEdBQUluSyxNQUFKLENBQVVXLElBQVYsQ0FBUixDQUNBLElBQUksR0FBSXFKLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3JKLElBQW5CLENBQXlCLEVBQUVxSixDQUEzQixDQUE4QixDQUM1QixHQUFJb1YsSUFBRyxDQUFHLENBQUMsQ0FBRCxDQUFJLENBQUosQ0FBTyxDQUFQLENBQVUsQ0FBVixDQUFWLENBQ0EsR0FBSXRJLElBQUcsQ0FBSTlNLENBQUMsQ0FBR3V5QixNQUFMLENBQWUsQ0FBekIsQ0FDQSxHQUFJQyxLQUFJLENBQUksQ0FBQ0QsTUFBTSxDQUFHLENBQVQsQ0FBY3Z5QixDQUFDLENBQUd1eUIsTUFBbkIsRUFBOEIzUyxJQUExQyxDQUNBeEssR0FBRyxDQUFDdEksR0FBRCxDQUFILENBQVksR0FBTThTLElBQUksQ0FBRyxDQUFkLEVBQXFCNFMsSUFBaEMsQ0FDQXJ5QixDQUFDLENBQUNILENBQUQsQ0FBRCxDQUFPLEtBQUt5eUIsb0JBQUwsQ0FBMEIsS0FBSzdULFFBQUwsQ0FBY3hKLEdBQWQsQ0FBbUJpZCxDQUFuQixDQUExQixDQUFpRHpTLElBQWpELENBQVAsQ0FDRCxDQUNELE1BQU96ZixFQUFQLENBQ0QsQ0FoQkQsQ0FrQkE7Ozs7OztHQU9BNm1CLEtBQUssQ0FBQ00sR0FBTixDQUFVcm1CLFNBQVYsQ0FBb0J3eEIsb0JBQXBCLENBQTJDLFNBQVNDLEdBQVQsQ0FBYzlTLElBQWQsQ0FBb0IsQ0FDN0Q7QUFDQTtBQUNBO0FBQ0EsR0FBSWpwQixLQUFJLENBQUcsR0FBS2lwQixJQUFoQixDQUNBLEdBQUkrUyxLQUFJLENBQUdoOEIsSUFBSSxHQUFLLENBQXBCLENBQ0EsR0FBSXdKLEVBQUMsQ0FBRyxHQUFJbkssTUFBSixDQUFVVyxJQUFWLENBQVIsQ0FDQXdKLENBQUMsQ0FBQ3d5QixJQUFELENBQUQsQ0FBVUQsR0FBRyxDQUFDbHdCLEtBQUosQ0FBVSxDQUFWLENBQVYsQ0FDQSxHQUFJeEMsRUFBQyxDQUFHMnlCLElBQUksR0FBSyxDQUFqQixDQUNBLE1BQU0zeUIsQ0FBQyxDQUFHLENBQVYsQ0FBYSxDQUNYO0FBQ0EsS0FBS2d5QixHQUFMLENBQVM3eEIsQ0FBQyxDQUFDLEVBQUlILENBQUwsQ0FBVixDQUFtQkcsQ0FBQyxDQUFDSCxDQUFELENBQUQsQ0FBTyxFQUExQixFQUNBQSxDQUFDLEdBQUssQ0FBTixDQUNELENBQ0RBLENBQUMsQ0FBRyxDQUFKLENBQ0EsTUFBTUEsQ0FBQyxDQUFHMnlCLElBQVYsQ0FBZ0IsQ0FDZCxJQUFJLEdBQUlubkIsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHeEwsQ0FBbkIsQ0FBc0IsRUFBRXdMLENBQXhCLENBQTJCLENBQ3pCLEdBQUlvbkIsSUFBRyxDQUFHenlCLENBQUMsQ0FBQ0gsQ0FBRCxDQUFYLENBQ0EsR0FBSTZ5QixJQUFHLENBQUcxeUIsQ0FBQyxDQUFDcUwsQ0FBRCxDQUFYLENBQ0FyTCxDQUFDLENBQUNILENBQUMsQ0FBR3dMLENBQUwsQ0FBRCxDQUFXLENBQ1RvbkIsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFTQyxHQUFHLENBQUMsQ0FBRCxDQURILENBRVRELEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBU0MsR0FBRyxDQUFDLENBQUQsQ0FGSCxDQUdURCxHQUFHLENBQUMsQ0FBRCxDQUFILENBQVNDLEdBQUcsQ0FBQyxDQUFELENBSEgsQ0FJVEQsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFTQyxHQUFHLENBQUMsQ0FBRCxDQUpILENBQVgsQ0FNRCxDQUNEN3lCLENBQUMsRUFBSSxDQUFMLENBQ0QsQ0FDREcsQ0FBQyxDQUFDLENBQUQsQ0FBRCxDQUFPLENBQUMsQ0FBRCxDQUFJLENBQUosQ0FBTyxDQUFQLENBQVUsQ0FBVixDQUFQLENBQ0E7Z0VBRUEsSUFBSUgsQ0FBQyxDQUFHMnlCLElBQUksQ0FBRyxDQUFmLENBQWtCM3lCLENBQUMsQ0FBR3JKLElBQXRCLENBQTRCLEVBQUVxSixDQUE5QixDQUFpQyxDQUMvQixHQUFJSSxFQUFDLENBQUdELENBQUMsQ0FBQ0gsQ0FBQyxDQUFHMnlCLElBQUwsQ0FBVCxDQUNBeHlCLENBQUMsQ0FBQ0gsQ0FBRCxDQUFELENBQU8sQ0FBQzB5QixHQUFHLENBQUMsQ0FBRCxDQUFILENBQVN0eUIsQ0FBQyxDQUFDLENBQUQsQ0FBWCxDQUFnQnN5QixHQUFHLENBQUMsQ0FBRCxDQUFILENBQVN0eUIsQ0FBQyxDQUFDLENBQUQsQ0FBMUIsQ0FBK0JzeUIsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFTdHlCLENBQUMsQ0FBQyxDQUFELENBQXpDLENBQThDc3lCLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBU3R5QixDQUFDLENBQUMsQ0FBRCxDQUF4RCxDQUFQLENBQ0QsQ0FDRCxNQUFPRCxFQUFQLENBQ0QsQ0FwQ0QsQ0FzQ0Esd0JBRUEsUUFBUyt2QixZQUFULENBQXFCakssRUFBckIsQ0FBeUIsQ0FDdkIsR0FBRyxNQUFPQSxHQUFQLEdBQWMsUUFBakIsQ0FBMkIsQ0FDekI7QUFDQUEsRUFBRSxDQUFHcm9CLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0I4ZSxFQUF4QixDQUFMLENBQ0QsQ0FFRCxHQUFHcm9CLEtBQUssQ0FBQzJELElBQU4sQ0FBV21DLE9BQVgsQ0FBbUJ1aUIsRUFBbkIsR0FBMEJBLEVBQUUsQ0FBQ253QixNQUFILENBQVksQ0FBekMsQ0FBNEMsQ0FDMUM7QUFDQSxHQUFJc2YsSUFBRyxDQUFHNlEsRUFBVixDQUNBQSxFQUFFLENBQUdyb0IsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUFMLENBQ0EsSUFBSSxHQUFJbkgsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHb1YsR0FBRyxDQUFDdGYsTUFBdkIsQ0FBK0IsRUFBRWtLLENBQWpDLENBQW9DLENBQ2xDaW1CLEVBQUUsQ0FBQ3JoQixPQUFILENBQVd3USxHQUFHLENBQUNwVixDQUFELENBQWQsRUFDRCxDQUNGLENBQ0QsR0FBRyxDQUFDcEMsS0FBSyxDQUFDMkQsSUFBTixDQUFXbUMsT0FBWCxDQUFtQnVpQixFQUFuQixDQUFKLENBQTRCLENBQzFCO0FBQ0FBLEVBQUUsQ0FBRyxDQUFDQSxFQUFFLENBQUMzZixRQUFILEVBQUQsQ0FBZ0IyZixFQUFFLENBQUMzZixRQUFILEVBQWhCLENBQStCMmYsRUFBRSxDQUFDM2YsUUFBSCxFQUEvQixDQUE4QzJmLEVBQUUsQ0FBQzNmLFFBQUgsRUFBOUMsQ0FBTCxDQUNELENBRUQsTUFBTzJmLEdBQVAsQ0FDRCxDQUVELFFBQVN1SyxNQUFULENBQWVzQyxLQUFmLENBQXNCLENBQ3BCO0FBQ0FBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDaDlCLE1BQU4sQ0FBZSxDQUFoQixDQUFMLENBQTJCZzlCLEtBQUssQ0FBQ0EsS0FBSyxDQUFDaDlCLE1BQU4sQ0FBZSxDQUFoQixDQUFMLENBQTBCLENBQTNCLENBQWdDLFVBQTFELENBQ0QsQ0FFRCxRQUFTMjdCLFdBQVQsQ0FBb0IxZ0IsR0FBcEIsQ0FBeUIsQ0FDdkI7QUFDQSxNQUFPLENBQUVBLEdBQUcsQ0FBRyxXQUFQLENBQXNCLENBQXZCLENBQTBCQSxHQUFHLENBQUcsVUFBaEMsQ0FBUCxDQUNELENBR0QsS0FBTyxDQWw5VEcsQ0FtOVRWLFFBbjlUVSxDQW85VFYsS0FBTyxTQUFTdFIsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E4QkEsR0FBSWxDLE1BQUssQ0FBR2tDLG1CQUFtQixDQUFDLENBQUQsQ0FBL0IsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQSxhQUNBTCxNQUFNLENBQUNELE9BQVAsQ0FBaUI1QixLQUFLLENBQUNpdUIsR0FBTixDQUFZanVCLEtBQUssQ0FBQ2l1QixHQUFOLEVBQWEsRUFBMUMsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CQWp1QixLQUFLLENBQUNpdUIsR0FBTixDQUFVN0YsZUFBVixDQUE0QixTQUFTbnVCLEdBQVQsQ0FBY291QixFQUFkLENBQWtCMWIsTUFBbEIsQ0FBMEIyYixJQUExQixDQUFnQyxDQUMxRCxHQUFJdkssT0FBTSxDQUFHd0ssYUFBYSxDQUFDLENBQ3pCdHVCLEdBQUcsQ0FBRUEsR0FEb0IsQ0FFekIwUyxNQUFNLENBQUVBLE1BRmlCLENBR3pCbkwsT0FBTyxDQUFFLEtBSGdCLENBSXpCOG1CLElBQUksQ0FBRUEsSUFBSSxHQUFLRCxFQUFFLEdBQUssSUFBUCxDQUFjLEtBQWQsQ0FBc0IsS0FBM0IsQ0FKZSxDQUFELENBQTFCLENBTUF0SyxNQUFNLENBQUNoUSxLQUFQLENBQWFzYSxFQUFiLEVBQ0EsTUFBT3RLLE9BQVAsQ0FDRCxDQVRELENBV0E7Ozs7Ozs7Ozs7Ozs7R0FjQS9kLEtBQUssQ0FBQ2l1QixHQUFOLENBQVV6RixzQkFBVixDQUFtQyxTQUFTdnVCLEdBQVQsQ0FBY3F1QixJQUFkLENBQW9CLENBQ3JELE1BQU9DLGNBQWEsQ0FBQyxDQUNuQnR1QixHQUFHLENBQUVBLEdBRGMsQ0FFbkIwUyxNQUFNLENBQUUsSUFGVyxDQUduQm5MLE9BQU8sQ0FBRSxLQUhVLENBSW5COG1CLElBQUksQ0FBRUEsSUFKYSxDQUFELENBQXBCLENBTUQsQ0FQRCxDQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JBdG9CLEtBQUssQ0FBQ2l1QixHQUFOLENBQVV4RixlQUFWLENBQTRCLFNBQVN4dUIsR0FBVCxDQUFjb3VCLEVBQWQsQ0FBa0IxYixNQUFsQixDQUEwQjJiLElBQTFCLENBQWdDLENBQzFELEdBQUl2SyxPQUFNLENBQUd3SyxhQUFhLENBQUMsQ0FDekJ0dUIsR0FBRyxDQUFFQSxHQURvQixDQUV6QjBTLE1BQU0sQ0FBRUEsTUFGaUIsQ0FHekJuTCxPQUFPLENBQUUsSUFIZ0IsQ0FJekI4bUIsSUFBSSxDQUFFQSxJQUFJLEdBQUtELEVBQUUsR0FBSyxJQUFQLENBQWMsS0FBZCxDQUFzQixLQUEzQixDQUplLENBQUQsQ0FBMUIsQ0FNQXRLLE1BQU0sQ0FBQ2hRLEtBQVAsQ0FBYXNhLEVBQWIsRUFDQSxNQUFPdEssT0FBUCxDQUNELENBVEQsQ0FXQTs7Ozs7Ozs7Ozs7OztHQWNBL2QsS0FBSyxDQUFDaXVCLEdBQU4sQ0FBVXZGLHNCQUFWLENBQW1DLFNBQVN6dUIsR0FBVCxDQUFjcXVCLElBQWQsQ0FBb0IsQ0FDckQsTUFBT0MsY0FBYSxDQUFDLENBQ25CdHVCLEdBQUcsQ0FBRUEsR0FEYyxDQUVuQjBTLE1BQU0sQ0FBRSxJQUZXLENBR25CbkwsT0FBTyxDQUFFLElBSFUsQ0FJbkI4bUIsSUFBSSxDQUFFQSxJQUphLENBQUQsQ0FBcEIsQ0FNRCxDQVBELENBU0E7Ozs7Ozs7R0FRQXRvQixLQUFLLENBQUNpdUIsR0FBTixDQUFVdEYsU0FBVixDQUFzQixTQUFTL3BCLElBQVQsQ0FBZTBwQixJQUFmLENBQXFCLENBQ3pDLEdBQUl2bUIsS0FBSSxDQUFHLElBQVgsQ0FDQUEsSUFBSSxDQUFDbkQsSUFBTCxDQUFZQSxJQUFaLENBQ0FtRCxJQUFJLENBQUN1bUIsSUFBTCxDQUFZLEdBQUlBLEtBQUosQ0FBUyxDQUNuQk8sU0FBUyxDQUFFLENBRFEsQ0FFbkI5SyxNQUFNLENBQUUsQ0FDTnNELE9BQU8sQ0FBRSxpQkFBU3lILE9BQVQsQ0FBa0JDLFFBQWxCLENBQTRCLENBQ25DLE1BQU8vSyxhQUFZLENBQUNqYyxJQUFJLENBQUNvekIsS0FBTixDQUFhck0sT0FBYixDQUFzQkMsUUFBdEIsQ0FBZ0MsS0FBaEMsQ0FBbkIsQ0FDRCxDQUhLLENBSU52bkIsT0FBTyxDQUFFLGlCQUFTc25CLE9BQVQsQ0FBa0JDLFFBQWxCLENBQTRCLENBQ25DLE1BQU8vSyxhQUFZLENBQUNqYyxJQUFJLENBQUNvekIsS0FBTixDQUFhck0sT0FBYixDQUFzQkMsUUFBdEIsQ0FBZ0MsSUFBaEMsQ0FBbkIsQ0FDRCxDQU5LLENBRlcsQ0FBVCxDQUFaLENBV0FobkIsSUFBSSxDQUFDa25CLEtBQUwsQ0FBYSxLQUFiLENBQ0QsQ0FmRCxDQWlCQTs7Ozs7OztHQVFBanBCLEtBQUssQ0FBQ2l1QixHQUFOLENBQVV0RixTQUFWLENBQW9CdGxCLFNBQXBCLENBQThCdWxCLFVBQTlCLENBQTJDLFNBQVNyeEIsT0FBVCxDQUFrQixDQUMzRCxHQUFHLEtBQUsweEIsS0FBUixDQUFlLENBQ2IsT0FDRCxDQUVELEdBQUlodkIsSUFBRyxDQUFHK0YsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QmhTLE9BQU8sQ0FBQzBDLEdBQWhDLENBQVYsQ0FDQSxHQUFHLEtBQUsyRSxJQUFMLENBQVV5UixPQUFWLENBQWtCLE1BQWxCLElBQThCLENBQWpDLENBQW9DLENBQ2xDLEdBQUdwVyxHQUFHLENBQUMvQixNQUFKLEtBQWlCLEVBQXBCLENBQXdCLENBQ3RCLEtBQU0sSUFBSUYsTUFBSixDQUFVLGdDQUFrQ2lDLEdBQUcsQ0FBQy9CLE1BQUosR0FBZSxDQUEzRCxDQUFOLENBQ0QsQ0FDRixDQUVEO0FBQ0EsS0FBS2k5QixLQUFMLENBQWFDLFdBQVcsQ0FBQ243QixHQUFELENBQXhCLENBQ0EsS0FBS2d2QixLQUFMLENBQWEsSUFBYixDQUNELENBZkQsQ0FpQkEsK0JBRUFFLGlCQUFpQixDQUFDLFNBQUQsQ0FBWW5wQixLQUFLLENBQUMrZCxNQUFOLENBQWFxTCxLQUFiLENBQW1CQyxHQUEvQixDQUFqQixDQUNBRixpQkFBaUIsQ0FBQyxTQUFELENBQVlucEIsS0FBSyxDQUFDK2QsTUFBTixDQUFhcUwsS0FBYixDQUFtQkUsR0FBL0IsQ0FBakIsQ0FDQUgsaUJBQWlCLENBQUMsU0FBRCxDQUFZbnBCLEtBQUssQ0FBQytkLE1BQU4sQ0FBYXFMLEtBQWIsQ0FBbUJHLEdBQS9CLENBQWpCLENBQ0FKLGlCQUFpQixDQUFDLFNBQUQsQ0FBWW5wQixLQUFLLENBQUMrZCxNQUFOLENBQWFxTCxLQUFiLENBQW1CSSxHQUEvQixDQUFqQixDQUNBTCxpQkFBaUIsQ0FBQyxTQUFELENBQVlucEIsS0FBSyxDQUFDK2QsTUFBTixDQUFhcUwsS0FBYixDQUFtQkssR0FBL0IsQ0FBakIsQ0FFQU4saUJBQWlCLENBQUMsVUFBRCxDQUFhbnBCLEtBQUssQ0FBQytkLE1BQU4sQ0FBYXFMLEtBQWIsQ0FBbUJDLEdBQWhDLENBQWpCLENBQ0FGLGlCQUFpQixDQUFDLFVBQUQsQ0FBYW5wQixLQUFLLENBQUMrZCxNQUFOLENBQWFxTCxLQUFiLENBQW1CRSxHQUFoQyxDQUFqQixDQUNBSCxpQkFBaUIsQ0FBQyxVQUFELENBQWFucEIsS0FBSyxDQUFDK2QsTUFBTixDQUFhcUwsS0FBYixDQUFtQkcsR0FBaEMsQ0FBakIsQ0FDQUosaUJBQWlCLENBQUMsVUFBRCxDQUFhbnBCLEtBQUssQ0FBQytkLE1BQU4sQ0FBYXFMLEtBQWIsQ0FBbUJJLEdBQWhDLENBQWpCLENBQ0FMLGlCQUFpQixDQUFDLFVBQUQsQ0FBYW5wQixLQUFLLENBQUMrZCxNQUFOLENBQWFxTCxLQUFiLENBQW1CSyxHQUFoQyxDQUFqQixDQUVBLFFBQVNOLGtCQUFULENBQTJCdnFCLElBQTNCLENBQWlDMHBCLElBQWpDLENBQXVDLENBQ3JDLEdBQUkzbUIsUUFBTyxDQUFHLFFBQVZBLFFBQVUsRUFBVyxDQUN2QixNQUFPLElBQUkzQixNQUFLLENBQUNpdUIsR0FBTixDQUFVdEYsU0FBZCxDQUF3Qi9wQixJQUF4QixDQUE4QjBwQixJQUE5QixDQUFQLENBQ0QsQ0FGRCxDQUdBdG9CLEtBQUssQ0FBQytkLE1BQU4sQ0FBYW9MLGlCQUFiLENBQStCdnFCLElBQS9CLENBQXFDK0MsT0FBckMsRUFDRCxDQUVELDBCQUVBLEdBQUkwekIsWUFBVyxDQUFHLENBQUMsU0FBRCxDQUFXLENBQVgsQ0FBYSxPQUFiLENBQXFCLFNBQXJCLENBQStCLFNBQS9CLENBQXlDLE9BQXpDLENBQWlELEdBQWpELENBQXFELE9BQXJELENBQTZELEtBQTdELENBQW1FLFNBQW5FLENBQTZFLFNBQTdFLENBQXVGLEtBQXZGLENBQTZGLFNBQTdGLENBQXVHLFNBQXZHLENBQWlILFNBQWpILENBQTJILEdBQTNILENBQStILEtBQS9ILENBQXFJLFNBQXJJLENBQStJLFNBQS9JLENBQXlKLE9BQXpKLENBQWlLLE9BQWpLLENBQXlLLFNBQXpLLENBQW1MLFNBQW5MLENBQTZMLFNBQTdMLENBQXVNLE9BQXZNLENBQStNLFNBQS9NLENBQXlOLFNBQXpOLENBQW1PLE9BQW5PLENBQTJPLENBQTNPLENBQTZPLEtBQTdPLENBQW1QLE9BQW5QLENBQTJQLFNBQTNQLENBQXFRLE9BQXJRLENBQTZRLFNBQTdRLENBQXVSLEdBQXZSLENBQTJSLFNBQTNSLENBQXFTLFNBQXJTLENBQStTLFNBQS9TLENBQXlULFNBQXpULENBQW1VLEtBQW5VLENBQXlVLFNBQXpVLENBQW1WLE9BQW5WLENBQTJWLE9BQTNWLENBQW1XLFNBQW5XLENBQTZXLEtBQTdXLENBQW1YLEdBQW5YLENBQXVYLFNBQXZYLENBQWlZLE9BQWpZLENBQXlZLFNBQXpZLENBQW1aLE9BQW5aLENBQTJaLFNBQTNaLENBQXFhLFNBQXJhLENBQSthLFNBQS9hLENBQXliLEtBQXpiLENBQStiLE9BQS9iLENBQXVjLFNBQXZjLENBQWlkLEtBQWpkLENBQXVkLFNBQXZkLENBQWllLFNBQWplLENBQTJlLENBQTNlLENBQTZlLE9BQTdlLENBQXFmLE9BQXJmLENBQTZmLENBQTdmLENBQStmLFNBQS9mLENBQWxCLENBQ0EsR0FBSUMsWUFBVyxDQUFHLENBQUMsQ0FBQyxVQUFGLENBQWEsQ0FBQyxVQUFkLENBQXlCLE1BQXpCLENBQWdDLFFBQWhDLENBQXlDLFFBQXpDLENBQWtELElBQWxELENBQXVELENBQUMsVUFBeEQsQ0FBbUUsQ0FBQyxVQUFwRSxDQUErRSxDQUFDLFVBQWhGLENBQTJGLENBQUMsVUFBNUYsQ0FBdUcsQ0FBQyxVQUF4RyxDQUFtSCxDQUFDLFVBQXBILENBQStILENBQUMsVUFBaEksQ0FBMkksUUFBM0ksQ0FBb0osSUFBcEosQ0FBeUosQ0FBQyxVQUExSixDQUFxSyxRQUFySyxDQUE4SyxRQUE5SyxDQUF1TCxDQUFDLFVBQXhMLENBQW1NLENBQW5NLENBQXFNLENBQUMsVUFBdE0sQ0FBaU4sTUFBak4sQ0FBd04sUUFBeE4sQ0FBaU8sQ0FBQyxVQUFsTyxDQUE2TyxRQUE3TyxDQUFzUCxDQUFDLFVBQXZQLENBQWtRLENBQWxRLENBQW9RLFFBQXBRLENBQTZRLE1BQTdRLENBQW9SLENBQUMsVUFBclIsQ0FBZ1MsQ0FBQyxVQUFqUyxDQUE0UyxNQUE1UyxDQUFtVCxDQUFuVCxDQUFxVCxRQUFyVCxDQUE4VCxDQUFDLFVBQS9ULENBQTBVLFFBQTFVLENBQW1WLENBQUMsVUFBcFYsQ0FBK1YsQ0FBQyxVQUFoVyxDQUEyVyxDQUFDLFVBQTVXLENBQXVYLE1BQXZYLENBQThYLENBQUMsVUFBL1gsQ0FBMFksQ0FBQyxVQUEzWSxDQUFzWixJQUF0WixDQUEyWixDQUFDLFVBQTVaLENBQXVhLFFBQXZhLENBQWdiLElBQWhiLENBQXFiLE1BQXJiLENBQTRiLENBQUMsVUFBN2IsQ0FBd2MsTUFBeGMsQ0FBK2MsQ0FBQyxVQUFoZCxDQUEyZCxRQUEzZCxDQUFvZSxDQUFDLFVBQXJlLENBQWdmLFFBQWhmLENBQXlmLENBQUMsVUFBMWYsQ0FBcWdCLENBQUMsVUFBdGdCLENBQWloQixRQUFqaEIsQ0FBMGhCLFFBQTFoQixDQUFtaUIsQ0FBbmlCLENBQXFpQixDQUFDLFVBQXRpQixDQUFpakIsTUFBampCLENBQXdqQixDQUFDLFVBQXpqQixDQUFva0IsQ0FBQyxVQUFya0IsQ0FBZ2xCLENBQUMsVUFBamxCLENBQTRsQixRQUE1bEIsQ0FBbEIsQ0FDQSxHQUFJQyxZQUFXLENBQUcsQ0FBQyxLQUFELENBQU8sU0FBUCxDQUFpQixDQUFqQixDQUFtQixTQUFuQixDQUE2QixTQUE3QixDQUF1QyxDQUF2QyxDQUF5QyxPQUF6QyxDQUFpRCxTQUFqRCxDQUEyRCxPQUEzRCxDQUFtRSxTQUFuRSxDQUE2RSxTQUE3RSxDQUF1RixPQUF2RixDQUErRixTQUEvRixDQUF5RyxPQUF6RyxDQUFpSCxTQUFqSCxDQUEySCxLQUEzSCxDQUFpSSxTQUFqSSxDQUEySSxHQUEzSSxDQUErSSxTQUEvSSxDQUF5SixLQUF6SixDQUErSixPQUEvSixDQUF1SyxTQUF2SyxDQUFpTCxTQUFqTCxDQUEyTCxPQUEzTCxDQUFtTSxTQUFuTSxDQUE2TSxPQUE3TSxDQUFxTixPQUFyTixDQUE2TixTQUE3TixDQUF1TyxHQUF2TyxDQUEyTyxTQUEzTyxDQUFxUCxLQUFyUCxDQUEyUCxTQUEzUCxDQUFxUSxTQUFyUSxDQUErUSxTQUEvUSxDQUF5UixPQUF6UixDQUFpUyxLQUFqUyxDQUF1UyxPQUF2UyxDQUErUyxTQUEvUyxDQUF5VCxTQUF6VCxDQUFtVSxDQUFuVSxDQUFxVSxLQUFyVSxDQUEyVSxPQUEzVSxDQUFtVixTQUFuVixDQUE2VixTQUE3VixDQUF1VyxTQUF2VyxDQUFpWCxLQUFqWCxDQUF1WCxDQUF2WCxDQUF5WCxTQUF6WCxDQUFtWSxTQUFuWSxDQUE2WSxPQUE3WSxDQUFxWixTQUFyWixDQUErWixTQUEvWixDQUF5YSxHQUF6YSxDQUE2YSxPQUE3YSxDQUFxYixPQUFyYixDQUE2YixTQUE3YixDQUF1YyxTQUF2YyxDQUFpZCxTQUFqZCxDQUEyZCxLQUEzZCxDQUFpZSxTQUFqZSxDQUEyZSxPQUEzZSxDQUFtZixHQUFuZixDQUF1ZixTQUF2ZixDQUFpZ0IsT0FBamdCLENBQWxCLENBQ0EsR0FBSUMsWUFBVyxDQUFHLENBQUMsUUFBRCxDQUFVLE1BQVYsQ0FBaUIsTUFBakIsQ0FBd0IsSUFBeEIsQ0FBNkIsUUFBN0IsQ0FBc0MsUUFBdEMsQ0FBK0MsUUFBL0MsQ0FBd0QsTUFBeEQsQ0FBK0QsQ0FBL0QsQ0FBaUUsUUFBakUsQ0FBMEUsUUFBMUUsQ0FBbUYsUUFBbkYsQ0FBNEYsSUFBNUYsQ0FBaUcsQ0FBakcsQ0FBbUcsUUFBbkcsQ0FBNEcsUUFBNUcsQ0FBcUgsR0FBckgsQ0FBeUgsTUFBekgsQ0FBZ0ksUUFBaEksQ0FBeUksUUFBekksQ0FBa0osSUFBbEosQ0FBdUosUUFBdkosQ0FBZ0ssTUFBaEssQ0FBdUssTUFBdkssQ0FBOEssUUFBOUssQ0FBdUwsR0FBdkwsQ0FBMkwsTUFBM0wsQ0FBa00sUUFBbE0sQ0FBMk0sTUFBM00sQ0FBa04sUUFBbE4sQ0FBMk4sUUFBM04sQ0FBb08sSUFBcE8sQ0FBeU8sUUFBek8sQ0FBa1AsUUFBbFAsQ0FBMlAsUUFBM1AsQ0FBb1EsUUFBcFEsQ0FBNlEsSUFBN1EsQ0FBa1IsQ0FBbFIsQ0FBb1IsQ0FBcFIsQ0FBc1IsUUFBdFIsQ0FBK1IsTUFBL1IsQ0FBc1MsUUFBdFMsQ0FBK1MsUUFBL1MsQ0FBd1QsR0FBeFQsQ0FBNFQsUUFBNVQsQ0FBcVUsTUFBclUsQ0FBNFUsTUFBNVUsQ0FBbVYsSUFBblYsQ0FBd1YsUUFBeFYsQ0FBaVcsSUFBalcsQ0FBc1csR0FBdFcsQ0FBMFcsTUFBMVcsQ0FBaVgsUUFBalgsQ0FBMFgsTUFBMVgsQ0FBaVksUUFBalksQ0FBMFksUUFBMVksQ0FBbVosTUFBblosQ0FBMFosTUFBMVosQ0FBaWEsUUFBamEsQ0FBMGEsUUFBMWEsQ0FBbWIsSUFBbmIsQ0FBd2IsUUFBeGIsQ0FBaWMsTUFBamMsQ0FBd2MsUUFBeGMsQ0FBbEIsQ0FDQSxHQUFJQyxZQUFXLENBQUcsQ0FBQyxLQUFELENBQU8sU0FBUCxDQUFpQixTQUFqQixDQUEyQixVQUEzQixDQUFzQyxPQUF0QyxDQUE4QyxLQUE5QyxDQUFvRCxVQUFwRCxDQUErRCxTQUEvRCxDQUF5RSxVQUF6RSxDQUFvRixPQUFwRixDQUE0RixTQUE1RixDQUFzRyxVQUF0RyxDQUFpSCxVQUFqSCxDQUE0SCxVQUE1SCxDQUF1SSxPQUF2SSxDQUErSSxVQUEvSSxDQUEwSixTQUExSixDQUFvSyxVQUFwSyxDQUErSyxVQUEvSyxDQUEwTCxDQUExTCxDQUE0TCxVQUE1TCxDQUF1TSxVQUF2TSxDQUFrTixVQUFsTixDQUE2TixTQUE3TixDQUF1TyxVQUF2TyxDQUFrUCxVQUFsUCxDQUE2UCxDQUE3UCxDQUErUCxVQUEvUCxDQUEwUSxTQUExUSxDQUFvUixTQUFwUixDQUE4UixVQUE5UixDQUF5UyxPQUF6UyxDQUFpVCxPQUFqVCxDQUF5VCxVQUF6VCxDQUFvVSxLQUFwVSxDQUEwVSxTQUExVSxDQUFvVixVQUFwVixDQUErVixTQUEvVixDQUF5VyxVQUF6VyxDQUFvWCxVQUFwWCxDQUErWCxTQUEvWCxDQUF5WSxVQUF6WSxDQUFvWixVQUFwWixDQUErWixTQUEvWixDQUF5YSxVQUF6YSxDQUFvYixLQUFwYixDQUEwYixTQUExYixDQUFvYyxVQUFwYyxDQUErYyxVQUEvYyxDQUEwZCxPQUExZCxDQUFrZSxVQUFsZSxDQUE2ZSxVQUE3ZSxDQUF3ZixTQUF4ZixDQUFrZ0IsQ0FBbGdCLENBQW9nQixVQUFwZ0IsQ0FBK2dCLFVBQS9nQixDQUEwaEIsT0FBMWhCLENBQWtpQixTQUFsaUIsQ0FBNGlCLFVBQTVpQixDQUF1akIsT0FBdmpCLENBQStqQixDQUEvakIsQ0FBaWtCLFVBQWprQixDQUE0a0IsU0FBNWtCLENBQXNsQixVQUF0bEIsQ0FBbEIsQ0FDQSxHQUFJQyxZQUFXLENBQUcsQ0FBQyxVQUFELENBQVksVUFBWixDQUF1QixNQUF2QixDQUE4QixVQUE5QixDQUF5QyxVQUF6QyxDQUFvRCxJQUFwRCxDQUF5RCxVQUF6RCxDQUFvRSxRQUFwRSxDQUE2RSxVQUE3RSxDQUF3RixRQUF4RixDQUFpRyxRQUFqRyxDQUEwRyxVQUExRyxDQUFxSCxRQUFySCxDQUE4SCxVQUE5SCxDQUF5SSxVQUF6SSxDQUFvSixNQUFwSixDQUEySixDQUEzSixDQUE2SixRQUE3SixDQUFzSyxVQUF0SyxDQUFpTCxNQUFqTCxDQUF3TCxRQUF4TCxDQUFpTSxVQUFqTSxDQUE0TSxJQUE1TSxDQUFpTixVQUFqTixDQUE0TixVQUE1TixDQUF1TyxDQUF2TyxDQUF5TyxRQUF6TyxDQUFrUCxVQUFsUCxDQUE2UCxNQUE3UCxDQUFvUSxRQUFwUSxDQUE2USxVQUE3USxDQUF3UixVQUF4UixDQUFtUyxVQUFuUyxDQUE4UyxJQUE5UyxDQUFtVCxVQUFuVCxDQUE4VCxRQUE5VCxDQUF1VSxVQUF2VSxDQUFrVixRQUFsVixDQUEyVixNQUEzVixDQUFrVyxVQUFsVyxDQUE2VyxRQUE3VyxDQUFzWCxVQUF0WCxDQUFpWSxVQUFqWSxDQUE0WSxNQUE1WSxDQUFtWixVQUFuWixDQUE4WixVQUE5WixDQUF5YSxRQUF6YSxDQUFrYixVQUFsYixDQUE2YixRQUE3YixDQUFzYyxVQUF0YyxDQUFpZCxDQUFqZCxDQUFtZCxVQUFuZCxDQUE4ZCxJQUE5ZCxDQUFtZSxNQUFuZSxDQUEwZSxVQUExZSxDQUFxZixRQUFyZixDQUE4ZixNQUE5ZixDQUFxZ0IsUUFBcmdCLENBQThnQixVQUE5Z0IsQ0FBeWhCLENBQXpoQixDQUEyaEIsVUFBM2hCLENBQXNpQixVQUF0aUIsQ0FBaWpCLFFBQWpqQixDQUEwakIsVUFBMWpCLENBQWxCLENBQ0EsR0FBSUMsWUFBVyxDQUFHLENBQUMsUUFBRCxDQUFVLFNBQVYsQ0FBb0IsU0FBcEIsQ0FBOEIsQ0FBOUIsQ0FBZ0MsS0FBaEMsQ0FBc0MsU0FBdEMsQ0FBZ0QsUUFBaEQsQ0FBeUQsU0FBekQsQ0FBbUUsU0FBbkUsQ0FBNkUsUUFBN0UsQ0FBc0YsQ0FBdEYsQ0FBd0YsU0FBeEYsQ0FBa0csR0FBbEcsQ0FBc0csU0FBdEcsQ0FBZ0gsU0FBaEgsQ0FBMEgsS0FBMUgsQ0FBZ0ksU0FBaEksQ0FBMEksUUFBMUksQ0FBbUosUUFBbkosQ0FBNEosU0FBNUosQ0FBc0ssU0FBdEssQ0FBZ0wsU0FBaEwsQ0FBMEwsU0FBMUwsQ0FBb00sUUFBcE0sQ0FBNk0sU0FBN00sQ0FBdU4sS0FBdk4sQ0FBNk4sS0FBN04sQ0FBbU8sU0FBbk8sQ0FBNk8sUUFBN08sQ0FBc1AsR0FBdFAsQ0FBMFAsU0FBMVAsQ0FBb1EsUUFBcFEsQ0FBNlEsU0FBN1EsQ0FBdVIsUUFBdlIsQ0FBZ1MsUUFBaFMsQ0FBeVMsU0FBelMsQ0FBbVQsU0FBblQsQ0FBNlQsU0FBN1QsQ0FBdVUsU0FBdlUsQ0FBaVYsR0FBalYsQ0FBcVYsUUFBclYsQ0FBOFYsU0FBOVYsQ0FBd1csU0FBeFcsQ0FBa1gsUUFBbFgsQ0FBMlgsU0FBM1gsQ0FBcVksS0FBclksQ0FBMlksUUFBM1ksQ0FBb1osU0FBcFosQ0FBOFosS0FBOVosQ0FBb2EsU0FBcGEsQ0FBOGEsU0FBOWEsQ0FBd2IsU0FBeGIsQ0FBa2MsUUFBbGMsQ0FBMmMsQ0FBM2MsQ0FBNmMsR0FBN2MsQ0FBaWQsU0FBamQsQ0FBMmQsQ0FBM2QsQ0FBNmQsUUFBN2QsQ0FBc2UsU0FBdGUsQ0FBZ2YsS0FBaGYsQ0FBc2YsU0FBdGYsQ0FBZ2dCLFNBQWhnQixDQUEwZ0IsS0FBMWdCLENBQWdoQixRQUFoaEIsQ0FBbEIsQ0FDQSxHQUFJQyxZQUFXLENBQUcsQ0FBQyxVQUFELENBQVksTUFBWixDQUFtQixPQUFuQixDQUEyQixVQUEzQixDQUFzQyxVQUF0QyxDQUFpRCxVQUFqRCxDQUE0RCxJQUE1RCxDQUFpRSxVQUFqRSxDQUE0RSxPQUE1RSxDQUFvRixVQUFwRixDQUErRixVQUEvRixDQUEwRyxPQUExRyxDQUFrSCxVQUFsSCxDQUE2SCxPQUE3SCxDQUFxSSxNQUFySSxDQUE0SSxJQUE1SSxDQUFpSixVQUFqSixDQUE0SixVQUE1SixDQUF1SyxVQUF2SyxDQUFrTCxNQUFsTCxDQUF5TCxPQUF6TCxDQUFpTSxPQUFqTSxDQUF5TSxVQUF6TSxDQUFvTixVQUFwTixDQUErTixNQUEvTixDQUFzTyxDQUF0TyxDQUF3TyxDQUF4TyxDQUEwTyxVQUExTyxDQUFxUCxVQUFyUCxDQUFnUSxVQUFoUSxDQUEyUSxPQUEzUSxDQUFtUixPQUFuUixDQUEyUixPQUEzUixDQUFtUyxPQUFuUyxDQUEyUyxVQUEzUyxDQUFzVCxNQUF0VCxDQUE2VCxJQUE3VCxDQUFrVSxVQUFsVSxDQUE2VSxNQUE3VSxDQUFvVixPQUFwVixDQUE0VixVQUE1VixDQUF1VyxJQUF2VyxDQUE0VyxVQUE1VyxDQUF1WCxVQUF2WCxDQUFrWSxVQUFsWSxDQUE2WSxVQUE3WSxDQUF3WixPQUF4WixDQUFnYSxVQUFoYSxDQUEyYSxDQUEzYSxDQUE2YSxVQUE3YSxDQUF3YixPQUF4YixDQUFnYyxVQUFoYyxDQUEyYyxVQUEzYyxDQUFzZCxVQUF0ZCxDQUFpZSxVQUFqZSxDQUE0ZSxDQUE1ZSxDQUE4ZSxVQUE5ZSxDQUF5ZixPQUF6ZixDQUFpZ0IsT0FBamdCLENBQXlnQixNQUF6Z0IsQ0FBZ2hCLE1BQWhoQixDQUF1aEIsT0FBdmhCLENBQStoQixVQUEvaEIsQ0FBMGlCLFVBQTFpQixDQUFsQixDQUVBOzs7Ozs7R0FPQSxRQUFTUixZQUFULENBQXFCbjdCLEdBQXJCLENBQTBCLENBQ3hCLEdBQUk0N0IsVUFBUyxDQUFJLENBQUMsQ0FBRCxDQUFHLEdBQUgsQ0FBTyxVQUFQLENBQWtCLFVBQWxCLENBQTZCLE9BQTdCLENBQXFDLE9BQXJDLENBQTZDLFVBQTdDLENBQXdELFVBQXhELENBQW1FLEtBQW5FLENBQXlFLEtBQXpFLENBQStFLFVBQS9FLENBQTBGLFVBQTFGLENBQXFHLE9BQXJHLENBQTZHLE9BQTdHLENBQXFILFVBQXJILENBQWdJLFVBQWhJLENBQWpCLENBQ0lDLFNBQVMsQ0FBSSxDQUFDLENBQUQsQ0FBRyxHQUFILENBQU8sUUFBUCxDQUFnQixRQUFoQixDQUF5QixTQUF6QixDQUFtQyxTQUFuQyxDQUE2QyxTQUE3QyxDQUF1RCxTQUF2RCxDQUFpRSxLQUFqRSxDQUF1RSxLQUF2RSxDQUE2RSxRQUE3RSxDQUFzRixRQUF0RixDQUErRixTQUEvRixDQUF5RyxTQUF6RyxDQUFtSCxTQUFuSCxDQUE2SCxTQUE3SCxDQURqQixDQUVJQyxTQUFTLENBQUksQ0FBQyxDQUFELENBQUcsR0FBSCxDQUFPLEtBQVAsQ0FBYSxLQUFiLENBQW1CLFNBQW5CLENBQTZCLFNBQTdCLENBQXVDLFNBQXZDLENBQWlELFNBQWpELENBQTJELENBQTNELENBQTZELEdBQTdELENBQWlFLEtBQWpFLENBQXVFLEtBQXZFLENBQTZFLFNBQTdFLENBQXVGLFNBQXZGLENBQWlHLFNBQWpHLENBQTJHLFNBQTNHLENBRmpCLENBR0lDLFNBQVMsQ0FBSSxDQUFDLENBQUQsQ0FBRyxRQUFILENBQVksU0FBWixDQUFzQixTQUF0QixDQUFnQyxNQUFoQyxDQUF1QyxRQUF2QyxDQUFnRCxTQUFoRCxDQUEwRCxTQUExRCxDQUFvRSxPQUFwRSxDQUE0RSxRQUE1RSxDQUFxRixTQUFyRixDQUErRixTQUEvRixDQUF5RyxPQUF6RyxDQUFpSCxRQUFqSCxDQUEwSCxTQUExSCxDQUFvSSxTQUFwSSxDQUhqQixDQUlJQyxTQUFTLENBQUksQ0FBQyxDQUFELENBQUcsT0FBSCxDQUFXLElBQVgsQ0FBZ0IsT0FBaEIsQ0FBd0IsQ0FBeEIsQ0FBMEIsT0FBMUIsQ0FBa0MsSUFBbEMsQ0FBdUMsT0FBdkMsQ0FBK0MsTUFBL0MsQ0FBc0QsT0FBdEQsQ0FBOEQsTUFBOUQsQ0FBcUUsT0FBckUsQ0FBNkUsTUFBN0UsQ0FBb0YsT0FBcEYsQ0FBNEYsTUFBNUYsQ0FBbUcsT0FBbkcsQ0FKakIsQ0FLSUMsU0FBUyxDQUFJLENBQUMsQ0FBRCxDQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsS0FBZCxDQUFvQixDQUFwQixDQUFzQixLQUF0QixDQUE0QixJQUE1QixDQUFpQyxLQUFqQyxDQUF1QyxTQUF2QyxDQUFpRCxTQUFqRCxDQUEyRCxTQUEzRCxDQUFxRSxTQUFyRSxDQUErRSxTQUEvRSxDQUF5RixTQUF6RixDQUFtRyxTQUFuRyxDQUE2RyxTQUE3RyxDQUxqQixDQU1JQyxTQUFTLENBQUksQ0FBQyxDQUFELENBQUcsVUFBSCxDQUFjLE9BQWQsQ0FBc0IsVUFBdEIsQ0FBaUMsR0FBakMsQ0FBcUMsVUFBckMsQ0FBZ0QsT0FBaEQsQ0FBd0QsVUFBeEQsQ0FBbUUsQ0FBbkUsQ0FBcUUsVUFBckUsQ0FBZ0YsT0FBaEYsQ0FBd0YsVUFBeEYsQ0FBbUcsR0FBbkcsQ0FBdUcsVUFBdkcsQ0FBa0gsT0FBbEgsQ0FBMEgsVUFBMUgsQ0FOakIsQ0FPSUMsU0FBUyxDQUFJLENBQUMsQ0FBRCxDQUFHLE9BQUgsQ0FBVyxLQUFYLENBQWlCLE9BQWpCLENBQXlCLFVBQXpCLENBQW9DLFVBQXBDLENBQStDLFVBQS9DLENBQTBELFVBQTFELENBQXFFLE9BQXJFLENBQTZFLE9BQTdFLENBQXFGLE9BQXJGLENBQTZGLE9BQTdGLENBQXFHLFVBQXJHLENBQWdILFVBQWhILENBQTJILFVBQTNILENBQXNJLFVBQXRJLENBUGpCLENBUUlDLFNBQVMsQ0FBSSxDQUFDLENBQUQsQ0FBRyxPQUFILENBQVcsQ0FBWCxDQUFhLE9BQWIsQ0FBcUIsR0FBckIsQ0FBeUIsT0FBekIsQ0FBaUMsR0FBakMsQ0FBcUMsT0FBckMsQ0FBNkMsU0FBN0MsQ0FBdUQsU0FBdkQsQ0FBaUUsU0FBakUsQ0FBMkUsU0FBM0UsQ0FBcUYsU0FBckYsQ0FBK0YsU0FBL0YsQ0FBeUcsU0FBekcsQ0FBbUgsU0FBbkgsQ0FSakIsQ0FTSUMsU0FBUyxDQUFJLENBQUMsQ0FBRCxDQUFHLFVBQUgsQ0FBYyxHQUFkLENBQWtCLFVBQWxCLENBQTZCLENBQTdCLENBQStCLFVBQS9CLENBQTBDLEdBQTFDLENBQThDLFVBQTlDLENBQXlELEtBQXpELENBQStELFVBQS9ELENBQTBFLEtBQTFFLENBQWdGLFVBQWhGLENBQTJGLEtBQTNGLENBQWlHLFVBQWpHLENBQTRHLEtBQTVHLENBQWtILFVBQWxILENBVGpCLENBVUlDLFVBQVUsQ0FBRyxDQUFDLENBQUQsQ0FBRyxJQUFILENBQVEsQ0FBUixDQUFVLElBQVYsQ0FBZSxRQUFmLENBQXdCLFFBQXhCLENBQWlDLFFBQWpDLENBQTBDLFFBQTFDLENBQW1ELE1BQW5ELENBQTBELE1BQTFELENBQWlFLE1BQWpFLENBQXdFLE1BQXhFLENBQStFLFFBQS9FLENBQXdGLFFBQXhGLENBQWlHLFFBQWpHLENBQTBHLFFBQTFHLENBVmpCLENBV0lDLFVBQVUsQ0FBRyxDQUFDLENBQUQsQ0FBRyxTQUFILENBQWEsS0FBYixDQUFtQixTQUFuQixDQUE2QixRQUE3QixDQUFzQyxTQUF0QyxDQUFnRCxRQUFoRCxDQUF5RCxTQUF6RCxDQUFtRSxTQUFuRSxDQUE2RSxTQUE3RSxDQUF1RixTQUF2RixDQUFpRyxTQUFqRyxDQUEyRyxTQUEzRyxDQUFxSCxTQUFySCxDQUErSCxTQUEvSCxDQUF5SSxTQUF6SSxDQVhqQixDQVlJQyxVQUFVLENBQUcsQ0FBQyxDQUFELENBQUcsTUFBSCxDQUFVLFNBQVYsQ0FBb0IsU0FBcEIsQ0FBOEIsT0FBOUIsQ0FBc0MsT0FBdEMsQ0FBOEMsU0FBOUMsQ0FBd0QsU0FBeEQsQ0FBa0UsSUFBbEUsQ0FBdUUsTUFBdkUsQ0FBOEUsU0FBOUUsQ0FBd0YsU0FBeEYsQ0FBa0csT0FBbEcsQ0FBMEcsT0FBMUcsQ0FBa0gsU0FBbEgsQ0FBNEgsU0FBNUgsQ0FaakIsQ0FhSUMsVUFBVSxDQUFHLENBQUMsQ0FBRCxDQUFHLEdBQUgsQ0FBTyxLQUFQLENBQWEsS0FBYixDQUFtQixDQUFuQixDQUFxQixHQUFyQixDQUF5QixLQUF6QixDQUErQixLQUEvQixDQUFxQyxHQUFyQyxDQUF5QyxHQUF6QyxDQUE2QyxLQUE3QyxDQUFtRCxLQUFuRCxDQUF5RCxHQUF6RCxDQUE2RCxHQUE3RCxDQUFpRSxLQUFqRSxDQUF1RSxLQUF2RSxDQWJqQixDQWVBO0FBQ0E7QUFDQSxHQUFJMUYsV0FBVSxDQUFHLzJCLEdBQUcsQ0FBQy9CLE1BQUosR0FBZSxDQUFmLENBQW1CLENBQW5CLENBQXVCLENBQXhDLENBRUE7QUFDQSxHQUFJc0csS0FBSSxDQUFHLEVBQVgsQ0FFQTtBQUNBLEdBQUltNEIsT0FBTSxDQUFHLENBQUMsQ0FBRCxDQUFJLENBQUosQ0FBTyxDQUFQLENBQVUsQ0FBVixDQUFhLENBQWIsQ0FBZ0IsQ0FBaEIsQ0FBbUIsQ0FBbkIsQ0FBc0IsQ0FBdEIsQ0FBeUIsQ0FBekIsQ0FBNEIsQ0FBNUIsQ0FBK0IsQ0FBL0IsQ0FBa0MsQ0FBbEMsQ0FBcUMsQ0FBckMsQ0FBd0MsQ0FBeEMsQ0FBMkMsQ0FBM0MsQ0FBOEMsQ0FBOUMsQ0FBYixDQUVBLEdBQUk1ekIsRUFBQyxDQUFHLENBQVIsQ0FBV3lVLEdBQVgsQ0FDQSxJQUFJLEdBQUk1SixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdvakIsVUFBbkIsQ0FBK0JwakIsQ0FBQyxFQUFoQyxDQUFvQyxDQUNsQyxHQUFJZ3BCLEtBQUksQ0FBRzM4QixHQUFHLENBQUN5TyxRQUFKLEVBQVgsQ0FDQSxHQUFJbXVCLE1BQUssQ0FBRzU4QixHQUFHLENBQUN5TyxRQUFKLEVBQVosQ0FFQThPLEdBQUcsQ0FBRyxDQUFFb2YsSUFBSSxHQUFLLENBQVYsQ0FBZUMsS0FBaEIsRUFBeUIsVUFBL0IsQ0FDQUEsS0FBSyxFQUFJcmYsR0FBVCxDQUNBb2YsSUFBSSxFQUFLcGYsR0FBRyxFQUFJLENBQWhCLENBRUFBLEdBQUcsQ0FBRyxDQUFFcWYsS0FBSyxHQUFLLENBQUMsRUFBWixDQUFrQkQsSUFBbkIsRUFBMkIsVUFBakMsQ0FDQUEsSUFBSSxFQUFJcGYsR0FBUixDQUNBcWYsS0FBSyxFQUFLcmYsR0FBRyxFQUFJLENBQUMsRUFBbEIsQ0FFQUEsR0FBRyxDQUFHLENBQUVvZixJQUFJLEdBQUssQ0FBVixDQUFlQyxLQUFoQixFQUF5QixVQUEvQixDQUNBQSxLQUFLLEVBQUlyZixHQUFULENBQ0FvZixJQUFJLEVBQUtwZixHQUFHLEVBQUksQ0FBaEIsQ0FFQUEsR0FBRyxDQUFHLENBQUVxZixLQUFLLEdBQUssQ0FBQyxFQUFaLENBQWtCRCxJQUFuQixFQUEyQixVQUFqQyxDQUNBQSxJQUFJLEVBQUlwZixHQUFSLENBQ0FxZixLQUFLLEVBQUtyZixHQUFHLEVBQUksQ0FBQyxFQUFsQixDQUVBQSxHQUFHLENBQUcsQ0FBRW9mLElBQUksR0FBSyxDQUFWLENBQWVDLEtBQWhCLEVBQXlCLFVBQS9CLENBQ0FBLEtBQUssRUFBSXJmLEdBQVQsQ0FDQW9mLElBQUksRUFBS3BmLEdBQUcsRUFBSSxDQUFoQixDQUVBQSxHQUFHLENBQUcsQ0FBRXFmLEtBQUssR0FBSyxDQUFYLENBQWdCRCxJQUFqQixFQUF5QixVQUEvQixDQUNBQSxJQUFJLEVBQUlwZixHQUFSLENBQ0FxZixLQUFLLEVBQUtyZixHQUFHLEVBQUksQ0FBakIsQ0FFQUEsR0FBRyxDQUFHLENBQUVvZixJQUFJLEdBQUssQ0FBVixDQUFlQyxLQUFoQixFQUF5QixVQUEvQixDQUNBQSxLQUFLLEVBQUlyZixHQUFULENBQ0FvZixJQUFJLEVBQUtwZixHQUFHLEVBQUksQ0FBaEIsQ0FFQTtBQUNBQSxHQUFHLENBQUlvZixJQUFJLEVBQUksQ0FBVCxDQUFnQkMsS0FBSyxHQUFLLEVBQVgsQ0FBaUIsVUFBdEMsQ0FFQTtBQUNBRCxJQUFJLENBQUtDLEtBQUssRUFBSSxFQUFWLENBQWtCQSxLQUFLLEVBQUksQ0FBVixDQUFlLFFBQWhDLENBQ0pBLEtBQUssR0FBSyxDQUFYLENBQWdCLE1BRFgsQ0FDdUJBLEtBQUssR0FBSyxFQUFYLENBQWlCLElBRC9DLENBRUFBLEtBQUssQ0FBR3JmLEdBQVIsQ0FFQTtBQUNBLElBQUksR0FBSXBWLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3UwQixNQUFNLENBQUN6K0IsTUFBMUIsQ0FBa0MsRUFBRWtLLENBQXBDLENBQXVDLENBQ3JDO0FBQ0EsR0FBR3UwQixNQUFNLENBQUN2MEIsQ0FBRCxDQUFULENBQWMsQ0FDWncwQixJQUFJLENBQUlBLElBQUksRUFBSSxDQUFULENBQWVBLElBQUksR0FBSyxFQUEvQixDQUNBQyxLQUFLLENBQUlBLEtBQUssRUFBSSxDQUFWLENBQWdCQSxLQUFLLEdBQUssRUFBbEMsQ0FDRCxDQUhELElBR08sQ0FDTEQsSUFBSSxDQUFJQSxJQUFJLEVBQUksQ0FBVCxDQUFlQSxJQUFJLEdBQUssRUFBL0IsQ0FDQUMsS0FBSyxDQUFJQSxLQUFLLEVBQUksQ0FBVixDQUFnQkEsS0FBSyxHQUFLLEVBQWxDLENBQ0QsQ0FDREQsSUFBSSxFQUFJLENBQUMsR0FBVCxDQUNBQyxLQUFLLEVBQUksQ0FBQyxHQUFWLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUlDLFFBQU8sQ0FDVGpCLFNBQVMsQ0FBQ2UsSUFBSSxHQUFLLEVBQVYsQ0FBVCxDQUF5QmQsU0FBUyxDQUFFYyxJQUFJLEdBQUssRUFBVixDQUFnQixHQUFqQixDQUFsQyxDQUNBYixTQUFTLENBQUVhLElBQUksR0FBSyxFQUFWLENBQWdCLEdBQWpCLENBRFQsQ0FDaUNaLFNBQVMsQ0FBRVksSUFBSSxHQUFLLEVBQVYsQ0FBZ0IsR0FBakIsQ0FEMUMsQ0FFQVgsU0FBUyxDQUFFVyxJQUFJLEdBQUssRUFBVixDQUFnQixHQUFqQixDQUZULENBRWlDVixTQUFTLENBQUVVLElBQUksR0FBSyxDQUFWLENBQWUsR0FBaEIsQ0FGMUMsQ0FHQVQsU0FBUyxDQUFFUyxJQUFJLEdBQUssQ0FBVixDQUFlLEdBQWhCLENBSlgsQ0FLQSxHQUFJRyxTQUFRLENBQ1ZYLFNBQVMsQ0FBQ1MsS0FBSyxHQUFLLEVBQVgsQ0FBVCxDQUEwQlIsU0FBUyxDQUFFUSxLQUFLLEdBQUssRUFBWCxDQUFpQixHQUFsQixDQUFuQyxDQUNBUCxTQUFTLENBQUVPLEtBQUssR0FBSyxFQUFYLENBQWlCLEdBQWxCLENBRFQsQ0FDa0NOLFVBQVUsQ0FBRU0sS0FBSyxHQUFLLEVBQVgsQ0FBaUIsR0FBbEIsQ0FENUMsQ0FFQUwsVUFBVSxDQUFFSyxLQUFLLEdBQUssRUFBWCxDQUFpQixHQUFsQixDQUZWLENBRW1DSixVQUFVLENBQUVJLEtBQUssR0FBSyxDQUFYLENBQWdCLEdBQWpCLENBRjdDLENBR0FILFVBQVUsQ0FBRUcsS0FBSyxHQUFLLENBQVgsQ0FBZ0IsR0FBakIsQ0FKWixDQUtBcmYsR0FBRyxDQUFHLENBQUV1ZixRQUFRLEdBQUssRUFBZCxDQUFvQkQsT0FBckIsRUFBZ0MsVUFBdEMsQ0FDQXQ0QixJQUFJLENBQUN1RSxDQUFDLEVBQUYsQ0FBSixDQUFZK3pCLE9BQU8sQ0FBR3RmLEdBQXRCLENBQ0FoWixJQUFJLENBQUN1RSxDQUFDLEVBQUYsQ0FBSixDQUFZZzBCLFFBQVEsQ0FBSXZmLEdBQUcsRUFBSSxFQUEvQixDQUNELENBQ0YsQ0FFRCxNQUFPaFosS0FBUCxDQUNELENBRUQ7Ozs7Ozs7O0dBU0EsUUFBU3dmLGFBQVQsQ0FBc0J4ZixJQUF0QixDQUE0QmtOLEtBQTVCLENBQW1DaUIsTUFBbkMsQ0FBMkNuTCxPQUEzQyxDQUFvRCxDQUNsRDtBQUNBLEdBQUl3dkIsV0FBVSxDQUFHeHlCLElBQUksQ0FBQ3RHLE1BQUwsR0FBZ0IsRUFBaEIsQ0FBcUIsQ0FBckIsQ0FBeUIsQ0FBMUMsQ0FDQSxHQUFJOCtCLFFBQUosQ0FDQSxHQUFHaEcsVUFBVSxHQUFLLENBQWxCLENBQXFCLENBQ25CZ0csT0FBTyxDQUFHeDFCLE9BQU8sQ0FBRyxDQUFDLEVBQUQsQ0FBSyxDQUFDLENBQU4sQ0FBUyxDQUFDLENBQVYsQ0FBSCxDQUFrQixDQUFDLENBQUQsQ0FBSSxFQUFKLENBQVEsQ0FBUixDQUFuQyxDQUNELENBRkQsSUFFTyxDQUNMdzFCLE9BQU8sQ0FBSXgxQixPQUFPLENBQ2hCLENBQUMsRUFBRCxDQUFLLEVBQUwsQ0FBUyxDQUFDLENBQVYsQ0FBYSxFQUFiLENBQWlCLEVBQWpCLENBQXFCLENBQXJCLENBQXdCLEVBQXhCLENBQTRCLENBQUMsQ0FBN0IsQ0FBZ0MsQ0FBQyxDQUFqQyxDQURnQixDQUVoQixDQUFDLENBQUQsQ0FBSSxFQUFKLENBQVEsQ0FBUixDQUFXLEVBQVgsQ0FBZSxFQUFmLENBQW1CLENBQUMsQ0FBcEIsQ0FBdUIsRUFBdkIsQ0FBMkIsRUFBM0IsQ0FBK0IsQ0FBL0IsQ0FGRixDQUdELENBRUQsR0FBSWdXLElBQUosQ0FFQSxHQUFJb2YsS0FBSSxDQUFHbHJCLEtBQUssQ0FBQyxDQUFELENBQWhCLENBQ0EsR0FBSW1yQixNQUFLLENBQUduckIsS0FBSyxDQUFDLENBQUQsQ0FBakIsQ0FFQTtBQUNBOEwsR0FBRyxDQUFHLENBQUVvZixJQUFJLEdBQUssQ0FBVixDQUFlQyxLQUFoQixFQUF5QixVQUEvQixDQUNBQSxLQUFLLEVBQUlyZixHQUFULENBQ0FvZixJQUFJLEVBQUtwZixHQUFHLEVBQUksQ0FBaEIsQ0FFQUEsR0FBRyxDQUFHLENBQUVvZixJQUFJLEdBQUssRUFBVixDQUFnQkMsS0FBakIsRUFBMEIsVUFBaEMsQ0FDQUEsS0FBSyxFQUFJcmYsR0FBVCxDQUNBb2YsSUFBSSxFQUFLcGYsR0FBRyxFQUFJLEVBQWhCLENBRUFBLEdBQUcsQ0FBRyxDQUFFcWYsS0FBSyxHQUFLLENBQVgsQ0FBZ0JELElBQWpCLEVBQXlCLFVBQS9CLENBQ0FBLElBQUksRUFBSXBmLEdBQVIsQ0FDQXFmLEtBQUssRUFBS3JmLEdBQUcsRUFBSSxDQUFqQixDQUVBQSxHQUFHLENBQUcsQ0FBRXFmLEtBQUssR0FBSyxDQUFYLENBQWdCRCxJQUFqQixFQUF5QixVQUEvQixDQUNBQSxJQUFJLEVBQUlwZixHQUFSLENBQ0FxZixLQUFLLEVBQUtyZixHQUFHLEVBQUksQ0FBakIsQ0FFQUEsR0FBRyxDQUFHLENBQUVvZixJQUFJLEdBQUssQ0FBVixDQUFlQyxLQUFoQixFQUF5QixVQUEvQixDQUNBQSxLQUFLLEVBQUlyZixHQUFULENBQ0FvZixJQUFJLEVBQUtwZixHQUFHLEVBQUksQ0FBaEIsQ0FFQTtBQUNBb2YsSUFBSSxDQUFLQSxJQUFJLEVBQUksQ0FBVCxDQUFlQSxJQUFJLEdBQUssRUFBaEMsQ0FDQUMsS0FBSyxDQUFLQSxLQUFLLEVBQUksQ0FBVixDQUFnQkEsS0FBSyxHQUFLLEVBQW5DLENBRUEsSUFBSSxHQUFJanBCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR29qQixVQUFuQixDQUErQnBqQixDQUFDLEVBQUksQ0FBcEMsQ0FBdUMsQ0FDckMsR0FBSXFwQixRQUFPLENBQUdELE9BQU8sQ0FBQ3BwQixDQUFDLENBQUcsQ0FBTCxDQUFyQixDQUNBLEdBQUlzcEIsUUFBTyxDQUFHRixPQUFPLENBQUNwcEIsQ0FBQyxDQUFHLENBQUwsQ0FBckIsQ0FFQTtBQUNBLElBQUksR0FBSXhMLEVBQUMsQ0FBRzQwQixPQUFPLENBQUNwcEIsQ0FBRCxDQUFuQixDQUF3QnhMLENBQUMsRUFBSTYwQixPQUE3QixDQUFzQzcwQixDQUFDLEVBQUk4MEIsT0FBM0MsQ0FBb0QsQ0FDbEQsR0FBSUMsT0FBTSxDQUFHTixLQUFLLENBQUdyNEIsSUFBSSxDQUFDNEQsQ0FBRCxDQUF6QixDQUNBLEdBQUlnMUIsT0FBTSxDQUFHLENBQUVQLEtBQUssR0FBSyxDQUFYLENBQWlCQSxLQUFLLEVBQUksRUFBM0IsRUFBa0NyNEIsSUFBSSxDQUFDNEQsQ0FBQyxDQUFHLENBQUwsQ0FBbkQsQ0FFQTtBQUNBb1YsR0FBRyxDQUFHb2YsSUFBTixDQUNBQSxJQUFJLENBQUdDLEtBQVAsQ0FDQUEsS0FBSyxDQUFHcmYsR0FBRyxFQUNUOGQsV0FBVyxDQUFFNkIsTUFBTSxHQUFLLEVBQVosQ0FBa0IsSUFBbkIsQ0FBWCxDQUNBM0IsV0FBVyxDQUFFMkIsTUFBTSxHQUFLLEVBQVosQ0FBa0IsSUFBbkIsQ0FEWCxDQUVBekIsV0FBVyxDQUFFeUIsTUFBTSxHQUFNLENBQWIsQ0FBa0IsSUFBbkIsQ0FGWCxDQUdBdkIsV0FBVyxDQUFDdUIsTUFBTSxDQUFHLElBQVYsQ0FIWCxDQUlBOUIsV0FBVyxDQUFFK0IsTUFBTSxHQUFLLEVBQVosQ0FBa0IsSUFBbkIsQ0FKWCxDQUtBN0IsV0FBVyxDQUFFNkIsTUFBTSxHQUFLLEVBQVosQ0FBa0IsSUFBbkIsQ0FMWCxDQU1BM0IsV0FBVyxDQUFFMkIsTUFBTSxHQUFNLENBQWIsQ0FBa0IsSUFBbkIsQ0FOWCxDQU9BekIsV0FBVyxDQUFDeUIsTUFBTSxDQUFHLElBQVYsQ0FSRixDQUFYLENBU0QsQ0FDRDtBQUNBNWYsR0FBRyxDQUFHb2YsSUFBTixDQUNBQSxJQUFJLENBQUdDLEtBQVAsQ0FDQUEsS0FBSyxDQUFHcmYsR0FBUixDQUNELENBRUQ7QUFDQW9mLElBQUksQ0FBS0EsSUFBSSxHQUFLLENBQVYsQ0FBZ0JBLElBQUksRUFBSSxFQUFoQyxDQUNBQyxLQUFLLENBQUtBLEtBQUssR0FBSyxDQUFYLENBQWlCQSxLQUFLLEVBQUksRUFBbkMsQ0FFQTtBQUNBcmYsR0FBRyxDQUFHLENBQUVvZixJQUFJLEdBQUssQ0FBVixDQUFlQyxLQUFoQixFQUF5QixVQUEvQixDQUNBQSxLQUFLLEVBQUlyZixHQUFULENBQ0FvZixJQUFJLEVBQUtwZixHQUFHLEVBQUksQ0FBaEIsQ0FFQUEsR0FBRyxDQUFHLENBQUVxZixLQUFLLEdBQUssQ0FBWCxDQUFnQkQsSUFBakIsRUFBeUIsVUFBL0IsQ0FDQUEsSUFBSSxFQUFJcGYsR0FBUixDQUNBcWYsS0FBSyxFQUFLcmYsR0FBRyxFQUFJLENBQWpCLENBRUFBLEdBQUcsQ0FBRyxDQUFFcWYsS0FBSyxHQUFLLENBQVgsQ0FBZ0JELElBQWpCLEVBQXlCLFVBQS9CLENBQ0FBLElBQUksRUFBSXBmLEdBQVIsQ0FDQXFmLEtBQUssRUFBS3JmLEdBQUcsRUFBSSxDQUFqQixDQUVBQSxHQUFHLENBQUcsQ0FBRW9mLElBQUksR0FBSyxFQUFWLENBQWdCQyxLQUFqQixFQUEwQixVQUFoQyxDQUNBQSxLQUFLLEVBQUlyZixHQUFULENBQ0FvZixJQUFJLEVBQUtwZixHQUFHLEVBQUksRUFBaEIsQ0FFQUEsR0FBRyxDQUFHLENBQUVvZixJQUFJLEdBQUssQ0FBVixDQUFlQyxLQUFoQixFQUF5QixVQUEvQixDQUNBQSxLQUFLLEVBQUlyZixHQUFULENBQ0FvZixJQUFJLEVBQUtwZixHQUFHLEVBQUksQ0FBaEIsQ0FFQTdLLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBWWlxQixJQUFaLENBQ0FqcUIsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFZa3FCLEtBQVosQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkEsUUFBU3RPLGNBQVQsQ0FBdUJoeEIsT0FBdkIsQ0FBZ0MsQ0FDOUJBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0EsR0FBSSt3QixLQUFJLENBQUcsQ0FBQy93QixPQUFPLENBQUMrd0IsSUFBUixFQUFnQixLQUFqQixFQUF3QnZELFdBQXhCLEVBQVgsQ0FDQSxHQUFJbEYsVUFBUyxDQUFHLE9BQVN5SSxJQUF6QixDQUVBLEdBQUl2SyxPQUFKLENBQ0EsR0FBR3htQixPQUFPLENBQUNpSyxPQUFYLENBQW9CLENBQ2xCdWMsTUFBTSxDQUFHL2QsS0FBSyxDQUFDK2QsTUFBTixDQUFhMk4sY0FBYixDQUE0QjdMLFNBQTVCLENBQXVDdG9CLE9BQU8sQ0FBQzBDLEdBQS9DLENBQVQsQ0FDRCxDQUZELElBRU8sQ0FDTDhqQixNQUFNLENBQUcvZCxLQUFLLENBQUMrZCxNQUFOLENBQWE0TixZQUFiLENBQTBCOUwsU0FBMUIsQ0FBcUN0b0IsT0FBTyxDQUFDMEMsR0FBN0MsQ0FBVCxDQUNELENBRUQ7QUFDQSxHQUFJOFQsTUFBSyxDQUFHZ1EsTUFBTSxDQUFDaFEsS0FBbkIsQ0FDQWdRLE1BQU0sQ0FBQ2hRLEtBQVAsQ0FBZSxTQUFTc2EsRUFBVCxDQUFhOXdCLE9BQWIsQ0FBc0IsQ0FDbkM7QUFDQSxHQUFJb1YsT0FBTSxDQUFHLElBQWIsQ0FDQSxHQUFHcFYsT0FBTyxXQUFZeUksTUFBSyxDQUFDMkQsSUFBTixDQUFXMkMsVUFBakMsQ0FBNkMsQ0FDM0NxRyxNQUFNLENBQUdwVixPQUFULENBQ0FBLE9BQU8sQ0FBRyxFQUFWLENBQ0QsQ0FDREEsT0FBTyxDQUFHQSxPQUFPLEVBQUksRUFBckIsQ0FDQUEsT0FBTyxDQUFDb1YsTUFBUixDQUFpQkEsTUFBakIsQ0FDQXBWLE9BQU8sQ0FBQzh3QixFQUFSLENBQWFBLEVBQWIsQ0FDQXRhLEtBQUssQ0FBQ3pMLElBQU4sQ0FBV3liLE1BQVgsQ0FBbUJ4bUIsT0FBbkIsRUFDRCxDQVhELENBYUEsTUFBT3dtQixPQUFQLENBQ0QsQ0FHRCxLQUFPLENBdjhVRyxDQXc4VVYsUUF4OFVVLENBeThVVixLQUFPLFNBQVNsYyxNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7OztHQVNBLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBRUEsR0FBSWtzQixNQUFLLENBQUdwdUIsS0FBSyxDQUFDb3VCLEtBQU4sQ0FBY3B1QixLQUFLLENBQUNvdUIsS0FBTixFQUFlLEVBQXpDLENBRUEsR0FBSTFQLE9BQUosQ0FDQSxHQUFHMWUsS0FBSyxDQUFDMkQsSUFBTixDQUFXZ0MsUUFBWCxFQUF1QixDQUFDM0YsS0FBSyxDQUFDekksT0FBTixDQUFja00saUJBQXpDLENBQTRELENBQzFEaWIsTUFBTSxDQUFHeGMsbUJBQW1CLENBQUMsRUFBRCxDQUE1QixDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7OztHQWdCQUwsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDcXVCLE1BQU4sQ0FBZUQsS0FBSyxDQUFDQyxNQUFOLENBQWUsU0FDN0M5cUIsQ0FENkMsQ0FDMUNDLENBRDBDLENBQ3ZDaEIsQ0FEdUMsQ0FDcENtckIsS0FEb0MsQ0FDN0J0USxFQUQ2QixDQUN6QmxaLFFBRHlCLENBQ2YsQ0FDOUIsR0FBRyxNQUFPa1osR0FBUCxHQUFjLFVBQWpCLENBQTZCLENBQzNCbFosUUFBUSxDQUFHa1osRUFBWCxDQUNBQSxFQUFFLENBQUcsSUFBTCxDQUNELENBRUQ7QUFDQTtBQUNBLEdBQUdyZCxLQUFLLENBQUMyRCxJQUFOLENBQVdnQyxRQUFYLEVBQXVCLENBQUMzRixLQUFLLENBQUN6SSxPQUFOLENBQWNrTSxpQkFBdEMsRUFDRGliLE1BQU0sQ0FBQzJQLE1BRE4sR0FDaUJoUixFQUFFLEdBQUssSUFBUCxFQUFlLFFBQU9BLEVBQVAsSUFBYyxRQUQ5QyxJQUVBcUIsTUFBTSxDQUFDMlksVUFBUCxDQUFrQm4vQixNQUFsQixDQUEyQixDQUEzQixFQUFpQyxDQUFDbWxCLEVBQUQsRUFBT0EsRUFBRSxHQUFLLE1BRi9DLENBQUgsQ0FFNEQsQ0FDMUQsR0FBRyxNQUFPQSxHQUFQLEdBQWMsUUFBakIsQ0FBMkIsQ0FDekI7QUFDQUEsRUFBRSxDQUFHLE1BQUwsQ0FDRCxDQUNEOVosQ0FBQyxDQUFHLEdBQUltRCxPQUFKLENBQVduRCxDQUFYLENBQWMsUUFBZCxDQUFKLENBQ0FDLENBQUMsQ0FBRyxHQUFJa0QsT0FBSixDQUFXbEQsQ0FBWCxDQUFjLFFBQWQsQ0FBSixDQUNBLEdBQUcsQ0FBQ1csUUFBSixDQUFjLENBQ1osR0FBR3VhLE1BQU0sQ0FBQzJZLFVBQVAsQ0FBa0JuL0IsTUFBbEIsR0FBNkIsQ0FBaEMsQ0FBbUMsQ0FDakMsTUFBT3dtQixPQUFNLENBQUMyWSxVQUFQLENBQWtCOXpCLENBQWxCLENBQXFCQyxDQUFyQixDQUF3QmhCLENBQXhCLENBQTJCbXJCLEtBQTNCLEVBQWtDM3VCLFFBQWxDLENBQTJDLFFBQTNDLENBQVAsQ0FDRCxDQUNELE1BQU8wZixPQUFNLENBQUMyWSxVQUFQLENBQWtCOXpCLENBQWxCLENBQXFCQyxDQUFyQixDQUF3QmhCLENBQXhCLENBQTJCbXJCLEtBQTNCLENBQWtDdFEsRUFBbEMsRUFBc0NyZSxRQUF0QyxDQUErQyxRQUEvQyxDQUFQLENBQ0QsQ0FDRCxHQUFHMGYsTUFBTSxDQUFDMlksVUFBUCxDQUFrQm4vQixNQUFsQixHQUE2QixDQUFoQyxDQUFtQyxDQUNqQyxNQUFPd21CLE9BQU0sQ0FBQzJQLE1BQVAsQ0FBYzlxQixDQUFkLENBQWlCQyxDQUFqQixDQUFvQmhCLENBQXBCLENBQXVCbXJCLEtBQXZCLENBQThCLFNBQVMxWSxHQUFULENBQWNoYixHQUFkLENBQW1CLENBQ3RELEdBQUdnYixHQUFILENBQVEsQ0FDTixNQUFPOVEsU0FBUSxDQUFDOFEsR0FBRCxDQUFmLENBQ0QsQ0FDRDlRLFFBQVEsQ0FBQyxJQUFELENBQU9sSyxHQUFHLENBQUMrRSxRQUFKLENBQWEsUUFBYixDQUFQLENBQVIsQ0FDRCxDQUxNLENBQVAsQ0FNRCxDQUNELE1BQU8wZixPQUFNLENBQUMyUCxNQUFQLENBQWM5cUIsQ0FBZCxDQUFpQkMsQ0FBakIsQ0FBb0JoQixDQUFwQixDQUF1Qm1yQixLQUF2QixDQUE4QnRRLEVBQTlCLENBQWtDLFNBQVNwSSxHQUFULENBQWNoYixHQUFkLENBQW1CLENBQzFELEdBQUdnYixHQUFILENBQVEsQ0FDTixNQUFPOVEsU0FBUSxDQUFDOFEsR0FBRCxDQUFmLENBQ0QsQ0FDRDlRLFFBQVEsQ0FBQyxJQUFELENBQU9sSyxHQUFHLENBQUMrRSxRQUFKLENBQWEsUUFBYixDQUFQLENBQVIsQ0FDRCxDQUxNLENBQVAsQ0FNRCxDQUVELEdBQUcsTUFBT3FlLEdBQVAsR0FBYyxXQUFkLEVBQTZCQSxFQUFFLEdBQUssSUFBdkMsQ0FBNkMsQ0FDM0M7QUFDQUEsRUFBRSxDQUFHLE1BQUwsQ0FDRCxDQUNELEdBQUcsTUFBT0EsR0FBUCxHQUFjLFFBQWpCLENBQTJCLENBQ3pCLEdBQUcsRUFBRUEsRUFBRSxHQUFJcmQsTUFBSyxDQUFDcWQsRUFBTixDQUFTQyxVQUFqQixDQUFILENBQWlDLENBQy9CLEtBQU0sSUFBSXRsQixNQUFKLENBQVUsMkJBQTZCcWxCLEVBQXZDLENBQU4sQ0FDRCxDQUNEQSxFQUFFLENBQUdyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNBLEVBQVQsRUFBYTVpQixNQUFiLEVBQUwsQ0FDRCxDQUVELEdBQUk2OEIsS0FBSSxDQUFHamEsRUFBRSxDQUFDcVMsWUFBZCxDQUVBO1lBRUEsR0FBRy9CLEtBQUssQ0FBSSxXQUFhMkosSUFBekIsQ0FBZ0MsQ0FDOUIsR0FBSXJpQixJQUFHLENBQUcsR0FBSWpkLE1BQUosQ0FBVSwwQkFBVixDQUFWLENBQ0EsR0FBR21NLFFBQUgsQ0FBYSxDQUNYLE1BQU9BLFNBQVEsQ0FBQzhRLEdBQUQsQ0FBZixDQUNELENBQ0QsS0FBTUEsSUFBTixDQUNELENBRUQ7Ozs7O29DQU1BLEdBQUl2TCxJQUFHLENBQUc1SyxJQUFJLENBQUM4TCxJQUFMLENBQVUraUIsS0FBSyxDQUFHMkosSUFBbEIsQ0FBVixDQUNBLEdBQUkxVyxFQUFDLENBQUcrTSxLQUFLLENBQUcsQ0FBQ2prQixHQUFHLENBQUcsQ0FBUCxFQUFZNHRCLElBQTVCLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkF5QkEsR0FBSUMsSUFBRyxDQUFHdjNCLEtBQUssQ0FBQ3czQixJQUFOLENBQVcvOEIsTUFBWCxFQUFWLENBQ0E4OEIsR0FBRyxDQUFDeHBCLEtBQUosQ0FBVXNQLEVBQVYsQ0FBYzlaLENBQWQsRUFDQSxHQUFJNHFCLEdBQUUsQ0FBRyxFQUFULENBQ0EsR0FBSXNKLElBQUosQ0FBU0MsR0FBVCxDQUFjQyxJQUFkLENBRUE7QUFDQSxHQUFHLENBQUN4ekIsUUFBSixDQUFjLENBQ1osSUFBSSxHQUFJL0IsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxFQUFJc0gsR0FBcEIsQ0FBeUIsRUFBRXRILENBQTNCLENBQThCLENBQzVCO0FBQ0FtMUIsR0FBRyxDQUFDeHBCLEtBQUosQ0FBVSxJQUFWLENBQWdCLElBQWhCLEVBQ0F3cEIsR0FBRyxDQUFDdmpCLE1BQUosQ0FBV3hRLENBQVgsRUFDQSt6QixHQUFHLENBQUN2akIsTUFBSixDQUFXaFUsS0FBSyxDQUFDMkQsSUFBTixDQUFXeUksWUFBWCxDQUF3QmhLLENBQXhCLENBQVgsRUFDQXExQixHQUFHLENBQUdFLElBQUksQ0FBR0osR0FBRyxDQUFDdFgsTUFBSixHQUFhN1gsUUFBYixFQUFiLENBRUE7QUFDQSxJQUFJLEdBQUl3RixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLEVBQUlwTCxDQUFwQixDQUF1QixFQUFFb0wsQ0FBekIsQ0FBNEIsQ0FDMUIycEIsR0FBRyxDQUFDeHBCLEtBQUosQ0FBVSxJQUFWLENBQWdCLElBQWhCLEVBQ0F3cEIsR0FBRyxDQUFDdmpCLE1BQUosQ0FBVzJqQixJQUFYLEVBQ0FELEdBQUcsQ0FBR0gsR0FBRyxDQUFDdFgsTUFBSixHQUFhN1gsUUFBYixFQUFOLENBQ0E7QUFDQXF2QixHQUFHLENBQUd6M0IsS0FBSyxDQUFDMkQsSUFBTixDQUFXaUksUUFBWCxDQUFvQjZyQixHQUFwQixDQUF5QkMsR0FBekIsQ0FBOEJKLElBQTlCLENBQU4sQ0FDQUssSUFBSSxDQUFHRCxHQUFQLENBQ0QsQ0FFRDs7O29EQUlBdkosRUFBRSxFQUFLL3JCLENBQUMsQ0FBR3NILEdBQUwsQ0FBWSt0QixHQUFaLENBQWtCQSxHQUFHLENBQUN4NEIsTUFBSixDQUFXLENBQVgsQ0FBYzJoQixDQUFkLENBQXhCLENBQ0QsQ0FDRCxtQ0FDQSxNQUFPdU4sR0FBUCxDQUNELENBRUQ7QUFDQSxHQUFJL3JCLEVBQUMsQ0FBRyxDQUFSLENBQVd3TCxDQUFYLENBQ0EsUUFBU2dxQixNQUFULEVBQWlCLENBQ2YsR0FBR3gxQixDQUFDLENBQUdzSCxHQUFQLENBQVksQ0FDVjtBQUNBLE1BQU92RixTQUFRLENBQUMsSUFBRCxDQUFPZ3FCLEVBQVAsQ0FBZixDQUNELENBRUQ7QUFDQW9KLEdBQUcsQ0FBQ3hwQixLQUFKLENBQVUsSUFBVixDQUFnQixJQUFoQixFQUNBd3BCLEdBQUcsQ0FBQ3ZqQixNQUFKLENBQVd4USxDQUFYLEVBQ0ErekIsR0FBRyxDQUFDdmpCLE1BQUosQ0FBV2hVLEtBQUssQ0FBQzJELElBQU4sQ0FBV3lJLFlBQVgsQ0FBd0JoSyxDQUF4QixDQUFYLEVBQ0FxMUIsR0FBRyxDQUFHRSxJQUFJLENBQUdKLEdBQUcsQ0FBQ3RYLE1BQUosR0FBYTdYLFFBQWIsRUFBYixDQUVBO0FBQ0F3RixDQUFDLENBQUcsQ0FBSixDQUNBaXFCLEtBQUssR0FDTixDQUVELFFBQVNBLE1BQVQsRUFBaUIsQ0FDZixHQUFHanFCLENBQUMsRUFBSXBMLENBQVIsQ0FBVyxDQUNUKzBCLEdBQUcsQ0FBQ3hwQixLQUFKLENBQVUsSUFBVixDQUFnQixJQUFoQixFQUNBd3BCLEdBQUcsQ0FBQ3ZqQixNQUFKLENBQVcyakIsSUFBWCxFQUNBRCxHQUFHLENBQUdILEdBQUcsQ0FBQ3RYLE1BQUosR0FBYTdYLFFBQWIsRUFBTixDQUNBO0FBQ0FxdkIsR0FBRyxDQUFHejNCLEtBQUssQ0FBQzJELElBQU4sQ0FBV2lJLFFBQVgsQ0FBb0I2ckIsR0FBcEIsQ0FBeUJDLEdBQXpCLENBQThCSixJQUE5QixDQUFOLENBQ0FLLElBQUksQ0FBR0QsR0FBUCxDQUNBLEVBQUU5cEIsQ0FBRixDQUNBLE1BQU81TixNQUFLLENBQUMyRCxJQUFOLENBQVdJLFlBQVgsQ0FBd0I4ekIsS0FBeEIsQ0FBUCxDQUNELENBRUQ7OztrREFJQTFKLEVBQUUsRUFBSy9yQixDQUFDLENBQUdzSCxHQUFMLENBQVkrdEIsR0FBWixDQUFrQkEsR0FBRyxDQUFDeDRCLE1BQUosQ0FBVyxDQUFYLENBQWMyaEIsQ0FBZCxDQUF4QixDQUVBLEVBQUV4ZSxDQUFGLENBQ0F3MUIsS0FBSyxHQUNOLENBRURBLEtBQUssR0FDTixDQTdLRCxDQWdMQSxLQUFPLENBaHFWRyxDQWlxVlYsUUFqcVZVLENBa3FWVixLQUFPLFNBQVMvMUIsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7Ozs7R0FTQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQSxjQUNBLEdBQUlzMUIsS0FBSSxDQUFHMzFCLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVCLEtBQUssQ0FBQ3czQixJQUFOLENBQWF4M0IsS0FBSyxDQUFDdzNCLElBQU4sRUFBYyxFQUF2RCxDQUVBOzs7O0dBS0FBLElBQUksQ0FBQy84QixNQUFMLENBQWMsVUFBVyxDQUN2QjtBQUNBLEdBQUlxOUIsS0FBSSxDQUFHLElBQVgsQ0FFQTtBQUNBLEdBQUlDLElBQUcsQ0FBRyxJQUFWLENBRUE7QUFDQSxHQUFJQyxVQUFTLENBQUcsSUFBaEIsQ0FFQTtBQUNBLEdBQUlDLFVBQVMsQ0FBRyxJQUFoQixDQUVBO0FBQ0EsR0FBSTdaLElBQUcsQ0FBRyxFQUFWLENBRUE7Ozs7Ozs7S0FRQUEsR0FBRyxDQUFDclEsS0FBSixDQUFZLFNBQVNzUCxFQUFULENBQWFwakIsR0FBYixDQUFrQixDQUM1QixHQUFHb2pCLEVBQUUsR0FBSyxJQUFWLENBQWdCLENBQ2QsR0FBRyxNQUFPQSxHQUFQLEdBQWMsUUFBakIsQ0FBMkIsQ0FDekI7QUFDQUEsRUFBRSxDQUFHQSxFQUFFLENBQUN0ZCxXQUFILEVBQUwsQ0FDQSxHQUFHc2QsRUFBRSxHQUFJcmQsTUFBSyxDQUFDcWQsRUFBTixDQUFTQyxVQUFsQixDQUE4QixDQUM1QnlhLEdBQUcsQ0FBRy8zQixLQUFLLENBQUNxZCxFQUFOLENBQVNDLFVBQVQsQ0FBb0JELEVBQXBCLEVBQXdCNWlCLE1BQXhCLEVBQU4sQ0FDRCxDQUZELElBRU8sQ0FDTCxLQUFNLElBQUl6QyxNQUFKLENBQVUsMkJBQTZCcWxCLEVBQTdCLENBQWtDLEdBQTVDLENBQU4sQ0FDRCxDQUNGLENBUkQsSUFRTyxDQUNMO0FBQ0EwYSxHQUFHLENBQUcxYSxFQUFOLENBQ0QsQ0FDRixDQUVELEdBQUdwakIsR0FBRyxHQUFLLElBQVgsQ0FBaUIsQ0FDZjtBQUNBQSxHQUFHLENBQUc2OUIsSUFBTixDQUNELENBSEQsSUFHTyxDQUNMLEdBQUcsTUFBTzc5QixJQUFQLEdBQWUsUUFBbEIsQ0FBNEIsQ0FDMUI7QUFDQUEsR0FBRyxDQUFHK0YsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QnRQLEdBQXhCLENBQU4sQ0FDRCxDQUhELElBR08sSUFBRytGLEtBQUssQ0FBQzJELElBQU4sQ0FBV21DLE9BQVgsQ0FBbUI3TCxHQUFuQixDQUFILENBQTRCLENBQ2pDO0FBQ0EsR0FBSXVkLElBQUcsQ0FBR3ZkLEdBQVYsQ0FDQUEsR0FBRyxDQUFHK0YsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUFOLENBQ0EsSUFBSSxHQUFJbkgsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHb1YsR0FBRyxDQUFDdGYsTUFBdkIsQ0FBK0IsRUFBRWtLLENBQWpDLENBQW9DLENBQ2xDbkksR0FBRyxDQUFDK00sT0FBSixDQUFZd1EsR0FBRyxDQUFDcFYsQ0FBRCxDQUFmLEVBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBSTgxQixPQUFNLENBQUdqK0IsR0FBRyxDQUFDL0IsTUFBSixFQUFiLENBQ0EsR0FBR2dnQyxNQUFNLENBQUdILEdBQUcsQ0FBQ3BJLFdBQWhCLENBQTZCLENBQzNCb0ksR0FBRyxDQUFDaHFCLEtBQUosR0FDQWdxQixHQUFHLENBQUMvakIsTUFBSixDQUFXL1osR0FBRyxDQUFDc04sS0FBSixFQUFYLEVBQ0F0TixHQUFHLENBQUc4OUIsR0FBRyxDQUFDOVgsTUFBSixFQUFOLENBQ0QsQ0FFRDtBQUNBO0FBQ0E7QUFDQStYLFNBQVMsQ0FBR2g0QixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQVosQ0FDQTB1QixTQUFTLENBQUdqNEIsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUFaLENBQ0EydUIsTUFBTSxDQUFHaitCLEdBQUcsQ0FBQy9CLE1BQUosRUFBVCxDQUNBLElBQUksR0FBSWtLLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzgxQixNQUFuQixDQUEyQixFQUFFOTFCLENBQTdCLENBQWdDLENBQzlCLEdBQUlvVixJQUFHLENBQUd2ZCxHQUFHLENBQUNtUCxFQUFKLENBQU9oSCxDQUFQLENBQVYsQ0FDQTQxQixTQUFTLENBQUNoeEIsT0FBVixDQUFrQixLQUFPd1EsR0FBekIsRUFDQXlnQixTQUFTLENBQUNqeEIsT0FBVixDQUFrQixLQUFPd1EsR0FBekIsRUFDRCxDQUVEO0FBQ0EsR0FBRzBnQixNQUFNLENBQUdILEdBQUcsQ0FBQ3BJLFdBQWhCLENBQTZCLENBQzNCLEdBQUluWSxJQUFHLENBQUd1Z0IsR0FBRyxDQUFDcEksV0FBSixDQUFrQnVJLE1BQTVCLENBQ0EsSUFBSSxHQUFJOTFCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR29WLEdBQW5CLENBQXdCLEVBQUVwVixDQUExQixDQUE2QixDQUMzQjQxQixTQUFTLENBQUNoeEIsT0FBVixDQUFrQixJQUFsQixFQUNBaXhCLFNBQVMsQ0FBQ2p4QixPQUFWLENBQWtCLElBQWxCLEVBQ0QsQ0FDRixDQUNEOHdCLElBQUksQ0FBRzc5QixHQUFQLENBQ0ErOUIsU0FBUyxDQUFHQSxTQUFTLENBQUN6d0IsS0FBVixFQUFaLENBQ0Ewd0IsU0FBUyxDQUFHQSxTQUFTLENBQUMxd0IsS0FBVixFQUFaLENBQ0QsQ0FFRDtBQUVBO0FBQ0E7QUFDQXd3QixHQUFHLENBQUNocUIsS0FBSixHQUNBZ3FCLEdBQUcsQ0FBQy9qQixNQUFKLENBQVdna0IsU0FBWCxFQUNELENBdkVELENBeUVBOzs7O0tBS0E1WixHQUFHLENBQUNwSyxNQUFKLENBQWEsU0FBU3pNLEtBQVQsQ0FBZ0IsQ0FDM0J3d0IsR0FBRyxDQUFDL2pCLE1BQUosQ0FBV3pNLEtBQVgsRUFDRCxDQUZELENBSUE7Ozs7S0FLQTZXLEdBQUcsQ0FBQytaLE1BQUosQ0FBYSxVQUFXLENBQ3RCO0FBQ0E7QUFDQSxHQUFJTixNQUFLLENBQUdFLEdBQUcsQ0FBQzlYLE1BQUosR0FBYTFZLEtBQWIsRUFBWixDQUNBd3dCLEdBQUcsQ0FBQ2hxQixLQUFKLEdBQ0FncUIsR0FBRyxDQUFDL2pCLE1BQUosQ0FBV2lrQixTQUFYLEVBQ0FGLEdBQUcsQ0FBQy9qQixNQUFKLENBQVc2akIsS0FBWCxFQUNBLE1BQU9FLElBQUcsQ0FBQzlYLE1BQUosRUFBUCxDQUNELENBUkQsQ0FTQTtBQUNBN0IsR0FBRyxDQUFDNkIsTUFBSixDQUFhN0IsR0FBRyxDQUFDK1osTUFBakIsQ0FFQSxNQUFPL1osSUFBUCxDQUNELENBNUhELENBK0hBLEtBQU8sQ0F4elZHLENBeXpWVixRQXp6VlUsQ0EwelZWLEtBQU8sU0FBU3ZjLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCLENBRWpDLGVBRmlDLENBSWpDLEtBQU8sQ0E5elZHLENBK3pWVixRQS96VlUsQ0FnMFZWLEtBQU8sU0FBU0MsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7OztFQVJzRCxDQWN0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0Fkc0QsQ0E0Q3REOzs7OztFQU1BLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBRUFMLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVCLEtBQUssQ0FBQ3NmLElBQU4sQ0FBYXRmLEtBQUssQ0FBQ3NmLElBQU4sRUFBYyxFQUE1QyxDQUVBO0FBQ0EsR0FBSThZLE1BQUosQ0FFQTtBQUNBLEdBQUlDLE9BQU0sQ0FBRyxjQUFiLENBQ0EsR0FBSUMsS0FBSSxDQUFJLENBQUNELE1BQU0sQ0FBQyxRQUFSLEdBQW1CLFFBQS9CLENBRUE7QUFDQSxRQUFTaFosV0FBVCxDQUFvQmlNLENBQXBCLENBQXNCOWtCLENBQXRCLENBQXdCaEUsQ0FBeEIsQ0FBMkIsQ0FDekIsS0FBSzFJLElBQUwsQ0FBWSxFQUFaLENBQ0EsR0FBR3d4QixDQUFDLEVBQUksSUFBUixDQUNFLEdBQUcsVUFBWSxNQUFPQSxFQUF0QixDQUF5QixLQUFLaU4sVUFBTCxDQUFnQmpOLENBQWhCLENBQWtCOWtCLENBQWxCLENBQW9CaEUsQ0FBcEIsRUFBekIsSUFDSyxJQUFHZ0UsQ0FBQyxFQUFJLElBQUwsRUFBYSxVQUFZLE1BQU84a0IsRUFBbkMsQ0FBc0MsS0FBS2tOLFVBQUwsQ0FBZ0JsTixDQUFoQixDQUFrQixHQUFsQixFQUF0QyxJQUNBLE1BQUtrTixVQUFMLENBQWdCbE4sQ0FBaEIsQ0FBa0I5a0IsQ0FBbEIsRUFDUixDQUNEeEcsS0FBSyxDQUFDc2YsSUFBTixDQUFXRCxVQUFYLENBQXdCQSxVQUF4QixDQUVBO0FBQ0EsUUFBU29aLElBQVQsRUFBZSxDQUFFLE1BQU8sSUFBSXBaLFdBQUosQ0FBZSxJQUFmLENBQVAsQ0FBOEIsQ0FFL0M7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFTcVosSUFBVCxDQUFhdDJCLENBQWIsQ0FBZTJELENBQWYsQ0FBaUIya0IsQ0FBakIsQ0FBbUI5YyxDQUFuQixDQUFxQnBMLENBQXJCLENBQXVCTyxDQUF2QixDQUEwQixDQUN4QixNQUFNLEVBQUVBLENBQUYsRUFBTyxDQUFiLENBQWdCLENBQ2QsR0FBSW9aLEVBQUMsQ0FBR3BXLENBQUMsQ0FBQyxLQUFLak0sSUFBTCxDQUFVc0ksQ0FBQyxFQUFYLENBQUYsQ0FBaUJzb0IsQ0FBQyxDQUFDNXdCLElBQUYsQ0FBTzhULENBQVAsQ0FBakIsQ0FBMkJwTCxDQUFuQyxDQUNBQSxDQUFDLENBQUcxRCxJQUFJLENBQUNpVyxLQUFMLENBQVdvSCxDQUFDLENBQUMsU0FBYixDQUFKLENBQ0F1TyxDQUFDLENBQUM1d0IsSUFBRixDQUFPOFQsQ0FBQyxFQUFSLEVBQWN1TyxDQUFDLENBQUMsU0FBaEIsQ0FDRCxDQUNELE1BQU8zWixFQUFQLENBQ0QsQ0FDRDtBQUNBO0FBQ0E7QUFDQSxRQUFTbTJCLElBQVQsQ0FBYXYyQixDQUFiLENBQWUyRCxDQUFmLENBQWlCMmtCLENBQWpCLENBQW1COWMsQ0FBbkIsQ0FBcUJwTCxDQUFyQixDQUF1Qk8sQ0FBdkIsQ0FBMEIsQ0FDeEIsR0FBSTYxQixHQUFFLENBQUc3eUIsQ0FBQyxDQUFDLE1BQVgsQ0FBbUI4eUIsRUFBRSxDQUFHOXlCLENBQUMsRUFBRSxFQUEzQixDQUNBLE1BQU0sRUFBRWhELENBQUYsRUFBTyxDQUFiLENBQWdCLENBQ2QsR0FBSVYsRUFBQyxDQUFHLEtBQUt2SSxJQUFMLENBQVVzSSxDQUFWLEVBQWEsTUFBckIsQ0FDQSxHQUFJcXlCLEVBQUMsQ0FBRyxLQUFLMzZCLElBQUwsQ0FBVXNJLENBQUMsRUFBWCxHQUFnQixFQUF4QixDQUNBLEdBQUlHLEVBQUMsQ0FBR3MyQixFQUFFLENBQUN4MkIsQ0FBSCxDQUFLb3lCLENBQUMsQ0FBQ21FLEVBQWYsQ0FDQXYyQixDQUFDLENBQUd1MkIsRUFBRSxDQUFDdjJCLENBQUgsRUFBTSxDQUFDRSxDQUFDLENBQUMsTUFBSCxHQUFZLEVBQWxCLEVBQXNCbW9CLENBQUMsQ0FBQzV3QixJQUFGLENBQU84VCxDQUFQLENBQXRCLEVBQWlDcEwsQ0FBQyxDQUFDLFVBQW5DLENBQUosQ0FDQUEsQ0FBQyxDQUFHLENBQUNILENBQUMsR0FBRyxFQUFMLEdBQVVFLENBQUMsR0FBRyxFQUFkLEVBQWtCczJCLEVBQUUsQ0FBQ3BFLENBQXJCLEVBQXdCanlCLENBQUMsR0FBRyxFQUE1QixDQUFKLENBQ0Frb0IsQ0FBQyxDQUFDNXdCLElBQUYsQ0FBTzhULENBQUMsRUFBUixFQUFjdkwsQ0FBQyxDQUFDLFVBQWhCLENBQ0QsQ0FDRCxNQUFPRyxFQUFQLENBQ0QsQ0FDRDtBQUNBO0FBQ0EsUUFBU3MyQixJQUFULENBQWExMkIsQ0FBYixDQUFlMkQsQ0FBZixDQUFpQjJrQixDQUFqQixDQUFtQjljLENBQW5CLENBQXFCcEwsQ0FBckIsQ0FBdUJPLENBQXZCLENBQTBCLENBQ3hCLEdBQUk2MUIsR0FBRSxDQUFHN3lCLENBQUMsQ0FBQyxNQUFYLENBQW1COHlCLEVBQUUsQ0FBRzl5QixDQUFDLEVBQUUsRUFBM0IsQ0FDQSxNQUFNLEVBQUVoRCxDQUFGLEVBQU8sQ0FBYixDQUFnQixDQUNkLEdBQUlWLEVBQUMsQ0FBRyxLQUFLdkksSUFBTCxDQUFVc0ksQ0FBVixFQUFhLE1BQXJCLENBQ0EsR0FBSXF5QixFQUFDLENBQUcsS0FBSzM2QixJQUFMLENBQVVzSSxDQUFDLEVBQVgsR0FBZ0IsRUFBeEIsQ0FDQSxHQUFJRyxFQUFDLENBQUdzMkIsRUFBRSxDQUFDeDJCLENBQUgsQ0FBS295QixDQUFDLENBQUNtRSxFQUFmLENBQ0F2MkIsQ0FBQyxDQUFHdTJCLEVBQUUsQ0FBQ3YyQixDQUFILEVBQU0sQ0FBQ0UsQ0FBQyxDQUFDLE1BQUgsR0FBWSxFQUFsQixFQUFzQm1vQixDQUFDLENBQUM1d0IsSUFBRixDQUFPOFQsQ0FBUCxDQUF0QixDQUFnQ3BMLENBQXBDLENBQ0FBLENBQUMsQ0FBRyxDQUFDSCxDQUFDLEVBQUUsRUFBSixHQUFTRSxDQUFDLEVBQUUsRUFBWixFQUFnQnMyQixFQUFFLENBQUNwRSxDQUF2QixDQUNBL0osQ0FBQyxDQUFDNXdCLElBQUYsQ0FBTzhULENBQUMsRUFBUixFQUFjdkwsQ0FBQyxDQUFDLFNBQWhCLENBQ0QsQ0FDRCxNQUFPRyxFQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUcsTUFBTzBSLFVBQVAsR0FBc0IsV0FBekIsQ0FDQSxDQUNHbUwsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjAxQixFQUFyQixDQUEwQkQsR0FBMUIsQ0FDQVYsS0FBSyxDQUFHLEVBQVIsQ0FDRixDQUpELElBSU8sSUFBR0UsSUFBSSxFQUFLcGtCLFNBQVMsQ0FBQ2pjLE9BQVYsRUFBcUIsNkJBQWpDLENBQWlFLENBQ3RFb25CLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUIwMUIsRUFBckIsQ0FBMEJKLEdBQTFCLENBQ0FQLEtBQUssQ0FBRyxFQUFSLENBQ0QsQ0FITSxJQUdBLElBQUdFLElBQUksRUFBS3BrQixTQUFTLENBQUNqYyxPQUFWLEVBQXFCLFVBQWpDLENBQThDLENBQ25Eb25CLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUIwMUIsRUFBckIsQ0FBMEJMLEdBQTFCLENBQ0FOLEtBQUssQ0FBRyxFQUFSLENBQ0QsQ0FITSxJQUdBLENBQUU7QUFDUC9ZLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUIwMUIsRUFBckIsQ0FBMEJELEdBQTFCLENBQ0FWLEtBQUssQ0FBRyxFQUFSLENBQ0QsQ0FFRC9ZLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUIyMUIsRUFBckIsQ0FBMEJaLEtBQTFCLENBQ0EvWSxVQUFVLENBQUNoYyxTQUFYLENBQXFCNDFCLEVBQXJCLENBQTJCLENBQUMsR0FBR2IsS0FBSixFQUFXLENBQXRDLENBQ0EvWSxVQUFVLENBQUNoYyxTQUFYLENBQXFCNjFCLEVBQXJCLENBQTJCLEdBQUdkLEtBQTlCLENBRUEsR0FBSWUsTUFBSyxDQUFHLEVBQVosQ0FDQTlaLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUIrMUIsRUFBckIsQ0FBMEJ0NkIsSUFBSSxDQUFDczFCLEdBQUwsQ0FBUyxDQUFULENBQVcrRSxLQUFYLENBQTFCLENBQ0E5WixVQUFVLENBQUNoYyxTQUFYLENBQXFCZzJCLEVBQXJCLENBQTBCRixLQUFLLENBQUNmLEtBQWhDLENBQ0EvWSxVQUFVLENBQUNoYyxTQUFYLENBQXFCaTJCLEVBQXJCLENBQTBCLEVBQUVsQixLQUFGLENBQVFlLEtBQWxDLENBRUE7QUFDQSxHQUFJSSxNQUFLLENBQUcsc0NBQVosQ0FDQSxHQUFJQyxNQUFLLENBQUcsR0FBSXBoQyxNQUFKLEVBQVosQ0FDQSxHQUFJcWhDLEdBQUosQ0FBT0MsRUFBUCxDQUNBRCxFQUFFLENBQUcsSUFBSW54QixVQUFKLENBQWUsQ0FBZixDQUFMLENBQ0EsSUFBSW94QixFQUFFLENBQUcsQ0FBVCxDQUFZQSxFQUFFLEVBQUksQ0FBbEIsQ0FBcUIsRUFBRUEsRUFBdkIsRUFBMkJGLEtBQUssQ0FBQ0MsRUFBRSxFQUFILENBQUwsQ0FBY0MsRUFBZCxDQUEzQixDQUNBRCxFQUFFLENBQUcsSUFBSW54QixVQUFKLENBQWUsQ0FBZixDQUFMLENBQ0EsSUFBSW94QixFQUFFLENBQUcsRUFBVCxDQUFhQSxFQUFFLENBQUcsRUFBbEIsQ0FBc0IsRUFBRUEsRUFBeEIsRUFBNEJGLEtBQUssQ0FBQ0MsRUFBRSxFQUFILENBQUwsQ0FBY0MsRUFBZCxDQUE1QixDQUNBRCxFQUFFLENBQUcsSUFBSW54QixVQUFKLENBQWUsQ0FBZixDQUFMLENBQ0EsSUFBSW94QixFQUFFLENBQUcsRUFBVCxDQUFhQSxFQUFFLENBQUcsRUFBbEIsQ0FBc0IsRUFBRUEsRUFBeEIsRUFBNEJGLEtBQUssQ0FBQ0MsRUFBRSxFQUFILENBQUwsQ0FBY0MsRUFBZCxDQUE1QixDQUVBLFFBQVNDLFNBQVQsQ0FBa0I1MkIsQ0FBbEIsQ0FBcUIsQ0FBRSxNQUFPdzJCLE1BQUssQ0FBQ3hzQixNQUFOLENBQWFoSyxDQUFiLENBQVAsQ0FBeUIsQ0FDaEQsUUFBUzYyQixNQUFULENBQWVwMkIsQ0FBZixDQUFpQnBCLENBQWpCLENBQW9CLENBQ2xCLEdBQUlJLEVBQUMsQ0FBR2czQixLQUFLLENBQUNoMkIsQ0FBQyxDQUFDOEUsVUFBRixDQUFhbEcsQ0FBYixDQUFELENBQWIsQ0FDQSxNQUFRSSxFQUFDLEVBQUUsSUFBSixDQUFVLENBQUMsQ0FBWCxDQUFhQSxDQUFwQixDQUNELENBRUQ7QUFDQSxRQUFTcTNCLFVBQVQsQ0FBbUJqWixDQUFuQixDQUFzQixDQUNwQixJQUFJLEdBQUl4ZSxFQUFDLENBQUcsS0FBSzRKLENBQUwsQ0FBTyxDQUFuQixDQUFzQjVKLENBQUMsRUFBSSxDQUEzQixDQUE4QixFQUFFQSxDQUFoQyxFQUFtQ3dlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFQLEVBQVksS0FBS3RJLElBQUwsQ0FBVXNJLENBQVYsQ0FBWixDQUFuQyxDQUNBd2UsQ0FBQyxDQUFDNVUsQ0FBRixDQUFNLEtBQUtBLENBQVgsQ0FDQTRVLENBQUMsQ0FBQ3BkLENBQUYsQ0FBTSxLQUFLQSxDQUFYLENBQ0QsQ0FFRDtBQUNBLFFBQVNzMkIsV0FBVCxDQUFvQi96QixDQUFwQixDQUF1QixDQUNyQixLQUFLaUcsQ0FBTCxDQUFTLENBQVQsQ0FDQSxLQUFLeEksQ0FBTCxDQUFVdUMsQ0FBQyxDQUFDLENBQUgsQ0FBTSxDQUFDLENBQVAsQ0FBUyxDQUFsQixDQUNBLEdBQUdBLENBQUMsQ0FBRyxDQUFQLENBQVUsS0FBS2pNLElBQUwsQ0FBVSxDQUFWLEVBQWVpTSxDQUFmLENBQVYsSUFDSyxJQUFHQSxDQUFDLENBQUcsQ0FBQyxDQUFSLENBQVcsS0FBS2pNLElBQUwsQ0FBVSxDQUFWLEVBQWVpTSxDQUFDLENBQUMsS0FBS216QixFQUF0QixDQUFYLElBQ0EsTUFBS2x0QixDQUFMLENBQVMsQ0FBVCxDQUNOLENBRUQ7QUFDQSxRQUFTK3RCLElBQVQsQ0FBYTMzQixDQUFiLENBQWdCLENBQUUsR0FBSXdlLEVBQUMsQ0FBRzZYLEdBQUcsRUFBWCxDQUFlN1gsQ0FBQyxDQUFDNEIsT0FBRixDQUFVcGdCLENBQVYsRUFBYyxNQUFPd2UsRUFBUCxDQUFXLENBRTFEO0FBQ0EsUUFBU29aLGNBQVQsQ0FBdUJ4MkIsQ0FBdkIsQ0FBeUJnRCxDQUF6QixDQUE0QixDQUMxQixHQUFJOUgsRUFBSixDQUNBLEdBQUc4SCxDQUFDLEVBQUksRUFBUixDQUFZOUgsQ0FBQyxDQUFHLENBQUosQ0FBWixJQUNLLElBQUc4SCxDQUFDLEVBQUksQ0FBUixDQUFXOUgsQ0FBQyxDQUFHLENBQUosQ0FBWCxJQUNBLElBQUc4SCxDQUFDLEVBQUksR0FBUixDQUFhOUgsQ0FBQyxDQUFHLENBQUosQ0FBTztBQUFwQixJQUNBLElBQUc4SCxDQUFDLEVBQUksQ0FBUixDQUFXOUgsQ0FBQyxDQUFHLENBQUosQ0FBWCxJQUNBLElBQUc4SCxDQUFDLEVBQUksRUFBUixDQUFZOUgsQ0FBQyxDQUFHLENBQUosQ0FBWixJQUNBLElBQUc4SCxDQUFDLEVBQUksQ0FBUixDQUFXOUgsQ0FBQyxDQUFHLENBQUosQ0FBWCxJQUNBLENBQUUsS0FBS3U3QixTQUFMLENBQWV6MkIsQ0FBZixDQUFpQmdELENBQWpCLEVBQXFCLE9BQVMsQ0FDckMsS0FBS3dGLENBQUwsQ0FBUyxDQUFULENBQ0EsS0FBS3hJLENBQUwsQ0FBUyxDQUFULENBQ0EsR0FBSXBCLEVBQUMsQ0FBR29CLENBQUMsQ0FBQ3RMLE1BQVYsQ0FBa0JnaUMsRUFBRSxDQUFHLEtBQXZCLENBQThCQyxFQUFFLENBQUcsQ0FBbkMsQ0FDQSxNQUFNLEVBQUUvM0IsQ0FBRixFQUFPLENBQWIsQ0FBZ0IsQ0FDZCxHQUFJMkQsRUFBQyxDQUFJckgsQ0FBQyxFQUFFLENBQUosQ0FBTzhFLENBQUMsQ0FBQ3BCLENBQUQsQ0FBRCxDQUFLLElBQVosQ0FBaUJ3M0IsS0FBSyxDQUFDcDJCLENBQUQsQ0FBR3BCLENBQUgsQ0FBOUIsQ0FDQSxHQUFHMkQsQ0FBQyxDQUFHLENBQVAsQ0FBVSxDQUNSLEdBQUd2QyxDQUFDLENBQUN1SixNQUFGLENBQVMzSyxDQUFULEdBQWUsR0FBbEIsQ0FBdUI4M0IsRUFBRSxDQUFHLElBQUwsQ0FDdkIsU0FDRCxDQUNEQSxFQUFFLENBQUcsS0FBTCxDQUNBLEdBQUdDLEVBQUUsRUFBSSxDQUFULENBQ0UsS0FBS3JnQyxJQUFMLENBQVUsS0FBS2tTLENBQUwsRUFBVixFQUFzQmpHLENBQXRCLENBREYsSUFFSyxJQUFHbzBCLEVBQUUsQ0FBQ3o3QixDQUFILENBQU8sS0FBS3M2QixFQUFmLENBQW1CLENBQ3RCLEtBQUtsL0IsSUFBTCxDQUFVLEtBQUtrUyxDQUFMLENBQU8sQ0FBakIsR0FBdUIsQ0FBQ2pHLENBQUMsQ0FBRSxDQUFDLEdBQUksS0FBS2l6QixFQUFMLENBQVFtQixFQUFiLEVBQWtCLENBQXRCLEdBQTJCQSxFQUFsRCxDQUNBLEtBQUtyZ0MsSUFBTCxDQUFVLEtBQUtrUyxDQUFMLEVBQVYsRUFBdUJqRyxDQUFDLEVBQUcsS0FBS2l6QixFQUFMLENBQVFtQixFQUFuQyxDQUNELENBSEksSUFJSCxNQUFLcmdDLElBQUwsQ0FBVSxLQUFLa1MsQ0FBTCxDQUFPLENBQWpCLEdBQXVCakcsQ0FBQyxFQUFFbzBCLEVBQTFCLENBQ0ZBLEVBQUUsRUFBSXo3QixDQUFOLENBQ0EsR0FBR3k3QixFQUFFLEVBQUksS0FBS25CLEVBQWQsQ0FBa0JtQixFQUFFLEVBQUksS0FBS25CLEVBQVgsQ0FDbkIsQ0FDRCxHQUFHdDZCLENBQUMsRUFBSSxDQUFMLEVBQVUsQ0FBQzhFLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBSyxJQUFOLEdBQWUsQ0FBNUIsQ0FBK0IsQ0FDN0IsS0FBS0EsQ0FBTCxDQUFTLENBQUMsQ0FBVixDQUNBLEdBQUcyMkIsRUFBRSxDQUFHLENBQVIsQ0FBVyxLQUFLcmdDLElBQUwsQ0FBVSxLQUFLa1MsQ0FBTCxDQUFPLENBQWpCLEdBQXdCLENBQUMsR0FBSSxLQUFLZ3RCLEVBQUwsQ0FBUW1CLEVBQWIsRUFBa0IsQ0FBbkIsRUFBdUJBLEVBQTlDLENBQ1osQ0FDRCxLQUFLQyxLQUFMLEdBQ0EsR0FBR0YsRUFBSCxDQUFPN2EsVUFBVSxDQUFDZ2IsSUFBWCxDQUFnQkMsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsSUFBM0IsRUFDUixDQUVEO0FBQ0EsUUFBU0MsU0FBVCxFQUFvQixDQUNsQixHQUFJLzNCLEVBQUMsQ0FBRyxLQUFLZ0IsQ0FBTCxDQUFPLEtBQUt5MUIsRUFBcEIsQ0FDQSxNQUFNLEtBQUtqdEIsQ0FBTCxDQUFTLENBQVQsRUFBYyxLQUFLbFMsSUFBTCxDQUFVLEtBQUtrUyxDQUFMLENBQU8sQ0FBakIsR0FBdUJ4SixDQUEzQyxFQUE4QyxFQUFFLEtBQUt3SixDQUFQLENBQTlDLENBQ0QsQ0FFRDtBQUNBLFFBQVN3dUIsV0FBVCxDQUFvQmgwQixDQUFwQixDQUF1QixDQUNyQixHQUFHLEtBQUtoRCxDQUFMLENBQVMsQ0FBWixDQUFlLE1BQU8sSUFBSSxLQUFLaTNCLE1BQUwsR0FBY3o3QixRQUFkLENBQXVCd0gsQ0FBdkIsQ0FBWCxDQUNmLEdBQUk5SCxFQUFKLENBQ0EsR0FBRzhILENBQUMsRUFBSSxFQUFSLENBQVk5SCxDQUFDLENBQUcsQ0FBSixDQUFaLElBQ0ssSUFBRzhILENBQUMsRUFBSSxDQUFSLENBQVc5SCxDQUFDLENBQUcsQ0FBSixDQUFYLElBQ0EsSUFBRzhILENBQUMsRUFBSSxDQUFSLENBQVc5SCxDQUFDLENBQUcsQ0FBSixDQUFYLElBQ0EsSUFBRzhILENBQUMsRUFBSSxFQUFSLENBQVk5SCxDQUFDLENBQUcsQ0FBSixDQUFaLElBQ0EsSUFBRzhILENBQUMsRUFBSSxDQUFSLENBQVc5SCxDQUFDLENBQUcsQ0FBSixDQUFYLElBQ0EsT0FBTyxNQUFLZzhCLE9BQUwsQ0FBYWwwQixDQUFiLENBQVAsQ0FDTCxHQUFJaEosR0FBRSxDQUFHLENBQUMsR0FBR2tCLENBQUosRUFBTyxDQUFoQixDQUFtQitELENBQW5CLENBQXNCRixDQUFDLENBQUcsS0FBMUIsQ0FBaUNxZSxDQUFDLENBQUcsRUFBckMsQ0FBeUN4ZSxDQUFDLENBQUcsS0FBSzRKLENBQWxELENBQ0EsR0FBSXpJLEVBQUMsQ0FBRyxLQUFLeTFCLEVBQUwsQ0FBUzUyQixDQUFDLENBQUMsS0FBSzQyQixFQUFSLENBQVl0NkIsQ0FBNUIsQ0FDQSxHQUFHMEQsQ0FBQyxHQUFLLENBQVQsQ0FBWSxDQUNWLEdBQUdtQixDQUFDLENBQUcsS0FBS3kxQixFQUFULEVBQWUsQ0FBQ3YyQixDQUFDLENBQUcsS0FBSzNJLElBQUwsQ0FBVXNJLENBQVYsR0FBY21CLENBQW5CLEVBQXdCLENBQTFDLENBQTZDLENBQUVoQixDQUFDLENBQUcsSUFBSixDQUFVcWUsQ0FBQyxDQUFHK1ksUUFBUSxDQUFDbDNCLENBQUQsQ0FBWixDQUFrQixDQUMzRSxNQUFNTCxDQUFDLEVBQUksQ0FBWCxDQUFjLENBQ1osR0FBR21CLENBQUMsQ0FBRzdFLENBQVAsQ0FBVSxDQUNSK0QsQ0FBQyxDQUFHLENBQUMsS0FBSzNJLElBQUwsQ0FBVXNJLENBQVYsRUFBYyxDQUFDLEdBQUdtQixDQUFKLEVBQU8sQ0FBdEIsR0FBNEI3RSxDQUFDLENBQUM2RSxDQUFsQyxDQUNBZCxDQUFDLEVBQUksS0FBSzNJLElBQUwsQ0FBVSxFQUFFc0ksQ0FBWixJQUFpQm1CLENBQUMsRUFBRSxLQUFLeTFCLEVBQUwsQ0FBUXQ2QixDQUE1QixDQUFMLENBQ0QsQ0FIRCxJQUdPLENBQ0wrRCxDQUFDLENBQUksS0FBSzNJLElBQUwsQ0FBVXNJLENBQVYsSUFBZW1CLENBQUMsRUFBRTdFLENBQWxCLENBQUQsQ0FBdUJsQixFQUEzQixDQUNBLEdBQUcrRixDQUFDLEVBQUksQ0FBUixDQUFXLENBQUVBLENBQUMsRUFBSSxLQUFLeTFCLEVBQVYsQ0FBYyxFQUFFNTJCLENBQUYsQ0FBTSxDQUNsQyxDQUNELEdBQUdLLENBQUMsQ0FBRyxDQUFQLENBQVVGLENBQUMsQ0FBRyxJQUFKLENBQ1YsR0FBR0EsQ0FBSCxDQUFNcWUsQ0FBQyxFQUFJK1ksUUFBUSxDQUFDbDNCLENBQUQsQ0FBYixDQUNQLENBQ0YsQ0FDRCxNQUFPRixFQUFDLENBQUNxZSxDQUFELENBQUcsR0FBWCxDQUNELENBRUQ7QUFDQSxRQUFTK1osU0FBVCxFQUFvQixDQUFFLEdBQUkvWixFQUFDLENBQUc2WCxHQUFHLEVBQVgsQ0FBZXBaLFVBQVUsQ0FBQ2diLElBQVgsQ0FBZ0JDLEtBQWhCLENBQXNCLElBQXRCLENBQTJCMVosQ0FBM0IsRUFBK0IsTUFBT0EsRUFBUCxDQUFXLENBRS9FO0FBQ0EsUUFBU2dhLE1BQVQsRUFBaUIsQ0FBRSxNQUFRLE1BQUtwM0IsQ0FBTCxDQUFPLENBQVIsQ0FBVyxLQUFLaTNCLE1BQUwsRUFBWCxDQUF5QixJQUFoQyxDQUF1QyxDQUUxRDtBQUNBLFFBQVNJLFlBQVQsQ0FBcUJ2UCxDQUFyQixDQUF3QixDQUN0QixHQUFJMUssRUFBQyxDQUFHLEtBQUtwZCxDQUFMLENBQU84bkIsQ0FBQyxDQUFDOW5CLENBQWpCLENBQ0EsR0FBR29kLENBQUMsRUFBSSxDQUFSLENBQVcsTUFBT0EsRUFBUCxDQUNYLEdBQUl4ZSxFQUFDLENBQUcsS0FBSzRKLENBQWIsQ0FDQTRVLENBQUMsQ0FBR3hlLENBQUMsQ0FBQ2twQixDQUFDLENBQUN0ZixDQUFSLENBQ0EsR0FBRzRVLENBQUMsRUFBSSxDQUFSLENBQVcsTUFBUSxNQUFLcGQsQ0FBTCxDQUFPLENBQVIsQ0FBVyxDQUFDb2QsQ0FBWixDQUFjQSxDQUFyQixDQUNYLE1BQU0sRUFBRXhlLENBQUYsRUFBTyxDQUFiLEVBQWdCLEdBQUcsQ0FBQ3dlLENBQUMsQ0FBQyxLQUFLOW1CLElBQUwsQ0FBVXNJLENBQVYsRUFBYWtwQixDQUFDLENBQUN4eEIsSUFBRixDQUFPc0ksQ0FBUCxDQUFoQixHQUE4QixDQUFqQyxDQUFvQyxNQUFPd2UsRUFBUCxDQUFwRCxDQUNBLE1BQU8sRUFBUCxDQUNELENBRUQ7QUFDQSxRQUFTa2EsTUFBVCxDQUFlLzBCLENBQWYsQ0FBa0IsQ0FDaEIsR0FBSTZhLEVBQUMsQ0FBRyxDQUFSLENBQVc1VSxDQUFYLENBQ0EsR0FBRyxDQUFDQSxDQUFDLENBQUNqRyxDQUFDLEdBQUcsRUFBUCxHQUFjLENBQWpCLENBQW9CLENBQUVBLENBQUMsQ0FBR2lHLENBQUosQ0FBTzRVLENBQUMsRUFBSSxFQUFMLENBQVUsQ0FDdkMsR0FBRyxDQUFDNVUsQ0FBQyxDQUFDakcsQ0FBQyxFQUFFLENBQU4sR0FBWSxDQUFmLENBQWtCLENBQUVBLENBQUMsQ0FBR2lHLENBQUosQ0FBTzRVLENBQUMsRUFBSSxDQUFMLENBQVMsQ0FDcEMsR0FBRyxDQUFDNVUsQ0FBQyxDQUFDakcsQ0FBQyxFQUFFLENBQU4sR0FBWSxDQUFmLENBQWtCLENBQUVBLENBQUMsQ0FBR2lHLENBQUosQ0FBTzRVLENBQUMsRUFBSSxDQUFMLENBQVMsQ0FDcEMsR0FBRyxDQUFDNVUsQ0FBQyxDQUFDakcsQ0FBQyxFQUFFLENBQU4sR0FBWSxDQUFmLENBQWtCLENBQUVBLENBQUMsQ0FBR2lHLENBQUosQ0FBTzRVLENBQUMsRUFBSSxDQUFMLENBQVMsQ0FDcEMsR0FBRyxDQUFDNVUsQ0FBQyxDQUFDakcsQ0FBQyxFQUFFLENBQU4sR0FBWSxDQUFmLENBQWtCLENBQUVBLENBQUMsQ0FBR2lHLENBQUosQ0FBTzRVLENBQUMsRUFBSSxDQUFMLENBQVMsQ0FDcEMsTUFBT0EsRUFBUCxDQUNELENBRUQ7QUFDQSxRQUFTbWEsWUFBVCxFQUF1QixDQUNyQixHQUFHLEtBQUsvdUIsQ0FBTCxFQUFVLENBQWIsQ0FBZ0IsTUFBTyxFQUFQLENBQ2hCLE1BQU8sTUFBS2d0QixFQUFMLEVBQVMsS0FBS2h0QixDQUFMLENBQU8sQ0FBaEIsRUFBbUI4dUIsS0FBSyxDQUFDLEtBQUtoaEMsSUFBTCxDQUFVLEtBQUtrUyxDQUFMLENBQU8sQ0FBakIsRUFBcUIsS0FBS3hJLENBQUwsQ0FBTyxLQUFLeTFCLEVBQWxDLENBQS9CLENBQ0QsQ0FFRDtBQUNBLFFBQVMrQixhQUFULENBQXNCajRCLENBQXRCLENBQXdCNmQsQ0FBeEIsQ0FBMkIsQ0FDekIsR0FBSXhlLEVBQUosQ0FDQSxJQUFJQSxDQUFDLENBQUcsS0FBSzRKLENBQUwsQ0FBTyxDQUFmLENBQWtCNUosQ0FBQyxFQUFJLENBQXZCLENBQTBCLEVBQUVBLENBQTVCLEVBQStCd2UsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQUMsQ0FBQ1csQ0FBVCxFQUFjLEtBQUtqSixJQUFMLENBQVVzSSxDQUFWLENBQWQsQ0FBL0IsQ0FDQSxJQUFJQSxDQUFDLENBQUdXLENBQUMsQ0FBQyxDQUFWLENBQWFYLENBQUMsRUFBSSxDQUFsQixDQUFxQixFQUFFQSxDQUF2QixFQUEwQndlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFQLEVBQVksQ0FBWixDQUExQixDQUNBd2UsQ0FBQyxDQUFDNVUsQ0FBRixDQUFNLEtBQUtBLENBQUwsQ0FBT2pKLENBQWIsQ0FDQTZkLENBQUMsQ0FBQ3BkLENBQUYsQ0FBTSxLQUFLQSxDQUFYLENBQ0QsQ0FFRDtBQUNBLFFBQVN5M0IsYUFBVCxDQUFzQmw0QixDQUF0QixDQUF3QjZkLENBQXhCLENBQTJCLENBQ3pCLElBQUksR0FBSXhlLEVBQUMsQ0FBR1csQ0FBWixDQUFlWCxDQUFDLENBQUcsS0FBSzRKLENBQXhCLENBQTJCLEVBQUU1SixDQUE3QixFQUFnQ3dlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFDLENBQUNXLENBQVQsRUFBYyxLQUFLakosSUFBTCxDQUFVc0ksQ0FBVixDQUFkLENBQWhDLENBQ0F3ZSxDQUFDLENBQUM1VSxDQUFGLENBQU1sTixJQUFJLENBQUNrSyxHQUFMLENBQVMsS0FBS2dELENBQUwsQ0FBT2pKLENBQWhCLENBQWtCLENBQWxCLENBQU4sQ0FDQTZkLENBQUMsQ0FBQ3BkLENBQUYsQ0FBTSxLQUFLQSxDQUFYLENBQ0QsQ0FFRDtBQUNBLFFBQVMwM0IsWUFBVCxDQUFxQm40QixDQUFyQixDQUF1QjZkLENBQXZCLENBQTBCLENBQ3hCLEdBQUl1YSxHQUFFLENBQUdwNEIsQ0FBQyxDQUFDLEtBQUtpMkIsRUFBaEIsQ0FDQSxHQUFJb0MsSUFBRyxDQUFHLEtBQUtwQyxFQUFMLENBQVFtQyxFQUFsQixDQUNBLEdBQUlFLEdBQUUsQ0FBRyxDQUFDLEdBQUdELEdBQUosRUFBUyxDQUFsQixDQUNBLEdBQUlFLEdBQUUsQ0FBR3g4QixJQUFJLENBQUNpVyxLQUFMLENBQVdoUyxDQUFDLENBQUMsS0FBS2kyQixFQUFsQixDQUFULENBQWdDeDJCLENBQUMsQ0FBSSxLQUFLZ0IsQ0FBTCxFQUFRMjNCLEVBQVQsQ0FBYSxLQUFLbEMsRUFBdEQsQ0FBMEQ3MkIsQ0FBMUQsQ0FDQSxJQUFJQSxDQUFDLENBQUcsS0FBSzRKLENBQUwsQ0FBTyxDQUFmLENBQWtCNUosQ0FBQyxFQUFJLENBQXZCLENBQTBCLEVBQUVBLENBQTVCLENBQStCLENBQzdCd2UsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQUMsQ0FBQ2s1QixFQUFGLENBQUssQ0FBWixFQUFrQixLQUFLeGhDLElBQUwsQ0FBVXNJLENBQVYsR0FBY2c1QixHQUFmLENBQW9CNTRCLENBQXJDLENBQ0FBLENBQUMsQ0FBRyxDQUFDLEtBQUsxSSxJQUFMLENBQVVzSSxDQUFWLEVBQWFpNUIsRUFBZCxHQUFtQkYsRUFBdkIsQ0FDRCxDQUNELElBQUkvNEIsQ0FBQyxDQUFHazVCLEVBQUUsQ0FBQyxDQUFYLENBQWNsNUIsQ0FBQyxFQUFJLENBQW5CLENBQXNCLEVBQUVBLENBQXhCLEVBQTJCd2UsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQVAsRUFBWSxDQUFaLENBQTNCLENBQ0F3ZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPd2hDLEVBQVAsRUFBYTk0QixDQUFiLENBQ0FvZSxDQUFDLENBQUM1VSxDQUFGLENBQU0sS0FBS0EsQ0FBTCxDQUFPc3ZCLEVBQVAsQ0FBVSxDQUFoQixDQUNBMWEsQ0FBQyxDQUFDcGQsQ0FBRixDQUFNLEtBQUtBLENBQVgsQ0FDQW9kLENBQUMsQ0FBQ3daLEtBQUYsR0FDRCxDQUVEO0FBQ0EsUUFBU21CLFlBQVQsQ0FBcUJ4NEIsQ0FBckIsQ0FBdUI2ZCxDQUF2QixDQUEwQixDQUN4QkEsQ0FBQyxDQUFDcGQsQ0FBRixDQUFNLEtBQUtBLENBQVgsQ0FDQSxHQUFJODNCLEdBQUUsQ0FBR3g4QixJQUFJLENBQUNpVyxLQUFMLENBQVdoUyxDQUFDLENBQUMsS0FBS2kyQixFQUFsQixDQUFULENBQ0EsR0FBR3NDLEVBQUUsRUFBSSxLQUFLdHZCLENBQWQsQ0FBaUIsQ0FBRTRVLENBQUMsQ0FBQzVVLENBQUYsQ0FBTSxDQUFOLENBQVMsT0FBUyxDQUNyQyxHQUFJbXZCLEdBQUUsQ0FBR3A0QixDQUFDLENBQUMsS0FBS2kyQixFQUFoQixDQUNBLEdBQUlvQyxJQUFHLENBQUcsS0FBS3BDLEVBQUwsQ0FBUW1DLEVBQWxCLENBQ0EsR0FBSUUsR0FBRSxDQUFHLENBQUMsR0FBR0YsRUFBSixFQUFRLENBQWpCLENBQ0F2YSxDQUFDLENBQUM5bUIsSUFBRixDQUFPLENBQVAsRUFBWSxLQUFLQSxJQUFMLENBQVV3aEMsRUFBVixHQUFlSCxFQUEzQixDQUNBLElBQUksR0FBSS80QixFQUFDLENBQUdrNUIsRUFBRSxDQUFDLENBQWYsQ0FBa0JsNUIsQ0FBQyxDQUFHLEtBQUs0SixDQUEzQixDQUE4QixFQUFFNUosQ0FBaEMsQ0FBbUMsQ0FDakN3ZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBQyxDQUFDazVCLEVBQUYsQ0FBSyxDQUFaLEdBQWtCLENBQUMsS0FBS3hoQyxJQUFMLENBQVVzSSxDQUFWLEVBQWFpNUIsRUFBZCxHQUFtQkQsR0FBckMsQ0FDQXhhLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFDLENBQUNrNUIsRUFBVCxFQUFlLEtBQUt4aEMsSUFBTCxDQUFVc0ksQ0FBVixHQUFjKzRCLEVBQTdCLENBQ0QsQ0FDRCxHQUFHQSxFQUFFLENBQUcsQ0FBUixDQUFXdmEsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBTyxLQUFLa1MsQ0FBTCxDQUFPc3ZCLEVBQVAsQ0FBVSxDQUFqQixHQUF1QixDQUFDLEtBQUs5M0IsQ0FBTCxDQUFPNjNCLEVBQVIsR0FBYUQsR0FBcEMsQ0FDWHhhLENBQUMsQ0FBQzVVLENBQUYsQ0FBTSxLQUFLQSxDQUFMLENBQU9zdkIsRUFBYixDQUNBMWEsQ0FBQyxDQUFDd1osS0FBRixHQUNELENBRUQ7QUFDQSxRQUFTb0IsU0FBVCxDQUFrQmxRLENBQWxCLENBQW9CMUssQ0FBcEIsQ0FBdUIsQ0FDckIsR0FBSXhlLEVBQUMsQ0FBRyxDQUFSLENBQVdJLENBQUMsQ0FBRyxDQUFmLENBQWtCRCxDQUFDLENBQUd6RCxJQUFJLENBQUNvSyxHQUFMLENBQVNvaUIsQ0FBQyxDQUFDdGYsQ0FBWCxDQUFhLEtBQUtBLENBQWxCLENBQXRCLENBQ0EsTUFBTTVKLENBQUMsQ0FBR0csQ0FBVixDQUFhLENBQ1hDLENBQUMsRUFBSSxLQUFLMUksSUFBTCxDQUFVc0ksQ0FBVixFQUFha3BCLENBQUMsQ0FBQ3h4QixJQUFGLENBQU9zSSxDQUFQLENBQWxCLENBQ0F3ZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBQyxFQUFSLEVBQWNJLENBQUMsQ0FBQyxLQUFLeTJCLEVBQXJCLENBQ0F6MkIsQ0FBQyxHQUFLLEtBQUt3MkIsRUFBWCxDQUNELENBQ0QsR0FBRzFOLENBQUMsQ0FBQ3RmLENBQUYsQ0FBTSxLQUFLQSxDQUFkLENBQWlCLENBQ2Z4SixDQUFDLEVBQUk4b0IsQ0FBQyxDQUFDOW5CLENBQVAsQ0FDQSxNQUFNcEIsQ0FBQyxDQUFHLEtBQUs0SixDQUFmLENBQWtCLENBQ2hCeEosQ0FBQyxFQUFJLEtBQUsxSSxJQUFMLENBQVVzSSxDQUFWLENBQUwsQ0FDQXdlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFDLEVBQVIsRUFBY0ksQ0FBQyxDQUFDLEtBQUt5MkIsRUFBckIsQ0FDQXoyQixDQUFDLEdBQUssS0FBS3cyQixFQUFYLENBQ0QsQ0FDRHgyQixDQUFDLEVBQUksS0FBS2dCLENBQVYsQ0FDRCxDQVJELElBUU8sQ0FDTGhCLENBQUMsRUFBSSxLQUFLZ0IsQ0FBVixDQUNBLE1BQU1wQixDQUFDLENBQUdrcEIsQ0FBQyxDQUFDdGYsQ0FBWixDQUFlLENBQ2J4SixDQUFDLEVBQUk4b0IsQ0FBQyxDQUFDeHhCLElBQUYsQ0FBT3NJLENBQVAsQ0FBTCxDQUNBd2UsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQUMsRUFBUixFQUFjSSxDQUFDLENBQUMsS0FBS3kyQixFQUFyQixDQUNBejJCLENBQUMsR0FBSyxLQUFLdzJCLEVBQVgsQ0FDRCxDQUNEeDJCLENBQUMsRUFBSThvQixDQUFDLENBQUM5bkIsQ0FBUCxDQUNELENBQ0RvZCxDQUFDLENBQUNwZCxDQUFGLENBQU9oQixDQUFDLENBQUMsQ0FBSCxDQUFNLENBQUMsQ0FBUCxDQUFTLENBQWYsQ0FDQSxHQUFHQSxDQUFDLENBQUcsQ0FBQyxDQUFSLENBQVdvZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBQyxFQUFSLEVBQWMsS0FBSzgyQixFQUFMLENBQVExMkIsQ0FBdEIsQ0FBWCxJQUNLLElBQUdBLENBQUMsQ0FBRyxDQUFQLENBQVVvZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBQyxFQUFSLEVBQWNJLENBQWQsQ0FDZm9lLENBQUMsQ0FBQzVVLENBQUYsQ0FBTTVKLENBQU4sQ0FDQXdlLENBQUMsQ0FBQ3daLEtBQUYsR0FDRCxDQUVEO0FBQ0E7QUFDQSxRQUFTcUIsY0FBVCxDQUF1Qm5RLENBQXZCLENBQXlCMUssQ0FBekIsQ0FBNEIsQ0FDMUIsR0FBSTdhLEVBQUMsQ0FBRyxLQUFLNk0sR0FBTCxFQUFSLENBQW9Cd08sQ0FBQyxDQUFHa0ssQ0FBQyxDQUFDMVksR0FBRixFQUF4QixDQUNBLEdBQUl4USxFQUFDLENBQUcyRCxDQUFDLENBQUNpRyxDQUFWLENBQ0E0VSxDQUFDLENBQUM1VSxDQUFGLENBQU01SixDQUFDLENBQUNnZixDQUFDLENBQUNwVixDQUFWLENBQ0EsTUFBTSxFQUFFNUosQ0FBRixFQUFPLENBQWIsRUFBZ0J3ZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBUCxFQUFZLENBQVosQ0FBaEIsQ0FDQSxJQUFJQSxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUdnZixDQUFDLENBQUNwVixDQUFqQixDQUFvQixFQUFFNUosQ0FBdEIsRUFBeUJ3ZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBQyxDQUFDMkQsQ0FBQyxDQUFDaUcsQ0FBWCxFQUFnQmpHLENBQUMsQ0FBQ2d6QixFQUFGLENBQUssQ0FBTCxDQUFPM1gsQ0FBQyxDQUFDdG5CLElBQUYsQ0FBT3NJLENBQVAsQ0FBUCxDQUFpQndlLENBQWpCLENBQW1CeGUsQ0FBbkIsQ0FBcUIsQ0FBckIsQ0FBdUIyRCxDQUFDLENBQUNpRyxDQUF6QixDQUFoQixDQUF6QixDQUNBNFUsQ0FBQyxDQUFDcGQsQ0FBRixDQUFNLENBQU4sQ0FDQW9kLENBQUMsQ0FBQ3daLEtBQUYsR0FDQSxHQUFHLEtBQUs1MkIsQ0FBTCxFQUFVOG5CLENBQUMsQ0FBQzluQixDQUFmLENBQWtCNmIsVUFBVSxDQUFDZ2IsSUFBWCxDQUFnQkMsS0FBaEIsQ0FBc0IxWixDQUF0QixDQUF3QkEsQ0FBeEIsRUFDbkIsQ0FFRDtBQUNBLFFBQVM4YSxZQUFULENBQXFCOWEsQ0FBckIsQ0FBd0IsQ0FDdEIsR0FBSTdhLEVBQUMsQ0FBRyxLQUFLNk0sR0FBTCxFQUFSLENBQ0EsR0FBSXhRLEVBQUMsQ0FBR3dlLENBQUMsQ0FBQzVVLENBQUYsQ0FBTSxFQUFFakcsQ0FBQyxDQUFDaUcsQ0FBbEIsQ0FDQSxNQUFNLEVBQUU1SixDQUFGLEVBQU8sQ0FBYixFQUFnQndlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFQLEVBQVksQ0FBWixDQUFoQixDQUNBLElBQUlBLENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsQ0FBRzJELENBQUMsQ0FBQ2lHLENBQUYsQ0FBSSxDQUFuQixDQUFzQixFQUFFNUosQ0FBeEIsQ0FBMkIsQ0FDekIsR0FBSUksRUFBQyxDQUFHdUQsQ0FBQyxDQUFDZ3pCLEVBQUYsQ0FBSzMyQixDQUFMLENBQU8yRCxDQUFDLENBQUNqTSxJQUFGLENBQU9zSSxDQUFQLENBQVAsQ0FBaUJ3ZSxDQUFqQixDQUFtQixFQUFFeGUsQ0FBckIsQ0FBdUIsQ0FBdkIsQ0FBeUIsQ0FBekIsQ0FBUixDQUNBLEdBQUcsQ0FBQ3dlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFDLENBQUMyRCxDQUFDLENBQUNpRyxDQUFYLEdBQWVqRyxDQUFDLENBQUNnekIsRUFBRixDQUFLMzJCLENBQUMsQ0FBQyxDQUFQLENBQVMsRUFBRTJELENBQUMsQ0FBQ2pNLElBQUYsQ0FBT3NJLENBQVAsQ0FBWCxDQUFxQndlLENBQXJCLENBQXVCLEVBQUV4ZSxDQUFGLENBQUksQ0FBM0IsQ0FBNkJJLENBQTdCLENBQStCdUQsQ0FBQyxDQUFDaUcsQ0FBRixDQUFJNUosQ0FBSixDQUFNLENBQXJDLENBQWhCLEdBQTREMkQsQ0FBQyxDQUFDbXpCLEVBQWpFLENBQXFFLENBQ25FdFksQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQUMsQ0FBQzJELENBQUMsQ0FBQ2lHLENBQVgsR0FBaUJqRyxDQUFDLENBQUNtekIsRUFBbkIsQ0FDQXRZLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFDLENBQUMyRCxDQUFDLENBQUNpRyxDQUFKLENBQU0sQ0FBYixFQUFrQixDQUFsQixDQUNELENBQ0YsQ0FDRCxHQUFHNFUsQ0FBQyxDQUFDNVUsQ0FBRixDQUFNLENBQVQsQ0FBWTRVLENBQUMsQ0FBQzltQixJQUFGLENBQU84bUIsQ0FBQyxDQUFDNVUsQ0FBRixDQUFJLENBQVgsR0FBaUJqRyxDQUFDLENBQUNnekIsRUFBRixDQUFLMzJCLENBQUwsQ0FBTzJELENBQUMsQ0FBQ2pNLElBQUYsQ0FBT3NJLENBQVAsQ0FBUCxDQUFpQndlLENBQWpCLENBQW1CLEVBQUV4ZSxDQUFyQixDQUF1QixDQUF2QixDQUF5QixDQUF6QixDQUFqQixDQUNad2UsQ0FBQyxDQUFDcGQsQ0FBRixDQUFNLENBQU4sQ0FDQW9kLENBQUMsQ0FBQ3daLEtBQUYsR0FDRCxDQUVEO0FBQ0E7QUFDQSxRQUFTdUIsWUFBVCxDQUFxQnA1QixDQUFyQixDQUF1QjJOLENBQXZCLENBQXlCMFEsQ0FBekIsQ0FBNEIsQ0FDMUIsR0FBSWdiLEdBQUUsQ0FBR3I1QixDQUFDLENBQUNxUSxHQUFGLEVBQVQsQ0FDQSxHQUFHZ3BCLEVBQUUsQ0FBQzV2QixDQUFILEVBQVEsQ0FBWCxDQUFjLE9BQ2QsR0FBSTZ2QixHQUFFLENBQUcsS0FBS2pwQixHQUFMLEVBQVQsQ0FDQSxHQUFHaXBCLEVBQUUsQ0FBQzd2QixDQUFILENBQU80dkIsRUFBRSxDQUFDNXZCLENBQWIsQ0FBZ0IsQ0FDZCxHQUFHa0UsQ0FBQyxFQUFJLElBQVIsQ0FBY0EsQ0FBQyxDQUFDc1MsT0FBRixDQUFVLENBQVYsRUFDZCxHQUFHNUIsQ0FBQyxFQUFJLElBQVIsQ0FBYyxLQUFLa2IsTUFBTCxDQUFZbGIsQ0FBWixFQUNkLE9BQ0QsQ0FDRCxHQUFHQSxDQUFDLEVBQUksSUFBUixDQUFjQSxDQUFDLENBQUc2WCxHQUFHLEVBQVAsQ0FDZCxHQUFJclgsRUFBQyxDQUFHcVgsR0FBRyxFQUFYLENBQWVzRCxFQUFFLENBQUcsS0FBS3Y0QixDQUF6QixDQUE0Qnc0QixFQUFFLENBQUd6NUIsQ0FBQyxDQUFDaUIsQ0FBbkMsQ0FDQSxHQUFJeTRCLElBQUcsQ0FBRyxLQUFLakQsRUFBTCxDQUFROEIsS0FBSyxDQUFDYyxFQUFFLENBQUM5aEMsSUFBSCxDQUFROGhDLEVBQUUsQ0FBQzV2QixDQUFILENBQUssQ0FBYixDQUFELENBQXZCLENBQTBDO0FBQzFDLEdBQUdpd0IsR0FBRyxDQUFHLENBQVQsQ0FBWSxDQUFFTCxFQUFFLENBQUNNLFFBQUgsQ0FBWUQsR0FBWixDQUFnQjdhLENBQWhCLEVBQW9CeWEsRUFBRSxDQUFDSyxRQUFILENBQVlELEdBQVosQ0FBZ0JyYixDQUFoQixFQUFxQixDQUF2RCxJQUE2RCxDQUFFZ2IsRUFBRSxDQUFDRSxNQUFILENBQVUxYSxDQUFWLEVBQWN5YSxFQUFFLENBQUNDLE1BQUgsQ0FBVWxiLENBQVYsRUFBZSxDQUM1RixHQUFJdWIsR0FBRSxDQUFHL2EsQ0FBQyxDQUFDcFYsQ0FBWCxDQUNBLEdBQUlvd0IsR0FBRSxDQUFHaGIsQ0FBQyxDQUFDdG5CLElBQUYsQ0FBT3FpQyxFQUFFLENBQUMsQ0FBVixDQUFULENBQ0EsR0FBR0MsRUFBRSxFQUFJLENBQVQsQ0FBWSxPQUNaLEdBQUlDLEdBQUUsQ0FBR0QsRUFBRSxFQUFFLEdBQUcsS0FBSy9DLEVBQVYsQ0FBRixFQUFrQjhDLEVBQUUsQ0FBQyxDQUFKLENBQU8vYSxDQUFDLENBQUN0bkIsSUFBRixDQUFPcWlDLEVBQUUsQ0FBQyxDQUFWLEdBQWMsS0FBSzdDLEVBQTFCLENBQTZCLENBQTlDLENBQVQsQ0FDQSxHQUFJZ0QsR0FBRSxDQUFHLEtBQUtsRCxFQUFMLENBQVFpRCxFQUFqQixDQUFxQkUsRUFBRSxDQUFHLENBQUMsR0FBRyxLQUFLbEQsRUFBVCxFQUFhZ0QsRUFBdkMsQ0FBMkN0MUIsQ0FBQyxDQUFHLEdBQUcsS0FBS3V5QixFQUF2RCxDQUNBLEdBQUlsM0IsRUFBQyxDQUFHd2UsQ0FBQyxDQUFDNVUsQ0FBVixDQUFhNEIsQ0FBQyxDQUFHeEwsQ0FBQyxDQUFDKzVCLEVBQW5CLENBQXVCbndCLENBQUMsQ0FBSWtFLENBQUMsRUFBRSxJQUFKLENBQVV1b0IsR0FBRyxFQUFiLENBQWdCdm9CLENBQTNDLENBQ0FrUixDQUFDLENBQUNvYixTQUFGLENBQVk1dUIsQ0FBWixDQUFjNUIsQ0FBZCxFQUNBLEdBQUc0VSxDQUFDLENBQUNFLFNBQUYsQ0FBWTlVLENBQVosR0FBa0IsQ0FBckIsQ0FBd0IsQ0FDdEI0VSxDQUFDLENBQUM5bUIsSUFBRixDQUFPOG1CLENBQUMsQ0FBQzVVLENBQUYsRUFBUCxFQUFnQixDQUFoQixDQUNBNFUsQ0FBQyxDQUFDMFosS0FBRixDQUFRdHVCLENBQVIsQ0FBVTRVLENBQVYsRUFDRCxDQUNEdkIsVUFBVSxDQUFDbUIsR0FBWCxDQUFlZ2MsU0FBZixDQUF5QkwsRUFBekIsQ0FBNEJud0IsQ0FBNUIsRUFDQUEsQ0FBQyxDQUFDc3VCLEtBQUYsQ0FBUWxaLENBQVIsQ0FBVUEsQ0FBVixFQUFjO0FBQ2QsTUFBTUEsQ0FBQyxDQUFDcFYsQ0FBRixDQUFNbXdCLEVBQVosRUFBZ0IvYSxDQUFDLENBQUN0bkIsSUFBRixDQUFPc25CLENBQUMsQ0FBQ3BWLENBQUYsRUFBUCxFQUFnQixDQUFoQixDQUFoQixDQUNBLE1BQU0sRUFBRTRCLENBQUYsRUFBTyxDQUFiLENBQWdCLENBQ2Q7QUFDQSxHQUFJNnVCLEdBQUUsQ0FBSTdiLENBQUMsQ0FBQzltQixJQUFGLENBQU8sRUFBRXNJLENBQVQsR0FBYWc2QixFQUFkLENBQWtCLEtBQUtuRCxFQUF2QixDQUEwQm42QixJQUFJLENBQUNpVyxLQUFMLENBQVc2TCxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBUCxFQUFVazZCLEVBQVYsQ0FBYSxDQUFDMWIsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQUMsQ0FBQyxDQUFULEVBQVkyRSxDQUFiLEVBQWdCdzFCLEVBQXhDLENBQW5DLENBQ0EsR0FBRyxDQUFDM2IsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQVAsR0FBV2dmLENBQUMsQ0FBQzJYLEVBQUYsQ0FBSyxDQUFMLENBQU8wRCxFQUFQLENBQVU3YixDQUFWLENBQVloVCxDQUFaLENBQWMsQ0FBZCxDQUFnQnV1QixFQUFoQixDQUFaLEVBQW1DTSxFQUF0QyxDQUEwQyxDQUFFO0FBQzFDcmIsQ0FBQyxDQUFDb2IsU0FBRixDQUFZNXVCLENBQVosQ0FBYzVCLENBQWQsRUFDQTRVLENBQUMsQ0FBQzBaLEtBQUYsQ0FBUXR1QixDQUFSLENBQVU0VSxDQUFWLEVBQ0EsTUFBTUEsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQVAsRUFBWSxFQUFFcTZCLEVBQXBCLEVBQXdCN2IsQ0FBQyxDQUFDMFosS0FBRixDQUFRdHVCLENBQVIsQ0FBVTRVLENBQVYsRUFBeEIsQ0FDRCxDQUNGLENBQ0QsR0FBRzFRLENBQUMsRUFBSSxJQUFSLENBQWMsQ0FDWjBRLENBQUMsQ0FBQzhiLFNBQUYsQ0FBWVAsRUFBWixDQUFlanNCLENBQWYsRUFDQSxHQUFHNnJCLEVBQUUsRUFBSUMsRUFBVCxDQUFhM2MsVUFBVSxDQUFDZ2IsSUFBWCxDQUFnQkMsS0FBaEIsQ0FBc0JwcUIsQ0FBdEIsQ0FBd0JBLENBQXhCLEVBQ2QsQ0FDRDBRLENBQUMsQ0FBQzVVLENBQUYsQ0FBTW13QixFQUFOLENBQ0F2YixDQUFDLENBQUN3WixLQUFGLEdBQ0EsR0FBRzZCLEdBQUcsQ0FBRyxDQUFULENBQVlyYixDQUFDLENBQUMrYixRQUFGLENBQVdWLEdBQVgsQ0FBZXJiLENBQWYsRUFBbUI7QUFDL0IsR0FBR21iLEVBQUUsQ0FBRyxDQUFSLENBQVcxYyxVQUFVLENBQUNnYixJQUFYLENBQWdCQyxLQUFoQixDQUFzQjFaLENBQXRCLENBQXdCQSxDQUF4QixFQUNaLENBRUQ7QUFDQSxRQUFTZ2MsTUFBVCxDQUFldFIsQ0FBZixDQUFrQixDQUNoQixHQUFJMUssRUFBQyxDQUFHNlgsR0FBRyxFQUFYLENBQ0EsS0FBSzdsQixHQUFMLEdBQVdpcUIsUUFBWCxDQUFvQnZSLENBQXBCLENBQXNCLElBQXRCLENBQTJCMUssQ0FBM0IsRUFDQSxHQUFHLEtBQUtwZCxDQUFMLENBQVMsQ0FBVCxFQUFjb2QsQ0FBQyxDQUFDRSxTQUFGLENBQVl6QixVQUFVLENBQUNnYixJQUF2QixFQUErQixDQUFoRCxDQUFtRC9PLENBQUMsQ0FBQ2dQLEtBQUYsQ0FBUTFaLENBQVIsQ0FBVUEsQ0FBVixFQUNuRCxNQUFPQSxFQUFQLENBQ0QsQ0FFRDtBQUNBLFFBQVNrYyxRQUFULENBQWlCdjZCLENBQWpCLENBQW9CLENBQUUsS0FBS0EsQ0FBTCxDQUFTQSxDQUFULENBQWEsQ0FDbkMsUUFBU3c2QixTQUFULENBQWtCaDNCLENBQWxCLENBQXFCLENBQ25CLEdBQUdBLENBQUMsQ0FBQ3ZDLENBQUYsQ0FBTSxDQUFOLEVBQVd1QyxDQUFDLENBQUMrYSxTQUFGLENBQVksS0FBS3ZlLENBQWpCLEdBQXVCLENBQXJDLENBQXdDLE1BQU93RCxFQUFDLENBQUN1YSxHQUFGLENBQU0sS0FBSy9kLENBQVgsQ0FBUCxDQUF4QyxJQUNLLE9BQU93RCxFQUFQLENBQ04sQ0FDRCxRQUFTaTNCLFFBQVQsQ0FBaUJqM0IsQ0FBakIsQ0FBb0IsQ0FBRSxNQUFPQSxFQUFQLENBQVcsQ0FDakMsUUFBU2szQixRQUFULENBQWlCbDNCLENBQWpCLENBQW9CLENBQUVBLENBQUMsQ0FBQzgyQixRQUFGLENBQVcsS0FBS3Q2QixDQUFoQixDQUFrQixJQUFsQixDQUF1QndELENBQXZCLEVBQTRCLENBQ2xELFFBQVNtM0IsT0FBVCxDQUFnQm4zQixDQUFoQixDQUFrQnFiLENBQWxCLENBQW9CUixDQUFwQixDQUF1QixDQUFFN2EsQ0FBQyxDQUFDbzNCLFVBQUYsQ0FBYS9iLENBQWIsQ0FBZVIsQ0FBZixFQUFtQixLQUFLdGxCLE1BQUwsQ0FBWXNsQixDQUFaLEVBQWlCLENBQzdELFFBQVN3YyxPQUFULENBQWdCcjNCLENBQWhCLENBQWtCNmEsQ0FBbEIsQ0FBcUIsQ0FBRTdhLENBQUMsQ0FBQ3MzQixRQUFGLENBQVd6YyxDQUFYLEVBQWUsS0FBS3RsQixNQUFMLENBQVlzbEIsQ0FBWixFQUFpQixDQUV2RGtjLE9BQU8sQ0FBQ3o1QixTQUFSLENBQWtCaTZCLE9BQWxCLENBQTRCUCxRQUE1QixDQUNBRCxPQUFPLENBQUN6NUIsU0FBUixDQUFrQms2QixNQUFsQixDQUEyQlAsT0FBM0IsQ0FDQUYsT0FBTyxDQUFDejVCLFNBQVIsQ0FBa0IvSCxNQUFsQixDQUEyQjJoQyxPQUEzQixDQUNBSCxPQUFPLENBQUN6NUIsU0FBUixDQUFrQm02QixLQUFsQixDQUEwQk4sTUFBMUIsQ0FDQUosT0FBTyxDQUFDejVCLFNBQVIsQ0FBa0JvNkIsS0FBbEIsQ0FBMEJMLE1BQTFCLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFTTSxZQUFULEVBQXVCLENBQ3JCLEdBQUcsS0FBSzF4QixDQUFMLENBQVMsQ0FBWixDQUFlLE1BQU8sRUFBUCxDQUNmLEdBQUlqRyxFQUFDLENBQUcsS0FBS2pNLElBQUwsQ0FBVSxDQUFWLENBQVIsQ0FDQSxHQUFHLENBQUNpTSxDQUFDLENBQUMsQ0FBSCxHQUFTLENBQVosQ0FBZSxNQUFPLEVBQVAsQ0FDZixHQUFJcWIsRUFBQyxDQUFHcmIsQ0FBQyxDQUFDLENBQVYsQ0FBYztBQUNkcWIsQ0FBQyxDQUFJQSxDQUFDLEVBQUUsRUFBRSxDQUFDcmIsQ0FBQyxDQUFDLEdBQUgsRUFBUXFiLENBQVosQ0FBRixDQUFrQixHQUF0QixDQUEyQjtBQUMzQkEsQ0FBQyxDQUFJQSxDQUFDLEVBQUUsRUFBRSxDQUFDcmIsQ0FBQyxDQUFDLElBQUgsRUFBU3FiLENBQWIsQ0FBRixDQUFtQixJQUF2QixDQUE2QjtBQUM3QkEsQ0FBQyxDQUFJQSxDQUFDLEVBQUUsR0FBSSxDQUFDcmIsQ0FBQyxDQUFDLE1BQUgsRUFBV3FiLENBQVosQ0FBZSxNQUFsQixDQUFGLENBQUYsQ0FBZ0MsTUFBcEMsQ0FBNEM7QUFDNUM7QUFDQTtBQUNBQSxDQUFDLENBQUlBLENBQUMsRUFBRSxFQUFFcmIsQ0FBQyxDQUFDcWIsQ0FBRixDQUFJLEtBQUs4WCxFQUFiLENBQUYsQ0FBb0IsS0FBS0EsRUFBN0IsQ0FBa0M7QUFDbEM7QUFDQSxNQUFROVgsRUFBQyxDQUFDLENBQUgsQ0FBTSxLQUFLOFgsRUFBTCxDQUFROVgsQ0FBZCxDQUFnQixDQUFDQSxDQUF4QixDQUNELENBRUQ7QUFDQSxRQUFTdWMsV0FBVCxDQUFvQnA3QixDQUFwQixDQUF1QixDQUNyQixLQUFLQSxDQUFMLENBQVNBLENBQVQsQ0FDQSxLQUFLcTdCLEVBQUwsQ0FBVXI3QixDQUFDLENBQUNzN0IsUUFBRixFQUFWLENBQ0EsS0FBS0MsR0FBTCxDQUFXLEtBQUtGLEVBQUwsQ0FBUSxNQUFuQixDQUNBLEtBQUtHLEdBQUwsQ0FBVyxLQUFLSCxFQUFMLEVBQVMsRUFBcEIsQ0FDQSxLQUFLSSxFQUFMLENBQVUsQ0FBQyxHQUFJejdCLENBQUMsQ0FBQ3kyQixFQUFGLENBQUssRUFBVixFQUFlLENBQXpCLENBQ0EsS0FBS2lGLEdBQUwsQ0FBVyxFQUFFMTdCLENBQUMsQ0FBQ3lKLENBQWYsQ0FDRCxDQUVEO0FBQ0EsUUFBU2t5QixZQUFULENBQXFCbjRCLENBQXJCLENBQXdCLENBQ3RCLEdBQUk2YSxFQUFDLENBQUc2WCxHQUFHLEVBQVgsQ0FDQTF5QixDQUFDLENBQUM2TSxHQUFGLEdBQVE0cEIsU0FBUixDQUFrQixLQUFLajZCLENBQUwsQ0FBT3lKLENBQXpCLENBQTJCNFUsQ0FBM0IsRUFDQUEsQ0FBQyxDQUFDaWMsUUFBRixDQUFXLEtBQUt0NkIsQ0FBaEIsQ0FBa0IsSUFBbEIsQ0FBdUJxZSxDQUF2QixFQUNBLEdBQUc3YSxDQUFDLENBQUN2QyxDQUFGLENBQU0sQ0FBTixFQUFXb2QsQ0FBQyxDQUFDRSxTQUFGLENBQVl6QixVQUFVLENBQUNnYixJQUF2QixFQUErQixDQUE3QyxDQUFnRCxLQUFLOTNCLENBQUwsQ0FBTyszQixLQUFQLENBQWExWixDQUFiLENBQWVBLENBQWYsRUFDaEQsTUFBT0EsRUFBUCxDQUNELENBRUQ7QUFDQSxRQUFTdWQsV0FBVCxDQUFvQnA0QixDQUFwQixDQUF1QixDQUNyQixHQUFJNmEsRUFBQyxDQUFHNlgsR0FBRyxFQUFYLENBQ0ExeUIsQ0FBQyxDQUFDKzFCLE1BQUYsQ0FBU2xiLENBQVQsRUFDQSxLQUFLdGxCLE1BQUwsQ0FBWXNsQixDQUFaLEVBQ0EsTUFBT0EsRUFBUCxDQUNELENBRUQ7QUFDQSxRQUFTd2QsV0FBVCxDQUFvQnI0QixDQUFwQixDQUF1QixDQUNyQixNQUFNQSxDQUFDLENBQUNpRyxDQUFGLEVBQU8sS0FBS2l5QixHQUFsQixFQUF1QjtBQUNyQmw0QixDQUFDLENBQUNqTSxJQUFGLENBQU9pTSxDQUFDLENBQUNpRyxDQUFGLEVBQVAsRUFBZ0IsQ0FBaEIsQ0FERixDQUVBLElBQUksR0FBSTVKLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLRyxDQUFMLENBQU95SixDQUExQixDQUE2QixFQUFFNUosQ0FBL0IsQ0FBa0MsQ0FDaEM7QUFDQSxHQUFJd0wsRUFBQyxDQUFHN0gsQ0FBQyxDQUFDak0sSUFBRixDQUFPc0ksQ0FBUCxFQUFVLE1BQWxCLENBQ0EsR0FBSWk4QixHQUFFLENBQUl6d0IsQ0FBQyxDQUFDLEtBQUtrd0IsR0FBUCxFQUFZLENBQUVsd0IsQ0FBQyxDQUFDLEtBQUttd0IsR0FBUCxDQUFXLENBQUNoNEIsQ0FBQyxDQUFDak0sSUFBRixDQUFPc0ksQ0FBUCxHQUFXLEVBQVosRUFBZ0IsS0FBSzA3QixHQUFqQyxDQUFzQyxLQUFLRSxFQUE1QyxHQUFpRCxFQUE3RCxDQUFELENBQW1FajRCLENBQUMsQ0FBQ2t6QixFQUE5RSxDQUNBO0FBQ0FyckIsQ0FBQyxDQUFHeEwsQ0FBQyxDQUFDLEtBQUtHLENBQUwsQ0FBT3lKLENBQWIsQ0FDQWpHLENBQUMsQ0FBQ2pNLElBQUYsQ0FBTzhULENBQVAsR0FBYSxLQUFLckwsQ0FBTCxDQUFPdzJCLEVBQVAsQ0FBVSxDQUFWLENBQVlzRixFQUFaLENBQWV0NEIsQ0FBZixDQUFpQjNELENBQWpCLENBQW1CLENBQW5CLENBQXFCLEtBQUtHLENBQUwsQ0FBT3lKLENBQTVCLENBQWIsQ0FDQTtBQUNBLE1BQU1qRyxDQUFDLENBQUNqTSxJQUFGLENBQU84VCxDQUFQLEdBQWE3SCxDQUFDLENBQUNtekIsRUFBckIsQ0FBeUIsQ0FBRW56QixDQUFDLENBQUNqTSxJQUFGLENBQU84VCxDQUFQLEdBQWE3SCxDQUFDLENBQUNtekIsRUFBZixDQUFtQm56QixDQUFDLENBQUNqTSxJQUFGLENBQU8sRUFBRThULENBQVQsSUFBZ0IsQ0FDL0QsQ0FDRDdILENBQUMsQ0FBQ3EwQixLQUFGLEdBQ0FyMEIsQ0FBQyxDQUFDMjJCLFNBQUYsQ0FBWSxLQUFLbjZCLENBQUwsQ0FBT3lKLENBQW5CLENBQXFCakcsQ0FBckIsRUFDQSxHQUFHQSxDQUFDLENBQUMrYSxTQUFGLENBQVksS0FBS3ZlLENBQWpCLEdBQXVCLENBQTFCLENBQTZCd0QsQ0FBQyxDQUFDdTBCLEtBQUYsQ0FBUSxLQUFLLzNCLENBQWIsQ0FBZXdELENBQWYsRUFDOUIsQ0FFRDtBQUNBLFFBQVN1NEIsVUFBVCxDQUFtQnY0QixDQUFuQixDQUFxQjZhLENBQXJCLENBQXdCLENBQUU3YSxDQUFDLENBQUNzM0IsUUFBRixDQUFXemMsQ0FBWCxFQUFlLEtBQUt0bEIsTUFBTCxDQUFZc2xCLENBQVosRUFBaUIsQ0FFMUQ7QUFDQSxRQUFTMmQsVUFBVCxDQUFtQng0QixDQUFuQixDQUFxQnFiLENBQXJCLENBQXVCUixDQUF2QixDQUEwQixDQUFFN2EsQ0FBQyxDQUFDbzNCLFVBQUYsQ0FBYS9iLENBQWIsQ0FBZVIsQ0FBZixFQUFtQixLQUFLdGxCLE1BQUwsQ0FBWXNsQixDQUFaLEVBQWlCLENBRWhFK2MsVUFBVSxDQUFDdDZCLFNBQVgsQ0FBcUJpNkIsT0FBckIsQ0FBK0JZLFdBQS9CLENBQ0FQLFVBQVUsQ0FBQ3Q2QixTQUFYLENBQXFCazZCLE1BQXJCLENBQThCWSxVQUE5QixDQUNBUixVQUFVLENBQUN0NkIsU0FBWCxDQUFxQi9ILE1BQXJCLENBQThCOGlDLFVBQTlCLENBQ0FULFVBQVUsQ0FBQ3Q2QixTQUFYLENBQXFCbTZCLEtBQXJCLENBQTZCZSxTQUE3QixDQUNBWixVQUFVLENBQUN0NkIsU0FBWCxDQUFxQm82QixLQUFyQixDQUE2QmEsU0FBN0IsQ0FFQTtBQUNBLFFBQVNFLFVBQVQsRUFBcUIsQ0FBRSxNQUFPLENBQUUsS0FBS3h5QixDQUFMLENBQU8sQ0FBUixDQUFZLEtBQUtsUyxJQUFMLENBQVUsQ0FBVixFQUFhLENBQXpCLENBQTRCLEtBQUswSixDQUFsQyxHQUF3QyxDQUEvQyxDQUFtRCxDQUUxRTtBQUNBLFFBQVNpN0IsT0FBVCxDQUFnQjEzQixDQUFoQixDQUFrQnd0QixDQUFsQixDQUFxQixDQUNuQixHQUFHeHRCLENBQUMsQ0FBRyxVQUFKLEVBQWtCQSxDQUFDLENBQUcsQ0FBekIsQ0FBNEIsTUFBT3NZLFdBQVUsQ0FBQ21CLEdBQWxCLENBQzVCLEdBQUlJLEVBQUMsQ0FBRzZYLEdBQUcsRUFBWCxDQUFlaGpCLEVBQUUsQ0FBR2dqQixHQUFHLEVBQXZCLENBQTJCaUcsQ0FBQyxDQUFHbkssQ0FBQyxDQUFDK0ksT0FBRixDQUFVLElBQVYsQ0FBL0IsQ0FBZ0RsN0IsQ0FBQyxDQUFHMDRCLEtBQUssQ0FBQy96QixDQUFELENBQUwsQ0FBUyxDQUE3RCxDQUNBMjNCLENBQUMsQ0FBQzVDLE1BQUYsQ0FBU2xiLENBQVQsRUFDQSxNQUFNLEVBQUV4ZSxDQUFGLEVBQU8sQ0FBYixDQUFnQixDQUNkbXlCLENBQUMsQ0FBQ2tKLEtBQUYsQ0FBUTdjLENBQVIsQ0FBVW5MLEVBQVYsRUFDQSxHQUFHLENBQUMxTyxDQUFDLENBQUUsR0FBRzNFLENBQVAsRUFBYSxDQUFoQixDQUFtQm15QixDQUFDLENBQUNpSixLQUFGLENBQVEvbkIsRUFBUixDQUFXaXBCLENBQVgsQ0FBYTlkLENBQWIsRUFBbkIsSUFDSyxDQUFFLEdBQUk1VSxFQUFDLENBQUc0VSxDQUFSLENBQVdBLENBQUMsQ0FBR25MLEVBQUosQ0FBUUEsRUFBRSxDQUFHekosQ0FBTCxDQUFTLENBQ3BDLENBQ0QsTUFBT3VvQixFQUFDLENBQUNnSixNQUFGLENBQVMzYyxDQUFULENBQVAsQ0FDRCxDQUVEO0FBQ0EsUUFBUytkLFlBQVQsQ0FBcUI1M0IsQ0FBckIsQ0FBdUJ4RSxDQUF2QixDQUEwQixDQUN4QixHQUFJZ3lCLEVBQUosQ0FDQSxHQUFHeHRCLENBQUMsQ0FBRyxHQUFKLEVBQVd4RSxDQUFDLENBQUNxOEIsTUFBRixFQUFkLENBQTBCckssQ0FBQyxDQUFHLEdBQUl1SSxRQUFKLENBQVl2NkIsQ0FBWixDQUFKLENBQTFCLElBQW1EZ3lCLEVBQUMsQ0FBRyxHQUFJb0osV0FBSixDQUFlcDdCLENBQWYsQ0FBSixDQUNuRCxNQUFPLE1BQUtzOEIsR0FBTCxDQUFTOTNCLENBQVQsQ0FBV3d0QixDQUFYLENBQVAsQ0FDRCxDQUVEO0FBQ0FsVixVQUFVLENBQUNoYyxTQUFYLENBQXFCeTRCLE1BQXJCLENBQThCakMsU0FBOUIsQ0FDQXhhLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJtZixPQUFyQixDQUErQnNYLFVBQS9CLENBQ0F6YSxVQUFVLENBQUNoYyxTQUFYLENBQXFCbTFCLFVBQXJCLENBQWtDd0IsYUFBbEMsQ0FDQTNhLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUIrMkIsS0FBckIsQ0FBNkJHLFFBQTdCLENBQ0FsYixVQUFVLENBQUNoYyxTQUFYLENBQXFCbTVCLFNBQXJCLENBQWlDeEIsWUFBakMsQ0FDQTNiLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJxNUIsU0FBckIsQ0FBaUN6QixZQUFqQyxDQUNBNWIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjY0QixRQUFyQixDQUFnQ2hCLFdBQWhDLENBQ0E3YixVQUFVLENBQUNoYyxTQUFYLENBQXFCczVCLFFBQXJCLENBQWdDcEIsV0FBaEMsQ0FDQWxjLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJpM0IsS0FBckIsQ0FBNkJrQixRQUE3QixDQUNBbmMsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjg1QixVQUFyQixDQUFrQzFCLGFBQWxDLENBQ0FwYyxVQUFVLENBQUNoYyxTQUFYLENBQXFCZzZCLFFBQXJCLENBQWdDM0IsV0FBaEMsQ0FDQXJjLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJ3NUIsUUFBckIsQ0FBZ0NsQixXQUFoQyxDQUNBdGMsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQnc2QixRQUFyQixDQUFnQ0gsV0FBaEMsQ0FDQXJlLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJ1N0IsTUFBckIsQ0FBOEJKLFNBQTlCLENBQ0FuZixVQUFVLENBQUNoYyxTQUFYLENBQXFCdzdCLEdBQXJCLENBQTJCSixNQUEzQixDQUVBO0FBQ0FwZixVQUFVLENBQUNoYyxTQUFYLENBQXFCckUsUUFBckIsQ0FBZ0N3N0IsVUFBaEMsQ0FDQW5iLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJvM0IsTUFBckIsQ0FBOEJFLFFBQTlCLENBQ0F0YixVQUFVLENBQUNoYyxTQUFYLENBQXFCdVAsR0FBckIsQ0FBMkJnb0IsS0FBM0IsQ0FDQXZiLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJ5ZCxTQUFyQixDQUFpQytaLFdBQWpDLENBQ0F4YixVQUFVLENBQUNoYyxTQUFYLENBQXFCd2QsU0FBckIsQ0FBaUNrYSxXQUFqQyxDQUNBMWIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQmlkLEdBQXJCLENBQTJCc2MsS0FBM0IsQ0FDQXZkLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJ5N0IsU0FBckIsQ0FBaUNILFdBQWpDLENBRUE7QUFDQXRmLFVBQVUsQ0FBQ2diLElBQVgsQ0FBa0JOLEdBQUcsQ0FBQyxDQUFELENBQXJCLENBQ0ExYSxVQUFVLENBQUNtQixHQUFYLENBQWlCdVosR0FBRyxDQUFDLENBQUQsQ0FBcEIsQ0FFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBLFFBQVNnRixRQUFULEVBQW1CLENBQUUsR0FBSW5lLEVBQUMsQ0FBRzZYLEdBQUcsRUFBWCxDQUFlLEtBQUtxRCxNQUFMLENBQVlsYixDQUFaLEVBQWdCLE1BQU9BLEVBQVAsQ0FBVyxDQUUvRDtBQUNBLFFBQVNvZSxXQUFULEVBQXNCLENBQ3RCLEdBQUcsS0FBS3g3QixDQUFMLENBQVMsQ0FBWixDQUFlLENBQ2QsR0FBRyxLQUFLd0ksQ0FBTCxFQUFVLENBQWIsQ0FBZ0IsTUFBTyxNQUFLbFMsSUFBTCxDQUFVLENBQVYsRUFBYSxLQUFLby9CLEVBQXpCLENBQWhCLElBQ0ssSUFBRyxLQUFLbHRCLENBQUwsRUFBVSxDQUFiLENBQWdCLE1BQU8sQ0FBQyxDQUFSLENBQ3JCLENBSEQsSUFHTyxJQUFHLEtBQUtBLENBQUwsRUFBVSxDQUFiLENBQWdCLE1BQU8sTUFBS2xTLElBQUwsQ0FBVSxDQUFWLENBQVAsQ0FBaEIsSUFDRixJQUFHLEtBQUtrUyxDQUFMLEVBQVUsQ0FBYixDQUFnQixNQUFPLEVBQVAsQ0FDckI7QUFDQSxNQUFRLENBQUMsS0FBS2xTLElBQUwsQ0FBVSxDQUFWLEVBQWMsQ0FBQyxHQUFJLEdBQUcsS0FBS2svQixFQUFiLEVBQWtCLENBQWpDLEdBQXNDLEtBQUtBLEVBQTVDLENBQWdELEtBQUtsL0IsSUFBTCxDQUFVLENBQVYsQ0FBdkQsQ0FDQyxDQUVEO0FBQ0EsUUFBU21sQyxZQUFULEVBQXVCLENBQUUsTUFBUSxNQUFLanpCLENBQUwsRUFBUSxDQUFULENBQVksS0FBS3hJLENBQWpCLENBQW9CLEtBQUsxSixJQUFMLENBQVUsQ0FBVixHQUFjLEVBQWYsRUFBb0IsRUFBOUMsQ0FBbUQsQ0FFNUU7QUFDQSxRQUFTb2xDLGFBQVQsRUFBd0IsQ0FBRSxNQUFRLE1BQUtsekIsQ0FBTCxFQUFRLENBQVQsQ0FBWSxLQUFLeEksQ0FBakIsQ0FBb0IsS0FBSzFKLElBQUwsQ0FBVSxDQUFWLEdBQWMsRUFBZixFQUFvQixFQUE5QyxDQUFtRCxDQUU3RTtBQUNBLFFBQVNxbEMsYUFBVCxDQUFzQnZlLENBQXRCLENBQXlCLENBQUUsTUFBTzloQixLQUFJLENBQUNpVyxLQUFMLENBQVdqVyxJQUFJLENBQUNzZ0MsR0FBTCxDQUFTLEtBQUtwRyxFQUFkLENBQWlCbDZCLElBQUksQ0FBQ3VnQyxHQUFMLENBQVN6ZSxDQUFULENBQTVCLENBQVAsQ0FBa0QsQ0FFN0U7QUFDQSxRQUFTMGUsU0FBVCxFQUFvQixDQUNwQixHQUFHLEtBQUs5N0IsQ0FBTCxDQUFTLENBQVosQ0FBZSxNQUFPLENBQUMsQ0FBUixDQUFmLElBQ0ssSUFBRyxLQUFLd0ksQ0FBTCxFQUFVLENBQVYsRUFBZ0IsS0FBS0EsQ0FBTCxFQUFVLENBQVYsRUFBZSxLQUFLbFMsSUFBTCxDQUFVLENBQVYsR0FBZ0IsQ0FBbEQsQ0FBc0QsTUFBTyxFQUFQLENBQXRELElBQ0EsT0FBTyxFQUFQLENBQ0osQ0FFRDtBQUNBLFFBQVN5bEMsV0FBVCxDQUFvQi80QixDQUFwQixDQUF1QixDQUN2QixHQUFHQSxDQUFDLEVBQUksSUFBUixDQUFjQSxDQUFDLENBQUcsRUFBSixDQUNkLEdBQUcsS0FBS2c1QixNQUFMLElBQWlCLENBQWpCLEVBQXNCaDVCLENBQUMsQ0FBRyxDQUExQixFQUErQkEsQ0FBQyxDQUFHLEVBQXRDLENBQTBDLE1BQU8sR0FBUCxDQUMxQyxHQUFJaTVCLEdBQUUsQ0FBRyxLQUFLQyxTQUFMLENBQWVsNUIsQ0FBZixDQUFULENBQ0EsR0FBSThrQixFQUFDLENBQUd4c0IsSUFBSSxDQUFDczFCLEdBQUwsQ0FBUzV0QixDQUFULENBQVdpNUIsRUFBWCxDQUFSLENBQ0EsR0FBSWg5QixFQUFDLENBQUdzM0IsR0FBRyxDQUFDek8sQ0FBRCxDQUFYLENBQWdCbEssQ0FBQyxDQUFHcVgsR0FBRyxFQUF2QixDQUEyQmxFLENBQUMsQ0FBR2tFLEdBQUcsRUFBbEMsQ0FBc0M3WCxDQUFDLENBQUcsRUFBMUMsQ0FDQSxLQUFLaWMsUUFBTCxDQUFjcDZCLENBQWQsQ0FBZ0IyZSxDQUFoQixDQUFrQm1ULENBQWxCLEVBQ0EsTUFBTW5ULENBQUMsQ0FBQ29lLE1BQUYsR0FBYSxDQUFuQixDQUFzQixDQUNyQjVlLENBQUMsQ0FBRyxDQUFDMEssQ0FBQyxDQUFDaUosQ0FBQyxDQUFDb0wsUUFBRixFQUFILEVBQWlCM2dDLFFBQWpCLENBQTBCd0gsQ0FBMUIsRUFBNkJ2SCxNQUE3QixDQUFvQyxDQUFwQyxFQUF5QzJoQixDQUE3QyxDQUNBUSxDQUFDLENBQUN5YixRQUFGLENBQVdwNkIsQ0FBWCxDQUFhMmUsQ0FBYixDQUFlbVQsQ0FBZixFQUNBLENBQ0QsTUFBT0EsRUFBQyxDQUFDb0wsUUFBRixHQUFhM2dDLFFBQWIsQ0FBc0J3SCxDQUF0QixFQUEyQm9hLENBQWxDLENBQ0MsQ0FFRDtBQUNBLFFBQVNnZixhQUFULENBQXNCcDhCLENBQXRCLENBQXdCZ0QsQ0FBeEIsQ0FBMkIsQ0FDM0IsS0FBS2djLE9BQUwsQ0FBYSxDQUFiLEVBQ0EsR0FBR2hjLENBQUMsRUFBSSxJQUFSLENBQWNBLENBQUMsQ0FBRyxFQUFKLENBQ2QsR0FBSWk1QixHQUFFLENBQUcsS0FBS0MsU0FBTCxDQUFlbDVCLENBQWYsQ0FBVCxDQUNBLEdBQUkvRCxFQUFDLENBQUczRCxJQUFJLENBQUNzMUIsR0FBTCxDQUFTNXRCLENBQVQsQ0FBV2k1QixFQUFYLENBQVIsQ0FBd0J2RixFQUFFLENBQUcsS0FBN0IsQ0FBb0N0c0IsQ0FBQyxDQUFHLENBQXhDLENBQTJDOGMsQ0FBQyxDQUFHLENBQS9DLENBQ0EsSUFBSSxHQUFJdG9CLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR29CLENBQUMsQ0FBQ3RMLE1BQXJCLENBQTZCLEVBQUVrSyxDQUEvQixDQUFrQyxDQUNqQyxHQUFJMkQsRUFBQyxDQUFHNnpCLEtBQUssQ0FBQ3AyQixDQUFELENBQUdwQixDQUFILENBQWIsQ0FDQSxHQUFHMkQsQ0FBQyxDQUFHLENBQVAsQ0FBVSxDQUNSLEdBQUd2QyxDQUFDLENBQUN1SixNQUFGLENBQVMzSyxDQUFULEdBQWUsR0FBZixFQUFzQixLQUFLbzlCLE1BQUwsSUFBaUIsQ0FBMUMsQ0FBNkN0RixFQUFFLENBQUcsSUFBTCxDQUM3QyxTQUNELENBQ0R4UCxDQUFDLENBQUdsa0IsQ0FBQyxDQUFDa2tCLENBQUYsQ0FBSTNrQixDQUFSLENBQ0EsR0FBRyxFQUFFNkgsQ0FBRixFQUFPNnhCLEVBQVYsQ0FBYyxDQUNaLEtBQUtJLFNBQUwsQ0FBZXA5QixDQUFmLEVBQ0EsS0FBSzJnQixVQUFMLENBQWdCc0gsQ0FBaEIsQ0FBa0IsQ0FBbEIsRUFDQTljLENBQUMsQ0FBRyxDQUFKLENBQ0E4YyxDQUFDLENBQUcsQ0FBSixDQUNELENBQ0QsQ0FDRCxHQUFHOWMsQ0FBQyxDQUFHLENBQVAsQ0FBVSxDQUNULEtBQUtpeUIsU0FBTCxDQUFlL2dDLElBQUksQ0FBQ3MxQixHQUFMLENBQVM1dEIsQ0FBVCxDQUFXb0gsQ0FBWCxDQUFmLEVBQ0EsS0FBS3dWLFVBQUwsQ0FBZ0JzSCxDQUFoQixDQUFrQixDQUFsQixFQUNBLENBQ0QsR0FBR3dQLEVBQUgsQ0FBTzdhLFVBQVUsQ0FBQ2diLElBQVgsQ0FBZ0JDLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLElBQTNCLEVBQ04sQ0FFRDtBQUNBLFFBQVN3RixjQUFULENBQXVCeFUsQ0FBdkIsQ0FBeUI5a0IsQ0FBekIsQ0FBMkJoRSxDQUEzQixDQUE4QixDQUM5QixHQUFHLFVBQVksTUFBT2dFLEVBQXRCLENBQXlCLENBQ3hCO0FBQ0EsR0FBRzhrQixDQUFDLENBQUcsQ0FBUCxDQUFVLEtBQUs5SSxPQUFMLENBQWEsQ0FBYixFQUFWLElBQ0ssQ0FDSCxLQUFLK1YsVUFBTCxDQUFnQmpOLENBQWhCLENBQWtCOW9CLENBQWxCLEVBQ0EsR0FBRyxDQUFDLEtBQUt5Z0IsT0FBTCxDQUFhcUksQ0FBQyxDQUFDLENBQWYsQ0FBSixDQUF3QjtBQUN0QixLQUFLcEksU0FBTCxDQUFlN0QsVUFBVSxDQUFDbUIsR0FBWCxDQUFlMkMsU0FBZixDQUF5Qm1JLENBQUMsQ0FBQyxDQUEzQixDQUFmLENBQTZDMUksS0FBN0MsQ0FBbUQsSUFBbkQsRUFDRixHQUFHLEtBQUtnYyxNQUFMLEVBQUgsQ0FBa0IsS0FBS3hiLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBa0IsQ0FBbEIsRUFBc0I7QUFDeEMsTUFBTSxDQUFDLEtBQUtFLGVBQUwsQ0FBcUI5YyxDQUFyQixDQUFQLENBQWdDLENBQzlCLEtBQUs0YyxVQUFMLENBQWdCLENBQWhCLENBQWtCLENBQWxCLEVBQ0EsR0FBRyxLQUFLdkMsU0FBTCxHQUFtQnlLLENBQXRCLENBQXlCLEtBQUtnUCxLQUFMLENBQVdqYixVQUFVLENBQUNtQixHQUFYLENBQWUyQyxTQUFmLENBQXlCbUksQ0FBQyxDQUFDLENBQTNCLENBQVgsQ0FBeUMsSUFBekMsRUFDMUIsQ0FDRixDQUNELENBYkQsSUFhTyxDQUNOO0FBQ0EsR0FBSXZsQixFQUFDLENBQUcsR0FBSTNOLE1BQUosRUFBUixDQUFxQjRULENBQUMsQ0FBR3NmLENBQUMsQ0FBQyxDQUEzQixDQUNBdmxCLENBQUMsQ0FBQzdOLE1BQUYsQ0FBVyxDQUFDb3pCLENBQUMsRUFBRSxDQUFKLEVBQU8sQ0FBbEIsQ0FDQTlrQixDQUFDLENBQUMwYixTQUFGLENBQVluYyxDQUFaLEVBQ0EsR0FBR2lHLENBQUMsQ0FBRyxDQUFQLENBQVVqRyxDQUFDLENBQUMsQ0FBRCxDQUFELEVBQVMsQ0FBQyxHQUFHaUcsQ0FBSixFQUFPLENBQWhCLENBQVYsSUFBbUNqRyxFQUFDLENBQUMsQ0FBRCxDQUFELENBQU8sQ0FBUCxDQUNuQyxLQUFLeXlCLFVBQUwsQ0FBZ0J6eUIsQ0FBaEIsQ0FBa0IsR0FBbEIsRUFDQSxDQUNBLENBRUQ7QUFDQSxRQUFTZzZCLGNBQVQsRUFBeUIsQ0FDekIsR0FBSTM5QixFQUFDLENBQUcsS0FBSzRKLENBQWIsQ0FBZ0I0VSxDQUFDLENBQUcsR0FBSXhvQixNQUFKLEVBQXBCLENBQ0F3b0IsQ0FBQyxDQUFDLENBQUQsQ0FBRCxDQUFPLEtBQUtwZCxDQUFaLENBQ0EsR0FBSUQsRUFBQyxDQUFHLEtBQUt5MUIsRUFBTCxDQUFTNTJCLENBQUMsQ0FBQyxLQUFLNDJCLEVBQVIsQ0FBWSxDQUE1QixDQUErQnYyQixDQUEvQixDQUFrQy9ELENBQUMsQ0FBRyxDQUF0QyxDQUNBLEdBQUcwRCxDQUFDLEdBQUssQ0FBVCxDQUFZLENBQ1gsR0FBR21CLENBQUMsQ0FBRyxLQUFLeTFCLEVBQVQsRUFBZSxDQUFDdjJCLENBQUMsQ0FBRyxLQUFLM0ksSUFBTCxDQUFVc0ksQ0FBVixHQUFjbUIsQ0FBbkIsR0FBeUIsQ0FBQyxLQUFLQyxDQUFMLENBQU8sS0FBS3kxQixFQUFiLEdBQWtCMTFCLENBQTdELENBQ0VxZCxDQUFDLENBQUNsaUIsQ0FBQyxFQUFGLENBQUQsQ0FBUytELENBQUMsQ0FBRSxLQUFLZSxDQUFMLEVBQVMsS0FBS3cxQixFQUFMLENBQVF6MUIsQ0FBN0IsQ0FDRixNQUFNbkIsQ0FBQyxFQUFJLENBQVgsQ0FBYyxDQUNaLEdBQUdtQixDQUFDLENBQUcsQ0FBUCxDQUFVLENBQ1JkLENBQUMsQ0FBRyxDQUFDLEtBQUszSSxJQUFMLENBQVVzSSxDQUFWLEVBQWMsQ0FBQyxHQUFHbUIsQ0FBSixFQUFPLENBQXRCLEdBQTRCLEVBQUVBLENBQWxDLENBQ0FkLENBQUMsRUFBSSxLQUFLM0ksSUFBTCxDQUFVLEVBQUVzSSxDQUFaLElBQWlCbUIsQ0FBQyxFQUFFLEtBQUt5MUIsRUFBTCxDQUFRLENBQTVCLENBQUwsQ0FDRCxDQUhELElBR08sQ0FDTHYyQixDQUFDLENBQUksS0FBSzNJLElBQUwsQ0FBVXNJLENBQVYsSUFBZW1CLENBQUMsRUFBRSxDQUFsQixDQUFELENBQXVCLElBQTNCLENBQ0EsR0FBR0EsQ0FBQyxFQUFJLENBQVIsQ0FBVyxDQUFFQSxDQUFDLEVBQUksS0FBS3kxQixFQUFWLENBQWMsRUFBRTUyQixDQUFGLENBQU0sQ0FDbEMsQ0FDRCxHQUFHLENBQUNLLENBQUMsQ0FBQyxJQUFILEdBQVksQ0FBZixDQUFrQkEsQ0FBQyxFQUFJLENBQUMsR0FBTixDQUNsQixHQUFHL0QsQ0FBQyxFQUFJLENBQUwsRUFBVSxDQUFDLEtBQUs4RSxDQUFMLENBQU8sSUFBUixJQUFrQmYsQ0FBQyxDQUFDLElBQXBCLENBQWIsQ0FBd0MsRUFBRS9ELENBQUYsQ0FDeEMsR0FBR0EsQ0FBQyxDQUFHLENBQUosRUFBUytELENBQUMsRUFBSSxLQUFLZSxDQUF0QixDQUF5Qm9kLENBQUMsQ0FBQ2xpQixDQUFDLEVBQUYsQ0FBRCxDQUFTK0QsQ0FBVCxDQUMxQixDQUNELENBQ0QsTUFBT21lLEVBQVAsQ0FDQyxDQUVELFFBQVNvZixTQUFULENBQWtCMVUsQ0FBbEIsQ0FBcUIsQ0FBRSxNQUFPLE1BQUt4SyxTQUFMLENBQWV3SyxDQUFmLEdBQW1CLENBQTFCLENBQStCLENBQ3RELFFBQVMyVSxNQUFULENBQWUzVSxDQUFmLENBQWtCLENBQUUsTUFBTyxNQUFLeEssU0FBTCxDQUFld0ssQ0FBZixFQUFrQixDQUFuQixDQUFzQixJQUF0QixDQUEyQkEsQ0FBakMsQ0FBcUMsQ0FDekQsUUFBUzRVLE1BQVQsQ0FBZTVVLENBQWYsQ0FBa0IsQ0FBRSxNQUFPLE1BQUt4SyxTQUFMLENBQWV3SyxDQUFmLEVBQWtCLENBQW5CLENBQXNCLElBQXRCLENBQTJCQSxDQUFqQyxDQUFxQyxDQUV6RDtBQUNBLFFBQVM2VSxhQUFULENBQXNCN1UsQ0FBdEIsQ0FBd0I4VSxFQUF4QixDQUEyQnhmLENBQTNCLENBQThCLENBQzlCLEdBQUl4ZSxFQUFKLENBQU9pK0IsQ0FBUCxDQUFVOTlCLENBQUMsQ0FBR3pELElBQUksQ0FBQ29LLEdBQUwsQ0FBU29pQixDQUFDLENBQUN0ZixDQUFYLENBQWEsS0FBS0EsQ0FBbEIsQ0FBZCxDQUNBLElBQUk1SixDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUdHLENBQWYsQ0FBa0IsRUFBRUgsQ0FBcEIsRUFBdUJ3ZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBUCxFQUFZZytCLEVBQUUsQ0FBQyxLQUFLdG1DLElBQUwsQ0FBVXNJLENBQVYsQ0FBRCxDQUFja3BCLENBQUMsQ0FBQ3h4QixJQUFGLENBQU9zSSxDQUFQLENBQWQsQ0FBZCxDQUF2QixDQUNBLEdBQUdrcEIsQ0FBQyxDQUFDdGYsQ0FBRixDQUFNLEtBQUtBLENBQWQsQ0FBaUIsQ0FDaEJxMEIsQ0FBQyxDQUFHL1UsQ0FBQyxDQUFDOW5CLENBQUYsQ0FBSSxLQUFLeTFCLEVBQWIsQ0FDQSxJQUFJNzJCLENBQUMsQ0FBR0csQ0FBUixDQUFXSCxDQUFDLENBQUcsS0FBSzRKLENBQXBCLENBQXVCLEVBQUU1SixDQUF6QixFQUE0QndlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFQLEVBQVlnK0IsRUFBRSxDQUFDLEtBQUt0bUMsSUFBTCxDQUFVc0ksQ0FBVixDQUFELENBQWNpK0IsQ0FBZCxDQUFkLENBQTVCLENBQ0F6ZixDQUFDLENBQUM1VSxDQUFGLENBQU0sS0FBS0EsQ0FBWCxDQUNBLENBSkQsSUFJTyxDQUNOcTBCLENBQUMsQ0FBRyxLQUFLNzhCLENBQUwsQ0FBTyxLQUFLeTFCLEVBQWhCLENBQ0EsSUFBSTcyQixDQUFDLENBQUdHLENBQVIsQ0FBV0gsQ0FBQyxDQUFHa3BCLENBQUMsQ0FBQ3RmLENBQWpCLENBQW9CLEVBQUU1SixDQUF0QixFQUF5QndlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFQLEVBQVlnK0IsRUFBRSxDQUFDQyxDQUFELENBQUcvVSxDQUFDLENBQUN4eEIsSUFBRixDQUFPc0ksQ0FBUCxDQUFILENBQWQsQ0FBekIsQ0FDQXdlLENBQUMsQ0FBQzVVLENBQUYsQ0FBTXNmLENBQUMsQ0FBQ3RmLENBQVIsQ0FDQSxDQUNENFUsQ0FBQyxDQUFDcGQsQ0FBRixDQUFNNDhCLEVBQUUsQ0FBQyxLQUFLNThCLENBQU4sQ0FBUThuQixDQUFDLENBQUM5bkIsQ0FBVixDQUFSLENBQ0FvZCxDQUFDLENBQUN3WixLQUFGLEdBQ0MsQ0FFRDtBQUNBLFFBQVNrRyxPQUFULENBQWdCdjZCLENBQWhCLENBQWtCcWIsQ0FBbEIsQ0FBcUIsQ0FBRSxNQUFPcmIsRUFBQyxDQUFDcWIsQ0FBVCxDQUFhLENBQ3BDLFFBQVNtZixNQUFULENBQWVqVixDQUFmLENBQWtCLENBQUUsR0FBSTFLLEVBQUMsQ0FBRzZYLEdBQUcsRUFBWCxDQUFlLEtBQUt2VixTQUFMLENBQWVvSSxDQUFmLENBQWlCZ1YsTUFBakIsQ0FBd0IxZixDQUF4QixFQUE0QixNQUFPQSxFQUFQLENBQVcsQ0FFMUU7QUFDQSxRQUFTZ0MsTUFBVCxDQUFlN2MsQ0FBZixDQUFpQnFiLENBQWpCLENBQW9CLENBQUUsTUFBT3JiLEVBQUMsQ0FBQ3FiLENBQVQsQ0FBYSxDQUNuQyxRQUFTb2YsS0FBVCxDQUFjbFYsQ0FBZCxDQUFpQixDQUFFLEdBQUkxSyxFQUFDLENBQUc2WCxHQUFHLEVBQVgsQ0FBZSxLQUFLdlYsU0FBTCxDQUFlb0ksQ0FBZixDQUFpQjFJLEtBQWpCLENBQXVCaEMsQ0FBdkIsRUFBMkIsTUFBT0EsRUFBUCxDQUFXLENBRXhFO0FBQ0EsUUFBUzZmLE9BQVQsQ0FBZ0IxNkIsQ0FBaEIsQ0FBa0JxYixDQUFsQixDQUFxQixDQUFFLE1BQU9yYixFQUFDLENBQUNxYixDQUFULENBQWEsQ0FDcEMsUUFBU3NmLE1BQVQsQ0FBZXBWLENBQWYsQ0FBa0IsQ0FBRSxHQUFJMUssRUFBQyxDQUFHNlgsR0FBRyxFQUFYLENBQWUsS0FBS3ZWLFNBQUwsQ0FBZW9JLENBQWYsQ0FBaUJtVixNQUFqQixDQUF3QjdmLENBQXhCLEVBQTRCLE1BQU9BLEVBQVAsQ0FBVyxDQUUxRTtBQUNBLFFBQVMrZixVQUFULENBQW1CNTZCLENBQW5CLENBQXFCcWIsQ0FBckIsQ0FBd0IsQ0FBRSxNQUFPcmIsRUFBQyxDQUFDLENBQUNxYixDQUFWLENBQWMsQ0FDeEMsUUFBU3dmLFNBQVQsQ0FBa0J0VixDQUFsQixDQUFxQixDQUFFLEdBQUkxSyxFQUFDLENBQUc2WCxHQUFHLEVBQVgsQ0FBZSxLQUFLdlYsU0FBTCxDQUFlb0ksQ0FBZixDQUFpQnFWLFNBQWpCLENBQTJCL2YsQ0FBM0IsRUFBK0IsTUFBT0EsRUFBUCxDQUFXLENBRWhGO0FBQ0EsUUFBU2lnQixNQUFULEVBQWlCLENBQ2pCLEdBQUlqZ0IsRUFBQyxDQUFHNlgsR0FBRyxFQUFYLENBQ0EsSUFBSSxHQUFJcjJCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRyxLQUFLNEosQ0FBeEIsQ0FBMkIsRUFBRTVKLENBQTdCLEVBQWdDd2UsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQVAsRUFBWSxLQUFLNjJCLEVBQUwsQ0FBUSxDQUFDLEtBQUtuL0IsSUFBTCxDQUFVc0ksQ0FBVixDQUFyQixDQUFoQyxDQUNBd2UsQ0FBQyxDQUFDNVUsQ0FBRixDQUFNLEtBQUtBLENBQVgsQ0FDQTRVLENBQUMsQ0FBQ3BkLENBQUYsQ0FBTSxDQUFDLEtBQUtBLENBQVosQ0FDQSxNQUFPb2QsRUFBUCxDQUNDLENBRUQ7QUFDQSxRQUFTa2dCLFlBQVQsQ0FBcUIvOUIsQ0FBckIsQ0FBd0IsQ0FDeEIsR0FBSTZkLEVBQUMsQ0FBRzZYLEdBQUcsRUFBWCxDQUNBLEdBQUcxMUIsQ0FBQyxDQUFHLENBQVAsQ0FBVSxLQUFLNDVCLFFBQUwsQ0FBYyxDQUFDNTVCLENBQWYsQ0FBaUI2ZCxDQUFqQixFQUFWLElBQW9DLE1BQUtzYixRQUFMLENBQWNuNUIsQ0FBZCxDQUFnQjZkLENBQWhCLEVBQ3BDLE1BQU9BLEVBQVAsQ0FDQyxDQUVEO0FBQ0EsUUFBU21nQixhQUFULENBQXNCaCtCLENBQXRCLENBQXlCLENBQ3pCLEdBQUk2ZCxFQUFDLENBQUc2WCxHQUFHLEVBQVgsQ0FDQSxHQUFHMTFCLENBQUMsQ0FBRyxDQUFQLENBQVUsS0FBS201QixRQUFMLENBQWMsQ0FBQ241QixDQUFmLENBQWlCNmQsQ0FBakIsRUFBVixJQUFvQyxNQUFLK2IsUUFBTCxDQUFjNTVCLENBQWQsQ0FBZ0I2ZCxDQUFoQixFQUNwQyxNQUFPQSxFQUFQLENBQ0MsQ0FFRDtBQUNBLFFBQVNvZ0IsS0FBVCxDQUFjajdCLENBQWQsQ0FBaUIsQ0FDakIsR0FBR0EsQ0FBQyxFQUFJLENBQVIsQ0FBVyxNQUFPLENBQUMsQ0FBUixDQUNYLEdBQUk2YSxFQUFDLENBQUcsQ0FBUixDQUNBLEdBQUcsQ0FBQzdhLENBQUMsQ0FBQyxNQUFILEdBQWMsQ0FBakIsQ0FBb0IsQ0FBRUEsQ0FBQyxHQUFLLEVBQU4sQ0FBVTZhLENBQUMsRUFBSSxFQUFMLENBQVUsQ0FDMUMsR0FBRyxDQUFDN2EsQ0FBQyxDQUFDLElBQUgsR0FBWSxDQUFmLENBQWtCLENBQUVBLENBQUMsR0FBSyxDQUFOLENBQVM2YSxDQUFDLEVBQUksQ0FBTCxDQUFTLENBQ3RDLEdBQUcsQ0FBQzdhLENBQUMsQ0FBQyxHQUFILEdBQVcsQ0FBZCxDQUFpQixDQUFFQSxDQUFDLEdBQUssQ0FBTixDQUFTNmEsQ0FBQyxFQUFJLENBQUwsQ0FBUyxDQUNyQyxHQUFHLENBQUM3YSxDQUFDLENBQUMsQ0FBSCxHQUFTLENBQVosQ0FBZSxDQUFFQSxDQUFDLEdBQUssQ0FBTixDQUFTNmEsQ0FBQyxFQUFJLENBQUwsQ0FBUyxDQUNuQyxHQUFHLENBQUM3YSxDQUFDLENBQUMsQ0FBSCxHQUFTLENBQVosQ0FBZSxFQUFFNmEsQ0FBRixDQUNmLE1BQU9BLEVBQVAsQ0FDQyxDQUVEO0FBQ0EsUUFBU3FnQixrQkFBVCxFQUE2QixDQUM3QixJQUFJLEdBQUk3K0IsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLEtBQUs0SixDQUF4QixDQUEyQixFQUFFNUosQ0FBN0IsRUFDQyxHQUFHLEtBQUt0SSxJQUFMLENBQVVzSSxDQUFWLEdBQWdCLENBQW5CLENBQXNCLE1BQU9BLEVBQUMsQ0FBQyxLQUFLNDJCLEVBQVAsQ0FBVWdJLElBQUksQ0FBQyxLQUFLbG5DLElBQUwsQ0FBVXNJLENBQVYsQ0FBRCxDQUFyQixDQUR2QixDQUVBLEdBQUcsS0FBS29CLENBQUwsQ0FBUyxDQUFaLENBQWUsTUFBTyxNQUFLd0ksQ0FBTCxDQUFPLEtBQUtndEIsRUFBbkIsQ0FDZixNQUFPLENBQUMsQ0FBUixDQUNDLENBRUQ7QUFDQSxRQUFTa0ksS0FBVCxDQUFjbjdCLENBQWQsQ0FBaUIsQ0FDakIsR0FBSTZhLEVBQUMsQ0FBRyxDQUFSLENBQ0EsTUFBTTdhLENBQUMsRUFBSSxDQUFYLENBQWMsQ0FBRUEsQ0FBQyxFQUFJQSxDQUFDLENBQUMsQ0FBUCxDQUFVLEVBQUU2YSxDQUFGLENBQU0sQ0FDaEMsTUFBT0EsRUFBUCxDQUNDLENBRUQ7QUFDQSxRQUFTdWdCLFdBQVQsRUFBc0IsQ0FDdEIsR0FBSXZnQixFQUFDLENBQUcsQ0FBUixDQUFXN2EsQ0FBQyxDQUFHLEtBQUt2QyxDQUFMLENBQU8sS0FBS3kxQixFQUEzQixDQUNBLElBQUksR0FBSTcyQixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsS0FBSzRKLENBQXhCLENBQTJCLEVBQUU1SixDQUE3QixFQUFnQ3dlLENBQUMsRUFBSXNnQixJQUFJLENBQUMsS0FBS3BuQyxJQUFMLENBQVVzSSxDQUFWLEVBQWEyRCxDQUFkLENBQVQsQ0FBaEMsQ0FDQSxNQUFPNmEsRUFBUCxDQUNDLENBRUQ7QUFDQSxRQUFTd2dCLFVBQVQsQ0FBbUJyK0IsQ0FBbkIsQ0FBc0IsQ0FDdEIsR0FBSTZLLEVBQUMsQ0FBRzlPLElBQUksQ0FBQ2lXLEtBQUwsQ0FBV2hTLENBQUMsQ0FBQyxLQUFLaTJCLEVBQWxCLENBQVIsQ0FDQSxHQUFHcHJCLENBQUMsRUFBSSxLQUFLNUIsQ0FBYixDQUFnQixNQUFPLE1BQUt4SSxDQUFMLEVBQVEsQ0FBZixDQUNoQixNQUFPLENBQUMsS0FBSzFKLElBQUwsQ0FBVThULENBQVYsRUFBYyxHQUFJN0ssQ0FBQyxDQUFDLEtBQUtpMkIsRUFBMUIsR0FBaUMsQ0FBeEMsQ0FDQyxDQUVEO0FBQ0EsUUFBU3FJLGFBQVQsQ0FBc0J0K0IsQ0FBdEIsQ0FBd0JxOUIsRUFBeEIsQ0FBNEIsQ0FDNUIsR0FBSXhmLEVBQUMsQ0FBR3ZCLFVBQVUsQ0FBQ21CLEdBQVgsQ0FBZTJDLFNBQWYsQ0FBeUJwZ0IsQ0FBekIsQ0FBUixDQUNBLEtBQUttZ0IsU0FBTCxDQUFldEMsQ0FBZixDQUFpQndmLEVBQWpCLENBQW9CeGYsQ0FBcEIsRUFDQSxNQUFPQSxFQUFQLENBQ0MsQ0FFRDtBQUNBLFFBQVMwZ0IsU0FBVCxDQUFrQnYrQixDQUFsQixDQUFxQixDQUFFLE1BQU8sTUFBS3crQixTQUFMLENBQWV4K0IsQ0FBZixDQUFpQjZmLEtBQWpCLENBQVAsQ0FBaUMsQ0FFeEQ7QUFDQSxRQUFTNGUsV0FBVCxDQUFvQnorQixDQUFwQixDQUF1QixDQUFFLE1BQU8sTUFBS3crQixTQUFMLENBQWV4K0IsQ0FBZixDQUFpQjQ5QixTQUFqQixDQUFQLENBQXFDLENBRTlEO0FBQ0EsUUFBU2MsVUFBVCxDQUFtQjErQixDQUFuQixDQUFzQixDQUFFLE1BQU8sTUFBS3crQixTQUFMLENBQWV4K0IsQ0FBZixDQUFpQjA5QixNQUFqQixDQUFQLENBQWtDLENBRTFEO0FBQ0EsUUFBU2lCLFNBQVQsQ0FBa0JwVyxDQUFsQixDQUFvQjFLLENBQXBCLENBQXVCLENBQ3ZCLEdBQUl4ZSxFQUFDLENBQUcsQ0FBUixDQUFXSSxDQUFDLENBQUcsQ0FBZixDQUFrQkQsQ0FBQyxDQUFHekQsSUFBSSxDQUFDb0ssR0FBTCxDQUFTb2lCLENBQUMsQ0FBQ3RmLENBQVgsQ0FBYSxLQUFLQSxDQUFsQixDQUF0QixDQUNBLE1BQU01SixDQUFDLENBQUdHLENBQVYsQ0FBYSxDQUNaQyxDQUFDLEVBQUksS0FBSzFJLElBQUwsQ0FBVXNJLENBQVYsRUFBYWtwQixDQUFDLENBQUN4eEIsSUFBRixDQUFPc0ksQ0FBUCxDQUFsQixDQUNBd2UsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQUMsRUFBUixFQUFjSSxDQUFDLENBQUMsS0FBS3kyQixFQUFyQixDQUNBejJCLENBQUMsR0FBSyxLQUFLdzJCLEVBQVgsQ0FDQSxDQUNELEdBQUcxTixDQUFDLENBQUN0ZixDQUFGLENBQU0sS0FBS0EsQ0FBZCxDQUFpQixDQUNoQnhKLENBQUMsRUFBSThvQixDQUFDLENBQUM5bkIsQ0FBUCxDQUNBLE1BQU1wQixDQUFDLENBQUcsS0FBSzRKLENBQWYsQ0FBa0IsQ0FDaEJ4SixDQUFDLEVBQUksS0FBSzFJLElBQUwsQ0FBVXNJLENBQVYsQ0FBTCxDQUNBd2UsQ0FBQyxDQUFDOW1CLElBQUYsQ0FBT3NJLENBQUMsRUFBUixFQUFjSSxDQUFDLENBQUMsS0FBS3kyQixFQUFyQixDQUNBejJCLENBQUMsR0FBSyxLQUFLdzJCLEVBQVgsQ0FDRCxDQUNEeDJCLENBQUMsRUFBSSxLQUFLZ0IsQ0FBVixDQUNBLENBUkQsSUFRTyxDQUNOaEIsQ0FBQyxFQUFJLEtBQUtnQixDQUFWLENBQ0EsTUFBTXBCLENBQUMsQ0FBR2twQixDQUFDLENBQUN0ZixDQUFaLENBQWUsQ0FDYnhKLENBQUMsRUFBSThvQixDQUFDLENBQUN4eEIsSUFBRixDQUFPc0ksQ0FBUCxDQUFMLENBQ0F3ZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBQyxFQUFSLEVBQWNJLENBQUMsQ0FBQyxLQUFLeTJCLEVBQXJCLENBQ0F6MkIsQ0FBQyxHQUFLLEtBQUt3MkIsRUFBWCxDQUNELENBQ0R4MkIsQ0FBQyxFQUFJOG9CLENBQUMsQ0FBQzluQixDQUFQLENBQ0EsQ0FDRG9kLENBQUMsQ0FBQ3BkLENBQUYsQ0FBT2hCLENBQUMsQ0FBQyxDQUFILENBQU0sQ0FBQyxDQUFQLENBQVMsQ0FBZixDQUNBLEdBQUdBLENBQUMsQ0FBRyxDQUFQLENBQVVvZSxDQUFDLENBQUM5bUIsSUFBRixDQUFPc0ksQ0FBQyxFQUFSLEVBQWNJLENBQWQsQ0FBVixJQUNLLElBQUdBLENBQUMsQ0FBRyxDQUFDLENBQVIsQ0FBV29lLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFDLEVBQVIsRUFBYyxLQUFLODJCLEVBQUwsQ0FBUTEyQixDQUF0QixDQUNoQm9lLENBQUMsQ0FBQzVVLENBQUYsQ0FBTTVKLENBQU4sQ0FDQXdlLENBQUMsQ0FBQ3daLEtBQUYsR0FDQyxDQUVEO0FBQ0EsUUFBU3VILE1BQVQsQ0FBZXJXLENBQWYsQ0FBa0IsQ0FBRSxHQUFJMUssRUFBQyxDQUFHNlgsR0FBRyxFQUFYLENBQWUsS0FBS21KLEtBQUwsQ0FBV3RXLENBQVgsQ0FBYTFLLENBQWIsRUFBaUIsTUFBT0EsRUFBUCxDQUFXLENBRS9EO0FBQ0EsUUFBU2loQixXQUFULENBQW9CdlcsQ0FBcEIsQ0FBdUIsQ0FBRSxHQUFJMUssRUFBQyxDQUFHNlgsR0FBRyxFQUFYLENBQWUsS0FBSzZCLEtBQUwsQ0FBV2hQLENBQVgsQ0FBYTFLLENBQWIsRUFBaUIsTUFBT0EsRUFBUCxDQUFXLENBRXBFO0FBQ0EsUUFBU2toQixXQUFULENBQW9CeFcsQ0FBcEIsQ0FBdUIsQ0FBRSxHQUFJMUssRUFBQyxDQUFHNlgsR0FBRyxFQUFYLENBQWUsS0FBSzBFLFVBQUwsQ0FBZ0I3UixDQUFoQixDQUFrQjFLLENBQWxCLEVBQXNCLE1BQU9BLEVBQVAsQ0FBVyxDQUV6RTtBQUNBLFFBQVNtaEIsU0FBVCxDQUFrQnpXLENBQWxCLENBQXFCLENBQUUsR0FBSTFLLEVBQUMsQ0FBRzZYLEdBQUcsRUFBWCxDQUFlLEtBQUtvRSxRQUFMLENBQWN2UixDQUFkLENBQWdCMUssQ0FBaEIsQ0FBa0IsSUFBbEIsRUFBeUIsTUFBT0EsRUFBUCxDQUFXLENBRTFFO0FBQ0EsUUFBU29oQixZQUFULENBQXFCMVcsQ0FBckIsQ0FBd0IsQ0FBRSxHQUFJMUssRUFBQyxDQUFHNlgsR0FBRyxFQUFYLENBQWUsS0FBS29FLFFBQUwsQ0FBY3ZSLENBQWQsQ0FBZ0IsSUFBaEIsQ0FBcUIxSyxDQUFyQixFQUF5QixNQUFPQSxFQUFQLENBQVcsQ0FFN0U7QUFDQSxRQUFTcWhCLHFCQUFULENBQThCM1csQ0FBOUIsQ0FBaUMsQ0FDakMsR0FBSXBiLEVBQUMsQ0FBR3VvQixHQUFHLEVBQVgsQ0FBZTdYLENBQUMsQ0FBRzZYLEdBQUcsRUFBdEIsQ0FDQSxLQUFLb0UsUUFBTCxDQUFjdlIsQ0FBZCxDQUFnQnBiLENBQWhCLENBQWtCMFEsQ0FBbEIsRUFDQSxNQUFPLElBQUl4b0IsTUFBSixDQUFVOFgsQ0FBVixDQUFZMFEsQ0FBWixDQUFQLENBQ0MsQ0FFRDtBQUNBLFFBQVNzaEIsYUFBVCxDQUFzQm4vQixDQUF0QixDQUF5QixDQUN6QixLQUFLakosSUFBTCxDQUFVLEtBQUtrUyxDQUFmLEVBQW9CLEtBQUsrc0IsRUFBTCxDQUFRLENBQVIsQ0FBVWgyQixDQUFDLENBQUMsQ0FBWixDQUFjLElBQWQsQ0FBbUIsQ0FBbkIsQ0FBcUIsQ0FBckIsQ0FBdUIsS0FBS2lKLENBQTVCLENBQXBCLENBQ0EsRUFBRSxLQUFLQSxDQUFQLENBQ0EsS0FBS291QixLQUFMLEdBQ0MsQ0FFRDtBQUNBLFFBQVMrSCxjQUFULENBQXVCcC9CLENBQXZCLENBQXlCMm5CLENBQXpCLENBQTRCLENBQzVCLEdBQUczbkIsQ0FBQyxFQUFJLENBQVIsQ0FBVyxPQUNYLE1BQU0sS0FBS2lKLENBQUwsRUFBVTBlLENBQWhCLEVBQW1CLEtBQUs1d0IsSUFBTCxDQUFVLEtBQUtrUyxDQUFMLEVBQVYsRUFBc0IsQ0FBdEIsQ0FBbkIsQ0FDQSxLQUFLbFMsSUFBTCxDQUFVNHdCLENBQVYsR0FBZ0IzbkIsQ0FBaEIsQ0FDQSxNQUFNLEtBQUtqSixJQUFMLENBQVU0d0IsQ0FBVixHQUFnQixLQUFLd08sRUFBM0IsQ0FBK0IsQ0FDOUIsS0FBS3AvQixJQUFMLENBQVU0d0IsQ0FBVixHQUFnQixLQUFLd08sRUFBckIsQ0FDQSxHQUFHLEVBQUV4TyxDQUFGLEVBQU8sS0FBSzFlLENBQWYsQ0FBa0IsS0FBS2xTLElBQUwsQ0FBVSxLQUFLa1MsQ0FBTCxFQUFWLEVBQXNCLENBQXRCLENBQ2xCLEVBQUUsS0FBS2xTLElBQUwsQ0FBVTR3QixDQUFWLENBQUYsQ0FDQSxDQUNBLENBRUQ7QUFDQSxRQUFTMFgsUUFBVCxFQUFtQixDQUFFLENBQ3JCLFFBQVNDLEtBQVQsQ0FBY3Q4QixDQUFkLENBQWlCLENBQUUsTUFBT0EsRUFBUCxDQUFXLENBQzlCLFFBQVN1OEIsT0FBVCxDQUFnQnY4QixDQUFoQixDQUFrQnFiLENBQWxCLENBQW9CUixDQUFwQixDQUF1QixDQUFFN2EsQ0FBQyxDQUFDbzNCLFVBQUYsQ0FBYS9iLENBQWIsQ0FBZVIsQ0FBZixFQUFvQixDQUM3QyxRQUFTMmhCLE9BQVQsQ0FBZ0J4OEIsQ0FBaEIsQ0FBa0I2YSxDQUFsQixDQUFxQixDQUFFN2EsQ0FBQyxDQUFDczNCLFFBQUYsQ0FBV3pjLENBQVgsRUFBZ0IsQ0FFdkN3aEIsT0FBTyxDQUFDLytCLFNBQVIsQ0FBa0JpNkIsT0FBbEIsQ0FBNEIrRSxJQUE1QixDQUNBRCxPQUFPLENBQUMvK0IsU0FBUixDQUFrQms2QixNQUFsQixDQUEyQjhFLElBQTNCLENBQ0FELE9BQU8sQ0FBQy8rQixTQUFSLENBQWtCbTZCLEtBQWxCLENBQTBCOEUsTUFBMUIsQ0FDQUYsT0FBTyxDQUFDLytCLFNBQVIsQ0FBa0JvNkIsS0FBbEIsQ0FBMEI4RSxNQUExQixDQUVBO0FBQ0EsUUFBU0MsTUFBVCxDQUFlejdCLENBQWYsQ0FBa0IsQ0FBRSxNQUFPLE1BQUs4M0IsR0FBTCxDQUFTOTNCLENBQVQsQ0FBVyxHQUFJcTdCLFFBQUosRUFBWCxDQUFQLENBQW1DLENBRXZEO0FBQ0E7QUFDQSxRQUFTSyxtQkFBVCxDQUE0Qm5YLENBQTVCLENBQThCdm9CLENBQTlCLENBQWdDNmQsQ0FBaEMsQ0FBbUMsQ0FDbkMsR0FBSXhlLEVBQUMsQ0FBR3RELElBQUksQ0FBQ29LLEdBQUwsQ0FBUyxLQUFLOEMsQ0FBTCxDQUFPc2YsQ0FBQyxDQUFDdGYsQ0FBbEIsQ0FBb0JqSixDQUFwQixDQUFSLENBQ0E2ZCxDQUFDLENBQUNwZCxDQUFGLENBQU0sQ0FBTixDQUFTO0FBQ1RvZCxDQUFDLENBQUM1VSxDQUFGLENBQU01SixDQUFOLENBQ0EsTUFBTUEsQ0FBQyxDQUFHLENBQVYsRUFBYXdlLENBQUMsQ0FBQzltQixJQUFGLENBQU8sRUFBRXNJLENBQVQsRUFBYyxDQUFkLENBQWIsQ0FDQSxHQUFJd0wsRUFBSixDQUNBLElBQUlBLENBQUMsQ0FBR2dULENBQUMsQ0FBQzVVLENBQUYsQ0FBSSxLQUFLQSxDQUFqQixDQUFvQjVKLENBQUMsQ0FBR3dMLENBQXhCLENBQTJCLEVBQUV4TCxDQUE3QixFQUFnQ3dlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFDLENBQUMsS0FBSzRKLENBQWQsRUFBbUIsS0FBSytzQixFQUFMLENBQVEsQ0FBUixDQUFVek4sQ0FBQyxDQUFDeHhCLElBQUYsQ0FBT3NJLENBQVAsQ0FBVixDQUFvQndlLENBQXBCLENBQXNCeGUsQ0FBdEIsQ0FBd0IsQ0FBeEIsQ0FBMEIsS0FBSzRKLENBQS9CLENBQW5CLENBQWhDLENBQ0EsSUFBSTRCLENBQUMsQ0FBRzlPLElBQUksQ0FBQ29LLEdBQUwsQ0FBU29pQixDQUFDLENBQUN0ZixDQUFYLENBQWFqSixDQUFiLENBQVIsQ0FBeUJYLENBQUMsQ0FBR3dMLENBQTdCLENBQWdDLEVBQUV4TCxDQUFsQyxFQUFxQyxLQUFLMjJCLEVBQUwsQ0FBUSxDQUFSLENBQVV6TixDQUFDLENBQUN4eEIsSUFBRixDQUFPc0ksQ0FBUCxDQUFWLENBQW9Cd2UsQ0FBcEIsQ0FBc0J4ZSxDQUF0QixDQUF3QixDQUF4QixDQUEwQlcsQ0FBQyxDQUFDWCxDQUE1QixFQUFyQyxDQUNBd2UsQ0FBQyxDQUFDd1osS0FBRixHQUNDLENBRUQ7QUFDQTtBQUNBLFFBQVNzSSxtQkFBVCxDQUE0QnBYLENBQTVCLENBQThCdm9CLENBQTlCLENBQWdDNmQsQ0FBaEMsQ0FBbUMsQ0FDbkMsRUFBRTdkLENBQUYsQ0FDQSxHQUFJWCxFQUFDLENBQUd3ZSxDQUFDLENBQUM1VSxDQUFGLENBQU0sS0FBS0EsQ0FBTCxDQUFPc2YsQ0FBQyxDQUFDdGYsQ0FBVCxDQUFXakosQ0FBekIsQ0FDQTZkLENBQUMsQ0FBQ3BkLENBQUYsQ0FBTSxDQUFOLENBQVM7QUFDVCxNQUFNLEVBQUVwQixDQUFGLEVBQU8sQ0FBYixFQUFnQndlLENBQUMsQ0FBQzltQixJQUFGLENBQU9zSSxDQUFQLEVBQVksQ0FBWixDQUFoQixDQUNBLElBQUlBLENBQUMsQ0FBR3RELElBQUksQ0FBQ2tLLEdBQUwsQ0FBU2pHLENBQUMsQ0FBQyxLQUFLaUosQ0FBaEIsQ0FBa0IsQ0FBbEIsQ0FBUixDQUE4QjVKLENBQUMsQ0FBR2twQixDQUFDLENBQUN0ZixDQUFwQyxDQUF1QyxFQUFFNUosQ0FBekMsRUFDQ3dlLENBQUMsQ0FBQzltQixJQUFGLENBQU8sS0FBS2tTLENBQUwsQ0FBTzVKLENBQVAsQ0FBU1csQ0FBaEIsRUFBcUIsS0FBS2cyQixFQUFMLENBQVFoMkIsQ0FBQyxDQUFDWCxDQUFWLENBQVlrcEIsQ0FBQyxDQUFDeHhCLElBQUYsQ0FBT3NJLENBQVAsQ0FBWixDQUFzQndlLENBQXRCLENBQXdCLENBQXhCLENBQTBCLENBQTFCLENBQTRCLEtBQUs1VSxDQUFMLENBQU81SixDQUFQLENBQVNXLENBQXJDLENBQXJCLENBREQsQ0FFQTZkLENBQUMsQ0FBQ3daLEtBQUYsR0FDQXhaLENBQUMsQ0FBQzhiLFNBQUYsQ0FBWSxDQUFaLENBQWM5YixDQUFkLEVBQ0MsQ0FFRDtBQUNBLFFBQVMraEIsUUFBVCxDQUFpQnBnQyxDQUFqQixDQUFvQixDQUNwQjtBQUNBLEtBQUtrVCxFQUFMLENBQVVnakIsR0FBRyxFQUFiLENBQ0EsS0FBS21LLEVBQUwsQ0FBVW5LLEdBQUcsRUFBYixDQUNBcFosVUFBVSxDQUFDbUIsR0FBWCxDQUFlZ2MsU0FBZixDQUF5QixFQUFFajZCLENBQUMsQ0FBQ3lKLENBQTdCLENBQStCLEtBQUt5SixFQUFwQyxFQUNBLEtBQUtvdEIsRUFBTCxDQUFVLEtBQUtwdEIsRUFBTCxDQUFRcXRCLE1BQVIsQ0FBZXZnQyxDQUFmLENBQVYsQ0FDQSxLQUFLQSxDQUFMLENBQVNBLENBQVQsQ0FDQyxDQUVELFFBQVN3Z0MsZUFBVCxDQUF3Qmg5QixDQUF4QixDQUEyQixDQUMzQixHQUFHQSxDQUFDLENBQUN2QyxDQUFGLENBQU0sQ0FBTixFQUFXdUMsQ0FBQyxDQUFDaUcsQ0FBRixDQUFNLEVBQUUsS0FBS3pKLENBQUwsQ0FBT3lKLENBQTdCLENBQWdDLE1BQU9qRyxFQUFDLENBQUN1YSxHQUFGLENBQU0sS0FBSy9kLENBQVgsQ0FBUCxDQUFoQyxJQUNLLElBQUd3RCxDQUFDLENBQUMrYSxTQUFGLENBQVksS0FBS3ZlLENBQWpCLEVBQXNCLENBQXpCLENBQTRCLE1BQU93RCxFQUFQLENBQTVCLElBQ0EsQ0FBRSxHQUFJNmEsRUFBQyxDQUFHNlgsR0FBRyxFQUFYLENBQWUxeUIsQ0FBQyxDQUFDKzFCLE1BQUYsQ0FBU2xiLENBQVQsRUFBYSxLQUFLdGxCLE1BQUwsQ0FBWXNsQixDQUFaLEVBQWdCLE1BQU9BLEVBQVAsQ0FBVyxDQUM3RCxDQUVELFFBQVNvaUIsY0FBVCxDQUF1Qmo5QixDQUF2QixDQUEwQixDQUFFLE1BQU9BLEVBQVAsQ0FBVyxDQUV2QztBQUNBLFFBQVNrOUIsY0FBVCxDQUF1Qmw5QixDQUF2QixDQUEwQixDQUMxQkEsQ0FBQyxDQUFDMjJCLFNBQUYsQ0FBWSxLQUFLbjZCLENBQUwsQ0FBT3lKLENBQVAsQ0FBUyxDQUFyQixDQUF1QixLQUFLeUosRUFBNUIsRUFDQSxHQUFHMVAsQ0FBQyxDQUFDaUcsQ0FBRixDQUFNLEtBQUt6SixDQUFMLENBQU95SixDQUFQLENBQVMsQ0FBbEIsQ0FBcUIsQ0FBRWpHLENBQUMsQ0FBQ2lHLENBQUYsQ0FBTSxLQUFLekosQ0FBTCxDQUFPeUosQ0FBUCxDQUFTLENBQWYsQ0FBa0JqRyxDQUFDLENBQUNxMEIsS0FBRixHQUFZLENBQ3JELEtBQUt5SSxFQUFMLENBQVFLLGVBQVIsQ0FBd0IsS0FBS3p0QixFQUE3QixDQUFnQyxLQUFLbFQsQ0FBTCxDQUFPeUosQ0FBUCxDQUFTLENBQXpDLENBQTJDLEtBQUs0MkIsRUFBaEQsRUFDQSxLQUFLcmdDLENBQUwsQ0FBTzRnQyxlQUFQLENBQXVCLEtBQUtQLEVBQTVCLENBQStCLEtBQUtyZ0MsQ0FBTCxDQUFPeUosQ0FBUCxDQUFTLENBQXhDLENBQTBDLEtBQUt5SixFQUEvQyxFQUNBLE1BQU0xUCxDQUFDLENBQUMrYSxTQUFGLENBQVksS0FBS3JMLEVBQWpCLEVBQXVCLENBQTdCLEVBQWdDMVAsQ0FBQyxDQUFDcWQsVUFBRixDQUFhLENBQWIsQ0FBZSxLQUFLN2dCLENBQUwsQ0FBT3lKLENBQVAsQ0FBUyxDQUF4QixFQUFoQyxDQUNBakcsQ0FBQyxDQUFDdTBCLEtBQUYsQ0FBUSxLQUFLN2tCLEVBQWIsQ0FBZ0IxUCxDQUFoQixFQUNBLE1BQU1BLENBQUMsQ0FBQythLFNBQUYsQ0FBWSxLQUFLdmUsQ0FBakIsR0FBdUIsQ0FBN0IsRUFBZ0N3RCxDQUFDLENBQUN1MEIsS0FBRixDQUFRLEtBQUsvM0IsQ0FBYixDQUFld0QsQ0FBZixFQUFoQyxDQUNDLENBRUQ7QUFDQSxRQUFTcTlCLGFBQVQsQ0FBc0JyOUIsQ0FBdEIsQ0FBd0I2YSxDQUF4QixDQUEyQixDQUFFN2EsQ0FBQyxDQUFDczNCLFFBQUYsQ0FBV3pjLENBQVgsRUFBZSxLQUFLdGxCLE1BQUwsQ0FBWXNsQixDQUFaLEVBQWlCLENBRTdEO0FBQ0EsUUFBU3lpQixhQUFULENBQXNCdDlCLENBQXRCLENBQXdCcWIsQ0FBeEIsQ0FBMEJSLENBQTFCLENBQTZCLENBQUU3YSxDQUFDLENBQUNvM0IsVUFBRixDQUFhL2IsQ0FBYixDQUFlUixDQUFmLEVBQW1CLEtBQUt0bEIsTUFBTCxDQUFZc2xCLENBQVosRUFBaUIsQ0FFbkUraEIsT0FBTyxDQUFDdC9CLFNBQVIsQ0FBa0JpNkIsT0FBbEIsQ0FBNEJ5RixjQUE1QixDQUNBSixPQUFPLENBQUN0L0IsU0FBUixDQUFrQms2QixNQUFsQixDQUEyQnlGLGFBQTNCLENBQ0FMLE9BQU8sQ0FBQ3QvQixTQUFSLENBQWtCL0gsTUFBbEIsQ0FBMkIybkMsYUFBM0IsQ0FDQU4sT0FBTyxDQUFDdC9CLFNBQVIsQ0FBa0JtNkIsS0FBbEIsQ0FBMEI2RixZQUExQixDQUNBVixPQUFPLENBQUN0L0IsU0FBUixDQUFrQm82QixLQUFsQixDQUEwQjJGLFlBQTFCLENBRUE7QUFDQSxRQUFTRSxTQUFULENBQWtCdjhCLENBQWxCLENBQW9CeEUsQ0FBcEIsQ0FBdUIsQ0FDdkIsR0FBSUgsRUFBQyxDQUFHMkUsQ0FBQyxDQUFDOFosU0FBRixFQUFSLENBQXVCbmlCLENBQXZCLENBQTBCa2lCLENBQUMsQ0FBR21aLEdBQUcsQ0FBQyxDQUFELENBQWpDLENBQXNDeEYsQ0FBdEMsQ0FDQSxHQUFHbnlCLENBQUMsRUFBSSxDQUFSLENBQVcsTUFBT3dlLEVBQVAsQ0FBWCxJQUNLLElBQUd4ZSxDQUFDLENBQUcsRUFBUCxDQUFXMUQsQ0FBQyxDQUFHLENBQUosQ0FBWCxJQUNBLElBQUcwRCxDQUFDLENBQUcsRUFBUCxDQUFXMUQsQ0FBQyxDQUFHLENBQUosQ0FBWCxJQUNBLElBQUcwRCxDQUFDLENBQUcsR0FBUCxDQUFZMUQsQ0FBQyxDQUFHLENBQUosQ0FBWixJQUNBLElBQUcwRCxDQUFDLENBQUcsR0FBUCxDQUFZMUQsQ0FBQyxDQUFHLENBQUosQ0FBWixJQUNBQSxFQUFDLENBQUcsQ0FBSixDQUNMLEdBQUcwRCxDQUFDLENBQUcsQ0FBUCxDQUNDbXlCLENBQUMsQ0FBRyxHQUFJdUksUUFBSixDQUFZdjZCLENBQVosQ0FBSixDQURELElBRUssSUFBR0EsQ0FBQyxDQUFDcThCLE1BQUYsRUFBSCxDQUNKckssQ0FBQyxDQUFHLEdBQUlvTyxRQUFKLENBQVlwZ0MsQ0FBWixDQUFKLENBREksSUFHSmd5QixFQUFDLENBQUcsR0FBSW9KLFdBQUosQ0FBZXA3QixDQUFmLENBQUosQ0FFRDtBQUNBLEdBQUltOEIsRUFBQyxDQUFHLEdBQUl0bUMsTUFBSixFQUFSLENBQXFCMkssQ0FBQyxDQUFHLENBQXpCLENBQTRCd2dDLEVBQUUsQ0FBRzdrQyxDQUFDLENBQUMsQ0FBbkMsQ0FBc0NsQixFQUFFLENBQUcsQ0FBQyxHQUFHa0IsQ0FBSixFQUFPLENBQWxELENBQ0FnZ0MsQ0FBQyxDQUFDLENBQUQsQ0FBRCxDQUFPbkssQ0FBQyxDQUFDK0ksT0FBRixDQUFVLElBQVYsQ0FBUCxDQUNBLEdBQUc1K0IsQ0FBQyxDQUFHLENBQVAsQ0FBVSxDQUNULEdBQUk4a0MsR0FBRSxDQUFHL0ssR0FBRyxFQUFaLENBQ0FsRSxDQUFDLENBQUNrSixLQUFGLENBQVFpQixDQUFDLENBQUMsQ0FBRCxDQUFULENBQWE4RSxFQUFiLEVBQ0EsTUFBTXpnQyxDQUFDLEVBQUl2RixFQUFYLENBQWUsQ0FDYmtoQyxDQUFDLENBQUMzN0IsQ0FBRCxDQUFELENBQU8wMUIsR0FBRyxFQUFWLENBQ0FsRSxDQUFDLENBQUNpSixLQUFGLENBQVFnRyxFQUFSLENBQVc5RSxDQUFDLENBQUMzN0IsQ0FBQyxDQUFDLENBQUgsQ0FBWixDQUFrQjI3QixDQUFDLENBQUMzN0IsQ0FBRCxDQUFuQixFQUNBQSxDQUFDLEVBQUksQ0FBTCxDQUNELENBQ0QsQ0FFRCxHQUFJNkssRUFBQyxDQUFHN0csQ0FBQyxDQUFDaUYsQ0FBRixDQUFJLENBQVosQ0FBZTBlLENBQWYsQ0FBa0IrWSxHQUFHLENBQUcsSUFBeEIsQ0FBOEJodUIsRUFBRSxDQUFHZ2pCLEdBQUcsRUFBdEMsQ0FBMEN6c0IsQ0FBMUMsQ0FDQTVKLENBQUMsQ0FBRzA0QixLQUFLLENBQUMvekIsQ0FBQyxDQUFDak4sSUFBRixDQUFPOFQsQ0FBUCxDQUFELENBQUwsQ0FBaUIsQ0FBckIsQ0FDQSxNQUFNQSxDQUFDLEVBQUksQ0FBWCxDQUFjLENBQ2IsR0FBR3hMLENBQUMsRUFBSW1oQyxFQUFSLENBQVk3WSxDQUFDLENBQUkzakIsQ0FBQyxDQUFDak4sSUFBRixDQUFPOFQsQ0FBUCxHQUFZeEwsQ0FBQyxDQUFDbWhDLEVBQWYsQ0FBb0IvbEMsRUFBeEIsQ0FBWixJQUNLLENBQ0hrdEIsQ0FBQyxDQUFHLENBQUMzakIsQ0FBQyxDQUFDak4sSUFBRixDQUFPOFQsQ0FBUCxFQUFXLENBQUMsR0FBSXhMLENBQUMsQ0FBQyxDQUFQLEVBQVcsQ0FBdkIsR0FBNkJtaEMsRUFBRSxDQUFDbmhDLENBQXBDLENBQ0EsR0FBR3dMLENBQUMsQ0FBRyxDQUFQLENBQVU4YyxDQUFDLEVBQUkzakIsQ0FBQyxDQUFDak4sSUFBRixDQUFPOFQsQ0FBQyxDQUFDLENBQVQsR0FBYyxLQUFLb3JCLEVBQUwsQ0FBUTUyQixDQUFSLENBQVVtaEMsRUFBN0IsQ0FDWCxDQUVEeGdDLENBQUMsQ0FBR3JFLENBQUosQ0FDQSxNQUFNLENBQUNnc0IsQ0FBQyxDQUFDLENBQUgsR0FBUyxDQUFmLENBQWtCLENBQUVBLENBQUMsR0FBSyxDQUFOLENBQVMsRUFBRTNuQixDQUFGLENBQU0sQ0FDbkMsR0FBRyxDQUFDWCxDQUFDLEVBQUlXLENBQU4sRUFBVyxDQUFkLENBQWlCLENBQUVYLENBQUMsRUFBSSxLQUFLNDJCLEVBQVYsQ0FBYyxFQUFFcHJCLENBQUYsQ0FBTSxDQUN2QyxHQUFHNjFCLEdBQUgsQ0FBUSxDQUFHO0FBQ1QvRSxDQUFDLENBQUNoVSxDQUFELENBQUQsQ0FBS29SLE1BQUwsQ0FBWWxiLENBQVosRUFDQTZpQixHQUFHLENBQUcsS0FBTixDQUNELENBSEQsSUFHTyxDQUNMLE1BQU0xZ0MsQ0FBQyxDQUFHLENBQVYsQ0FBYSxDQUFFd3hCLENBQUMsQ0FBQ2tKLEtBQUYsQ0FBUTdjLENBQVIsQ0FBVW5MLEVBQVYsRUFBZThlLENBQUMsQ0FBQ2tKLEtBQUYsQ0FBUWhvQixFQUFSLENBQVdtTCxDQUFYLEVBQWU3ZCxDQUFDLEVBQUksQ0FBTCxDQUFTLENBQ3RELEdBQUdBLENBQUMsQ0FBRyxDQUFQLENBQVV3eEIsQ0FBQyxDQUFDa0osS0FBRixDQUFRN2MsQ0FBUixDQUFVbkwsRUFBVixFQUFWLElBQThCLENBQUV6SixDQUFDLENBQUc0VSxDQUFKLENBQU9BLENBQUMsQ0FBR25MLEVBQUosQ0FBUUEsRUFBRSxDQUFHekosQ0FBTCxDQUFTLENBQ3hEdW9CLENBQUMsQ0FBQ2lKLEtBQUYsQ0FBUS9uQixFQUFSLENBQVdpcEIsQ0FBQyxDQUFDaFUsQ0FBRCxDQUFaLENBQWdCOUosQ0FBaEIsRUFDRCxDQUVELE1BQU1oVCxDQUFDLEVBQUksQ0FBTCxFQUFVLENBQUM3RyxDQUFDLENBQUNqTixJQUFGLENBQU84VCxDQUFQLEVBQVcsR0FBR3hMLENBQWYsR0FBc0IsQ0FBdEMsQ0FBeUMsQ0FDdkNteUIsQ0FBQyxDQUFDa0osS0FBRixDQUFRN2MsQ0FBUixDQUFVbkwsRUFBVixFQUFlekosQ0FBQyxDQUFHNFUsQ0FBSixDQUFPQSxDQUFDLENBQUduTCxFQUFKLENBQVFBLEVBQUUsQ0FBR3pKLENBQUwsQ0FDOUIsR0FBRyxFQUFFNUosQ0FBRixDQUFNLENBQVQsQ0FBWSxDQUFFQSxDQUFDLENBQUcsS0FBSzQyQixFQUFMLENBQVEsQ0FBWixDQUFlLEVBQUVwckIsQ0FBRixDQUFNLENBQ3BDLENBQ0QsQ0FDRCxNQUFPMm1CLEVBQUMsQ0FBQ2dKLE1BQUYsQ0FBUzNjLENBQVQsQ0FBUCxDQUNDLENBRUQ7QUFDQSxRQUFTOGlCLE1BQVQsQ0FBZXBZLENBQWYsQ0FBa0IsQ0FDbEIsR0FBSXZsQixFQUFDLENBQUksS0FBS3ZDLENBQUwsQ0FBTyxDQUFSLENBQVcsS0FBS2kzQixNQUFMLEVBQVgsQ0FBeUIsS0FBS2tKLEtBQUwsRUFBakMsQ0FDQSxHQUFJdmlCLEVBQUMsQ0FBSWtLLENBQUMsQ0FBQzluQixDQUFGLENBQUksQ0FBTCxDQUFROG5CLENBQUMsQ0FBQ21QLE1BQUYsRUFBUixDQUFtQm5QLENBQUMsQ0FBQ3FZLEtBQUYsRUFBM0IsQ0FDQSxHQUFHNTlCLENBQUMsQ0FBQythLFNBQUYsQ0FBWU0sQ0FBWixFQUFpQixDQUFwQixDQUF1QixDQUFFLEdBQUlwVixFQUFDLENBQUdqRyxDQUFSLENBQVdBLENBQUMsQ0FBR3FiLENBQUosQ0FBT0EsQ0FBQyxDQUFHcFYsQ0FBSixDQUFRLENBQ25ELEdBQUk1SixFQUFDLENBQUcyRCxDQUFDLENBQUM2OUIsZUFBRixFQUFSLENBQTZCbEYsQ0FBQyxDQUFHdGQsQ0FBQyxDQUFDd2lCLGVBQUYsRUFBakMsQ0FDQSxHQUFHbEYsQ0FBQyxDQUFHLENBQVAsQ0FBVSxNQUFPMzRCLEVBQVAsQ0FDVixHQUFHM0QsQ0FBQyxDQUFHczhCLENBQVAsQ0FBVUEsQ0FBQyxDQUFHdDhCLENBQUosQ0FDVixHQUFHczhCLENBQUMsQ0FBRyxDQUFQLENBQVUsQ0FDVDM0QixDQUFDLENBQUM0MkIsUUFBRixDQUFXK0IsQ0FBWCxDQUFhMzRCLENBQWIsRUFDQXFiLENBQUMsQ0FBQ3ViLFFBQUYsQ0FBVytCLENBQVgsQ0FBYXRkLENBQWIsRUFDQSxDQUNELE1BQU1yYixDQUFDLENBQUN5NUIsTUFBRixHQUFhLENBQW5CLENBQXNCLENBQ3JCLEdBQUcsQ0FBQ3A5QixDQUFDLENBQUcyRCxDQUFDLENBQUM2OUIsZUFBRixFQUFMLEVBQTRCLENBQS9CLENBQWtDNzlCLENBQUMsQ0FBQzQyQixRQUFGLENBQVd2NkIsQ0FBWCxDQUFhMkQsQ0FBYixFQUNsQyxHQUFHLENBQUMzRCxDQUFDLENBQUdnZixDQUFDLENBQUN3aUIsZUFBRixFQUFMLEVBQTRCLENBQS9CLENBQWtDeGlCLENBQUMsQ0FBQ3ViLFFBQUYsQ0FBV3Y2QixDQUFYLENBQWFnZixDQUFiLEVBQ2xDLEdBQUdyYixDQUFDLENBQUMrYSxTQUFGLENBQVlNLENBQVosR0FBa0IsQ0FBckIsQ0FBd0IsQ0FDdEJyYixDQUFDLENBQUN1MEIsS0FBRixDQUFRbFosQ0FBUixDQUFVcmIsQ0FBVixFQUNBQSxDQUFDLENBQUM0MkIsUUFBRixDQUFXLENBQVgsQ0FBYTUyQixDQUFiLEVBQ0QsQ0FIRCxJQUdPLENBQ0xxYixDQUFDLENBQUNrWixLQUFGLENBQVF2MEIsQ0FBUixDQUFVcWIsQ0FBVixFQUNBQSxDQUFDLENBQUN1YixRQUFGLENBQVcsQ0FBWCxDQUFhdmIsQ0FBYixFQUNELENBQ0QsQ0FDRCxHQUFHc2QsQ0FBQyxDQUFHLENBQVAsQ0FBVXRkLENBQUMsQ0FBQzhhLFFBQUYsQ0FBV3dDLENBQVgsQ0FBYXRkLENBQWIsRUFDVixNQUFPQSxFQUFQLENBQ0MsQ0FFRDtBQUNBLFFBQVN5aUIsVUFBVCxDQUFtQjlnQyxDQUFuQixDQUFzQixDQUN0QixHQUFHQSxDQUFDLEVBQUksQ0FBUixDQUFXLE1BQU8sRUFBUCxDQUNYLEdBQUlOLEVBQUMsQ0FBRyxLQUFLeTJCLEVBQUwsQ0FBUW4yQixDQUFoQixDQUFtQjZkLENBQUMsQ0FBSSxLQUFLcGQsQ0FBTCxDQUFPLENBQVIsQ0FBV1QsQ0FBQyxDQUFDLENBQWIsQ0FBZSxDQUF0QyxDQUNBLEdBQUcsS0FBS2lKLENBQUwsQ0FBUyxDQUFaLENBQ0MsR0FBR3ZKLENBQUMsRUFBSSxDQUFSLENBQVdtZSxDQUFDLENBQUcsS0FBSzltQixJQUFMLENBQVUsQ0FBVixFQUFhaUosQ0FBakIsQ0FBWCxJQUNLLEtBQUksR0FBSVgsRUFBQyxDQUFHLEtBQUs0SixDQUFMLENBQU8sQ0FBbkIsQ0FBc0I1SixDQUFDLEVBQUksQ0FBM0IsQ0FBOEIsRUFBRUEsQ0FBaEMsRUFBbUN3ZSxDQUFDLENBQUcsQ0FBQ25lLENBQUMsQ0FBQ21lLENBQUYsQ0FBSSxLQUFLOW1CLElBQUwsQ0FBVXNJLENBQVYsQ0FBTCxFQUFtQlcsQ0FBdkIsQ0FBbkMsQ0FDTixNQUFPNmQsRUFBUCxDQUNDLENBRUQ7QUFDQSxRQUFTa2pCLGFBQVQsQ0FBc0J2aEMsQ0FBdEIsQ0FBeUIsQ0FDekIsR0FBSXdoQyxHQUFFLENBQUd4aEMsQ0FBQyxDQUFDcThCLE1BQUYsRUFBVCxDQUNBLEdBQUksS0FBS0EsTUFBTCxJQUFpQm1GLEVBQWxCLEVBQXlCeGhDLENBQUMsQ0FBQ2k5QixNQUFGLElBQWMsQ0FBMUMsQ0FBNkMsTUFBT25nQixXQUFVLENBQUNnYixJQUFsQixDQUM3QyxHQUFJNUssRUFBQyxDQUFHbHRCLENBQUMsQ0FBQ29oQyxLQUFGLEVBQVIsQ0FBbUJ4bkIsQ0FBQyxDQUFHLEtBQUt3bkIsS0FBTCxFQUF2QixDQUNBLEdBQUlyWSxFQUFDLENBQUd5TyxHQUFHLENBQUMsQ0FBRCxDQUFYLENBQWdCdnpCLENBQUMsQ0FBR3V6QixHQUFHLENBQUMsQ0FBRCxDQUF2QixDQUE0QnYzQixDQUFDLENBQUd1M0IsR0FBRyxDQUFDLENBQUQsQ0FBbkMsQ0FBd0N0M0IsQ0FBQyxDQUFHczNCLEdBQUcsQ0FBQyxDQUFELENBQS9DLENBQ0EsTUFBTXRLLENBQUMsQ0FBQytQLE1BQUYsSUFBYyxDQUFwQixDQUF1QixDQUN0QixNQUFNL1AsQ0FBQyxDQUFDbVAsTUFBRixFQUFOLENBQWtCLENBQ2hCblAsQ0FBQyxDQUFDa04sUUFBRixDQUFXLENBQVgsQ0FBYWxOLENBQWIsRUFDQSxHQUFHc1UsRUFBSCxDQUFPLENBQ0wsR0FBRyxDQUFDelksQ0FBQyxDQUFDc1QsTUFBRixFQUFELEVBQWUsQ0FBQ3A0QixDQUFDLENBQUNvNEIsTUFBRixFQUFuQixDQUErQixDQUFFdFQsQ0FBQyxDQUFDc1csS0FBRixDQUFRLElBQVIsQ0FBYXRXLENBQWIsRUFBaUI5a0IsQ0FBQyxDQUFDOHpCLEtBQUYsQ0FBUS8zQixDQUFSLENBQVVpRSxDQUFWLEVBQWUsQ0FDakU4a0IsQ0FBQyxDQUFDcVIsUUFBRixDQUFXLENBQVgsQ0FBYXJSLENBQWIsRUFDRCxDQUhELElBR08sSUFBRyxDQUFDOWtCLENBQUMsQ0FBQ280QixNQUFGLEVBQUosQ0FBZ0JwNEIsQ0FBQyxDQUFDOHpCLEtBQUYsQ0FBUS8zQixDQUFSLENBQVVpRSxDQUFWLEVBQ3ZCQSxDQUFDLENBQUNtMkIsUUFBRixDQUFXLENBQVgsQ0FBYW4yQixDQUFiLEVBQ0QsQ0FDRCxNQUFNMlYsQ0FBQyxDQUFDeWlCLE1BQUYsRUFBTixDQUFrQixDQUNoQnppQixDQUFDLENBQUN3Z0IsUUFBRixDQUFXLENBQVgsQ0FBYXhnQixDQUFiLEVBQ0EsR0FBRzRuQixFQUFILENBQU8sQ0FDTCxHQUFHLENBQUN2aEMsQ0FBQyxDQUFDbzhCLE1BQUYsRUFBRCxFQUFlLENBQUNuOEIsQ0FBQyxDQUFDbThCLE1BQUYsRUFBbkIsQ0FBK0IsQ0FBRXA4QixDQUFDLENBQUNvL0IsS0FBRixDQUFRLElBQVIsQ0FBYXAvQixDQUFiLEVBQWlCQyxDQUFDLENBQUM2M0IsS0FBRixDQUFRLzNCLENBQVIsQ0FBVUUsQ0FBVixFQUFlLENBQ2pFRCxDQUFDLENBQUNtNkIsUUFBRixDQUFXLENBQVgsQ0FBYW42QixDQUFiLEVBQ0QsQ0FIRCxJQUdPLElBQUcsQ0FBQ0MsQ0FBQyxDQUFDbThCLE1BQUYsRUFBSixDQUFnQm44QixDQUFDLENBQUM2M0IsS0FBRixDQUFRLzNCLENBQVIsQ0FBVUUsQ0FBVixFQUN2QkEsQ0FBQyxDQUFDazZCLFFBQUYsQ0FBVyxDQUFYLENBQWFsNkIsQ0FBYixFQUNELENBQ0QsR0FBR2d0QixDQUFDLENBQUMzTyxTQUFGLENBQVkzRSxDQUFaLEdBQWtCLENBQXJCLENBQXdCLENBQ3RCc1QsQ0FBQyxDQUFDNkssS0FBRixDQUFRbmUsQ0FBUixDQUFVc1QsQ0FBVixFQUNBLEdBQUdzVSxFQUFILENBQU96WSxDQUFDLENBQUNnUCxLQUFGLENBQVE5M0IsQ0FBUixDQUFVOG9CLENBQVYsRUFDUDlrQixDQUFDLENBQUM4ekIsS0FBRixDQUFRNzNCLENBQVIsQ0FBVStELENBQVYsRUFDRCxDQUpELElBSU8sQ0FDTDJWLENBQUMsQ0FBQ21lLEtBQUYsQ0FBUTdLLENBQVIsQ0FBVXRULENBQVYsRUFDQSxHQUFHNG5CLEVBQUgsQ0FBT3ZoQyxDQUFDLENBQUM4M0IsS0FBRixDQUFRaFAsQ0FBUixDQUFVOW9CLENBQVYsRUFDUEMsQ0FBQyxDQUFDNjNCLEtBQUYsQ0FBUTl6QixDQUFSLENBQVUvRCxDQUFWLEVBQ0QsQ0FDRCxDQUNELEdBQUcwWixDQUFDLENBQUMyRSxTQUFGLENBQVl6QixVQUFVLENBQUNtQixHQUF2QixHQUErQixDQUFsQyxDQUFxQyxNQUFPbkIsV0FBVSxDQUFDZ2IsSUFBbEIsQ0FDckMsR0FBRzUzQixDQUFDLENBQUNxZSxTQUFGLENBQVl2ZSxDQUFaLEdBQWtCLENBQXJCLENBQXdCLE1BQU9FLEVBQUMsQ0FBQzhkLFFBQUYsQ0FBV2hlLENBQVgsQ0FBUCxDQUN4QixHQUFHRSxDQUFDLENBQUMrOEIsTUFBRixHQUFhLENBQWhCLENBQW1CLzhCLENBQUMsQ0FBQ20vQixLQUFGLENBQVFyL0IsQ0FBUixDQUFVRSxDQUFWLEVBQW5CLElBQXNDLE9BQU9BLEVBQVAsQ0FDdEMsR0FBR0EsQ0FBQyxDQUFDKzhCLE1BQUYsR0FBYSxDQUFoQixDQUFtQixNQUFPLzhCLEVBQUMsQ0FBQzBlLEdBQUYsQ0FBTTVlLENBQU4sQ0FBUCxDQUFuQixJQUF5QyxPQUFPRSxFQUFQLENBQ3hDLENBRUQsR0FBSXVoQyxVQUFTLENBQUcsQ0FBQyxDQUFELENBQUcsQ0FBSCxDQUFLLENBQUwsQ0FBTyxDQUFQLENBQVMsRUFBVCxDQUFZLEVBQVosQ0FBZSxFQUFmLENBQWtCLEVBQWxCLENBQXFCLEVBQXJCLENBQXdCLEVBQXhCLENBQTJCLEVBQTNCLENBQThCLEVBQTlCLENBQWlDLEVBQWpDLENBQW9DLEVBQXBDLENBQXVDLEVBQXZDLENBQTBDLEVBQTFDLENBQTZDLEVBQTdDLENBQWdELEVBQWhELENBQW1ELEVBQW5ELENBQXNELEVBQXRELENBQXlELEVBQXpELENBQTRELEVBQTVELENBQStELEVBQS9ELENBQWtFLEVBQWxFLENBQXFFLEVBQXJFLENBQXdFLEdBQXhFLENBQTRFLEdBQTVFLENBQWdGLEdBQWhGLENBQW9GLEdBQXBGLENBQXdGLEdBQXhGLENBQTRGLEdBQTVGLENBQWdHLEdBQWhHLENBQW9HLEdBQXBHLENBQXdHLEdBQXhHLENBQTRHLEdBQTVHLENBQWdILEdBQWhILENBQW9ILEdBQXBILENBQXdILEdBQXhILENBQTRILEdBQTVILENBQWdJLEdBQWhJLENBQW9JLEdBQXBJLENBQXdJLEdBQXhJLENBQTRJLEdBQTVJLENBQWdKLEdBQWhKLENBQW9KLEdBQXBKLENBQXdKLEdBQXhKLENBQTRKLEdBQTVKLENBQWdLLEdBQWhLLENBQW9LLEdBQXBLLENBQXdLLEdBQXhLLENBQTRLLEdBQTVLLENBQWdMLEdBQWhMLENBQW9MLEdBQXBMLENBQXdMLEdBQXhMLENBQTRMLEdBQTVMLENBQWdNLEdBQWhNLENBQW9NLEdBQXBNLENBQXdNLEdBQXhNLENBQTRNLEdBQTVNLENBQWdOLEdBQWhOLENBQW9OLEdBQXBOLENBQXdOLEdBQXhOLENBQTROLEdBQTVOLENBQWdPLEdBQWhPLENBQW9PLEdBQXBPLENBQXdPLEdBQXhPLENBQTRPLEdBQTVPLENBQWdQLEdBQWhQLENBQW9QLEdBQXBQLENBQXdQLEdBQXhQLENBQTRQLEdBQTVQLENBQWdRLEdBQWhRLENBQW9RLEdBQXBRLENBQXdRLEdBQXhRLENBQTRRLEdBQTVRLENBQWdSLEdBQWhSLENBQW9SLEdBQXBSLENBQXdSLEdBQXhSLENBQTRSLEdBQTVSLENBQWdTLEdBQWhTLENBQW9TLEdBQXBTLENBQXdTLEdBQXhTLENBQTRTLEdBQTVTLENBQWdULEdBQWhULENBQW9ULEdBQXBULENBQXdULEdBQXhULENBQTRULEdBQTVULENBQWdVLEdBQWhVLENBQW9VLEdBQXBVLENBQXdVLEdBQXhVLENBQTRVLEdBQTVVLENBQWdWLEdBQWhWLENBQW9WLEdBQXBWLENBQXdWLEdBQXhWLENBQTRWLEdBQTVWLENBQWdXLEdBQWhXLENBQW9XLEdBQXBXLENBQWhCLENBQ0EsR0FBSUMsTUFBSyxDQUFHLENBQUMsR0FBRyxFQUFKLEVBQVFELFNBQVMsQ0FBQ0EsU0FBUyxDQUFDOXJDLE1BQVYsQ0FBaUIsQ0FBbEIsQ0FBN0IsQ0FFQTtBQUNBLFFBQVNnc0Msa0JBQVQsQ0FBMkJsNEIsQ0FBM0IsQ0FBOEIsQ0FDOUIsR0FBSTVKLEVBQUosQ0FBTzJELENBQUMsQ0FBRyxLQUFLNk0sR0FBTCxFQUFYLENBQ0EsR0FBRzdNLENBQUMsQ0FBQ2lHLENBQUYsRUFBTyxDQUFQLEVBQVlqRyxDQUFDLENBQUNqTSxJQUFGLENBQU8sQ0FBUCxHQUFha3FDLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDOXJDLE1BQVYsQ0FBaUIsQ0FBbEIsQ0FBckMsQ0FBMkQsQ0FDMUQsSUFBSWtLLENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsQ0FBRzRoQyxTQUFTLENBQUM5ckMsTUFBekIsQ0FBaUMsRUFBRWtLLENBQW5DLEVBQ0UsR0FBRzJELENBQUMsQ0FBQ2pNLElBQUYsQ0FBTyxDQUFQLEdBQWFrcUMsU0FBUyxDQUFDNWhDLENBQUQsQ0FBekIsQ0FBOEIsTUFBTyxLQUFQLENBRGhDLENBRUEsTUFBTyxNQUFQLENBQ0EsQ0FDRCxHQUFHMkQsQ0FBQyxDQUFDNjRCLE1BQUYsRUFBSCxDQUFlLE1BQU8sTUFBUCxDQUNmeDhCLENBQUMsQ0FBRyxDQUFKLENBQ0EsTUFBTUEsQ0FBQyxDQUFHNGhDLFNBQVMsQ0FBQzlyQyxNQUFwQixDQUE0QixDQUMzQixHQUFJcUssRUFBQyxDQUFHeWhDLFNBQVMsQ0FBQzVoQyxDQUFELENBQWpCLENBQXNCd0wsQ0FBQyxDQUFHeEwsQ0FBQyxDQUFDLENBQTVCLENBQ0EsTUFBTXdMLENBQUMsQ0FBR28yQixTQUFTLENBQUM5ckMsTUFBZCxFQUF3QnFLLENBQUMsQ0FBRzBoQyxLQUFsQyxFQUF5QzFoQyxDQUFDLEVBQUl5aEMsU0FBUyxDQUFDcDJCLENBQUMsRUFBRixDQUFkLENBQXpDLENBQ0FyTCxDQUFDLENBQUd3RCxDQUFDLENBQUNvK0IsTUFBRixDQUFTNWhDLENBQVQsQ0FBSixDQUNBLE1BQU1ILENBQUMsQ0FBR3dMLENBQVYsRUFBYSxHQUFHckwsQ0FBQyxDQUFDeWhDLFNBQVMsQ0FBQzVoQyxDQUFDLEVBQUYsQ0FBWCxFQUFvQixDQUF2QixDQUEwQixNQUFPLE1BQVAsQ0FBdkMsQ0FDQSxDQUNELE1BQU8yRCxFQUFDLENBQUNxK0IsV0FBRixDQUFjcDRCLENBQWQsQ0FBUCxDQUNDLENBRUQ7QUFDQSxRQUFTcTRCLGVBQVQsQ0FBd0JyNEIsQ0FBeEIsQ0FBMkIsQ0FDM0IsR0FBSXM0QixHQUFFLENBQUcsS0FBSy9qQixRQUFMLENBQWNsQixVQUFVLENBQUNtQixHQUF6QixDQUFULENBQ0EsR0FBSTloQixFQUFDLENBQUc0bEMsRUFBRSxDQUFDVixlQUFILEVBQVIsQ0FDQSxHQUFHbGxDLENBQUMsRUFBSSxDQUFSLENBQVcsTUFBTyxNQUFQLENBQ1gsR0FBSWtpQixFQUFDLENBQUcwakIsRUFBRSxDQUFDQyxVQUFILENBQWM3bEMsQ0FBZCxDQUFSLENBQ0EsR0FBSTJmLEtBQUksQ0FBR21tQixTQUFTLEVBQXBCLENBQ0EsR0FBSWxaLEVBQUosQ0FDQSxJQUFJLEdBQUlscEIsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHNEosQ0FBbkIsQ0FBc0IsRUFBRTVKLENBQXhCLENBQTJCLENBQzFCO0FBQ0EsRUFBRyxDQUNEa3BCLENBQUMsQ0FBRyxHQUFJak0sV0FBSixDQUFlLEtBQUt3QixTQUFMLEVBQWYsQ0FBaUN4QyxJQUFqQyxDQUFKLENBQ0QsQ0FGRCxNQUdNaU4sQ0FBQyxDQUFDeEssU0FBRixDQUFZekIsVUFBVSxDQUFDbUIsR0FBdkIsR0FBK0IsQ0FBL0IsRUFBb0M4SyxDQUFDLENBQUN4SyxTQUFGLENBQVl3akIsRUFBWixHQUFtQixDQUg3RCxFQUlBLEdBQUlsakIsRUFBQyxDQUFHa0ssQ0FBQyxDQUFDbEwsTUFBRixDQUFTUSxDQUFULENBQVcsSUFBWCxDQUFSLENBQ0EsR0FBR1EsQ0FBQyxDQUFDTixTQUFGLENBQVl6QixVQUFVLENBQUNtQixHQUF2QixHQUErQixDQUEvQixFQUFvQ1ksQ0FBQyxDQUFDTixTQUFGLENBQVl3akIsRUFBWixHQUFtQixDQUExRCxDQUE2RCxDQUMzRCxHQUFJMTJCLEVBQUMsQ0FBRyxDQUFSLENBQ0EsTUFBTUEsQ0FBQyxHQUFLbFAsQ0FBTixFQUFXMGlCLENBQUMsQ0FBQ04sU0FBRixDQUFZd2pCLEVBQVosR0FBbUIsQ0FBcEMsQ0FBdUMsQ0FDckNsakIsQ0FBQyxDQUFHQSxDQUFDLENBQUMwZCxTQUFGLENBQVksQ0FBWixDQUFjLElBQWQsQ0FBSixDQUNBLEdBQUcxZCxDQUFDLENBQUNOLFNBQUYsQ0FBWXpCLFVBQVUsQ0FBQ21CLEdBQXZCLEdBQStCLENBQWxDLENBQXFDLE1BQU8sTUFBUCxDQUN0QyxDQUNELEdBQUdZLENBQUMsQ0FBQ04sU0FBRixDQUFZd2pCLEVBQVosR0FBbUIsQ0FBdEIsQ0FBeUIsTUFBTyxNQUFQLENBQzFCLENBQ0QsQ0FDRCxNQUFPLEtBQVAsQ0FDQyxDQUVEO0FBQ0EsUUFBU0UsVUFBVCxFQUFxQixDQUNuQjtBQUNBLE1BQU8sQ0FDTDtBQUNBdGlCLFNBQVMsQ0FBRSxtQkFBU25jLENBQVQsQ0FBWSxDQUNyQixJQUFJLEdBQUkzRCxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcyRCxDQUFDLENBQUM3TixNQUFyQixDQUE2QixFQUFFa0ssQ0FBL0IsQ0FBa0MsQ0FDaEMyRCxDQUFDLENBQUMzRCxDQUFELENBQUQsQ0FBT3RELElBQUksQ0FBQ2lXLEtBQUwsQ0FBV2pXLElBQUksQ0FBQ0MsTUFBTCxHQUFnQixNQUEzQixDQUFQLENBQ0QsQ0FDRixDQU5JLENBQVAsQ0FRRCxDQUVEO0FBQ0FzZ0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQnE4QixTQUFyQixDQUFpQ1AsWUFBakMsQ0FDQTlmLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJxM0IsT0FBckIsQ0FBK0I2RSxVQUEvQixDQUNBbGdCLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUI0MkIsU0FBckIsQ0FBaUMyRixZQUFqQyxDQUNBdmdCLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJrMUIsVUFBckIsQ0FBa0N1SCxhQUFsQyxDQUNBemdCLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUI2ZixTQUFyQixDQUFpQ2lkLFlBQWpDLENBQ0E5Z0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQmsrQixTQUFyQixDQUFpQ0YsWUFBakMsQ0FDQWhpQixVQUFVLENBQUNoYyxTQUFYLENBQXFCdStCLEtBQXJCLENBQTZCRixRQUE3QixDQUNBcmlCLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJ3OEIsU0FBckIsQ0FBaUNxQyxZQUFqQyxDQUNBN2lCLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUIrZixVQUFyQixDQUFrQytlLGFBQWxDLENBQ0E5aUIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjgvQixlQUFyQixDQUF1Q1Ysa0JBQXZDLENBQ0FwakIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjYvQixlQUFyQixDQUF1Q1Isa0JBQXZDLENBQ0FyakIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjhnQyxNQUFyQixDQUE4Qk4sU0FBOUIsQ0FDQXhrQixVQUFVLENBQUNoYyxTQUFYLENBQXFCK2dDLFdBQXJCLENBQW1DQyxjQUFuQyxDQUVBO0FBQ0FobEIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQnNnQyxLQUFyQixDQUE2QjVFLE9BQTdCLENBQ0ExZixVQUFVLENBQUNoYyxTQUFYLENBQXFCczhCLFFBQXJCLENBQWdDWCxVQUFoQyxDQUNBM2YsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQmdnQixTQUFyQixDQUFpQzRiLFdBQWpDLENBQ0E1ZixVQUFVLENBQUNoYyxTQUFYLENBQXFCb2hDLFVBQXJCLENBQWtDdkYsWUFBbEMsQ0FDQTdmLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUJtOEIsTUFBckIsQ0FBOEJGLFFBQTlCLENBQ0FqZ0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQnFoQyxXQUFyQixDQUFtQzNFLGFBQW5DLENBQ0ExZ0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQndVLE1BQXJCLENBQThCbW9CLFFBQTlCLENBQ0EzZ0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjZGLEdBQXJCLENBQTJCKzJCLEtBQTNCLENBQ0E1Z0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjJGLEdBQXJCLENBQTJCazNCLEtBQTNCLENBQ0E3Z0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQnNoQyxHQUFyQixDQUEyQnBFLEtBQTNCLENBQ0FsaEIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQnVoQyxFQUFyQixDQUEwQnBFLElBQTFCLENBQ0FuaEIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQm8wQixHQUFyQixDQUEyQmlKLEtBQTNCLENBQ0FyaEIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQndoQyxNQUFyQixDQUE4QmpFLFFBQTlCLENBQ0F2aEIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQnloQyxHQUFyQixDQUEyQmpFLEtBQTNCLENBQ0F4aEIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjhmLFNBQXJCLENBQWlDMmQsV0FBakMsQ0FDQXpoQixVQUFVLENBQUNoYyxTQUFYLENBQXFCa2hDLFVBQXJCLENBQWtDeEQsWUFBbEMsQ0FDQTFoQixVQUFVLENBQUNoYyxTQUFYLENBQXFCdWdDLGVBQXJCLENBQXVDM0MsaUJBQXZDLENBQ0E1aEIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjBoQyxRQUFyQixDQUFnQzVELFVBQWhDLENBQ0E5aEIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjRmLE9BQXJCLENBQStCbWUsU0FBL0IsQ0FDQS9oQixVQUFVLENBQUNoYyxTQUFYLENBQXFCMmhDLE1BQXJCLENBQThCMUQsUUFBOUIsQ0FDQWppQixVQUFVLENBQUNoYyxTQUFYLENBQXFCNGhDLFFBQXJCLENBQWdDekQsVUFBaEMsQ0FDQW5pQixVQUFVLENBQUNoYyxTQUFYLENBQXFCNmhDLE9BQXJCLENBQStCekQsU0FBL0IsQ0FDQXBpQixVQUFVLENBQUNoYyxTQUFYLENBQXFCOGQsR0FBckIsQ0FBMkJ3Z0IsS0FBM0IsQ0FDQXRpQixVQUFVLENBQUNoYyxTQUFYLENBQXFCa2QsUUFBckIsQ0FBZ0NzaEIsVUFBaEMsQ0FDQXhpQixVQUFVLENBQUNoYyxTQUFYLENBQXFCMmQsUUFBckIsQ0FBZ0M4Z0IsVUFBaEMsQ0FDQXppQixVQUFVLENBQUNoYyxTQUFYLENBQXFCeS9CLE1BQXJCLENBQThCZixRQUE5QixDQUNBMWlCLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUI4aEMsU0FBckIsQ0FBaUNuRCxXQUFqQyxDQUNBM2lCLFVBQVUsQ0FBQ2hjLFNBQVgsQ0FBcUIraEMsa0JBQXJCLENBQTBDbkQsb0JBQTFDLENBQ0E1aUIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQitjLE1BQXJCLENBQThCa2pCLFFBQTlCLENBQ0Fqa0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQnNkLFVBQXJCLENBQWtDbWpCLFlBQWxDLENBQ0F6a0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQit3QixHQUFyQixDQUEyQm9PLEtBQTNCLENBQ0FuakIsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQjBkLEdBQXJCLENBQTJCMmlCLEtBQTNCLENBQ0Fya0IsVUFBVSxDQUFDaGMsU0FBWCxDQUFxQmlnQixlQUFyQixDQUF1QzRnQixpQkFBdkMsQ0FFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBLEtBQU8sQ0FwallHLENBcWpZVixRQXJqWVUsQ0FzallWLEtBQU8sU0FBU3JpQyxNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7R0FPQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQSxHQUFJc3RCLEtBQUksQ0FBRzN0QixNQUFNLENBQUNELE9BQVAsQ0FBaUI1QixLQUFLLENBQUN3dkIsSUFBTixDQUFheHZCLEtBQUssQ0FBQ3d2QixJQUFOLEVBQWMsRUFBdkQsQ0FDQXh2QixLQUFLLENBQUNxZCxFQUFOLENBQVNtUyxJQUFULENBQWdCeHZCLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU0MsVUFBVCxDQUFvQmtTLElBQXBCLENBQTJCQSxJQUEzQyxDQUVBOzs7O0dBS0FBLElBQUksQ0FBQy8wQixNQUFMLENBQWMsVUFBVyxDQUN2QjtBQUNBLEdBQUcsQ0FBQzRxQyxZQUFKLENBQWtCLENBQ2hCcGMsS0FBSyxHQUNOLENBRUQ7QUFDQSxHQUFJcWMsT0FBTSxDQUFHLElBQWIsQ0FFQTtBQUNBLEdBQUk3VCxPQUFNLENBQUd6eEIsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUFiLENBRUE7QUFDQSxHQUFJeWYsR0FBRSxDQUFHLEdBQUk1d0IsTUFBSixDQUFVLEVBQVYsQ0FBVCxDQUVBO0FBQ0EsR0FBSWlsQixHQUFFLENBQUcsQ0FDUHdDLFNBQVMsQ0FBRSxNQURKLENBRVA4UCxXQUFXLENBQUUsRUFGTixDQUdQRCxZQUFZLENBQUUsRUFIUCxDQUlQO0FBQ0E2VixhQUFhLENBQUUsQ0FMUixDQU1QO0FBQ0FDLGlCQUFpQixDQUFFLElBUFosQ0FRUDtBQUNBQyxpQkFBaUIsQ0FBRSxDQVRaLENBQVQsQ0FZQTs7OztLQUtBcG9CLEVBQUUsQ0FBQ3RQLEtBQUgsQ0FBVyxVQUFXLENBQ3BCO0FBQ0FzUCxFQUFFLENBQUNrb0IsYUFBSCxDQUFtQixDQUFuQixDQUVBO0FBQ0Fsb0IsRUFBRSxDQUFDbW9CLGlCQUFILENBQXVCbm9CLEVBQUUsQ0FBQ3FvQixlQUFILENBQXFCLEVBQTVDLENBQ0EsR0FBSUMsT0FBTSxDQUFHdG9CLEVBQUUsQ0FBQ29vQixpQkFBSCxDQUF1QixDQUFwQyxDQUNBLElBQUksR0FBSXJqQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUd1akMsTUFBbkIsQ0FBMkIsRUFBRXZqQyxDQUE3QixDQUFnQyxDQUM5QmliLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQjFnQyxJQUFyQixDQUEwQixDQUExQixFQUNELENBQ0Qyc0IsTUFBTSxDQUFHenhCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBVCxDQUNBKzdCLE1BQU0sQ0FBRyxDQUNQTSxFQUFFLENBQUUsVUFERyxDQUVQQyxFQUFFLENBQUUsVUFGRyxDQUdQQyxFQUFFLENBQUUsVUFIRyxDQUlQQyxFQUFFLENBQUUsVUFKRyxDQUtQQyxFQUFFLENBQUUsVUFMRyxDQUFULENBT0EsTUFBTzNvQixHQUFQLENBQ0QsQ0FuQkQsQ0FvQkE7QUFDQUEsRUFBRSxDQUFDdFAsS0FBSCxHQUVBOzs7Ozs7Ozs7S0FVQXNQLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBWSxTQUFTeFAsR0FBVCxDQUFja0csUUFBZCxDQUF3QixDQUNsQyxHQUFHQSxRQUFRLEdBQUssTUFBaEIsQ0FBd0IsQ0FDdEJsRyxHQUFHLENBQUd4RSxLQUFLLENBQUMyRCxJQUFOLENBQVcrRCxVQUFYLENBQXNCbEQsR0FBdEIsQ0FBTixDQUNELENBRUQ7QUFDQSxHQUFJa0YsSUFBRyxDQUFHbEYsR0FBRyxDQUFDdE0sTUFBZCxDQUNBbWxCLEVBQUUsQ0FBQ2tvQixhQUFILEVBQW9CNzdCLEdBQXBCLENBQ0FBLEdBQUcsQ0FBRyxDQUFFQSxHQUFHLENBQUcsV0FBUCxHQUF3QixDQUF6QixDQUE0QkEsR0FBRyxHQUFLLENBQXBDLENBQU4sQ0FDQSxJQUFJLEdBQUl0SCxFQUFDLENBQUdpYixFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJ0dEMsTUFBckIsQ0FBOEIsQ0FBMUMsQ0FBNkNrSyxDQUFDLEVBQUksQ0FBbEQsQ0FBcUQsRUFBRUEsQ0FBdkQsQ0FBMEQsQ0FDeERpYixFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJwakMsQ0FBckIsR0FBMkJzSCxHQUFHLENBQUMsQ0FBRCxDQUE5QixDQUNBQSxHQUFHLENBQUMsQ0FBRCxDQUFILENBQVNBLEdBQUcsQ0FBQyxDQUFELENBQUgsRUFBVzJULEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQnBqQyxDQUFyQixFQUEwQixXQUEzQixHQUE0QyxDQUF0RCxDQUFULENBQ0FpYixFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJwakMsQ0FBckIsRUFBMEJpYixFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJwakMsQ0FBckIsSUFBNEIsQ0FBdEQsQ0FDQXNILEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBV0EsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFTLFdBQVYsR0FBMkIsQ0FBckMsQ0FDRCxDQUVEO0FBQ0ErbkIsTUFBTSxDQUFDcHFCLFFBQVAsQ0FBZ0I3QyxHQUFoQixFQUVBO0FBQ0F5aEMsT0FBTyxDQUFDWCxNQUFELENBQVN0YyxFQUFULENBQWF5SSxNQUFiLENBQVAsQ0FFQTtBQUNBLEdBQUdBLE1BQU0sQ0FBQ2hyQixJQUFQLENBQWMsSUFBZCxFQUFzQmdyQixNQUFNLENBQUN2NUIsTUFBUCxLQUFvQixDQUE3QyxDQUFnRCxDQUM5Q3U1QixNQUFNLENBQUNqb0IsT0FBUCxHQUNELENBRUQsTUFBTzZULEdBQVAsQ0FDRCxDQTVCRCxDQThCQzs7OztNQUtBQSxFQUFFLENBQUM0QyxNQUFILENBQVksVUFBVyxDQUN0Qjs7OzJDQURzQixDQU10Qjs7Ozs7Ozs7Ozs7OztxRUFlQSxHQUFJaW1CLFdBQVUsQ0FBR2xtQyxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQWpCLENBQ0EyOEIsVUFBVSxDQUFDNytCLFFBQVgsQ0FBb0JvcUIsTUFBTSxDQUFDbHFCLEtBQVAsRUFBcEIsRUFFQTtBQUNBLEdBQUkrUSxVQUFTLENBQ1grRSxFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJub0IsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCdHRDLE1BQXJCLENBQThCLENBQW5ELEVBQ0FtbEIsRUFBRSxDQUFDb29CLGlCQUZMLENBSUE7QUFDQTtBQUNBO0FBQ0EsR0FBSTNULFNBQVEsQ0FBR3haLFNBQVMsQ0FBSStFLEVBQUUsQ0FBQ3NTLFdBQUgsQ0FBaUIsQ0FBN0MsQ0FDQXVXLFVBQVUsQ0FBQzcrQixRQUFYLENBQW9COCtCLFFBQVEsQ0FBQ2xuQyxNQUFULENBQWdCLENBQWhCLENBQW1Cb2UsRUFBRSxDQUFDc1MsV0FBSCxDQUFpQm1DLFFBQXBDLENBQXBCLEVBRUE7QUFDQTtBQUNBLEdBQUlqZ0IsS0FBSixDQUFVdTBCLEtBQVYsQ0FDQSxHQUFJcGtCLEtBQUksQ0FBRzNFLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQixDQUFyQixFQUEwQixDQUFyQyxDQUNBLElBQUksR0FBSXBqQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdpYixFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJ0dEMsTUFBckIsQ0FBOEIsQ0FBakQsQ0FBb0QsRUFBRWtLLENBQXRELENBQXlELENBQ3ZEeVAsSUFBSSxDQUFHd0wsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCcGpDLENBQUMsQ0FBRyxDQUF6QixFQUE4QixDQUFyQyxDQUNBZ2tDLEtBQUssQ0FBSXYwQixJQUFJLENBQUcsV0FBUixHQUF5QixDQUFqQyxDQUNBbVEsSUFBSSxFQUFJb2tCLEtBQVIsQ0FDQUYsVUFBVSxDQUFDcitCLFFBQVgsQ0FBb0JtYSxJQUFJLEdBQUssQ0FBN0IsRUFDQUEsSUFBSSxDQUFHblEsSUFBSSxHQUFLLENBQWhCLENBQ0QsQ0FDRHEwQixVQUFVLENBQUNyK0IsUUFBWCxDQUFvQm1hLElBQXBCLEVBRUEsR0FBSWxXLEdBQUUsQ0FBRyxDQUNQODVCLEVBQUUsQ0FBRU4sTUFBTSxDQUFDTSxFQURKLENBRVBDLEVBQUUsQ0FBRVAsTUFBTSxDQUFDTyxFQUZKLENBR1BDLEVBQUUsQ0FBRVIsTUFBTSxDQUFDUSxFQUhKLENBSVBDLEVBQUUsQ0FBRVQsTUFBTSxDQUFDUyxFQUpKLENBS1BDLEVBQUUsQ0FBRVYsTUFBTSxDQUFDVSxFQUxKLENBQVQsQ0FPQUMsT0FBTyxDQUFDbjZCLEVBQUQsQ0FBS2tkLEVBQUwsQ0FBU2tkLFVBQVQsQ0FBUCxDQUNBLEdBQUkxOUIsS0FBSSxDQUFHeEksS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUFYLENBQ0FmLElBQUksQ0FBQ1gsUUFBTCxDQUFjaUUsRUFBRSxDQUFDODVCLEVBQWpCLEVBQ0FwOUIsSUFBSSxDQUFDWCxRQUFMLENBQWNpRSxFQUFFLENBQUMrNUIsRUFBakIsRUFDQXI5QixJQUFJLENBQUNYLFFBQUwsQ0FBY2lFLEVBQUUsQ0FBQ2c2QixFQUFqQixFQUNBdDlCLElBQUksQ0FBQ1gsUUFBTCxDQUFjaUUsRUFBRSxDQUFDaTZCLEVBQWpCLEVBQ0F2OUIsSUFBSSxDQUFDWCxRQUFMLENBQWNpRSxFQUFFLENBQUNrNkIsRUFBakIsRUFDQSxNQUFPeDlCLEtBQVAsQ0FDRCxDQS9EQSxDQWlFRCxNQUFPNlUsR0FBUCxDQUNELENBdktELENBeUtBO0FBQ0EsR0FBSThvQixTQUFRLENBQUcsSUFBZixDQUNBLEdBQUlkLGFBQVksQ0FBRyxLQUFuQixDQUVBOztHQUdBLFFBQVNwYyxNQUFULEVBQWlCLENBQ2Y7QUFDQWtkLFFBQVEsQ0FBR3QvQixNQUFNLENBQUNDLFlBQVAsQ0FBb0IsR0FBcEIsQ0FBWCxDQUNBcS9CLFFBQVEsRUFBSW5tQyxLQUFLLENBQUMyRCxJQUFOLENBQVdnSSxVQUFYLENBQXNCOUUsTUFBTSxDQUFDQyxZQUFQLENBQW9CLElBQXBCLENBQXRCLENBQWlELEVBQWpELENBQVosQ0FFQTtBQUNBdStCLFlBQVksQ0FBRyxJQUFmLENBQ0QsQ0FFRDs7Ozs7O0dBT0EsUUFBU1ksUUFBVCxDQUFpQnppQyxDQUFqQixDQUFvQmtuQixDQUFwQixDQUF1Qm5qQixLQUF2QixDQUE4QixDQUM1QjtBQUNBLEdBQUl5RSxFQUFKLENBQU9zZixDQUFQLENBQVU5a0IsQ0FBVixDQUFhaEUsQ0FBYixDQUFnQkMsQ0FBaEIsQ0FBbUJzRSxDQUFuQixDQUFzQnM1QixDQUF0QixDQUF5QmorQixDQUF6QixDQUNBLEdBQUlzSCxJQUFHLENBQUduQyxLQUFLLENBQUNyUCxNQUFOLEVBQVYsQ0FDQSxNQUFNd1IsR0FBRyxFQUFJLEVBQWIsQ0FBaUIsQ0FDZjtBQUNBO0FBQ0E7QUFFQTtBQUNBNGhCLENBQUMsQ0FBRzluQixDQUFDLENBQUNvaUMsRUFBTixDQUNBcC9CLENBQUMsQ0FBR2hELENBQUMsQ0FBQ3FpQyxFQUFOLENBQ0FyakMsQ0FBQyxDQUFHZ0IsQ0FBQyxDQUFDc2lDLEVBQU4sQ0FDQXJqQyxDQUFDLENBQUdlLENBQUMsQ0FBQ3VpQyxFQUFOLENBQ0FoL0IsQ0FBQyxDQUFHdkQsQ0FBQyxDQUFDd2lDLEVBQU4sQ0FFQTtBQUNBLElBQUk1akMsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHLEVBQWYsQ0FBbUIsRUFBRUEsQ0FBckIsQ0FBd0IsQ0FDdEI0SixDQUFDLENBQUd6RSxLQUFLLENBQUNtQixRQUFOLEVBQUosQ0FDQWdpQixDQUFDLENBQUN0b0IsQ0FBRCxDQUFELENBQU80SixDQUFQLENBQ0FxMEIsQ0FBQyxDQUFHNTlCLENBQUMsQ0FBSStELENBQUMsRUFBSWhFLENBQUMsQ0FBR0MsQ0FBUixDQUFWLENBQ0F1SixDQUFDLENBQUcsQ0FBRXNmLENBQUMsRUFBSSxDQUFOLENBQVlBLENBQUMsR0FBSyxFQUFuQixFQUEwQitVLENBQTFCLENBQThCdDVCLENBQTlCLENBQWtDLFVBQWxDLENBQStDaUYsQ0FBbkQsQ0FDQWpGLENBQUMsQ0FBR3RFLENBQUosQ0FDQUEsQ0FBQyxDQUFHRCxDQUFKLENBQ0E7QUFDQUEsQ0FBQyxDQUFHLENBQUVnRSxDQUFDLEVBQUksRUFBTixDQUFhQSxDQUFDLEdBQUssQ0FBcEIsSUFBNEIsQ0FBaEMsQ0FDQUEsQ0FBQyxDQUFHOGtCLENBQUosQ0FDQUEsQ0FBQyxDQUFHdGYsQ0FBSixDQUNELENBQ0QsS0FBTTVKLENBQUMsQ0FBRyxFQUFWLENBQWMsRUFBRUEsQ0FBaEIsQ0FBbUIsQ0FDakI0SixDQUFDLENBQUkwZSxDQUFDLENBQUN0b0IsQ0FBQyxDQUFHLENBQUwsQ0FBRCxDQUFXc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsQ0FBTCxDQUFaLENBQXNCc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsRUFBTCxDQUF2QixDQUFrQ3NvQixDQUFDLENBQUN0b0IsQ0FBQyxDQUFHLEVBQUwsQ0FBeEMsQ0FDQTRKLENBQUMsQ0FBSUEsQ0FBQyxFQUFJLENBQU4sQ0FBWUEsQ0FBQyxHQUFLLEVBQXRCLENBQ0EwZSxDQUFDLENBQUN0b0IsQ0FBRCxDQUFELENBQU80SixDQUFQLENBQ0FxMEIsQ0FBQyxDQUFHNTlCLENBQUMsQ0FBSStELENBQUMsRUFBSWhFLENBQUMsQ0FBR0MsQ0FBUixDQUFWLENBQ0F1SixDQUFDLENBQUcsQ0FBRXNmLENBQUMsRUFBSSxDQUFOLENBQVlBLENBQUMsR0FBSyxFQUFuQixFQUEwQitVLENBQTFCLENBQThCdDVCLENBQTlCLENBQWtDLFVBQWxDLENBQStDaUYsQ0FBbkQsQ0FDQWpGLENBQUMsQ0FBR3RFLENBQUosQ0FDQUEsQ0FBQyxDQUFHRCxDQUFKLENBQ0E7QUFDQUEsQ0FBQyxDQUFHLENBQUVnRSxDQUFDLEVBQUksRUFBTixDQUFhQSxDQUFDLEdBQUssQ0FBcEIsSUFBNEIsQ0FBaEMsQ0FDQUEsQ0FBQyxDQUFHOGtCLENBQUosQ0FDQUEsQ0FBQyxDQUFHdGYsQ0FBSixDQUNELENBQ0Q7QUFDQSxLQUFNNUosQ0FBQyxDQUFHLEVBQVYsQ0FBYyxFQUFFQSxDQUFoQixDQUFtQixDQUNqQjRKLENBQUMsQ0FBSTBlLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsQ0FBTCxDQUFELENBQVdzb0IsQ0FBQyxDQUFDdG9CLENBQUMsQ0FBRyxDQUFMLENBQVosQ0FBc0Jzb0IsQ0FBQyxDQUFDdG9CLENBQUMsQ0FBRyxFQUFMLENBQXZCLENBQWtDc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsRUFBTCxDQUF4QyxDQUNBNEosQ0FBQyxDQUFJQSxDQUFDLEVBQUksQ0FBTixDQUFZQSxDQUFDLEdBQUssRUFBdEIsQ0FDQTBlLENBQUMsQ0FBQ3RvQixDQUFELENBQUQsQ0FBTzRKLENBQVAsQ0FDQXEwQixDQUFDLENBQUc3NUIsQ0FBQyxDQUFHaEUsQ0FBSixDQUFRQyxDQUFaLENBQ0F1SixDQUFDLENBQUcsQ0FBRXNmLENBQUMsRUFBSSxDQUFOLENBQVlBLENBQUMsR0FBSyxFQUFuQixFQUEwQitVLENBQTFCLENBQThCdDVCLENBQTlCLENBQWtDLFVBQWxDLENBQStDaUYsQ0FBbkQsQ0FDQWpGLENBQUMsQ0FBR3RFLENBQUosQ0FDQUEsQ0FBQyxDQUFHRCxDQUFKLENBQ0E7QUFDQUEsQ0FBQyxDQUFHLENBQUVnRSxDQUFDLEVBQUksRUFBTixDQUFhQSxDQUFDLEdBQUssQ0FBcEIsSUFBNEIsQ0FBaEMsQ0FDQUEsQ0FBQyxDQUFHOGtCLENBQUosQ0FDQUEsQ0FBQyxDQUFHdGYsQ0FBSixDQUNELENBQ0QsS0FBTTVKLENBQUMsQ0FBRyxFQUFWLENBQWMsRUFBRUEsQ0FBaEIsQ0FBbUIsQ0FDakI0SixDQUFDLENBQUkwZSxDQUFDLENBQUN0b0IsQ0FBQyxDQUFHLENBQUwsQ0FBRCxDQUFXc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsRUFBTCxDQUFaLENBQXVCc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsRUFBTCxDQUF4QixDQUFtQ3NvQixDQUFDLENBQUN0b0IsQ0FBQyxDQUFHLEVBQUwsQ0FBekMsQ0FDQTRKLENBQUMsQ0FBSUEsQ0FBQyxFQUFJLENBQU4sQ0FBWUEsQ0FBQyxHQUFLLEVBQXRCLENBQ0EwZSxDQUFDLENBQUN0b0IsQ0FBRCxDQUFELENBQU80SixDQUFQLENBQ0FxMEIsQ0FBQyxDQUFHNzVCLENBQUMsQ0FBR2hFLENBQUosQ0FBUUMsQ0FBWixDQUNBdUosQ0FBQyxDQUFHLENBQUVzZixDQUFDLEVBQUksQ0FBTixDQUFZQSxDQUFDLEdBQUssRUFBbkIsRUFBMEIrVSxDQUExQixDQUE4QnQ1QixDQUE5QixDQUFrQyxVQUFsQyxDQUErQ2lGLENBQW5ELENBQ0FqRixDQUFDLENBQUd0RSxDQUFKLENBQ0FBLENBQUMsQ0FBR0QsQ0FBSixDQUNBO0FBQ0FBLENBQUMsQ0FBRyxDQUFFZ0UsQ0FBQyxFQUFJLEVBQU4sQ0FBYUEsQ0FBQyxHQUFLLENBQXBCLElBQTRCLENBQWhDLENBQ0FBLENBQUMsQ0FBRzhrQixDQUFKLENBQ0FBLENBQUMsQ0FBR3RmLENBQUosQ0FDRCxDQUNEO0FBQ0EsS0FBTTVKLENBQUMsQ0FBRyxFQUFWLENBQWMsRUFBRUEsQ0FBaEIsQ0FBbUIsQ0FDakI0SixDQUFDLENBQUkwZSxDQUFDLENBQUN0b0IsQ0FBQyxDQUFHLENBQUwsQ0FBRCxDQUFXc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsRUFBTCxDQUFaLENBQXVCc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsRUFBTCxDQUF4QixDQUFtQ3NvQixDQUFDLENBQUN0b0IsQ0FBQyxDQUFHLEVBQUwsQ0FBekMsQ0FDQTRKLENBQUMsQ0FBSUEsQ0FBQyxFQUFJLENBQU4sQ0FBWUEsQ0FBQyxHQUFLLEVBQXRCLENBQ0EwZSxDQUFDLENBQUN0b0IsQ0FBRCxDQUFELENBQU80SixDQUFQLENBQ0FxMEIsQ0FBQyxDQUFJNzVCLENBQUMsQ0FBR2hFLENBQUwsQ0FBV0MsQ0FBQyxFQUFJK0QsQ0FBQyxDQUFHaEUsQ0FBUixDQUFoQixDQUNBd0osQ0FBQyxDQUFHLENBQUVzZixDQUFDLEVBQUksQ0FBTixDQUFZQSxDQUFDLEdBQUssRUFBbkIsRUFBMEIrVSxDQUExQixDQUE4QnQ1QixDQUE5QixDQUFrQyxVQUFsQyxDQUErQ2lGLENBQW5ELENBQ0FqRixDQUFDLENBQUd0RSxDQUFKLENBQ0FBLENBQUMsQ0FBR0QsQ0FBSixDQUNBO0FBQ0FBLENBQUMsQ0FBRyxDQUFFZ0UsQ0FBQyxFQUFJLEVBQU4sQ0FBYUEsQ0FBQyxHQUFLLENBQXBCLElBQTRCLENBQWhDLENBQ0FBLENBQUMsQ0FBRzhrQixDQUFKLENBQ0FBLENBQUMsQ0FBR3RmLENBQUosQ0FDRCxDQUNEO0FBQ0EsS0FBTTVKLENBQUMsQ0FBRyxFQUFWLENBQWMsRUFBRUEsQ0FBaEIsQ0FBbUIsQ0FDakI0SixDQUFDLENBQUkwZSxDQUFDLENBQUN0b0IsQ0FBQyxDQUFHLENBQUwsQ0FBRCxDQUFXc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsRUFBTCxDQUFaLENBQXVCc29CLENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsRUFBTCxDQUF4QixDQUFtQ3NvQixDQUFDLENBQUN0b0IsQ0FBQyxDQUFHLEVBQUwsQ0FBekMsQ0FDQTRKLENBQUMsQ0FBSUEsQ0FBQyxFQUFJLENBQU4sQ0FBWUEsQ0FBQyxHQUFLLEVBQXRCLENBQ0EwZSxDQUFDLENBQUN0b0IsQ0FBRCxDQUFELENBQU80SixDQUFQLENBQ0FxMEIsQ0FBQyxDQUFHNzVCLENBQUMsQ0FBR2hFLENBQUosQ0FBUUMsQ0FBWixDQUNBdUosQ0FBQyxDQUFHLENBQUVzZixDQUFDLEVBQUksQ0FBTixDQUFZQSxDQUFDLEdBQUssRUFBbkIsRUFBMEIrVSxDQUExQixDQUE4QnQ1QixDQUE5QixDQUFrQyxVQUFsQyxDQUErQ2lGLENBQW5ELENBQ0FqRixDQUFDLENBQUd0RSxDQUFKLENBQ0FBLENBQUMsQ0FBR0QsQ0FBSixDQUNBO0FBQ0FBLENBQUMsQ0FBRyxDQUFFZ0UsQ0FBQyxFQUFJLEVBQU4sQ0FBYUEsQ0FBQyxHQUFLLENBQXBCLElBQTRCLENBQWhDLENBQ0FBLENBQUMsQ0FBRzhrQixDQUFKLENBQ0FBLENBQUMsQ0FBR3RmLENBQUosQ0FDRCxDQUVEO0FBQ0F4SSxDQUFDLENBQUNvaUMsRUFBRixDQUFRcGlDLENBQUMsQ0FBQ29pQyxFQUFGLENBQU90YSxDQUFSLENBQWEsQ0FBcEIsQ0FDQTluQixDQUFDLENBQUNxaUMsRUFBRixDQUFRcmlDLENBQUMsQ0FBQ3FpQyxFQUFGLENBQU9yL0IsQ0FBUixDQUFhLENBQXBCLENBQ0FoRCxDQUFDLENBQUNzaUMsRUFBRixDQUFRdGlDLENBQUMsQ0FBQ3NpQyxFQUFGLENBQU90akMsQ0FBUixDQUFhLENBQXBCLENBQ0FnQixDQUFDLENBQUN1aUMsRUFBRixDQUFRdmlDLENBQUMsQ0FBQ3VpQyxFQUFGLENBQU90akMsQ0FBUixDQUFhLENBQXBCLENBQ0FlLENBQUMsQ0FBQ3dpQyxFQUFGLENBQVF4aUMsQ0FBQyxDQUFDd2lDLEVBQUYsQ0FBT2ovQixDQUFSLENBQWEsQ0FBcEIsQ0FFQTJDLEdBQUcsRUFBSSxFQUFQLENBQ0QsQ0FDRixDQUdELEtBQU8sQ0F6M1lHLENBMDNZVixRQTEzWVUsQ0EyM1lWLEtBQU8sU0FBUzdILE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZHQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBRUE7QUFDQSxHQUFJd1QsS0FBSSxDQUFHMVYsS0FBSyxDQUFDMFYsSUFBakIsQ0FFQSxxREFDQSxHQUFJaFYsSUFBRyxDQUFHbUIsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDVSxHQUFOLENBQVlWLEtBQUssQ0FBQ1UsR0FBTixFQUFhLEVBQXBELENBQ0EsR0FBSXVjLEtBQUksQ0FBR3ZjLEdBQUcsQ0FBQ3VjLElBQWYsQ0FFQTtBQUNBLEdBQUlvcEIsWUFBVyxDQUFHLEVBQWxCLENBQ0FBLFdBQVcsQ0FBQyxJQUFELENBQVgsQ0FBb0JwcEIsSUFBSSxDQUFDLFlBQUQsQ0FBeEIsQ0FDQW9wQixXQUFXLENBQUMsWUFBRCxDQUFYLENBQTRCLElBQTVCLENBQ0FBLFdBQVcsQ0FBQyxHQUFELENBQVgsQ0FBbUJwcEIsSUFBSSxDQUFDLGFBQUQsQ0FBdkIsQ0FDQW9wQixXQUFXLENBQUMsYUFBRCxDQUFYLENBQTZCLEdBQTdCLENBQ0FBLFdBQVcsQ0FBQyxHQUFELENBQVgsQ0FBbUJwcEIsSUFBSSxDQUFDLGNBQUQsQ0FBdkIsQ0FDQW9wQixXQUFXLENBQUMsY0FBRCxDQUFYLENBQThCLEdBQTlCLENBQ0FBLFdBQVcsQ0FBQyxJQUFELENBQVgsQ0FBb0JwcEIsSUFBSSxDQUFDLHFCQUFELENBQXhCLENBQ0FvcEIsV0FBVyxDQUFDLHFCQUFELENBQVgsQ0FBcUMsSUFBckMsQ0FDQUEsV0FBVyxDQUFDLEdBQUQsQ0FBWCxDQUFtQnBwQixJQUFJLENBQUMsa0JBQUQsQ0FBdkIsQ0FDQW9wQixXQUFXLENBQUMsa0JBQUQsQ0FBWCxDQUFrQyxHQUFsQyxDQUNBQSxXQUFXLENBQUMsSUFBRCxDQUFYLENBQW9CcHBCLElBQUksQ0FBQyx3QkFBRCxDQUF4QixDQUNBb3BCLFdBQVcsQ0FBQyx3QkFBRCxDQUFYLENBQXdDLElBQXhDLENBQ0FBLFdBQVcsQ0FBQyxHQUFELENBQVgsQ0FBbUJwcEIsSUFBSSxDQUFDLGNBQUQsQ0FBdkIsQ0FDQW9wQixXQUFXLENBQUMsY0FBRCxDQUFYLENBQThCLEdBQTlCLENBRUE7QUFDQTtBQUNBLEdBQUkxbUIsbUJBQWtCLENBQUczZixLQUFLLENBQUNVLEdBQU4sQ0FBVU4sR0FBVixDQUFjdWYsa0JBQXZDLENBRUE7QUFDQSxHQUFJMm1CLHlCQUF3QixDQUFHLENBQzdCMW5DLElBQUksQ0FBRSxhQUR1QixDQUU3QjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZRLENBRzdCN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGEsQ0FJN0JRLFdBQVcsQ0FBRSxJQUpnQixDQUs3QjNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsNEJBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIVixDQUlOUSxXQUFXLENBQUUsSUFKUCxDQUtOK0UsV0FBVyxDQUFFLGdCQUxQLENBTU4xSyxLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLG9DQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRmYsQ0FHTi9HLElBQUksQ0FBRSxDQUhBLENBSU53SSxXQUFXLENBQUUsSUFKUCxDQUtOOEUsUUFBUSxDQUFFLElBTEosQ0FNTnpLLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsNENBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIVixDQUlOb0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxhQUxILENBQUQsQ0FORCxDQUFELENBYUosQ0FDRHhkLElBQUksQ0FBRSx5Q0FETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIZixDQUlEb0IsV0FBVyxDQUFFLEtBSlosQ0FLRDZFLE9BQU8sQ0FBRSxrQkFMUixDQWJJLENBbUJKLENBQ0R4ZCxJQUFJLENBQUUsc0NBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGYsQ0FJRFEsV0FBVyxDQUFFLElBSlosQ0FLRDNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsZ0RBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxzQkFMSCxDQUFELENBTUosQ0FDRHhkLElBQUksQ0FBRSxpREFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0R5RyxRQUFRLENBQUUsSUFIVCxDQUlEQyxXQUFXLENBQUUseUJBSlosQ0FOSSxDQUxOLENBbkJJLENBb0NKLENBQ0QxZCxJQUFJLENBQUUsbUNBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGYsQ0FJRFEsV0FBVyxDQUFFLElBSlosQ0FLRCtFLFdBQVcsQ0FBRSxZQUxaLENBcENJLENBMENKLENBQ0QxZCxJQUFJLENBQUUscUNBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGYsQ0FJRFEsV0FBVyxDQUFFLElBSlosQ0FLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBM0YsS0FBSyxDQUFFLENBQUMsQ0FDTjtBQUNBaFQsSUFBSSxDQUFFLHFEQUZBLENBR04wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIZixDQUlON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVtQixPQUpWLENBS05JLFdBQVcsQ0FBRSxLQUxQLENBTU44RSxRQUFRLENBQUUsSUFOSixDQU9ORCxPQUFPLENBQUUsc0JBUEgsQ0FBRCxDQVFKLENBQ0Q7QUFDQXhkLElBQUksQ0FBRSw2REFGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVW9CLGVBSmYsQ0FLREcsV0FBVyxDQUFFLEtBTFosQ0FNRDhFLFFBQVEsQ0FBRSxJQU5ULENBT0RELE9BQU8sQ0FBRSw4QkFQUixDQVJJLENBZ0JKLENBQ0Q7QUFDQXhkLElBQUksQ0FBRSxvREFGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVW1CLE9BSmYsQ0FLREksV0FBVyxDQUFFLEtBTFosQ0FNRDhFLFFBQVEsQ0FBRSxJQU5ULENBT0RELE9BQU8sQ0FBRSxzQkFQUixDQWhCSSxDQXdCSixDQUNEO0FBQ0F4ZCxJQUFJLENBQUUsNERBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVvQixlQUpmLENBS0RHLFdBQVcsQ0FBRSxLQUxaLENBTUQ4RSxRQUFRLENBQUUsSUFOVCxDQU9ERCxPQUFPLENBQUUsOEJBUFIsQ0F4QkksQ0FUTixDQTFDSSxDQW9GSixDQUNEO0FBQ0F4ZCxJQUFJLENBQUUsb0NBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSmYsQ0FLRFEsV0FBVyxDQUFFLElBTFosQ0FNRCtFLFdBQVcsQ0FBRSxhQU5aLENBcEZJLENBNEZMO0FBQ0FxRCxrQkE3RkssQ0E4RlAsQ0FDRTtBQUNBL2dCLElBQUksQ0FBRSwyQ0FGUixDQUdFMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUh2QixDQUlFL0csSUFBSSxDQUFFLENBSlIsQ0FLRXdJLFdBQVcsQ0FBRSxJQUxmLENBTUU4RSxRQUFRLENBQUUsSUFOWixDQU9FekssS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSw4Q0FEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUhWLENBSU5tQixXQUFXLENBQUUsS0FKUCxDQUtOO0FBQ0FpRixxQkFBcUIsQ0FBRSxvQkFOakIsQ0FBRCxDQVBULENBOUZPLENBNkdKLENBQ0Q7QUFDQTVkLElBQUksQ0FBRSw0Q0FGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUhwQixDQUlEL0csSUFBSSxDQUFFLENBSkwsQ0FLRHdJLFdBQVcsQ0FBRSxJQUxaLENBTUQ4RSxRQUFRLENBQUUsSUFOVCxDQU9EekssS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSwrQ0FEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUhWLENBSU5tQixXQUFXLENBQUUsS0FKUCxDQUtOO0FBQ0FpRixxQkFBcUIsQ0FBRSxxQkFOakIsQ0FBRCxDQVBOLENBN0dJLENBNEhKLENBQ0Q7QUFDQTVkLElBQUksQ0FBRSx1Q0FGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUhwQixDQUlEL0csSUFBSSxDQUFFLENBSkwsQ0FLRHdJLFdBQVcsQ0FBRSxJQUxaLENBTUQrRSxXQUFXLENBQUUsZ0JBTlosQ0FPREQsUUFBUSxDQUFFLElBUFQsQ0E1SEksQ0FORCxDQUFELENBMklKLENBQ0Q7QUFDQXpkLElBQUksQ0FBRSxnQ0FGTCxDQUdEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBSHBCLENBSUQ3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFKZixDQUtEUSxXQUFXLENBQUUsSUFMWixDQU1EM0YsS0FBSyxDQUFFLENBQUMsQ0FDTjtBQUNBaFQsSUFBSSxDQUFFLDBDQUZBLENBR04wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FIZixDQUlON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSlYsQ0FLTmdCLFdBQVcsQ0FBRSxLQUxQLENBTU42RSxPQUFPLENBQUUsa0JBTkgsQ0FBRCxDQU9KLENBQ0R4ZCxJQUFJLENBQUUsaURBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEeUcsUUFBUSxDQUFFLElBSFQsQ0FJREMsV0FBVyxDQUFFLHFCQUpaLENBUEksQ0FOTixDQTNJSSxDQThKSixDQUNEO0FBQ0ExZCxJQUFJLENBQUUsNEJBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVJLFNBSmYsQ0FLRG1CLFdBQVcsQ0FBRSxLQUxaLENBTURpRixxQkFBcUIsQ0FBRSxlQU50QixDQTlKSSxDQUxzQixDQUEvQixDQTZLQSxHQUFJK3BCLDRCQUEyQixDQUFHLENBQ2hDM25DLElBQUksQ0FBRSxRQUQwQixDQUVoQzBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZXLENBR2hDN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGdCLENBSWhDUSxXQUFXLENBQUUsSUFKbUIsQ0FLaEMzRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLHNCQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRmYsQ0FHTi9HLElBQUksQ0FBRSxDQUhBLENBSU53SSxXQUFXLENBQUUsSUFKUCxDQUtOM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSwwQ0FEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ0MsS0FBTCxDQUFXb0IsUUFIWCxDQUlOUSxXQUFXLENBQUUsSUFKUCxDQUtOOEUsUUFBUSxDQUFFLElBTEosQ0FNTnpLLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsb0RBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxTQUNULG9EQU5NLENBQUQsQ0FORCxDQUFELENBTEQsQ0FBRCxDQW9CSixDQUNEeGQsSUFBSSxDQUFFLHlCQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRnBCLENBR0QvRyxJQUFJLENBQUUsQ0FITCxDQUlEd0ksV0FBVyxDQUFFLElBSlosQ0FLRDNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsNkNBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNDLEtBQUwsQ0FBV29CLFFBSFgsQ0FJTlEsV0FBVyxDQUFFLElBSlAsQ0FLTjhFLFFBQVEsQ0FBRSxJQUxKLENBTU56SyxLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLHVEQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsWUFMSCxDQUFELENBTUosQ0FDRHhkLElBQUksQ0FBRSxvREFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIZixDQUlEUSxXQUFXLENBQUUsSUFKWixDQUtEM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSw4REFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGdCQUNULG9EQU5NLENBQUQsQ0FMTixDQU5JLENBTkQsQ0FBRCxDQUxOLENBcEJJLENBb0RKLENBQ0R4ZCxJQUFJLENBQUUsbUJBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRC9HLElBQUksQ0FBRSxDQUhMLENBSURzTixRQUFRLENBQUUsSUFKVCxDQUtEekssS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSw4QkFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ0MsS0FBTCxDQUFXUSxPQUhYLENBSU5vQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLFlBTEgsQ0FBRCxDQUxOLENBcERJLENBZ0VKLENBQ0R4ZCxJQUFJLENBQUUscUJBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRC9HLElBQUksQ0FBRSxDQUhMLENBSURzTixRQUFRLENBQUUsSUFKVCxDQUtEekssS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSx3QkFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ0MsS0FBTCxDQUFXUSxPQUhYLENBSU5vQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLFNBTEgsQ0FBRCxDQUxOLENBaEVJLENBTHlCLENBQWxDLENBb0ZBO0FBQ0EsR0FBSW9xQixrQ0FBaUMsQ0FBRyxDQUN0QzVuQyxJQUFJLENBQUUsMEJBRGdDLENBRXRDMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmlCLENBR3RDN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSHNCLENBSXRDUSxXQUFXLENBQUUsSUFKeUIsQ0FLdEMrRSxXQUFXLENBQUUsMEJBTHlCLENBTXRDMUssS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSxrQ0FEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUhWLENBSU5vQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGlDQUxILENBQUQsQ0FNSixDQUNEO0FBQ0F4ZCxJQUFJLENBQUUsa0NBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSmYsQ0FLRFEsV0FBVyxDQUFFLElBTFosQ0FNRCtFLFdBQVcsQ0FBRSxpQ0FOWixDQU5JLENBY1A7QUFDQXFELGtCQWZPLENBZ0JQLENBQ0UvZ0IsSUFBSSxDQUFFLHFDQURSLENBRUUwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRnZCLENBR0UvRyxJQUFJLENBQUUsQ0FIUixDQUlFd0ksV0FBVyxDQUFFLElBSmYsQ0FLRThFLFFBQVEsQ0FBRSxJQUxaLENBTUVELE9BQU8sQ0FBRSxvQ0FOWCxDQU9FeEssS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSxxQ0FEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhWLENBSU5RLFdBQVcsQ0FBRSxJQUpQLENBS04zRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLDBDQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBQUQsQ0FLSixDQUNEM1ksSUFBSSxDQUFFLDJDQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FIZixDQUlETyxXQUFXLENBQUUsSUFKWixDQUxJLENBTEQsQ0FBRCxDQVBULENBaEJPLENBTitCLENBQXhDLENBaURBO0FBQ0EsR0FBSWt2Qiw4QkFBNkIsQ0FBRyxDQUNsQzduQyxJQUFJLENBQUUsc0JBRDRCLENBRWxDMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmEsQ0FHbEM3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIa0IsQ0FJbENRLFdBQVcsQ0FBRSxJQUpxQixDQUtsQytFLFdBQVcsQ0FBRSxLQUxxQixDQU1sQzFLLEtBQUssQ0FBRSxDQUNMNDBCLGlDQURLLENBQzhCLENBQ25DO0FBQ0E1bkMsSUFBSSxDQUFFLHlDQUY2QixDQUduQzBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhjLENBSW5DN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSm1CLENBS25DUSxXQUFXLENBQUUsSUFMc0IsQ0FNbkMzRixLQUFLLENBQUUsQ0FBQyxDQUNOO0FBQ0FoVCxJQUFJLENBQUUsbURBRkEsQ0FHTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhmLENBSU43RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FKVixDQUtOZ0IsV0FBVyxDQUFFLEtBTFAsQ0FNTjZFLE9BQU8sQ0FBRSxpQkFOSCxDQUFELENBT0osQ0FDRHhkLElBQUksQ0FBRSxvREFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0R5RyxRQUFRLENBQUUsSUFIVCxDQUlEQyxXQUFXLENBQUUsb0JBSlosQ0FQSSxDQU40QixDQUQ5QixDQW9CSixDQUNEO0FBQ0ExZCxJQUFJLENBQUUsZ0NBRkwsQ0FHRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUhwQixDQUlEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVJLFNBSmYsQ0FLRG1CLFdBQVcsQ0FBRSxLQUxaLENBTURpRixxQkFBcUIsQ0FBRSxjQU50QixDQXBCSSxDQU4yQixDQUFwQyxDQW9DQTs7Ozs7O0dBT0E5YixHQUFHLENBQUNnbUMsb0JBQUosQ0FBMkIsU0FBU0MsR0FBVCxDQUFjdHBCLEVBQWQsQ0FBa0IsQ0FDM0MsR0FBSTdVLEtBQUksQ0FBRyxFQUFYLENBRUE7QUFDQSxHQUFJZ0MsSUFBSixDQUFTckYsSUFBVCxDQUFla0osR0FBZixDQUNBLElBQUksR0FBSXU0QixHQUFFLENBQUcsQ0FBYixDQUFnQkEsRUFBRSxDQUFHRCxHQUFHLENBQUMvMEIsS0FBSixDQUFVMVosTUFBL0IsQ0FBdUMsRUFBRTB1QyxFQUF6QyxDQUE2QyxDQUMzQztBQUNBcDhCLEdBQUcsQ0FBR204QixHQUFHLENBQUMvMEIsS0FBSixDQUFVZzFCLEVBQVYsQ0FBTixDQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksR0FBSXhrQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdvSSxHQUFHLENBQUNvSCxLQUFKLENBQVUxWixNQUE3QixDQUFxQyxFQUFFa0ssQ0FBdkMsQ0FBMEMsQ0FDeENpTSxHQUFHLENBQUcsRUFBTixDQUNBbEosSUFBSSxDQUFHcUYsR0FBRyxDQUFDb0gsS0FBSixDQUFVeFAsQ0FBVixDQUFQLENBQ0FpTSxHQUFHLENBQUNVLElBQUosQ0FBVzJHLElBQUksQ0FBQ3NFLFFBQUwsQ0FBYzdVLElBQUksQ0FBQ3lNLEtBQUwsQ0FBVyxDQUFYLEVBQWNBLEtBQTVCLENBQVgsQ0FDQXZELEdBQUcsQ0FBQ3VELEtBQUosQ0FBWXpNLElBQUksQ0FBQ3lNLEtBQUwsQ0FBVyxDQUFYLEVBQWNBLEtBQTFCLENBQ0F2RCxHQUFHLENBQUN3NEIsYUFBSixDQUFvQjFoQyxJQUFJLENBQUN5TSxLQUFMLENBQVcsQ0FBWCxFQUFjN0MsSUFBbEMsQ0FDQTtBQUNBLEdBQUdWLEdBQUcsQ0FBQ1UsSUFBSixHQUFZa08sS0FBZixDQUFxQixDQUNuQjVPLEdBQUcsQ0FBQ3pQLElBQUosQ0FBV3FlLElBQUksQ0FBQzVPLEdBQUcsQ0FBQ1UsSUFBTCxDQUFmLENBQ0EsR0FBR1YsR0FBRyxDQUFDelAsSUFBSixHQUFZeW5DLFlBQWYsQ0FBNEIsQ0FDMUJoNEIsR0FBRyxDQUFDeTRCLFNBQUosQ0FBZ0JULFdBQVcsQ0FBQ2g0QixHQUFHLENBQUN6UCxJQUFMLENBQTNCLENBQ0QsQ0FDRixDQUNELEdBQUd5ZSxFQUFILENBQU8sQ0FDTEEsRUFBRSxDQUFDckosTUFBSCxDQUFVM0YsR0FBRyxDQUFDVSxJQUFkLEVBQ0FzTyxFQUFFLENBQUNySixNQUFILENBQVUzRixHQUFHLENBQUN1RCxLQUFkLEVBQ0QsQ0FDRHBKLElBQUksQ0FBQzFELElBQUwsQ0FBVXVKLEdBQVYsRUFDRCxDQUNGLENBRUQsTUFBTzdGLEtBQVAsQ0FDRCxDQWxDRCxDQW9DQTs7Ozs7R0FNQTlILEdBQUcsQ0FBQ3FtQyxvQkFBSixDQUEyQixTQUFTdmhDLFVBQVQsQ0FBcUIsQ0FDOUMsR0FBSWdELEtBQUksQ0FBRyxFQUFYLENBRUE7QUFDQSxJQUFJLEdBQUlvK0IsR0FBRSxDQUFHLENBQWIsQ0FBZ0JBLEVBQUUsQ0FBR3BoQyxVQUFVLENBQUN0TixNQUFoQyxDQUF3QyxFQUFFMHVDLEVBQTFDLENBQThDLENBQzVDO0FBQ0EsR0FBSUksSUFBRyxDQUFHeGhDLFVBQVUsQ0FBQ29oQyxFQUFELENBQXBCLENBRUE7QUFDQTtBQUNBLEdBQUk3M0IsS0FBSSxDQUFHMkcsSUFBSSxDQUFDc0UsUUFBTCxDQUFjZ3RCLEdBQUcsQ0FBQ3AxQixLQUFKLENBQVUsQ0FBVixFQUFhQSxLQUEzQixDQUFYLENBQ0EsR0FBSWtJLE9BQU0sQ0FBR2t0QixHQUFHLENBQUNwMUIsS0FBSixDQUFVLENBQVYsRUFBYUEsS0FBMUIsQ0FDQSxJQUFJLEdBQUkrYSxHQUFFLENBQUcsQ0FBYixDQUFnQkEsRUFBRSxDQUFHN1MsTUFBTSxDQUFDNWhCLE1BQTVCLENBQW9DLEVBQUV5MEIsRUFBdEMsQ0FBMEMsQ0FDeEMsR0FBSXRlLElBQUcsQ0FBRyxFQUFWLENBQ0FBLEdBQUcsQ0FBQ1UsSUFBSixDQUFXQSxJQUFYLENBQ0FWLEdBQUcsQ0FBQ3VELEtBQUosQ0FBWWtJLE1BQU0sQ0FBQzZTLEVBQUQsQ0FBTixDQUFXL2EsS0FBdkIsQ0FDQXZELEdBQUcsQ0FBQ3c0QixhQUFKLENBQW9CL3NCLE1BQU0sQ0FBQzZTLEVBQUQsQ0FBTixDQUFXNWQsSUFBL0IsQ0FDQTtBQUNBLEdBQUdWLEdBQUcsQ0FBQ1UsSUFBSixHQUFZa08sS0FBZixDQUFxQixDQUNuQjVPLEdBQUcsQ0FBQ3pQLElBQUosQ0FBV3FlLElBQUksQ0FBQzVPLEdBQUcsQ0FBQ1UsSUFBTCxDQUFmLENBQ0EsR0FBR1YsR0FBRyxDQUFDelAsSUFBSixHQUFZeW5DLFlBQWYsQ0FBNEIsQ0FDMUJoNEIsR0FBRyxDQUFDeTRCLFNBQUosQ0FBZ0JULFdBQVcsQ0FBQ2g0QixHQUFHLENBQUN6UCxJQUFMLENBQTNCLENBQ0QsQ0FDRixDQUNEO0FBQ0EsR0FBR3lQLEdBQUcsQ0FBQ1UsSUFBSixHQUFha08sSUFBSSxDQUFDZ3FCLGdCQUFyQixDQUF1QyxDQUNyQzU0QixHQUFHLENBQUM2NEIsVUFBSixDQUFpQixFQUFqQixDQUNBLElBQUksR0FBSWhkLEdBQUUsQ0FBRyxDQUFiLENBQWdCQSxFQUFFLENBQUc3YixHQUFHLENBQUN1RCxLQUFKLENBQVUxWixNQUEvQixDQUF1QyxFQUFFZ3lCLEVBQXpDLENBQTZDLENBQzNDN2IsR0FBRyxDQUFDNjRCLFVBQUosQ0FBZXBpQyxJQUFmLENBQW9CcEUsR0FBRyxDQUFDeW1DLDRCQUFKLENBQWlDOTRCLEdBQUcsQ0FBQ3VELEtBQUosQ0FBVXNZLEVBQVYsQ0FBakMsQ0FBcEIsRUFDRCxDQUNGLENBQ0QxaEIsSUFBSSxDQUFDMUQsSUFBTCxDQUFVdUosR0FBVixFQUNELENBQ0YsQ0FFRCxNQUFPN0YsS0FBUCxDQUNELENBcENELENBc0NBOzs7Ozs7Ozs7O0dBV0EsUUFBUzQrQixjQUFULENBQXVCLzRCLEdBQXZCLENBQTRCOVcsT0FBNUIsQ0FBcUMsQ0FDbkMsR0FBRyxNQUFPQSxRQUFQLEdBQW1CLFFBQXRCLENBQWdDLENBQzlCQSxPQUFPLENBQUcsQ0FBQ3V2QyxTQUFTLENBQUV2dkMsT0FBWixDQUFWLENBQ0QsQ0FFRCxHQUFJaVIsS0FBSSxDQUFHLElBQVgsQ0FDQSxHQUFJckQsS0FBSixDQUNBLElBQUksR0FBSS9DLEVBQUMsQ0FBRyxDQUFaLENBQWVvRyxJQUFJLEdBQUssSUFBVCxFQUFpQnBHLENBQUMsQ0FBR2lNLEdBQUcsQ0FBQzdJLFVBQUosQ0FBZXROLE1BQW5ELENBQTJELEVBQUVrSyxDQUE3RCxDQUFnRSxDQUM5RCtDLElBQUksQ0FBR2tKLEdBQUcsQ0FBQzdJLFVBQUosQ0FBZXBELENBQWYsQ0FBUCxDQUNBLEdBQUc3SyxPQUFPLENBQUN3WCxJQUFSLEVBQWdCeFgsT0FBTyxDQUFDd1gsSUFBUixHQUFpQjVKLElBQUksQ0FBQzRKLElBQXpDLENBQStDLENBQzdDdkcsSUFBSSxDQUFHckQsSUFBUCxDQUNELENBRkQsSUFFTyxJQUFHNU4sT0FBTyxDQUFDcUgsSUFBUixFQUFnQnJILE9BQU8sQ0FBQ3FILElBQVIsR0FBaUJ1RyxJQUFJLENBQUN2RyxJQUF6QyxDQUErQyxDQUNwRDRKLElBQUksQ0FBR3JELElBQVAsQ0FDRCxDQUZNLElBRUEsSUFBRzVOLE9BQU8sQ0FBQ3V2QyxTQUFSLEVBQXFCdnZDLE9BQU8sQ0FBQ3V2QyxTQUFSLEdBQXNCM2hDLElBQUksQ0FBQzJoQyxTQUFuRCxDQUE4RCxDQUNuRXQrQixJQUFJLENBQUdyRCxJQUFQLENBQ0QsQ0FDRixDQUNELE1BQU9xRCxLQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCQSxHQUFJNitCLHlCQUF3QixDQUFHLFFBQTNCQSx5QkFBMkIsQ0FBU3h0QixHQUFULENBQWN4TCxHQUFkLENBQW1CaTVCLFlBQW5CLENBQWlDLENBQzlELEdBQUl0cEMsT0FBTSxDQUFHLEVBQWIsQ0FFQSxHQUFHNmIsR0FBRyxHQUFLb0QsSUFBSSxDQUFDLFlBQUQsQ0FBZixDQUErQixDQUM3QixNQUFPamYsT0FBUCxDQUNELENBRUQsR0FBR3NwQyxZQUFILENBQWlCLENBQ2Z0cEMsTUFBTSxDQUFHLENBQ1B3QixJQUFJLENBQUUsQ0FDSituQyxZQUFZLENBQUV0cUIsSUFBSSxDQUFDLE1BQUQsQ0FEZCxDQURDLENBSVB1cUIsR0FBRyxDQUFFLENBQ0hELFlBQVksQ0FBRXRxQixJQUFJLENBQUMsTUFBRCxDQURmLENBRUh6ZCxJQUFJLENBQUUsQ0FDSituQyxZQUFZLENBQUV0cUIsSUFBSSxDQUFDLE1BQUQsQ0FEZCxDQUZILENBSkUsQ0FVUHdxQixVQUFVLENBQUUsRUFWTCxDQUFULENBWUQsQ0FFRCxHQUFJcnJCLFFBQU8sQ0FBRyxFQUFkLENBQ0EsR0FBSS9lLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBRyxDQUFDcVksSUFBSSxDQUFDd0csUUFBTCxDQUFjN04sR0FBZCxDQUFtQms0QiwyQkFBbkIsQ0FBZ0RucUIsT0FBaEQsQ0FBeUQvZSxNQUF6RCxDQUFKLENBQXNFLENBQ3BFLEdBQUluRCxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSx5Q0FBVixDQUFaLENBQ0FrQyxLQUFLLENBQUNtRCxNQUFOLENBQWVBLE1BQWYsQ0FDQSxLQUFNbkQsTUFBTixDQUNELENBRUQsR0FBR2tpQixPQUFPLENBQUNzckIsT0FBUixHQUFvQnpqQyxTQUF2QixDQUFrQyxDQUNoQ2pHLE1BQU0sQ0FBQ3dCLElBQVAsQ0FBY3hCLE1BQU0sQ0FBQ3dCLElBQVAsRUFBZSxFQUE3QixDQUNBeEIsTUFBTSxDQUFDd0IsSUFBUCxDQUFZK25DLFlBQVosQ0FBMkI3eEIsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDc3JCLE9BQXRCLENBQTNCLENBQ0QsQ0FFRCxHQUFHdHJCLE9BQU8sQ0FBQ3VyQixVQUFSLEdBQXVCMWpDLFNBQTFCLENBQXFDLENBQ25DakcsTUFBTSxDQUFDd3BDLEdBQVAsQ0FBYXhwQyxNQUFNLENBQUN3cEMsR0FBUCxFQUFjLEVBQTNCLENBQ0F4cEMsTUFBTSxDQUFDd3BDLEdBQVAsQ0FBV0QsWUFBWCxDQUEwQjd4QixJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUN1ckIsVUFBdEIsQ0FBMUIsQ0FDQTNwQyxNQUFNLENBQUN3cEMsR0FBUCxDQUFXaG9DLElBQVgsQ0FBa0J4QixNQUFNLENBQUN3cEMsR0FBUCxDQUFXaG9DLElBQVgsRUFBbUIsRUFBckMsQ0FDQXhCLE1BQU0sQ0FBQ3dwQyxHQUFQLENBQVdob0MsSUFBWCxDQUFnQituQyxZQUFoQixDQUErQjd4QixJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUN3ckIsY0FBdEIsQ0FBL0IsQ0FDRCxDQUVELEdBQUd4ckIsT0FBTyxDQUFDcXJCLFVBQVIsR0FBdUJ4akMsU0FBMUIsQ0FBcUMsQ0FDbkNqRyxNQUFNLENBQUN5cEMsVUFBUCxDQUFvQnJyQixPQUFPLENBQUNxckIsVUFBUixDQUFtQm4vQixVQUFuQixDQUE4QixDQUE5QixDQUFwQixDQUNELENBRUQsTUFBT3RLLE9BQVAsQ0FDRCxDQS9DRCxDQWlEQTs7Ozs7Ozs7Ozs7Ozs7R0FlQTBDLEdBQUcsQ0FBQ21uQyxrQkFBSixDQUF5QixTQUFTamMsR0FBVCxDQUFja2MsV0FBZCxDQUEyQmx2QixNQUEzQixDQUFtQyxDQUMxRCxHQUFJcFUsSUFBRyxDQUFHeEUsS0FBSyxDQUFDNHJCLEdBQU4sQ0FBVTdnQixNQUFWLENBQWlCNmdCLEdBQWpCLEVBQXNCLENBQXRCLENBQVYsQ0FFQSxHQUFHcG5CLEdBQUcsQ0FBQ3VLLElBQUosR0FBYSxhQUFiLEVBQ0R2SyxHQUFHLENBQUN1SyxJQUFKLEdBQWEsa0JBRFosRUFFRHZLLEdBQUcsQ0FBQ3VLLElBQUosR0FBYSxxQkFGZixDQUVzQyxDQUNwQyxHQUFJN1UsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsMkRBQ3BCLHFFQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQyswQixVQUFOLENBQW1CenFCLEdBQUcsQ0FBQ3VLLElBQXZCLENBQ0EsS0FBTTdVLE1BQU4sQ0FDRCxDQUNELEdBQUdzSyxHQUFHLENBQUNzbkIsUUFBSixFQUFnQnRuQixHQUFHLENBQUNzbkIsUUFBSixDQUFhL2MsSUFBYixHQUFzQixXQUF6QyxDQUFzRCxDQUNwRCxLQUFNLElBQUkvVyxNQUFKLENBQVUsMkRBQVYsQ0FBTixDQUNELENBRUQ7QUFDQSxHQUFJcVcsSUFBRyxDQUFHcUgsSUFBSSxDQUFDaUQsT0FBTCxDQUFhblUsR0FBRyxDQUFDNG5CLElBQWpCLENBQXVCeFQsTUFBdkIsQ0FBVixDQUVBLE1BQU9sWSxJQUFHLENBQUNxbkMsbUJBQUosQ0FBd0IxNUIsR0FBeEIsQ0FBNkJ5NUIsV0FBN0IsQ0FBUCxDQUNELENBbkJELENBcUJBOzs7Ozs7O0dBUUFwbkMsR0FBRyxDQUFDc25DLGdCQUFKLENBQXVCLFNBQVNDLElBQVQsQ0FBZXg3QixPQUFmLENBQXdCLENBQzdDO0FBQ0EsR0FBSWpJLElBQUcsQ0FBRyxDQUNSdUssSUFBSSxDQUFFLGFBREUsQ0FFUnFkLElBQUksQ0FBRTFXLElBQUksQ0FBQytELEtBQUwsQ0FBVy9ZLEdBQUcsQ0FBQ3duQyxpQkFBSixDQUFzQkQsSUFBdEIsQ0FBWCxFQUF3QzcvQixRQUF4QyxFQUZFLENBQVYsQ0FJQSxNQUFPcEksTUFBSyxDQUFDNHJCLEdBQU4sQ0FBVXpnQixNQUFWLENBQWlCM0csR0FBakIsQ0FBc0IsQ0FBQ2lJLE9BQU8sQ0FBRUEsT0FBVixDQUF0QixDQUFQLENBQ0QsQ0FQRCxDQVNBOzs7Ozs7R0FPQS9MLEdBQUcsQ0FBQ3luQyxnQkFBSixDQUF1QixTQUFTdmMsR0FBVCxDQUFjLENBQ25DLEdBQUlwbkIsSUFBRyxDQUFHeEUsS0FBSyxDQUFDNHJCLEdBQU4sQ0FBVTdnQixNQUFWLENBQWlCNmdCLEdBQWpCLEVBQXNCLENBQXRCLENBQVYsQ0FFQSxHQUFHcG5CLEdBQUcsQ0FBQ3VLLElBQUosR0FBYSxZQUFiLEVBQTZCdkssR0FBRyxDQUFDdUssSUFBSixHQUFhLGdCQUE3QyxDQUErRCxDQUM3RCxHQUFJN1UsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUscURBQ3BCLCtDQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQyswQixVQUFOLENBQW1CenFCLEdBQUcsQ0FBQ3VLLElBQXZCLENBQ0EsS0FBTTdVLE1BQU4sQ0FDRCxDQUNELEdBQUdzSyxHQUFHLENBQUNzbkIsUUFBSixFQUFnQnRuQixHQUFHLENBQUNzbkIsUUFBSixDQUFhL2MsSUFBYixHQUFzQixXQUF6QyxDQUFzRCxDQUNwRCxLQUFNLElBQUkvVyxNQUFKLENBQVUsMERBQVYsQ0FBTixDQUNELENBRUQ7QUFDQSxHQUFJcVcsSUFBRyxDQUFHcUgsSUFBSSxDQUFDaUQsT0FBTCxDQUFhblUsR0FBRyxDQUFDNG5CLElBQWpCLENBQVYsQ0FFQSxNQUFPMXJCLElBQUcsQ0FBQzJsQixpQkFBSixDQUFzQmhZLEdBQXRCLENBQVAsQ0FDRCxDQWpCRCxDQW1CQTs7Ozs7OztHQVFBM04sR0FBRyxDQUFDQyxjQUFKLENBQXFCLFNBQVMxRyxHQUFULENBQWN3UyxPQUFkLENBQXVCLENBQzFDO0FBQ0EsR0FBSWpJLElBQUcsQ0FBRyxDQUNSdUssSUFBSSxDQUFFLFlBREUsQ0FFUnFkLElBQUksQ0FBRTFXLElBQUksQ0FBQytELEtBQUwsQ0FBVy9ZLEdBQUcsQ0FBQ2dtQixlQUFKLENBQW9CenNCLEdBQXBCLENBQVgsRUFBcUNtTyxRQUFyQyxFQUZFLENBQVYsQ0FJQSxNQUFPcEksTUFBSyxDQUFDNHJCLEdBQU4sQ0FBVXpnQixNQUFWLENBQWlCM0csR0FBakIsQ0FBc0IsQ0FBQ2lJLE9BQU8sQ0FBRUEsT0FBVixDQUF0QixDQUFQLENBQ0QsQ0FQRCxDQVNBOzs7Ozs7O0dBUUEvTCxHQUFHLENBQUMwbkMsMEJBQUosQ0FBaUMsU0FBU251QyxHQUFULENBQWN3UyxPQUFkLENBQXVCLENBQ3REO0FBQ0EsR0FBSWpJLElBQUcsQ0FBRyxDQUNSdUssSUFBSSxDQUFFLGdCQURFLENBRVJxZCxJQUFJLENBQUUxVyxJQUFJLENBQUMrRCxLQUFMLENBQVcvWSxHQUFHLENBQUNrbUIsdUJBQUosQ0FBNEIzc0IsR0FBNUIsQ0FBWCxFQUE2Q21PLFFBQTdDLEVBRkUsQ0FBVixDQUlBLE1BQU9wSSxNQUFLLENBQUM0ckIsR0FBTixDQUFVemdCLE1BQVYsQ0FBaUIzRyxHQUFqQixDQUFzQixDQUFDaUksT0FBTyxDQUFFQSxPQUFWLENBQXRCLENBQVAsQ0FDRCxDQVBELENBU0E7Ozs7Ozs7Ozs7Ozs7R0FjQS9MLEdBQUcsQ0FBQzJuQyx1QkFBSixDQUE4QixTQUFTcHVDLEdBQVQsQ0FBYzFDLE9BQWQsQ0FBdUIsQ0FDbkRBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0EsR0FBSThsQixHQUFFLENBQUc5bEIsT0FBTyxDQUFDOGxCLEVBQVIsRUFBY3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU21TLElBQVQsQ0FBYy8wQixNQUFkLEVBQXZCLENBQ0EsR0FBSXNVLEtBQUksQ0FBR3hYLE9BQU8sQ0FBQ3dYLElBQVIsRUFBZ0IsY0FBM0IsQ0FFQSxHQUFJeEgsTUFBSixDQUNBLE9BQU93SCxJQUFQLEVBQ0EsSUFBSyxjQUFMLENBQ0V4SCxLQUFLLENBQUdtTyxJQUFJLENBQUMrRCxLQUFMLENBQVcvWSxHQUFHLENBQUNrbUIsdUJBQUosQ0FBNEIzc0IsR0FBNUIsQ0FBWCxFQUE2Q21PLFFBQTdDLEVBQVIsQ0FDQSxNQUNGLElBQUssc0JBQUwsQ0FDRWIsS0FBSyxDQUFHbU8sSUFBSSxDQUFDK0QsS0FBTCxDQUFXL1ksR0FBRyxDQUFDZ21CLGVBQUosQ0FBb0J6c0IsR0FBcEIsQ0FBWCxFQUFxQ21PLFFBQXJDLEVBQVIsQ0FDQSxNQUNGLFFBQ0UsS0FBTSxJQUFJcFEsTUFBSixDQUFVLDZCQUErQlQsT0FBTyxDQUFDd1gsSUFBdkMsQ0FBOEMsSUFBeEQsQ0FBTixDQVJGLENBV0E7QUFDQXNPLEVBQUUsQ0FBQ3RQLEtBQUgsR0FDQXNQLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVXpNLEtBQVYsRUFDQSxHQUFJMFksT0FBTSxDQUFHNUMsRUFBRSxDQUFDNEMsTUFBSCxFQUFiLENBQ0EsR0FBRzFvQixPQUFPLENBQUNtVCxRQUFSLEdBQXFCLEtBQXhCLENBQStCLENBQzdCLEdBQUlJLElBQUcsQ0FBR21WLE1BQU0sQ0FBQ3RXLEtBQVAsRUFBVixDQUNBLEdBQUdwUyxPQUFPLENBQUMrd0MsU0FBWCxDQUFzQixDQUNwQixNQUFPeDlCLElBQUcsQ0FBQ29ILEtBQUosQ0FBVSxPQUFWLEVBQW1CM1osSUFBbkIsQ0FBd0JoQixPQUFPLENBQUMrd0MsU0FBaEMsQ0FBUCxDQUNELENBQ0QsTUFBT3g5QixJQUFQLENBQ0QsQ0FORCxJQU1PLElBQUd2VCxPQUFPLENBQUNtVCxRQUFSLEdBQXFCLFFBQXhCLENBQWtDLENBQ3ZDLE1BQU91VixPQUFNLENBQUM3WCxRQUFQLEVBQVAsQ0FDRCxDQUZNLElBRUEsSUFBRzdRLE9BQU8sQ0FBQ21ULFFBQVgsQ0FBcUIsQ0FDMUIsS0FBTSxJQUFJMVMsTUFBSixDQUFVLHFCQUF1QlQsT0FBTyxDQUFDbVQsUUFBL0IsQ0FBMEMsSUFBcEQsQ0FBTixDQUNELENBQ0QsTUFBT3VWLE9BQVAsQ0FDRCxDQWpDRCxDQW1DQTs7Ozs7Ozs7Ozs7Ozs7R0FlQXZmLEdBQUcsQ0FBQzZuQywyQkFBSixDQUFrQyxTQUFTM2MsR0FBVCxDQUFja2MsV0FBZCxDQUEyQmx2QixNQUEzQixDQUFtQyxDQUNuRSxHQUFJcFUsSUFBRyxDQUFHeEUsS0FBSyxDQUFDNHJCLEdBQU4sQ0FBVTdnQixNQUFWLENBQWlCNmdCLEdBQWpCLEVBQXNCLENBQXRCLENBQVYsQ0FFQSxHQUFHcG5CLEdBQUcsQ0FBQ3VLLElBQUosR0FBYSxxQkFBaEIsQ0FBdUMsQ0FDckMsR0FBSTdVLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLHFEQUNwQiwrQ0FEVSxDQUFaLENBRUFrQyxLQUFLLENBQUMrMEIsVUFBTixDQUFtQnpxQixHQUFHLENBQUN1SyxJQUF2QixDQUNBLEtBQU03VSxNQUFOLENBQ0QsQ0FDRCxHQUFHc0ssR0FBRyxDQUFDc25CLFFBQUosRUFBZ0J0bkIsR0FBRyxDQUFDc25CLFFBQUosQ0FBYS9jLElBQWIsR0FBc0IsV0FBekMsQ0FBc0QsQ0FDcEQsS0FBTSxJQUFJL1csTUFBSixDQUFVLHFEQUNkLG1CQURJLENBQU4sQ0FFRCxDQUVEO0FBQ0EsR0FBSXFXLElBQUcsQ0FBR3FILElBQUksQ0FBQ2lELE9BQUwsQ0FBYW5VLEdBQUcsQ0FBQzRuQixJQUFqQixDQUF1QnhULE1BQXZCLENBQVYsQ0FFQSxNQUFPbFksSUFBRyxDQUFDOG5DLDRCQUFKLENBQWlDbjZCLEdBQWpDLENBQXNDeTVCLFdBQXRDLENBQVAsQ0FDRCxDQWxCRCxDQW9CQTs7Ozs7OztHQVFBcG5DLEdBQUcsQ0FBQytuQyx5QkFBSixDQUFnQyxTQUFTQyxHQUFULENBQWNqOEIsT0FBZCxDQUF1QixDQUNyRDtBQUNBLEdBQUlqSSxJQUFHLENBQUcsQ0FDUnVLLElBQUksQ0FBRSxxQkFERSxDQUVScWQsSUFBSSxDQUFFMVcsSUFBSSxDQUFDK0QsS0FBTCxDQUFXL1ksR0FBRyxDQUFDaW9DLDBCQUFKLENBQStCRCxHQUEvQixDQUFYLEVBQWdEdGdDLFFBQWhELEVBRkUsQ0FBVixDQUlBLE1BQU9wSSxNQUFLLENBQUM0ckIsR0FBTixDQUFVemdCLE1BQVYsQ0FBaUIzRyxHQUFqQixDQUFzQixDQUFDaUksT0FBTyxDQUFFQSxPQUFWLENBQXRCLENBQVAsQ0FDRCxDQVBELENBU0E7Ozs7R0FLQS9MLEdBQUcsQ0FBQ2tvQyxpQkFBSixDQUF3QixVQUFXLENBQ2pDLEdBQUlYLEtBQUksQ0FBRyxFQUFYLENBQ0FBLElBQUksQ0FBQ2xjLE9BQUwsQ0FBZSxJQUFmLENBQ0FrYyxJQUFJLENBQUNZLFlBQUwsQ0FBb0IsSUFBcEIsQ0FDQVosSUFBSSxDQUFDYSxZQUFMLENBQW9CLElBQXBCLENBQ0FiLElBQUksQ0FBQzlpQixTQUFMLENBQWlCLElBQWpCLENBQ0E4aUIsSUFBSSxDQUFDYyxPQUFMLENBQWUsRUFBZixDQUNBZCxJQUFJLENBQUNjLE9BQUwsQ0FBYXhCLFlBQWIsQ0FBNEIsSUFBNUIsQ0FDQVUsSUFBSSxDQUFDZSxRQUFMLENBQWdCLEVBQWhCLENBQ0FmLElBQUksQ0FBQ2UsUUFBTCxDQUFjQyxTQUFkLENBQTBCLEdBQUkvakMsS0FBSixFQUExQixDQUNBK2lDLElBQUksQ0FBQ2UsUUFBTCxDQUFjRSxRQUFkLENBQXlCLEdBQUloa0MsS0FBSixFQUF6QixDQUVBK2lDLElBQUksQ0FBQ2tCLE1BQUwsQ0FBYyxFQUFkLENBQ0FsQixJQUFJLENBQUNrQixNQUFMLENBQVlDLFFBQVosQ0FBdUIsU0FBU0MsRUFBVCxDQUFhLENBQ2xDLE1BQU9qQyxjQUFhLENBQUNhLElBQUksQ0FBQ2tCLE1BQU4sQ0FBY0UsRUFBZCxDQUFwQixDQUNELENBRkQsQ0FHQXBCLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWUcsUUFBWixDQUF1QixTQUFTbmtDLElBQVQsQ0FBZSxDQUNwQ29rQyxrQkFBa0IsQ0FBQyxDQUFDcGtDLElBQUQsQ0FBRCxDQUFsQixDQUNBOGlDLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWTNqQyxVQUFaLENBQXVCVixJQUF2QixDQUE0QkssSUFBNUIsRUFDRCxDQUhELENBSUE4aUMsSUFBSSxDQUFDa0IsTUFBTCxDQUFZM2pDLFVBQVosQ0FBeUIsRUFBekIsQ0FDQXlpQyxJQUFJLENBQUNrQixNQUFMLENBQVkzcEMsSUFBWixDQUFtQixJQUFuQixDQUVBeW9DLElBQUksQ0FBQ3VCLE9BQUwsQ0FBZSxFQUFmLENBQ0F2QixJQUFJLENBQUN1QixPQUFMLENBQWFKLFFBQWIsQ0FBd0IsU0FBU0MsRUFBVCxDQUFhLENBQ25DLE1BQU9qQyxjQUFhLENBQUNhLElBQUksQ0FBQ3VCLE9BQU4sQ0FBZUgsRUFBZixDQUFwQixDQUNELENBRkQsQ0FHQXBCLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYUYsUUFBYixDQUF3QixTQUFTbmtDLElBQVQsQ0FBZSxDQUNyQ29rQyxrQkFBa0IsQ0FBQyxDQUFDcGtDLElBQUQsQ0FBRCxDQUFsQixDQUNBOGlDLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYWhrQyxVQUFiLENBQXdCVixJQUF4QixDQUE2QkssSUFBN0IsRUFDRCxDQUhELENBSUE4aUMsSUFBSSxDQUFDdUIsT0FBTCxDQUFhaGtDLFVBQWIsQ0FBMEIsRUFBMUIsQ0FDQXlpQyxJQUFJLENBQUN1QixPQUFMLENBQWFocUMsSUFBYixDQUFvQixJQUFwQixDQUVBeW9DLElBQUksQ0FBQ2YsVUFBTCxDQUFrQixFQUFsQixDQUNBZSxJQUFJLENBQUNybkMsU0FBTCxDQUFpQixJQUFqQixDQUNBcW5DLElBQUksQ0FBQzVxQixFQUFMLENBQVUsSUFBVixDQUVBOzs7OztLQU1BNHFCLElBQUksQ0FBQ3dCLFVBQUwsQ0FBa0IsU0FBU0MsS0FBVCxDQUFnQkMsUUFBaEIsQ0FBMEIsQ0FDMUM7QUFDQUosa0JBQWtCLENBQUNHLEtBQUQsQ0FBbEIsQ0FDQXpCLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYWhrQyxVQUFiLENBQTBCa2tDLEtBQTFCLENBQ0EsTUFBT3pCLEtBQUksQ0FBQ3VCLE9BQUwsQ0FBYUcsUUFBcEIsQ0FDQSxHQUFHQSxRQUFILENBQWEsQ0FDWDtBQUNBMUIsSUFBSSxDQUFDdUIsT0FBTCxDQUFhRyxRQUFiLENBQXdCQSxRQUF4QixDQUNELENBQ0QxQixJQUFJLENBQUN1QixPQUFMLENBQWFocUMsSUFBYixDQUFvQixJQUFwQixDQUNELENBVkQsQ0FZQTs7Ozs7S0FNQXlvQyxJQUFJLENBQUMyQixTQUFMLENBQWlCLFNBQVNGLEtBQVQsQ0FBZ0JDLFFBQWhCLENBQTBCLENBQ3pDO0FBQ0FKLGtCQUFrQixDQUFDRyxLQUFELENBQWxCLENBQ0F6QixJQUFJLENBQUNrQixNQUFMLENBQVkzakMsVUFBWixDQUF5QmtrQyxLQUF6QixDQUNBLE1BQU96QixLQUFJLENBQUNrQixNQUFMLENBQVlRLFFBQW5CLENBQ0EsR0FBR0EsUUFBSCxDQUFhLENBQ1g7QUFDQTFCLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWVEsUUFBWixDQUF1QkEsUUFBdkIsQ0FDRCxDQUNEMUIsSUFBSSxDQUFDa0IsTUFBTCxDQUFZM3BDLElBQVosQ0FBbUIsSUFBbkIsQ0FDRCxDQVZELENBWUE7Ozs7S0FLQXlvQyxJQUFJLENBQUM0QixhQUFMLENBQXFCLFNBQVNDLElBQVQsQ0FBZSxDQUNsQyxJQUFJLEdBQUkxbkMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHMG5DLElBQUksQ0FBQzV4QyxNQUF4QixDQUFnQyxFQUFFa0ssQ0FBbEMsQ0FBcUMsQ0FDbkMybkMsMkJBQTJCLENBQUNELElBQUksQ0FBQzFuQyxDQUFELENBQUwsQ0FBVSxDQUFDNmxDLElBQUksQ0FBRUEsSUFBUCxDQUFWLENBQTNCLENBQ0QsQ0FDRDtBQUNBQSxJQUFJLENBQUNmLFVBQUwsQ0FBa0I0QyxJQUFsQixDQUNELENBTkQsQ0FRQTs7Ozs7Ozs7S0FTQTdCLElBQUksQ0FBQytCLFlBQUwsQ0FBb0IsU0FBU3p5QyxPQUFULENBQWtCLENBQ3BDLEdBQUcsTUFBT0EsUUFBUCxHQUFtQixRQUF0QixDQUFnQyxDQUM5QkEsT0FBTyxDQUFHLENBQUNxSCxJQUFJLENBQUVySCxPQUFQLENBQVYsQ0FDRCxDQUVELEdBQUlpUixLQUFJLENBQUcsSUFBWCxDQUNBLEdBQUl5aEMsSUFBSixDQUNBLElBQUksR0FBSTduQyxFQUFDLENBQUcsQ0FBWixDQUFlb0csSUFBSSxHQUFLLElBQVQsRUFBaUJwRyxDQUFDLENBQUc2bEMsSUFBSSxDQUFDZixVQUFMLENBQWdCaHZDLE1BQXBELENBQTRELEVBQUVrSyxDQUE5RCxDQUFpRSxDQUMvRDZuQyxHQUFHLENBQUdoQyxJQUFJLENBQUNmLFVBQUwsQ0FBZ0I5a0MsQ0FBaEIsQ0FBTixDQUNBLEdBQUc3SyxPQUFPLENBQUM2VyxFQUFSLEVBQWM2N0IsR0FBRyxDQUFDNzdCLEVBQUosR0FBVzdXLE9BQU8sQ0FBQzZXLEVBQXBDLENBQXdDLENBQ3RDNUYsSUFBSSxDQUFHeWhDLEdBQVAsQ0FDRCxDQUZELElBRU8sSUFBRzF5QyxPQUFPLENBQUNxSCxJQUFSLEVBQWdCcXJDLEdBQUcsQ0FBQ3JyQyxJQUFKLEdBQWFySCxPQUFPLENBQUNxSCxJQUF4QyxDQUE4QyxDQUNuRDRKLElBQUksQ0FBR3loQyxHQUFQLENBQ0QsQ0FDRixDQUNELE1BQU96aEMsS0FBUCxDQUNELENBaEJELENBa0JBOzs7OztLQU1BeS9CLElBQUksQ0FBQzNpQixJQUFMLENBQVksU0FBU3JyQixHQUFULENBQWNvakIsRUFBZCxDQUFrQixDQUM1QjtBQUNBNHFCLElBQUksQ0FBQzVxQixFQUFMLENBQVVBLEVBQUUsRUFBSXJkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU21TLElBQVQsQ0FBYy8wQixNQUFkLEVBQWhCLENBQ0EsR0FBSThzQyxhQUFZLENBQUd0cUIsSUFBSSxDQUFDZ3JCLElBQUksQ0FBQzVxQixFQUFMLENBQVF3QyxTQUFSLENBQW9CLG1CQUFyQixDQUF2QixDQUNBLEdBQUcsQ0FBQzBuQixZQUFKLENBQWtCLENBQ2hCLEdBQUlydEMsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUseUNBQ3BCLHVDQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQzJsQixTQUFOLENBQWtCb29CLElBQUksQ0FBQzVxQixFQUFMLENBQVF3QyxTQUExQixDQUNBLEtBQU0zbEIsTUFBTixDQUNELENBQ0QrdEMsSUFBSSxDQUFDYSxZQUFMLENBQW9CYixJQUFJLENBQUNjLE9BQUwsQ0FBYXhCLFlBQWIsQ0FBNEJBLFlBQWhELENBRUE7QUFDQVUsSUFBSSxDQUFDaUMsY0FBTCxDQUFzQnhwQyxHQUFHLENBQUN5cEMsaUJBQUosQ0FBc0JsQyxJQUF0QixDQUF0QixDQUNBLEdBQUkxZ0MsTUFBSyxDQUFHbU8sSUFBSSxDQUFDK0QsS0FBTCxDQUFXd3VCLElBQUksQ0FBQ2lDLGNBQWhCLENBQVosQ0FFQTtBQUNBakMsSUFBSSxDQUFDNXFCLEVBQUwsQ0FBUXJKLE1BQVIsQ0FBZXpNLEtBQUssQ0FBQ2EsUUFBTixFQUFmLEVBQ0E2L0IsSUFBSSxDQUFDOWlCLFNBQUwsQ0FBaUJsckIsR0FBRyxDQUFDcXJCLElBQUosQ0FBUzJpQixJQUFJLENBQUM1cUIsRUFBZCxDQUFqQixDQUNELENBbkJELENBcUJBOzs7Ozs7O0tBUUE0cUIsSUFBSSxDQUFDL2lCLE1BQUwsQ0FBYyxTQUFTa2xCLEtBQVQsQ0FBZ0IsQ0FDNUIsR0FBSTVoQyxLQUFJLENBQUcsS0FBWCxDQUVBLEdBQUcsQ0FBQ3kvQixJQUFJLENBQUNvQyxNQUFMLENBQVlELEtBQVosQ0FBSixDQUF3QixDQUN0QixHQUFJakIsT0FBTSxDQUFHaUIsS0FBSyxDQUFDakIsTUFBbkIsQ0FDQSxHQUFJSyxRQUFPLENBQUd2QixJQUFJLENBQUN1QixPQUFuQixDQUNBLEdBQUl0dkMsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsd0RBQ3BCLGtFQURvQixDQUVwQixvQkFGVSxDQUFaLENBR0FrQyxLQUFLLENBQUNvd0MsY0FBTixDQUF1Qm5CLE1BQU0sQ0FBQzNqQyxVQUE5QixDQUNBdEwsS0FBSyxDQUFDcXdDLFlBQU4sQ0FBcUJmLE9BQU8sQ0FBQ2hrQyxVQUE3QixDQUNBLEtBQU10TCxNQUFOLENBQ0QsQ0FFRCxHQUFJbWpCLEdBQUUsQ0FBRytzQixLQUFLLENBQUMvc0IsRUFBZixDQUNBLEdBQUdBLEVBQUUsR0FBSyxJQUFWLENBQWdCLENBQ2Q7QUFDQSxHQUFHK3NCLEtBQUssQ0FBQ3RCLFlBQU4sR0FBc0I3ckIsS0FBekIsQ0FBK0IsQ0FDN0IsR0FBSXBELElBQUcsQ0FBR29ELElBQUksQ0FBQ210QixLQUFLLENBQUN0QixZQUFQLENBQWQsQ0FDQSxPQUFPanZCLEdBQVAsRUFDQSxJQUFLLHVCQUFMLENBQ0V3RCxFQUFFLENBQUdyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNtUyxJQUFULENBQWMvMEIsTUFBZCxFQUFMLENBQ0EsTUFDRixJQUFLLHNCQUFMLENBQ0U0aUIsRUFBRSxDQUFHcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTNlQsR0FBVCxDQUFhejJCLE1BQWIsRUFBTCxDQUNBLE1BQ0YsSUFBSyx5QkFBTCxDQUNFNGlCLEVBQUUsQ0FBR3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU2EsTUFBVCxDQUFnQnpqQixNQUFoQixFQUFMLENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0U0aUIsRUFBRSxDQUFHcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTbXRCLE1BQVQsQ0FBZ0IvdkMsTUFBaEIsRUFBTCxDQUNBLE1BQ0YsSUFBSyx5QkFBTCxDQUNFNGlCLEVBQUUsQ0FBR3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU2dVLE1BQVQsQ0FBZ0I1MkIsTUFBaEIsRUFBTCxDQUNBLE1BQ0YsSUFBSyxZQUFMLENBQ0U0aUIsRUFBRSxDQUFHcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTYSxNQUFULENBQWdCempCLE1BQWhCLEVBQUwsQ0FDQSxNQWxCRixDQW9CRCxDQUNELEdBQUc0aUIsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDZCxHQUFJbmpCLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLHlDQUNwQix3QkFEVSxDQUFaLENBRUFrQyxLQUFLLENBQUM0dUMsWUFBTixDQUFxQnNCLEtBQUssQ0FBQ3RCLFlBQTNCLENBQ0EsS0FBTTV1QyxNQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlnd0MsZUFBYyxDQUFHRSxLQUFLLENBQUNGLGNBQU4sRUFBd0J4cEMsR0FBRyxDQUFDeXBDLGlCQUFKLENBQXNCQyxLQUF0QixDQUE3QyxDQUNBLEdBQUk3aUMsTUFBSyxDQUFHbU8sSUFBSSxDQUFDK0QsS0FBTCxDQUFXeXdCLGNBQVgsQ0FBWixDQUNBN3NCLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVXpNLEtBQUssQ0FBQ2EsUUFBTixFQUFWLEVBQ0QsQ0FFRCxHQUFHaVYsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDZCxHQUFJM04sT0FBSixDQUVBLE9BQU8wNkIsS0FBSyxDQUFDdEIsWUFBYixFQUNBLElBQUs3ckIsS0FBSSxDQUFDd3RCLHFCQUFWLENBQ0UvNkIsTUFBTSxDQUFHekwsU0FBVCxDQUFxQixvQ0FDckIsTUFDRixJQUFLZ1osS0FBSSxDQUFDLFlBQUQsQ0FBVCxDQUNFLEdBQUl6ZCxLQUFKLENBQVVnb0MsR0FBVixDQUVBLG9CQUNBaG9DLElBQUksQ0FBR3lkLElBQUksQ0FBQ210QixLQUFLLENBQUNNLG1CQUFOLENBQTBCbEQsR0FBMUIsQ0FBOEJob0MsSUFBOUIsQ0FBbUMrbkMsWUFBcEMsQ0FBWCxDQUNBLEdBQUcvbkMsSUFBSSxHQUFLeUUsU0FBVCxFQUFzQmpFLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBUzdkLElBQVQsSUFBbUJ5RSxTQUE1QyxDQUF1RCxDQUNyRCxHQUFJL0osTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsZ0NBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDMmYsR0FBTixDQUFZdXdCLEtBQUssQ0FBQ00sbUJBQU4sQ0FBMEJsRCxHQUExQixDQUE4QmhvQyxJQUE5QixDQUFtQytuQyxZQUEvQyxDQUNBcnRDLEtBQUssQ0FBQzBFLElBQU4sQ0FBYVksSUFBYixDQUNBLEtBQU10RixNQUFOLENBQ0QsQ0FFRHN0QyxHQUFHLENBQUd2cUIsSUFBSSxDQUFDbXRCLEtBQUssQ0FBQ00sbUJBQU4sQ0FBMEJsRCxHQUExQixDQUE4QkQsWUFBL0IsQ0FBVixDQUNBLEdBQUdDLEdBQUcsR0FBS3ZqQyxTQUFSLEVBQXFCakUsS0FBSyxDQUFDd25DLEdBQU4sQ0FBVUEsR0FBVixJQUFtQnZqQyxTQUEzQyxDQUFzRCxDQUNwRCxHQUFJL0osTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsMkJBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDMmYsR0FBTixDQUFZdXdCLEtBQUssQ0FBQ00sbUJBQU4sQ0FBMEJsRCxHQUExQixDQUE4QkQsWUFBMUMsQ0FDQXJ0QyxLQUFLLENBQUMwRSxJQUFOLENBQWE0b0MsR0FBYixDQUNBLEtBQU10dEMsTUFBTixDQUNELENBRURzdEMsR0FBRyxDQUFHeG5DLEtBQUssQ0FBQ3duQyxHQUFOLENBQVVBLEdBQVYsRUFBZS9zQyxNQUFmLENBQXNCdUYsS0FBSyxDQUFDcWQsRUFBTixDQUFTN2QsSUFBVCxFQUFlL0UsTUFBZixFQUF0QixDQUFOLENBRUEsOEJBQ0ErRSxJQUFJLENBQUd5ZCxJQUFJLENBQUNtdEIsS0FBSyxDQUFDTSxtQkFBTixDQUEwQmxyQyxJQUExQixDQUErQituQyxZQUFoQyxDQUFYLENBQ0EsR0FBRy9uQyxJQUFJLEdBQUt5RSxTQUFULEVBQXNCakUsS0FBSyxDQUFDcWQsRUFBTixDQUFTN2QsSUFBVCxJQUFtQnlFLFNBQTVDLENBQXVELENBQ3JELEtBQU0sQ0FDSnRILE9BQU8sQ0FBRSx1Q0FETCxDQUVKa2QsR0FBRyxDQUFFdXdCLEtBQUssQ0FBQ00sbUJBQU4sQ0FBMEJsckMsSUFBMUIsQ0FBK0IrbkMsWUFGaEMsQ0FHSjNvQyxJQUFJLENBQUVZLElBSEYsQ0FBTixDQUtELENBRURrUSxNQUFNLENBQUcxUCxLQUFLLENBQUMycUMsR0FBTixDQUFVbHdDLE1BQVYsQ0FBaUJ1RixLQUFLLENBQUNxZCxFQUFOLENBQVM3ZCxJQUFULEVBQWUvRSxNQUFmLEVBQWpCLENBQTBDK3NDLEdBQTFDLENBQ1A0QyxLQUFLLENBQUNNLG1CQUFOLENBQTBCakQsVUFEbkIsQ0FBVCxDQUVBLE1BdENGLENBeUNBO0FBQ0FqL0IsSUFBSSxDQUFHeS9CLElBQUksQ0FBQ3JuQyxTQUFMLENBQWVza0IsTUFBZixDQUNMN0gsRUFBRSxDQUFDNEMsTUFBSCxHQUFZN1gsUUFBWixFQURLLENBQ21CZ2lDLEtBQUssQ0FBQ2psQixTQUR6QixDQUNvQ3pWLE1BRHBDLENBQVAsQ0FFRCxDQUVELE1BQU9sSCxLQUFQLENBQ0QsQ0F2R0QsQ0F5R0E7Ozs7Ozs7O0tBU0F5L0IsSUFBSSxDQUFDMkMsUUFBTCxDQUFnQixTQUFTQyxNQUFULENBQWlCLENBQy9CLEdBQUlyaUMsS0FBSSxDQUFHLEtBQVgsQ0FFQSxHQUFJcEcsRUFBQyxDQUFHNmxDLElBQUksQ0FBQ2tCLE1BQWIsQ0FDQSxHQUFJM2xDLEVBQUMsQ0FBR3FuQyxNQUFNLENBQUNyQixPQUFmLENBRUE7QUFDQSxHQUFHcG5DLENBQUMsQ0FBQzVDLElBQUYsRUFBVWdFLENBQUMsQ0FBQ2hFLElBQWYsQ0FBcUIsQ0FDbkJnSixJQUFJLENBQUlwRyxDQUFDLENBQUM1QyxJQUFGLEdBQVdnRSxDQUFDLENBQUNoRSxJQUFyQixDQUNELENBRkQsSUFFTyxJQUFHNEMsQ0FBQyxDQUFDb0QsVUFBRixDQUFhdE4sTUFBYixHQUF3QnNMLENBQUMsQ0FBQ2dDLFVBQUYsQ0FBYXROLE1BQXhDLENBQWdELENBQ3JEO0FBQ0FzUSxJQUFJLENBQUcsSUFBUCxDQUNBLEdBQUlzaUMsTUFBSixDQUFXQyxLQUFYLENBQ0EsSUFBSSxHQUFJaG9DLEVBQUMsQ0FBRyxDQUFaLENBQWV5RixJQUFJLEVBQUl6RixDQUFDLENBQUdYLENBQUMsQ0FBQ29ELFVBQUYsQ0FBYXROLE1BQXhDLENBQWdELEVBQUU2SyxDQUFsRCxDQUFxRCxDQUNuRCtuQyxLQUFLLENBQUcxb0MsQ0FBQyxDQUFDb0QsVUFBRixDQUFhekMsQ0FBYixDQUFSLENBQ0Fnb0MsS0FBSyxDQUFHdm5DLENBQUMsQ0FBQ2dDLFVBQUYsQ0FBYXpDLENBQWIsQ0FBUixDQUNBLEdBQUcrbkMsS0FBSyxDQUFDLzdCLElBQU4sR0FBZWc4QixLQUFLLENBQUNoOEIsSUFBckIsRUFBNkIrN0IsS0FBSyxDQUFDbDVCLEtBQU4sR0FBZ0JtNUIsS0FBSyxDQUFDbjVCLEtBQXRELENBQTZELENBQzNEO0FBQ0FwSixJQUFJLENBQUcsS0FBUCxDQUNELENBQ0YsQ0FDRixDQUVELE1BQU9BLEtBQVAsQ0FDRCxDQXhCRCxDQTBCQTs7Ozs7Ozs7S0FTQXkvQixJQUFJLENBQUNvQyxNQUFMLENBQWMsU0FBU0QsS0FBVCxDQUFnQixDQUM1QixNQUFPQSxNQUFLLENBQUNRLFFBQU4sQ0FBZTNDLElBQWYsQ0FBUCxDQUNELENBRkQsQ0FJQTs7OztLQUtBQSxJQUFJLENBQUMrQyw0QkFBTCxDQUFvQyxVQUFXLENBQzdDOzs7Ozs7Ozs7O01BRDZDLENBYTdDO0FBQ0E7QUFDQTtBQUNBLE1BQU90cUMsSUFBRyxDQUFDMm5DLHVCQUFKLENBQTRCSixJQUFJLENBQUNybkMsU0FBakMsQ0FBNEMsQ0FBQ21PLElBQUksQ0FBRSxjQUFQLENBQTVDLENBQVAsQ0FDRCxDQWpCRCxDQW1CQTs7Ozs7O0tBT0FrNUIsSUFBSSxDQUFDZ0QsMEJBQUwsQ0FBa0MsVUFBVyxDQUMzQyxHQUFJcHhCLElBQUcsQ0FBR29ELElBQUksQ0FBQyxzQkFBRCxDQUFkLENBQ0EsSUFBSSxHQUFJN2EsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHNmxDLElBQUksQ0FBQ2YsVUFBTCxDQUFnQmh2QyxNQUFuQyxDQUEyQyxFQUFFa0ssQ0FBN0MsQ0FBZ0QsQ0FDOUMsR0FBSTZuQyxJQUFHLENBQUdoQyxJQUFJLENBQUNmLFVBQUwsQ0FBZ0I5a0MsQ0FBaEIsQ0FBVixDQUNBLEdBQUc2bkMsR0FBRyxDQUFDNzdCLEVBQUosR0FBV3lMLEdBQWQsQ0FBbUIsQ0FDakIsR0FBSXF4QixJQUFHLENBQUdqRCxJQUFJLENBQUMrQyw0QkFBTCxHQUFvQzVpQyxRQUFwQyxFQUFWLENBQ0EsTUFBUXBJLE1BQUssQ0FBQzJELElBQU4sQ0FBV3NJLFVBQVgsQ0FBc0JnK0IsR0FBRyxDQUFDa0Isb0JBQTFCLElBQW9ERCxHQUE1RCxDQUNELENBQ0YsQ0FDRCxNQUFPLE1BQVAsQ0FDRCxDQVZELENBWUEsTUFBT2pELEtBQVAsQ0FDRCxDQTFWRCxDQTRWQTs7Ozs7Ozs7Ozs7O0dBYUF2bkMsR0FBRyxDQUFDcW5DLG1CQUFKLENBQTBCLFNBQVMxNUIsR0FBVCxDQUFjeTVCLFdBQWQsQ0FBMkIsQ0FDbkQ7QUFDQSxHQUFJMXJCLFFBQU8sQ0FBRyxFQUFkLENBQ0EsR0FBSS9lLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBRyxDQUFDcVksSUFBSSxDQUFDd0csUUFBTCxDQUFjN04sR0FBZCxDQUFtQmk0Qix3QkFBbkIsQ0FBNkNscUIsT0FBN0MsQ0FBc0QvZSxNQUF0RCxDQUFKLENBQW1FLENBQ2pFLEdBQUluRCxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxrQ0FDcEIsNENBRFUsQ0FBWixDQUVBa0MsS0FBSyxDQUFDbUQsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5ELE1BQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSTJmLElBQUcsQ0FBR25FLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ2tLLFlBQXRCLENBQVYsQ0FDQSxHQUFHek0sR0FBRyxHQUFLblosR0FBRyxDQUFDdWMsSUFBSixDQUFTd0ksYUFBcEIsQ0FBbUMsQ0FDakMsS0FBTSxJQUFJenRCLE1BQUosQ0FBVSx5Q0FBVixDQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlpd0MsS0FBSSxDQUFHdm5DLEdBQUcsQ0FBQ2tvQyxpQkFBSixFQUFYLENBQ0FYLElBQUksQ0FBQ2xjLE9BQUwsQ0FBZTNQLE9BQU8sQ0FBQ2d2QixXQUFSLENBQ2JodkIsT0FBTyxDQUFDZ3ZCLFdBQVIsQ0FBb0I5aUMsVUFBcEIsQ0FBK0IsQ0FBL0IsQ0FEYSxDQUN1QixDQUR0QyxDQUVBLEdBQUkraUMsT0FBTSxDQUFHcnJDLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0I2UyxPQUFPLENBQUNrdkIsZ0JBQWhDLENBQWIsQ0FDQXJELElBQUksQ0FBQ1ksWUFBTCxDQUFvQndDLE1BQU0sQ0FBQzFoQyxLQUFQLEVBQXBCLENBQ0FzK0IsSUFBSSxDQUFDYSxZQUFMLENBQW9COW9DLEtBQUssQ0FBQzBWLElBQU4sQ0FBV3NFLFFBQVgsQ0FBb0JvQyxPQUFPLENBQUNtdkIsZ0JBQTVCLENBQXBCLENBQ0F0RCxJQUFJLENBQUN5QyxtQkFBTCxDQUEyQnJELHdCQUF3QixDQUNqRFksSUFBSSxDQUFDYSxZQUQ0QyxDQUM5QjFzQixPQUFPLENBQUNvdkIsbUJBRHNCLENBQ0QsSUFEQyxDQUFuRCxDQUVBdkQsSUFBSSxDQUFDYyxPQUFMLENBQWF4QixZQUFiLENBQTRCdm5DLEtBQUssQ0FBQzBWLElBQU4sQ0FBV3NFLFFBQVgsQ0FBb0JvQyxPQUFPLENBQUNxdkIsb0JBQTVCLENBQTVCLENBQ0F4RCxJQUFJLENBQUNjLE9BQUwsQ0FBYTVjLFVBQWIsQ0FBMEJrYix3QkFBd0IsQ0FBQ1ksSUFBSSxDQUFDYyxPQUFMLENBQWF4QixZQUFkLENBQ2hEbnJCLE9BQU8sQ0FBQ3N2Qix1QkFEd0MsQ0FDZixLQURlLENBQWxELENBRUF6RCxJQUFJLENBQUM5aUIsU0FBTCxDQUFpQi9JLE9BQU8sQ0FBQ3V2QixhQUF6QixDQUVBLEdBQUkzQyxTQUFRLENBQUcsRUFBZixDQUNBLEdBQUc1c0IsT0FBTyxDQUFDd3ZCLG9CQUFSLEdBQWlDM25DLFNBQXBDLENBQStDLENBQzdDK2tDLFFBQVEsQ0FBQ2xrQyxJQUFULENBQWM0USxJQUFJLENBQUN1RSxhQUFMLENBQW1CbUMsT0FBTyxDQUFDd3ZCLG9CQUEzQixDQUFkLEVBQ0QsQ0FDRCxHQUFHeHZCLE9BQU8sQ0FBQ3l2Qiw0QkFBUixHQUF5QzVuQyxTQUE1QyxDQUF1RCxDQUNyRCtrQyxRQUFRLENBQUNsa0MsSUFBVCxDQUFjNFEsSUFBSSxDQUFDcUYscUJBQUwsQ0FDWnFCLE9BQU8sQ0FBQ3l2Qiw0QkFESSxDQUFkLEVBRUQsQ0FDRCxHQUFHenZCLE9BQU8sQ0FBQzB2QixvQkFBUixHQUFpQzduQyxTQUFwQyxDQUErQyxDQUM3QytrQyxRQUFRLENBQUNsa0MsSUFBVCxDQUFjNFEsSUFBSSxDQUFDdUUsYUFBTCxDQUFtQm1DLE9BQU8sQ0FBQzB2QixvQkFBM0IsQ0FBZCxFQUNELENBQ0QsR0FBRzF2QixPQUFPLENBQUMydkIsNEJBQVIsR0FBeUM5bkMsU0FBNUMsQ0FBdUQsQ0FDckQra0MsUUFBUSxDQUFDbGtDLElBQVQsQ0FBYzRRLElBQUksQ0FBQ3FGLHFCQUFMLENBQ1pxQixPQUFPLENBQUMydkIsNEJBREksQ0FBZCxFQUVELENBQ0QsR0FBRy9DLFFBQVEsQ0FBQzl3QyxNQUFULENBQWtCLENBQXJCLENBQXdCLENBQ3RCLEtBQU0sSUFBSUYsTUFBSixDQUFVLHVEQUNkLGtEQURJLENBQU4sQ0FFRCxDQUNELEdBQUdneEMsUUFBUSxDQUFDOXdDLE1BQVQsQ0FBa0IsQ0FBckIsQ0FBd0IsQ0FDdEIsS0FBTSxJQUFJRixNQUFKLENBQVUsdURBQ2QseURBREksQ0FBTixDQUVELENBQ0Rpd0MsSUFBSSxDQUFDZSxRQUFMLENBQWNDLFNBQWQsQ0FBMEJELFFBQVEsQ0FBQyxDQUFELENBQWxDLENBQ0FmLElBQUksQ0FBQ2UsUUFBTCxDQUFjRSxRQUFkLENBQXlCRixRQUFRLENBQUMsQ0FBRCxDQUFqQyxDQUVBO0FBQ0FmLElBQUksQ0FBQ2lDLGNBQUwsQ0FBc0I5dEIsT0FBTyxDQUFDOHRCLGNBQTlCLENBRUEsR0FBR3BDLFdBQUgsQ0FBZ0IsQ0FDZDtBQUNBRyxJQUFJLENBQUM1cUIsRUFBTCxDQUFVLElBQVYsQ0FDQSxHQUFHNHFCLElBQUksQ0FBQ2EsWUFBTCxHQUFxQjdyQixLQUF4QixDQUE4QixDQUM1QixHQUFJcEQsSUFBRyxDQUFHb0QsSUFBSSxDQUFDZ3JCLElBQUksQ0FBQ2EsWUFBTixDQUFkLENBQ0EsT0FBT2p2QixHQUFQLEVBQ0EsSUFBSyx1QkFBTCxDQUNFb3VCLElBQUksQ0FBQzVxQixFQUFMLENBQVVyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNtUyxJQUFULENBQWMvMEIsTUFBZCxFQUFWLENBQ0EsTUFDRixJQUFLLHNCQUFMLENBQ0V3dEMsSUFBSSxDQUFDNXFCLEVBQUwsQ0FBVXJkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBUzZULEdBQVQsQ0FBYXoyQixNQUFiLEVBQVYsQ0FDQSxNQUNGLElBQUsseUJBQUwsQ0FDRXd0QyxJQUFJLENBQUM1cUIsRUFBTCxDQUFVcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTYSxNQUFULENBQWdCempCLE1BQWhCLEVBQVYsQ0FDQSxNQUNGLElBQUsseUJBQUwsQ0FDRXd0QyxJQUFJLENBQUM1cUIsRUFBTCxDQUFVcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTbXRCLE1BQVQsQ0FBZ0IvdkMsTUFBaEIsRUFBVixDQUNBLE1BQ0YsSUFBSyx5QkFBTCxDQUNFd3RDLElBQUksQ0FBQzVxQixFQUFMLENBQVVyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNnVSxNQUFULENBQWdCNTJCLE1BQWhCLEVBQVYsQ0FDQSxNQUNGLElBQUssWUFBTCxDQUNFd3RDLElBQUksQ0FBQzVxQixFQUFMLENBQVVyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNhLE1BQVQsQ0FBZ0J6akIsTUFBaEIsRUFBVixDQUNBLE1BbEJGLENBb0JELENBQ0QsR0FBR3d0QyxJQUFJLENBQUM1cUIsRUFBTCxHQUFZLElBQWYsQ0FBcUIsQ0FDbkIsR0FBSW5qQixNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSx5Q0FDcEIsd0JBRFUsQ0FBWixDQUVBa0MsS0FBSyxDQUFDNHVDLFlBQU4sQ0FBcUJiLElBQUksQ0FBQ2EsWUFBMUIsQ0FDQSxLQUFNNXVDLE1BQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSXFOLE1BQUssQ0FBR21PLElBQUksQ0FBQytELEtBQUwsQ0FBV3d1QixJQUFJLENBQUNpQyxjQUFoQixDQUFaLENBQ0FqQyxJQUFJLENBQUM1cUIsRUFBTCxDQUFRckosTUFBUixDQUFlek0sS0FBSyxDQUFDYSxRQUFOLEVBQWYsRUFDRCxDQUVEO0FBQ0EsR0FBSTRqQyxJQUFHLENBQUdoc0MsS0FBSyxDQUFDcWQsRUFBTixDQUFTbVMsSUFBVCxDQUFjLzBCLE1BQWQsRUFBVixDQUNBd3RDLElBQUksQ0FBQ2tCLE1BQUwsQ0FBWUMsUUFBWixDQUF1QixTQUFTQyxFQUFULENBQWEsQ0FDbEMsTUFBT2pDLGNBQWEsQ0FBQ2EsSUFBSSxDQUFDa0IsTUFBTixDQUFjRSxFQUFkLENBQXBCLENBQ0QsQ0FGRCxDQUdBcEIsSUFBSSxDQUFDa0IsTUFBTCxDQUFZRyxRQUFaLENBQXVCLFNBQVNua0MsSUFBVCxDQUFlLENBQ3BDb2tDLGtCQUFrQixDQUFDLENBQUNwa0MsSUFBRCxDQUFELENBQWxCLENBQ0E4aUMsSUFBSSxDQUFDa0IsTUFBTCxDQUFZM2pDLFVBQVosQ0FBdUJWLElBQXZCLENBQTRCSyxJQUE1QixFQUNELENBSEQsQ0FJQThpQyxJQUFJLENBQUNrQixNQUFMLENBQVkzakMsVUFBWixDQUF5QjlFLEdBQUcsQ0FBQ2dtQyxvQkFBSixDQUF5QnRxQixPQUFPLENBQUM2dkIsVUFBakMsQ0FBNkNELEdBQTdDLENBQXpCLENBQ0EsR0FBRzV2QixPQUFPLENBQUM4dkIsa0JBQVgsQ0FBK0IsQ0FDN0JqRSxJQUFJLENBQUNrQixNQUFMLENBQVlRLFFBQVosQ0FBdUJ2dEIsT0FBTyxDQUFDOHZCLGtCQUEvQixDQUNELENBQ0RqRSxJQUFJLENBQUNrQixNQUFMLENBQVkzcEMsSUFBWixDQUFtQndzQyxHQUFHLENBQUMvckIsTUFBSixHQUFhdFcsS0FBYixFQUFuQixDQUVBO0FBQ0EsR0FBSXdpQyxJQUFHLENBQUduc0MsS0FBSyxDQUFDcWQsRUFBTixDQUFTbVMsSUFBVCxDQUFjLzBCLE1BQWQsRUFBVixDQUNBd3RDLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYUosUUFBYixDQUF3QixTQUFTQyxFQUFULENBQWEsQ0FDbkMsTUFBT2pDLGNBQWEsQ0FBQ2EsSUFBSSxDQUFDdUIsT0FBTixDQUFlSCxFQUFmLENBQXBCLENBQ0QsQ0FGRCxDQUdBcEIsSUFBSSxDQUFDdUIsT0FBTCxDQUFhRixRQUFiLENBQXdCLFNBQVNua0MsSUFBVCxDQUFlLENBQ3JDb2tDLGtCQUFrQixDQUFDLENBQUNwa0MsSUFBRCxDQUFELENBQWxCLENBQ0E4aUMsSUFBSSxDQUFDdUIsT0FBTCxDQUFhaGtDLFVBQWIsQ0FBd0JWLElBQXhCLENBQTZCSyxJQUE3QixFQUNELENBSEQsQ0FJQThpQyxJQUFJLENBQUN1QixPQUFMLENBQWFoa0MsVUFBYixDQUEwQjlFLEdBQUcsQ0FBQ2dtQyxvQkFBSixDQUF5QnRxQixPQUFPLENBQUNnd0IsV0FBakMsQ0FBOENELEdBQTlDLENBQTFCLENBQ0EsR0FBRy92QixPQUFPLENBQUNpd0IsbUJBQVgsQ0FBZ0MsQ0FDOUJwRSxJQUFJLENBQUN1QixPQUFMLENBQWFHLFFBQWIsQ0FBd0J2dEIsT0FBTyxDQUFDaXdCLG1CQUFoQyxDQUNELENBQ0RwRSxJQUFJLENBQUN1QixPQUFMLENBQWFocUMsSUFBYixDQUFvQjJzQyxHQUFHLENBQUNsc0IsTUFBSixHQUFhdFcsS0FBYixFQUFwQixDQUVBO0FBQ0EsR0FBR3lTLE9BQU8sQ0FBQ2t3QixjQUFYLENBQTJCLENBQ3pCckUsSUFBSSxDQUFDZixVQUFMLENBQWtCeG1DLEdBQUcsQ0FBQzZyQyw2QkFBSixDQUFrQ253QixPQUFPLENBQUNrd0IsY0FBMUMsQ0FBbEIsQ0FDRCxDQUZELElBRU8sQ0FDTHJFLElBQUksQ0FBQ2YsVUFBTCxDQUFrQixFQUFsQixDQUNELENBRUQ7QUFDQWUsSUFBSSxDQUFDcm5DLFNBQUwsQ0FBaUJGLEdBQUcsQ0FBQzJsQixpQkFBSixDQUFzQmpLLE9BQU8sQ0FBQ293QixvQkFBOUIsQ0FBakIsQ0FFQSxNQUFPdkUsS0FBUCxDQUNELENBM0lELENBNklBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1REF2bkMsR0FBRyxDQUFDNnJDLDZCQUFKLENBQW9DLFNBQVN6QyxJQUFULENBQWUsQ0FDakQsR0FBSXRoQyxLQUFJLENBQUcsRUFBWCxDQUNBLElBQUksR0FBSXBHLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzBuQyxJQUFJLENBQUNsNEIsS0FBTCxDQUFXMVosTUFBOUIsQ0FBc0MsRUFBRWtLLENBQXhDLENBQTJDLENBQ3pDO0FBQ0EsR0FBSXFxQyxPQUFNLENBQUczQyxJQUFJLENBQUNsNEIsS0FBTCxDQUFXeFAsQ0FBWCxDQUFiLENBQ0EsSUFBSSxHQUFJOG5CLEdBQUUsQ0FBRyxDQUFiLENBQWdCQSxFQUFFLENBQUd1aUIsTUFBTSxDQUFDNzZCLEtBQVAsQ0FBYTFaLE1BQWxDLENBQTBDLEVBQUVneUIsRUFBNUMsQ0FBZ0QsQ0FDOUMxaEIsSUFBSSxDQUFDMUQsSUFBTCxDQUFVcEUsR0FBRyxDQUFDeW1DLDRCQUFKLENBQWlDc0YsTUFBTSxDQUFDNzZCLEtBQVAsQ0FBYXNZLEVBQWIsQ0FBakMsQ0FBVixFQUNELENBQ0YsQ0FFRCxNQUFPMWhCLEtBQVAsQ0FDRCxDQVhELENBYUE7Ozs7OztHQU9BOUgsR0FBRyxDQUFDeW1DLDRCQUFKLENBQW1DLFNBQVM4QyxHQUFULENBQWMsQ0FDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFJbGpDLEVBQUMsQ0FBRyxFQUFSLENBQ0FBLENBQUMsQ0FBQ3FILEVBQUYsQ0FBT3NILElBQUksQ0FBQ3NFLFFBQUwsQ0FBY2l3QixHQUFHLENBQUNyNEIsS0FBSixDQUFVLENBQVYsRUFBYUEsS0FBM0IsQ0FBUCxDQUNBN0ssQ0FBQyxDQUFDMmxDLFFBQUYsQ0FBYSxLQUFiLENBQ0EsR0FBR3pDLEdBQUcsQ0FBQ3I0QixLQUFKLENBQVUsQ0FBVixFQUFhN0MsSUFBYixHQUFzQjJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRSxPQUFuQyxDQUE0QyxDQUMxQ25QLENBQUMsQ0FBQzJsQyxRQUFGLENBQWN6QyxHQUFHLENBQUNyNEIsS0FBSixDQUFVLENBQVYsRUFBYUEsS0FBYixDQUFtQnRKLFVBQW5CLENBQThCLENBQTlCLElBQXFDLElBQW5ELENBQ0F2QixDQUFDLENBQUM2SyxLQUFGLENBQVVxNEIsR0FBRyxDQUFDcjRCLEtBQUosQ0FBVSxDQUFWLEVBQWFBLEtBQXZCLENBQ0QsQ0FIRCxJQUdPLENBQ0w3SyxDQUFDLENBQUM2SyxLQUFGLENBQVVxNEIsR0FBRyxDQUFDcjRCLEtBQUosQ0FBVSxDQUFWLEVBQWFBLEtBQXZCLENBQ0QsQ0FDRDtBQUNBLEdBQUc3SyxDQUFDLENBQUNxSCxFQUFGLEdBQVE2TyxLQUFYLENBQWlCLENBQ2ZsVyxDQUFDLENBQUNuSSxJQUFGLENBQVNxZSxJQUFJLENBQUNsVyxDQUFDLENBQUNxSCxFQUFILENBQWIsQ0FFQTtBQUNBLEdBQUdySCxDQUFDLENBQUNuSSxJQUFGLEdBQVcsVUFBZCxDQUEwQixDQUN4QjtBQUNBLEdBQUkrdEMsR0FBRSxDQUFHajNCLElBQUksQ0FBQ2lELE9BQUwsQ0FBYTVSLENBQUMsQ0FBQzZLLEtBQWYsQ0FBVCxDQUNBLEdBQUl1RyxHQUFFLENBQUcsSUFBVCxDQUNBLEdBQUl5MEIsR0FBRSxDQUFHLElBQVQsQ0FDQSxHQUFHRCxFQUFFLENBQUMvNkIsS0FBSCxDQUFTMVosTUFBVCxDQUFrQixDQUFyQixDQUF3QixDQUN0QjtBQUNBO0FBQ0E7QUFDQWlnQixFQUFFLENBQUd3MEIsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBU3RKLFVBQVQsQ0FBb0IsQ0FBcEIsQ0FBTCxDQUNBc2tDLEVBQUUsQ0FBR0QsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUzFaLE1BQVQsQ0FBa0IsQ0FBbEIsQ0FBc0J5MEMsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBU3RKLFVBQVQsQ0FBb0IsQ0FBcEIsQ0FBdEIsQ0FBK0MsQ0FBcEQsQ0FDRCxDQUNEO0FBQ0F2QixDQUFDLENBQUM4bEMsZ0JBQUYsQ0FBcUIsQ0FBQzEwQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUFyQyxDQUNBcFIsQ0FBQyxDQUFDK2xDLGNBQUYsQ0FBbUIsQ0FBQzMwQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUFuQyxDQUNBcFIsQ0FBQyxDQUFDZ21DLGVBQUYsQ0FBb0IsQ0FBQzUwQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUFwQyxDQUNBcFIsQ0FBQyxDQUFDaW1DLGdCQUFGLENBQXFCLENBQUM3MEIsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBckMsQ0FDQXBSLENBQUMsQ0FBQ2ttQyxZQUFGLENBQWlCLENBQUM5MEIsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBakMsQ0FDQXBSLENBQUMsQ0FBQ21tQyxXQUFGLENBQWdCLENBQUMvMEIsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBaEMsQ0FDQXBSLENBQUMsQ0FBQ29tQyxPQUFGLENBQVksQ0FBQ2gxQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUE1QixDQUNBcFIsQ0FBQyxDQUFDcW1DLFlBQUYsQ0FBaUIsQ0FBQ2oxQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUFqQyxDQUNBcFIsQ0FBQyxDQUFDc21DLFlBQUYsQ0FBaUIsQ0FBQ1QsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBakMsQ0FDRCxDQXRCRCxJQXNCTyxJQUFHN2xDLENBQUMsQ0FBQ25JLElBQUYsR0FBVyxrQkFBZCxDQUFrQyxDQUN2QztBQUNBO0FBQ0EsR0FBSSt0QyxHQUFFLENBQUdqM0IsSUFBSSxDQUFDaUQsT0FBTCxDQUFhNVIsQ0FBQyxDQUFDNkssS0FBZixDQUFULENBQ0E7QUFDQSxHQUFHKzZCLEVBQUUsQ0FBQy82QixLQUFILENBQVMxWixNQUFULENBQWtCLENBQWxCLEVBQXVCeTBDLEVBQUUsQ0FBQy82QixLQUFILENBQVMsQ0FBVCxFQUFZN0MsSUFBWixHQUFxQjJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRSxPQUF6RCxDQUFrRSxDQUNoRW5QLENBQUMsQ0FBQ3VtQyxFQUFGLENBQVFYLEVBQUUsQ0FBQy82QixLQUFILENBQVMsQ0FBVCxFQUFZQSxLQUFaLENBQWtCdEosVUFBbEIsQ0FBNkIsQ0FBN0IsSUFBb0MsSUFBNUMsQ0FDRCxDQUZELElBRU8sQ0FDTHZCLENBQUMsQ0FBQ3VtQyxFQUFGLENBQU8sS0FBUCxDQUNELENBQ0Q7QUFDQSxHQUFJMTdCLE1BQUssQ0FBRyxJQUFaLENBQ0EsR0FBRys2QixFQUFFLENBQUMvNkIsS0FBSCxDQUFTMVosTUFBVCxDQUFrQixDQUFsQixFQUF1QnkwQyxFQUFFLENBQUMvNkIsS0FBSCxDQUFTLENBQVQsRUFBWTdDLElBQVosR0FBcUIyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBekQsQ0FBa0UsQ0FDaEV2RSxLQUFLLENBQUcrNkIsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUyxDQUFULEVBQVlBLEtBQXBCLENBQ0QsQ0FGRCxJQUVPLElBQUcrNkIsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUzFaLE1BQVQsQ0FBa0IsQ0FBckIsQ0FBd0IsQ0FDN0IwWixLQUFLLENBQUcrNkIsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUyxDQUFULEVBQVlBLEtBQXBCLENBQ0QsQ0FDRCxHQUFHQSxLQUFLLEdBQUssSUFBYixDQUFtQixDQUNqQjdLLENBQUMsQ0FBQ3dtQyxpQkFBRixDQUFzQjczQixJQUFJLENBQUN1RyxZQUFMLENBQWtCckssS0FBbEIsQ0FBdEIsQ0FDRCxDQUNGLENBcEJNLElBb0JBLElBQUc3SyxDQUFDLENBQUNuSSxJQUFGLEdBQVcsYUFBZCxDQUE2QixDQUNsQztBQUNBO0FBQ0EsR0FBSSt0QyxHQUFFLENBQUdqM0IsSUFBSSxDQUFDaUQsT0FBTCxDQUFhNVIsQ0FBQyxDQUFDNkssS0FBZixDQUFULENBQ0EsSUFBSSxHQUFJK2EsR0FBRSxDQUFHLENBQWIsQ0FBZ0JBLEVBQUUsQ0FBR2dnQixFQUFFLENBQUMvNkIsS0FBSCxDQUFTMVosTUFBOUIsQ0FBc0MsRUFBRXkwQixFQUF4QyxDQUE0QyxDQUMxQyxHQUFJOVMsSUFBRyxDQUFHbkUsSUFBSSxDQUFDc0UsUUFBTCxDQUFjMnlCLEVBQUUsQ0FBQy82QixLQUFILENBQVMrYSxFQUFULEVBQWEvYSxLQUEzQixDQUFWLENBQ0EsR0FBR2lJLEdBQUcsR0FBSW9ELEtBQVYsQ0FBZ0IsQ0FDZGxXLENBQUMsQ0FBQ2tXLElBQUksQ0FBQ3BELEdBQUQsQ0FBTCxDQUFELENBQWUsSUFBZixDQUNELENBRkQsSUFFTyxDQUNMOVMsQ0FBQyxDQUFDOFMsR0FBRCxDQUFELENBQVMsSUFBVCxDQUNELENBQ0YsQ0FDRixDQVpNLElBWUEsSUFBRzlTLENBQUMsQ0FBQ25JLElBQUYsR0FBVyxZQUFkLENBQTRCLENBQ2pDO0FBQ0E7QUFDQSxHQUFJK3RDLEdBQUUsQ0FBR2ozQixJQUFJLENBQUNpRCxPQUFMLENBQWE1UixDQUFDLENBQUM2SyxLQUFmLENBQVQsQ0FDQSxHQUFJdUcsR0FBRSxDQUFHLElBQVQsQ0FDQSxHQUFHdzBCLEVBQUUsQ0FBQy82QixLQUFILENBQVMxWixNQUFULENBQWtCLENBQXJCLENBQXdCLENBQ3RCO0FBQ0E7QUFDQTtBQUNBaWdCLEVBQUUsQ0FBR3cwQixFQUFFLENBQUMvNkIsS0FBSCxDQUFTdEosVUFBVCxDQUFvQixDQUFwQixDQUFMLENBQ0QsQ0FDRDtBQUNBdkIsQ0FBQyxDQUFDeW1DLE1BQUYsQ0FBVyxDQUFDcjFCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQTNCLENBQ0FwUixDQUFDLENBQUMwbUMsTUFBRixDQUFXLENBQUN0MUIsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBM0IsQ0FDQXBSLENBQUMsQ0FBQzJtQyxLQUFGLENBQVUsQ0FBQ3YxQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUExQixDQUNBcFIsQ0FBQyxDQUFDNG1DLE9BQUYsQ0FBWSxDQUFDeDFCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQTVCLENBQ0FwUixDQUFDLENBQUM2bUMsUUFBRixDQUFhLENBQUN6MUIsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBN0IsQ0FDQXBSLENBQUMsQ0FBQzhtQyxLQUFGLENBQVUsQ0FBQzExQixFQUFFLENBQUcsSUFBTixJQUFnQixJQUExQixDQUNBcFIsQ0FBQyxDQUFDK21DLE9BQUYsQ0FBWSxDQUFDMzFCLEVBQUUsQ0FBRyxJQUFOLElBQWdCLElBQTVCLENBQ0FwUixDQUFDLENBQUNnbkMsS0FBRixDQUFVLENBQUM1MUIsRUFBRSxDQUFHLElBQU4sSUFBZ0IsSUFBMUIsQ0FDRCxDQXBCTSxJQW9CQSxJQUNMcFIsQ0FBQyxDQUFDbkksSUFBRixHQUFXLGdCQUFYLEVBQ0FtSSxDQUFDLENBQUNuSSxJQUFGLEdBQVcsZUFGTixDQUV1QixDQUM1QjtBQUNBbUksQ0FBQyxDQUFDaW5DLFFBQUYsQ0FBYSxFQUFiLENBRUE7QUFDQSxHQUFJQyxHQUFKLENBQ0EsR0FBSXRCLEdBQUUsQ0FBR2ozQixJQUFJLENBQUNpRCxPQUFMLENBQWE1UixDQUFDLENBQUM2SyxLQUFmLENBQVQsQ0FDQSxJQUFJLEdBQUk3TyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUc0cEMsRUFBRSxDQUFDLzZCLEtBQUgsQ0FBUzFaLE1BQTVCLENBQW9DLEVBQUU2SyxDQUF0QyxDQUF5QyxDQUN2QztBQUNBa3JDLEVBQUUsQ0FBR3RCLEVBQUUsQ0FBQy82QixLQUFILENBQVM3TyxDQUFULENBQUwsQ0FFQSxHQUFJbXJDLFFBQU8sQ0FBRyxDQUNabi9CLElBQUksQ0FBRWsvQixFQUFFLENBQUNsL0IsSUFERyxDQUVaNkMsS0FBSyxDQUFFcThCLEVBQUUsQ0FBQ3I4QixLQUZFLENBQWQsQ0FJQTdLLENBQUMsQ0FBQ2luQyxRQUFGLENBQVdscEMsSUFBWCxDQUFnQm9wQyxPQUFoQixFQUVBO0FBQ0EsT0FBT0QsRUFBRSxDQUFDbC9CLElBQVYsRUFDQTtBQUNBLElBQUssRUFBTCxDQUNBO0FBQ0EsSUFBSyxFQUFMLENBQ0E7QUFDQSxJQUFLLEVBQUwsQ0FDRSxNQUNGO0FBQ0EsSUFBSyxFQUFMLENBQ0U7QUFDQW0vQixPQUFPLENBQUNsN0IsRUFBUixDQUFhaFQsS0FBSyxDQUFDMkQsSUFBTixDQUFXMlAsU0FBWCxDQUFxQjI2QixFQUFFLENBQUNyOEIsS0FBeEIsQ0FBYixDQUNBLE1BQ0Y7QUFDQSxJQUFLLEVBQUwsQ0FDRXM4QixPQUFPLENBQUNyMEIsR0FBUixDQUFjbkUsSUFBSSxDQUFDc0UsUUFBTCxDQUFjaTBCLEVBQUUsQ0FBQ3I4QixLQUFqQixDQUFkLENBQ0EsTUFDRixRQUNFO0FBbEJGLENBb0JELENBQ0YsQ0F6Q00sSUF5Q0EsSUFBRzdLLENBQUMsQ0FBQ25JLElBQUYsR0FBVyxzQkFBZCxDQUFzQyxDQUMzQztBQUNBO0FBQ0EsR0FBSSt0QyxHQUFFLENBQUdqM0IsSUFBSSxDQUFDaUQsT0FBTCxDQUFhNVIsQ0FBQyxDQUFDNkssS0FBZixDQUFULENBQ0E3SyxDQUFDLENBQUNva0Msb0JBQUYsQ0FBeUJuckMsS0FBSyxDQUFDMkQsSUFBTixDQUFXd0ksVUFBWCxDQUFzQndnQyxFQUFFLENBQUMvNkIsS0FBekIsQ0FBekIsQ0FDRCxDQUNGLENBQ0QsTUFBTzdLLEVBQVAsQ0FDRCxDQTlJRCxDQWdKQTs7Ozs7Ozs7Ozs7O0dBYUFyRyxHQUFHLENBQUM4bkMsNEJBQUosQ0FBbUMsU0FBU242QixHQUFULENBQWN5NUIsV0FBZCxDQUEyQixDQUM1RDtBQUNBLEdBQUkxckIsUUFBTyxDQUFHLEVBQWQsQ0FDQSxHQUFJL2UsT0FBTSxDQUFHLEVBQWIsQ0FDQSxHQUFHLENBQUNxWSxJQUFJLENBQUN3RyxRQUFMLENBQWM3TixHQUFkLENBQW1CbzRCLDZCQUFuQixDQUFrRHJxQixPQUFsRCxDQUEyRC9lLE1BQTNELENBQUosQ0FBd0UsQ0FDdEUsR0FBSW5ELE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLDRDQUNwQixxREFEVSxDQUFaLENBRUFrQyxLQUFLLENBQUNtRCxNQUFOLENBQWVBLE1BQWYsQ0FDQSxLQUFNbkQsTUFBTixDQUNELENBRUQ7QUFDQSxHQUFJMmYsSUFBRyxDQUFHbkUsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDa0ssWUFBdEIsQ0FBVixDQUNBLEdBQUd6TSxHQUFHLEdBQUtuWixHQUFHLENBQUN1YyxJQUFKLENBQVN3SSxhQUFwQixDQUFtQyxDQUNqQyxLQUFNLElBQUl6dEIsTUFBSixDQUFVLHlDQUFWLENBQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSTB3QyxJQUFHLENBQUdob0MsR0FBRyxDQUFDeXRDLDBCQUFKLEVBQVYsQ0FDQXpGLEdBQUcsQ0FBQzNjLE9BQUosQ0FBYzNQLE9BQU8sQ0FBQ2d5QixVQUFSLENBQXFCaHlCLE9BQU8sQ0FBQ2d5QixVQUFSLENBQW1COWxDLFVBQW5CLENBQThCLENBQTlCLENBQXJCLENBQXdELENBQXRFLENBQ0FvZ0MsR0FBRyxDQUFDSSxZQUFKLENBQW1COW9DLEtBQUssQ0FBQzBWLElBQU4sQ0FBV3NFLFFBQVgsQ0FBb0JvQyxPQUFPLENBQUNpeUIsZUFBNUIsQ0FBbkIsQ0FDQTNGLEdBQUcsQ0FBQ2dDLG1CQUFKLENBQTBCckQsd0JBQXdCLENBQ2hEcUIsR0FBRyxDQUFDSSxZQUQ0QyxDQUM5QjFzQixPQUFPLENBQUNreUIsa0JBRHNCLENBQ0YsSUFERSxDQUFsRCxDQUVBNUYsR0FBRyxDQUFDSyxPQUFKLENBQVl4QixZQUFaLENBQTJCdm5DLEtBQUssQ0FBQzBWLElBQU4sQ0FBV3NFLFFBQVgsQ0FBb0JvQyxPQUFPLENBQUNpeUIsZUFBNUIsQ0FBM0IsQ0FDQTNGLEdBQUcsQ0FBQ0ssT0FBSixDQUFZNWMsVUFBWixDQUF5QmtiLHdCQUF3QixDQUMvQ3FCLEdBQUcsQ0FBQ0ssT0FBSixDQUFZeEIsWUFEbUMsQ0FDckJuckIsT0FBTyxDQUFDa3lCLGtCQURhLENBQ08sS0FEUCxDQUFqRCxDQUVBNUYsR0FBRyxDQUFDdmpCLFNBQUosQ0FBZ0IvSSxPQUFPLENBQUNteUIsWUFBeEIsQ0FFQTtBQUNBN0YsR0FBRyxDQUFDOEYsd0JBQUosQ0FBK0JweUIsT0FBTyxDQUFDb3lCLHdCQUF2QyxDQUVBLEdBQUcxRyxXQUFILENBQWdCLENBQ2Q7QUFDQVksR0FBRyxDQUFDcnJCLEVBQUosQ0FBUyxJQUFULENBQ0EsR0FBR3FyQixHQUFHLENBQUNJLFlBQUosR0FBb0I3ckIsS0FBdkIsQ0FBNkIsQ0FDM0IsR0FBSXBELElBQUcsQ0FBR29ELElBQUksQ0FBQ3lyQixHQUFHLENBQUNJLFlBQUwsQ0FBZCxDQUNBLE9BQU9qdkIsR0FBUCxFQUNBLElBQUssdUJBQUwsQ0FDRTZ1QixHQUFHLENBQUNyckIsRUFBSixDQUFTcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTbVMsSUFBVCxDQUFjLzBCLE1BQWQsRUFBVCxDQUNBLE1BQ0YsSUFBSyxzQkFBTCxDQUNFaXVDLEdBQUcsQ0FBQ3JyQixFQUFKLENBQVNyZCxLQUFLLENBQUNxZCxFQUFOLENBQVM2VCxHQUFULENBQWF6MkIsTUFBYixFQUFULENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0VpdUMsR0FBRyxDQUFDcnJCLEVBQUosQ0FBU3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU2EsTUFBVCxDQUFnQnpqQixNQUFoQixFQUFULENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0VpdUMsR0FBRyxDQUFDcnJCLEVBQUosQ0FBU3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU210QixNQUFULENBQWdCL3ZDLE1BQWhCLEVBQVQsQ0FDQSxNQUNGLElBQUsseUJBQUwsQ0FDRWl1QyxHQUFHLENBQUNyckIsRUFBSixDQUFTcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTZ1UsTUFBVCxDQUFnQjUyQixNQUFoQixFQUFULENBQ0EsTUFDRixJQUFLLFlBQUwsQ0FDRWl1QyxHQUFHLENBQUNyckIsRUFBSixDQUFTcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTYSxNQUFULENBQWdCempCLE1BQWhCLEVBQVQsQ0FDQSxNQWxCRixDQW9CRCxDQUNELEdBQUdpdUMsR0FBRyxDQUFDcnJCLEVBQUosR0FBVyxJQUFkLENBQW9CLENBQ2xCLEdBQUluakIsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsbURBQ3BCLHdCQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQzR1QyxZQUFOLENBQXFCSixHQUFHLENBQUNJLFlBQXpCLENBQ0EsS0FBTTV1QyxNQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlxTixNQUFLLENBQUdtTyxJQUFJLENBQUMrRCxLQUFMLENBQVdpdkIsR0FBRyxDQUFDOEYsd0JBQWYsQ0FBWixDQUNBOUYsR0FBRyxDQUFDcnJCLEVBQUosQ0FBT3JKLE1BQVAsQ0FBY3pNLEtBQUssQ0FBQ2EsUUFBTixFQUFkLEVBQ0QsQ0FFRDtBQUNBLEdBQUkrakMsSUFBRyxDQUFHbnNDLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU21TLElBQVQsQ0FBYy8wQixNQUFkLEVBQVYsQ0FDQWl1QyxHQUFHLENBQUNjLE9BQUosQ0FBWUosUUFBWixDQUF1QixTQUFTQyxFQUFULENBQWEsQ0FDbEMsTUFBT2pDLGNBQWEsQ0FBQ3NCLEdBQUcsQ0FBQ2MsT0FBTCxDQUFjSCxFQUFkLENBQXBCLENBQ0QsQ0FGRCxDQUdBWCxHQUFHLENBQUNjLE9BQUosQ0FBWUYsUUFBWixDQUF1QixTQUFTbmtDLElBQVQsQ0FBZSxDQUNwQ29rQyxrQkFBa0IsQ0FBQyxDQUFDcGtDLElBQUQsQ0FBRCxDQUFsQixDQUNBdWpDLEdBQUcsQ0FBQ2MsT0FBSixDQUFZaGtDLFVBQVosQ0FBdUJWLElBQXZCLENBQTRCSyxJQUE1QixFQUNELENBSEQsQ0FJQXVqQyxHQUFHLENBQUNjLE9BQUosQ0FBWWhrQyxVQUFaLENBQXlCOUUsR0FBRyxDQUFDZ21DLG9CQUFKLENBQ3ZCdHFCLE9BQU8sQ0FBQ3F5QiwrQkFEZSxDQUNrQnRDLEdBRGxCLENBQXpCLENBRUF6RCxHQUFHLENBQUNjLE9BQUosQ0FBWWhxQyxJQUFaLENBQW1CMnNDLEdBQUcsQ0FBQ2xzQixNQUFKLEdBQWF0VyxLQUFiLEVBQW5CLENBRUE7QUFDQSsrQixHQUFHLENBQUM5bkMsU0FBSixDQUFnQkYsR0FBRyxDQUFDMmxCLGlCQUFKLENBQXNCakssT0FBTyxDQUFDb3dCLG9CQUE5QixDQUFoQixDQUVBO0FBQ0E5RCxHQUFHLENBQUNnRyxZQUFKLENBQW1CLFNBQVNyRixFQUFULENBQWEsQ0FDOUIsTUFBT2pDLGNBQWEsQ0FBQ3NCLEdBQUQsQ0FBTVcsRUFBTixDQUFwQixDQUNELENBRkQsQ0FHQVgsR0FBRyxDQUFDaUcsWUFBSixDQUFtQixTQUFTeHBDLElBQVQsQ0FBZSxDQUNoQ29rQyxrQkFBa0IsQ0FBQyxDQUFDcGtDLElBQUQsQ0FBRCxDQUFsQixDQUNBdWpDLEdBQUcsQ0FBQ2xqQyxVQUFKLENBQWVWLElBQWYsQ0FBb0JLLElBQXBCLEVBQ0QsQ0FIRCxDQUlBdWpDLEdBQUcsQ0FBQ2xqQyxVQUFKLENBQWlCOUUsR0FBRyxDQUFDcW1DLG9CQUFKLENBQ2YzcUIsT0FBTyxDQUFDd3lCLGtDQUFSLEVBQThDLEVBRC9CLENBQWpCLENBR0EsTUFBT2xHLElBQVAsQ0FDRCxDQWpHRCxDQW1HQTs7Ozs7O0dBT0Fob0MsR0FBRyxDQUFDeXRDLDBCQUFKLENBQWlDLFVBQVcsQ0FDMUMsR0FBSXpGLElBQUcsQ0FBRyxFQUFWLENBQ0FBLEdBQUcsQ0FBQzNjLE9BQUosQ0FBYyxJQUFkLENBQ0EyYyxHQUFHLENBQUNJLFlBQUosQ0FBbUIsSUFBbkIsQ0FDQUosR0FBRyxDQUFDdmpCLFNBQUosQ0FBZ0IsSUFBaEIsQ0FDQXVqQixHQUFHLENBQUNLLE9BQUosQ0FBYyxFQUFkLENBQ0FMLEdBQUcsQ0FBQ0ssT0FBSixDQUFZeEIsWUFBWixDQUEyQixJQUEzQixDQUVBbUIsR0FBRyxDQUFDYyxPQUFKLENBQWMsRUFBZCxDQUNBZCxHQUFHLENBQUNjLE9BQUosQ0FBWUosUUFBWixDQUF1QixTQUFTQyxFQUFULENBQWEsQ0FDbEMsTUFBT2pDLGNBQWEsQ0FBQ3NCLEdBQUcsQ0FBQ2MsT0FBTCxDQUFjSCxFQUFkLENBQXBCLENBQ0QsQ0FGRCxDQUdBWCxHQUFHLENBQUNjLE9BQUosQ0FBWUYsUUFBWixDQUF1QixTQUFTbmtDLElBQVQsQ0FBZSxDQUNwQ29rQyxrQkFBa0IsQ0FBQyxDQUFDcGtDLElBQUQsQ0FBRCxDQUFsQixDQUNBdWpDLEdBQUcsQ0FBQ2MsT0FBSixDQUFZaGtDLFVBQVosQ0FBdUJWLElBQXZCLENBQTRCSyxJQUE1QixFQUNELENBSEQsQ0FJQXVqQyxHQUFHLENBQUNjLE9BQUosQ0FBWWhrQyxVQUFaLENBQXlCLEVBQXpCLENBQ0FrakMsR0FBRyxDQUFDYyxPQUFKLENBQVlocUMsSUFBWixDQUFtQixJQUFuQixDQUVBa3BDLEdBQUcsQ0FBQzluQyxTQUFKLENBQWdCLElBQWhCLENBQ0E4bkMsR0FBRyxDQUFDbGpDLFVBQUosQ0FBaUIsRUFBakIsQ0FDQWtqQyxHQUFHLENBQUNnRyxZQUFKLENBQW1CLFNBQVNyRixFQUFULENBQWEsQ0FDOUIsTUFBT2pDLGNBQWEsQ0FBQ3NCLEdBQUQsQ0FBTVcsRUFBTixDQUFwQixDQUNELENBRkQsQ0FHQVgsR0FBRyxDQUFDaUcsWUFBSixDQUFtQixTQUFTeHBDLElBQVQsQ0FBZSxDQUNoQ29rQyxrQkFBa0IsQ0FBQyxDQUFDcGtDLElBQUQsQ0FBRCxDQUFsQixDQUNBdWpDLEdBQUcsQ0FBQ2xqQyxVQUFKLENBQWVWLElBQWYsQ0FBb0JLLElBQXBCLEVBQ0QsQ0FIRCxDQUlBdWpDLEdBQUcsQ0FBQ3JyQixFQUFKLENBQVMsSUFBVCxDQUVBOzs7O0tBS0FxckIsR0FBRyxDQUFDZSxVQUFKLENBQWlCLFNBQVNDLEtBQVQsQ0FBZ0IsQ0FDL0I7QUFDQUgsa0JBQWtCLENBQUNHLEtBQUQsQ0FBbEIsQ0FDQWhCLEdBQUcsQ0FBQ2MsT0FBSixDQUFZaGtDLFVBQVosQ0FBeUJra0MsS0FBekIsQ0FDQWhCLEdBQUcsQ0FBQ2MsT0FBSixDQUFZaHFDLElBQVosQ0FBbUIsSUFBbkIsQ0FDRCxDQUxELENBT0E7Ozs7S0FLQWtwQyxHQUFHLENBQUNtRyxhQUFKLENBQW9CLFNBQVNuRixLQUFULENBQWdCLENBQ2xDO0FBQ0FILGtCQUFrQixDQUFDRyxLQUFELENBQWxCLENBQ0FoQixHQUFHLENBQUNsakMsVUFBSixDQUFpQmtrQyxLQUFqQixDQUNELENBSkQsQ0FNQTs7Ozs7S0FNQWhCLEdBQUcsQ0FBQ3BqQixJQUFKLENBQVcsU0FBU3JyQixHQUFULENBQWNvakIsRUFBZCxDQUFrQixDQUMzQjtBQUNBcXJCLEdBQUcsQ0FBQ3JyQixFQUFKLENBQVNBLEVBQUUsRUFBSXJkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU21TLElBQVQsQ0FBYy8wQixNQUFkLEVBQWYsQ0FDQSxHQUFJOHNDLGFBQVksQ0FBR3RxQixJQUFJLENBQUN5ckIsR0FBRyxDQUFDcnJCLEVBQUosQ0FBT3dDLFNBQVAsQ0FBbUIsbUJBQXBCLENBQXZCLENBQ0EsR0FBRyxDQUFDMG5CLFlBQUosQ0FBa0IsQ0FDaEIsR0FBSXJ0QyxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxtREFDcEIsdUNBRFUsQ0FBWixDQUVBa0MsS0FBSyxDQUFDMmxCLFNBQU4sQ0FBa0I2b0IsR0FBRyxDQUFDcnJCLEVBQUosQ0FBT3dDLFNBQXpCLENBQ0EsS0FBTTNsQixNQUFOLENBQ0QsQ0FDRHd1QyxHQUFHLENBQUNJLFlBQUosQ0FBbUJKLEdBQUcsQ0FBQ0ssT0FBSixDQUFZeEIsWUFBWixDQUEyQkEsWUFBOUMsQ0FFQTtBQUNBbUIsR0FBRyxDQUFDOEYsd0JBQUosQ0FBK0I5dEMsR0FBRyxDQUFDb3VDLDJCQUFKLENBQWdDcEcsR0FBaEMsQ0FBL0IsQ0FDQSxHQUFJbmhDLE1BQUssQ0FBR21PLElBQUksQ0FBQytELEtBQUwsQ0FBV2l2QixHQUFHLENBQUM4Rix3QkFBZixDQUFaLENBRUE7QUFDQTlGLEdBQUcsQ0FBQ3JyQixFQUFKLENBQU9ySixNQUFQLENBQWN6TSxLQUFLLENBQUNhLFFBQU4sRUFBZCxFQUNBc2dDLEdBQUcsQ0FBQ3ZqQixTQUFKLENBQWdCbHJCLEdBQUcsQ0FBQ3FyQixJQUFKLENBQVNvakIsR0FBRyxDQUFDcnJCLEVBQWIsQ0FBaEIsQ0FDRCxDQW5CRCxDQXFCQTs7Ozs7Ozs7OztLQVdBcXJCLEdBQUcsQ0FBQ3hqQixNQUFKLENBQWEsVUFBVyxDQUN0QixHQUFJMWMsS0FBSSxDQUFHLEtBQVgsQ0FFQSxHQUFJNlUsR0FBRSxDQUFHcXJCLEdBQUcsQ0FBQ3JyQixFQUFiLENBQ0EsR0FBR0EsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDZDtBQUNBLEdBQUdxckIsR0FBRyxDQUFDSSxZQUFKLEdBQW9CN3JCLEtBQXZCLENBQTZCLENBQzNCO0FBQ0EsR0FBSXBELElBQUcsQ0FBR29ELElBQUksQ0FBQ3lyQixHQUFHLENBQUNJLFlBQUwsQ0FBZCxDQUNBLE9BQU9qdkIsR0FBUCxFQUNBLElBQUssdUJBQUwsQ0FDRXdELEVBQUUsQ0FBR3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU21TLElBQVQsQ0FBYy8wQixNQUFkLEVBQUwsQ0FDQSxNQUNGLElBQUssc0JBQUwsQ0FDRTRpQixFQUFFLENBQUdyZCxLQUFLLENBQUNxZCxFQUFOLENBQVM2VCxHQUFULENBQWF6MkIsTUFBYixFQUFMLENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0U0aUIsRUFBRSxDQUFHcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTYSxNQUFULENBQWdCempCLE1BQWhCLEVBQUwsQ0FDQSxNQUNGLElBQUsseUJBQUwsQ0FDRTRpQixFQUFFLENBQUdyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNtdEIsTUFBVCxDQUFnQi92QyxNQUFoQixFQUFMLENBQ0EsTUFDRixJQUFLLHlCQUFMLENBQ0U0aUIsRUFBRSxDQUFHcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTZ1UsTUFBVCxDQUFnQjUyQixNQUFoQixFQUFMLENBQ0EsTUFDRixJQUFLLFlBQUwsQ0FDRTRpQixFQUFFLENBQUdyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNhLE1BQVQsQ0FBZ0J6akIsTUFBaEIsRUFBTCxDQUNBLE1BbEJGLENBb0JELENBQ0QsR0FBRzRpQixFQUFFLEdBQUssSUFBVixDQUFnQixDQUNkLEdBQUluakIsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsbURBQ3BCLHdCQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQzR1QyxZQUFOLENBQXFCSixHQUFHLENBQUNJLFlBQXpCLENBQ0EsS0FBTTV1QyxNQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUk2MEMsSUFBRyxDQUFHckcsR0FBRyxDQUFDOEYsd0JBQUosRUFDUjl0QyxHQUFHLENBQUNvdUMsMkJBQUosQ0FBZ0NwRyxHQUFoQyxDQURGLENBRUEsR0FBSW5oQyxNQUFLLENBQUdtTyxJQUFJLENBQUMrRCxLQUFMLENBQVdzMUIsR0FBWCxDQUFaLENBQ0ExeEIsRUFBRSxDQUFDckosTUFBSCxDQUFVek0sS0FBSyxDQUFDYSxRQUFOLEVBQVYsRUFDRCxDQUVELEdBQUdpVixFQUFFLEdBQUssSUFBVixDQUFnQixDQUNkLEdBQUkzTixPQUFKLENBRUEsT0FBT2c1QixHQUFHLENBQUNJLFlBQVgsRUFDQSxJQUFLN3JCLEtBQUksQ0FBQ3d0QixxQkFBVixDQUNFLG9DQUNBLE1BQ0YsSUFBS3h0QixLQUFJLENBQUMsWUFBRCxDQUFULENBQ0UsR0FBSXpkLEtBQUosQ0FBVWdvQyxHQUFWLENBRUEsb0JBQ0Fob0MsSUFBSSxDQUFHeWQsSUFBSSxDQUFDeXJCLEdBQUcsQ0FBQ2dDLG1CQUFKLENBQXdCbEQsR0FBeEIsQ0FBNEJob0MsSUFBNUIsQ0FBaUMrbkMsWUFBbEMsQ0FBWCxDQUNBLEdBQUcvbkMsSUFBSSxHQUFLeUUsU0FBVCxFQUFzQmpFLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBUzdkLElBQVQsSUFBbUJ5RSxTQUE1QyxDQUF1RCxDQUNyRCxHQUFJL0osTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsZ0NBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDMmYsR0FBTixDQUFZNnVCLEdBQUcsQ0FBQ2dDLG1CQUFKLENBQXdCbEQsR0FBeEIsQ0FBNEJob0MsSUFBNUIsQ0FBaUMrbkMsWUFBN0MsQ0FDQXJ0QyxLQUFLLENBQUMwRSxJQUFOLENBQWFZLElBQWIsQ0FDQSxLQUFNdEYsTUFBTixDQUNELENBRURzdEMsR0FBRyxDQUFHdnFCLElBQUksQ0FBQ3lyQixHQUFHLENBQUNnQyxtQkFBSixDQUF3QmxELEdBQXhCLENBQTRCRCxZQUE3QixDQUFWLENBQ0EsR0FBR0MsR0FBRyxHQUFLdmpDLFNBQVIsRUFBcUJqRSxLQUFLLENBQUN3bkMsR0FBTixDQUFVQSxHQUFWLElBQW1CdmpDLFNBQTNDLENBQXNELENBQ3BELEdBQUkvSixNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSwyQkFBVixDQUFaLENBQ0FrQyxLQUFLLENBQUMyZixHQUFOLENBQVk2dUIsR0FBRyxDQUFDZ0MsbUJBQUosQ0FBd0JsRCxHQUF4QixDQUE0QkQsWUFBeEMsQ0FDQXJ0QyxLQUFLLENBQUMwRSxJQUFOLENBQWE0b0MsR0FBYixDQUNBLEtBQU10dEMsTUFBTixDQUNELENBRURzdEMsR0FBRyxDQUFHeG5DLEtBQUssQ0FBQ3duQyxHQUFOLENBQVVBLEdBQVYsRUFBZS9zQyxNQUFmLENBQXNCdUYsS0FBSyxDQUFDcWQsRUFBTixDQUFTN2QsSUFBVCxFQUFlL0UsTUFBZixFQUF0QixDQUFOLENBRUEsOEJBQ0ErRSxJQUFJLENBQUd5ZCxJQUFJLENBQUN5ckIsR0FBRyxDQUFDZ0MsbUJBQUosQ0FBd0JsckMsSUFBeEIsQ0FBNkIrbkMsWUFBOUIsQ0FBWCxDQUNBLEdBQUcvbkMsSUFBSSxHQUFLeUUsU0FBVCxFQUFzQmpFLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBUzdkLElBQVQsSUFBbUJ5RSxTQUE1QyxDQUF1RCxDQUNyRCxHQUFJL0osTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsdUNBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDMmYsR0FBTixDQUFZNnVCLEdBQUcsQ0FBQ2dDLG1CQUFKLENBQXdCbHJDLElBQXhCLENBQTZCK25DLFlBQXpDLENBQ0FydEMsS0FBSyxDQUFDMEUsSUFBTixDQUFhWSxJQUFiLENBQ0EsS0FBTXRGLE1BQU4sQ0FDRCxDQUVEd1YsTUFBTSxDQUFHMVAsS0FBSyxDQUFDMnFDLEdBQU4sQ0FBVWx3QyxNQUFWLENBQWlCdUYsS0FBSyxDQUFDcWQsRUFBTixDQUFTN2QsSUFBVCxFQUFlL0UsTUFBZixFQUFqQixDQUEwQytzQyxHQUExQyxDQUNQa0IsR0FBRyxDQUFDZ0MsbUJBQUosQ0FBd0JqRCxVQURqQixDQUFULENBRUEsTUFyQ0YsQ0F3Q0E7QUFDQWovQixJQUFJLENBQUdrZ0MsR0FBRyxDQUFDOW5DLFNBQUosQ0FBY3NrQixNQUFkLENBQ0w3SCxFQUFFLENBQUM0QyxNQUFILEdBQVk3WCxRQUFaLEVBREssQ0FDbUJzZ0MsR0FBRyxDQUFDdmpCLFNBRHZCLENBQ2tDelYsTUFEbEMsQ0FBUCxDQUVELENBRUQsTUFBT2xILEtBQVAsQ0FDRCxDQTdGRCxDQStGQSxNQUFPa2dDLElBQVAsQ0FDRCxDQTNMRCxDQTZMQTs7Ozs7O0dBT0EsUUFBU3NHLFVBQVQsQ0FBbUIzZ0MsR0FBbkIsQ0FBd0IsQ0FDdEI7QUFDQSxHQUFJN0YsS0FBSSxDQUFHa04sSUFBSSxDQUFDamIsTUFBTCxDQUNUaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBREYsQ0FDYUYsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBRHZCLENBQ2lDLElBRGpDLENBQ3VDLEVBRHZDLENBQVgsQ0FHQTtBQUNBLEdBQUk1UixLQUFKLENBQVVxRixHQUFWLENBQ0EsR0FBSWsvQixNQUFLLENBQUdyN0IsR0FBRyxDQUFDN0ksVUFBaEIsQ0FDQSxJQUFJLEdBQUlwRCxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdzbkMsS0FBSyxDQUFDeHhDLE1BQXpCLENBQWlDLEVBQUVrSyxDQUFuQyxDQUFzQyxDQUNwQytDLElBQUksQ0FBR3VrQyxLQUFLLENBQUN0bkMsQ0FBRCxDQUFaLENBQ0EsR0FBSXdQLE1BQUssQ0FBR3pNLElBQUksQ0FBQ3lNLEtBQWpCLENBRUE7QUFDQSxHQUFJaTFCLGNBQWEsQ0FBR254QixJQUFJLENBQUNNLElBQUwsQ0FBVWlCLGVBQTlCLENBQ0EsR0FBRyxpQkFBbUI5UixLQUF0QixDQUE0QixDQUMxQjBoQyxhQUFhLENBQUcxaEMsSUFBSSxDQUFDMGhDLGFBQXJCLENBRUEsR0FBR0EsYUFBYSxHQUFLbnhCLElBQUksQ0FBQ00sSUFBTCxDQUFVYSxJQUEvQixDQUFxQyxDQUNuQ2pGLEtBQUssQ0FBRzVSLEtBQUssQ0FBQzJELElBQU4sQ0FBVytELFVBQVgsQ0FBc0JrSyxLQUF0QixDQUFSLENBQ0QsQ0FDRDtBQUNELENBRUQ7QUFDQTtBQUNBO0FBQ0FwSCxHQUFHLENBQUdrTCxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FBNUMsQ0FBaUQsSUFBakQsQ0FBdUQsQ0FDM0R0QixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjelUsSUFBSSxDQUFDNEosSUFBbkIsRUFBeUIzRyxRQUF6QixFQURGLENBRjBELENBSTFEO0FBQ0FzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NpeEIsYUFBbEMsQ0FBaUQsS0FBakQsQ0FBd0RqMUIsS0FBeEQsQ0FMMEQsQ0FBNUQsQ0FEMkQsQ0FBdkQsQ0FBTixDQVNBcEosSUFBSSxDQUFDb0osS0FBTCxDQUFXOU0sSUFBWCxDQUFnQjBGLEdBQWhCLEVBQ0QsQ0FFRCxNQUFPaEMsS0FBUCxDQUNELENBRUQ7Ozs7Ozs7R0FRQSxRQUFTeW1DLHFCQUFULENBQThCdkYsS0FBOUIsQ0FBcUMsQ0FDbkMsR0FBSWxoQyxLQUFJLENBQUcsRUFBWCxDQUNBLElBQUksR0FBSXBHLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3NuQyxLQUFLLENBQUN4eEMsTUFBekIsQ0FBaUMsRUFBRWtLLENBQW5DLENBQXNDLENBQ3BDLEdBQUkrQyxLQUFJLENBQUd1a0MsS0FBSyxDQUFDdG5DLENBQUQsQ0FBaEIsQ0FDQSxHQUFHK0MsSUFBSSxDQUFDMmhDLFNBQUwsR0FDRDNoQyxJQUFJLENBQUMwaEMsYUFBTCxHQUF1Qm54QixJQUFJLENBQUNNLElBQUwsQ0FBVWEsSUFBakMsRUFDQTFSLElBQUksQ0FBQzBoQyxhQUFMLEdBQXVCbnhCLElBQUksQ0FBQ00sSUFBTCxDQUFVaUIsZUFEakMsRUFFQTlSLElBQUksQ0FBQzBoQyxhQUFMLEdBQXVCbnhCLElBQUksQ0FBQ00sSUFBTCxDQUFVa0IsU0FIaEMsQ0FBSCxDQUcrQyxDQUM3QyxHQUFJdEYsTUFBSyxDQUFHek0sSUFBSSxDQUFDeU0sS0FBakIsQ0FDQSxHQUFHek0sSUFBSSxDQUFDMGhDLGFBQUwsR0FBdUJueEIsSUFBSSxDQUFDTSxJQUFMLENBQVVhLElBQXBDLENBQTBDLENBQ3hDakYsS0FBSyxDQUFHNVIsS0FBSyxDQUFDMkQsSUFBTixDQUFXK0QsVUFBWCxDQUFzQnZDLElBQUksQ0FBQ3lNLEtBQTNCLENBQVIsQ0FDRCxDQUNELEdBQUcsRUFBRXpNLElBQUksQ0FBQzJoQyxTQUFMLEdBQWtCdCtCLEtBQXBCLENBQUgsQ0FBOEIsQ0FDNUJBLElBQUksQ0FBQ3JELElBQUksQ0FBQzJoQyxTQUFOLENBQUosQ0FBdUJsMUIsS0FBdkIsQ0FDRCxDQUZELElBRU8sSUFBRzVSLEtBQUssQ0FBQzJELElBQU4sQ0FBV21DLE9BQVgsQ0FBbUIwQyxJQUFJLENBQUNyRCxJQUFJLENBQUMyaEMsU0FBTixDQUF2QixDQUFILENBQTZDLENBQ2xEdCtCLElBQUksQ0FBQ3JELElBQUksQ0FBQzJoQyxTQUFOLENBQUosQ0FBcUJoaUMsSUFBckIsQ0FBMEI4TSxLQUExQixFQUNELENBRk0sSUFFQSxDQUNMcEosSUFBSSxDQUFDckQsSUFBSSxDQUFDMmhDLFNBQU4sQ0FBSixDQUF1QixDQUFDdCtCLElBQUksQ0FBQ3JELElBQUksQ0FBQzJoQyxTQUFOLENBQUwsQ0FBdUJsMUIsS0FBdkIsQ0FBdkIsQ0FDRCxDQUNGLENBQ0YsQ0FDRCxNQUFPcEosS0FBUCxDQUNELENBRUQ7Ozs7R0FLQSxRQUFTK2dDLG1CQUFULENBQTRCRyxLQUE1QixDQUFtQyxDQUNqQyxHQUFJdmtDLEtBQUosQ0FDQSxJQUFJLEdBQUkvQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdzbkMsS0FBSyxDQUFDeHhDLE1BQXpCLENBQWlDLEVBQUVrSyxDQUFuQyxDQUFzQyxDQUNwQytDLElBQUksQ0FBR3VrQyxLQUFLLENBQUN0bkMsQ0FBRCxDQUFaLENBRUE7QUFDQSxHQUFHLE1BQU8rQyxLQUFJLENBQUN2RyxJQUFaLEdBQXFCLFdBQXhCLENBQXFDLENBQ25DLEdBQUd1RyxJQUFJLENBQUM0SixJQUFMLEVBQWE1SixJQUFJLENBQUM0SixJQUFMLEdBQWFyTyxJQUFHLENBQUN1YyxJQUFqQyxDQUF1QyxDQUNyQzlYLElBQUksQ0FBQ3ZHLElBQUwsQ0FBWThCLEdBQUcsQ0FBQ3VjLElBQUosQ0FBUzlYLElBQUksQ0FBQzRKLElBQWQsQ0FBWixDQUNELENBRkQsSUFFTyxJQUFHNUosSUFBSSxDQUFDMmhDLFNBQUwsRUFBa0IzaEMsSUFBSSxDQUFDMmhDLFNBQUwsR0FBa0JULFlBQXZDLENBQW9ELENBQ3pEbGhDLElBQUksQ0FBQ3ZHLElBQUwsQ0FBWThCLEdBQUcsQ0FBQ3VjLElBQUosQ0FBU29wQixXQUFXLENBQUNsaEMsSUFBSSxDQUFDMmhDLFNBQU4sQ0FBcEIsQ0FBWixDQUNELENBQ0YsQ0FFRDtBQUNBLEdBQUcsTUFBTzNoQyxLQUFJLENBQUM0SixJQUFaLEdBQXFCLFdBQXhCLENBQXFDLENBQ25DLEdBQUc1SixJQUFJLENBQUN2RyxJQUFMLEVBQWF1RyxJQUFJLENBQUN2RyxJQUFMLEdBQWE4QixJQUFHLENBQUN1YyxJQUFqQyxDQUF1QyxDQUNyQzlYLElBQUksQ0FBQzRKLElBQUwsQ0FBWXJPLEdBQUcsQ0FBQ3VjLElBQUosQ0FBUzlYLElBQUksQ0FBQ3ZHLElBQWQsQ0FBWixDQUNELENBRkQsSUFFTyxDQUNMLEdBQUkxRSxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSwrQkFBVixDQUFaLENBQ0FrQyxLQUFLLENBQUNnMUMsU0FBTixDQUFrQi9wQyxJQUFsQixDQUNBLEtBQU1qTCxNQUFOLENBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBRyxNQUFPaUwsS0FBSSxDQUFDMmhDLFNBQVosR0FBMEIsV0FBN0IsQ0FBMEMsQ0FDeEMsR0FBRzNoQyxJQUFJLENBQUN2RyxJQUFMLEVBQWF1RyxJQUFJLENBQUN2RyxJQUFMLEdBQWF5bkMsWUFBN0IsQ0FBMEMsQ0FDeENsaEMsSUFBSSxDQUFDMmhDLFNBQUwsQ0FBaUJULFdBQVcsQ0FBQ2xoQyxJQUFJLENBQUN2RyxJQUFOLENBQTVCLENBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBR3VHLElBQUksQ0FBQzRKLElBQUwsR0FBY2tPLElBQUksQ0FBQ2dxQixnQkFBdEIsQ0FBd0MsQ0FDdEM5aEMsSUFBSSxDQUFDZ3FDLGdCQUFMLENBQXdCLElBQXhCLENBQ0FocUMsSUFBSSxDQUFDMGhDLGFBQUwsQ0FBcUJueEIsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQS9CLENBQ0EsR0FBRyxDQUFDNVIsSUFBSSxDQUFDeU0sS0FBTixFQUFlek0sSUFBSSxDQUFDK2hDLFVBQXZCLENBQW1DLENBQ2pDL2hDLElBQUksQ0FBQ3lNLEtBQUwsQ0FBYSxFQUFiLENBQ0EsSUFBSSxHQUFJc1ksR0FBRSxDQUFHLENBQWIsQ0FBZ0JBLEVBQUUsQ0FBRy9rQixJQUFJLENBQUMraEMsVUFBTCxDQUFnQmh2QyxNQUFyQyxDQUE2QyxFQUFFZ3lCLEVBQS9DLENBQW1ELENBQ2pEL2tCLElBQUksQ0FBQ3lNLEtBQUwsQ0FBVzlNLElBQVgsQ0FBZ0JwRSxHQUFHLENBQUMwdUMsMEJBQUosQ0FDZHJGLDJCQUEyQixDQUFDNWtDLElBQUksQ0FBQytoQyxVQUFMLENBQWdCaGQsRUFBaEIsQ0FBRCxDQURiLENBQWhCLEVBRUQsQ0FDRixDQUNGLENBRUQsR0FBRyxNQUFPL2tCLEtBQUksQ0FBQ3lNLEtBQVosR0FBc0IsV0FBekIsQ0FBc0MsQ0FDcEMsR0FBSTFYLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLGdDQUFWLENBQVosQ0FDQWtDLEtBQUssQ0FBQ2cxQyxTQUFOLENBQWtCL3BDLElBQWxCLENBQ0EsS0FBTWpMLE1BQU4sQ0FDRCxDQUNGLENBQ0YsQ0FFRDs7Ozs7Ozs7R0FTQSxRQUFTNnZDLDRCQUFULENBQXFDaGpDLENBQXJDLENBQXdDeFAsT0FBeEMsQ0FBaUQsQ0FDL0NBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBRUE7QUFDQSxHQUFHLE1BQU93UCxFQUFDLENBQUNuSSxJQUFULEdBQWtCLFdBQXJCLENBQWtDLENBQ2hDLEdBQUdtSSxDQUFDLENBQUNxSCxFQUFGLEVBQVFySCxDQUFDLENBQUNxSCxFQUFGLEdBQVExTixJQUFHLENBQUN1YyxJQUF2QixDQUE2QixDQUMzQmxXLENBQUMsQ0FBQ25JLElBQUYsQ0FBUzhCLEdBQUcsQ0FBQ3VjLElBQUosQ0FBU2xXLENBQUMsQ0FBQ3FILEVBQVgsQ0FBVCxDQUNELENBQ0YsQ0FFRDtBQUNBLEdBQUcsTUFBT3JILEVBQUMsQ0FBQ3FILEVBQVQsR0FBZ0IsV0FBbkIsQ0FBZ0MsQ0FDOUIsR0FBR3JILENBQUMsQ0FBQ25JLElBQUYsRUFBVW1JLENBQUMsQ0FBQ25JLElBQUYsR0FBVThCLElBQUcsQ0FBQ3VjLElBQTNCLENBQWlDLENBQy9CbFcsQ0FBQyxDQUFDcUgsRUFBRixDQUFPMU4sR0FBRyxDQUFDdWMsSUFBSixDQUFTbFcsQ0FBQyxDQUFDbkksSUFBWCxDQUFQLENBQ0QsQ0FGRCxJQUVPLENBQ0wsR0FBSTFFLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLDZCQUFWLENBQVosQ0FDQWtDLEtBQUssQ0FBQ20xQyxTQUFOLENBQWtCdG9DLENBQWxCLENBQ0EsS0FBTTdNLE1BQU4sQ0FDRCxDQUNGLENBRUQsR0FBRyxNQUFPNk0sRUFBQyxDQUFDNkssS0FBVCxHQUFtQixXQUF0QixDQUFtQyxDQUNqQyxNQUFPN0ssRUFBUCxDQUNELENBRUQ7QUFFQTtBQUNBLEdBQUdBLENBQUMsQ0FBQ25JLElBQUYsR0FBVyxVQUFkLENBQTBCLENBQ3hCO0FBQ0EsR0FBSXVhLE9BQU0sQ0FBRyxDQUFiLENBQ0EsR0FBSWhCLEdBQUUsQ0FBRyxJQUFULENBQ0EsR0FBSXkwQixHQUFFLENBQUcsSUFBVCxDQUNBLEdBQUc3bEMsQ0FBQyxDQUFDOGxDLGdCQUFMLENBQXVCLENBQ3JCMTBCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBQ0QsR0FBR3BTLENBQUMsQ0FBQytsQyxjQUFMLENBQXFCLENBQ25CMzBCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBQ0QsR0FBR3BTLENBQUMsQ0FBQ2dtQyxlQUFMLENBQXNCLENBQ3BCNTBCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBQ0QsR0FBR3BTLENBQUMsQ0FBQ2ltQyxnQkFBTCxDQUF1QixDQUNyQjcwQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUdwUyxDQUFDLENBQUNrbUMsWUFBTCxDQUFtQixDQUNqQjkwQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUdwUyxDQUFDLENBQUNtbUMsV0FBTCxDQUFrQixDQUNoQi8wQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUdwUyxDQUFDLENBQUNvbUMsT0FBTCxDQUFjLENBQ1poMUIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHcFMsQ0FBQyxDQUFDcW1DLFlBQUwsQ0FBbUIsQ0FDakJqMUIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHcFMsQ0FBQyxDQUFDc21DLFlBQUwsQ0FBbUIsQ0FDakJULEVBQUUsRUFBSSxJQUFOLENBQ0F6ekIsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUVEO0FBQ0EsR0FBSXZILE1BQUssQ0FBRy9LLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQnFTLE1BQXBCLENBQVosQ0FDQSxHQUFHeXpCLEVBQUUsR0FBSyxDQUFWLENBQWEsQ0FDWGg3QixLQUFLLEVBQUkvSyxNQUFNLENBQUNDLFlBQVAsQ0FBb0JxUixFQUFwQixFQUEwQnRSLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQjhsQyxFQUFwQixDQUFuQyxDQUNELENBRkQsSUFFTyxJQUFHejBCLEVBQUUsR0FBSyxDQUFWLENBQWEsQ0FDbEJ2RyxLQUFLLEVBQUkvSyxNQUFNLENBQUNDLFlBQVAsQ0FBb0JxUixFQUFwQixDQUFULENBQ0QsQ0FDRHBSLENBQUMsQ0FBQzZLLEtBQUYsQ0FBVThELElBQUksQ0FBQ2piLE1BQUwsQ0FDUmliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURILENBQ2NGLElBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUR4QixDQUNtQyxLQURuQyxDQUMwQ3hFLEtBRDFDLENBQVYsQ0FFRCxDQW5ERCxJQW1ETyxJQUFHN0ssQ0FBQyxDQUFDbkksSUFBRixHQUFXLGtCQUFkLENBQWtDLENBQ3ZDO0FBQ0FtSSxDQUFDLENBQUM2SyxLQUFGLENBQVU4RCxJQUFJLENBQUNqYixNQUFMLENBQ1JpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FESCxDQUNjRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFEeEIsQ0FDa0MsSUFEbEMsQ0FDd0MsRUFEeEMsQ0FBVixDQUVBO0FBQ0EsR0FBR2hRLENBQUMsQ0FBQ3VtQyxFQUFMLENBQVMsQ0FDUHZtQyxDQUFDLENBQUM2SyxLQUFGLENBQVFBLEtBQVIsQ0FBYzlNLElBQWQsQ0FBbUI0USxJQUFJLENBQUNqYixNQUFMLENBQ2pCaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRE0sQ0FDS0YsSUFBSSxDQUFDTSxJQUFMLENBQVVFLE9BRGYsQ0FDd0IsS0FEeEIsQ0FFakJyUCxNQUFNLENBQUNDLFlBQVAsQ0FBb0IsSUFBcEIsQ0FGaUIsQ0FBbkIsRUFHRCxDQUNELEdBQUcscUJBQXVCQyxFQUExQixDQUE2QixDQUMzQkEsQ0FBQyxDQUFDNkssS0FBRixDQUFRQSxLQUFSLENBQWM5TSxJQUFkLENBQW1CNFEsSUFBSSxDQUFDamIsTUFBTCxDQUNqQmliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURNLENBQ0tGLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQURmLENBQ3dCLEtBRHhCLENBRWpCVCxJQUFJLENBQUNxRyxZQUFMLENBQWtCaFYsQ0FBQyxDQUFDd21DLGlCQUFwQixFQUF1Q25sQyxRQUF2QyxFQUZpQixDQUFuQixFQUdELENBQ0YsQ0FmTSxJQWVBLElBQUdyQixDQUFDLENBQUNuSSxJQUFGLEdBQVcsYUFBZCxDQUE2QixDQUNsQztBQUNBbUksQ0FBQyxDQUFDNkssS0FBRixDQUFVOEQsSUFBSSxDQUFDamIsTUFBTCxDQUNSaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBREgsQ0FDY0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBRHhCLENBQ2tDLElBRGxDLENBQ3dDLEVBRHhDLENBQVYsQ0FFQSxHQUFJaXdCLElBQUcsQ0FBR2pnQyxDQUFDLENBQUM2SyxLQUFGLENBQVFBLEtBQWxCLENBQ0EsSUFBSSxHQUFJM1gsSUFBUixHQUFlOE0sRUFBZixDQUFrQixDQUNoQixHQUFHQSxDQUFDLENBQUM5TSxHQUFELENBQUQsR0FBVyxJQUFkLENBQW9CLENBQ2xCLFNBQ0QsQ0FDRDtBQUNBLEdBQUdBLEdBQUcsR0FBSWdqQixLQUFWLENBQWdCLENBQ2QrcEIsR0FBRyxDQUFDbGlDLElBQUosQ0FBUzRRLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQ1AsS0FETyxDQUNBYixJQUFJLENBQUNrRSxRQUFMLENBQWNxRCxJQUFJLENBQUNoakIsR0FBRCxDQUFsQixFQUF5Qm1PLFFBQXpCLEVBREEsQ0FBVCxFQUVELENBSEQsSUFHTyxJQUFHbk8sR0FBRyxDQUFDb1csT0FBSixDQUFZLEdBQVosSUFBcUIsQ0FBQyxDQUF6QixDQUE0QixDQUNqQztBQUNBMjJCLEdBQUcsQ0FBQ2xpQyxJQUFKLENBQVM0USxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUNQLEtBRE8sQ0FDQWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjM2YsR0FBZCxFQUFtQm1PLFFBQW5CLEVBREEsQ0FBVCxFQUVELENBQ0YsQ0FDRixDQW5CTSxJQW1CQSxJQUFHckIsQ0FBQyxDQUFDbkksSUFBRixHQUFXLFlBQWQsQ0FBNEIsQ0FDakM7QUFDQTtBQUNBLEdBQUl1YSxPQUFNLENBQUcsQ0FBYixDQUNBLEdBQUloQixHQUFFLENBQUcsSUFBVCxDQUVBLEdBQUdwUixDQUFDLENBQUN5bUMsTUFBTCxDQUFhLENBQ1hyMUIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHcFMsQ0FBQyxDQUFDMG1DLE1BQUwsQ0FBYSxDQUNYdDFCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBQ0QsR0FBR3BTLENBQUMsQ0FBQzJtQyxLQUFMLENBQVksQ0FDVnYxQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUdwUyxDQUFDLENBQUM0bUMsT0FBTCxDQUFjLENBQ1p4MUIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHcFMsQ0FBQyxDQUFDNm1DLFFBQUwsQ0FBZSxDQUNiejFCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBQ0QsR0FBR3BTLENBQUMsQ0FBQzhtQyxLQUFMLENBQVksQ0FDVjExQixFQUFFLEVBQUksSUFBTixDQUNBZ0IsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNELEdBQUdwUyxDQUFDLENBQUMrbUMsT0FBTCxDQUFjLENBQ1ozMUIsRUFBRSxFQUFJLElBQU4sQ0FDQWdCLE1BQU0sQ0FBRyxDQUFULENBQ0QsQ0FDRCxHQUFHcFMsQ0FBQyxDQUFDZ25DLEtBQUwsQ0FBWSxDQUNWNTFCLEVBQUUsRUFBSSxJQUFOLENBQ0FnQixNQUFNLENBQUcsQ0FBVCxDQUNELENBRUQ7QUFDQSxHQUFJdkgsTUFBSyxDQUFHL0ssTUFBTSxDQUFDQyxZQUFQLENBQW9CcVMsTUFBcEIsQ0FBWixDQUNBLEdBQUdoQixFQUFFLEdBQUssQ0FBVixDQUFhLENBQ1h2RyxLQUFLLEVBQUkvSyxNQUFNLENBQUNDLFlBQVAsQ0FBb0JxUixFQUFwQixDQUFULENBQ0QsQ0FDRHBSLENBQUMsQ0FBQzZLLEtBQUYsQ0FBVThELElBQUksQ0FBQ2piLE1BQUwsQ0FDUmliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURILENBQ2NGLElBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUR4QixDQUNtQyxLQURuQyxDQUMwQ3hFLEtBRDFDLENBQVYsQ0FFRCxDQTlDTSxJQThDQSxJQUFHN0ssQ0FBQyxDQUFDbkksSUFBRixHQUFXLGdCQUFYLEVBQStCbUksQ0FBQyxDQUFDbkksSUFBRixHQUFXLGVBQTdDLENBQThELENBQ25FO0FBQ0FtSSxDQUFDLENBQUM2SyxLQUFGLENBQVU4RCxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxFQUE1RCxDQUFWLENBRUEsR0FBSW0zQixRQUFKLENBQ0EsSUFBSSxHQUFJbnJDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR2dFLENBQUMsQ0FBQ2luQyxRQUFGLENBQVc5MUMsTUFBOUIsQ0FBc0MsRUFBRTZLLENBQXhDLENBQTJDLENBQ3pDbXJDLE9BQU8sQ0FBR25uQyxDQUFDLENBQUNpbkMsUUFBRixDQUFXanJDLENBQVgsQ0FBVixDQUNBLEdBQUk2TyxNQUFLLENBQUdzOEIsT0FBTyxDQUFDdDhCLEtBQXBCLENBQ0E7QUFDQSxHQUFHczhCLE9BQU8sQ0FBQ24vQixJQUFSLEdBQWlCLENBQWpCLEVBQXNCbS9CLE9BQU8sQ0FBQ2w3QixFQUFqQyxDQUFxQyxDQUNuQ3BCLEtBQUssQ0FBRzVSLEtBQUssQ0FBQzJELElBQU4sQ0FBV29QLFdBQVgsQ0FBdUJtN0IsT0FBTyxDQUFDbDdCLEVBQS9CLENBQVIsQ0FDQSxHQUFHcEIsS0FBSyxHQUFLLElBQWIsQ0FBbUIsQ0FDakIsR0FBSTFYLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUNWLDJEQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQ20xQyxTQUFOLENBQWtCdG9DLENBQWxCLENBQ0EsS0FBTTdNLE1BQU4sQ0FDRCxDQUNGLENBUkQsSUFRTyxJQUFHZzBDLE9BQU8sQ0FBQ24vQixJQUFSLEdBQWlCLENBQXBCLENBQXVCLENBQzVCO0FBQ0EsR0FBR20vQixPQUFPLENBQUNyMEIsR0FBWCxDQUFnQixDQUNkakksS0FBSyxDQUFHOEQsSUFBSSxDQUFDa0UsUUFBTCxDQUFjbEUsSUFBSSxDQUFDa0UsUUFBTCxDQUFjczBCLE9BQU8sQ0FBQ3IwQixHQUF0QixDQUFkLENBQVIsQ0FDRCxDQUZELElBRU8sQ0FDTDtBQUNBakksS0FBSyxDQUFHOEQsSUFBSSxDQUFDa0UsUUFBTCxDQUFjaEksS0FBZCxDQUFSLENBQ0QsQ0FDRixDQUNEN0ssQ0FBQyxDQUFDNkssS0FBRixDQUFRQSxLQUFSLENBQWM5TSxJQUFkLENBQW1CNFEsSUFBSSxDQUFDamIsTUFBTCxDQUNqQmliLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFETSxDQUNZbzRCLE9BQU8sQ0FBQ24vQixJQURwQixDQUMwQixLQUQxQixDQUVqQjZDLEtBRmlCLENBQW5CLEVBR0QsQ0FDRixDQTlCTSxJQThCQSxJQUFHN0ssQ0FBQyxDQUFDbkksSUFBRixHQUFXLHNCQUFYLEVBQXFDckgsT0FBTyxDQUFDMHdDLElBQWhELENBQXNELENBQzNELEdBQUlpRCxJQUFHLENBQUczekMsT0FBTyxDQUFDMHdDLElBQVIsQ0FBYStDLDRCQUFiLEVBQVYsQ0FDQWprQyxDQUFDLENBQUNva0Msb0JBQUYsQ0FBeUJELEdBQUcsQ0FBQ3ZoQyxLQUFKLEVBQXpCLENBQ0E7QUFDQTVDLENBQUMsQ0FBQzZLLEtBQUYsQ0FBVThELElBQUksQ0FBQ2piLE1BQUwsQ0FDUmliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURILENBQ2NGLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUR4QixDQUNxQyxLQURyQyxDQUM0QzYwQixHQUFHLENBQUM5aUMsUUFBSixFQUQ1QyxDQUFWLENBRUQsQ0FOTSxJQU1BLElBQUdyQixDQUFDLENBQUNuSSxJQUFGLEdBQVcsd0JBQVgsRUFBdUNySCxPQUFPLENBQUMwd0MsSUFBbEQsQ0FBd0QsQ0FDN0Q7QUFDQWxoQyxDQUFDLENBQUM2SyxLQUFGLENBQVU4RCxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxFQUE1RCxDQUFWLENBQ0EsR0FBSWl3QixJQUFHLENBQUdqZ0MsQ0FBQyxDQUFDNkssS0FBRixDQUFRQSxLQUFsQixDQUVBLEdBQUc3SyxDQUFDLENBQUN1b0MsYUFBTCxDQUFvQixDQUNsQixHQUFJQSxjQUFhLENBQUl2b0MsQ0FBQyxDQUFDdW9DLGFBQUYsR0FBb0IsSUFBcEIsQ0FDbkIvM0MsT0FBTyxDQUFDMHdDLElBQVIsQ0FBYStDLDRCQUFiLEdBQTRDNWlDLFFBQTVDLEVBRG1CLENBRW5CckIsQ0FBQyxDQUFDdW9DLGFBRkosQ0FHQXRJLEdBQUcsQ0FBQ2xpQyxJQUFKLENBQ0U0USxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLEtBQTVDLENBQW1EdzVCLGFBQW5ELENBREYsRUFFRCxDQUVELEdBQUd2b0MsQ0FBQyxDQUFDd29DLG1CQUFMLENBQTBCLENBQ3hCLEdBQUlBLG9CQUFtQixDQUFHLENBQ3hCNzVCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0QsQ0FDaERrNUIsU0FBUyxDQUFDam9DLENBQUMsQ0FBQ3dvQyxtQkFBRixHQUEwQixJQUExQixDQUNSaDRDLE9BQU8sQ0FBQzB3QyxJQUFSLENBQWFrQixNQURMLENBQ2NwaUMsQ0FBQyxDQUFDd29DLG1CQURqQixDQUR1QyxDQUFsRCxDQUR3QixDQUExQixDQU1BdkksR0FBRyxDQUFDbGlDLElBQUosQ0FDRTRRLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0R5NUIsbUJBQWxELENBREYsRUFFRCxDQUVELEdBQUd4b0MsQ0FBQyxDQUFDOGhDLFlBQUwsQ0FBbUIsQ0FDakIsR0FBSUEsYUFBWSxDQUFHN29DLEtBQUssQ0FBQzJELElBQU4sQ0FBV3NJLFVBQVgsQ0FBc0JsRixDQUFDLENBQUM4aEMsWUFBRixHQUFtQixJQUFuQixDQUN2Q3R4QyxPQUFPLENBQUMwd0MsSUFBUixDQUFhWSxZQUQwQixDQUNYOWhDLENBQUMsQ0FBQzhoQyxZQURiLENBQW5CLENBRUE3QixHQUFHLENBQUNsaUMsSUFBSixDQUNFNFEsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxLQUE1QyxDQUFtRCt5QixZQUFuRCxDQURGLEVBRUQsQ0FDRixDQTlCTSxJQThCQSxJQUFJOWhDLENBQUMsQ0FBQ25JLElBQUYsR0FBVyx1QkFBZixDQUF3QyxDQUM3Q21JLENBQUMsQ0FBQzZLLEtBQUYsQ0FBVThELElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELEVBQTVELENBQVYsQ0FDQSxHQUFJaXdCLElBQUcsQ0FBR2pnQyxDQUFDLENBQUM2SyxLQUFGLENBQVFBLEtBQWxCLENBRUE7QUFDQSxHQUFJNDlCLE9BQU0sQ0FBRzk1QixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxFQUE1RCxDQUFiLENBRUE7QUFDQSxHQUFJMDRCLHFCQUFvQixDQUFHLzVCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0QsRUFBbEQsQ0FBM0IsQ0FDQSxHQUFJbzRCLFFBQUosQ0FDQSxJQUFJLEdBQUluckMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHZ0UsQ0FBQyxDQUFDaW5DLFFBQUYsQ0FBVzkxQyxNQUE5QixDQUFzQyxFQUFFNkssQ0FBeEMsQ0FBMkMsQ0FDekNtckMsT0FBTyxDQUFHbm5DLENBQUMsQ0FBQ2luQyxRQUFGLENBQVdqckMsQ0FBWCxDQUFWLENBQ0EsR0FBSTZPLE1BQUssQ0FBR3M4QixPQUFPLENBQUN0OEIsS0FBcEIsQ0FDQTtBQUNBLEdBQUdzOEIsT0FBTyxDQUFDbi9CLElBQVIsR0FBaUIsQ0FBakIsRUFBc0JtL0IsT0FBTyxDQUFDbDdCLEVBQWpDLENBQXFDLENBQ25DcEIsS0FBSyxDQUFHNVIsS0FBSyxDQUFDMkQsSUFBTixDQUFXb1AsV0FBWCxDQUF1Qm03QixPQUFPLENBQUNsN0IsRUFBL0IsQ0FBUixDQUNBLEdBQUdwQixLQUFLLEdBQUssSUFBYixDQUFtQixDQUNqQixHQUFJMVgsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQ1YsMkRBRFUsQ0FBWixDQUVBa0MsS0FBSyxDQUFDbTFDLFNBQU4sQ0FBa0J0b0MsQ0FBbEIsQ0FDQSxLQUFNN00sTUFBTixDQUNELENBQ0YsQ0FSRCxJQVFPLElBQUdnMEMsT0FBTyxDQUFDbi9CLElBQVIsR0FBaUIsQ0FBcEIsQ0FBdUIsQ0FDNUI7QUFDQSxHQUFHbS9CLE9BQU8sQ0FBQ3IwQixHQUFYLENBQWdCLENBQ2RqSSxLQUFLLENBQUc4RCxJQUFJLENBQUNrRSxRQUFMLENBQWNsRSxJQUFJLENBQUNrRSxRQUFMLENBQWNzMEIsT0FBTyxDQUFDcjBCLEdBQXRCLENBQWQsQ0FBUixDQUNELENBRkQsSUFFTyxDQUNMO0FBQ0FqSSxLQUFLLENBQUc4RCxJQUFJLENBQUNrRSxRQUFMLENBQWNoSSxLQUFkLENBQVIsQ0FDRCxDQUNGLENBQ0Q2OUIsb0JBQW9CLENBQUM3OUIsS0FBckIsQ0FBMkI5TSxJQUEzQixDQUFnQzRRLElBQUksQ0FBQ2piLE1BQUwsQ0FDOUJpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRG1CLENBQ0RvNEIsT0FBTyxDQUFDbi9CLElBRFAsQ0FDYSxLQURiLENBRTlCNkMsS0FGOEIsQ0FBaEMsRUFHRCxDQUVEO0FBQ0E0OUIsTUFBTSxDQUFDNTlCLEtBQVAsQ0FBYTlNLElBQWIsQ0FBa0I0USxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQUMyNUIsb0JBQUQsQ0FBbEQsQ0FBbEIsRUFDQXpJLEdBQUcsQ0FBQ2xpQyxJQUFKLENBQVMwcUMsTUFBVCxFQUNELENBRUQ7QUFDQSxHQUFHLE1BQU96b0MsRUFBQyxDQUFDNkssS0FBVCxHQUFtQixXQUF0QixDQUFtQyxDQUNqQyxHQUFJMVgsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsZ0NBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDbTFDLFNBQU4sQ0FBa0J0b0MsQ0FBbEIsQ0FDQSxLQUFNN00sTUFBTixDQUNELENBRUQsTUFBTzZNLEVBQVAsQ0FDRCxDQUVEOzs7Ozs7R0FPQSxRQUFTMm9DLDJCQUFULENBQW9DNzFCLEdBQXBDLENBQXlDN2IsTUFBekMsQ0FBaUQsQ0FDL0MsT0FBTzZiLEdBQVAsRUFDQSxJQUFLb0QsS0FBSSxDQUFDLFlBQUQsQ0FBVCxDQUNFLEdBQUk1SyxNQUFLLENBQUcsRUFBWixDQUVBLEdBQUdyVSxNQUFNLENBQUN3QixJQUFQLENBQVkrbkMsWUFBWixHQUE2QnRqQyxTQUFoQyxDQUEyQyxDQUN6Q29PLEtBQUssQ0FBQ3ZOLElBQU4sQ0FBVzRRLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0QsQ0FDM0RKLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjNWIsTUFBTSxDQUFDd0IsSUFBUCxDQUFZK25DLFlBQTFCLEVBQXdDbi9CLFFBQXhDLEVBREYsQ0FEMEQsQ0FHMURzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTSxJQUE1QyxDQUFrRCxLQUFsRCxDQUF5RCxFQUF6RCxDQUgwRCxDQUE1RCxDQUQyRCxDQUFsRCxDQUFYLEVBT0QsQ0FFRCxHQUFHdFksTUFBTSxDQUFDd3BDLEdBQVAsQ0FBV0QsWUFBWCxHQUE0QnRqQyxTQUEvQixDQUEwQyxDQUN4Q29PLEtBQUssQ0FBQ3ZOLElBQU4sQ0FBVzRRLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0QsQ0FDM0RKLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjNWIsTUFBTSxDQUFDd3BDLEdBQVAsQ0FBV0QsWUFBekIsRUFBdUNuL0IsUUFBdkMsRUFERixDQUQwRCxDQUcxRHNOLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjNWIsTUFBTSxDQUFDd3BDLEdBQVAsQ0FBV2hvQyxJQUFYLENBQWdCK25DLFlBQTlCLEVBQTRDbi9CLFFBQTVDLEVBREYsQ0FEMEQsQ0FHMURzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTSxJQUE1QyxDQUFrRCxLQUFsRCxDQUF5RCxFQUF6RCxDQUgwRCxDQUE1RCxDQUgwRCxDQUE1RCxDQUQyRCxDQUFsRCxDQUFYLEVBV0QsQ0FFRCxHQUFHdFksTUFBTSxDQUFDeXBDLFVBQVAsR0FBc0J4akMsU0FBekIsQ0FBb0MsQ0FDbENvTyxLQUFLLENBQUN2TixJQUFOLENBQVc0USxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQzNESixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUE1QyxDQUFxRCxLQUFyRCxDQUNFVCxJQUFJLENBQUNxRyxZQUFMLENBQWtCL2QsTUFBTSxDQUFDeXBDLFVBQXpCLEVBQXFDci9CLFFBQXJDLEVBREYsQ0FEMkQsQ0FBbEQsQ0FBWCxFQUlELENBRUQsTUFBT3NOLEtBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTREMUUsS0FBNUQsQ0FBUCxDQUVGLFFBQ0UsTUFBT3FELEtBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVNLElBQTVDLENBQWtELEtBQWxELENBQXlELEVBQXpELENBQVAsQ0F0Q0YsQ0F3Q0QsQ0FFRDs7Ozs7OztHQVFBLFFBQVNxNUIscUJBQVQsQ0FBOEJqSCxHQUE5QixDQUFtQyxDQUNqQztBQUNBLEdBQUlsZ0MsS0FBSSxDQUFHa04sSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxJQUE1QyxDQUFrRCxFQUFsRCxDQUFYLENBRUE7QUFDQSxHQUFHNHlCLEdBQUcsQ0FBQ2xqQyxVQUFKLENBQWV0TixNQUFmLEdBQTBCLENBQTdCLENBQWdDLENBQzlCLE1BQU9zUSxLQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUlraEMsTUFBSyxDQUFHaEIsR0FBRyxDQUFDbGpDLFVBQWhCLENBQ0EsSUFBSSxHQUFJcEQsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHc25DLEtBQUssQ0FBQ3h4QyxNQUF6QixDQUFpQyxFQUFFa0ssQ0FBbkMsQ0FBc0MsQ0FDcEMsR0FBSStDLEtBQUksQ0FBR3VrQyxLQUFLLENBQUN0bkMsQ0FBRCxDQUFoQixDQUNBLEdBQUl3UCxNQUFLLENBQUd6TSxJQUFJLENBQUN5TSxLQUFqQixDQUVBO0FBQ0EsR0FBSWkxQixjQUFhLENBQUdueEIsSUFBSSxDQUFDTSxJQUFMLENBQVVhLElBQTlCLENBQ0EsR0FBRyxpQkFBbUIxUixLQUF0QixDQUE0QixDQUMxQjBoQyxhQUFhLENBQUcxaEMsSUFBSSxDQUFDMGhDLGFBQXJCLENBQ0QsQ0FDRCxHQUFHQSxhQUFhLEdBQUtueEIsSUFBSSxDQUFDTSxJQUFMLENBQVVhLElBQS9CLENBQXFDLENBQ25DakYsS0FBSyxDQUFHNVIsS0FBSyxDQUFDMkQsSUFBTixDQUFXK0QsVUFBWCxDQUFzQmtLLEtBQXRCLENBQVIsQ0FDRCxDQUNELEdBQUl1OUIsaUJBQWdCLENBQUcsS0FBdkIsQ0FDQSxHQUFHLG9CQUFzQmhxQyxLQUF6QixDQUErQixDQUM3QmdxQyxnQkFBZ0IsQ0FBR2hxQyxJQUFJLENBQUNncUMsZ0JBQXhCLENBQ0QsQ0FDRDtBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUluSSxJQUFHLENBQUd0eEIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDcEU7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY3pVLElBQUksQ0FBQzRKLElBQW5CLEVBQXlCM0csUUFBekIsRUFERixDQUZvRSxDQUlwRXNOLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVnQixHQUE1QyxDQUFpRCxJQUFqRCxDQUF1RCxDQUNyRDtBQUNBdEIsSUFBSSxDQUFDamIsTUFBTCxDQUNFaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRGIsQ0FDd0JpeEIsYUFEeEIsQ0FDdUNzSSxnQkFEdkMsQ0FDeUR2OUIsS0FEekQsQ0FGcUQsQ0FBdkQsQ0FKb0UsQ0FBNUQsQ0FBVixDQVVBcEosSUFBSSxDQUFDb0osS0FBTCxDQUFXOU0sSUFBWCxDQUFnQmtpQyxHQUFoQixFQUNELENBRUQsTUFBT3grQixLQUFQLENBQ0QsQ0FFRCxHQUFNb25DLFdBQVUsQ0FBRyxHQUFJMXFDLEtBQUosQ0FBUyxzQkFBVCxDQUFuQixDQUNBLEdBQU0ycUMsV0FBVSxDQUFHLEdBQUkzcUMsS0FBSixDQUFTLHNCQUFULENBQW5CLENBRUE7Ozs7Ozs7R0FRQyxRQUFTNHFDLFlBQVQsQ0FBcUIzMUIsSUFBckIsQ0FBMEIsQ0FDekIsR0FBR0EsSUFBSSxFQUFJeTFCLFVBQVIsRUFBc0J6MUIsSUFBSSxDQUFHMDFCLFVBQWhDLENBQTRDLENBQzFDLE1BQU9uNkIsS0FBSSxDQUFDamIsTUFBTCxDQUNMaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRE4sQ0FDaUJGLElBQUksQ0FBQ00sSUFBTCxDQUFVbUIsT0FEM0IsQ0FDb0MsS0FEcEMsQ0FFTHpCLElBQUksQ0FBQzZGLGFBQUwsQ0FBbUJwQixJQUFuQixDQUZLLENBQVAsQ0FHRCxDQUpELElBSU8sQ0FDTCxNQUFPekUsS0FBSSxDQUFDamIsTUFBTCxDQUNMaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRE4sQ0FDaUJGLElBQUksQ0FBQ00sSUFBTCxDQUFVb0IsZUFEM0IsQ0FDNEMsS0FENUMsQ0FFTDFCLElBQUksQ0FBQ29HLHFCQUFMLENBQTJCM0IsSUFBM0IsQ0FGSyxDQUFQLENBR0QsQ0FDRixDQUVEOzs7Ozs7R0FPQXpaLEdBQUcsQ0FBQ3lwQyxpQkFBSixDQUF3QixTQUFTbEMsSUFBVCxDQUFlLENBQ3JDO0FBQ0EsR0FBSWdCLFVBQVMsQ0FBRzZHLFdBQVcsQ0FBQzdILElBQUksQ0FBQ2UsUUFBTCxDQUFjQyxTQUFmLENBQTNCLENBQ0EsR0FBSUMsU0FBUSxDQUFHNEcsV0FBVyxDQUFDN0gsSUFBSSxDQUFDZSxRQUFMLENBQWNFLFFBQWYsQ0FBMUIsQ0FDQSxHQUFJNkcsSUFBRyxDQUFHcjZCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQ3BFO0FBQ0FyQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hEO0FBQ0FKLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0VULElBQUksQ0FBQ3FHLFlBQUwsQ0FBa0Jrc0IsSUFBSSxDQUFDbGMsT0FBdkIsRUFBZ0MzakIsUUFBaEMsRUFERixDQUZnRCxDQUFsRCxDQUZvRSxDQU9wRTtBQUNBc04sSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRW5XLEtBQUssQ0FBQzJELElBQU4sQ0FBV3NJLFVBQVgsQ0FBc0JnOEIsSUFBSSxDQUFDWSxZQUEzQixDQURGLENBUm9FLENBVXBFO0FBQ0FuekIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY3F1QixJQUFJLENBQUNjLE9BQUwsQ0FBYXhCLFlBQTNCLEVBQXlDbi9CLFFBQXpDLEVBREYsQ0FGMEQsQ0FJMUQ7QUFDQXNuQywwQkFBMEIsQ0FDeEJ6SCxJQUFJLENBQUNjLE9BQUwsQ0FBYXhCLFlBRFcsQ0FDR1UsSUFBSSxDQUFDYyxPQUFMLENBQWE1YyxVQURoQixDQUxnQyxDQUE1RCxDQVhvRSxDQW1CcEU7QUFDQTZpQixTQUFTLENBQUMvRyxJQUFJLENBQUNrQixNQUFOLENBcEIyRCxDQXFCcEU7QUFDQXp6QixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRGt5QixTQUQwRCxDQUUxREMsUUFGMEQsQ0FBNUQsQ0F0Qm9FLENBMEJwRTtBQUNBOEYsU0FBUyxDQUFDL0csSUFBSSxDQUFDdUIsT0FBTixDQTNCMkQsQ0E0QnBFO0FBQ0E5b0MsR0FBRyxDQUFDZ21CLGVBQUosQ0FBb0J1aEIsSUFBSSxDQUFDcm5DLFNBQXpCLENBN0JvRSxDQUE1RCxDQUFWLENBZ0NBLEdBQUdxbkMsSUFBSSxDQUFDa0IsTUFBTCxDQUFZUSxRQUFmLENBQXlCLENBQ3ZCO0FBQ0FvRyxHQUFHLENBQUNuK0IsS0FBSixDQUFVOU0sSUFBVixDQUNFNFEsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxJQUE1QyxDQUFrRCxDQUNoREosSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FBNUMsQ0FBdUQsS0FBdkQsQ0FDRTtBQUNBdlAsTUFBTSxDQUFDQyxZQUFQLENBQW9CLElBQXBCLEVBQ0FtaEMsSUFBSSxDQUFDa0IsTUFBTCxDQUFZUSxRQUhkLENBRGdELENBQWxELENBREYsRUFTRCxDQUNELEdBQUcxQixJQUFJLENBQUN1QixPQUFMLENBQWFHLFFBQWhCLENBQTBCLENBQ3hCO0FBQ0FvRyxHQUFHLENBQUNuK0IsS0FBSixDQUFVOU0sSUFBVixDQUNFNFEsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxJQUE1QyxDQUFrRCxDQUNoREosSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FBNUMsQ0FBdUQsS0FBdkQsQ0FDRTtBQUNBdlAsTUFBTSxDQUFDQyxZQUFQLENBQW9CLElBQXBCLEVBQ0FtaEMsSUFBSSxDQUFDdUIsT0FBTCxDQUFhRyxRQUhmLENBRGdELENBQWxELENBREYsRUFTRCxDQUVELEdBQUcxQixJQUFJLENBQUNmLFVBQUwsQ0FBZ0JodkMsTUFBaEIsQ0FBeUIsQ0FBNUIsQ0FBK0IsQ0FDN0I7QUFDQTYzQyxHQUFHLENBQUNuK0IsS0FBSixDQUFVOU0sSUFBVixDQUFlcEUsR0FBRyxDQUFDc3ZDLDJCQUFKLENBQWdDL0gsSUFBSSxDQUFDZixVQUFyQyxDQUFmLEVBQ0QsQ0FFRCxNQUFPNkksSUFBUCxDQUNELENBbkVELENBcUVBOzs7Ozs7O0dBUUFydkMsR0FBRyxDQUFDb3VDLDJCQUFKLENBQWtDLFNBQVNwRyxHQUFULENBQWMsQ0FDOUM7QUFDQSxHQUFJcUcsSUFBRyxDQUFHcjVCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQ3BFO0FBQ0FyQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUE1QyxDQUFxRCxLQUFyRCxDQUNFVCxJQUFJLENBQUNxRyxZQUFMLENBQWtCMnNCLEdBQUcsQ0FBQzNjLE9BQXRCLEVBQStCM2pCLFFBQS9CLEVBREYsQ0FGb0UsQ0FJcEU7QUFDQTRtQyxTQUFTLENBQUN0RyxHQUFHLENBQUNjLE9BQUwsQ0FMMkQsQ0FNcEU7QUFDQTlvQyxHQUFHLENBQUNnbUIsZUFBSixDQUFvQmdpQixHQUFHLENBQUM5bkMsU0FBeEIsQ0FQb0UsQ0FRcEU7QUFDQSt1QyxvQkFBb0IsQ0FBQ2pILEdBQUQsQ0FUZ0QsQ0FBNUQsQ0FBVixDQVlBLE1BQU9xRyxJQUFQLENBQ0QsQ0FmRCxDQWlCQTs7Ozs7O0dBT0FydUMsR0FBRyxDQUFDdXZDLHVCQUFKLENBQThCLFNBQVNDLEVBQVQsQ0FBYSxDQUN6QyxNQUFPbEIsVUFBUyxDQUFDa0IsRUFBRCxDQUFoQixDQUNELENBRkQsQ0FJQTs7Ozs7O0dBT0F4dkMsR0FBRyxDQUFDd25DLGlCQUFKLENBQXdCLFNBQVNELElBQVQsQ0FBZSxDQUNyQztBQUNBLEdBQUlpQyxlQUFjLENBQUdqQyxJQUFJLENBQUNpQyxjQUFMLEVBQXVCeHBDLEdBQUcsQ0FBQ3lwQyxpQkFBSixDQUFzQmxDLElBQXRCLENBQTVDLENBRUE7QUFDQSxNQUFPdnlCLEtBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQ2pFO0FBQ0FtekIsY0FGaUUsQ0FHakU7QUFDQXgwQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjcXVCLElBQUksQ0FBQ2EsWUFBbkIsRUFBaUMxZ0MsUUFBakMsRUFERixDQUYwRCxDQUkxRDtBQUNBc25DLDBCQUEwQixDQUFDekgsSUFBSSxDQUFDYSxZQUFOLENBQW9CYixJQUFJLENBQUN5QyxtQkFBekIsQ0FMZ0MsQ0FBNUQsQ0FKaUUsQ0FXakU7QUFDQWgxQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVSSxTQUE1QyxDQUF1RCxLQUF2RCxDQUNFdlAsTUFBTSxDQUFDQyxZQUFQLENBQW9CLElBQXBCLEVBQTRCbWhDLElBQUksQ0FBQzlpQixTQURuQyxDQVppRSxDQUE1RCxDQUFQLENBZUQsQ0FwQkQsQ0FzQkE7Ozs7OztHQU9BemtCLEdBQUcsQ0FBQ3N2QywyQkFBSixDQUFrQyxTQUFTbEcsSUFBVCxDQUFlLENBQy9DO0FBQ0EsR0FBSXRoQyxLQUFJLENBQUdrTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELEVBQWxELENBQVgsQ0FFQTtBQUNBLEdBQUlreEIsSUFBRyxDQUFHdHhCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELEVBQTVELENBQVYsQ0FDQXZPLElBQUksQ0FBQ29KLEtBQUwsQ0FBVzlNLElBQVgsQ0FBZ0JraUMsR0FBaEIsRUFFQSxJQUFJLEdBQUk1a0MsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHMG5DLElBQUksQ0FBQzV4QyxNQUF4QixDQUFnQyxFQUFFa0ssQ0FBbEMsQ0FBcUMsQ0FDbkM0a0MsR0FBRyxDQUFDcDFCLEtBQUosQ0FBVTlNLElBQVYsQ0FBZXBFLEdBQUcsQ0FBQzB1QywwQkFBSixDQUErQnRGLElBQUksQ0FBQzFuQyxDQUFELENBQW5DLENBQWYsRUFDRCxDQUVELE1BQU9vRyxLQUFQLENBQ0QsQ0FiRCxDQWVBOzs7Ozs7R0FPQTlILEdBQUcsQ0FBQzB1QywwQkFBSixDQUFpQyxTQUFTbkYsR0FBVCxDQUFjLENBQzdDO0FBQ0EsR0FBSXdDLE9BQU0sQ0FBRy8yQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxFQUE1RCxDQUFiLENBRUE7QUFDQTAxQixNQUFNLENBQUM3NkIsS0FBUCxDQUFhOU0sSUFBYixDQUFrQjRRLElBQUksQ0FBQ2piLE1BQUwsQ0FDaEJpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FESyxDQUNNRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FEaEIsQ0FDcUIsS0FEckIsQ0FFaEJiLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY3F3QixHQUFHLENBQUM3N0IsRUFBbEIsRUFBc0JoRyxRQUF0QixFQUZnQixDQUFsQixFQUlBO0FBQ0EsR0FBRzZoQyxHQUFHLENBQUN5QyxRQUFQLENBQWlCLENBQ2Y7QUFDQUQsTUFBTSxDQUFDNzZCLEtBQVAsQ0FBYTlNLElBQWIsQ0FBa0I0USxJQUFJLENBQUNqYixNQUFMLENBQ2hCaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBREssQ0FDTUYsSUFBSSxDQUFDTSxJQUFMLENBQVVFLE9BRGhCLENBQ3lCLEtBRHpCLENBRWhCclAsTUFBTSxDQUFDQyxZQUFQLENBQW9CLElBQXBCLENBRmdCLENBQWxCLEVBR0QsQ0FFRCxHQUFJOEssTUFBSyxDQUFHcTRCLEdBQUcsQ0FBQ3I0QixLQUFoQixDQUNBLEdBQUcsTUFBT3E0QixJQUFHLENBQUNyNEIsS0FBWCxHQUFxQixRQUF4QixDQUFrQyxDQUNoQztBQUNBQSxLQUFLLENBQUc4RCxJQUFJLENBQUMrRCxLQUFMLENBQVc3SCxLQUFYLEVBQWtCeEosUUFBbEIsRUFBUixDQUNELENBRUQ7QUFDQXFrQyxNQUFNLENBQUM3NkIsS0FBUCxDQUFhOU0sSUFBYixDQUFrQjRRLElBQUksQ0FBQ2piLE1BQUwsQ0FDaEJpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FESyxDQUNNRixJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FEaEIsQ0FDNkIsS0FEN0IsQ0FDb0N6RSxLQURwQyxDQUFsQixFQUdBLE1BQU82NkIsT0FBUCxDQUNELENBNUJELENBOEJBOzs7Ozs7R0FPQS9yQyxHQUFHLENBQUNpb0MsMEJBQUosQ0FBaUMsU0FBU0QsR0FBVCxDQUFjLENBQzdDO0FBQ0EsR0FBSXFHLElBQUcsQ0FBR3JHLEdBQUcsQ0FBQzhGLHdCQUFKLEVBQ1I5dEMsR0FBRyxDQUFDb3VDLDJCQUFKLENBQWdDcEcsR0FBaEMsQ0FERixDQUdBO0FBQ0EsTUFBT2h6QixLQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUNqRTtBQUNBZzRCLEdBRmlFLENBR2pFO0FBQ0FyNUIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBYzh1QixHQUFHLENBQUNJLFlBQWxCLEVBQWdDMWdDLFFBQWhDLEVBREYsQ0FGMEQsQ0FJMUQ7QUFDQXNuQywwQkFBMEIsQ0FBQ2hILEdBQUcsQ0FBQ0ksWUFBTCxDQUFtQkosR0FBRyxDQUFDZ0MsbUJBQXZCLENBTGdDLENBQTVELENBSmlFLENBV2pFO0FBQ0FoMUIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUksU0FBNUMsQ0FBdUQsS0FBdkQsQ0FDRXZQLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQixJQUFwQixFQUE0QjRoQyxHQUFHLENBQUN2akIsU0FEbEMsQ0FaaUUsQ0FBNUQsQ0FBUCxDQWVELENBckJELENBdUJBOzs7Ozs7O0dBUUF6a0IsR0FBRyxDQUFDeXZDLGFBQUosQ0FBb0IsU0FBU0MsS0FBVCxDQUFnQixDQUNsQztBQUNBLEdBQUlDLFFBQU8sQ0FBRyxDQUNaO0FBQ0FELEtBQUssQ0FBRSxFQUZLLENBQWQsQ0FLQTs7Ozs7OztLQVFBQyxPQUFPLENBQUNDLFNBQVIsQ0FBb0IsU0FBU3JJLElBQVQsQ0FBZSxDQUNqQyxHQUFJei9CLEtBQUksQ0FBRytuQyxZQUFZLENBQUN0SSxJQUFJLENBQUNrQixNQUFOLENBQXZCLENBRUE7QUFDQTs7Ozs7O09BUUEsTUFBTzNnQyxLQUFQLENBQ0QsQ0FiRCxDQWVBOzs7OztLQU1BNm5DLE9BQU8sQ0FBQ0csY0FBUixDQUF5QixTQUFTdkksSUFBVCxDQUFlLENBQ3RDO0FBQ0EsR0FBRyxNQUFPQSxLQUFQLEdBQWdCLFFBQW5CLENBQTZCLENBQzNCQSxJQUFJLENBQUdqb0MsS0FBSyxDQUFDVSxHQUFOLENBQVVtbkMsa0JBQVYsQ0FBNkJJLElBQTdCLENBQVAsQ0FDRCxDQUVEd0ksb0JBQW9CLENBQUN4SSxJQUFJLENBQUN1QixPQUFOLENBQXBCLENBRUEsR0FBRyxDQUFDNkcsT0FBTyxDQUFDSyxjQUFSLENBQXVCekksSUFBdkIsQ0FBSixDQUFrQyxDQUFHO0FBQ25DLEdBQUdBLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYWhxQyxJQUFiLEdBQXFCNndDLFFBQU8sQ0FBQ0QsS0FBaEMsQ0FBdUMsQ0FDckM7QUFDQSxHQUFJNTRCLElBQUcsQ0FBRzY0QixPQUFPLENBQUNELEtBQVIsQ0FBY25JLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYWhxQyxJQUEzQixDQUFWLENBQ0EsR0FBRyxDQUFDUSxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1CMFIsR0FBbkIsQ0FBSixDQUE2QixDQUMzQkEsR0FBRyxDQUFHLENBQUNBLEdBQUQsQ0FBTixDQUNELENBQ0RBLEdBQUcsQ0FBQzFTLElBQUosQ0FBU21qQyxJQUFULEVBQ0FvSSxPQUFPLENBQUNELEtBQVIsQ0FBY25JLElBQUksQ0FBQ3VCLE9BQUwsQ0FBYWhxQyxJQUEzQixFQUFtQ2dZLEdBQW5DLENBQ0QsQ0FSRCxJQVFPLENBQ0w2NEIsT0FBTyxDQUFDRCxLQUFSLENBQWNuSSxJQUFJLENBQUN1QixPQUFMLENBQWFocUMsSUFBM0IsRUFBbUN5b0MsSUFBbkMsQ0FDRCxDQUNGLENBQ0YsQ0FyQkQsQ0F1QkE7Ozs7Ozs7S0FRQW9JLE9BQU8sQ0FBQ0ssY0FBUixDQUF5QixTQUFTekksSUFBVCxDQUFlLENBQ3RDO0FBQ0EsR0FBRyxNQUFPQSxLQUFQLEdBQWdCLFFBQW5CLENBQTZCLENBQzNCQSxJQUFJLENBQUdqb0MsS0FBSyxDQUFDVSxHQUFOLENBQVVtbkMsa0JBQVYsQ0FBNkJJLElBQTdCLENBQVAsQ0FDRCxDQUVELEdBQUkvMUIsTUFBSyxDQUFHcStCLFlBQVksQ0FBQ3RJLElBQUksQ0FBQ3VCLE9BQU4sQ0FBeEIsQ0FDQSxHQUFHLENBQUN0M0IsS0FBSixDQUFXLENBQ1QsTUFBTyxNQUFQLENBQ0QsQ0FDRCxHQUFHLENBQUNsUyxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1Cb00sS0FBbkIsQ0FBSixDQUErQixDQUM3QkEsS0FBSyxDQUFHLENBQUNBLEtBQUQsQ0FBUixDQUNELENBQ0Q7QUFDQSxHQUFJeStCLEtBQUksQ0FBR2o3QixJQUFJLENBQUMrRCxLQUFMLENBQVcvWSxHQUFHLENBQUN3bkMsaUJBQUosQ0FBc0JELElBQXRCLENBQVgsRUFBd0M3L0IsUUFBeEMsRUFBWCxDQUNBLElBQUksR0FBSWhHLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzhQLEtBQUssQ0FBQ2hhLE1BQXpCLENBQWlDLEVBQUVrSyxDQUFuQyxDQUFzQyxDQUNwQyxHQUFJd3VDLEtBQUksQ0FBR2w3QixJQUFJLENBQUMrRCxLQUFMLENBQVcvWSxHQUFHLENBQUN3bkMsaUJBQUosQ0FBc0JoMkIsS0FBSyxDQUFDOVAsQ0FBRCxDQUEzQixDQUFYLEVBQTRDZ0csUUFBNUMsRUFBWCxDQUNBLEdBQUd1b0MsSUFBSSxHQUFLQyxJQUFaLENBQWtCLENBQ2hCLE1BQU8sS0FBUCxDQUNELENBQ0YsQ0FDRCxNQUFPLE1BQVAsQ0FDRCxDQXRCRCxDQXdCQTs7OztLQUtBUCxPQUFPLENBQUNRLG1CQUFSLENBQThCLFVBQVcsQ0FDdkMsR0FBSUMsU0FBUSxDQUFHLEVBQWYsQ0FFQSxJQUFJLEdBQUl0eEMsS0FBUixHQUFnQjZ3QyxRQUFPLENBQUNELEtBQXhCLENBQStCLENBQzdCLEdBQUdDLE9BQU8sQ0FBQ0QsS0FBUixDQUFjOXNDLGNBQWQsQ0FBNkI5RCxJQUE3QixDQUFILENBQXVDLENBQ3JDLEdBQUlvUyxNQUFLLENBQUd5K0IsT0FBTyxDQUFDRCxLQUFSLENBQWM1d0MsSUFBZCxDQUFaLENBQ0EsR0FBRyxDQUFDUSxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1COEwsS0FBbkIsQ0FBSixDQUErQixDQUM3QmsvQixRQUFRLENBQUNoc0MsSUFBVCxDQUFjOE0sS0FBZCxFQUNELENBRkQsSUFFTyxDQUNMLElBQUksR0FBSXhQLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3dQLEtBQUssQ0FBQzFaLE1BQXpCLENBQWlDLEVBQUVrSyxDQUFuQyxDQUFzQyxDQUNwQzB1QyxRQUFRLENBQUNoc0MsSUFBVCxDQUFjOE0sS0FBSyxDQUFDeFAsQ0FBRCxDQUFuQixFQUNELENBQ0YsQ0FDRixDQUNGLENBRUQsTUFBTzB1QyxTQUFQLENBQ0QsQ0FqQkQsQ0FtQkE7Ozs7Ozs7O0tBU0FULE9BQU8sQ0FBQ1UsaUJBQVIsQ0FBNEIsU0FBUzlJLElBQVQsQ0FBZSxDQUN6QyxHQUFJanVDLE9BQUosQ0FFQTtBQUNBLEdBQUcsTUFBT2l1QyxLQUFQLEdBQWdCLFFBQW5CLENBQTZCLENBQzNCQSxJQUFJLENBQUdqb0MsS0FBSyxDQUFDVSxHQUFOLENBQVVtbkMsa0JBQVYsQ0FBNkJJLElBQTdCLENBQVAsQ0FDRCxDQUNEd0ksb0JBQW9CLENBQUN4SSxJQUFJLENBQUN1QixPQUFOLENBQXBCLENBQ0EsR0FBRyxDQUFDNkcsT0FBTyxDQUFDSyxjQUFSLENBQXVCekksSUFBdkIsQ0FBSixDQUFrQyxDQUNoQyxNQUFPLEtBQVAsQ0FDRCxDQUVELEdBQUkvMUIsTUFBSyxDQUFHcStCLFlBQVksQ0FBQ3RJLElBQUksQ0FBQ3VCLE9BQU4sQ0FBeEIsQ0FFQSxHQUFHLENBQUN4cEMsS0FBSyxDQUFDMkQsSUFBTixDQUFXbUMsT0FBWCxDQUFtQm9NLEtBQW5CLENBQUosQ0FBK0IsQ0FDN0JsWSxNQUFNLENBQUdxMkMsT0FBTyxDQUFDRCxLQUFSLENBQWNuSSxJQUFJLENBQUN1QixPQUFMLENBQWFocUMsSUFBM0IsQ0FBVCxDQUNBLE1BQU82d0MsUUFBTyxDQUFDRCxLQUFSLENBQWNuSSxJQUFJLENBQUN1QixPQUFMLENBQWFocUMsSUFBM0IsQ0FBUCxDQUNBLE1BQU94RixPQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUkyMkMsS0FBSSxDQUFHajdCLElBQUksQ0FBQytELEtBQUwsQ0FBVy9ZLEdBQUcsQ0FBQ3duQyxpQkFBSixDQUFzQkQsSUFBdEIsQ0FBWCxFQUF3QzcvQixRQUF4QyxFQUFYLENBQ0EsSUFBSSxHQUFJaEcsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHOFAsS0FBSyxDQUFDaGEsTUFBekIsQ0FBaUMsRUFBRWtLLENBQW5DLENBQXNDLENBQ3BDLEdBQUl3dUMsS0FBSSxDQUFHbDdCLElBQUksQ0FBQytELEtBQUwsQ0FBVy9ZLEdBQUcsQ0FBQ3duQyxpQkFBSixDQUFzQmgyQixLQUFLLENBQUM5UCxDQUFELENBQTNCLENBQVgsRUFBNENnRyxRQUE1QyxFQUFYLENBQ0EsR0FBR3VvQyxJQUFJLEdBQUtDLElBQVosQ0FBa0IsQ0FDaEI1MkMsTUFBTSxDQUFHa1ksS0FBSyxDQUFDOVAsQ0FBRCxDQUFkLENBQ0E4UCxLQUFLLENBQUMyQixNQUFOLENBQWF6UixDQUFiLENBQWdCLENBQWhCLEVBQ0QsQ0FDRixDQUNELEdBQUc4UCxLQUFLLENBQUNoYSxNQUFOLEdBQWlCLENBQXBCLENBQXVCLENBQ3JCLE1BQU9tNEMsUUFBTyxDQUFDRCxLQUFSLENBQWNuSSxJQUFJLENBQUN1QixPQUFMLENBQWFocUMsSUFBM0IsQ0FBUCxDQUNELENBRUQsTUFBT3hGLE9BQVAsQ0FDRCxDQWxDRCxDQW9DQSxRQUFTdTJDLGFBQVQsQ0FBc0IvRyxPQUF0QixDQUErQixDQUM3QmlILG9CQUFvQixDQUFDakgsT0FBRCxDQUFwQixDQUNBLE1BQU82RyxRQUFPLENBQUNELEtBQVIsQ0FBYzVHLE9BQU8sQ0FBQ2hxQyxJQUF0QixHQUErQixJQUF0QyxDQUNELENBRUQsUUFBU2l4QyxxQkFBVCxDQUE4QmpILE9BQTlCLENBQXVDLENBQ3JDO0FBQ0EsR0FBRyxDQUFDQSxPQUFPLENBQUNocUMsSUFBWixDQUFrQixDQUNoQixHQUFJNmQsR0FBRSxDQUFHcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTbVMsSUFBVCxDQUFjLzBCLE1BQWQsRUFBVCxDQUNBK3VDLE9BQU8sQ0FBQ2hrQyxVQUFSLENBQXNCOUUsR0FBRyxDQUFDZ21DLG9CQUFKLENBQXlCc0ksU0FBUyxDQUFDeEYsT0FBRCxDQUFsQyxDQUE2Q25zQixFQUE3QyxDQUF0QixDQUNBbXNCLE9BQU8sQ0FBQ2hxQyxJQUFSLENBQWU2ZCxFQUFFLENBQUM0QyxNQUFILEdBQVl0VyxLQUFaLEVBQWYsQ0FDRCxDQUNGLENBRUQ7QUFDQSxHQUFHeW1DLEtBQUgsQ0FBVSxDQUNSO0FBQ0EsSUFBSSxHQUFJaHVDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR2d1QyxLQUFLLENBQUNsNEMsTUFBekIsQ0FBaUMsRUFBRWtLLENBQW5DLENBQXNDLENBQ3BDLEdBQUk2bEMsS0FBSSxDQUFHbUksS0FBSyxDQUFDaHVDLENBQUQsQ0FBaEIsQ0FDQWl1QyxPQUFPLENBQUNHLGNBQVIsQ0FBdUJ2SSxJQUF2QixFQUNELENBQ0YsQ0FFRCxNQUFPb0ksUUFBUCxDQUNELENBeExELENBMExBOztHQUdBM3ZDLEdBQUcsQ0FBQ3N3QyxnQkFBSixDQUF1QixDQUNyQkMsZUFBZSxDQUFFLDBCQURJLENBRXJCQyx1QkFBdUIsQ0FBRSxrQ0FGSixDQUdyQkMsbUJBQW1CLENBQUUsOEJBSEEsQ0FJckJDLG1CQUFtQixDQUFFLDhCQUpBLENBS3JCQyxtQkFBbUIsQ0FBRSw4QkFMQSxDQU1yQkMsVUFBVSxDQUFFLHVDQU5TLENBQXZCLENBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1QkE1d0MsR0FBRyxDQUFDNndDLHNCQUFKLENBQTZCLFNBQVNsQixPQUFULENBQWtCbUIsS0FBbEIsQ0FBeUJ0c0IsTUFBekIsQ0FBaUMsQ0FDNUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBRDRELENBMkY1RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkEzRjRELENBa0k1RDtBQUNBO0FBQ0Fzc0IsS0FBSyxDQUFHQSxLQUFLLENBQUM1c0MsS0FBTixDQUFZLENBQVosQ0FBUixDQUNBLEdBQUl3ckMsTUFBSyxDQUFHb0IsS0FBSyxDQUFDNXNDLEtBQU4sQ0FBWSxDQUFaLENBQVosQ0FFQTtBQUNBLEdBQUlLLElBQUcsQ0FBRyxHQUFJQyxLQUFKLEVBQVYsQ0FFQTtBQUNBO0FBQ0EsR0FBSWdpQixNQUFLLENBQUcsSUFBWixDQUNBLEdBQUlodEIsTUFBSyxDQUFHLElBQVosQ0FDQSxHQUFJNmUsTUFBSyxDQUFHLENBQVosQ0FDQSxFQUFHLENBQ0QsR0FBSWt2QixLQUFJLENBQUd1SixLQUFLLENBQUM3Z0MsS0FBTixFQUFYLENBQ0EsR0FBSWs2QixPQUFNLENBQUcsSUFBYixDQUNBLEdBQUk0RyxXQUFVLENBQUcsS0FBakIsQ0FFQTtBQUNBLEdBQUd4c0MsR0FBRyxDQUFHZ2pDLElBQUksQ0FBQ2UsUUFBTCxDQUFjQyxTQUFwQixFQUFpQ2hrQyxHQUFHLENBQUdnakMsSUFBSSxDQUFDZSxRQUFMLENBQWNFLFFBQXhELENBQWtFLENBQ2hFaHZDLEtBQUssQ0FBRyxDQUNOeUMsT0FBTyxDQUFFLDhDQURILENBRU56QyxLQUFLLENBQUV3RyxHQUFHLENBQUNzd0MsZ0JBQUosQ0FBcUJJLG1CQUZ0QixDQUdObkksU0FBUyxDQUFFaEIsSUFBSSxDQUFDZSxRQUFMLENBQWNDLFNBSG5CLENBSU5DLFFBQVEsQ0FBRWpCLElBQUksQ0FBQ2UsUUFBTCxDQUFjRSxRQUpsQixDQUtOamtDLEdBQUcsQ0FBRUEsR0FMQyxDQUFSLENBT0QsQ0FFRDtBQUNBLEdBQUcvSyxLQUFLLEdBQUssSUFBYixDQUFtQixDQUNqQjJ3QyxNQUFNLENBQUcyRyxLQUFLLENBQUMsQ0FBRCxDQUFMLEVBQVluQixPQUFPLENBQUNDLFNBQVIsQ0FBa0JySSxJQUFsQixDQUFyQixDQUNBLEdBQUc0QyxNQUFNLEdBQUssSUFBZCxDQUFvQixDQUNsQjtBQUNBLEdBQUc1QyxJQUFJLENBQUMyQyxRQUFMLENBQWMzQyxJQUFkLENBQUgsQ0FBd0IsQ0FDdEJ3SixVQUFVLENBQUcsSUFBYixDQUNBNUcsTUFBTSxDQUFHNUMsSUFBVCxDQUNELENBQ0YsQ0FFRCxHQUFHNEMsTUFBSCxDQUFXLENBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUk2RyxRQUFPLENBQUc3RyxNQUFkLENBQ0EsR0FBRyxDQUFDN3FDLEtBQUssQ0FBQzJELElBQU4sQ0FBV21DLE9BQVgsQ0FBbUI0ckMsT0FBbkIsQ0FBSixDQUFpQyxDQUMvQkEsT0FBTyxDQUFHLENBQUNBLE9BQUQsQ0FBVixDQUNELENBRUQ7QUFDQSxHQUFJQyxTQUFRLENBQUcsS0FBZixDQUNBLE1BQU0sQ0FBQ0EsUUFBRCxFQUFhRCxPQUFPLENBQUN4NUMsTUFBUixDQUFpQixDQUFwQyxDQUF1QyxDQUNyQzJ5QyxNQUFNLENBQUc2RyxPQUFPLENBQUMvZ0MsS0FBUixFQUFULENBQ0EsR0FBSSxDQUNGZ2hDLFFBQVEsQ0FBRzlHLE1BQU0sQ0FBQzNsQixNQUFQLENBQWMraUIsSUFBZCxDQUFYLENBQ0QsQ0FBQyxNQUFNOTRCLEVBQU4sQ0FBVSxDQUNWO0FBQ0QsQ0FDRixDQUVELEdBQUcsQ0FBQ3dpQyxRQUFKLENBQWMsQ0FDWnozQyxLQUFLLENBQUcsQ0FDTnlDLE9BQU8sQ0FBRSxtQ0FESCxDQUVOekMsS0FBSyxDQUFFd0csR0FBRyxDQUFDc3dDLGdCQUFKLENBQXFCQyxlQUZ0QixDQUFSLENBSUQsQ0FDRixDQUVELEdBQUcvMkMsS0FBSyxHQUFLLElBQVYsR0FBbUIsQ0FBQzJ3QyxNQUFELEVBQVc0RyxVQUE5QixHQUNELENBQUNwQixPQUFPLENBQUNLLGNBQVIsQ0FBdUJ6SSxJQUF2QixDQURILENBQ2lDLENBQy9CO0FBQ0EvdEMsS0FBSyxDQUFHLENBQ055QyxPQUFPLENBQUUsNkJBREgsQ0FFTnpDLEtBQUssQ0FBRXdHLEdBQUcsQ0FBQ3N3QyxnQkFBSixDQUFxQk0sVUFGdEIsQ0FBUixDQUlELENBQ0YsQ0FFRDtBQUVBO0FBQ0EsR0FBR3AzQyxLQUFLLEdBQUssSUFBVixFQUFrQjJ3QyxNQUFsQixFQUE0QixDQUFDNUMsSUFBSSxDQUFDMkMsUUFBTCxDQUFjQyxNQUFkLENBQWhDLENBQXVELENBQ3JEO0FBQ0Ezd0MsS0FBSyxDQUFHLENBQ055QyxPQUFPLENBQUUsZ0NBREgsQ0FFTnpDLEtBQUssQ0FBRXdHLEdBQUcsQ0FBQ3N3QyxnQkFBSixDQUFxQkMsZUFGdEIsQ0FBUixDQUlELENBRUQ7QUFFQTtBQUVBO0FBQ0EsR0FBRy8yQyxLQUFLLEdBQUssSUFBYixDQUFtQixDQUNqQjtBQUNBLEdBQUkwM0MsR0FBRSxDQUFHLENBQ1BDLFFBQVEsQ0FBRSxJQURILENBRVBDLGdCQUFnQixDQUFFLElBRlgsQ0FBVCxDQUlBLElBQUksR0FBSTF2QyxFQUFDLENBQUcsQ0FBWixDQUFlbEksS0FBSyxHQUFLLElBQVYsRUFBa0JrSSxDQUFDLENBQUc2bEMsSUFBSSxDQUFDZixVQUFMLENBQWdCaHZDLE1BQXJELENBQTZELEVBQUVrSyxDQUEvRCxDQUFrRSxDQUNoRSxHQUFJNm5DLElBQUcsQ0FBR2hDLElBQUksQ0FBQ2YsVUFBTCxDQUFnQjlrQyxDQUFoQixDQUFWLENBQ0EsR0FBRzZuQyxHQUFHLENBQUN5QyxRQUFKLEVBQWdCLEVBQUV6QyxHQUFHLENBQUNyckMsSUFBSixHQUFZZ3pDLEdBQWQsQ0FBbkIsQ0FBc0MsQ0FDcEMxM0MsS0FBSyxDQUFHLENBQ055QyxPQUFPLENBQ0wsb0RBRkksQ0FHTnpDLEtBQUssQ0FBRXdHLEdBQUcsQ0FBQ3N3QyxnQkFBSixDQUFxQkUsdUJBSHRCLENBQVIsQ0FLRCxDQUNGLENBQ0YsQ0FFRDtBQUNBO0FBQ0EsR0FBR2gzQyxLQUFLLEdBQUssSUFBVixHQUNBLENBQUNndEIsS0FBRCxFQUFXc3FCLEtBQUssQ0FBQ3Q1QyxNQUFOLEdBQWlCLENBQWpCLEdBQXVCLENBQUMyeUMsTUFBRCxFQUFXNEcsVUFBbEMsQ0FEWCxDQUFILENBQytELENBQzdEO0FBQ0EsR0FBSU0sTUFBSyxDQUFHOUosSUFBSSxDQUFDK0IsWUFBTCxDQUFrQixrQkFBbEIsQ0FBWixDQUNBLEdBQUlnSSxZQUFXLENBQUcvSixJQUFJLENBQUMrQixZQUFMLENBQWtCLFVBQWxCLENBQWxCLENBQ0EsR0FBR2dJLFdBQVcsR0FBSyxJQUFuQixDQUF5QixDQUN2QjtBQUNBO0FBQ0EsR0FBRyxDQUFDQSxXQUFXLENBQUM5RSxXQUFiLEVBQTRCNkUsS0FBSyxHQUFLLElBQXpDLENBQStDLENBQzdDO0FBQ0E3M0MsS0FBSyxDQUFHLENBQ055QyxPQUFPLENBQ0wscURBQ0EsZ0RBREEsQ0FFQSxxREFGQSxDQUdBLGtEQUhBLENBSUEsV0FOSSxDQU9OekMsS0FBSyxDQUFFd0csR0FBRyxDQUFDc3dDLGdCQUFKLENBQXFCQyxlQVB0QixDQUFSLENBU0QsQ0FDRixDQUNEO0FBQ0EsR0FBRy8yQyxLQUFLLEdBQUssSUFBVixFQUFrQjYzQyxLQUFLLEdBQUssSUFBNUIsRUFBb0MsQ0FBQ0EsS0FBSyxDQUFDekUsRUFBOUMsQ0FBa0QsQ0FDaEQ7QUFDQXB6QyxLQUFLLENBQUcsQ0FDTnlDLE9BQU8sQ0FDTCwwREFDQSxjQUhJLENBSU56QyxLQUFLLENBQUV3RyxHQUFHLENBQUNzd0MsZ0JBQUosQ0FBcUJDLGVBSnRCLENBQVIsQ0FNRCxDQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUcvMkMsS0FBSyxHQUFLLElBQVYsRUFBa0I4M0MsV0FBVyxHQUFLLElBQWxDLEVBQ0QscUJBQXVCRCxNQUR6QixDQUNnQyxDQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUlFLFFBQU8sQ0FBR2w1QixLQUFLLENBQUcsQ0FBdEIsQ0FDQSxHQUFHazVCLE9BQU8sQ0FBR0YsS0FBSyxDQUFDeEUsaUJBQW5CLENBQXNDLENBQ3BDO0FBQ0FyekMsS0FBSyxDQUFHLENBQ055QyxPQUFPLENBQ0wsMERBRkksQ0FHTnpDLEtBQUssQ0FBRXdHLEdBQUcsQ0FBQ3N3QyxnQkFBSixDQUFxQkMsZUFIdEIsQ0FBUixDQUtELENBQ0YsQ0FDRixDQUVEO0FBQ0EsR0FBSWlCLElBQUcsQ0FBSWg0QyxLQUFLLEdBQUssSUFBWCxDQUFtQixJQUFuQixDQUEwQkEsS0FBSyxDQUFDQSxLQUExQyxDQUNBLEdBQUlpNEMsSUFBRyxDQUFHanRCLE1BQU0sQ0FBR0EsTUFBTSxDQUFDZ3RCLEdBQUQsQ0FBTW41QixLQUFOLENBQWFxM0IsS0FBYixDQUFULENBQStCOEIsR0FBL0MsQ0FDQSxHQUFHQyxHQUFHLEdBQUssSUFBWCxDQUFpQixDQUNmO0FBQ0FqNEMsS0FBSyxDQUFHLElBQVIsQ0FDRCxDQUhELElBR08sQ0FDTDtBQUNBLEdBQUdnNEMsR0FBRyxHQUFLLElBQVgsQ0FBaUIsQ0FDZmg0QyxLQUFLLENBQUcsQ0FDTnlDLE9BQU8sQ0FBRSwyQ0FESCxDQUVOekMsS0FBSyxDQUFFd0csR0FBRyxDQUFDc3dDLGdCQUFKLENBQXFCQyxlQUZ0QixDQUFSLENBSUQsQ0FFRDtBQUNBLEdBQUdrQixHQUFHLEVBQUlBLEdBQUcsR0FBSyxDQUFsQixDQUFxQixDQUNuQjtBQUNBLEdBQUcsUUFBT0EsR0FBUCxJQUFlLFFBQWYsRUFBMkIsQ0FBQ255QyxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1CcXNDLEdBQW5CLENBQS9CLENBQXdELENBQ3RELEdBQUdBLEdBQUcsQ0FBQ3gxQyxPQUFQLENBQWdCLENBQ2J6QyxLQUFLLENBQUN5QyxPQUFOLENBQWdCdzFDLEdBQUcsQ0FBQ3gxQyxPQUFwQixDQUNGLENBQ0QsR0FBR3cxQyxHQUFHLENBQUNqNEMsS0FBUCxDQUFjLENBQ1pBLEtBQUssQ0FBQ0EsS0FBTixDQUFjaTRDLEdBQUcsQ0FBQ2o0QyxLQUFsQixDQUNELENBQ0YsQ0FQRCxJQU9PLElBQUcsTUFBT2k0QyxJQUFQLEdBQWUsUUFBbEIsQ0FBNEIsQ0FDakM7QUFDQWo0QyxLQUFLLENBQUNBLEtBQU4sQ0FBY2k0QyxHQUFkLENBQ0QsQ0FDRixDQUVEO0FBQ0EsS0FBTWo0QyxNQUFOLENBQ0QsQ0FFRDtBQUNBZ3RCLEtBQUssQ0FBRyxLQUFSLENBQ0EsRUFBRW5PLEtBQUYsQ0FDRCxDQXBNRCxNQW9NUXk0QixLQUFLLENBQUN0NUMsTUFBTixDQUFlLENBcE12QixFQXNNQSxNQUFPLEtBQVAsQ0FDRCxDQXRWRCxDQXlWQSxLQUFPLENBM2xmRyxDQTRsZlYsUUE1bGZVLENBNmxmVixLQUFPLFNBQVMySixNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7R0FPQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQTtBQUNBLEdBQUl5b0MsSUFBRyxDQUFHOW9DLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVCLEtBQUssQ0FBQzJxQyxHQUFOLENBQVkzcUMsS0FBSyxDQUFDMnFDLEdBQU4sRUFBYSxFQUFwRCxDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkFBLEdBQUcsQ0FBQ2x3QyxNQUFKLENBQWEsU0FBU2xELE9BQVQsQ0FBa0IsQ0FDN0I7QUFDQSxHQUFHMk0sU0FBUyxDQUFDaE0sTUFBVixHQUFxQixDQUF4QixDQUEyQixDQUN6QlgsT0FBTyxDQUFHLENBQ1I4bEIsRUFBRSxDQUFFblosU0FBUyxDQUFDLENBQUQsQ0FETCxDQUVSc2pDLEdBQUcsQ0FBRXRqQyxTQUFTLENBQUMsQ0FBRCxDQUZOLENBR1J1akMsVUFBVSxDQUFFdmpDLFNBQVMsQ0FBQyxDQUFELENBSGIsQ0FBVixDQUtELENBRUQsR0FBSTFFLEtBQUksQ0FBR2pJLE9BQU8sQ0FBQzhsQixFQUFuQixDQUNBLEdBQUltcUIsSUFBRyxDQUFHandDLE9BQU8sQ0FBQ2l3QyxHQUFsQixDQUNBLEdBQUlsUSxLQUFJLENBQUc5M0IsSUFBSSxDQUFDa3dCLFlBQWhCLENBRUEsR0FBSTBpQixNQUFLLENBQUc3NkMsT0FBTyxDQUFDazJCLElBQVIsRUFBZ0IsSUFBNUIsQ0FDQSxHQUFHLE1BQU8ya0IsTUFBUCxHQUFpQixRQUFwQixDQUE4QixDQUM1QjtBQUNBQSxLQUFLLENBQUdweUMsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxDQUF3QjZvQyxLQUF4QixDQUFSLENBQ0QsQ0FFRCxHQUFJQyxLQUFKLENBQ0EsR0FBRyxjQUFnQjk2QyxRQUFuQixDQUE0QixDQUMxQjg2QyxJQUFJLENBQUc5NkMsT0FBTyxDQUFDa3dDLFVBQWYsQ0FDRCxDQUZELElBRU8sSUFBRzJLLEtBQUssR0FBSyxJQUFiLENBQW1CLENBQ3hCQyxJQUFJLENBQUdELEtBQUssQ0FBQ2w2QyxNQUFOLEVBQVAsQ0FDRCxDQUZNLElBRUEsQ0FDTCxLQUFNLElBQUlGLE1BQUosQ0FBVSx1REFBVixDQUFOLENBQ0QsQ0FFRCxHQUFHbzZDLEtBQUssR0FBSyxJQUFWLEVBQWtCQSxLQUFLLENBQUNsNkMsTUFBTixLQUFtQm02QyxJQUF4QyxDQUE4QyxDQUM1QyxLQUFNLElBQUlyNkMsTUFBSixDQUFVLHdEQUFWLENBQU4sQ0FDRCxDQUVELEdBQUlxbUIsS0FBSSxDQUFHOW1CLE9BQU8sQ0FBQzhtQixJQUFSLEVBQWdCcmUsS0FBSyxDQUFDakIsTUFBakMsQ0FFQSxHQUFJdXpDLE9BQU0sQ0FBRyxFQUFiLENBRUE7Ozs7Ozs7Ozs7S0FXQUEsTUFBTSxDQUFDbm5DLE1BQVAsQ0FBZ0IsU0FBU2tTLEVBQVQsQ0FBYWsxQixPQUFiLENBQXNCLENBQ3BDLEdBQUlud0MsRUFBSixDQUNBLEdBQUlvd0MsT0FBTSxDQUFHRCxPQUFPLENBQUcsQ0FBdkIsQ0FDQSxHQUFJRSxNQUFLLENBQUczekMsSUFBSSxDQUFDOEwsSUFBTCxDQUFVNG5DLE1BQU0sQ0FBRyxDQUFuQixDQUFaLENBRUEsNkRBQ0EsR0FBSUUsTUFBSyxDQUFHcjFCLEVBQUUsQ0FBQzRDLE1BQUgsR0FBWTdYLFFBQVosRUFBWixDQUVBLHNFQUNBLEdBQUdxcUMsS0FBSyxDQUFHbmIsSUFBSSxDQUFHK2EsSUFBUCxDQUFjLENBQXpCLENBQTRCLENBQzFCLEtBQU0sSUFBSXI2QyxNQUFKLENBQVUsaUNBQVYsQ0FBTixDQUNELENBRUQ7MkNBRUEsR0FBSXkxQixLQUFKLENBQ0EsR0FBRzJrQixLQUFLLEdBQUssSUFBYixDQUFtQixDQUNqQjNrQixJQUFJLENBQUdwUCxJQUFJLENBQUNDLFlBQUwsQ0FBa0IrekIsSUFBbEIsQ0FBUCxDQUNELENBRkQsSUFFTyxDQUNMNWtCLElBQUksQ0FBRzJrQixLQUFLLENBQUM3cUMsS0FBTixFQUFQLENBQ0QsQ0FFRCwrREFDQSxHQUFJb3JDLEdBQUUsQ0FBRyxHQUFJM3lDLE1BQUssQ0FBQzJELElBQU4sQ0FBVzJDLFVBQWYsRUFBVCxDQUNBcXNDLEVBQUUsQ0FBQ3JyQyxZQUFILENBQWdCLENBQWhCLENBQW1CLENBQW5CLEVBQ0FxckMsRUFBRSxDQUFDdHJDLFFBQUgsQ0FBWXFyQyxLQUFaLEVBQ0FDLEVBQUUsQ0FBQ3RyQyxRQUFILENBQVlvbUIsSUFBWixFQUVBLDBEQUNBanVCLElBQUksQ0FBQ3VPLEtBQUwsR0FDQXZPLElBQUksQ0FBQ3dVLE1BQUwsQ0FBWTIrQixFQUFFLENBQUN2cUMsUUFBSCxFQUFaLEVBQ0EsR0FBSXFzQixFQUFDLENBQUdqMUIsSUFBSSxDQUFDeWdCLE1BQUwsR0FBYzdYLFFBQWQsRUFBUixDQUVBO3FEQUVBLEdBQUl3cUMsR0FBRSxDQUFHLEdBQUk1eUMsTUFBSyxDQUFDMkQsSUFBTixDQUFXMkMsVUFBZixFQUFULENBQ0Fzc0MsRUFBRSxDQUFDdHJDLFlBQUgsQ0FBZ0IsQ0FBaEIsQ0FBbUJtckMsS0FBSyxDQUFHSixJQUFSLENBQWUvYSxJQUFmLENBQXNCLENBQXpDLEVBRUE7OEJBRUFzYixFQUFFLENBQUM1ckMsT0FBSCxDQUFXLElBQVgsRUFDQTRyQyxFQUFFLENBQUN2ckMsUUFBSCxDQUFZb21CLElBQVosRUFDQSxHQUFJb2xCLEdBQUUsQ0FBR0QsRUFBRSxDQUFDeHFDLFFBQUgsRUFBVCxDQUVBLCtDQUNBLEdBQUkwcUMsUUFBTyxDQUFHTCxLQUFLLENBQUduYixJQUFSLENBQWUsQ0FBN0IsQ0FDQSxHQUFJeWIsT0FBTSxDQUFHdkwsR0FBRyxDQUFDdG5DLFFBQUosQ0FBYXUwQixDQUFiLENBQWdCcWUsT0FBaEIsQ0FBYixDQUVBLHdDQUNBLEdBQUlFLFNBQVEsQ0FBRyxFQUFmLENBQ0EsSUFBSTV3QyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUcwd0MsT0FBZixDQUF3QjF3QyxDQUFDLEVBQXpCLENBQTZCLENBQzNCNHdDLFFBQVEsRUFBSW5zQyxNQUFNLENBQUNDLFlBQVAsQ0FBb0IrckMsRUFBRSxDQUFDdnFDLFVBQUgsQ0FBY2xHLENBQWQsRUFBbUIyd0MsTUFBTSxDQUFDenFDLFVBQVAsQ0FBa0JsRyxDQUFsQixDQUF2QyxDQUFaLENBQ0QsQ0FFRDsrQkFFQSxHQUFJNndDLEtBQUksQ0FBSSxRQUFXLEVBQUlSLEtBQUosQ0FBWUQsTUFBeEIsQ0FBbUMsSUFBOUMsQ0FDQVEsUUFBUSxDQUFHbnNDLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQmtzQyxRQUFRLENBQUMxcUMsVUFBVCxDQUFvQixDQUFwQixFQUF5QixDQUFDMnFDLElBQTlDLEVBQ1RELFFBQVEsQ0FBQy96QyxNQUFULENBQWdCLENBQWhCLENBREYsQ0FHQTt3QkFFQSxNQUFPK3pDLFNBQVEsQ0FBR3ZlLENBQVgsQ0FBZTV0QixNQUFNLENBQUNDLFlBQVAsQ0FBb0IsSUFBcEIsQ0FBdEIsQ0FDRCxDQS9ERCxDQWlFQTs7Ozs7Ozs7Ozs7O0tBYUF3ckMsTUFBTSxDQUFDcHRCLE1BQVAsQ0FBZ0IsU0FBU3d0QixLQUFULENBQWdCenJCLEVBQWhCLENBQW9Cc3JCLE9BQXBCLENBQTZCLENBQzNDLEdBQUlud0MsRUFBSixDQUNBLEdBQUlvd0MsT0FBTSxDQUFHRCxPQUFPLENBQUcsQ0FBdkIsQ0FDQSxHQUFJRSxNQUFLLENBQUczekMsSUFBSSxDQUFDOEwsSUFBTCxDQUFVNG5DLE1BQU0sQ0FBRyxDQUFuQixDQUFaLENBRUE7O3VEQUdBdnJCLEVBQUUsQ0FBR0EsRUFBRSxDQUFDaG9CLE1BQUgsQ0FBVSxDQUFDd3pDLEtBQVgsQ0FBTCxDQUVBLG9FQUNBLEdBQUdBLEtBQUssQ0FBR25iLElBQUksQ0FBRythLElBQVAsQ0FBYyxDQUF6QixDQUE0QixDQUMxQixLQUFNLElBQUlyNkMsTUFBSixDQUFVLHdEQUFWLENBQU4sQ0FDRCxDQUVEO2tEQUVBLEdBQUdpdkIsRUFBRSxDQUFDM2UsVUFBSCxDQUFjbXFDLEtBQUssQ0FBRyxDQUF0QixJQUE2QixJQUFoQyxDQUFzQyxDQUNwQyxLQUFNLElBQUl6NkMsTUFBSixDQUFVLHVDQUFWLENBQU4sQ0FDRCxDQUVEOzJDQUVBLEdBQUk4NkMsUUFBTyxDQUFHTCxLQUFLLENBQUduYixJQUFSLENBQWUsQ0FBN0IsQ0FDQSxHQUFJMGIsU0FBUSxDQUFHL3JCLEVBQUUsQ0FBQ2hvQixNQUFILENBQVUsQ0FBVixDQUFhNnpDLE9BQWIsQ0FBZixDQUNBLEdBQUlyZSxFQUFDLENBQUd4TixFQUFFLENBQUNob0IsTUFBSCxDQUFVNnpDLE9BQVYsQ0FBbUJ4YixJQUFuQixDQUFSLENBRUE7Z0ZBRUEsR0FBSTJiLEtBQUksQ0FBSSxRQUFXLEVBQUlSLEtBQUosQ0FBWUQsTUFBeEIsQ0FBbUMsSUFBOUMsQ0FDQSxHQUFHLENBQUNRLFFBQVEsQ0FBQzFxQyxVQUFULENBQW9CLENBQXBCLEVBQXlCMnFDLElBQTFCLElBQW9DLENBQXZDLENBQTBDLENBQ3hDLEtBQU0sSUFBSWo3QyxNQUFKLENBQVUsMkNBQVYsQ0FBTixDQUNELENBRUQsK0NBQ0EsR0FBSSs2QyxPQUFNLENBQUd2TCxHQUFHLENBQUN0bkMsUUFBSixDQUFhdTBCLENBQWIsQ0FBZ0JxZSxPQUFoQixDQUFiLENBRUEsdUNBQ0EsR0FBSUQsR0FBRSxDQUFHLEVBQVQsQ0FDQSxJQUFJendDLENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsQ0FBRzB3QyxPQUFmLENBQXdCMXdDLENBQUMsRUFBekIsQ0FBNkIsQ0FDM0J5d0MsRUFBRSxFQUFJaHNDLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQmtzQyxRQUFRLENBQUMxcUMsVUFBVCxDQUFvQmxHLENBQXBCLEVBQXlCMndDLE1BQU0sQ0FBQ3pxQyxVQUFQLENBQWtCbEcsQ0FBbEIsQ0FBN0MsQ0FBTixDQUNELENBRUQ7d0JBRUF5d0MsRUFBRSxDQUFHaHNDLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQityQyxFQUFFLENBQUN2cUMsVUFBSCxDQUFjLENBQWQsRUFBbUIsQ0FBQzJxQyxJQUF4QyxFQUFnREosRUFBRSxDQUFDNXpDLE1BQUgsQ0FBVSxDQUFWLENBQXJELENBRUE7Ozt5Q0FJQSxHQUFJaTBDLFNBQVEsQ0FBR1QsS0FBSyxDQUFHbmIsSUFBUixDQUFlK2EsSUFBZixDQUFzQixDQUFyQyxDQUNBLElBQUlqd0MsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHOHdDLFFBQWYsQ0FBeUI5d0MsQ0FBQyxFQUExQixDQUE4QixDQUM1QixHQUFHeXdDLEVBQUUsQ0FBQ3ZxQyxVQUFILENBQWNsRyxDQUFkLElBQXFCLElBQXhCLENBQThCLENBQzVCLEtBQU0sSUFBSXBLLE1BQUosQ0FBVSxzQ0FBVixDQUFOLENBQ0QsQ0FDRixDQUVELEdBQUc2NkMsRUFBRSxDQUFDdnFDLFVBQUgsQ0FBYzRxQyxRQUFkLElBQTRCLElBQS9CLENBQXFDLENBQ25DLEtBQU0sSUFBSWw3QyxNQUFKLENBQVUsbURBQVYsQ0FBTixDQUNELENBRUQsaURBQ0EsR0FBSXkxQixLQUFJLENBQUdvbEIsRUFBRSxDQUFDNXpDLE1BQUgsQ0FBVSxDQUFDb3pDLElBQVgsQ0FBWCxDQUVBLGdFQUNBLEdBQUlNLEdBQUUsQ0FBRyxHQUFJM3lDLE1BQUssQ0FBQzJELElBQU4sQ0FBVzJDLFVBQWYsRUFBVCxDQUNBcXNDLEVBQUUsQ0FBQ3JyQyxZQUFILENBQWdCLENBQWhCLENBQW1CLENBQW5CLEVBQ0FxckMsRUFBRSxDQUFDdHJDLFFBQUgsQ0FBWXFyQyxLQUFaLEVBQ0FDLEVBQUUsQ0FBQ3RyQyxRQUFILENBQVlvbUIsSUFBWixFQUVBLDREQUNBanVCLElBQUksQ0FBQ3VPLEtBQUwsR0FDQXZPLElBQUksQ0FBQ3dVLE1BQUwsQ0FBWTIrQixFQUFFLENBQUN2cUMsUUFBSCxFQUFaLEVBQ0EsR0FBSStxQyxHQUFFLENBQUczekMsSUFBSSxDQUFDeWdCLE1BQUwsR0FBYzdYLFFBQWQsRUFBVCxDQUVBLDJFQUNBLE1BQU9xc0IsRUFBQyxHQUFLMGUsRUFBYixDQUNELENBOUVELENBZ0ZBLE1BQU9iLE9BQVAsQ0FDRCxDQS9NRCxDQWtOQSxLQUFPLENBbDFmRyxDQW0xZlYsUUFuMWZVLENBbzFmVixLQUFPLFNBQVN6d0MsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0REEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBTCxNQUFNLENBQUNELE9BQVAsQ0FBaUJNLG1CQUFtQixDQUFDLENBQUQsQ0FBcEMsQ0FHQSxLQUFPLENBMTFmRyxDQTIxZlYsUUEzMWZVLENBNDFmVixLQUFPLFNBQVNMLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7Ozs7R0FRQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxFQUFELENBQW5CLENBRUE7QUFDQSxHQUFJd1QsS0FBSSxDQUFHMVYsS0FBSyxDQUFDMFYsSUFBakIsQ0FFQSxxREFDQSxHQUFJaFYsSUFBRyxDQUFHbUIsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDVSxHQUFOLENBQVlWLEtBQUssQ0FBQ1UsR0FBTixFQUFhLEVBQXBELENBRUE7Ozs7Ozs7O0dBU0FBLEdBQUcsQ0FBQzB5QyxRQUFKLENBQWUsU0FBU3huQixHQUFULENBQWMsQ0FDM0IsR0FBSXBuQixJQUFHLENBQUd4RSxLQUFLLENBQUM0ckIsR0FBTixDQUFVN2dCLE1BQVYsQ0FBaUI2Z0IsR0FBakIsRUFBc0IsQ0FBdEIsQ0FBVixDQUNBLEdBQUdwbkIsR0FBRyxDQUFDc25CLFFBQUosRUFBZ0J0bkIsR0FBRyxDQUFDc25CLFFBQUosQ0FBYS9jLElBQWIsR0FBc0IsV0FBekMsQ0FBc0QsQ0FDcEQsS0FBTSxJQUFJL1csTUFBSixDQUFVLGlEQUFWLENBQU4sQ0FDRCxDQUNELE1BQU9nSSxNQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLENBQXdCL0UsR0FBRyxDQUFDNG5CLElBQTVCLENBQVAsQ0FDRCxDQU5ELENBUUE7Ozs7OztHQU9BMXJCLEdBQUcsQ0FBQzJ5QyxpQkFBSixDQUF3QixTQUFTem5CLEdBQVQsQ0FBYyxDQUNwQyxHQUFJcG5CLElBQUcsQ0FBR3hFLEtBQUssQ0FBQzRyQixHQUFOLENBQVU3Z0IsTUFBVixDQUFpQjZnQixHQUFqQixFQUFzQixDQUF0QixDQUFWLENBRUEsR0FBR3BuQixHQUFHLENBQUN1SyxJQUFKLEdBQWEsYUFBYixFQUE4QnZLLEdBQUcsQ0FBQ3VLLElBQUosR0FBYSxpQkFBOUMsQ0FBaUUsQ0FDL0QsR0FBSTdVLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLCtDQUNwQix3REFEVSxDQUFaLENBRUFrQyxLQUFLLENBQUMrMEIsVUFBTixDQUFtQnpxQixHQUFHLENBQUN1SyxJQUF2QixDQUNBLEtBQU03VSxNQUFOLENBQ0QsQ0FDRCxHQUFHc0ssR0FBRyxDQUFDc25CLFFBQUosRUFBZ0J0bkIsR0FBRyxDQUFDc25CLFFBQUosQ0FBYS9jLElBQWIsR0FBc0IsV0FBekMsQ0FBc0QsQ0FDcEQsS0FBTSxJQUFJL1csTUFBSixDQUFVLDJEQUFWLENBQU4sQ0FDRCxDQUVEO0FBQ0EsR0FBSXFXLElBQUcsQ0FBR3FILElBQUksQ0FBQ2lELE9BQUwsQ0FBYW5VLEdBQUcsQ0FBQzRuQixJQUFqQixDQUFWLENBRUEsTUFBTzFyQixJQUFHLENBQUMyakIsa0JBQUosQ0FBdUJoVyxHQUF2QixDQUFQLENBQ0QsQ0FqQkQsQ0FtQkE7Ozs7Ozs7R0FRQTNOLEdBQUcsQ0FBQ0ksZUFBSixDQUFzQixTQUFTN0csR0FBVCxDQUFjd1MsT0FBZCxDQUF1QixDQUMzQztBQUNBLEdBQUlqSSxJQUFHLENBQUcsQ0FDUnVLLElBQUksQ0FBRSxpQkFERSxDQUVScWQsSUFBSSxDQUFFMVcsSUFBSSxDQUFDK0QsS0FBTCxDQUFXL1ksR0FBRyxDQUFDd2xCLGdCQUFKLENBQXFCanNCLEdBQXJCLENBQVgsRUFBc0NtTyxRQUF0QyxFQUZFLENBQVYsQ0FJQSxNQUFPcEksTUFBSyxDQUFDNHJCLEdBQU4sQ0FBVXpnQixNQUFWLENBQWlCM0csR0FBakIsQ0FBc0IsQ0FBQ2lJLE9BQU8sQ0FBRUEsT0FBVixDQUF0QixDQUFQLENBQ0QsQ0FQRCxDQVNBOzs7Ozs7O0dBUUEvTCxHQUFHLENBQUM0eUMsbUJBQUosQ0FBMEIsU0FBUzV5QyxHQUFULENBQWMrTCxPQUFkLENBQXVCLENBQy9DO0FBQ0EsR0FBSWpJLElBQUcsQ0FBRyxDQUNSdUssSUFBSSxDQUFFLGFBREUsQ0FFUnFkLElBQUksQ0FBRTFXLElBQUksQ0FBQytELEtBQUwsQ0FBVy9ZLEdBQVgsRUFBZ0IwSCxRQUFoQixFQUZFLENBQVYsQ0FJQSxNQUFPcEksTUFBSyxDQUFDNHJCLEdBQU4sQ0FBVXpnQixNQUFWLENBQWlCM0csR0FBakIsQ0FBc0IsQ0FBQ2lJLE9BQU8sQ0FBRUEsT0FBVixDQUF0QixDQUFQLENBQ0QsQ0FQRCxDQVVBLEtBQU8sQ0F0OGZHLENBdThmVixRQXY4ZlUsQ0F3OGZWLEtBQU8sU0FBUzVLLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCLENBRWpDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQThCQSxHQUFJaEssSUFBRyxDQUFHLEVBQVYsQ0FDQWlLLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQmhLLEdBQWpCLENBRUE7QUFDQSxHQUFJMjdDLGtCQUFpQixDQUFHLEVBQXhCLENBRUE7Ozs7Ozs7O0dBU0EzN0MsR0FBRyxDQUFDdVQsTUFBSixDQUFhLFNBQVNPLEtBQVQsQ0FBZ0I4bkMsUUFBaEIsQ0FBMEIvbUMsT0FBMUIsQ0FBbUMsQ0FDOUMsR0FBRyxNQUFPK21DLFNBQVAsR0FBb0IsUUFBdkIsQ0FBaUMsQ0FDL0IsS0FBTSxJQUFJQyxVQUFKLENBQWMsOEJBQWQsQ0FBTixDQUNELENBQ0QsR0FBR2huQyxPQUFPLEdBQUt4SSxTQUFaLEVBQXlCLE1BQU93SSxRQUFQLEdBQW1CLFFBQS9DLENBQXlELENBQ3ZELEtBQU0sSUFBSWduQyxVQUFKLENBQWMsNkJBQWQsQ0FBTixDQUNELENBRUQsR0FBSTltQyxPQUFNLENBQUcsRUFBYixDQUVBLEdBQUcsRUFBRWpCLEtBQUssV0FBWTlFLFdBQW5CLENBQUgsQ0FBbUMsQ0FDakM7QUFDQStGLE1BQU0sQ0FBRyttQyxxQkFBcUIsQ0FBQ2hvQyxLQUFELENBQVE4bkMsUUFBUixDQUE5QixDQUNELENBSEQsSUFHTyxDQUNMLEdBQUlweEMsRUFBQyxDQUFHLENBQVIsQ0FDQSxHQUFJdXhDLEtBQUksQ0FBR0gsUUFBUSxDQUFDdDdDLE1BQXBCLENBQ0EsR0FBSWd2QixNQUFLLENBQUdzc0IsUUFBUSxDQUFDem1DLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBWixDQUNBLEdBQUk2bUMsT0FBTSxDQUFHLENBQUMsQ0FBRCxDQUFiLENBQ0EsSUFBSXh4QyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUdzSixLQUFLLENBQUN4VCxNQUFyQixDQUE2QixFQUFFa0ssQ0FBL0IsQ0FBa0MsQ0FDaEMsSUFBSSxHQUFJd0wsRUFBQyxDQUFHLENBQVIsQ0FBV3c0QixLQUFLLENBQUcxNkIsS0FBSyxDQUFDdEosQ0FBRCxDQUE1QixDQUFpQ3dMLENBQUMsQ0FBR2dtQyxNQUFNLENBQUMxN0MsTUFBNUMsQ0FBb0QsRUFBRTBWLENBQXRELENBQXlELENBQ3ZEdzRCLEtBQUssRUFBSXdOLE1BQU0sQ0FBQ2htQyxDQUFELENBQU4sRUFBYSxDQUF0QixDQUNBZ21DLE1BQU0sQ0FBQ2htQyxDQUFELENBQU4sQ0FBWXc0QixLQUFLLENBQUd1TixJQUFwQixDQUNBdk4sS0FBSyxDQUFJQSxLQUFLLENBQUd1TixJQUFULENBQWlCLENBQXpCLENBQ0QsQ0FFRCxNQUFNdk4sS0FBSyxDQUFHLENBQWQsQ0FBaUIsQ0FDZndOLE1BQU0sQ0FBQzl1QyxJQUFQLENBQVlzaEMsS0FBSyxDQUFHdU4sSUFBcEIsRUFDQXZOLEtBQUssQ0FBSUEsS0FBSyxDQUFHdU4sSUFBVCxDQUFpQixDQUF6QixDQUNELENBQ0YsQ0FFRDtBQUNBLElBQUl2eEMsQ0FBQyxDQUFHLENBQVIsQ0FBV3NKLEtBQUssQ0FBQ3RKLENBQUQsQ0FBTCxHQUFhLENBQWIsRUFBa0JBLENBQUMsQ0FBR3NKLEtBQUssQ0FBQ3hULE1BQU4sQ0FBZSxDQUFoRCxDQUFtRCxFQUFFa0ssQ0FBckQsQ0FBd0QsQ0FDdER1SyxNQUFNLEVBQUl1YSxLQUFWLENBQ0QsQ0FDRDtBQUNBLElBQUk5a0IsQ0FBQyxDQUFHd3hDLE1BQU0sQ0FBQzE3QyxNQUFQLENBQWdCLENBQXhCLENBQTJCa0ssQ0FBQyxFQUFJLENBQWhDLENBQW1DLEVBQUVBLENBQXJDLENBQXdDLENBQ3RDdUssTUFBTSxFQUFJNm1DLFFBQVEsQ0FBQ0ksTUFBTSxDQUFDeHhDLENBQUQsQ0FBUCxDQUFsQixDQUNELENBQ0YsQ0FFRCxHQUFHcUssT0FBSCxDQUFZLENBQ1YsR0FBSTZDLE1BQUssQ0FBRyxHQUFJM1YsT0FBSixDQUFXLE9BQVM4UyxPQUFULENBQW1CLEdBQTlCLENBQW1DLEdBQW5DLENBQVosQ0FDQUUsTUFBTSxDQUFHQSxNQUFNLENBQUN1RixLQUFQLENBQWE1QyxLQUFiLEVBQW9CL1csSUFBcEIsQ0FBeUIsTUFBekIsQ0FBVCxDQUNELENBRUQsTUFBT29VLE9BQVAsQ0FDRCxDQS9DRCxDQWlEQTs7Ozs7OztHQVFBL1UsR0FBRyxDQUFDbVQsTUFBSixDQUFhLFNBQVNXLEtBQVQsQ0FBZ0I4bkMsUUFBaEIsQ0FBMEIsQ0FDckMsR0FBRyxNQUFPOW5DLE1BQVAsR0FBaUIsUUFBcEIsQ0FBOEIsQ0FDNUIsS0FBTSxJQUFJK25DLFVBQUosQ0FBYywyQkFBZCxDQUFOLENBQ0QsQ0FDRCxHQUFHLE1BQU9ELFNBQVAsR0FBb0IsUUFBdkIsQ0FBaUMsQ0FDL0IsS0FBTSxJQUFJQyxVQUFKLENBQWMsOEJBQWQsQ0FBTixDQUNELENBRUQsR0FBSUksTUFBSyxDQUFHTixpQkFBaUIsQ0FBQ0MsUUFBRCxDQUE3QixDQUNBLEdBQUcsQ0FBQ0ssS0FBSixDQUFXLENBQ1Q7QUFDQUEsS0FBSyxDQUFHTixpQkFBaUIsQ0FBQ0MsUUFBRCxDQUFqQixDQUE4QixFQUF0QyxDQUNBLElBQUksR0FBSXB4QyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdveEMsUUFBUSxDQUFDdDdDLE1BQTVCLENBQW9DLEVBQUVrSyxDQUF0QyxDQUF5QyxDQUN2Q3l4QyxLQUFLLENBQUNMLFFBQVEsQ0FBQ2xyQyxVQUFULENBQW9CbEcsQ0FBcEIsQ0FBRCxDQUFMLENBQWdDQSxDQUFoQyxDQUNELENBQ0YsQ0FFRDtBQUNBc0osS0FBSyxDQUFHQSxLQUFLLENBQUNwVCxPQUFOLENBQWMsS0FBZCxDQUFxQixFQUFyQixDQUFSLENBRUEsR0FBSXE3QyxLQUFJLENBQUdILFFBQVEsQ0FBQ3Q3QyxNQUFwQixDQUNBLEdBQUlndkIsTUFBSyxDQUFHc3NCLFFBQVEsQ0FBQ3ptQyxNQUFULENBQWdCLENBQWhCLENBQVosQ0FDQSxHQUFJeEYsTUFBSyxDQUFHLENBQUMsQ0FBRCxDQUFaLENBQ0EsSUFBSSxHQUFJbkYsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHc0osS0FBSyxDQUFDeFQsTUFBekIsQ0FBaUNrSyxDQUFDLEVBQWxDLENBQXNDLENBQ3BDLEdBQUl3UCxNQUFLLENBQUdpaUMsS0FBSyxDQUFDbm9DLEtBQUssQ0FBQ3BELFVBQU4sQ0FBaUJsRyxDQUFqQixDQUFELENBQWpCLENBQ0EsR0FBR3dQLEtBQUssR0FBSzNOLFNBQWIsQ0FBd0IsQ0FDdEIsT0FDRCxDQUVELElBQUksR0FBSTJKLEVBQUMsQ0FBRyxDQUFSLENBQVd3NEIsS0FBSyxDQUFHeDBCLEtBQXZCLENBQThCaEUsQ0FBQyxDQUFHckcsS0FBSyxDQUFDclAsTUFBeEMsQ0FBZ0QsRUFBRTBWLENBQWxELENBQXFELENBQ25EdzRCLEtBQUssRUFBSTcrQixLQUFLLENBQUNxRyxDQUFELENBQUwsQ0FBVytsQyxJQUFwQixDQUNBcHNDLEtBQUssQ0FBQ3FHLENBQUQsQ0FBTCxDQUFXdzRCLEtBQUssQ0FBRyxJQUFuQixDQUNBQSxLQUFLLEdBQUssQ0FBVixDQUNELENBRUQsTUFBTUEsS0FBSyxDQUFHLENBQWQsQ0FBaUIsQ0FDZjcrQixLQUFLLENBQUN6QyxJQUFOLENBQVdzaEMsS0FBSyxDQUFHLElBQW5CLEVBQ0FBLEtBQUssR0FBSyxDQUFWLENBQ0QsQ0FDRixDQUVEO0FBQ0EsSUFBSSxHQUFJMW5DLEVBQUMsQ0FBRyxDQUFaLENBQWVnTixLQUFLLENBQUNoTixDQUFELENBQUwsR0FBYXdvQixLQUFiLEVBQXNCeG9CLENBQUMsQ0FBR2dOLEtBQUssQ0FBQ3hULE1BQU4sQ0FBZSxDQUF4RCxDQUEyRCxFQUFFd0csQ0FBN0QsQ0FBZ0UsQ0FDOUQ2SSxLQUFLLENBQUN6QyxJQUFOLENBQVcsQ0FBWCxFQUNELENBRUQsR0FBRyxNQUFPNEIsT0FBUCxHQUFrQixXQUFyQixDQUFrQyxDQUNoQyxNQUFPQSxPQUFNLENBQUNvdEMsSUFBUCxDQUFZdnNDLEtBQUssQ0FBQ3RMLE9BQU4sRUFBWixDQUFQLENBQ0QsQ0FFRCxNQUFPLElBQUkySyxXQUFKLENBQWVXLEtBQUssQ0FBQ3RMLE9BQU4sRUFBZixDQUFQLENBQ0QsQ0FuREQsQ0FxREEsUUFBU3kzQyxzQkFBVCxDQUErQmhvQyxLQUEvQixDQUFzQzhuQyxRQUF0QyxDQUFnRCxDQUM5QyxHQUFJcHhDLEVBQUMsQ0FBRyxDQUFSLENBQ0EsR0FBSXV4QyxLQUFJLENBQUdILFFBQVEsQ0FBQ3Q3QyxNQUFwQixDQUNBLEdBQUlndkIsTUFBSyxDQUFHc3NCLFFBQVEsQ0FBQ3ptQyxNQUFULENBQWdCLENBQWhCLENBQVosQ0FDQSxHQUFJNm1DLE9BQU0sQ0FBRyxDQUFDLENBQUQsQ0FBYixDQUNBLElBQUl4eEMsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHc0osS0FBSyxDQUFDeFQsTUFBTixFQUFmLENBQStCLEVBQUVrSyxDQUFqQyxDQUFvQyxDQUNsQyxJQUFJLEdBQUl3TCxFQUFDLENBQUcsQ0FBUixDQUFXdzRCLEtBQUssQ0FBRzE2QixLQUFLLENBQUN0QyxFQUFOLENBQVNoSCxDQUFULENBQXZCLENBQW9Dd0wsQ0FBQyxDQUFHZ21DLE1BQU0sQ0FBQzE3QyxNQUEvQyxDQUF1RCxFQUFFMFYsQ0FBekQsQ0FBNEQsQ0FDMUR3NEIsS0FBSyxFQUFJd04sTUFBTSxDQUFDaG1DLENBQUQsQ0FBTixFQUFhLENBQXRCLENBQ0FnbUMsTUFBTSxDQUFDaG1DLENBQUQsQ0FBTixDQUFZdzRCLEtBQUssQ0FBR3VOLElBQXBCLENBQ0F2TixLQUFLLENBQUlBLEtBQUssQ0FBR3VOLElBQVQsQ0FBaUIsQ0FBekIsQ0FDRCxDQUVELE1BQU12TixLQUFLLENBQUcsQ0FBZCxDQUFpQixDQUNmd04sTUFBTSxDQUFDOXVDLElBQVAsQ0FBWXNoQyxLQUFLLENBQUd1TixJQUFwQixFQUNBdk4sS0FBSyxDQUFJQSxLQUFLLENBQUd1TixJQUFULENBQWlCLENBQXpCLENBQ0QsQ0FDRixDQUVELEdBQUlobkMsT0FBTSxDQUFHLEVBQWIsQ0FFQTtBQUNBLElBQUl2SyxDQUFDLENBQUcsQ0FBUixDQUFXc0osS0FBSyxDQUFDdEMsRUFBTixDQUFTaEgsQ0FBVCxJQUFnQixDQUFoQixFQUFxQkEsQ0FBQyxDQUFHc0osS0FBSyxDQUFDeFQsTUFBTixHQUFpQixDQUFyRCxDQUF3RCxFQUFFa0ssQ0FBMUQsQ0FBNkQsQ0FDM0R1SyxNQUFNLEVBQUl1YSxLQUFWLENBQ0QsQ0FDRDtBQUNBLElBQUk5a0IsQ0FBQyxDQUFHd3hDLE1BQU0sQ0FBQzE3QyxNQUFQLENBQWdCLENBQXhCLENBQTJCa0ssQ0FBQyxFQUFJLENBQWhDLENBQW1DLEVBQUVBLENBQXJDLENBQXdDLENBQ3RDdUssTUFBTSxFQUFJNm1DLFFBQVEsQ0FBQ0ksTUFBTSxDQUFDeHhDLENBQUQsQ0FBUCxDQUFsQixDQUNELENBRUQsTUFBT3VLLE9BQVAsQ0FDRCxDQUdELEtBQU8sQ0F0b2dCRyxDQXVvZ0JWLFFBdm9nQlUsQ0F3b2dCVixLQUFPLFNBQVM5SyxNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7OztHQVNBLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUVBLEdBQUlnYyxPQUFNLENBQUdyYyxNQUFNLENBQUNELE9BQVAsQ0FBaUI1QixLQUFLLENBQUNrZSxNQUFOLENBQWVsZSxLQUFLLENBQUNrZSxNQUFOLEVBQWdCLEVBQTdELENBQ0FsZSxLQUFLLENBQUNxZCxFQUFOLENBQVNhLE1BQVQsQ0FBa0JsZSxLQUFLLENBQUNxZCxFQUFOLENBQVNDLFVBQVQsQ0FBb0JZLE1BQXBCLENBQTZCQSxNQUEvQyxDQUVBOzs7O0dBS0FBLE1BQU0sQ0FBQ3pqQixNQUFQLENBQWdCLFVBQVcsQ0FDekI7QUFDQSxHQUFHLENBQUM0cUMsWUFBSixDQUFrQixDQUNoQnBjLEtBQUssR0FDTixDQUVEO0FBQ0EsR0FBSXFjLE9BQU0sQ0FBRyxJQUFiLENBRUE7QUFDQSxHQUFJN1QsT0FBTSxDQUFHenhCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBYixDQUVBO0FBQ0EsR0FBSXlmLEdBQUUsQ0FBRyxHQUFJNXdCLE1BQUosQ0FBVSxFQUFWLENBQVQsQ0FFQTtBQUNBLEdBQUlpbEIsR0FBRSxDQUFHLENBQ1B3QyxTQUFTLENBQUUsUUFESixDQUVQOFAsV0FBVyxDQUFFLEVBRk4sQ0FHUEQsWUFBWSxDQUFFLEVBSFAsQ0FJUDtBQUNBNlYsYUFBYSxDQUFFLENBTFIsQ0FNUDtBQUNBQyxpQkFBaUIsQ0FBRSxJQVBaLENBUVA7QUFDQUMsaUJBQWlCLENBQUUsQ0FUWixDQUFULENBWUE7Ozs7S0FLQXBvQixFQUFFLENBQUN0UCxLQUFILENBQVcsVUFBVyxDQUNwQjtBQUNBc1AsRUFBRSxDQUFDa29CLGFBQUgsQ0FBbUIsQ0FBbkIsQ0FFQTtBQUNBbG9CLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUF1Qm5vQixFQUFFLENBQUNxb0IsZUFBSCxDQUFxQixFQUE1QyxDQUNBLEdBQUlDLE9BQU0sQ0FBR3RvQixFQUFFLENBQUNvb0IsaUJBQUgsQ0FBdUIsQ0FBcEMsQ0FDQSxJQUFJLEdBQUlyakMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHdWpDLE1BQW5CLENBQTJCLEVBQUV2akMsQ0FBN0IsQ0FBZ0MsQ0FDOUJpYixFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUIxZ0MsSUFBckIsQ0FBMEIsQ0FBMUIsRUFDRCxDQUNEMnNCLE1BQU0sQ0FBR3p4QixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQVQsQ0FDQSs3QixNQUFNLENBQUcsQ0FDUE0sRUFBRSxDQUFFLFVBREcsQ0FFUEMsRUFBRSxDQUFFLFVBRkcsQ0FHUEMsRUFBRSxDQUFFLFVBSEcsQ0FJUEMsRUFBRSxDQUFFLFVBSkcsQ0FLUEMsRUFBRSxDQUFFLFVBTEcsQ0FNUCtOLEVBQUUsQ0FBRSxVQU5HLENBT1BDLEVBQUUsQ0FBRSxVQVBHLENBUVBDLEVBQUUsQ0FBRSxVQVJHLENBQVQsQ0FVQSxNQUFPNTJCLEdBQVAsQ0FDRCxDQXRCRCxDQXVCQTtBQUNBQSxFQUFFLENBQUN0UCxLQUFILEdBRUE7Ozs7Ozs7OztLQVVBc1AsRUFBRSxDQUFDckosTUFBSCxDQUFZLFNBQVN4UCxHQUFULENBQWNrRyxRQUFkLENBQXdCLENBQ2xDLEdBQUdBLFFBQVEsR0FBSyxNQUFoQixDQUF3QixDQUN0QmxHLEdBQUcsQ0FBR3hFLEtBQUssQ0FBQzJELElBQU4sQ0FBVytELFVBQVgsQ0FBc0JsRCxHQUF0QixDQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlrRixJQUFHLENBQUdsRixHQUFHLENBQUN0TSxNQUFkLENBQ0FtbEIsRUFBRSxDQUFDa29CLGFBQUgsRUFBb0I3N0IsR0FBcEIsQ0FDQUEsR0FBRyxDQUFHLENBQUVBLEdBQUcsQ0FBRyxXQUFQLEdBQXdCLENBQXpCLENBQTRCQSxHQUFHLEdBQUssQ0FBcEMsQ0FBTixDQUNBLElBQUksR0FBSXRILEVBQUMsQ0FBR2liLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQnR0QyxNQUFyQixDQUE4QixDQUExQyxDQUE2Q2tLLENBQUMsRUFBSSxDQUFsRCxDQUFxRCxFQUFFQSxDQUF2RCxDQUEwRCxDQUN4RGliLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQnBqQyxDQUFyQixHQUEyQnNILEdBQUcsQ0FBQyxDQUFELENBQTlCLENBQ0FBLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBU0EsR0FBRyxDQUFDLENBQUQsQ0FBSCxFQUFXMlQsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCcGpDLENBQXJCLEVBQTBCLFdBQTNCLEdBQTRDLENBQXRELENBQVQsQ0FDQWliLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQnBqQyxDQUFyQixFQUEwQmliLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQnBqQyxDQUFyQixJQUE0QixDQUF0RCxDQUNBc0gsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFXQSxHQUFHLENBQUMsQ0FBRCxDQUFILENBQVMsV0FBVixHQUEyQixDQUFyQyxDQUNELENBRUQ7QUFDQStuQixNQUFNLENBQUNwcUIsUUFBUCxDQUFnQjdDLEdBQWhCLEVBRUE7QUFDQXloQyxPQUFPLENBQUNYLE1BQUQsQ0FBU3RjLEVBQVQsQ0FBYXlJLE1BQWIsQ0FBUCxDQUVBO0FBQ0EsR0FBR0EsTUFBTSxDQUFDaHJCLElBQVAsQ0FBYyxJQUFkLEVBQXNCZ3JCLE1BQU0sQ0FBQ3Y1QixNQUFQLEtBQW9CLENBQTdDLENBQWdELENBQzlDdTVCLE1BQU0sQ0FBQ2pvQixPQUFQLEdBQ0QsQ0FFRCxNQUFPNlQsR0FBUCxDQUNELENBNUJELENBOEJBOzs7O0tBS0FBLEVBQUUsQ0FBQzRDLE1BQUgsQ0FBWSxVQUFXLENBQ3JCOzs7MkNBRHFCLENBTXJCOzs7Ozs7Ozs7Ozs7O3FFQWVBLEdBQUlpbUIsV0FBVSxDQUFHbG1DLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBakIsQ0FDQTI4QixVQUFVLENBQUM3K0IsUUFBWCxDQUFvQm9xQixNQUFNLENBQUNscUIsS0FBUCxFQUFwQixFQUVBO0FBQ0EsR0FBSStRLFVBQVMsQ0FDWCtFLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQm5vQixFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJ0dEMsTUFBckIsQ0FBOEIsQ0FBbkQsRUFDQW1sQixFQUFFLENBQUNvb0IsaUJBRkwsQ0FJQTtBQUNBO0FBQ0E7QUFDQSxHQUFJM1QsU0FBUSxDQUFHeFosU0FBUyxDQUFJK0UsRUFBRSxDQUFDc1MsV0FBSCxDQUFpQixDQUE3QyxDQUNBdVcsVUFBVSxDQUFDNytCLFFBQVgsQ0FBb0I4K0IsUUFBUSxDQUFDbG5DLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBbUJvZSxFQUFFLENBQUNzUyxXQUFILENBQWlCbUMsUUFBcEMsQ0FBcEIsRUFFQTtBQUNBO0FBQ0EsR0FBSWpnQixLQUFKLENBQVV1MEIsS0FBVixDQUNBLEdBQUlwa0IsS0FBSSxDQUFHM0UsRUFBRSxDQUFDbW9CLGlCQUFILENBQXFCLENBQXJCLEVBQTBCLENBQXJDLENBQ0EsSUFBSSxHQUFJcGpDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR2liLEVBQUUsQ0FBQ21vQixpQkFBSCxDQUFxQnR0QyxNQUFyQixDQUE4QixDQUFqRCxDQUFvRCxFQUFFa0ssQ0FBdEQsQ0FBeUQsQ0FDdkR5UCxJQUFJLENBQUd3TCxFQUFFLENBQUNtb0IsaUJBQUgsQ0FBcUJwakMsQ0FBQyxDQUFHLENBQXpCLEVBQThCLENBQXJDLENBQ0Fna0MsS0FBSyxDQUFJdjBCLElBQUksQ0FBRyxXQUFSLEdBQXlCLENBQWpDLENBQ0FtUSxJQUFJLEVBQUlva0IsS0FBUixDQUNBRixVQUFVLENBQUNyK0IsUUFBWCxDQUFvQm1hLElBQUksR0FBSyxDQUE3QixFQUNBQSxJQUFJLENBQUduUSxJQUFJLEdBQUssQ0FBaEIsQ0FDRCxDQUNEcTBCLFVBQVUsQ0FBQ3IrQixRQUFYLENBQW9CbWEsSUFBcEIsRUFFQSxHQUFJbFcsR0FBRSxDQUFHLENBQ1A4NUIsRUFBRSxDQUFFTixNQUFNLENBQUNNLEVBREosQ0FFUEMsRUFBRSxDQUFFUCxNQUFNLENBQUNPLEVBRkosQ0FHUEMsRUFBRSxDQUFFUixNQUFNLENBQUNRLEVBSEosQ0FJUEMsRUFBRSxDQUFFVCxNQUFNLENBQUNTLEVBSkosQ0FLUEMsRUFBRSxDQUFFVixNQUFNLENBQUNVLEVBTEosQ0FNUCtOLEVBQUUsQ0FBRXpPLE1BQU0sQ0FBQ3lPLEVBTkosQ0FPUEMsRUFBRSxDQUFFMU8sTUFBTSxDQUFDME8sRUFQSixDQVFQQyxFQUFFLENBQUUzTyxNQUFNLENBQUMyTyxFQVJKLENBQVQsQ0FVQWhPLE9BQU8sQ0FBQ242QixFQUFELENBQUtrZCxFQUFMLENBQVNrZCxVQUFULENBQVAsQ0FDQSxHQUFJMTlCLEtBQUksQ0FBR3hJLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBWCxDQUNBZixJQUFJLENBQUNYLFFBQUwsQ0FBY2lFLEVBQUUsQ0FBQzg1QixFQUFqQixFQUNBcDlCLElBQUksQ0FBQ1gsUUFBTCxDQUFjaUUsRUFBRSxDQUFDKzVCLEVBQWpCLEVBQ0FyOUIsSUFBSSxDQUFDWCxRQUFMLENBQWNpRSxFQUFFLENBQUNnNkIsRUFBakIsRUFDQXQ5QixJQUFJLENBQUNYLFFBQUwsQ0FBY2lFLEVBQUUsQ0FBQ2k2QixFQUFqQixFQUNBdjlCLElBQUksQ0FBQ1gsUUFBTCxDQUFjaUUsRUFBRSxDQUFDazZCLEVBQWpCLEVBQ0F4OUIsSUFBSSxDQUFDWCxRQUFMLENBQWNpRSxFQUFFLENBQUNpb0MsRUFBakIsRUFDQXZyQyxJQUFJLENBQUNYLFFBQUwsQ0FBY2lFLEVBQUUsQ0FBQ2tvQyxFQUFqQixFQUNBeHJDLElBQUksQ0FBQ1gsUUFBTCxDQUFjaUUsRUFBRSxDQUFDbW9DLEVBQWpCLEVBQ0EsTUFBT3pyQyxLQUFQLENBQ0QsQ0FyRUQsQ0F1RUEsTUFBTzZVLEdBQVAsQ0FDRCxDQWhMRCxDQWtMQTtBQUNBLEdBQUk4b0IsU0FBUSxDQUFHLElBQWYsQ0FDQSxHQUFJZCxhQUFZLENBQUcsS0FBbkIsQ0FFQTtBQUNBLEdBQUk2TyxHQUFFLENBQUcsSUFBVCxDQUVBOztHQUdBLFFBQVNqckIsTUFBVCxFQUFpQixDQUNmO0FBQ0FrZCxRQUFRLENBQUd0L0IsTUFBTSxDQUFDQyxZQUFQLENBQW9CLEdBQXBCLENBQVgsQ0FDQXEvQixRQUFRLEVBQUlubUMsS0FBSyxDQUFDMkQsSUFBTixDQUFXZ0ksVUFBWCxDQUFzQjlFLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQixJQUFwQixDQUF0QixDQUFpRCxFQUFqRCxDQUFaLENBRUE7QUFDQW90QyxFQUFFLENBQUcsQ0FDSCxVQURHLENBQ1MsVUFEVCxDQUNxQixVQURyQixDQUNpQyxVQURqQyxDQUVILFVBRkcsQ0FFUyxVQUZULENBRXFCLFVBRnJCLENBRWlDLFVBRmpDLENBR0gsVUFIRyxDQUdTLFVBSFQsQ0FHcUIsVUFIckIsQ0FHaUMsVUFIakMsQ0FJSCxVQUpHLENBSVMsVUFKVCxDQUlxQixVQUpyQixDQUlpQyxVQUpqQyxDQUtILFVBTEcsQ0FLUyxVQUxULENBS3FCLFVBTHJCLENBS2lDLFVBTGpDLENBTUgsVUFORyxDQU1TLFVBTlQsQ0FNcUIsVUFOckIsQ0FNaUMsVUFOakMsQ0FPSCxVQVBHLENBT1MsVUFQVCxDQU9xQixVQVByQixDQU9pQyxVQVBqQyxDQVFILFVBUkcsQ0FRUyxVQVJULENBUXFCLFVBUnJCLENBUWlDLFVBUmpDLENBU0gsVUFURyxDQVNTLFVBVFQsQ0FTcUIsVUFUckIsQ0FTaUMsVUFUakMsQ0FVSCxVQVZHLENBVVMsVUFWVCxDQVVxQixVQVZyQixDQVVpQyxVQVZqQyxDQVdILFVBWEcsQ0FXUyxVQVhULENBV3FCLFVBWHJCLENBV2lDLFVBWGpDLENBWUgsVUFaRyxDQVlTLFVBWlQsQ0FZcUIsVUFackIsQ0FZaUMsVUFaakMsQ0FhSCxVQWJHLENBYVMsVUFiVCxDQWFxQixVQWJyQixDQWFpQyxVQWJqQyxDQWNILFVBZEcsQ0FjUyxVQWRULENBY3FCLFVBZHJCLENBY2lDLFVBZGpDLENBZUgsVUFmRyxDQWVTLFVBZlQsQ0FlcUIsVUFmckIsQ0FlaUMsVUFmakMsQ0FnQkgsVUFoQkcsQ0FnQlMsVUFoQlQsQ0FnQnFCLFVBaEJyQixDQWdCaUMsVUFoQmpDLENBQUwsQ0FrQkE7QUFDQTdPLFlBQVksQ0FBRyxJQUFmLENBQ0QsQ0FFRDs7Ozs7O0dBT0EsUUFBU1ksUUFBVCxDQUFpQnppQyxDQUFqQixDQUFvQmtuQixDQUFwQixDQUF1Qm5qQixLQUF2QixDQUE4QixDQUM1QjtBQUNBLEdBQUlzYixHQUFKLENBQVFDLEVBQVIsQ0FBWXF4QixFQUFaLENBQWdCdG9DLEVBQWhCLENBQW9CdW9DLEVBQXBCLENBQXdCQyxHQUF4QixDQUE2Qmp5QyxDQUE3QixDQUFnQ2twQixDQUFoQyxDQUFtQzlrQixDQUFuQyxDQUFzQ2hFLENBQXRDLENBQXlDQyxDQUF6QyxDQUE0Q3NFLENBQTVDLENBQStDczVCLENBQS9DLENBQWtEM0IsQ0FBbEQsQ0FBcURqSyxDQUFyRCxDQUNBLEdBQUkvcUIsSUFBRyxDQUFHbkMsS0FBSyxDQUFDclAsTUFBTixFQUFWLENBQ0EsTUFBTXdSLEdBQUcsRUFBSSxFQUFiLENBQWlCLENBQ2Y7QUFDQTtBQUNBLElBQUl0SCxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUcsRUFBZixDQUFtQixFQUFFQSxDQUFyQixDQUF3QixDQUN0QnNvQixDQUFDLENBQUN0b0IsQ0FBRCxDQUFELENBQU9tRixLQUFLLENBQUNtQixRQUFOLEVBQVAsQ0FDRCxDQUNELEtBQU10RyxDQUFDLENBQUcsRUFBVixDQUFjLEVBQUVBLENBQWhCLENBQW1CLENBQ2pCO0FBQ0F5Z0IsRUFBRSxDQUFHNkgsQ0FBQyxDQUFDdG9CLENBQUMsQ0FBRyxDQUFMLENBQU4sQ0FDQXlnQixFQUFFLENBQ0EsQ0FBRUEsRUFBRSxHQUFLLEVBQVIsQ0FBZUEsRUFBRSxFQUFJLEVBQXRCLEdBQ0VBLEVBQUUsR0FBSyxFQUFSLENBQWVBLEVBQUUsRUFBSSxFQUR0QixFQUVDQSxFQUFFLEdBQUssRUFIVixDQUlBO0FBQ0FDLEVBQUUsQ0FBRzRILENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsRUFBTCxDQUFOLENBQ0EwZ0IsRUFBRSxDQUNBLENBQUVBLEVBQUUsR0FBSyxDQUFSLENBQWNBLEVBQUUsRUFBSSxFQUFyQixHQUNFQSxFQUFFLEdBQUssRUFBUixDQUFlQSxFQUFFLEVBQUksRUFEdEIsRUFFQ0EsRUFBRSxHQUFLLENBSFYsQ0FJQTtBQUNBNEgsQ0FBQyxDQUFDdG9CLENBQUQsQ0FBRCxDQUFReWdCLEVBQUUsQ0FBRzZILENBQUMsQ0FBQ3RvQixDQUFDLENBQUcsQ0FBTCxDQUFOLENBQWdCMGdCLEVBQWhCLENBQXFCNEgsQ0FBQyxDQUFDdG9CLENBQUMsQ0FBRyxFQUFMLENBQXZCLENBQW1DLENBQTFDLENBQ0QsQ0FFRDtBQUNBa3BCLENBQUMsQ0FBRzluQixDQUFDLENBQUNvaUMsRUFBTixDQUNBcC9CLENBQUMsQ0FBR2hELENBQUMsQ0FBQ3FpQyxFQUFOLENBQ0FyakMsQ0FBQyxDQUFHZ0IsQ0FBQyxDQUFDc2lDLEVBQU4sQ0FDQXJqQyxDQUFDLENBQUdlLENBQUMsQ0FBQ3VpQyxFQUFOLENBQ0FoL0IsQ0FBQyxDQUFHdkQsQ0FBQyxDQUFDd2lDLEVBQU4sQ0FDQTNGLENBQUMsQ0FBRzc4QixDQUFDLENBQUN1d0MsRUFBTixDQUNBclYsQ0FBQyxDQUFHbDdCLENBQUMsQ0FBQ3d3QyxFQUFOLENBQ0F2ZixDQUFDLENBQUdqeEIsQ0FBQyxDQUFDeXdDLEVBQU4sQ0FFQTtBQUNBLElBQUk3eEMsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHLEVBQWYsQ0FBbUIsRUFBRUEsQ0FBckIsQ0FBd0IsQ0FDdEI7QUFDQXlKLEVBQUUsQ0FDQSxDQUFFOUUsQ0FBQyxHQUFLLENBQVAsQ0FBYUEsQ0FBQyxFQUFJLEVBQW5CLEdBQ0VBLENBQUMsR0FBSyxFQUFQLENBQWNBLENBQUMsRUFBSSxFQURwQixHQUVFQSxDQUFDLEdBQUssRUFBUCxDQUFjQSxDQUFDLEVBQUksQ0FGcEIsQ0FERixDQUlBO0FBQ0FxdEMsRUFBRSxDQUFHMVYsQ0FBQyxDQUFJMzNCLENBQUMsRUFBSXM1QixDQUFDLENBQUczQixDQUFSLENBQVgsQ0FDQTtBQUNBeVYsRUFBRSxDQUNBLENBQUU3b0IsQ0FBQyxHQUFLLENBQVAsQ0FBYUEsQ0FBQyxFQUFJLEVBQW5CLEdBQ0VBLENBQUMsR0FBSyxFQUFQLENBQWNBLENBQUMsRUFBSSxFQURwQixHQUVFQSxDQUFDLEdBQUssRUFBUCxDQUFjQSxDQUFDLEVBQUksRUFGcEIsQ0FERixDQUlBO0FBQ0Erb0IsR0FBRyxDQUFJL29CLENBQUMsQ0FBRzlrQixDQUFMLENBQVdoRSxDQUFDLEVBQUk4b0IsQ0FBQyxDQUFHOWtCLENBQVIsQ0FBbEIsQ0FFQTtBQUNBcWMsRUFBRSxDQUFHNFIsQ0FBQyxDQUFHNW9CLEVBQUosQ0FBU3VvQyxFQUFULENBQWNGLEVBQUUsQ0FBQzl4QyxDQUFELENBQWhCLENBQXNCc29CLENBQUMsQ0FBQ3RvQixDQUFELENBQTVCLENBQ0EwZ0IsRUFBRSxDQUFHcXhCLEVBQUUsQ0FBR0UsR0FBVixDQUNBNWYsQ0FBQyxDQUFHaUssQ0FBSixDQUNBQSxDQUFDLENBQUcyQixDQUFKLENBQ0FBLENBQUMsQ0FBR3Q1QixDQUFKLENBQ0E7QUFDQTtBQUNBQSxDQUFDLENBQUl0RSxDQUFDLENBQUdvZ0IsRUFBTCxHQUFhLENBQWpCLENBQ0FwZ0IsQ0FBQyxDQUFHRCxDQUFKLENBQ0FBLENBQUMsQ0FBR2dFLENBQUosQ0FDQUEsQ0FBQyxDQUFHOGtCLENBQUosQ0FDQTtBQUNBO0FBQ0FBLENBQUMsQ0FBSXpJLEVBQUUsQ0FBR0MsRUFBTixHQUFjLENBQWxCLENBQ0QsQ0FFRDtBQUNBdGYsQ0FBQyxDQUFDb2lDLEVBQUYsQ0FBUXBpQyxDQUFDLENBQUNvaUMsRUFBRixDQUFPdGEsQ0FBUixDQUFhLENBQXBCLENBQ0E5bkIsQ0FBQyxDQUFDcWlDLEVBQUYsQ0FBUXJpQyxDQUFDLENBQUNxaUMsRUFBRixDQUFPci9CLENBQVIsQ0FBYSxDQUFwQixDQUNBaEQsQ0FBQyxDQUFDc2lDLEVBQUYsQ0FBUXRpQyxDQUFDLENBQUNzaUMsRUFBRixDQUFPdGpDLENBQVIsQ0FBYSxDQUFwQixDQUNBZ0IsQ0FBQyxDQUFDdWlDLEVBQUYsQ0FBUXZpQyxDQUFDLENBQUN1aUMsRUFBRixDQUFPdGpDLENBQVIsQ0FBYSxDQUFwQixDQUNBZSxDQUFDLENBQUN3aUMsRUFBRixDQUFReGlDLENBQUMsQ0FBQ3dpQyxFQUFGLENBQU9qL0IsQ0FBUixDQUFhLENBQXBCLENBQ0F2RCxDQUFDLENBQUN1d0MsRUFBRixDQUFRdndDLENBQUMsQ0FBQ3V3QyxFQUFGLENBQU8xVCxDQUFSLENBQWEsQ0FBcEIsQ0FDQTc4QixDQUFDLENBQUN3d0MsRUFBRixDQUFReHdDLENBQUMsQ0FBQ3d3QyxFQUFGLENBQU90VixDQUFSLENBQWEsQ0FBcEIsQ0FDQWw3QixDQUFDLENBQUN5d0MsRUFBRixDQUFRendDLENBQUMsQ0FBQ3l3QyxFQUFGLENBQU94ZixDQUFSLENBQWEsQ0FBcEIsQ0FDQS9xQixHQUFHLEVBQUksRUFBUCxDQUNELENBQ0YsQ0FHRCxLQUFPLENBbjlnQkcsQ0FvOWdCVixRQXA5Z0JVLENBcTlnQlYsS0FBTyxTQUFTN0gsTUFBVCxDQUFpQkQsT0FBakIsQ0FBMEJNLG1CQUExQixDQUErQyxDQUV0RDs7Ozs7Ozs7OztHQVdBLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQSxHQUFJdWMsUUFBTyxDQUFHLElBQWQsQ0FDQSxHQUFHemUsS0FBSyxDQUFDMkQsSUFBTixDQUFXZ0MsUUFBWCxFQUF1QixDQUFDM0YsS0FBSyxDQUFDekksT0FBTixDQUFja00saUJBQXRDLEVBQ0QsQ0FBQ0csT0FBTyxDQUFDZ0MsUUFBUixDQUFpQixhQUFqQixDQURILENBQ29DLENBQ2xDNlksT0FBTyxDQUFHdmMsbUJBQW1CLENBQUMsRUFBRCxDQUE3QixDQUNELENBRUQsY0FDQSxHQUFJbWMsS0FBSSxDQUFHeGMsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDcWUsSUFBTixDQUFhcmUsS0FBSyxDQUFDcWUsSUFBTixFQUFjLEVBQXZELENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JBQSxJQUFJLENBQUM1akIsTUFBTCxDQUFjLFNBQVM2NUMsTUFBVCxDQUFpQixDQUM3QixHQUFJbDJCLElBQUcsQ0FBRyxDQUNSazJCLE1BQU0sQ0FBRUEsTUFEQSxDQUVScjZDLEdBQUcsQ0FBRSxJQUZHLENBR1I2akIsSUFBSSxDQUFFLElBSEUsQ0FJUnkyQixJQUFJLENBQUUsSUFKRSxDQUtSO0FBQ0FDLE9BQU8sQ0FBRSxDQU5ELENBT1I7QUFDQUMsU0FBUyxDQUFFLENBUkgsQ0FTUjtBQUNBQyxRQUFRLENBQUUsRUFWRixDQUFWLENBYUE7QUFDQSxHQUFJcjNCLEdBQUUsQ0FBR2kzQixNQUFNLENBQUNqM0IsRUFBaEIsQ0FDQSxHQUFJczNCLE1BQUssQ0FBRyxHQUFJdjhDLE1BQUosQ0FBVSxFQUFWLENBQVosQ0FDQSxJQUFJLEdBQUlnSyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsRUFBbkIsQ0FBdUIsRUFBRUEsQ0FBekIsQ0FBNEIsQ0FDMUJ1eUMsS0FBSyxDQUFDdnlDLENBQUQsQ0FBTCxDQUFXaWIsRUFBRSxDQUFDNWlCLE1BQUgsRUFBWCxDQUNELENBQ0QyakIsR0FBRyxDQUFDdTJCLEtBQUosQ0FBWUEsS0FBWixDQUVBO0FBQ0F2MkIsR0FBRyxDQUFDdzJCLElBQUosQ0FBVyxDQUFYLENBRUE7Ozs7Ozs7OztLQVVBeDJCLEdBQUcsQ0FBQ2xlLFFBQUosQ0FBZSxTQUFTK0ksS0FBVCxDQUFnQjlFLFFBQWhCLENBQTBCLENBQ3ZDO0FBQ0EsR0FBRyxDQUFDQSxRQUFKLENBQWMsQ0FDWixNQUFPaWEsSUFBRyxDQUFDeTJCLFlBQUosQ0FBaUI1ckMsS0FBakIsQ0FBUCxDQUNELENBRUQ7QUFDQSxHQUFJOFUsT0FBTSxDQUFHSyxHQUFHLENBQUNrMkIsTUFBSixDQUFXdjJCLE1BQXhCLENBQ0EsR0FBSUUsVUFBUyxDQUFHRyxHQUFHLENBQUNrMkIsTUFBSixDQUFXcjJCLFNBQTNCLENBQ0EsR0FBSVAsVUFBUyxDQUFHVSxHQUFHLENBQUNrMkIsTUFBSixDQUFXNTJCLFNBQTNCLENBQ0EsR0FBSUcsV0FBVSxDQUFHTyxHQUFHLENBQUNrMkIsTUFBSixDQUFXejJCLFVBQTVCLENBQ0EsR0FBSXJYLEVBQUMsQ0FBR3hHLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBUixDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTZVLEdBQUcsQ0FBQ25rQixHQUFKLENBQVUsSUFBVixDQUVBaUcsUUFBUSxHQUVSLFFBQVNBLFNBQVQsQ0FBa0IrVSxHQUFsQixDQUF1QixDQUNyQixHQUFHQSxHQUFILENBQVEsQ0FDTixNQUFPOVEsU0FBUSxDQUFDOFEsR0FBRCxDQUFmLENBQ0QsQ0FFRDtBQUNBLEdBQUd6TyxDQUFDLENBQUN0TyxNQUFGLElBQWMrUSxLQUFqQixDQUF3QixDQUN0QixNQUFPOUUsU0FBUSxDQUFDLElBQUQsQ0FBT3FDLENBQUMsQ0FBQzRCLFFBQUYsQ0FBV2EsS0FBWCxDQUFQLENBQWYsQ0FDRCxDQUVEO0FBQ0EsR0FBR21WLEdBQUcsQ0FBQ3EyQixTQUFKLENBQWdCLE9BQW5CLENBQTRCLENBQzFCcjJCLEdBQUcsQ0FBQ25rQixHQUFKLENBQVUsSUFBVixDQUNELENBRUQsR0FBR21rQixHQUFHLENBQUNua0IsR0FBSixHQUFZLElBQWYsQ0FBcUIsQ0FDbkI7QUFDQSxNQUFPK0YsTUFBSyxDQUFDMkQsSUFBTixDQUFXRSxRQUFYLENBQW9CLFVBQVcsQ0FDcENpeEMsT0FBTyxDQUFDNTBDLFFBQUQsQ0FBUCxDQUNELENBRk0sQ0FBUCxDQUdELENBRUQ7QUFDQSxHQUFJcUgsTUFBSyxDQUFHd1csTUFBTSxDQUFDSyxHQUFHLENBQUNua0IsR0FBTCxDQUFVbWtCLEdBQUcsQ0FBQ04sSUFBZCxDQUFsQixDQUNBTSxHQUFHLENBQUNxMkIsU0FBSixFQUFpQmx0QyxLQUFLLENBQUNyUCxNQUF2QixDQUNBc08sQ0FBQyxDQUFDYSxRQUFGLENBQVdFLEtBQVgsRUFFQTtBQUNBNlcsR0FBRyxDQUFDbmtCLEdBQUosQ0FBVXlqQixTQUFTLENBQUNLLE1BQU0sQ0FBQ0ssR0FBRyxDQUFDbmtCLEdBQUwsQ0FBVWdrQixTQUFTLENBQUNHLEdBQUcsQ0FBQ04sSUFBTCxDQUFuQixDQUFQLENBQW5CLENBQ0FNLEdBQUcsQ0FBQ04sSUFBSixDQUFXRCxVQUFVLENBQUNFLE1BQU0sQ0FBQ0ssR0FBRyxDQUFDbmtCLEdBQUwsQ0FBVW1rQixHQUFHLENBQUNOLElBQWQsQ0FBUCxDQUFyQixDQUVBOWQsS0FBSyxDQUFDMkQsSUFBTixDQUFXSSxZQUFYLENBQXdCN0QsUUFBeEIsRUFDRCxDQUNGLENBdkRELENBeURBOzs7Ozs7S0FPQWtlLEdBQUcsQ0FBQ3kyQixZQUFKLENBQW1CLFNBQVM1ckMsS0FBVCxDQUFnQixDQUNqQztBQUNBLEdBQUk4VSxPQUFNLENBQUdLLEdBQUcsQ0FBQ2syQixNQUFKLENBQVd2MkIsTUFBeEIsQ0FDQSxHQUFJRSxVQUFTLENBQUdHLEdBQUcsQ0FBQ2syQixNQUFKLENBQVdyMkIsU0FBM0IsQ0FDQSxHQUFJUCxVQUFTLENBQUdVLEdBQUcsQ0FBQ2syQixNQUFKLENBQVc1MkIsU0FBM0IsQ0FDQSxHQUFJRyxXQUFVLENBQUdPLEdBQUcsQ0FBQ2syQixNQUFKLENBQVd6MkIsVUFBNUIsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FPLEdBQUcsQ0FBQ25rQixHQUFKLENBQVUsSUFBVixDQUVBLEdBQUl1TSxFQUFDLENBQUd4RyxLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQVIsQ0FDQSxNQUFNL0MsQ0FBQyxDQUFDdE8sTUFBRixHQUFhK1EsS0FBbkIsQ0FBMEIsQ0FDeEI7QUFDQSxHQUFHbVYsR0FBRyxDQUFDcTJCLFNBQUosQ0FBZ0IsT0FBbkIsQ0FBNEIsQ0FDMUJyMkIsR0FBRyxDQUFDbmtCLEdBQUosQ0FBVSxJQUFWLENBQ0QsQ0FFRCxHQUFHbWtCLEdBQUcsQ0FBQ25rQixHQUFKLEdBQVksSUFBZixDQUFxQixDQUNuQjg2QyxXQUFXLEdBQ1osQ0FFRDtBQUNBLEdBQUl4dEMsTUFBSyxDQUFHd1csTUFBTSxDQUFDSyxHQUFHLENBQUNua0IsR0FBTCxDQUFVbWtCLEdBQUcsQ0FBQ04sSUFBZCxDQUFsQixDQUNBTSxHQUFHLENBQUNxMkIsU0FBSixFQUFpQmx0QyxLQUFLLENBQUNyUCxNQUF2QixDQUNBc08sQ0FBQyxDQUFDYSxRQUFGLENBQVdFLEtBQVgsRUFFQTtBQUNBNlcsR0FBRyxDQUFDbmtCLEdBQUosQ0FBVXlqQixTQUFTLENBQUNLLE1BQU0sQ0FBQ0ssR0FBRyxDQUFDbmtCLEdBQUwsQ0FBVWdrQixTQUFTLENBQUNHLEdBQUcsQ0FBQ04sSUFBTCxDQUFuQixDQUFQLENBQW5CLENBQ0FNLEdBQUcsQ0FBQ04sSUFBSixDQUFXRCxVQUFVLENBQUNFLE1BQU0sQ0FBQ0ssR0FBRyxDQUFDbmtCLEdBQUwsQ0FBVW1rQixHQUFHLENBQUNOLElBQWQsQ0FBUCxDQUFyQixDQUNELENBRUQsTUFBT3RYLEVBQUMsQ0FBQzRCLFFBQUYsQ0FBV2EsS0FBWCxDQUFQLENBQ0QsQ0FwQ0QsQ0FzQ0E7Ozs7S0FLQSxRQUFTNnJDLFFBQVQsQ0FBaUIzd0MsUUFBakIsQ0FBMkIsQ0FDekIsR0FBR2lhLEdBQUcsQ0FBQ3UyQixLQUFKLENBQVUsQ0FBVixFQUFhcFAsYUFBYixFQUE4QixFQUFqQyxDQUFxQyxDQUNuQ3lQLEtBQUssR0FDTCxNQUFPN3dDLFNBQVEsRUFBZixDQUNELENBQ0Q7QUFDQSxHQUFJOHdDLE9BQU0sQ0FBSSxHQUFLNzJCLEdBQUcsQ0FBQ3UyQixLQUFKLENBQVUsQ0FBVixFQUFhcFAsYUFBbkIsRUFBcUMsQ0FBbEQsQ0FDQW5uQixHQUFHLENBQUM4MkIsUUFBSixDQUFhRCxNQUFiLENBQXFCLFNBQVNoZ0MsR0FBVCxDQUFjMU4sS0FBZCxDQUFxQixDQUN4QyxHQUFHME4sR0FBSCxDQUFRLENBQ04sTUFBTzlRLFNBQVEsQ0FBQzhRLEdBQUQsQ0FBZixDQUNELENBQ0RtSixHQUFHLENBQUNVLE9BQUosQ0FBWXZYLEtBQVosRUFDQXl0QyxLQUFLLEdBQ0w3d0MsUUFBUSxHQUNULENBUEQsRUFRRCxDQUVEOztLQUdBLFFBQVM0d0MsWUFBVCxFQUF1QixDQUNyQixHQUFHMzJCLEdBQUcsQ0FBQ3UyQixLQUFKLENBQVUsQ0FBVixFQUFhcFAsYUFBYixFQUE4QixFQUFqQyxDQUFxQyxDQUNuQyxNQUFPeVAsTUFBSyxFQUFaLENBQ0QsQ0FDRDtBQUNBLEdBQUlDLE9BQU0sQ0FBSSxHQUFLNzJCLEdBQUcsQ0FBQ3UyQixLQUFKLENBQVUsQ0FBVixFQUFhcFAsYUFBbkIsRUFBcUMsQ0FBbEQsQ0FDQW5uQixHQUFHLENBQUNVLE9BQUosQ0FBWVYsR0FBRyxDQUFDKzJCLFlBQUosQ0FBaUJGLE1BQWpCLENBQVosRUFDQUQsS0FBSyxHQUNOLENBRUQ7O0tBR0EsUUFBU0EsTUFBVCxFQUFpQixDQUNmO0FBQ0E1MkIsR0FBRyxDQUFDbzJCLE9BQUosQ0FBZXAyQixHQUFHLENBQUNvMkIsT0FBSixHQUFnQixVQUFqQixDQUErQixDQUEvQixDQUFtQ3AyQixHQUFHLENBQUNvMkIsT0FBSixDQUFjLENBQS9ELENBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQSxHQUFJbjNCLEdBQUUsQ0FBR2UsR0FBRyxDQUFDazJCLE1BQUosQ0FBV2ozQixFQUFYLENBQWM1aUIsTUFBZCxFQUFULENBRUE7QUFDQTRpQixFQUFFLENBQUNySixNQUFILENBQVVvSyxHQUFHLENBQUNzMkIsUUFBZCxFQUVBO0FBQ0E7QUFDQSxHQUFJVSxPQUFNLENBQUcsQ0FBYixDQUNBLElBQUksR0FBSTEyQyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUcsRUFBbkIsQ0FBdUIsRUFBRUEsQ0FBekIsQ0FBNEIsQ0FDMUIsR0FBRzBmLEdBQUcsQ0FBQ28yQixPQUFKLENBQWNZLE1BQWQsR0FBeUIsQ0FBNUIsQ0FBK0IsQ0FDN0IvM0IsRUFBRSxDQUFDckosTUFBSCxDQUFVb0ssR0FBRyxDQUFDdTJCLEtBQUosQ0FBVWoyQyxDQUFWLEVBQWF1aEIsTUFBYixHQUFzQjdYLFFBQXRCLEVBQVYsRUFDQWdXLEdBQUcsQ0FBQ3UyQixLQUFKLENBQVVqMkMsQ0FBVixFQUFhcVAsS0FBYixHQUNELENBQ0RxbkMsTUFBTSxDQUFHQSxNQUFNLEVBQUksQ0FBbkIsQ0FDRCxDQUVEO0FBQ0FoM0IsR0FBRyxDQUFDczJCLFFBQUosQ0FBZXIzQixFQUFFLENBQUM0QyxNQUFILEdBQVk3WCxRQUFaLEVBQWYsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBaVYsRUFBRSxDQUFDdFAsS0FBSCxHQUNBc1AsRUFBRSxDQUFDckosTUFBSCxDQUFVb0ssR0FBRyxDQUFDczJCLFFBQWQsRUFDQSxHQUFJVyxVQUFTLENBQUdoNEIsRUFBRSxDQUFDNEMsTUFBSCxHQUFZN1gsUUFBWixFQUFoQixDQUVBO0FBQ0FnVyxHQUFHLENBQUNua0IsR0FBSixDQUFVbWtCLEdBQUcsQ0FBQ2syQixNQUFKLENBQVc1MkIsU0FBWCxDQUFxQlUsR0FBRyxDQUFDczJCLFFBQXpCLENBQVYsQ0FDQXQyQixHQUFHLENBQUNOLElBQUosQ0FBV00sR0FBRyxDQUFDazJCLE1BQUosQ0FBV3oyQixVQUFYLENBQXNCdzNCLFNBQXRCLENBQVgsQ0FDQWozQixHQUFHLENBQUNxMkIsU0FBSixDQUFnQixDQUFoQixDQUNELENBRUQ7Ozs7Ozs7S0FRQSxRQUFTYSxnQkFBVCxDQUF5QkwsTUFBekIsQ0FBaUMsQ0FDL0I7QUFDQSxHQUFJejJCLGdCQUFlLENBQUcsSUFBdEIsQ0FDQSxHQUFHLE1BQU9sZixPQUFQLEdBQWtCLFdBQXJCLENBQWtDLENBQ2hDLEdBQUltZixRQUFPLENBQUduZixNQUFNLENBQUNvZixNQUFQLEVBQWlCcGYsTUFBTSxDQUFDcWYsUUFBdEMsQ0FDQSxHQUFHRixPQUFPLEVBQUlBLE9BQU8sQ0FBQ0QsZUFBdEIsQ0FBdUMsQ0FDckNBLGVBQWUsQ0FBRyx5QkFBUzdYLEdBQVQsQ0FBYyxDQUM5QixNQUFPOFgsUUFBTyxDQUFDRCxlQUFSLENBQXdCN1gsR0FBeEIsQ0FBUCxDQUNELENBRkQsQ0FHRCxDQUNGLENBRUQsR0FBSUgsRUFBQyxDQUFHeEcsS0FBSyxDQUFDMkQsSUFBTixDQUFXNEYsWUFBWCxFQUFSLENBQ0EsR0FBR2lWLGVBQUgsQ0FBb0IsQ0FDbEIsTUFBTWhZLENBQUMsQ0FBQ3RPLE1BQUYsR0FBYSs4QyxNQUFuQixDQUEyQixDQUN6QjtBQUNBO0FBQ0EsR0FBSWhzQyxNQUFLLENBQUduSyxJQUFJLENBQUNrSyxHQUFMLENBQVMsQ0FBVCxDQUFZbEssSUFBSSxDQUFDb0ssR0FBTCxDQUFTK3JDLE1BQU0sQ0FBR3p1QyxDQUFDLENBQUN0TyxNQUFGLEVBQWxCLENBQThCLEtBQTlCLEVBQXVDLENBQW5ELENBQVosQ0FDQSxHQUFJcTlDLFFBQU8sQ0FBRyxHQUFJQyxZQUFKLENBQWdCMTJDLElBQUksQ0FBQ2lXLEtBQUwsQ0FBVzlMLEtBQVgsQ0FBaEIsQ0FBZCxDQUNBLEdBQUksQ0FDRnVWLGVBQWUsQ0FBQysyQixPQUFELENBQWYsQ0FDQSxJQUFJLEdBQUluekMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHbXpDLE9BQU8sQ0FBQ3I5QyxNQUEzQixDQUFtQyxFQUFFa0ssQ0FBckMsQ0FBd0MsQ0FDdENvRSxDQUFDLENBQUNxQixRQUFGLENBQVcwdEMsT0FBTyxDQUFDbnpDLENBQUQsQ0FBbEIsRUFDRCxDQUNGLENBQUMsTUFBTTJFLENBQU4sQ0FBUyxDQUNULG9DQUNBLEdBQUcsRUFBRSxNQUFPMHVDLG1CQUFQLEdBQThCLFdBQTlCLEVBQ0gxdUMsQ0FBQyxXQUFZMHVDLG1CQURaLENBQUgsQ0FDb0MsQ0FDbEMsS0FBTTF1QyxFQUFOLENBQ0QsQ0FDRixDQUNGLENBQ0YsQ0FFRDtBQUNBLEdBQUdQLENBQUMsQ0FBQ3RPLE1BQUYsR0FBYSs4QyxNQUFoQixDQUF3QixDQUN0Qjs7OENBR0EsR0FBSVMsR0FBSixDQUFRQyxFQUFSLENBQVk5akMsSUFBWixDQUNBLEdBQUlpTSxLQUFJLENBQUdoZixJQUFJLENBQUNpVyxLQUFMLENBQVdqVyxJQUFJLENBQUNDLE1BQUwsR0FBZ0IsUUFBM0IsQ0FBWCxDQUNBLE1BQU15SCxDQUFDLENBQUN0TyxNQUFGLEdBQWErOEMsTUFBbkIsQ0FBMkIsQ0FDekJVLEVBQUUsQ0FBRyxPQUFTNzNCLElBQUksQ0FBRyxNQUFoQixDQUFMLENBQ0E0M0IsRUFBRSxDQUFHLE9BQVM1M0IsSUFBSSxFQUFJLEVBQWpCLENBQUwsQ0FDQTYzQixFQUFFLEVBQUksQ0FBQ0QsRUFBRSxDQUFHLE1BQU4sR0FBaUIsRUFBdkIsQ0FDQUMsRUFBRSxFQUFJRCxFQUFFLEVBQUksRUFBWixDQUNBQyxFQUFFLENBQUcsQ0FBQ0EsRUFBRSxDQUFHLFVBQU4sR0FBcUJBLEVBQUUsRUFBSSxFQUEzQixDQUFMLENBQ0E3M0IsSUFBSSxDQUFHNjNCLEVBQUUsQ0FBRyxVQUFaLENBRUE7QUFDQSxJQUFJLEdBQUl2ekMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHLENBQW5CLENBQXNCLEVBQUVBLENBQXhCLENBQTJCLENBQ3pCO0FBQ0F5UCxJQUFJLENBQUdpTSxJQUFJLElBQU0xYixDQUFDLEVBQUksQ0FBWCxDQUFYLENBQ0F5UCxJQUFJLEVBQUkvUyxJQUFJLENBQUNpVyxLQUFMLENBQVdqVyxJQUFJLENBQUNDLE1BQUwsR0FBZ0IsTUFBM0IsQ0FBUixDQUNBeUgsQ0FBQyxDQUFDUSxPQUFGLENBQVVILE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQitLLElBQUksQ0FBRyxJQUEzQixDQUFWLEVBQ0QsQ0FDRixDQUNGLENBRUQsTUFBT3JMLEVBQUMsQ0FBQzRCLFFBQUYsQ0FBVzZzQyxNQUFYLENBQVAsQ0FDRCxDQUNEO0FBQ0EsR0FBR3gyQixPQUFILENBQVksQ0FDVjtBQUNBTCxHQUFHLENBQUM4MkIsUUFBSixDQUFlLFNBQVNELE1BQVQsQ0FBaUI5d0MsUUFBakIsQ0FBMkIsQ0FDeENzYSxPQUFPLENBQUNtM0IsV0FBUixDQUFvQlgsTUFBcEIsQ0FBNEIsU0FBU2hnQyxHQUFULENBQWMxTixLQUFkLENBQXFCLENBQy9DLEdBQUcwTixHQUFILENBQVEsQ0FDTixNQUFPOVEsU0FBUSxDQUFDOFEsR0FBRCxDQUFmLENBQ0QsQ0FDRDlRLFFBQVEsQ0FBQyxJQUFELENBQU9vRCxLQUFLLENBQUN2SSxRQUFOLEVBQVAsQ0FBUixDQUNELENBTEQsRUFNRCxDQVBELENBUUE7QUFDQW9mLEdBQUcsQ0FBQysyQixZQUFKLENBQW1CLFNBQVNGLE1BQVQsQ0FBaUIsQ0FDbEMsTUFBT3gyQixRQUFPLENBQUNtM0IsV0FBUixDQUFvQlgsTUFBcEIsRUFBNEJqMkMsUUFBNUIsRUFBUCxDQUNELENBRkQsQ0FHRCxDQWRELElBY08sQ0FDTG9mLEdBQUcsQ0FBQzgyQixRQUFKLENBQWUsU0FBU0QsTUFBVCxDQUFpQjl3QyxRQUFqQixDQUEyQixDQUN4QyxHQUFJLENBQ0ZBLFFBQVEsQ0FBQyxJQUFELENBQU9teEMsZUFBZSxDQUFDTCxNQUFELENBQXRCLENBQVIsQ0FDRCxDQUFDLE1BQU1sdUMsQ0FBTixDQUFTLENBQ1Q1QyxRQUFRLENBQUM0QyxDQUFELENBQVIsQ0FDRCxDQUNGLENBTkQsQ0FPQXFYLEdBQUcsQ0FBQysyQixZQUFKLENBQW1CRyxlQUFuQixDQUNELENBRUQ7Ozs7S0FLQWwzQixHQUFHLENBQUNVLE9BQUosQ0FBYyxTQUFTdlgsS0FBVCxDQUFnQixDQUM1QjtBQUNBLEdBQUkwQixNQUFLLENBQUcxQixLQUFLLENBQUNyUCxNQUFsQixDQUNBLElBQUksR0FBSWtLLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRzZHLEtBQW5CLENBQTBCLEVBQUU3RyxDQUE1QixDQUErQixDQUM3QmdjLEdBQUcsQ0FBQ3UyQixLQUFKLENBQVV2MkIsR0FBRyxDQUFDdzJCLElBQWQsRUFBb0I1Z0MsTUFBcEIsQ0FBMkJ6TSxLQUFLLENBQUN0SSxNQUFOLENBQWFtRCxDQUFiLENBQWdCLENBQWhCLENBQTNCLEVBQ0FnYyxHQUFHLENBQUN3MkIsSUFBSixDQUFZeDJCLEdBQUcsQ0FBQ3cyQixJQUFKLEdBQWEsRUFBZCxDQUFvQixDQUFwQixDQUF3QngyQixHQUFHLENBQUN3MkIsSUFBSixDQUFXLENBQTlDLENBQ0QsQ0FDRixDQVBELENBU0E7Ozs7O0tBTUF4MkIsR0FBRyxDQUFDUSxVQUFKLENBQWlCLFNBQVN4YyxDQUFULENBQVlXLENBQVosQ0FBZSxDQUM5QixHQUFJd0UsTUFBSyxDQUFHLEVBQVosQ0FDQSxJQUFJLEdBQUl4QixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdoRCxDQUFuQixDQUFzQmdELENBQUMsRUFBSSxDQUEzQixDQUE4QixDQUM1QndCLEtBQUssRUFBSVYsTUFBTSxDQUFDQyxZQUFQLENBQXFCMUUsQ0FBQyxFQUFJMkQsQ0FBTixDQUFXLElBQS9CLENBQVQsQ0FDRCxDQUNEcVksR0FBRyxDQUFDVSxPQUFKLENBQVl2WCxLQUFaLEVBQ0QsQ0FORCxDQVFBOzs7Ozs7O0tBUUE2VyxHQUFHLENBQUN5M0IsY0FBSixDQUFxQixTQUFTemdDLE1BQVQsQ0FBaUIsQ0FDcEM7QUFDQSxHQUFHQSxNQUFNLEdBQUtyVCxJQUFkLENBQW9CLENBQ2xCcWMsR0FBRyxDQUFDODJCLFFBQUosQ0FBZSxTQUFTRCxNQUFULENBQWlCOXdDLFFBQWpCLENBQTJCLENBQ3hDLFFBQVMyeEMsU0FBVCxDQUFrQi91QyxDQUFsQixDQUFxQixDQUNuQixHQUFJak4sS0FBSSxDQUFHaU4sQ0FBQyxDQUFDak4sSUFBYixDQUNBLEdBQUdBLElBQUksQ0FBQ2tHLEtBQUwsRUFBY2xHLElBQUksQ0FBQ2tHLEtBQUwsQ0FBV3FlLElBQTVCLENBQWtDLENBQ2hDdGMsSUFBSSxDQUFDZzBDLG1CQUFMLENBQXlCLFNBQXpCLENBQW9DRCxRQUFwQyxFQUNBM3hDLFFBQVEsQ0FBQ3JLLElBQUksQ0FBQ2tHLEtBQUwsQ0FBV3FlLElBQVgsQ0FBZ0JwSixHQUFqQixDQUFzQm5iLElBQUksQ0FBQ2tHLEtBQUwsQ0FBV3FlLElBQVgsQ0FBZ0I5VyxLQUF0QyxDQUFSLENBQ0QsQ0FDRixDQUNEeEYsSUFBSSxDQUFDZ0QsZ0JBQUwsQ0FBc0IsU0FBdEIsQ0FBaUMrd0MsUUFBakMsRUFDQS96QyxJQUFJLENBQUNsQyxXQUFMLENBQWlCLENBQUNHLEtBQUssQ0FBRSxDQUFDcWUsSUFBSSxDQUFFLENBQUM0MkIsTUFBTSxDQUFFQSxNQUFULENBQVAsQ0FBUixDQUFqQixFQUNELENBVkQsQ0FXRCxDQVpELElBWU8sQ0FDTDtBQUNBLEdBQUlhLFNBQVEsQ0FBRyxRQUFYQSxTQUFXLENBQVMvdUMsQ0FBVCxDQUFZLENBQ3pCLEdBQUlqTixLQUFJLENBQUdpTixDQUFDLENBQUNqTixJQUFiLENBQ0EsR0FBR0EsSUFBSSxDQUFDa0csS0FBTCxFQUFjbEcsSUFBSSxDQUFDa0csS0FBTCxDQUFXcWUsSUFBNUIsQ0FBa0MsQ0FDaENELEdBQUcsQ0FBQzgyQixRQUFKLENBQWFwN0MsSUFBSSxDQUFDa0csS0FBTCxDQUFXcWUsSUFBWCxDQUFnQjQyQixNQUE3QixDQUFxQyxTQUFTaGdDLEdBQVQsQ0FBYzFOLEtBQWQsQ0FBcUIsQ0FDeEQ2TixNQUFNLENBQUN2VixXQUFQLENBQW1CLENBQUNHLEtBQUssQ0FBRSxDQUFDcWUsSUFBSSxDQUFFLENBQUNwSixHQUFHLENBQUVBLEdBQU4sQ0FBVzFOLEtBQUssQ0FBRUEsS0FBbEIsQ0FBUCxDQUFSLENBQW5CLEVBQ0QsQ0FGRCxFQUdELENBQ0YsQ0FQRCxDQVFBO0FBQ0E2TixNQUFNLENBQUNyUSxnQkFBUCxDQUF3QixTQUF4QixDQUFtQyt3QyxRQUFuQyxFQUNELENBQ0YsQ0EzQkQsQ0E2QkEsTUFBTzEzQixJQUFQLENBQ0QsQ0ExWEQsQ0E2WEEsS0FBTyxDQTczaEJHLENBODNoQlYsUUE5M2hCVSxDQSszaEJWLEtBQU8sU0FBU3ZjLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7Ozs7OztHQVVBLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQSxHQUFJOHpDLFFBQU8sQ0FBRyxDQUNaLElBRFksQ0FDTixJQURNLENBQ0EsSUFEQSxDQUNNLElBRE4sQ0FDWSxJQURaLENBQ2tCLElBRGxCLENBQ3dCLElBRHhCLENBQzhCLElBRDlCLENBQ29DLElBRHBDLENBQzBDLElBRDFDLENBQ2dELElBRGhELENBQ3NELElBRHRELENBQzRELElBRDVELENBQ2tFLElBRGxFLENBQ3dFLElBRHhFLENBQzhFLElBRDlFLENBRVosSUFGWSxDQUVOLElBRk0sQ0FFQSxJQUZBLENBRU0sSUFGTixDQUVZLElBRlosQ0FFa0IsSUFGbEIsQ0FFd0IsSUFGeEIsQ0FFOEIsSUFGOUIsQ0FFb0MsSUFGcEMsQ0FFMEMsSUFGMUMsQ0FFZ0QsSUFGaEQsQ0FFc0QsSUFGdEQsQ0FFNEQsSUFGNUQsQ0FFa0UsSUFGbEUsQ0FFd0UsSUFGeEUsQ0FFOEUsSUFGOUUsQ0FHWixJQUhZLENBR04sSUFITSxDQUdBLElBSEEsQ0FHTSxJQUhOLENBR1ksSUFIWixDQUdrQixJQUhsQixDQUd3QixJQUh4QixDQUc4QixJQUg5QixDQUdvQyxJQUhwQyxDQUcwQyxJQUgxQyxDQUdnRCxJQUhoRCxDQUdzRCxJQUh0RCxDQUc0RCxJQUg1RCxDQUdrRSxJQUhsRSxDQUd3RSxJQUh4RSxDQUc4RSxJQUg5RSxDQUlaLElBSlksQ0FJTixJQUpNLENBSUEsSUFKQSxDQUlNLElBSk4sQ0FJWSxJQUpaLENBSWtCLElBSmxCLENBSXdCLElBSnhCLENBSThCLElBSjlCLENBSW9DLElBSnBDLENBSTBDLElBSjFDLENBSWdELElBSmhELENBSXNELElBSnRELENBSTRELElBSjVELENBSWtFLElBSmxFLENBSXdFLElBSnhFLENBSThFLElBSjlFLENBS1osSUFMWSxDQUtOLElBTE0sQ0FLQSxJQUxBLENBS00sSUFMTixDQUtZLElBTFosQ0FLa0IsSUFMbEIsQ0FLd0IsSUFMeEIsQ0FLOEIsSUFMOUIsQ0FLb0MsSUFMcEMsQ0FLMEMsSUFMMUMsQ0FLZ0QsSUFMaEQsQ0FLc0QsSUFMdEQsQ0FLNEQsSUFMNUQsQ0FLa0UsSUFMbEUsQ0FLd0UsSUFMeEUsQ0FLOEUsSUFMOUUsQ0FNWixJQU5ZLENBTU4sSUFOTSxDQU1BLElBTkEsQ0FNTSxJQU5OLENBTVksSUFOWixDQU1rQixJQU5sQixDQU13QixJQU54QixDQU04QixJQU45QixDQU1vQyxJQU5wQyxDQU0wQyxJQU4xQyxDQU1nRCxJQU5oRCxDQU1zRCxJQU50RCxDQU00RCxJQU41RCxDQU1rRSxJQU5sRSxDQU13RSxJQU54RSxDQU04RSxJQU45RSxDQU9aLElBUFksQ0FPTixJQVBNLENBT0EsSUFQQSxDQU9NLElBUE4sQ0FPWSxJQVBaLENBT2tCLElBUGxCLENBT3dCLElBUHhCLENBTzhCLElBUDlCLENBT29DLElBUHBDLENBTzBDLElBUDFDLENBT2dELElBUGhELENBT3NELElBUHRELENBTzRELElBUDVELENBT2tFLElBUGxFLENBT3dFLElBUHhFLENBTzhFLElBUDlFLENBUVosSUFSWSxDQVFOLElBUk0sQ0FRQSxJQVJBLENBUU0sSUFSTixDQVFZLElBUlosQ0FRa0IsSUFSbEIsQ0FRd0IsSUFSeEIsQ0FROEIsSUFSOUIsQ0FRb0MsSUFScEMsQ0FRMEMsSUFSMUMsQ0FRZ0QsSUFSaEQsQ0FRc0QsSUFSdEQsQ0FRNEQsSUFSNUQsQ0FRa0UsSUFSbEUsQ0FRd0UsSUFSeEUsQ0FROEUsSUFSOUUsQ0FTWixJQVRZLENBU04sSUFUTSxDQVNBLElBVEEsQ0FTTSxJQVROLENBU1ksSUFUWixDQVNrQixJQVRsQixDQVN3QixJQVR4QixDQVM4QixJQVQ5QixDQVNvQyxJQVRwQyxDQVMwQyxJQVQxQyxDQVNnRCxJQVRoRCxDQVNzRCxJQVR0RCxDQVM0RCxJQVQ1RCxDQVNrRSxJQVRsRSxDQVN3RSxJQVR4RSxDQVM4RSxJQVQ5RSxDQVVaLElBVlksQ0FVTixJQVZNLENBVUEsSUFWQSxDQVVNLElBVk4sQ0FVWSxJQVZaLENBVWtCLElBVmxCLENBVXdCLElBVnhCLENBVThCLElBVjlCLENBVW9DLElBVnBDLENBVTBDLElBVjFDLENBVWdELElBVmhELENBVXNELElBVnRELENBVTRELElBVjVELENBVWtFLElBVmxFLENBVXdFLElBVnhFLENBVThFLElBVjlFLENBV1osSUFYWSxDQVdOLElBWE0sQ0FXQSxJQVhBLENBV00sSUFYTixDQVdZLElBWFosQ0FXa0IsSUFYbEIsQ0FXd0IsSUFYeEIsQ0FXOEIsSUFYOUIsQ0FXb0MsSUFYcEMsQ0FXMEMsSUFYMUMsQ0FXZ0QsSUFYaEQsQ0FXc0QsSUFYdEQsQ0FXNEQsSUFYNUQsQ0FXa0UsSUFYbEUsQ0FXd0UsSUFYeEUsQ0FXOEUsSUFYOUUsQ0FZWixJQVpZLENBWU4sSUFaTSxDQVlBLElBWkEsQ0FZTSxJQVpOLENBWVksSUFaWixDQVlrQixJQVpsQixDQVl3QixJQVp4QixDQVk4QixJQVo5QixDQVlvQyxJQVpwQyxDQVkwQyxJQVoxQyxDQVlnRCxJQVpoRCxDQVlzRCxJQVp0RCxDQVk0RCxJQVo1RCxDQVlrRSxJQVpsRSxDQVl3RSxJQVp4RSxDQVk4RSxJQVo5RSxDQWFaLElBYlksQ0FhTixJQWJNLENBYUEsSUFiQSxDQWFNLElBYk4sQ0FhWSxJQWJaLENBYWtCLElBYmxCLENBYXdCLElBYnhCLENBYThCLElBYjlCLENBYW9DLElBYnBDLENBYTBDLElBYjFDLENBYWdELElBYmhELENBYXNELElBYnRELENBYTRELElBYjVELENBYWtFLElBYmxFLENBYXdFLElBYnhFLENBYThFLElBYjlFLENBY1osSUFkWSxDQWNOLElBZE0sQ0FjQSxJQWRBLENBY00sSUFkTixDQWNZLElBZFosQ0Fja0IsSUFkbEIsQ0Fjd0IsSUFkeEIsQ0FjOEIsSUFkOUIsQ0Fjb0MsSUFkcEMsQ0FjMEMsSUFkMUMsQ0FjZ0QsSUFkaEQsQ0Fjc0QsSUFkdEQsQ0FjNEQsSUFkNUQsQ0Fja0UsSUFkbEUsQ0Fjd0UsSUFkeEUsQ0FjOEUsSUFkOUUsQ0FlWixJQWZZLENBZU4sSUFmTSxDQWVBLElBZkEsQ0FlTSxJQWZOLENBZVksSUFmWixDQWVrQixJQWZsQixDQWV3QixJQWZ4QixDQWU4QixJQWY5QixDQWVvQyxJQWZwQyxDQWUwQyxJQWYxQyxDQWVnRCxJQWZoRCxDQWVzRCxJQWZ0RCxDQWU0RCxJQWY1RCxDQWVrRSxJQWZsRSxDQWV3RSxJQWZ4RSxDQWU4RSxJQWY5RSxDQWdCWixJQWhCWSxDQWdCTixJQWhCTSxDQWdCQSxJQWhCQSxDQWdCTSxJQWhCTixDQWdCWSxJQWhCWixDQWdCa0IsSUFoQmxCLENBZ0J3QixJQWhCeEIsQ0FnQjhCLElBaEI5QixDQWdCb0MsSUFoQnBDLENBZ0IwQyxJQWhCMUMsQ0FnQmdELElBaEJoRCxDQWdCc0QsSUFoQnRELENBZ0I0RCxJQWhCNUQsQ0FnQmtFLElBaEJsRSxDQWdCd0UsSUFoQnhFLENBZ0I4RSxJQWhCOUUsQ0FBZCxDQW1CQSxHQUFJeHlDLEVBQUMsQ0FBRyxDQUFDLENBQUQsQ0FBSSxDQUFKLENBQU8sQ0FBUCxDQUFVLENBQVYsQ0FBUixDQUVBOzs7Ozs7Ozs7R0FVQSxHQUFJeXlDLElBQUcsQ0FBRyxRQUFOQSxJQUFNLENBQVNDLElBQVQsQ0FBZWwwQixJQUFmLENBQXFCLENBQzdCLE1BQVNrMEIsS0FBSSxFQUFJbDBCLElBQVQsQ0FBaUIsTUFBbEIsQ0FBNkIsQ0FBQ2swQixJQUFJLENBQUcsTUFBUixHQUFvQixHQUFLbDBCLElBQTdELENBQ0QsQ0FGRCxDQUlBOzs7Ozs7Ozs7R0FVQSxHQUFJbTBCLElBQUcsQ0FBRyxRQUFOQSxJQUFNLENBQVNELElBQVQsQ0FBZWwwQixJQUFmLENBQXFCLENBQzdCLE1BQVEsQ0FBQ2swQixJQUFJLENBQUcsTUFBUixHQUFtQmwwQixJQUFwQixDQUE4QmswQixJQUFJLEVBQUssR0FBS2wwQixJQUFmLENBQXdCLE1BQTVELENBQ0QsQ0FGRCxDQUlBLGFBQ0FuZ0IsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDc3ZCLEdBQU4sQ0FBWXR2QixLQUFLLENBQUNzdkIsR0FBTixFQUFhLEVBQTFDLENBRUE7Ozs7OztHQU9BdHZCLEtBQUssQ0FBQ3N2QixHQUFOLENBQVU4bUIsU0FBVixDQUFzQixTQUFTbjhDLEdBQVQsQ0FBY284QyxVQUFkLENBQTBCLENBQzlDLEdBQUcsTUFBT3A4QyxJQUFQLEdBQWUsUUFBbEIsQ0FBNEIsQ0FDMUJBLEdBQUcsQ0FBRytGLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0J0UCxHQUF4QixDQUFOLENBQ0QsQ0FDRG84QyxVQUFVLENBQUdBLFVBQVUsRUFBSSxHQUEzQixDQUVBLGdFQUNBLEdBQUlDLEVBQUMsQ0FBR3I4QyxHQUFSLENBQ0EsR0FBSXM4QyxFQUFDLENBQUd0OEMsR0FBRyxDQUFDL0IsTUFBSixFQUFSLENBQ0EsR0FBSXMrQyxHQUFFLENBQUdILFVBQVQsQ0FDQSxHQUFJSSxHQUFFLENBQUczM0MsSUFBSSxDQUFDOEwsSUFBTCxDQUFVNHJDLEVBQUUsQ0FBRyxDQUFmLENBQVQsQ0FDQSxHQUFJRSxHQUFFLENBQUcsT0FBU0YsRUFBRSxDQUFHLElBQWQsQ0FBVCxDQUNBLEdBQUlwMEMsRUFBSixDQUVBLElBQUlBLENBQUMsQ0FBR20wQyxDQUFSLENBQVduMEMsQ0FBQyxDQUFHLEdBQWYsQ0FBb0JBLENBQUMsRUFBckIsQ0FBeUIsQ0FDdkJrMEMsQ0FBQyxDQUFDdHZDLE9BQUYsQ0FBVWd2QyxPQUFPLENBQUVNLENBQUMsQ0FBQ2x0QyxFQUFGLENBQUtoSCxDQUFDLENBQUcsQ0FBVCxFQUFjazBDLENBQUMsQ0FBQ2x0QyxFQUFGLENBQUtoSCxDQUFDLENBQUdtMEMsQ0FBVCxDQUFmLENBQThCLElBQS9CLENBQWpCLEVBQ0QsQ0FFREQsQ0FBQyxDQUFDanRDLEtBQUYsQ0FBUSxJQUFNb3RDLEVBQWQsQ0FBa0JULE9BQU8sQ0FBQ00sQ0FBQyxDQUFDbHRDLEVBQUYsQ0FBSyxJQUFNcXRDLEVBQVgsRUFBaUJDLEVBQWxCLENBQXpCLEVBRUEsSUFBSXQwQyxDQUFDLENBQUcsSUFBTXEwQyxFQUFkLENBQWtCcjBDLENBQUMsRUFBSSxDQUF2QixDQUEwQkEsQ0FBQyxFQUEzQixDQUErQixDQUM3QmswQyxDQUFDLENBQUNqdEMsS0FBRixDQUFRakgsQ0FBUixDQUFXNHpDLE9BQU8sQ0FBQ00sQ0FBQyxDQUFDbHRDLEVBQUYsQ0FBS2hILENBQUMsQ0FBRyxDQUFULEVBQWNrMEMsQ0FBQyxDQUFDbHRDLEVBQUYsQ0FBS2hILENBQUMsQ0FBR3EwQyxFQUFULENBQWYsQ0FBbEIsRUFDRCxDQUVELE1BQU9ILEVBQVAsQ0FDRCxDQXpCRCxDQTJCQTs7Ozs7Ozs7R0FTQSxHQUFJM3FCLGFBQVksQ0FBRyxRQUFmQSxhQUFlLENBQVMxeEIsR0FBVCxDQUFjK25CLElBQWQsQ0FBb0JYLE9BQXBCLENBQTZCLENBQzlDLEdBQUltUSxRQUFPLENBQUcsS0FBZCxDQUFxQkMsTUFBTSxDQUFHLElBQTlCLENBQW9Da2xCLE9BQU8sQ0FBRyxJQUE5QyxDQUFvRHRrQixHQUFHLENBQUcsSUFBMUQsQ0FDQSxHQUFJdWtCLFNBQUosQ0FBY0MsU0FBZCxDQUNBLEdBQUl6MEMsRUFBSixDQUFPd0wsQ0FBUCxDQUFVa3BDLENBQUMsQ0FBRyxFQUFkLENBRUEsd0NBQ0E3OEMsR0FBRyxDQUFHK0YsS0FBSyxDQUFDc3ZCLEdBQU4sQ0FBVThtQixTQUFWLENBQW9CbjhDLEdBQXBCLENBQXlCK25CLElBQXpCLENBQU4sQ0FDQSxJQUFJNWYsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHLEVBQWYsQ0FBbUJBLENBQUMsRUFBcEIsQ0FBd0IsQ0FDdEIwMEMsQ0FBQyxDQUFDaHlDLElBQUYsQ0FBTzdLLEdBQUcsQ0FBQzBPLFVBQUosRUFBUCxFQUNELENBRUQsR0FBRzBZLE9BQUgsQ0FBWSxDQUNWOzs7O09BS0F1MUIsUUFBUSxDQUFHLGtCQUFTRyxDQUFULENBQVksQ0FDckIsSUFBSTMwQyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUcsQ0FBZixDQUFrQkEsQ0FBQyxFQUFuQixDQUF1QixDQUNyQjIwQyxDQUFDLENBQUMzMEMsQ0FBRCxDQUFELEVBQVEwMEMsQ0FBQyxDQUFDbHBDLENBQUQsQ0FBRCxFQUFRbXBDLENBQUMsQ0FBQyxDQUFDMzBDLENBQUMsQ0FBRyxDQUFMLEVBQVUsQ0FBWCxDQUFELENBQWlCMjBDLENBQUMsQ0FBQyxDQUFDMzBDLENBQUMsQ0FBRyxDQUFMLEVBQVUsQ0FBWCxDQUExQixHQUNKLENBQUMyMEMsQ0FBQyxDQUFDLENBQUMzMEMsQ0FBQyxDQUFHLENBQUwsRUFBVSxDQUFYLENBQUgsQ0FBb0IyMEMsQ0FBQyxDQUFDLENBQUMzMEMsQ0FBQyxDQUFHLENBQUwsRUFBVSxDQUFYLENBRGhCLENBQVIsQ0FFQTIwQyxDQUFDLENBQUMzMEMsQ0FBRCxDQUFELENBQU82ekMsR0FBRyxDQUFDYyxDQUFDLENBQUMzMEMsQ0FBRCxDQUFGLENBQU9vQixDQUFDLENBQUNwQixDQUFELENBQVIsQ0FBVixDQUNBd0wsQ0FBQyxHQUNGLENBQ0YsQ0FQRCxDQVNBOzs7O09BS0FpcEMsU0FBUyxDQUFHLG1CQUFTRSxDQUFULENBQVksQ0FDdEIsSUFBSTMwQyxDQUFDLENBQUcsQ0FBUixDQUFXQSxDQUFDLENBQUcsQ0FBZixDQUFrQkEsQ0FBQyxFQUFuQixDQUF1QixDQUNyQjIwQyxDQUFDLENBQUMzMEMsQ0FBRCxDQUFELEVBQVEwMEMsQ0FBQyxDQUFDQyxDQUFDLENBQUMsQ0FBQzMwQyxDQUFDLENBQUcsQ0FBTCxFQUFVLENBQVgsQ0FBRCxDQUFpQixFQUFsQixDQUFULENBQ0QsQ0FDRixDQUpELENBS0QsQ0F6QkQsSUF5Qk8sQ0FDTDs7OztPQUtBdzBDLFFBQVEsQ0FBRyxrQkFBU0csQ0FBVCxDQUFZLENBQ3JCLElBQUkzMEMsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxFQUFJLENBQWhCLENBQW1CQSxDQUFDLEVBQXBCLENBQXdCLENBQ3RCMjBDLENBQUMsQ0FBQzMwQyxDQUFELENBQUQsQ0FBTyt6QyxHQUFHLENBQUNZLENBQUMsQ0FBQzMwQyxDQUFELENBQUYsQ0FBT29CLENBQUMsQ0FBQ3BCLENBQUQsQ0FBUixDQUFWLENBQ0EyMEMsQ0FBQyxDQUFDMzBDLENBQUQsQ0FBRCxFQUFRMDBDLENBQUMsQ0FBQ2xwQyxDQUFELENBQUQsRUFBUW1wQyxDQUFDLENBQUMsQ0FBQzMwQyxDQUFDLENBQUcsQ0FBTCxFQUFVLENBQVgsQ0FBRCxDQUFpQjIwQyxDQUFDLENBQUMsQ0FBQzMwQyxDQUFDLENBQUcsQ0FBTCxFQUFVLENBQVgsQ0FBMUIsR0FDSixDQUFDMjBDLENBQUMsQ0FBQyxDQUFDMzBDLENBQUMsQ0FBRyxDQUFMLEVBQVUsQ0FBWCxDQUFILENBQW9CMjBDLENBQUMsQ0FBQyxDQUFDMzBDLENBQUMsQ0FBRyxDQUFMLEVBQVUsQ0FBWCxDQURoQixDQUFSLENBRUF3TCxDQUFDLEdBQ0YsQ0FDRixDQVBELENBU0E7Ozs7T0FLQWlwQyxTQUFTLENBQUcsbUJBQVNFLENBQVQsQ0FBWSxDQUN0QixJQUFJMzBDLENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsRUFBSSxDQUFoQixDQUFtQkEsQ0FBQyxFQUFwQixDQUF3QixDQUN0QjIwQyxDQUFDLENBQUMzMEMsQ0FBRCxDQUFELEVBQVEwMEMsQ0FBQyxDQUFDQyxDQUFDLENBQUMsQ0FBQzMwQyxDQUFDLENBQUcsQ0FBTCxFQUFVLENBQVgsQ0FBRCxDQUFpQixFQUFsQixDQUFULENBQ0QsQ0FDRixDQUpELENBS0QsQ0FFRDs7Ozs7Ozs7Ozs7O0tBYUEsR0FBSTQwQyxRQUFPLENBQUcsUUFBVkEsUUFBVSxDQUFTQyxJQUFULENBQWUsQ0FDM0IsR0FBSUYsRUFBQyxDQUFHLEVBQVIsQ0FFQSwrREFDQSxJQUFJMzBDLENBQUMsQ0FBRyxDQUFSLENBQVdBLENBQUMsQ0FBRyxDQUFmLENBQWtCQSxDQUFDLEVBQW5CLENBQXVCLENBQ3JCLEdBQUlrTyxJQUFHLENBQUdtaEIsTUFBTSxDQUFDOW9CLFVBQVAsRUFBVixDQUVBLEdBQUcwcEIsR0FBRyxHQUFLLElBQVgsQ0FBaUIsQ0FDZixHQUFHaFIsT0FBSCxDQUFZLENBQ1YsMkNBQ0EvUSxHQUFHLEVBQUkraEIsR0FBRyxDQUFDMXBCLFVBQUosRUFBUCxDQUNELENBSEQsSUFHTyxDQUNMLHdEQUNBMHBCLEdBQUcsQ0FBQ3ZxQixVQUFKLENBQWV3SSxHQUFmLEVBQ0QsQ0FDRixDQUVEeW1DLENBQUMsQ0FBQ2p5QyxJQUFGLENBQU93TCxHQUFHLENBQUcsTUFBYixFQUNELENBRUQsNENBQ0ExQyxDQUFDLENBQUd5VCxPQUFPLENBQUcsQ0FBSCxDQUFPLEVBQWxCLENBRUEseUJBQ0EsSUFBSSxHQUFJNjFCLElBQUcsQ0FBRyxDQUFkLENBQWlCQSxHQUFHLENBQUdELElBQUksQ0FBQy8rQyxNQUE1QixDQUFvQ2cvQyxHQUFHLEVBQXZDLENBQTJDLENBQ3pDLElBQUksR0FBSXp0QixJQUFHLENBQUcsQ0FBZCxDQUFpQkEsR0FBRyxDQUFHd3RCLElBQUksQ0FBQ0MsR0FBRCxDQUFKLENBQVUsQ0FBVixDQUF2QixDQUFxQ3p0QixHQUFHLEVBQXhDLENBQTRDLENBQzFDd3RCLElBQUksQ0FBQ0MsR0FBRCxDQUFKLENBQVUsQ0FBVixFQUFhSCxDQUFiLEVBQ0QsQ0FDRixDQUVELHlDQUNBLElBQUkzMEMsQ0FBQyxDQUFHLENBQVIsQ0FBV0EsQ0FBQyxDQUFHLENBQWYsQ0FBa0JBLENBQUMsRUFBbkIsQ0FBdUIsQ0FDckIsR0FBR2l3QixHQUFHLEdBQUssSUFBWCxDQUFpQixDQUNmLEdBQUdoUixPQUFILENBQVksQ0FDVjs0REFFQWdSLEdBQUcsQ0FBQ3ZxQixVQUFKLENBQWVpdkMsQ0FBQyxDQUFDMzBDLENBQUQsQ0FBaEIsRUFDRCxDQUpELElBSU8sQ0FDTDIwQyxDQUFDLENBQUMzMEMsQ0FBRCxDQUFELEVBQVFpd0IsR0FBRyxDQUFDMXBCLFVBQUosRUFBUixDQUNELENBQ0YsQ0FFRGd1QyxPQUFPLENBQUM3dUMsVUFBUixDQUFtQml2QyxDQUFDLENBQUMzMEMsQ0FBRCxDQUFwQixFQUNELENBQ0YsQ0E1Q0QsQ0E4Q0EsMEJBQ0EsR0FBSTJiLE9BQU0sQ0FBRyxJQUFiLENBQ0FBLE1BQU0sQ0FBRyxDQUNQOzs7Ozs7Ozs7T0FVQWhRLEtBQUssQ0FBRSxlQUFTc2EsRUFBVCxDQUFhMWIsTUFBYixDQUFxQixDQUMxQixHQUFHMGIsRUFBSCxDQUFPLENBQ0wsY0FDQSxHQUFHLE1BQU9BLEdBQVAsR0FBYyxRQUFqQixDQUEyQixDQUN6QkEsRUFBRSxDQUFHcm9CLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0I4ZSxFQUF4QixDQUFMLENBQ0QsQ0FDRixDQUVEbUosT0FBTyxDQUFHLEtBQVYsQ0FDQUMsTUFBTSxDQUFHenhCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsRUFBVCxDQUNBb3RDLE9BQU8sQ0FBR2hxQyxNQUFNLEVBQUksR0FBSTNNLE1BQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQWYsRUFBcEIsQ0FDQThvQixHQUFHLENBQUdoSyxFQUFOLENBRUF0SyxNQUFNLENBQUNwUixNQUFQLENBQWdCZ3FDLE9BQWhCLENBQ0QsQ0F6Qk0sQ0EyQlA7Ozs7T0FLQTNpQyxNQUFNLENBQUUsZ0JBQVN0SSxLQUFULENBQWdCLENBQ3RCLEdBQUcsQ0FBQzhsQixPQUFKLENBQWEsQ0FDWDtBQUNBQyxNQUFNLENBQUN0cEIsU0FBUCxDQUFpQnVELEtBQWpCLEVBQ0QsQ0FFRCxNQUFNK2xCLE1BQU0sQ0FBQ3Y1QixNQUFQLElBQW1CLENBQXpCLENBQTRCLENBQzFCOCtDLE9BQU8sQ0FBQyxDQUNKLENBQUUsQ0FBRixDQUFLSixRQUFMLENBREksQ0FFSixDQUFFLENBQUYsQ0FBS0MsU0FBTCxDQUZJLENBR0osQ0FBRSxDQUFGLENBQUtELFFBQUwsQ0FISSxDQUlKLENBQUUsQ0FBRixDQUFLQyxTQUFMLENBSkksQ0FLSixDQUFFLENBQUYsQ0FBS0QsUUFBTCxDQUxJLENBQUQsQ0FBUCxDQU9ELENBQ0YsQ0EvQ00sQ0FpRFA7Ozs7Ozs7T0FRQXJ2QixNQUFNLENBQUUsZ0JBQVNxSyxHQUFULENBQWMsQ0FDcEIsR0FBSXBwQixLQUFJLENBQUcsSUFBWCxDQUVBLEdBQUc2WSxPQUFILENBQVksQ0FDVixHQUFHdVEsR0FBSCxDQUFRLENBQ05wcEIsSUFBSSxDQUFHb3BCLEdBQUcsQ0FBQyxDQUFELENBQUlILE1BQUosQ0FBWSxDQUFDcFEsT0FBYixDQUFWLENBQ0QsQ0FGRCxJQUVPLENBQ0w7QUFDQTtBQUNBLEdBQUk4USxRQUFPLENBQUlWLE1BQU0sQ0FBQ3Y1QixNQUFQLEtBQW9CLENBQXJCLENBQTBCLENBQTFCLENBQStCLEVBQUl1NUIsTUFBTSxDQUFDdjVCLE1BQVAsRUFBakQsQ0FDQXU1QixNQUFNLENBQUNucUIsWUFBUCxDQUFvQjZxQixPQUFwQixDQUE2QkEsT0FBN0IsRUFDRCxDQUNGLENBRUQsR0FBRzNwQixJQUFILENBQVMsQ0FDUDtBQUNBZ3BCLE9BQU8sQ0FBRyxJQUFWLENBQ0F6VCxNQUFNLENBQUMvSixNQUFQLEdBQ0QsQ0FFRCxHQUFHLENBQUNxTixPQUFKLENBQWEsQ0FDWDtBQUNBN1ksSUFBSSxDQUFJaXBCLE1BQU0sQ0FBQ3Y1QixNQUFQLEtBQW9CLENBQTVCLENBQ0EsR0FBR3NRLElBQUgsQ0FBUyxDQUNQLEdBQUdvcEIsR0FBSCxDQUFRLENBQ05wcEIsSUFBSSxDQUFHb3BCLEdBQUcsQ0FBQyxDQUFELENBQUkra0IsT0FBSixDQUFhLENBQUN0MUIsT0FBZCxDQUFWLENBQ0QsQ0FGRCxJQUVPLENBQ0w7QUFDQSxHQUFJM1gsSUFBRyxDQUFHaXRDLE9BQU8sQ0FBQ3orQyxNQUFSLEVBQVYsQ0FDQSxHQUFJK1EsTUFBSyxDQUFHMHRDLE9BQU8sQ0FBQ3Z0QyxFQUFSLENBQVdNLEdBQUcsQ0FBRyxDQUFqQixDQUFaLENBRUEsR0FBR1QsS0FBSyxDQUFHUyxHQUFYLENBQWdCLENBQ2RsQixJQUFJLENBQUcsS0FBUCxDQUNELENBRkQsSUFFTyxDQUNMO0FBQ0FtdUMsT0FBTyxDQUFDbHRDLFFBQVIsQ0FBaUJSLEtBQWpCLEVBQ0QsQ0FDRixDQUNGLENBQ0YsQ0FFRCxNQUFPVCxLQUFQLENBQ0QsQ0FuR00sQ0FBVCxDQXNHQSxNQUFPdVYsT0FBUCxDQUNELENBbk9ELENBcU9BOzs7Ozs7Ozs7Ozs7O0dBY0EvZCxLQUFLLENBQUNzdkIsR0FBTixDQUFVbEgsZUFBVixDQUE0QixTQUFTbnVCLEdBQVQsQ0FBY291QixFQUFkLENBQWtCMWIsTUFBbEIsQ0FBMEIsQ0FDcEQsR0FBSW9SLE9BQU0sQ0FBRy9kLEtBQUssQ0FBQ3N2QixHQUFOLENBQVU5RyxzQkFBVixDQUFpQ3Z1QixHQUFqQyxDQUFzQyxHQUF0QyxDQUFiLENBQ0E4akIsTUFBTSxDQUFDaFEsS0FBUCxDQUFhc2EsRUFBYixDQUFpQjFiLE1BQWpCLEVBQ0EsTUFBT29SLE9BQVAsQ0FDRCxDQUpELENBTUE7Ozs7Ozs7Ozs7OztHQWFBL2QsS0FBSyxDQUFDc3ZCLEdBQU4sQ0FBVTlHLHNCQUFWLENBQW1DLFNBQVN2dUIsR0FBVCxDQUFjK25CLElBQWQsQ0FBb0IsQ0FDckQsTUFBTzJKLGFBQVksQ0FBQzF4QixHQUFELENBQU0rbkIsSUFBTixDQUFZLElBQVosQ0FBbkIsQ0FDRCxDQUZELENBSUE7Ozs7Ozs7Ozs7Ozs7R0FjQWhpQixLQUFLLENBQUNzdkIsR0FBTixDQUFVN0csZUFBVixDQUE0QixTQUFTeHVCLEdBQVQsQ0FBY291QixFQUFkLENBQWtCMWIsTUFBbEIsQ0FBMEIsQ0FDcEQsR0FBSW9SLE9BQU0sQ0FBRy9kLEtBQUssQ0FBQ3N2QixHQUFOLENBQVU1RyxzQkFBVixDQUFpQ3p1QixHQUFqQyxDQUFzQyxHQUF0QyxDQUFiLENBQ0E4akIsTUFBTSxDQUFDaFEsS0FBUCxDQUFhc2EsRUFBYixDQUFpQjFiLE1BQWpCLEVBQ0EsTUFBT29SLE9BQVAsQ0FDRCxDQUpELENBTUE7Ozs7Ozs7Ozs7OztHQWFBL2QsS0FBSyxDQUFDc3ZCLEdBQU4sQ0FBVTVHLHNCQUFWLENBQW1DLFNBQVN6dUIsR0FBVCxDQUFjK25CLElBQWQsQ0FBb0IsQ0FDckQsTUFBTzJKLGFBQVksQ0FBQzF4QixHQUFELENBQU0rbkIsSUFBTixDQUFZLEtBQVosQ0FBbkIsQ0FDRCxDQUZELENBS0EsS0FBTyxDQTd4aUJHLENBOHhpQlYsUUE5eGlCVSxDQSt4aUJWLEtBQU8sU0FBU25nQixNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZDQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUVBO0FBQ0EsR0FBSThpQixNQUFLLENBQUduakIsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDZ2xCLEtBQU4sQ0FBY2hsQixLQUFLLENBQUNnbEIsS0FBTixFQUFlLEVBQTFELENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JBQSxLQUFLLENBQUNDLGVBQU4sQ0FBd0IsU0FBU2hyQixHQUFULENBQWMwQyxPQUFkLENBQXVCcEYsT0FBdkIsQ0FBZ0MsQ0FDdEQ7QUFDQSxHQUFJNC9DLE1BQUosQ0FDQSxHQUFJcjVCLEtBQUosQ0FDQSxHQUFJVCxHQUFKLENBQ0EsR0FBSSs1QixPQUFKLENBQ0E7QUFDQSxHQUFHLE1BQU83L0MsUUFBUCxHQUFtQixRQUF0QixDQUFnQyxDQUM5QjQvQyxLQUFLLENBQUc1L0MsT0FBUixDQUNBdW1CLElBQUksQ0FBRzVaLFNBQVMsQ0FBQyxDQUFELENBQVQsRUFBZ0JELFNBQXZCLENBQ0FvWixFQUFFLENBQUduWixTQUFTLENBQUMsQ0FBRCxDQUFULEVBQWdCRCxTQUFyQixDQUNELENBSkQsSUFJTyxJQUFHMU0sT0FBSCxDQUFZLENBQ2pCNC9DLEtBQUssQ0FBRzUvQyxPQUFPLENBQUM0L0MsS0FBUixFQUFpQmx6QyxTQUF6QixDQUNBNlosSUFBSSxDQUFHdm1CLE9BQU8sQ0FBQ3VtQixJQUFSLEVBQWdCN1osU0FBdkIsQ0FDQW9aLEVBQUUsQ0FBRzlsQixPQUFPLENBQUM4bEIsRUFBUixFQUFjcFosU0FBbkIsQ0FDQSxHQUFHMU0sT0FBTyxDQUFDOC9DLElBQVIsRUFBZ0I5L0MsT0FBTyxDQUFDOC9DLElBQVIsQ0FBYWg2QixFQUFoQyxDQUFvQyxDQUNsQys1QixNQUFNLENBQUc3L0MsT0FBTyxDQUFDOC9DLElBQVIsQ0FBYWg2QixFQUF0QixDQUNELENBQ0YsQ0FFRDtBQUNBLEdBQUcsQ0FBQ0EsRUFBSixDQUFRLENBQ05BLEVBQUUsQ0FBR3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU21TLElBQVQsQ0FBYy8wQixNQUFkLEVBQUwsQ0FDRCxDQUZELElBRU8sQ0FDTDRpQixFQUFFLENBQUN0UCxLQUFILEdBQ0QsQ0FFRDtBQUNBLEdBQUcsQ0FBQ3FwQyxNQUFKLENBQVksQ0FDVkEsTUFBTSxDQUFHLzVCLEVBQVQsQ0FDRCxDQUVEO0FBQ0EsR0FBSWk2QixVQUFTLENBQUd4NEMsSUFBSSxDQUFDOEwsSUFBTCxDQUFVM1EsR0FBRyxDQUFDOEksQ0FBSixDQUFNOGQsU0FBTixHQUFvQixDQUE5QixDQUFoQixDQUNBLEdBQUkwMkIsVUFBUyxDQUFHRCxTQUFTLENBQUcsRUFBSWo2QixFQUFFLENBQUNxUyxZQUFuQixDQUFrQyxDQUFsRCxDQUNBLEdBQUcveUIsT0FBTyxDQUFDekUsTUFBUixDQUFpQnEvQyxTQUFwQixDQUErQixDQUM3QixHQUFJcjlDLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLDhDQUFWLENBQVosQ0FDQWtDLEtBQUssQ0FBQ2hDLE1BQU4sQ0FBZXlFLE9BQU8sQ0FBQ3pFLE1BQXZCLENBQ0FnQyxLQUFLLENBQUNxOUMsU0FBTixDQUFrQkEsU0FBbEIsQ0FDQSxLQUFNcjlDLE1BQU4sQ0FDRCxDQUVELEdBQUcsQ0FBQ2k5QyxLQUFKLENBQVcsQ0FDVEEsS0FBSyxDQUFHLEVBQVIsQ0FDRCxDQUNEOTVCLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVW1qQyxLQUFWLENBQWlCLEtBQWpCLEVBQ0EsR0FBSUssTUFBSyxDQUFHbjZCLEVBQUUsQ0FBQzRDLE1BQUgsRUFBWixDQUVBLEdBQUl3M0IsR0FBRSxDQUFHLEVBQVQsQ0FDQSxHQUFJQyxVQUFTLENBQUdILFNBQVMsQ0FBRzU2QyxPQUFPLENBQUN6RSxNQUFwQyxDQUNBLElBQUssR0FBSWtLLEVBQUMsQ0FBRyxDQUFiLENBQWdCQSxDQUFDLENBQUdzMUMsU0FBcEIsQ0FBK0J0MUMsQ0FBQyxFQUFoQyxDQUFvQyxDQUNsQ3ExQyxFQUFFLEVBQUksTUFBTixDQUNELENBRUQsR0FBSXplLEdBQUUsQ0FBR3dlLEtBQUssQ0FBQ3B2QyxRQUFOLEdBQW1CcXZDLEVBQW5CLENBQXdCLE1BQXhCLENBQWlDOTZDLE9BQTFDLENBRUEsR0FBRyxDQUFDbWhCLElBQUosQ0FBVSxDQUNSQSxJQUFJLENBQUc5ZCxLQUFLLENBQUNqQixNQUFOLENBQWFxSixRQUFiLENBQXNCaVYsRUFBRSxDQUFDcVMsWUFBekIsQ0FBUCxDQUNELENBRkQsSUFFTyxJQUFHNVIsSUFBSSxDQUFDNWxCLE1BQUwsR0FBZ0JtbEIsRUFBRSxDQUFDcVMsWUFBdEIsQ0FBb0MsQ0FDekMsR0FBSXgxQixNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxpREFDcEIsMEJBRFUsQ0FBWixDQUVBa0MsS0FBSyxDQUFDeTlDLFVBQU4sQ0FBbUI3NUIsSUFBSSxDQUFDNWxCLE1BQXhCLENBQ0FnQyxLQUFLLENBQUN3MUIsWUFBTixDQUFxQnJTLEVBQUUsQ0FBQ3FTLFlBQXhCLENBQ0EsS0FBTXgxQixNQUFOLENBQ0QsQ0FFRCxHQUFJNjRDLE9BQU0sQ0FBRzZFLFFBQVEsQ0FBQzk1QixJQUFELENBQU93NUIsU0FBUyxDQUFHajZCLEVBQUUsQ0FBQ3FTLFlBQWYsQ0FBOEIsQ0FBckMsQ0FBd0MwbkIsTUFBeEMsQ0FBckIsQ0FDQSxHQUFJcEUsU0FBUSxDQUFHaHpDLEtBQUssQ0FBQzJELElBQU4sQ0FBV2lJLFFBQVgsQ0FBb0JvdEIsRUFBcEIsQ0FBd0IrWixNQUF4QixDQUFnQy9aLEVBQUUsQ0FBQzlnQyxNQUFuQyxDQUFmLENBRUEsR0FBSTIvQyxTQUFRLENBQUdELFFBQVEsQ0FBQzVFLFFBQUQsQ0FBVzMxQixFQUFFLENBQUNxUyxZQUFkLENBQTRCMG5CLE1BQTVCLENBQXZCLENBQ0EsR0FBSVUsV0FBVSxDQUFHOTNDLEtBQUssQ0FBQzJELElBQU4sQ0FBV2lJLFFBQVgsQ0FBb0JrUyxJQUFwQixDQUEwQis1QixRQUExQixDQUFvQy81QixJQUFJLENBQUM1bEIsTUFBekMsQ0FBakIsQ0FFQTtBQUNBLE1BQU8sT0FBUzQvQyxVQUFULENBQXNCOUUsUUFBN0IsQ0FDRCxDQTFFRCxDQTRFQTs7Ozs7Ozs7Ozs7Ozs7OztHQWlCQWh1QixLQUFLLENBQUNLLGVBQU4sQ0FBd0IsU0FBU3ByQixHQUFULENBQWNndEIsRUFBZCxDQUFrQjF2QixPQUFsQixDQUEyQixDQUNqRDtBQUNBLEdBQUk0L0MsTUFBSixDQUNBLEdBQUk5NUIsR0FBSixDQUNBLEdBQUkrNUIsT0FBSixDQUNBO0FBQ0EsR0FBRyxNQUFPNy9DLFFBQVAsR0FBbUIsUUFBdEIsQ0FBZ0MsQ0FDOUI0L0MsS0FBSyxDQUFHNS9DLE9BQVIsQ0FDQThsQixFQUFFLENBQUduWixTQUFTLENBQUMsQ0FBRCxDQUFULEVBQWdCRCxTQUFyQixDQUNELENBSEQsSUFHTyxJQUFHMU0sT0FBSCxDQUFZLENBQ2pCNC9DLEtBQUssQ0FBRzUvQyxPQUFPLENBQUM0L0MsS0FBUixFQUFpQmx6QyxTQUF6QixDQUNBb1osRUFBRSxDQUFHOWxCLE9BQU8sQ0FBQzhsQixFQUFSLEVBQWNwWixTQUFuQixDQUNBLEdBQUcxTSxPQUFPLENBQUM4L0MsSUFBUixFQUFnQjkvQyxPQUFPLENBQUM4L0MsSUFBUixDQUFhaDZCLEVBQWhDLENBQW9DLENBQ2xDKzVCLE1BQU0sQ0FBRzcvQyxPQUFPLENBQUM4L0MsSUFBUixDQUFhaDZCLEVBQXRCLENBQ0QsQ0FDRixDQUVEO0FBQ0EsR0FBSWk2QixVQUFTLENBQUd4NEMsSUFBSSxDQUFDOEwsSUFBTCxDQUFVM1EsR0FBRyxDQUFDOEksQ0FBSixDQUFNOGQsU0FBTixHQUFvQixDQUE5QixDQUFoQixDQUVBLEdBQUdvRyxFQUFFLENBQUMvdUIsTUFBSCxHQUFjby9DLFNBQWpCLENBQTRCLENBQzFCLEdBQUlwOUMsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsK0NBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDaEMsTUFBTixDQUFlK3VCLEVBQUUsQ0FBQy91QixNQUFsQixDQUNBZ0MsS0FBSyxDQUFDNjlDLGNBQU4sQ0FBdUJULFNBQXZCLENBQ0EsS0FBTXA5QyxNQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUdtakIsRUFBRSxHQUFLcFosU0FBVixDQUFxQixDQUNuQm9aLEVBQUUsQ0FBR3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU21TLElBQVQsQ0FBYy8wQixNQUFkLEVBQUwsQ0FDRCxDQUZELElBRU8sQ0FDTDRpQixFQUFFLENBQUN0UCxLQUFILEdBQ0QsQ0FFRDtBQUNBLEdBQUcsQ0FBQ3FwQyxNQUFKLENBQVksQ0FDVkEsTUFBTSxDQUFHLzVCLEVBQVQsQ0FDRCxDQUVELEdBQUdpNkIsU0FBUyxDQUFHLEVBQUlqNkIsRUFBRSxDQUFDcVMsWUFBUCxDQUFzQixDQUFyQyxDQUF3QyxDQUN0QyxLQUFNLElBQUkxM0IsTUFBSixDQUFVLG9EQUFWLENBQU4sQ0FDRCxDQUVELEdBQUcsQ0FBQ20vQyxLQUFKLENBQVcsQ0FDVEEsS0FBSyxDQUFHLEVBQVIsQ0FDRCxDQUNEOTVCLEVBQUUsQ0FBQ3JKLE1BQUgsQ0FBVW1qQyxLQUFWLENBQWlCLEtBQWpCLEVBQ0EsR0FBSUssTUFBSyxDQUFHbjZCLEVBQUUsQ0FBQzRDLE1BQUgsR0FBWTdYLFFBQVosRUFBWixDQUVBO0FBQ0EsR0FBSWdaLEVBQUMsQ0FBRzZGLEVBQUUsQ0FBQ2xhLE1BQUgsQ0FBVSxDQUFWLENBQVIsQ0FDQSxHQUFJK3FDLFdBQVUsQ0FBRzd3QixFQUFFLENBQUNoWixTQUFILENBQWEsQ0FBYixDQUFnQm9QLEVBQUUsQ0FBQ3FTLFlBQUgsQ0FBa0IsQ0FBbEMsQ0FBakIsQ0FDQSxHQUFJc2pCLFNBQVEsQ0FBRy9yQixFQUFFLENBQUNoWixTQUFILENBQWEsRUFBSW9QLEVBQUUsQ0FBQ3FTLFlBQXBCLENBQWYsQ0FFQSxHQUFJbW9CLFNBQVEsQ0FBR0QsUUFBUSxDQUFDNUUsUUFBRCxDQUFXMzFCLEVBQUUsQ0FBQ3FTLFlBQWQsQ0FBNEIwbkIsTUFBNUIsQ0FBdkIsQ0FDQSxHQUFJdDVCLEtBQUksQ0FBRzlkLEtBQUssQ0FBQzJELElBQU4sQ0FBV2lJLFFBQVgsQ0FBb0Jrc0MsVUFBcEIsQ0FBZ0NELFFBQWhDLENBQTBDQyxVQUFVLENBQUM1L0MsTUFBckQsQ0FBWCxDQUVBLEdBQUk2NkMsT0FBTSxDQUFHNkUsUUFBUSxDQUFDOTVCLElBQUQsQ0FBT3c1QixTQUFTLENBQUdqNkIsRUFBRSxDQUFDcVMsWUFBZixDQUE4QixDQUFyQyxDQUF3QzBuQixNQUF4QyxDQUFyQixDQUNBLEdBQUl2RSxHQUFFLENBQUc3eUMsS0FBSyxDQUFDMkQsSUFBTixDQUFXaUksUUFBWCxDQUFvQm9uQyxRQUFwQixDQUE4QkQsTUFBOUIsQ0FBc0NDLFFBQVEsQ0FBQzk2QyxNQUEvQyxDQUFULENBRUEsR0FBSTgvQyxXQUFVLENBQUduRixFQUFFLENBQUM1a0MsU0FBSCxDQUFhLENBQWIsQ0FBZ0JvUCxFQUFFLENBQUNxUyxZQUFuQixDQUFqQixDQUVBO0FBQ0EsR0FBSXgxQixNQUFLLENBQUlrbkIsQ0FBQyxHQUFLLE1BQW5CLENBRUE7QUFDQSxJQUFJLEdBQUloZixFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUdpYixFQUFFLENBQUNxUyxZQUF0QixDQUFvQyxFQUFFdHRCLENBQXRDLENBQXlDLENBQ3ZDbEksS0FBSyxFQUFLczlDLEtBQUssQ0FBQ3pxQyxNQUFOLENBQWEzSyxDQUFiLElBQW9CNDFDLFVBQVUsQ0FBQ2pyQyxNQUFYLENBQWtCM0ssQ0FBbEIsQ0FBOUIsQ0FDRCxDQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUk2MUMsTUFBSyxDQUFHLENBQVosQ0FDQSxHQUFJQyxNQUFLLENBQUc3NkIsRUFBRSxDQUFDcVMsWUFBZixDQUNBLElBQUksR0FBSTloQixFQUFDLENBQUd5UCxFQUFFLENBQUNxUyxZQUFmLENBQTZCOWhCLENBQUMsQ0FBR2lsQyxFQUFFLENBQUMzNkMsTUFBcEMsQ0FBNEMwVixDQUFDLEVBQTdDLENBQWlELENBQy9DLEdBQUkwRSxLQUFJLENBQUd1Z0MsRUFBRSxDQUFDdnFDLFVBQUgsQ0FBY3NGLENBQWQsQ0FBWCxDQUVBLEdBQUl1cUMsS0FBSSxDQUFJN2xDLElBQUksQ0FBRyxHQUFSLENBQWUsR0FBMUIsQ0FFQTtBQUNBLEdBQUk4bEMsV0FBVSxDQUFHSCxLQUFLLENBQUcsTUFBSCxDQUFZLE1BQWxDLENBQ0EvOUMsS0FBSyxFQUFLb1ksSUFBSSxDQUFHOGxDLFVBQWpCLENBRUE7QUFDQUgsS0FBSyxDQUFHQSxLQUFLLENBQUdFLElBQWhCLENBQ0FELEtBQUssRUFBSUQsS0FBVCxDQUNELENBRUQsR0FBRy85QyxLQUFLLEVBQUkyNEMsRUFBRSxDQUFDdnFDLFVBQUgsQ0FBYzR2QyxLQUFkLElBQXlCLEdBQXJDLENBQTBDLENBQ3hDLEtBQU0sSUFBSWxnRCxNQUFKLENBQVUsNkJBQVYsQ0FBTixDQUNELENBRUQsTUFBTzY2QyxHQUFFLENBQUM1a0MsU0FBSCxDQUFhaXFDLEtBQUssQ0FBRyxDQUFyQixDQUFQLENBQ0QsQ0E5RkQsQ0FnR0EsUUFBU04sU0FBVCxDQUFrQjk1QixJQUFsQixDQUF3QnU2QixVQUF4QixDQUFvQzc0QyxJQUFwQyxDQUEwQyxDQUN4QztBQUNBLEdBQUcsQ0FBQ0EsSUFBSixDQUFVLENBQ1JBLElBQUksQ0FBR1EsS0FBSyxDQUFDcWQsRUFBTixDQUFTbVMsSUFBVCxDQUFjLzBCLE1BQWQsRUFBUCxDQUNELENBQ0QsR0FBSXVSLEVBQUMsQ0FBRyxFQUFSLENBQ0EsR0FBSS9DLE1BQUssQ0FBR25LLElBQUksQ0FBQzhMLElBQUwsQ0FBVXl0QyxVQUFVLENBQUc3NEMsSUFBSSxDQUFDa3dCLFlBQTVCLENBQVosQ0FDQSxJQUFJLEdBQUl0dEIsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHNkcsS0FBbkIsQ0FBMEIsRUFBRTdHLENBQTVCLENBQStCLENBQzdCLEdBQUlJLEVBQUMsQ0FBR3FFLE1BQU0sQ0FBQ0MsWUFBUCxDQUNMMUUsQ0FBQyxFQUFJLEVBQU4sQ0FBWSxJQUROLENBQ2FBLENBQUMsRUFBSSxFQUFOLENBQVksSUFEeEIsQ0FDK0JBLENBQUMsRUFBSSxDQUFOLENBQVcsSUFEekMsQ0FDK0NBLENBQUMsQ0FBRyxJQURuRCxDQUFSLENBRUE1QyxJQUFJLENBQUN1TyxLQUFMLEdBQ0F2TyxJQUFJLENBQUN3VSxNQUFMLENBQVk4SixJQUFJLENBQUd0YixDQUFuQixFQUNBd0osQ0FBQyxFQUFJeE0sSUFBSSxDQUFDeWdCLE1BQUwsR0FBYzdYLFFBQWQsRUFBTCxDQUNELENBQ0QsTUFBTzRELEVBQUMsQ0FBQ2lDLFNBQUYsQ0FBWSxDQUFaLENBQWVvcUMsVUFBZixDQUFQLENBQ0QsQ0FHRCxLQUFPLENBdmpqQkcsQ0F3ampCVixRQXhqakJVLENBeWpqQlYsS0FBTyxTQUFTeDJDLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7OztHQU9BLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBRUEsQ0FBQyxVQUFXLENBRVo7QUFDQSxHQUFHbEMsS0FBSyxDQUFDd25CLEtBQVQsQ0FBZ0IsQ0FDZDNsQixNQUFNLENBQUNELE9BQVAsQ0FBaUI1QixLQUFLLENBQUN3bkIsS0FBdkIsQ0FDQSxPQUNELENBRUQsZUFDQSxHQUFJQSxNQUFLLENBQUczbEIsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDd25CLEtBQU4sQ0FBY3huQixLQUFLLENBQUN3bkIsS0FBTixFQUFlLEVBQTFELENBRUEsR0FBSW5JLFdBQVUsQ0FBR3JmLEtBQUssQ0FBQ3NmLElBQU4sQ0FBV0QsVUFBNUIsQ0FFQTtBQUNBLEdBQUlFLGFBQVksQ0FBRyxDQUFDLENBQUQsQ0FBSSxDQUFKLENBQU8sQ0FBUCxDQUFVLENBQVYsQ0FBYSxDQUFiLENBQWdCLENBQWhCLENBQW1CLENBQW5CLENBQXNCLENBQXRCLENBQW5CLENBQ0EsR0FBSW1ELE9BQU0sQ0FBRyxHQUFJckQsV0FBSixDQUFlLElBQWYsQ0FBYixDQUNBcUQsTUFBTSxDQUFDRixPQUFQLENBQWUsRUFBZixFQUNBLEdBQUlJLE1BQUssQ0FBRyxRQUFSQSxNQUFRLENBQVM3YyxDQUFULENBQVlxYixDQUFaLENBQWUsQ0FBQyxNQUFPcmIsRUFBQyxDQUFDcWIsQ0FBVCxDQUFZLENBQXhDLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2QkFvRyxLQUFLLENBQUNDLHFCQUFOLENBQThCLFNBQVN6RixJQUFULENBQWV6cUIsT0FBZixDQUF3QjRNLFFBQXhCLENBQWtDLENBQzlELEdBQUcsTUFBTzVNLFFBQVAsR0FBbUIsVUFBdEIsQ0FBa0MsQ0FDaEM0TSxRQUFRLENBQUc1TSxPQUFYLENBQ0FBLE9BQU8sQ0FBRyxFQUFWLENBQ0QsQ0FDREEsT0FBTyxDQUFHQSxPQUFPLEVBQUksRUFBckIsQ0FFQTtBQUNBLEdBQUlzb0IsVUFBUyxDQUFHdG9CLE9BQU8sQ0FBQ3NvQixTQUFSLEVBQXFCLFVBQXJDLENBQ0EsR0FBRyxNQUFPQSxVQUFQLEdBQXFCLFFBQXhCLENBQWtDLENBQ2hDQSxTQUFTLENBQUcsQ0FBQ2poQixJQUFJLENBQUVpaEIsU0FBUCxDQUFaLENBQ0QsQ0FDREEsU0FBUyxDQUFDdG9CLE9BQVYsQ0FBb0Jzb0IsU0FBUyxDQUFDdG9CLE9BQVYsRUFBcUIsRUFBekMsQ0FFQTtBQUNBLEdBQUk4bUIsS0FBSSxDQUFHOW1CLE9BQU8sQ0FBQzhtQixJQUFSLEVBQWdCcmUsS0FBSyxDQUFDakIsTUFBakMsQ0FDQSxHQUFJa2pCLElBQUcsQ0FBRyxDQUNSO0FBQ0FDLFNBQVMsQ0FBRSxtQkFBU25jLENBQVQsQ0FBWSxDQUNyQixHQUFJUyxFQUFDLENBQUc2WCxJQUFJLENBQUNDLFlBQUwsQ0FBa0J2WSxDQUFDLENBQUM3TixNQUFwQixDQUFSLENBQ0EsSUFBSSxHQUFJa0ssRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHMkQsQ0FBQyxDQUFDN04sTUFBckIsQ0FBNkIsRUFBRWtLLENBQS9CLENBQWtDLENBQ2hDMkQsQ0FBQyxDQUFDM0QsQ0FBRCxDQUFELENBQU9vRSxDQUFDLENBQUM4QixVQUFGLENBQWFsRyxDQUFiLENBQVAsQ0FDRCxDQUNGLENBUE8sQ0FBVixDQVVBLEdBQUd5ZCxTQUFTLENBQUNqaEIsSUFBVixHQUFtQixVQUF0QixDQUFrQyxDQUNoQyxNQUFPMDVDLGtCQUFpQixDQUFDdDJCLElBQUQsQ0FBT0MsR0FBUCxDQUFZcEMsU0FBUyxDQUFDdG9CLE9BQXRCLENBQStCNE0sUUFBL0IsQ0FBeEIsQ0FDRCxDQUVELEtBQU0sSUFBSW5NLE1BQUosQ0FBVSx1Q0FBeUM2bkIsU0FBUyxDQUFDamhCLElBQTdELENBQU4sQ0FDRCxDQS9CRCxDQWlDQSxRQUFTMDVDLGtCQUFULENBQTJCdDJCLElBQTNCLENBQWlDQyxHQUFqQyxDQUFzQzFxQixPQUF0QyxDQUErQzRNLFFBQS9DLENBQXlELENBQ3ZELEdBQUcsV0FBYTVNLFFBQWhCLENBQXlCLENBQ3ZCLE1BQU9naEQsNkJBQTRCLENBQUN2MkIsSUFBRCxDQUFPQyxHQUFQLENBQVkxcUIsT0FBWixDQUFxQjRNLFFBQXJCLENBQW5DLENBQ0QsQ0FDRCxNQUFPcTBDLGdDQUErQixDQUFDeDJCLElBQUQsQ0FBT0MsR0FBUCxDQUFZMXFCLE9BQVosQ0FBcUI0TSxRQUFyQixDQUF0QyxDQUNELENBRUQsUUFBU3EwQyxnQ0FBVCxDQUF5Q3gyQixJQUF6QyxDQUErQ0MsR0FBL0MsQ0FBb0QxcUIsT0FBcEQsQ0FBNkQ0TSxRQUE3RCxDQUF1RSxDQUNyRTtBQUNBLEdBQUlnUCxJQUFHLENBQUdzbEMsY0FBYyxDQUFDejJCLElBQUQsQ0FBT0MsR0FBUCxDQUF4QixDQUVBOzs7NkJBSUEsR0FBSVUsU0FBUSxDQUFHLENBQWYsQ0FFQTtBQUNBLEdBQUkrMUIsUUFBTyxDQUFHQyxtQkFBbUIsQ0FBQ3hsQyxHQUFHLENBQUMwTixTQUFKLEVBQUQsQ0FBakMsQ0FDQSxHQUFHLG9CQUFzQnRwQixRQUF6QixDQUFrQyxDQUNoQ21oRCxPQUFPLENBQUduaEQsT0FBTyxDQUFDcWhELGdCQUFsQixDQUNELENBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFJQyxhQUFZLENBQUcsRUFBbkIsQ0FDQSxHQUFHLGdCQUFrQnRoRCxRQUFyQixDQUE4QixDQUM1QnNoRCxZQUFZLENBQUd0aEQsT0FBTyxDQUFDc2hELFlBQXZCLENBQ0QsQ0FFREMsU0FBUyxDQUFDM2xDLEdBQUQsQ0FBTTZPLElBQU4sQ0FBWUMsR0FBWixDQUFpQlUsUUFBakIsQ0FBMkIrMUIsT0FBM0IsQ0FBb0NHLFlBQXBDLENBQWtEMTBDLFFBQWxELENBQVQsQ0FDRCxDQUVELFFBQVMyMEMsVUFBVCxDQUFtQjNsQyxHQUFuQixDQUF3QjZPLElBQXhCLENBQThCQyxHQUE5QixDQUFtQ1UsUUFBbkMsQ0FBNkMrMUIsT0FBN0MsQ0FBc0RHLFlBQXRELENBQW9FMTBDLFFBQXBFLENBQThFLENBQzVFLEdBQUk0SixNQUFLLENBQUcsQ0FBQyxHQUFJN0ksS0FBSixFQUFiLENBQ0EsRUFBRyxDQUNEO0FBQ0EsR0FBR2lPLEdBQUcsQ0FBQzBOLFNBQUosR0FBa0JtQixJQUFyQixDQUEyQixDQUN6QjdPLEdBQUcsQ0FBR3NsQyxjQUFjLENBQUN6MkIsSUFBRCxDQUFPQyxHQUFQLENBQXBCLENBQ0QsQ0FDRDtBQUNBLEdBQUc5TyxHQUFHLENBQUNtUSxlQUFKLENBQW9CbzFCLE9BQXBCLENBQUgsQ0FBaUMsQ0FDL0IsTUFBT3YwQyxTQUFRLENBQUMsSUFBRCxDQUFPZ1AsR0FBUCxDQUFmLENBQ0QsQ0FDRDtBQUNBQSxHQUFHLENBQUNpUSxVQUFKLENBQWU3RCxZQUFZLENBQUNvRCxRQUFRLEdBQUssQ0FBZCxDQUEzQixDQUE2QyxDQUE3QyxFQUNELENBWEQsTUFXUWsyQixZQUFZLENBQUcsQ0FBZixFQUFxQixDQUFDLEdBQUkzekMsS0FBSixFQUFELENBQWM2SSxLQUFkLENBQXNCOHFDLFlBWG5ELEVBYUE7QUFDQTc0QyxLQUFLLENBQUMyRCxJQUFOLENBQVdJLFlBQVgsQ0FBd0IsVUFBVyxDQUNqQyswQyxTQUFTLENBQUMzbEMsR0FBRCxDQUFNNk8sSUFBTixDQUFZQyxHQUFaLENBQWlCVSxRQUFqQixDQUEyQisxQixPQUEzQixDQUFvQ0csWUFBcEMsQ0FBa0QxMEMsUUFBbEQsQ0FBVCxDQUNELENBRkQsRUFHRCxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBU28wQyw2QkFBVCxDQUFzQ3YyQixJQUF0QyxDQUE0Q0MsR0FBNUMsQ0FBaUQxcUIsT0FBakQsQ0FBMEQ0TSxRQUExRCxDQUFvRSxDQUNsRTtBQUNBLEdBQUcsTUFBT2lRLE9BQVAsR0FBa0IsV0FBckIsQ0FBa0MsQ0FDaEMsTUFBT29rQyxnQ0FBK0IsQ0FBQ3gyQixJQUFELENBQU9DLEdBQVAsQ0FBWTFxQixPQUFaLENBQXFCNE0sUUFBckIsQ0FBdEMsQ0FDRCxDQUVEO0FBQ0EsR0FBSWdQLElBQUcsQ0FBR3NsQyxjQUFjLENBQUN6MkIsSUFBRCxDQUFPQyxHQUFQLENBQXhCLENBRUE7QUFDQSxHQUFJcE4sV0FBVSxDQUFHdGQsT0FBTyxDQUFDNGQsT0FBekIsQ0FDQSxHQUFJa1MsU0FBUSxDQUFHOXZCLE9BQU8sQ0FBQzh2QixRQUFSLEVBQW9CLEdBQW5DLENBQ0EsR0FBSTB4QixNQUFLLENBQUcxeEIsUUFBUSxDQUFHLEVBQVgsQ0FBZ0IsQ0FBNUIsQ0FDQSxHQUFJL21CLGFBQVksQ0FBRy9JLE9BQU8sQ0FBQytJLFlBQVIsRUFBd0IsdUJBQTNDLENBQ0EsR0FBR3VVLFVBQVUsR0FBSyxDQUFDLENBQW5CLENBQXNCLENBQ3BCLE1BQU83VSxNQUFLLENBQUMyRCxJQUFOLENBQVdvUSxhQUFYLENBQXlCLFNBQVNrQixHQUFULENBQWNoQixLQUFkLENBQXFCLENBQ25ELEdBQUdnQixHQUFILENBQVEsQ0FDTjtBQUNBaEIsS0FBSyxDQUFHLENBQVIsQ0FDRCxDQUNEWSxVQUFVLENBQUdaLEtBQUssQ0FBRyxDQUFyQixDQUNBL1QsUUFBUSxHQUNULENBUE0sQ0FBUCxDQVFELENBQ0RBLFFBQVEsR0FFUixRQUFTQSxTQUFULEVBQW9CLENBQ2xCO0FBQ0EyVSxVQUFVLENBQUcvVixJQUFJLENBQUNrSyxHQUFMLENBQVMsQ0FBVCxDQUFZNkwsVUFBWixDQUFiLENBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQSxHQUFJTSxRQUFPLENBQUcsRUFBZCxDQUNBLElBQUksR0FBSS9TLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3lTLFVBQW5CLENBQStCLEVBQUV6UyxDQUFqQyxDQUFvQyxDQUNsQztBQUNBK1MsT0FBTyxDQUFDL1MsQ0FBRCxDQUFQLENBQWEsR0FBSWdTLE9BQUosQ0FBVzlULFlBQVgsQ0FBYixDQUNELENBQ0QsR0FBSTA0QyxRQUFPLENBQUdua0MsVUFBZCxDQUVBO0FBQ0EsSUFBSSxHQUFJelMsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHeVMsVUFBbkIsQ0FBK0IsRUFBRXpTLENBQWpDLENBQW9DLENBQ2xDK1MsT0FBTyxDQUFDL1MsQ0FBRCxDQUFQLENBQVcyQyxnQkFBWCxDQUE0QixTQUE1QixDQUF1Q2swQyxhQUF2QyxFQUNELENBRUQ7Ozs7Ozs7Ozs7Ozt5REFjQSxHQUFJQyxNQUFLLENBQUcsS0FBWixDQUNBLFFBQVNELGNBQVQsQ0FBdUJseUMsQ0FBdkIsQ0FBMEIsQ0FDeEI7QUFDQSxHQUFHbXlDLEtBQUgsQ0FBVSxDQUNSLE9BQ0QsQ0FFRCxFQUFFRixPQUFGLENBQ0EsR0FBSWwvQyxLQUFJLENBQUdpTixDQUFDLENBQUNqTixJQUFiLENBQ0EsR0FBR0EsSUFBSSxDQUFDby9DLEtBQVIsQ0FBZSxDQUNiO0FBQ0EsSUFBSSxHQUFJOTJDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBRytTLE9BQU8sQ0FBQ2pkLE1BQTNCLENBQW1DLEVBQUVrSyxDQUFyQyxDQUF3QyxDQUN0QytTLE9BQU8sQ0FBQy9TLENBQUQsQ0FBUCxDQUFXaVQsU0FBWCxHQUNELENBQ0Q2akMsS0FBSyxDQUFHLElBQVIsQ0FDQSxNQUFPLzBDLFNBQVEsQ0FBQyxJQUFELENBQU8sR0FBSWtiLFdBQUosQ0FBZXZsQixJQUFJLENBQUMwdEIsS0FBcEIsQ0FBMkIsRUFBM0IsQ0FBUCxDQUFmLENBQ0QsQ0FFRDtBQUNBLEdBQUdyVSxHQUFHLENBQUMwTixTQUFKLEdBQWtCbUIsSUFBckIsQ0FBMkIsQ0FDekI3TyxHQUFHLENBQUdzbEMsY0FBYyxDQUFDejJCLElBQUQsQ0FBT0MsR0FBUCxDQUFwQixDQUNELENBRUQ7QUFDQSxHQUFJblgsSUFBRyxDQUFHcUksR0FBRyxDQUFDblUsUUFBSixDQUFhLEVBQWIsQ0FBVixDQUVBO0FBQ0ErSCxDQUFDLENBQUMyZCxNQUFGLENBQVM3a0IsV0FBVCxDQUFxQixDQUNuQmlMLEdBQUcsQ0FBRUEsR0FEYyxDQUVuQnVjLFFBQVEsQ0FBRUEsUUFGUyxDQUFyQixFQUtBbFUsR0FBRyxDQUFDaVEsVUFBSixDQUFlMjFCLEtBQWYsQ0FBc0IsQ0FBdEIsRUFDRCxDQUNGLENBQ0YsQ0FFRDs7Ozs7OztHQVFBLFFBQVNOLGVBQVQsQ0FBd0J6MkIsSUFBeEIsQ0FBOEJDLEdBQTlCLENBQW1DLENBQ2pDLEdBQUk5TyxJQUFHLENBQUcsR0FBSWtNLFdBQUosQ0FBZTJDLElBQWYsQ0FBcUJDLEdBQXJCLENBQVYsQ0FDQTtBQUNBLEdBQUllLE1BQUssQ0FBR2hCLElBQUksQ0FBRyxDQUFuQixDQUNBLEdBQUcsQ0FBQzdPLEdBQUcsQ0FBQzhQLE9BQUosQ0FBWUQsS0FBWixDQUFKLENBQXdCLENBQ3RCN1AsR0FBRyxDQUFDK1AsU0FBSixDQUFjN0QsVUFBVSxDQUFDbUIsR0FBWCxDQUFlMkMsU0FBZixDQUF5QkgsS0FBekIsQ0FBZCxDQUErQ0osS0FBL0MsQ0FBc0R6UCxHQUF0RCxFQUNELENBQ0Q7QUFDQUEsR0FBRyxDQUFDaVEsVUFBSixDQUFlLEdBQUtqUSxHQUFHLENBQUNtTixHQUFKLENBQVFvQyxNQUFSLEVBQWdCVyxTQUFoQixFQUFwQixDQUFpRCxDQUFqRCxFQUNBLE1BQU9sUSxJQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7O0dBVUEsUUFBU3dsQyxvQkFBVCxDQUE2QjMyQixJQUE3QixDQUFtQyxDQUNqQyxHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEdBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxHQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxHQUFYLENBQWdCLE1BQU8sR0FBUCxDQUNoQixHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEdBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxFQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxHQUFYLENBQWdCLE1BQU8sRUFBUCxDQUNoQixHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEVBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLEdBQVgsQ0FBZ0IsTUFBTyxFQUFQLENBQ2hCLEdBQUdBLElBQUksRUFBSSxHQUFYLENBQWdCLE1BQU8sRUFBUCxDQUNoQixHQUFHQSxJQUFJLEVBQUksR0FBWCxDQUFnQixNQUFPLEVBQVAsQ0FDaEIsR0FBR0EsSUFBSSxFQUFJLElBQVgsQ0FBaUIsTUFBTyxFQUFQLENBQ2pCLE1BQU8sRUFBUCxDQUNELENBRUEsQ0E1UkQsSUErUkEsS0FBTyxDQXQyakJHLENBdTJqQlYsUUF2MmpCVSxDQXcyakJWLEtBQU8sU0FBU25nQixNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBK0ZBLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsQ0FBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FDQUEsbUJBQW1CLENBQUMsRUFBRCxDQUFuQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FFQTtBQUNBLEdBQUl3VCxLQUFJLENBQUcxVixLQUFLLENBQUMwVixJQUFqQixDQUNBLEdBQUloVixJQUFHLENBQUdWLEtBQUssQ0FBQ1UsR0FBaEIsQ0FFQTtBQUNBLEdBQUl5NEMsSUFBRyxDQUFHdDNDLE1BQU0sQ0FBQ0QsT0FBUCxDQUFpQjVCLEtBQUssQ0FBQ281QyxNQUFOLENBQWVwNUMsS0FBSyxDQUFDbzVDLE1BQU4sRUFBZ0IsRUFBMUQsQ0FFQSxHQUFJQyxxQkFBb0IsQ0FBRyxDQUN6Qno2QyxJQUFJLENBQUUsYUFEbUIsQ0FFekIwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGSSxDQUd6QjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhTLENBR0U7QUFDM0JRLFdBQVcsQ0FBRSxJQUpZLENBS3pCM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSx5QkFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGFBTEgsQ0FBRCxDQU1KLENBQ0R4ZCxJQUFJLENBQUUscUJBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRHlCLFdBQVcsQ0FBRSxJQUhaLENBSUQrRSxXQUFXLENBQUUsU0FKWixDQU5JLENBTGtCLENBQTNCLENBbUJBLEdBQUlnOUIsYUFBWSxDQUFHLENBQ2pCMTZDLElBQUksQ0FBRSxLQURXLENBRWpCMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRkosQ0FHakI3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIQyxDQUlqQlEsV0FBVyxDQUFFLElBSkksQ0FLakIzRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLGFBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIVixDQUlOb0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxTQUxILENBQUQsQ0FPUGk5QixvQkFQTyxDQU9lLENBQ3BCejZDLElBQUksQ0FBRSxhQURjLENBRXBCMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRkQsQ0FHcEI3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFISSxDQUlwQlEsV0FBVyxDQUFFLElBSk8sQ0FLcEI4RSxRQUFRLENBQUUsSUFMVSxDQU1wQkMsV0FBVyxDQUFFLEtBTk8sQ0FPcEIxSyxLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLGlCQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSFYsQ0FHcUI7QUFDM0JRLFdBQVcsQ0FBRSxJQUpQLENBS04zRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLGlDQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSFYsQ0FHcUI7QUFDM0JRLFdBQVcsQ0FBRSxJQUpQLENBS04zRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLDJDQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsY0FMSCxDQUFELENBTUosQ0FDRHhkLElBQUksQ0FBRSw0Q0FETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0QwRyxXQUFXLENBQUUsd0JBSFosQ0FOSSxDQUxELENBQUQsQ0FnQkosQ0FDRDFkLElBQUksQ0FBRSx3QkFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FIZixDQUlEa0IsV0FBVyxDQUFFLEtBSlosQ0FLRDZFLE9BQU8sQ0FBRSxXQUxSLENBaEJJLENBTEQsQ0FBRCxDQTRCSixDQUNEeGQsSUFBSSxDQUFFLHFCQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUhmLENBSURrQixXQUFXLENBQUUsS0FKWixDQUtENkUsT0FBTyxDQUFFLFNBTFIsQ0E1QkksQ0FrQ0osQ0FDRHhkLElBQUksQ0FBRSx3QkFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIZixDQUlEb0IsV0FBVyxDQUFFLEtBSlosQ0FLRDhFLFFBQVEsQ0FBRSxJQUxULENBTURELE9BQU8sQ0FBRSxlQU5SLENBbENJLENBUGEsQ0FQZixDQUxVLENBQW5CLENBZ0VBLEdBQUltOUIsaUJBQWdCLENBQUcsQ0FDckIzNkMsSUFBSSxDQUFFLFNBRGUsQ0FFckIwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGQSxDQUdyQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhLLENBSXJCUSxXQUFXLENBQUUsSUFKUSxDQUtyQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsZUFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLE9BTEgsQ0FBRCxDQU1KLENBQ0R4ZCxJQUFJLENBQUUsa0JBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRHlCLFdBQVcsQ0FBRSxJQUhaLENBSUQrRSxXQUFXLENBQUUsVUFKWixDQU5JLENBV0osQ0FDRDFkLElBQUksQ0FBRSx1QkFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWdCLEdBSGYsQ0FJRE8sV0FBVyxDQUFFLElBSlosQ0FLRDhFLFFBQVEsQ0FBRSxJQUxULENBTURELE9BQU8sQ0FBRSxlQU5SLENBWEksQ0FMYyxDQUF2QixDQTBCQSxHQUFJbzlCLG1CQUFrQixDQUFHLENBQ3ZCNTZDLElBQUksQ0FBRSxXQURpQixDQUV2QjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZFLENBR3ZCN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSE8sQ0FJdkJRLFdBQVcsQ0FBRSxJQUpVLENBS3ZCM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSxrQkFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLEtBTEgsQ0FBRCxDQU1KLENBQ0R4ZCxJQUFJLENBQUUsc0JBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVnQixHQUhmLENBSURPLFdBQVcsQ0FBRSxJQUpaLENBS0Q2RSxPQUFPLENBQUUsUUFMUixDQU5JLENBTGdCLENBQXpCLENBb0JBLEdBQUlxOUIsaUJBQWdCLENBQUcsQ0FDckI3NkMsSUFBSSxDQUFFLFNBRGUsQ0FFckIwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGQSxDQUdyQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhLLENBSXJCUSxXQUFXLENBQUUsSUFKUSxDQUtyQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsZ0JBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FIVixDQUlOZ0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxRQUxILENBQUQsQ0FNSixDQUNEeGQsSUFBSSxDQUFFLG1CQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBRnBCLENBR0R5QixXQUFXLENBQUUsSUFIWixDQUlEO3NEQUVBM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSxzQkFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ0MsS0FBTCxDQUFXVSxXQUhYLENBSU5rQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLE1BTEgsQ0FBRCxDQU5OLENBTkksQ0FMYyxDQUF2QixDQTJCQTs7Ozs7Ozs7Ozs7R0FZQSxRQUFTczlCLG9CQUFULENBQTZCQyxZQUE3QixDQUEyQ0MsUUFBM0MsQ0FBcURDLFNBQXJELENBQWdFQyxPQUFoRSxDQUF5RSxDQUN2RSxHQUFJOS9DLE9BQU0sQ0FBRyxFQUFiLENBRUEsSUFBSSxHQUFJb0ksRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHdTNDLFlBQVksQ0FBQ3poRCxNQUFoQyxDQUF3Q2tLLENBQUMsRUFBekMsQ0FBNkMsQ0FDM0MsSUFBSSxHQUFJd0wsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHK3JDLFlBQVksQ0FBQ3YzQyxDQUFELENBQVosQ0FBZ0IyM0MsUUFBaEIsQ0FBeUI3aEQsTUFBNUMsQ0FBb0QwVixDQUFDLEVBQXJELENBQXlELENBQ3ZELEdBQUlvc0MsSUFBRyxDQUFHTCxZQUFZLENBQUN2M0MsQ0FBRCxDQUFaLENBQWdCMjNDLFFBQWhCLENBQXlCbnNDLENBQXpCLENBQVYsQ0FDQSxHQUFHa3NDLE9BQU8sR0FBSzcxQyxTQUFaLEVBQXlCKzFDLEdBQUcsQ0FBQ2pyQyxJQUFKLEdBQWErcUMsT0FBekMsQ0FBa0QsQ0FDaEQsU0FDRCxDQUNEO0FBQ0EsR0FBR0YsUUFBUSxHQUFLLElBQWhCLENBQXNCLENBQ3BCNS9DLE1BQU0sQ0FBQzhLLElBQVAsQ0FBWWsxQyxHQUFaLEVBQ0EsU0FDRCxDQUNELEdBQUdBLEdBQUcsQ0FBQ3gwQyxVQUFKLENBQWVvMEMsUUFBZixJQUE2QjMxQyxTQUE3QixFQUNEKzFDLEdBQUcsQ0FBQ3gwQyxVQUFKLENBQWVvMEMsUUFBZixFQUF5QnZwQyxPQUF6QixDQUFpQ3dwQyxTQUFqQyxHQUErQyxDQURqRCxDQUNvRCxDQUNsRDcvQyxNQUFNLENBQUM4SyxJQUFQLENBQVlrMUMsR0FBWixFQUNELENBQ0YsQ0FDRixDQUVELE1BQU9oZ0QsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7O0dBU0FtL0MsR0FBRyxDQUFDYyxjQUFKLENBQXFCLFNBQVM1ckMsR0FBVCxDQUFjdUssTUFBZCxDQUFzQjBVLFFBQXRCLENBQWdDLENBQ25EO0FBQ0EsR0FBRyxNQUFPMVUsT0FBUCxHQUFrQixRQUFyQixDQUErQixDQUM3QjBVLFFBQVEsQ0FBRzFVLE1BQVgsQ0FDQUEsTUFBTSxDQUFHLElBQVQsQ0FDRCxDQUhELElBR08sSUFBR0EsTUFBTSxHQUFLM1UsU0FBZCxDQUF5QixDQUM5QjJVLE1BQU0sQ0FBRyxJQUFULENBQ0QsQ0FFRDtBQUNBLEdBQUl3RCxRQUFPLENBQUcsRUFBZCxDQUNBLEdBQUkvZSxPQUFNLENBQUcsRUFBYixDQUNBLEdBQUcsQ0FBQ3FZLElBQUksQ0FBQ3dHLFFBQUwsQ0FBYzdOLEdBQWQsQ0FBbUJpckMsWUFBbkIsQ0FBaUNsOUIsT0FBakMsQ0FBMEMvZSxNQUExQyxDQUFKLENBQXVELENBQ3JELEdBQUluRCxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSw0QkFDcEIscUNBRFUsQ0FBWixDQUVBa0MsS0FBSyxDQUFDbUQsTUFBTixDQUFlbkQsS0FBZixDQUNBLEtBQU1BLE1BQU4sQ0FDRCxDQUVELEdBQUlnZ0QsSUFBRyxDQUFHLENBQ1JudUIsT0FBTyxDQUFFM1AsT0FBTyxDQUFDMlAsT0FBUixDQUFnQnpqQixVQUFoQixDQUEyQixDQUEzQixDQURELENBRVJxeEMsWUFBWSxDQUFFLEVBRk4sQ0FJUjs7Ozs7Ozs7Ozs7O09BYUFRLE9BQU8sQ0FBRSxpQkFBU2orQyxNQUFULENBQWlCLENBQ3hCLEdBQUlzTSxLQUFJLENBQUcsRUFBWCxDQUVBLEdBQUk0eEMsV0FBSixDQUNBLEdBQUcsY0FBZ0JsK0MsT0FBbkIsQ0FBMkIsQ0FDekJrK0MsVUFBVSxDQUFHbCtDLE1BQU0sQ0FBQ2srQyxVQUFwQixDQUNELENBRkQsSUFFTyxJQUFHLGlCQUFtQmwrQyxPQUF0QixDQUE4QixDQUNuQ2srQyxVQUFVLENBQUdwNkMsS0FBSyxDQUFDMkQsSUFBTixDQUFXc0ksVUFBWCxDQUFzQi9QLE1BQU0sQ0FBQ20rQyxhQUE3QixDQUFiLENBQ0QsQ0FFRDtBQUNBLEdBQUdELFVBQVUsR0FBS24yQyxTQUFmLEVBQTRCLEVBQUUsZ0JBQWtCL0gsT0FBcEIsQ0FBNUIsRUFDRCxXQUFhQSxPQURmLENBQ3VCLENBQ3JCc00sSUFBSSxDQUFDdE0sTUFBTSxDQUFDNDlDLE9BQVIsQ0FBSixDQUF1QkosbUJBQW1CLENBQ3hDUSxHQUFHLENBQUNQLFlBRG9DLENBQ3RCLElBRHNCLENBQ2hCLElBRGdCLENBQ1Z6OUMsTUFBTSxDQUFDNDlDLE9BREcsQ0FBMUMsQ0FFRCxDQUVELEdBQUdNLFVBQVUsR0FBS24yQyxTQUFsQixDQUE2QixDQUMzQnVFLElBQUksQ0FBQzR4QyxVQUFMLENBQWtCVixtQkFBbUIsQ0FDbkNRLEdBQUcsQ0FBQ1AsWUFEK0IsQ0FDakIsWUFEaUIsQ0FFbkNTLFVBRm1DLENBRXZCbCtDLE1BQU0sQ0FBQzQ5QyxPQUZnQixDQUFyQyxDQUdELENBQ0QsR0FBRyxnQkFBa0I1OUMsT0FBckIsQ0FBNkIsQ0FDM0JzTSxJQUFJLENBQUM4eEMsWUFBTCxDQUFvQlosbUJBQW1CLENBQ3JDUSxHQUFHLENBQUNQLFlBRGlDLENBQ25CLGNBRG1CLENBRXJDejlDLE1BQU0sQ0FBQ28rQyxZQUY4QixDQUVoQnArQyxNQUFNLENBQUM0OUMsT0FGUyxDQUF2QyxDQUdELENBRUQsTUFBT3R4QyxLQUFQLENBQ0QsQ0E5Q08sQ0FnRFI7Ozs7Ozs7OztPQVVBK3hDLHFCQUFxQixDQUFFLCtCQUFTRCxZQUFULENBQXVCUixPQUF2QixDQUFnQyxDQUNyRCxNQUFPSixvQkFBbUIsQ0FDeEJRLEdBQUcsQ0FBQ1AsWUFEb0IsQ0FDTixjQURNLENBQ1VXLFlBRFYsQ0FDd0JSLE9BRHhCLENBQTFCLENBRUQsQ0E3RE8sQ0ErRFI7Ozs7Ozs7OztPQVVBVSxtQkFBbUIsQ0FBRSw2QkFBU0osVUFBVCxDQUFxQk4sT0FBckIsQ0FBOEIsQ0FDakQsTUFBT0osb0JBQW1CLENBQ3hCUSxHQUFHLENBQUNQLFlBRG9CLENBQ04sWUFETSxDQUNRUyxVQURSLENBQ29CTixPQURwQixDQUExQixDQUVELENBNUVPLENBQVYsQ0ErRUEsR0FBRzE5QixPQUFPLENBQUMyUCxPQUFSLENBQWdCempCLFVBQWhCLENBQTJCLENBQTNCLElBQWtDLENBQXJDLENBQXdDLENBQ3RDLEdBQUlwTyxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSxvREFBVixDQUFaLENBQ0FrQyxLQUFLLENBQUM2eEIsT0FBTixDQUFnQjNQLE9BQU8sQ0FBQzJQLE9BQVIsQ0FBZ0J6akIsVUFBaEIsQ0FBMkIsQ0FBM0IsQ0FBaEIsQ0FDQSxLQUFNcE8sTUFBTixDQUNELENBRUQsR0FBR3diLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ3ErQixXQUF0QixJQUF1Qy81QyxHQUFHLENBQUN1YyxJQUFKLENBQVNuakIsSUFBbkQsQ0FBeUQsQ0FDdkQsR0FBSUksTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsd0RBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDMmYsR0FBTixDQUFZbkUsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDcStCLFdBQXRCLENBQVosQ0FDQSxLQUFNdmdELE1BQU4sQ0FDRCxDQUVELEdBQUlKLEtBQUksQ0FBR3NpQixPQUFPLENBQUNzK0IsT0FBUixDQUFnQjlvQyxLQUFoQixDQUFzQixDQUF0QixDQUFYLENBQ0EsR0FBRzlYLElBQUksQ0FBQ3dkLFFBQUwsR0FBa0I1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBN0IsRUFDQTliLElBQUksQ0FBQ2lWLElBQUwsR0FBYzJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUQzQixDQUN3QyxDQUN0QyxLQUFNLElBQUlyZSxNQUFKLENBQVUsdURBQVYsQ0FBTixDQUNELENBQ0Q4QixJQUFJLENBQUc2Z0QsZ0JBQWdCLENBQUM3Z0QsSUFBRCxDQUF2QixDQUVBO0FBQ0EsR0FBR3NpQixPQUFPLENBQUN3K0IsR0FBWCxDQUFnQixDQUNkLEdBQUl2OUIsR0FBRSxDQUFHLElBQVQsQ0FDQSxHQUFJdzlCLFlBQVcsQ0FBRyxDQUFsQixDQUNBLEdBQUlDLGFBQVksQ0FBR3BsQyxJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUMwK0IsWUFBdEIsQ0FBbkIsQ0FDQSxPQUFPQSxZQUFQLEVBQ0EsSUFBS3A2QyxJQUFHLENBQUN1YyxJQUFKLENBQVN1UyxJQUFkLENBQ0VuUyxFQUFFLENBQUdyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNtUyxJQUFULENBQWMvMEIsTUFBZCxFQUFMLENBQ0FvZ0QsV0FBVyxDQUFHLEVBQWQsQ0FDQSxNQUNGLElBQUtuNkMsSUFBRyxDQUFDdWMsSUFBSixDQUFTaUIsTUFBZCxDQUNFYixFQUFFLENBQUdyZCxLQUFLLENBQUNxZCxFQUFOLENBQVNhLE1BQVQsQ0FBZ0J6akIsTUFBaEIsRUFBTCxDQUNBb2dELFdBQVcsQ0FBRyxFQUFkLENBQ0EsTUFDRixJQUFLbjZDLElBQUcsQ0FBQ3VjLElBQUosQ0FBU3V0QixNQUFkLENBQ0VudEIsRUFBRSxDQUFHcmQsS0FBSyxDQUFDcWQsRUFBTixDQUFTbXRCLE1BQVQsQ0FBZ0IvdkMsTUFBaEIsRUFBTCxDQUNBb2dELFdBQVcsQ0FBRyxFQUFkLENBQ0EsTUFDRixJQUFLbjZDLElBQUcsQ0FBQ3VjLElBQUosQ0FBU29VLE1BQWQsQ0FDRWhVLEVBQUUsQ0FBR3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU2dVLE1BQVQsQ0FBZ0I1MkIsTUFBaEIsRUFBTCxDQUNBb2dELFdBQVcsQ0FBRyxFQUFkLENBQ0EsTUFDRixJQUFLbjZDLElBQUcsQ0FBQ3VjLElBQUosQ0FBU2lVLEdBQWQsQ0FDRTdULEVBQUUsQ0FBR3JkLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBUzZULEdBQVQsQ0FBYXoyQixNQUFiLEVBQUwsQ0FDQW9nRCxXQUFXLENBQUcsRUFBZCxDQUNBLE1BcEJGLENBc0JBLEdBQUd4OUIsRUFBRSxHQUFLLElBQVYsQ0FBZ0IsQ0FDZCxLQUFNLElBQUlybEIsTUFBSixDQUFVLDJDQUE2QzhpRCxZQUF2RCxDQUFOLENBQ0QsQ0FFRDtBQUNBLEdBQUlDLFFBQU8sQ0FBRyxHQUFJLzZDLE1BQUssQ0FBQzJELElBQU4sQ0FBVzJDLFVBQWYsQ0FBMEI4VixPQUFPLENBQUMyK0IsT0FBbEMsQ0FBZCxDQUNBLEdBQUlDLGNBQWEsQ0FBSyxpQkFBbUI1K0IsUUFBcEIsQ0FDbkJsUSxRQUFRLENBQUNsTSxLQUFLLENBQUMyRCxJQUFOLENBQVd3SSxVQUFYLENBQXNCaVEsT0FBTyxDQUFDNCtCLGFBQTlCLENBQUQsQ0FBK0MsRUFBL0MsQ0FEVyxDQUMwQyxDQUQvRCxDQUVBLEdBQUlDLE9BQU0sQ0FBRzlCLEdBQUcsQ0FBQ3IxQixXQUFKLENBQ1h3SixRQURXLENBQ0R5dEIsT0FEQyxDQUNRLENBRFIsQ0FDV0MsYUFEWCxDQUMwQkgsV0FEMUIsQ0FDdUN4OUIsRUFEdkMsQ0FBYixDQUVBLEdBQUl1OUIsSUFBRyxDQUFHNTZDLEtBQUssQ0FBQ3czQixJQUFOLENBQVcvOEIsTUFBWCxFQUFWLENBQ0FtZ0QsR0FBRyxDQUFDN3NDLEtBQUosQ0FBVXNQLEVBQVYsQ0FBYzQ5QixNQUFkLEVBQ0FMLEdBQUcsQ0FBQzVtQyxNQUFKLENBQVdsYSxJQUFJLENBQUM4WCxLQUFoQixFQUNBLEdBQUlzcEMsU0FBUSxDQUFHTixHQUFHLENBQUN6aUIsTUFBSixFQUFmLENBQ0EsR0FBRytpQixRQUFRLENBQUM5eUMsUUFBVCxLQUF3QmdVLE9BQU8sQ0FBQysrQixTQUFuQyxDQUE4QyxDQUM1QyxLQUFNLElBQUluakQsTUFBSixDQUFVLHNEQUFWLENBQU4sQ0FDRCxDQUNGLENBRURvakQsd0JBQXdCLENBQUNsQixHQUFELENBQU1wZ0QsSUFBSSxDQUFDOFgsS0FBWCxDQUFrQmdILE1BQWxCLENBQTBCMFUsUUFBMUIsQ0FBeEIsQ0FDQSxNQUFPNHNCLElBQVAsQ0FDRCxDQXJLRCxDQXVLQTs7Ozs7Ozs7Ozs7R0FZQSxRQUFTUyxpQkFBVCxDQUEwQjdnRCxJQUExQixDQUFnQyxDQUM5QjtBQUNBO0FBQ0EsR0FBR0EsSUFBSSxDQUFDMmQsUUFBTCxFQUFpQjNkLElBQUksQ0FBQ3lkLFdBQXpCLENBQXNDLENBQ3BDLEdBQUkzRixNQUFLLENBQUc1UixLQUFLLENBQUMyRCxJQUFOLENBQVc0RixZQUFYLEVBQVosQ0FDQSxJQUFJLEdBQUluSCxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUd0SSxJQUFJLENBQUM4WCxLQUFMLENBQVcxWixNQUE5QixDQUFzQyxFQUFFa0ssQ0FBeEMsQ0FBMkMsQ0FDekN3UCxLQUFLLENBQUN2SyxRQUFOLENBQWV2TixJQUFJLENBQUM4WCxLQUFMLENBQVd4UCxDQUFYLEVBQWN3UCxLQUE3QixFQUNELENBQ0Q5WCxJQUFJLENBQUMyZCxRQUFMLENBQWdCM2QsSUFBSSxDQUFDeWQsV0FBTCxDQUFtQixLQUFuQyxDQUNBemQsSUFBSSxDQUFDOFgsS0FBTCxDQUFhQSxLQUFLLENBQUN4SixRQUFOLEVBQWIsQ0FDRCxDQUNELE1BQU90TyxLQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7O0dBVUEsUUFBU3NoRCx5QkFBVCxDQUFrQ2xCLEdBQWxDLENBQXVDbUIsUUFBdkMsQ0FBaUR6aUMsTUFBakQsQ0FBeUQwVSxRQUF6RCxDQUFtRSxDQUNqRSt0QixRQUFRLENBQUczbEMsSUFBSSxDQUFDaUQsT0FBTCxDQUFhMGlDLFFBQWIsQ0FBdUJ6aUMsTUFBdkIsQ0FBWCxDQUE0QywrQkFFNUMsR0FBR3lpQyxRQUFRLENBQUMvakMsUUFBVCxHQUFzQjVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUFqQyxFQUNBeWxDLFFBQVEsQ0FBQ3RzQyxJQUFULEdBQWtCMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBRDVCLEVBRUFza0MsUUFBUSxDQUFDOWpDLFdBQVQsR0FBeUIsSUFGNUIsQ0FFa0MsQ0FDaEMsS0FBTSxJQUFJdmYsTUFBSixDQUFVLDhDQUNkLHlCQURJLENBQU4sQ0FFRCxDQUVELElBQUksR0FBSW9LLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR2k1QyxRQUFRLENBQUN6cEMsS0FBVCxDQUFlMVosTUFBbEMsQ0FBMENrSyxDQUFDLEVBQTNDLENBQStDLENBQzdDLEdBQUlrNUMsWUFBVyxDQUFHRCxRQUFRLENBQUN6cEMsS0FBVCxDQUFleFAsQ0FBZixDQUFsQixDQUVBO0FBQ0EsR0FBSWdhLFFBQU8sQ0FBRyxFQUFkLENBQ0EsR0FBSS9lLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBRyxDQUFDcVksSUFBSSxDQUFDd0csUUFBTCxDQUFjby9CLFdBQWQsQ0FBMkJqQyxvQkFBM0IsQ0FBaURqOUIsT0FBakQsQ0FBMEQvZSxNQUExRCxDQUFKLENBQXVFLENBQ3JFLEdBQUluRCxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FBVSwwQkFBVixDQUFaLENBQ0FrQyxLQUFLLENBQUNtRCxNQUFOLENBQWVBLE1BQWYsQ0FDQSxLQUFNbkQsTUFBTixDQUNELENBRUQsR0FBSW1VLElBQUcsQ0FBRyxDQUNSd2dCLFNBQVMsQ0FBRSxLQURILENBQVYsQ0FHQSxHQUFJOHFCLGFBQVksQ0FBRyxJQUFuQixDQUNBLEdBQUk3L0MsS0FBSSxDQUFHc2lCLE9BQU8sQ0FBQ3MrQixPQUFSLENBQWdCOW9DLEtBQWhCLENBQXNCLENBQXRCLENBQVgsQ0FDQSxPQUFPOEQsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDcStCLFdBQXRCLENBQVAsRUFDQSxJQUFLLzVDLElBQUcsQ0FBQ3VjLElBQUosQ0FBU25qQixJQUFkLENBQ0UsR0FBR0EsSUFBSSxDQUFDd2QsUUFBTCxHQUFrQjVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUE3QixFQUNBOWIsSUFBSSxDQUFDaVYsSUFBTCxHQUFjMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRDNCLENBQ3dDLENBQ3RDLEtBQU0sSUFBSXJlLE1BQUosQ0FBVSxtREFBVixDQUFOLENBQ0QsQ0FDRDJoRCxZQUFZLENBQUdnQixnQkFBZ0IsQ0FBQzdnRCxJQUFELENBQWhCLENBQXVCOFgsS0FBdEMsQ0FDQSxNQUNGLElBQUtsUixJQUFHLENBQUN1YyxJQUFKLENBQVM0USxhQUFkLENBQ0U4ckIsWUFBWSxDQUFHNEIsb0JBQW9CLENBQUN6aEQsSUFBRCxDQUFPd3pCLFFBQVAsQ0FBbkMsQ0FDQWpmLEdBQUcsQ0FBQ3dnQixTQUFKLENBQWdCLElBQWhCLENBQ0EsTUFDRixRQUNFLEdBQUkzMEIsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsa0NBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDdWdELFdBQU4sQ0FBb0Iva0MsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDcStCLFdBQXRCLENBQXBCLENBQ0EsS0FBTXZnRCxNQUFOLENBZkYsQ0FrQkFtVSxHQUFHLENBQUMwckMsUUFBSixDQUFleUIsbUJBQW1CLENBQUM3QixZQUFELENBQWUvZ0MsTUFBZixDQUF1QjBVLFFBQXZCLENBQWxDLENBQ0E0c0IsR0FBRyxDQUFDUCxZQUFKLENBQWlCNzBDLElBQWpCLENBQXNCdUosR0FBdEIsRUFDRCxDQUNGLENBRUQ7Ozs7Ozs7R0FRQSxRQUFTa3RDLHFCQUFULENBQThCemhELElBQTlCLENBQW9Dd3pCLFFBQXBDLENBQThDLENBQzVDLEdBQUlsUixRQUFPLENBQUcsRUFBZCxDQUNBLEdBQUkvZSxPQUFNLENBQUcsRUFBYixDQUNBLEdBQUcsQ0FBQ3FZLElBQUksQ0FBQ3dHLFFBQUwsQ0FDRnBpQixJQURFLENBQ0lrRyxLQUFLLENBQUN5N0MsS0FBTixDQUFZL2xDLElBQVosQ0FBaUJnbUMsc0JBRHJCLENBQzZDdC9CLE9BRDdDLENBQ3NEL2UsTUFEdEQsQ0FBSixDQUNtRSxDQUNqRSxHQUFJbkQsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsbUNBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDbUQsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5ELE1BQU4sQ0FDRCxDQUVELEdBQUkyZixJQUFHLENBQUduRSxJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUNxK0IsV0FBdEIsQ0FBVixDQUNBLEdBQUc1Z0MsR0FBRyxHQUFLblosR0FBRyxDQUFDdWMsSUFBSixDQUFTbmpCLElBQXBCLENBQTBCLENBQ3hCLEdBQUlJLE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUNWLHVEQURVLENBQVosQ0FFQWtDLEtBQUssQ0FBQzJmLEdBQU4sQ0FBWUEsR0FBWixDQUNBLEtBQU0zZixNQUFOLENBQ0QsQ0FFRDtBQUNBMmYsR0FBRyxDQUFHbkUsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDdS9CLFlBQXRCLENBQU4sQ0FDQSxHQUFJNTlCLE9BQU0sQ0FBR3JkLEdBQUcsQ0FBQ3VzQixHQUFKLENBQVEwQixTQUFSLENBQWtCOVUsR0FBbEIsQ0FBdUJ1QyxPQUFPLENBQUN3L0IsWUFBL0IsQ0FBNkN0dUIsUUFBN0MsQ0FBYixDQUVBO0FBQ0EsR0FBSXV1QixxQkFBb0IsQ0FBR2xCLGdCQUFnQixDQUFDditCLE9BQU8sQ0FBQ3kvQixvQkFBVCxDQUEzQyxDQUNBLEdBQUlodEIsVUFBUyxDQUFHN3VCLEtBQUssQ0FBQzJELElBQU4sQ0FBVzRGLFlBQVgsQ0FBd0JzeUMsb0JBQW9CLENBQUNqcUMsS0FBN0MsQ0FBaEIsQ0FFQW1NLE1BQU0sQ0FBQy9KLE1BQVAsQ0FBYzZhLFNBQWQsRUFDQSxHQUFHLENBQUM5USxNQUFNLENBQUN3SixNQUFQLEVBQUosQ0FBcUIsQ0FDbkIsS0FBTSxJQUFJdnZCLE1BQUosQ0FBVSx5Q0FBVixDQUFOLENBQ0QsQ0FFRCxNQUFPK2xCLE9BQU0sQ0FBQ3BSLE1BQVAsQ0FBY3ZFLFFBQWQsRUFBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7R0FXQSxRQUFTb3pDLG9CQUFULENBQTZCN0IsWUFBN0IsQ0FBMkMvZ0MsTUFBM0MsQ0FBbUQwVSxRQUFuRCxDQUE2RCxDQUMzRDtBQUNBLEdBQUcsQ0FBQzFVLE1BQUQsRUFBVytnQyxZQUFZLENBQUN6aEQsTUFBYixHQUF3QixDQUF0QyxDQUF5QyxDQUN2QyxNQUFPLEVBQVAsQ0FDRCxDQUVEO0FBQ0F5aEQsWUFBWSxDQUFHamtDLElBQUksQ0FBQ2lELE9BQUwsQ0FBYWdoQyxZQUFiLENBQTJCL2dDLE1BQTNCLENBQWYsQ0FFQSxHQUFHK2dDLFlBQVksQ0FBQ3JpQyxRQUFiLEdBQTBCNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXJDLEVBQ0QrakMsWUFBWSxDQUFDNXFDLElBQWIsR0FBc0IyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFEL0IsRUFFRDRpQyxZQUFZLENBQUNwaUMsV0FBYixHQUE2QixJQUYvQixDQUVxQyxDQUNuQyxLQUFNLElBQUl2ZixNQUFKLENBQ0osNERBREksQ0FBTixDQUVELENBRUQsR0FBSThqRCxJQUFHLENBQUcsRUFBVixDQUNBLElBQUksR0FBSTE1QyxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUd1M0MsWUFBWSxDQUFDL25DLEtBQWIsQ0FBbUIxWixNQUF0QyxDQUE4Q2tLLENBQUMsRUFBL0MsQ0FBbUQsQ0FDakQsR0FBSTI1QyxRQUFPLENBQUdwQyxZQUFZLENBQUMvbkMsS0FBYixDQUFtQnhQLENBQW5CLENBQWQsQ0FFQTtBQUNBLEdBQUlnYSxRQUFPLENBQUcsRUFBZCxDQUNBLEdBQUkvZSxPQUFNLENBQUcsRUFBYixDQUNBLEdBQUcsQ0FBQ3FZLElBQUksQ0FBQ3dHLFFBQUwsQ0FBYzYvQixPQUFkLENBQXVCeEMsZ0JBQXZCLENBQXlDbjlCLE9BQXpDLENBQWtEL2UsTUFBbEQsQ0FBSixDQUErRCxDQUM3RCxHQUFJbkQsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsc0JBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDbUQsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5ELE1BQU4sQ0FDRCxDQUVELGlEQUNBLEdBQUk4L0MsSUFBRyxDQUFHLENBQ1JqckMsSUFBSSxDQUFFMkcsSUFBSSxDQUFDc0UsUUFBTCxDQUFjb0MsT0FBTyxDQUFDNC9CLEtBQXRCLENBREUsQ0FFUngyQyxVQUFVLENBQUV5MkMsb0JBQW9CLENBQUM3L0IsT0FBTyxDQUFDOC9CLGFBQVQsQ0FGeEIsQ0FBVixDQUlBSixHQUFHLENBQUNoM0MsSUFBSixDQUFTazFDLEdBQVQsRUFFQSxHQUFJbUMsVUFBSixDQUFlQyxPQUFmLENBQ0EsR0FBSUMsUUFBTyxDQUFHamdDLE9BQU8sQ0FBQ2tnQyxRQUFSLENBQWlCMXFDLEtBQWpCLENBQXVCLENBQXZCLENBQWQsQ0FDQSxPQUFPb29DLEdBQUcsQ0FBQ2pyQyxJQUFYLEVBQ0UsSUFBS3JPLElBQUcsQ0FBQ3VjLElBQUosQ0FBU3MvQixtQkFBZCxDQUNFOzt3Q0FHQUYsT0FBTyxDQUFHMzdDLEdBQUcsQ0FBQyt0QixxQkFBSixDQUEwQjR0QixPQUExQixDQUFtQy91QixRQUFuQyxDQUFWLENBQ0EsR0FBRyt1QixPQUFPLEdBQUssSUFBZixDQUFxQixDQUNuQixLQUFNLElBQUlya0QsTUFBSixDQUNKLDBEQURJLENBQU4sQ0FFRCxDQUVELGtCQUNGLElBQUswSSxJQUFHLENBQUN1YyxJQUFKLENBQVN1L0IsTUFBZCxDQUNFOzs0Q0FHQSxHQUFJLENBQ0Z4QyxHQUFHLENBQUMvL0MsR0FBSixDQUFVeUcsR0FBRyxDQUFDMmpCLGtCQUFKLENBQXVCZzRCLE9BQXZCLENBQVYsQ0FDRCxDQUFDLE1BQU10MUMsQ0FBTixDQUFTLENBQ1Q7QUFDQWl6QyxHQUFHLENBQUMvL0MsR0FBSixDQUFVLElBQVYsQ0FDQSsvQyxHQUFHLENBQUN0a0MsSUFBSixDQUFXMm1DLE9BQVgsQ0FDRCxDQUNELFNBQVcseUJBRWIsSUFBSzM3QyxJQUFHLENBQUN1YyxJQUFKLENBQVN3L0IsT0FBZCxDQUNFOzt3RUFHQU4sU0FBUyxDQUFHMUMsZ0JBQVosQ0FDQTJDLE9BQU8sQ0FBRyxrQkFBVyxDQUNuQixHQUFHMW1DLElBQUksQ0FBQ3NFLFFBQUwsQ0FBY29DLE9BQU8sQ0FBQ3NnQyxNQUF0QixJQUFrQ2g4QyxHQUFHLENBQUN1YyxJQUFKLENBQVMwL0IsZUFBOUMsQ0FBK0QsQ0FDN0QsR0FBSXppRCxNQUFLLENBQUcsR0FBSWxDLE1BQUosQ0FDVixxREFEVSxDQUFaLENBRUFrQyxLQUFLLENBQUMyZixHQUFOLENBQVluRSxJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUNzZ0MsTUFBdEIsQ0FBWixDQUNBLEtBQU14aUQsTUFBTixDQUNELENBRUQ7QUFDQSxHQUFJMGlELFNBQVEsQ0FBR2xuQyxJQUFJLENBQUNpRCxPQUFMLENBQWF5RCxPQUFPLENBQUM2ckIsSUFBckIsQ0FBMkJydkIsTUFBM0IsQ0FBZixDQUNBLEdBQUksQ0FDRm9oQyxHQUFHLENBQUMvUixJQUFKLENBQVd2bkMsR0FBRyxDQUFDcW5DLG1CQUFKLENBQXdCNlUsUUFBeEIsQ0FBa0MsSUFBbEMsQ0FBWCxDQUNELENBQUMsTUFBTTcxQyxDQUFOLENBQVMsQ0FDVDtBQUNBaXpDLEdBQUcsQ0FBQy9SLElBQUosQ0FBVyxJQUFYLENBQ0ErUixHQUFHLENBQUN0a0MsSUFBSixDQUFXa25DLFFBQVgsQ0FDRCxDQUNGLENBakJELENBa0JBLE1BRUYsUUFDRSxHQUFJMWlELE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLG1DQUFWLENBQVosQ0FDQWtDLEtBQUssQ0FBQzJmLEdBQU4sQ0FBWW1nQyxHQUFHLENBQUNqckMsSUFBaEIsQ0FDQSxLQUFNN1UsTUFBTixDQXJESixDQXdEQSw2RUFDQSxHQUFHaWlELFNBQVMsR0FBS2w0QyxTQUFkLEVBQ0EsQ0FBQ3lSLElBQUksQ0FBQ3dHLFFBQUwsQ0FBY21nQyxPQUFkLENBQXVCRixTQUF2QixDQUFrQy8vQixPQUFsQyxDQUEyQy9lLE1BQTNDLENBREosQ0FDd0QsQ0FDdEQsR0FBSW5ELE1BQUssQ0FBRyxHQUFJbEMsTUFBSixDQUFVLHVCQUF5Qm1rRCxTQUFTLENBQUN2OUMsSUFBN0MsQ0FBWixDQUNBMUUsS0FBSyxDQUFDbUQsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5ELE1BQU4sQ0FDRCxDQUVELDREQUNBa2lELE9BQU8sR0FDUixDQUVELE1BQU9OLElBQVAsQ0FDRCxDQUVEOzs7Ozs7R0FPQSxRQUFTRyxxQkFBVCxDQUE4QnoyQyxVQUE5QixDQUEwQyxDQUN4QyxHQUFJcTNDLGFBQVksQ0FBRyxFQUFuQixDQUVBLEdBQUdyM0MsVUFBVSxHQUFLdkIsU0FBbEIsQ0FBNkIsQ0FDM0IsSUFBSSxHQUFJN0IsRUFBQyxDQUFHLENBQVosQ0FBZUEsQ0FBQyxDQUFHb0QsVUFBVSxDQUFDdE4sTUFBOUIsQ0FBc0MsRUFBRWtLLENBQXhDLENBQTJDLENBQ3pDLEdBQUlnYSxRQUFPLENBQUcsRUFBZCxDQUNBLEdBQUkvZSxPQUFNLENBQUcsRUFBYixDQUNBLEdBQUcsQ0FBQ3FZLElBQUksQ0FBQ3dHLFFBQUwsQ0FBYzFXLFVBQVUsQ0FBQ3BELENBQUQsQ0FBeEIsQ0FBNkJvM0Msa0JBQTdCLENBQWlEcDlCLE9BQWpELENBQTBEL2UsTUFBMUQsQ0FBSixDQUF1RSxDQUNyRSxHQUFJbkQsTUFBSyxDQUFHLEdBQUlsQyxNQUFKLENBQVUsbUNBQVYsQ0FBWixDQUNBa0MsS0FBSyxDQUFDbUQsTUFBTixDQUFlQSxNQUFmLENBQ0EsS0FBTW5ELE1BQU4sQ0FDRCxDQUVELEdBQUkyZixJQUFHLENBQUduRSxJQUFJLENBQUNzRSxRQUFMLENBQWNvQyxPQUFPLENBQUN2QyxHQUF0QixDQUFWLENBQ0EsR0FBR25aLEdBQUcsQ0FBQ3VjLElBQUosQ0FBU3BELEdBQVQsSUFBa0I1VixTQUFyQixDQUFnQyxDQUM5QjtBQUNBLFNBQ0QsQ0FFRDQ0QyxZQUFZLENBQUNuOEMsR0FBRyxDQUFDdWMsSUFBSixDQUFTcEQsR0FBVCxDQUFELENBQVosQ0FBOEIsRUFBOUIsQ0FDQSxJQUFJLEdBQUlqTSxFQUFDLENBQUcsQ0FBWixDQUFlQSxDQUFDLENBQUd3TyxPQUFPLENBQUN0QyxNQUFSLENBQWU1aEIsTUFBbEMsQ0FBMEMsRUFBRTBWLENBQTVDLENBQStDLENBQzdDaXZDLFlBQVksQ0FBQ244QyxHQUFHLENBQUN1YyxJQUFKLENBQVNwRCxHQUFULENBQUQsQ0FBWixDQUE0Qi9VLElBQTVCLENBQWlDc1gsT0FBTyxDQUFDdEMsTUFBUixDQUFlbE0sQ0FBZixFQUFrQmdFLEtBQW5ELEVBQ0QsQ0FDRixDQUNGLENBRUQsTUFBT2lyQyxhQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCQTFELEdBQUcsQ0FBQzJELFlBQUosQ0FBbUIsU0FBUzdpRCxHQUFULENBQWNndUMsSUFBZCxDQUFvQjNhLFFBQXBCLENBQThCLzFCLE9BQTlCLENBQXVDLENBQ3hEO0FBQ0FBLE9BQU8sQ0FBR0EsT0FBTyxFQUFJLEVBQXJCLENBQ0FBLE9BQU8sQ0FBQ2cyQixRQUFSLENBQW1CaDJCLE9BQU8sQ0FBQ2cyQixRQUFSLEVBQW9CLENBQXZDLENBQ0FoMkIsT0FBTyxDQUFDMFIsS0FBUixDQUFnQjFSLE9BQU8sQ0FBQzBSLEtBQVIsRUFBaUIsSUFBakMsQ0FDQTFSLE9BQU8sQ0FBQ3NvQixTQUFSLENBQW9CdG9CLE9BQU8sQ0FBQ3NvQixTQUFSLEVBQXFCdG9CLE9BQU8sQ0FBQ29rRCxZQUE3QixFQUE2QyxRQUFqRSxDQUNBLEdBQUcsRUFBRSxVQUFZcGtELFFBQWQsQ0FBSCxDQUEyQixDQUN6QkEsT0FBTyxDQUFDd2xELE1BQVIsQ0FBaUIsSUFBakIsQ0FDRCxDQUNELEdBQUcsRUFBRSxjQUFnQnhsRCxRQUFsQixDQUFILENBQStCLENBQzdCQSxPQUFPLENBQUM2aUQsVUFBUixDQUFxQixJQUFyQixDQUNELENBQ0QsR0FBRyxFQUFFLHNCQUF3QjdpRCxRQUExQixDQUFILENBQXVDLENBQ3JDQSxPQUFPLENBQUN5bEQsa0JBQVIsQ0FBNkIsSUFBN0IsQ0FDRCxDQUVELEdBQUk1QyxXQUFVLENBQUc3aUQsT0FBTyxDQUFDNmlELFVBQXpCLENBQ0EsR0FBSTZDLFNBQUosQ0FDQSxHQUFHN0MsVUFBVSxHQUFLLElBQWxCLENBQXdCLENBQ3RCQSxVQUFVLENBQUdwNkMsS0FBSyxDQUFDMkQsSUFBTixDQUFXc0ksVUFBWCxDQUFzQm11QyxVQUF0QixDQUFiLENBQ0QsQ0FGRCxJQUVPLElBQUc3aUQsT0FBTyxDQUFDeWxELGtCQUFYLENBQStCLENBQ3BDO0FBQ0EsR0FBRy9VLElBQUgsQ0FBUyxDQUNQLEdBQUlpVixXQUFVLENBQUdsOUMsS0FBSyxDQUFDMkQsSUFBTixDQUFXbUMsT0FBWCxDQUFtQm1pQyxJQUFuQixFQUEyQkEsSUFBSSxDQUFDLENBQUQsQ0FBL0IsQ0FBcUNBLElBQXRELENBQ0EsR0FBRyxNQUFPaVYsV0FBUCxHQUFzQixRQUF6QixDQUFtQyxDQUNqQ0EsVUFBVSxDQUFHeDhDLEdBQUcsQ0FBQ21uQyxrQkFBSixDQUF1QnFWLFVBQXZCLENBQWIsQ0FDRCxDQUNELEdBQUkxdEIsS0FBSSxDQUFHeHZCLEtBQUssQ0FBQ3FkLEVBQU4sQ0FBU21TLElBQVQsQ0FBYy8wQixNQUFkLEVBQVgsQ0FDQSswQixJQUFJLENBQUN4YixNQUFMLENBQVkwQixJQUFJLENBQUMrRCxLQUFMLENBQVcvWSxHQUFHLENBQUN3bkMsaUJBQUosQ0FBc0JnVixVQUF0QixDQUFYLEVBQThDOTBDLFFBQTlDLEVBQVosRUFDQWd5QyxVQUFVLENBQUc1cUIsSUFBSSxDQUFDdlAsTUFBTCxHQUFjN1gsUUFBZCxFQUFiLENBQ0QsQ0FSRCxJQVFPLENBQ0w7QUFDQTtBQUNBO0FBQ0FneUMsVUFBVSxDQUFHcDZDLEtBQUssQ0FBQ2pCLE1BQU4sQ0FBYXFKLFFBQWIsQ0FBc0IsRUFBdEIsQ0FBYixDQUNELENBQ0YsQ0FFRCxHQUFJc2hDLE1BQUssQ0FBRyxFQUFaLENBQ0EsR0FBRzBRLFVBQVUsR0FBSyxJQUFsQixDQUF3QixDQUN0QjFRLEtBQUssQ0FBQzVrQyxJQUFOLENBQ0U7QUFDQTRRLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEO0FBQ0FyQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUFpRCxLQUFqRCxDQUNFYixJQUFJLENBQUNrRSxRQUFMLENBQWNsWixHQUFHLENBQUN1YyxJQUFKLENBQVNtOUIsVUFBdkIsRUFBbUNoeUMsUUFBbkMsRUFERixDQUYwRCxDQUkxRDtBQUNBc04sSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWdCLEdBQTVDLENBQWlELElBQWpELENBQXVELENBQ3JEdEIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FBNUMsQ0FBeUQsS0FBekQsQ0FDRStqQyxVQURGLENBRHFELENBQXZELENBTDBELENBQTVELENBRkYsRUFZRCxDQUNELEdBQUcsZ0JBQWtCN2lELFFBQXJCLENBQThCLENBQzVCbXlDLEtBQUssQ0FBQzVrQyxJQUFOLENBQ0U7QUFDQTRRLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQzFEO0FBQ0FyQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUE1QyxDQUFpRCxLQUFqRCxDQUNFYixJQUFJLENBQUNrRSxRQUFMLENBQWNsWixHQUFHLENBQUN1YyxJQUFKLENBQVNxOUIsWUFBdkIsRUFBcUNseUMsUUFBckMsRUFERixDQUYwRCxDQUkxRDtBQUNBc04sSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWdCLEdBQTVDLENBQWlELElBQWpELENBQXVELENBQ3JEdEIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVXFCLFNBQTVDLENBQXVELEtBQXZELENBQ0U5ZixPQUFPLENBQUMraUQsWUFEVixDQURxRCxDQUF2RCxDQUwwRCxDQUE1RCxDQUZGLEVBWUQsQ0FFRCxHQUFHNVEsS0FBSyxDQUFDeHhDLE1BQU4sQ0FBZSxDQUFsQixDQUFxQixDQUNuQitrRCxRQUFRLENBQUd2bkMsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWdCLEdBQTVDLENBQWlELElBQWpELENBQXVEMHlCLEtBQXZELENBQVgsQ0FDRCxDQUVEO0FBQ0EsR0FBSXlULFNBQVEsQ0FBRyxFQUFmLENBRUE7QUFDQSxHQUFJM0wsTUFBSyxDQUFHLEVBQVosQ0FDQSxHQUFHdkosSUFBSSxHQUFLLElBQVosQ0FBa0IsQ0FDaEIsR0FBR2pvQyxLQUFLLENBQUMyRCxJQUFOLENBQVdtQyxPQUFYLENBQW1CbWlDLElBQW5CLENBQUgsQ0FBNkIsQ0FDM0J1SixLQUFLLENBQUd2SixJQUFSLENBQ0QsQ0FGRCxJQUVPLENBQ0x1SixLQUFLLENBQUcsQ0FBQ3ZKLElBQUQsQ0FBUixDQUNELENBQ0YsQ0FFRCxHQUFJbVYsYUFBWSxDQUFHLEVBQW5CLENBQ0EsSUFBSSxHQUFJaDdDLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR292QyxLQUFLLENBQUN0NUMsTUFBekIsQ0FBaUMsRUFBRWtLLENBQW5DLENBQXNDLENBQ3BDO0FBQ0E2bEMsSUFBSSxDQUFHdUosS0FBSyxDQUFDcHZDLENBQUQsQ0FBWixDQUNBLEdBQUcsTUFBTzZsQyxLQUFQLEdBQWdCLFFBQW5CLENBQTZCLENBQzNCQSxJQUFJLENBQUd2bkMsR0FBRyxDQUFDbW5DLGtCQUFKLENBQXVCSSxJQUF2QixDQUFQLENBQ0QsQ0FFRDtBQUNBLEdBQUlvVixhQUFZLENBQUlqN0MsQ0FBQyxHQUFLLENBQVAsQ0FBWTY2QyxRQUFaLENBQXVCaDVDLFNBQTFDLENBQ0EsR0FBSTI0QyxTQUFRLENBQUdsOEMsR0FBRyxDQUFDd25DLGlCQUFKLENBQXNCRCxJQUF0QixDQUFmLENBQ0EsR0FBSXFWLFlBQVcsQ0FDYjVuQyxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjbFosR0FBRyxDQUFDdWMsSUFBSixDQUFTdy9CLE9BQXZCLEVBQWdDcjBDLFFBQWhDLEVBREYsQ0FGMEQsQ0FJMUQ7QUFDQXNOLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFBdkIsQ0FBeUMsQ0FBekMsQ0FBNEMsSUFBNUMsQ0FBa0QsQ0FDaEQ7QUFDQUosSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY2xaLEdBQUcsQ0FBQ3VjLElBQUosQ0FBUzAvQixlQUF2QixFQUF3Q3YwQyxRQUF4QyxFQURGLENBRjBELENBSTFEO0FBQ0FzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hESixJQUFJLENBQUNqYixNQUFMLENBQ0VpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEYixDQUN3QkYsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRGxDLENBQytDLEtBRC9DLENBRUVYLElBQUksQ0FBQytELEtBQUwsQ0FBV21qQyxRQUFYLEVBQXFCeDBDLFFBQXJCLEVBRkYsQ0FEZ0QsQ0FBbEQsQ0FMMEQsQ0FBNUQsQ0FGZ0QsQ0FBbEQsQ0FMMEQsQ0FpQjFEO0FBQ0FpMUMsWUFsQjBELENBQTVELENBREYsQ0FxQkFELFlBQVksQ0FBQ3Q0QyxJQUFiLENBQWtCdzRDLFdBQWxCLEVBQ0QsQ0FFRCxHQUFHRixZQUFZLENBQUNsbEQsTUFBYixDQUFzQixDQUF6QixDQUE0QixDQUMxQjtBQUNBLEdBQUlxbEQsaUJBQWdCLENBQUc3bkMsSUFBSSxDQUFDamIsTUFBTCxDQUNyQmliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURVLENBQ0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQURYLENBQ3FCLElBRHJCLENBQzJCcW1DLFlBRDNCLENBQXZCLENBR0E7QUFDQSxHQUFJSSxPQUFNLENBQ1I7QUFDQTluQyxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRTtBQUNBYixJQUFJLENBQUNrRSxRQUFMLENBQWNsWixHQUFHLENBQUN1YyxJQUFKLENBQVNuakIsSUFBdkIsRUFBNkJzTyxRQUE3QixFQUZGLENBRjBELENBSzFEO0FBQ0FzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hESixJQUFJLENBQUNqYixNQUFMLENBQ0VpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEYixDQUN3QkYsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRGxDLENBQytDLEtBRC9DLENBRUVYLElBQUksQ0FBQytELEtBQUwsQ0FBVzhqQyxnQkFBWCxFQUE2Qm4xQyxRQUE3QixFQUZGLENBRGdELENBQWxELENBTjBELENBQTVELENBRkYsQ0FjQSswQyxRQUFRLENBQUNyNEMsSUFBVCxDQUFjMDRDLE1BQWQsRUFDRCxDQUVEO0FBQ0EsR0FBSWhCLE9BQU0sQ0FBRyxJQUFiLENBQ0EsR0FBR3ZpRCxHQUFHLEdBQUssSUFBWCxDQUFpQixDQUNmO0FBQ0EsR0FBSXdqRCxPQUFNLENBQUcvOEMsR0FBRyxDQUFDNmtCLGlCQUFKLENBQXNCN2tCLEdBQUcsQ0FBQ3dsQixnQkFBSixDQUFxQmpzQixHQUFyQixDQUF0QixDQUFiLENBQ0EsR0FBR3F6QixRQUFRLEdBQUssSUFBaEIsQ0FBc0IsQ0FDcEI7QUFDQWt2QixNQUFNLENBQUc5bUMsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDbkU7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY2xaLEdBQUcsQ0FBQ3VjLElBQUosQ0FBU3UvQixNQUF2QixFQUErQnAwQyxRQUEvQixFQURGLENBRm1FLENBSW5FO0FBQ0FzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hEO0FBQ0EybkMsTUFGZ0QsQ0FBbEQsQ0FMbUUsQ0FTbkU7QUFDQVIsUUFWbUUsQ0FBNUQsQ0FBVCxDQVlELENBZEQsSUFjTyxDQUNMO0FBQ0FULE1BQU0sQ0FBRzltQyxJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUNuRTtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjbFosR0FBRyxDQUFDdWMsSUFBSixDQUFTcy9CLG1CQUF2QixFQUE0Q24wQyxRQUE1QyxFQURGLENBRm1FLENBSW5FO0FBQ0FzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hEO0FBQ0FwVixHQUFHLENBQUMyc0IscUJBQUosQ0FBMEJvd0IsTUFBMUIsQ0FBa0Nud0IsUUFBbEMsQ0FBNEMvMUIsT0FBNUMsQ0FGZ0QsQ0FBbEQsQ0FMbUUsQ0FTbkU7QUFDQTBsRCxRQVZtRSxDQUE1RCxDQUFULENBWUQsQ0FFRDtBQUNBLEdBQUlTLGdCQUFlLENBQ2pCaG9DLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQUN5bEMsTUFBRCxDQUE1RCxDQURGLENBR0E7QUFDQSxHQUFJbUIsTUFBSyxDQUNQO0FBQ0Fqb0MsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0U7QUFDQWIsSUFBSSxDQUFDa0UsUUFBTCxDQUFjbFosR0FBRyxDQUFDdWMsSUFBSixDQUFTbmpCLElBQXZCLEVBQTZCc08sUUFBN0IsRUFGRixDQUYwRCxDQUsxRDtBQUNBc04sSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUF2QixDQUF5QyxDQUF6QyxDQUE0QyxJQUE1QyxDQUFrRCxDQUNoREosSUFBSSxDQUFDamIsTUFBTCxDQUNFaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRGIsQ0FDd0JGLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQURsQyxDQUMrQyxLQUQvQyxDQUVFWCxJQUFJLENBQUMrRCxLQUFMLENBQVdpa0MsZUFBWCxFQUE0QnQxQyxRQUE1QixFQUZGLENBRGdELENBQWxELENBTjBELENBQTVELENBRkYsQ0FjQSswQyxRQUFRLENBQUNyNEMsSUFBVCxDQUFjNjRDLEtBQWQsRUFDRCxDQUVEO0FBQ0EsR0FBSUMsS0FBSSxDQUFHbG9DLElBQUksQ0FBQ2piLE1BQUwsQ0FDVGliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURGLENBQ2FGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUR2QixDQUNpQyxJQURqQyxDQUN1Q29tQyxRQUR2QyxDQUFYLENBR0EsR0FBSVUsUUFBSixDQUNBLEdBQUd0bUQsT0FBTyxDQUFDd2xELE1BQVgsQ0FBbUIsQ0FDakI7QUFDQSxHQUFJdnRCLEtBQUksQ0FBR3h2QixLQUFLLENBQUNxZCxFQUFOLENBQVNtUyxJQUFULENBQWMvMEIsTUFBZCxFQUFYLENBQ0EsR0FBSXNnRCxRQUFPLENBQUcsR0FBSS82QyxNQUFLLENBQUMyRCxJQUFOLENBQVcyQyxVQUFmLENBQ1p0RyxLQUFLLENBQUNqQixNQUFOLENBQWFxSixRQUFiLENBQXNCN1EsT0FBTyxDQUFDZzJCLFFBQTlCLENBRFksQ0FBZCxDQUVBLEdBQUl0a0IsTUFBSyxDQUFHMVIsT0FBTyxDQUFDMFIsS0FBcEIsQ0FDQTtBQUNBLEdBQUloUCxJQUFHLENBQUdrL0MsR0FBRyxDQUFDcjFCLFdBQUosQ0FBZ0J3SixRQUFoQixDQUEwQnl0QixPQUExQixDQUFtQyxDQUFuQyxDQUFzQzl4QyxLQUF0QyxDQUE2QyxFQUE3QyxDQUFWLENBQ0EsR0FBSTJ4QyxJQUFHLENBQUc1NkMsS0FBSyxDQUFDdzNCLElBQU4sQ0FBVy84QixNQUFYLEVBQVYsQ0FDQW1nRCxHQUFHLENBQUM3c0MsS0FBSixDQUFVeWhCLElBQVYsQ0FBZ0J2MUIsR0FBaEIsRUFDQTJnRCxHQUFHLENBQUM1bUMsTUFBSixDQUFXMEIsSUFBSSxDQUFDK0QsS0FBTCxDQUFXbWtDLElBQVgsRUFBaUJ4MUMsUUFBakIsRUFBWCxFQUNBLEdBQUk4eUMsU0FBUSxDQUFHTixHQUFHLENBQUN6aUIsTUFBSixFQUFmLENBQ0EwbEIsT0FBTyxDQUFHbm9DLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBQTVDLENBQXNELElBQXRELENBQTRELENBQ3BFO0FBQ0FyQixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDMUQ7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBQTVDLENBQWlELEtBQWpELENBQ0ViLElBQUksQ0FBQ2tFLFFBQUwsQ0FBY2xaLEdBQUcsQ0FBQ3VjLElBQUosQ0FBU3VTLElBQXZCLEVBQTZCcG5CLFFBQTdCLEVBREYsQ0FGMEQsQ0FJMUQ7QUFDQXNOLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVNLElBQTVDLENBQWtELEtBQWxELENBQXlELEVBQXpELENBTDBELENBQTVELENBRjBELENBUzFEO0FBQ0FaLElBQUksQ0FBQ2piLE1BQUwsQ0FDRWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURiLENBQ3dCRixJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FEbEMsQ0FFRSxLQUZGLENBRVM2a0MsUUFBUSxDQUFDOXlDLFFBQVQsRUFGVCxDQVYwRCxDQUE1RCxDQUZvRSxDQWdCcEU7QUFDQXNOLElBQUksQ0FBQ2piLE1BQUwsQ0FDRWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQURiLENBQ3dCRixJQUFJLENBQUNNLElBQUwsQ0FBVUssV0FEbEMsQ0FDK0MsS0FEL0MsQ0FDc0Qwa0MsT0FBTyxDQUFDM3lDLFFBQVIsRUFEdEQsQ0FqQm9FLENBbUJwRTtBQUNBc04sSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FBNUMsQ0FBcUQsS0FBckQsQ0FDRVQsSUFBSSxDQUFDcUcsWUFBTCxDQUFrQjlTLEtBQWxCLEVBQXlCYixRQUF6QixFQURGLENBcEJvRSxDQUE1RCxDQUFWLENBd0JELENBRUQ7QUFDQSxNQUFPc04sS0FBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFBNUMsQ0FBc0QsSUFBdEQsQ0FBNEQsQ0FDakU7QUFDQXJCLElBQUksQ0FBQ2piLE1BQUwsQ0FBWWliLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUF2QixDQUFrQ0YsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BQTVDLENBQXFELEtBQXJELENBQ0VULElBQUksQ0FBQ3FHLFlBQUwsQ0FBa0IsQ0FBbEIsRUFBcUIzVCxRQUFyQixFQURGLENBRmlFLENBSWpFO0FBQ0FzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FBdkIsQ0FBa0NGLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUE1QyxDQUFzRCxJQUF0RCxDQUE0RCxDQUMxRDtBQUNBckIsSUFBSSxDQUFDamIsTUFBTCxDQUFZaWIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBQXZCLENBQWtDRixJQUFJLENBQUNNLElBQUwsQ0FBVU8sR0FBNUMsQ0FBaUQsS0FBakQsQ0FDRTtBQUNBYixJQUFJLENBQUNrRSxRQUFMLENBQWNsWixHQUFHLENBQUN1YyxJQUFKLENBQVNuakIsSUFBdkIsRUFBNkJzTyxRQUE3QixFQUZGLENBRjBELENBSzFEO0FBQ0FzTixJQUFJLENBQUNqYixNQUFMLENBQVlpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0csZ0JBQXZCLENBQXlDLENBQXpDLENBQTRDLElBQTVDLENBQWtELENBQ2hESixJQUFJLENBQUNqYixNQUFMLENBQ0VpYixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FEYixDQUN3QkYsSUFBSSxDQUFDTSxJQUFMLENBQVVLLFdBRGxDLENBQytDLEtBRC9DLENBRUVYLElBQUksQ0FBQytELEtBQUwsQ0FBV21rQyxJQUFYLEVBQWlCeDFDLFFBQWpCLEVBRkYsQ0FEZ0QsQ0FBbEQsQ0FOMEQsQ0FBNUQsQ0FMaUUsQ0FpQmpFeTFDLE9BakJpRSxDQUE1RCxDQUFQLENBbUJELENBdlFELENBeVFBOzs7Ozs7Ozs7Ozs7R0FhQTFFLEdBQUcsQ0FBQ3IxQixXQUFKLENBQWtCOWpCLEtBQUssQ0FBQ2l0QixHQUFOLENBQVV1QixpQkFBNUIsQ0FHQSxLQUFPLENBOTVsQkcsQ0ErNWxCVixRQS81bEJVLENBZzZsQlYsS0FBTyxTQUFTM3NCLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZHQSxHQUFJbEMsTUFBSyxDQUFHa0MsbUJBQW1CLENBQUMsQ0FBRCxDQUEvQixDQUNBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQTtBQUNBLEdBQUl3VCxLQUFJLENBQUcxVixLQUFLLENBQUMwVixJQUFqQixDQUVBO0FBQ0EsR0FBSW9vQyxJQUFHLENBQUdqOEMsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDKzlDLFNBQU4sQ0FBa0IvOUMsS0FBSyxDQUFDKzlDLFNBQU4sRUFBbUIsRUFBaEUsQ0FDQS85QyxLQUFLLENBQUN5N0MsS0FBTixDQUFjejdDLEtBQUssQ0FBQ3k3QyxLQUFOLEVBQWUsRUFBN0IsQ0FDQXo3QyxLQUFLLENBQUN5N0MsS0FBTixDQUFZL2xDLElBQVosQ0FBbUJvb0MsR0FBbkIsQ0FFQSxHQUFJekUscUJBQW9CLENBQUcsQ0FDekJ6NkMsSUFBSSxDQUFFLGFBRG1CLENBRXpCMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRkksQ0FHekI3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIUyxDQUl6QlEsV0FBVyxDQUFFLElBSlksQ0FLekIzRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLHlCQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsYUFMSCxDQUFELENBTUosQ0FDRHhkLElBQUksQ0FBRSxxQkFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUZwQixDQUdEL0csSUFBSSxDQUFFLENBSEwsQ0FJRHdJLFdBQVcsQ0FBRSxJQUpaLENBS0Q4RSxRQUFRLENBQUUsSUFMVCxDQU1EQyxXQUFXLENBQUUsU0FOWixDQU5JLENBTGtCLENBQTNCLENBb0JBd2hDLEdBQUcsQ0FBQ3pFLG9CQUFKLENBQTJCQSxvQkFBM0IsQ0FFQSxHQUFJMkUsOEJBQTZCLENBQUcsQ0FDbENwL0MsSUFBSSxDQUFFLHNCQUQ0QixDQUVsQzBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZhLENBR2xDN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGtCLENBSWxDUSxXQUFXLENBQUUsSUFKcUIsQ0FLbEMzRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLGtDQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVPLEdBSFYsQ0FJTmdCLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsYUFMSCxDQUFELENBTUosQ0FDRHhkLElBQUksQ0FBRSxpREFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIZixDQUlEUSxXQUFXLENBQUUsSUFKWixDQUtEM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSwyREFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGNBTEgsQ0FBRCxDQU1KLENBQ0R4ZCxJQUFJLENBQUUsMkRBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEMEcsV0FBVyxDQUFFLGNBSFosQ0FOSSxDQUxOLENBTkksQ0FzQkosQ0FDRDFkLElBQUksQ0FBRSx1Q0FETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUZwQixDQUdEL0csSUFBSSxDQUFFLENBSEwsQ0FJRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBCQXFOLE9BQU8sQ0FBRSxrQkE5QlIsQ0ErQkRFLFdBQVcsQ0FBRSxzQkEvQlosQ0F0QkksQ0FMMkIsQ0FBcEMsQ0E4REF3aEMsR0FBRyxDQUFDRyxzQkFBSixDQUE2QixDQUMzQnIvQyxJQUFJLENBQUUsZUFEcUIsQ0FFM0IwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGTSxDQUczQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhXLENBSTNCUSxXQUFXLENBQUUsSUFKYyxDQUszQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsdUJBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIVixDQUlOb0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxTQUxILENBQUQsQ0FNSixDQUNEeGQsSUFBSSxDQUFFLDhCQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FIZixDQUlETyxXQUFXLENBQUUsSUFKWixDQUtEK0UsV0FBVyxDQUFFLGdCQUxaLENBTkksRUFZSnNYLE1BWkksQ0FZR29xQiw2QkFaSCxDQUxvQixDQUE3QixDQW9CQUYsR0FBRyxDQUFDcEMsc0JBQUosQ0FBNkIsQ0FDM0I5OEMsSUFBSSxDQUFFLGVBRHFCLENBRTNCMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRk0sQ0FHM0I3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIVyxDQUkzQlEsV0FBVyxDQUFFLElBSmMsQ0FLM0IzRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLHVCQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSFYsQ0FJTm9CLFdBQVcsQ0FBRSxLQUpQLENBS042RSxPQUFPLENBQUUsU0FMSCxDQUFELEVBTUp3WCxNQU5JLENBTUdvcUIsNkJBTkgsQ0FMb0IsQ0FBN0IsQ0FjQSxHQUFJRSxnQkFBZSxDQUFHLENBQ3BCdC9DLElBQUksQ0FBRSxZQURjLENBRXBCMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRkQsQ0FHcEI3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFISSxDQUlwQlEsV0FBVyxDQUFFLElBSk8sQ0FLcEIzRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLG9CQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVHLE9BSFYsQ0FJTm9CLFdBQVcsQ0FBRSxLQUpQLENBQUQsQ0FLSixDQUNEM1ksSUFBSSxDQUFFLGtDQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhmLENBSURRLFdBQVcsQ0FBRSxJQUpaLENBS0QzRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLHlDQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSFYsQ0FJTlEsV0FBVyxDQUFFLElBSlAsQ0FLTitFLFdBQVcsQ0FBRSxRQUxQLENBQUQsQ0FNSixDQUNEMWQsSUFBSSxDQUFFLCtDQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUhmLENBSURvQixXQUFXLENBQUUsS0FKWixDQUtENkUsT0FBTyxDQUFFLFFBTFIsQ0FOSSxDQUxOLENBTEksQ0F1QkosQ0FDRHhkLElBQUksQ0FBRSw0QkFETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIZixDQUlEUSxXQUFXLENBQUUsSUFKWixDQUtEM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSxzQ0FEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGlCQUxILENBQUQsQ0FNSixDQUNEeGQsSUFBSSxDQUFFLHNDQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDJCLFdBQVcsQ0FBRSxLQUhaLENBSUQrRSxXQUFXLENBQUUsaUJBSlosQ0FLREQsUUFBUSxDQUFFLElBTFQsQ0FOSSxDQUxOLENBdkJJLENBeUNKLENBQ0R6ZCxJQUFJLENBQUUsb0NBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRC9HLElBQUksQ0FBRSxDQUhMLENBSUR3SSxXQUFXLENBQUUsSUFKWixDQUtEOEUsUUFBUSxDQUFFLElBTFQsQ0FNREQsT0FBTyxDQUFFLHlCQU5SLENBekNJLENBZ0RKLENBQ0R4ZCxJQUFJLENBQUUsc0NBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSGYsQ0FJRFEsV0FBVyxDQUFFLElBSlosQ0FLRDZFLE9BQU8sQ0FBRSxvQkFMUixDQWhESSxDQXNESixDQUNEeGQsSUFBSSxDQUFFLDRCQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUhmLENBSURrQixXQUFXLENBQUUsS0FKWixDQUtENkUsT0FBTyxDQUFFLFdBTFIsQ0F0REksQ0E0REosQ0FDRHhkLElBQUksQ0FBRSxzQ0FETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdHLGdCQUZwQixDQUdEL0csSUFBSSxDQUFFLENBSEwsQ0FJRHdJLFdBQVcsQ0FBRSxJQUpaLENBS0Q4RSxRQUFRLENBQUUsSUFMVCxDQU1ERCxPQUFPLENBQUUsMkJBTlIsQ0E1REksQ0FMYSxDQUF0QixDQTJFQTBoQyxHQUFHLENBQUNLLG1CQUFKLENBQTBCLENBQ3hCdi9DLElBQUksQ0FBRSxZQURrQixDQUV4QjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZHLENBR3hCN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSFEsQ0FJeEJRLFdBQVcsQ0FBRSxJQUpXLENBS3hCM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSxvQkFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUhWLENBSU5vQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLFNBTEgsQ0FBRCxDQU1KLENBQ0R4ZCxJQUFJLENBQUUsNkJBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEN0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVnQixHQUhmLENBSURPLFdBQVcsQ0FBRSxJQUpaLENBS0QrRSxXQUFXLENBQUUsa0JBTFosQ0FOSSxDQWFQKzhCLG9CQWJPLENBY1AsQ0FDRXo2QyxJQUFJLENBQUUseUJBRFIsQ0FFRTBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGdkIsQ0FHRS9HLElBQUksQ0FBRSxDQUhSLENBSUVzTixRQUFRLENBQUUsSUFKWixDQUtFQyxXQUFXLENBQUUsY0FMZixDQWRPLENBb0JKLENBQ0QxZCxJQUFJLENBQUUsdUNBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXRyxnQkFGcEIsQ0FHRC9HLElBQUksQ0FBRSxDQUhMLENBSURzTixRQUFRLENBQUUsSUFKVCxDQUtEQyxXQUFXLENBQUUsTUFMWixDQXBCSSxDQTBCSixDQUNEMWQsSUFBSSxDQUFFLHdCQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZ0IsR0FIZixDQUlEb0YsT0FBTyxDQUFFLGFBSlIsQ0FLREMsUUFBUSxDQUFFLElBTFQsQ0FNRHpLLEtBQUssQ0FBRSxDQUFDc3NDLGVBQUQsQ0FOTixDQTFCSSxDQUxpQixDQUExQixDQXlDQUosR0FBRyxDQUFDTSxzQkFBSixDQUE2QixDQUMzQngvQyxJQUFJLENBQUUsZUFEcUIsQ0FFM0IwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGTSxDQUczQjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhXLENBSTNCUSxXQUFXLENBQUUsSUFKYyxDQUszQjNGLEtBQUssQ0FBRSxDQUFDLENBQ05oVCxJQUFJLENBQUUsdUJBREEsQ0FFTjBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZmLENBR043RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVUcsT0FIVixDQUlOb0IsV0FBVyxDQUFFLEtBSlAsQ0FLTjZFLE9BQU8sQ0FBRSxTQUxILENBQUQsQ0FNSixDQUNEeGQsSUFBSSxDQUFFLCtCQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVZSxRQUhmLENBSURRLFdBQVcsQ0FBRSxJQUpaLENBS0QzRixLQUFLLENBQUUsQ0FBQyxDQUNOaFQsSUFBSSxDQUFFLHNDQURBLENBRU4wWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGZixDQUdON0csSUFBSSxDQUFFMkcsSUFBSSxDQUFDTSxJQUFMLENBQVVlLFFBSFYsQ0FJTlEsV0FBVyxDQUFFLElBSlAsQ0FLTitFLFdBQVcsQ0FBRSxRQUxQLENBQUQsQ0FNSixDQUNEMWQsSUFBSSxDQUFFLDRDQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVRyxPQUhmLENBSURvQixXQUFXLENBQUUsS0FKWixDQUtENkUsT0FBTyxDQUFFLFFBTFIsQ0FOSSxDQUxOLENBTkksQ0F3QkosQ0FDRHhkLElBQUksQ0FBRSxzQ0FETCxDQUVEMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRnBCLENBR0Q3RyxJQUFJLENBQUUyRyxJQUFJLENBQUNNLElBQUwsQ0FBVWUsUUFIZixDQUlEUSxXQUFXLENBQUUsSUFKWixDQUtEM0YsS0FBSyxDQUFFLENBQUMsQ0FDTmhULElBQUksQ0FBRSxnREFEQSxDQUVOMFksUUFBUSxDQUFFNUIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFNBRmYsQ0FHTjdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVTyxHQUhWLENBSU5nQixXQUFXLENBQUUsS0FKUCxDQUtONkUsT0FBTyxDQUFFLGNBTEgsQ0FBRCxDQU1KLENBQ0R4ZCxJQUFJLENBQUUsZ0RBREwsQ0FFRDBZLFFBQVEsQ0FBRTVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxTQUZwQixDQUdEMkIsV0FBVyxDQUFFLEtBSFosQ0FJRCtFLFdBQVcsQ0FBRSxjQUpaLENBTkksQ0FMTixDQXhCSSxDQXlDSixDQUNEMWQsSUFBSSxDQUFFLDRCQURMLENBRUQwWSxRQUFRLENBQUU1QixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsU0FGcEIsQ0FHRDdHLElBQUksQ0FBRTJHLElBQUksQ0FBQ00sSUFBTCxDQUFVSyxXQUhmLENBSURrQixXQUFXLENBQUUsS0FKWixDQUtENkUsT0FBTyxDQUFFLFFBTFIsQ0F6Q0ksQ0FMb0IsQ0FBN0IsQ0F3REEsS0FBTyxDQTd6bUJHLENBOHptQlYsUUE5em1CVSxDQSt6bUJWLEtBQU8sU0FBU3ZhLE1BQVQsQ0FBaUJELE9BQWpCLENBQTBCTSxtQkFBMUIsQ0FBK0MsQ0FFdEQ7Ozs7OztHQU9BLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLEVBQUQsQ0FBbkIsQ0FFQUwsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDd25DLEdBQU4sQ0FBWXhuQyxLQUFLLENBQUN3bkMsR0FBTixFQUFhLEVBQTFDLENBQ0F4bkMsS0FBSyxDQUFDd25DLEdBQU4sQ0FBVTZQLElBQVYsQ0FBaUJyM0MsS0FBSyxDQUFDcTNDLElBQXZCLENBR0EsS0FBTyxDQS8wbUJHLENBZzFtQlYsUUFoMW1CVSxDQWkxbUJWLEtBQU8sU0FBU3gxQyxNQUFULENBQWlCRCxPQUFqQixDQUEwQk0sbUJBQTFCLENBQStDLENBRXREOzs7Ozs7OztHQVNBLEdBQUlsQyxNQUFLLENBQUdrQyxtQkFBbUIsQ0FBQyxDQUFELENBQS9CLENBQ0FBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FFQWxDLEtBQUssQ0FBQ3duQyxHQUFOLENBQVl4bkMsS0FBSyxDQUFDd25DLEdBQU4sRUFBYSxFQUF6QixDQUNBLEdBQUk2UCxLQUFJLENBQUd4MUMsTUFBTSxDQUFDRCxPQUFQLENBQWlCNUIsS0FBSyxDQUFDd25DLEdBQU4sQ0FBVTZQLElBQVYsQ0FBaUJyM0MsS0FBSyxDQUFDcTNDLElBQU4sQ0FBYXIzQyxLQUFLLENBQUNxM0MsSUFBTixFQUFjLEVBQXhFLENBRUE7Ozs7OztHQU9BQSxJQUFJLENBQUM1OEMsTUFBTCxDQUFjLFNBQVM0aUIsRUFBVCxDQUFhLENBQ3pCLEdBQUltcUIsSUFBRyxDQUFHLENBQ1I7Ozs7OztPQU9BdG5DLFFBQVEsQ0FBRSxrQkFBUzRkLElBQVQsQ0FBZWcxQixPQUFmLENBQXdCLENBQ2hDLHlDQUNBLEdBQUk5bUMsRUFBQyxDQUFHLEdBQUloTSxNQUFLLENBQUMyRCxJQUFOLENBQVcyQyxVQUFmLEVBQVIsQ0FFQSxzRUFDQSxHQUFJb0QsSUFBRyxDQUFHNUssSUFBSSxDQUFDOEwsSUFBTCxDQUFVa29DLE9BQU8sQ0FBR3oxQixFQUFFLENBQUNxUyxZQUF2QixDQUFWLENBQ0EsSUFBSSxHQUFJdHRCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3NILEdBQW5CLENBQXdCdEgsQ0FBQyxFQUF6QixDQUE2QixDQUMzQixnRUFDQSxHQUFJSSxFQUFDLENBQUcsR0FBSXhDLE1BQUssQ0FBQzJELElBQU4sQ0FBVzJDLFVBQWYsRUFBUixDQUNBOUQsQ0FBQyxDQUFDcUYsUUFBRixDQUFXekYsQ0FBWCxFQUVBO3VCQUVBaWIsRUFBRSxDQUFDdFAsS0FBSCxHQUNBc1AsRUFBRSxDQUFDckosTUFBSCxDQUFVOEosSUFBSSxDQUFHdGIsQ0FBQyxDQUFDNEYsUUFBRixFQUFqQixFQUNBNEQsQ0FBQyxDQUFDN0QsU0FBRixDQUFZa1YsRUFBRSxDQUFDNEMsTUFBSCxFQUFaLEVBQ0QsQ0FFRCxzRUFDQWpVLENBQUMsQ0FBQ3ZDLFFBQUYsQ0FBV3VDLENBQUMsQ0FBQzlULE1BQUYsR0FBYTQ2QyxPQUF4QixFQUNBLE1BQU85bUMsRUFBQyxDQUFDNUQsUUFBRixFQUFQLENBQ0QsQ0E3Qk8sQ0FBVixDQWdDQSxNQUFPby9CLElBQVAsQ0FDRCxDQWxDRCxDQXFDQSxLQUFPLENBOTRtQkcsQ0FqRU0sQ0FBaEIsRUFpOW1CQyxDQTM5bUJELEUiLCJmaWxlIjoiZGlzY291cnNlLWNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiZGlzY291cnNlLWNsaWVudFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJkaXNjb3Vyc2UtY2xpZW50XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImRpc2NvdXJzZS1jbGllbnRcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xuIFx0ZnVuY3Rpb24gd2VicGFja0pzb25wQ2FsbGJhY2soZGF0YSkge1xuIFx0XHR2YXIgY2h1bmtJZHMgPSBkYXRhWzBdO1xuIFx0XHR2YXIgbW9yZU1vZHVsZXMgPSBkYXRhWzFdO1xuXG5cbiBcdFx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG4gXHRcdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdO1xuIFx0XHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcbiBcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdHJlc29sdmVzLnB1c2goaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKTtcbiBcdFx0XHR9XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcbiBcdFx0fVxuIFx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGlmKHBhcmVudEpzb25wRnVuY3Rpb24pIHBhcmVudEpzb25wRnVuY3Rpb24oZGF0YSk7XG5cbiBcdFx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG4gXHRcdFx0cmVzb2x2ZXMuc2hpZnQoKSgpO1xuIFx0XHR9XG5cbiBcdH07XG5cblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3NcbiBcdC8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuIFx0Ly8gUHJvbWlzZSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbiBcdHZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG4gXHRcdFwiZGlzY291cnNlLWNsaWVudC5qc1wiOiAwXG4gXHR9O1xuXG5cblxuIFx0Ly8gc2NyaXB0IHBhdGggZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIGpzb25wU2NyaXB0U3JjKGNodW5rSWQpIHtcbiBcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyAoe31bY2h1bmtJZF18fGNodW5rSWQpICsgXCIuanNcIlxuIFx0fVxuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cbiBcdC8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuIFx0Ly8gU2luY2UgYWxsIHJlZmVyZW5jZWQgY2h1bmtzIGFyZSBhbHJlYWR5IGluY2x1ZGVkXG4gXHQvLyBpbiB0aGlzIGZpbGUsIHRoaXMgZnVuY3Rpb24gaXMgZW1wdHkgaGVyZS5cbiBcdF9fd2VicGFja19yZXF1aXJlX18uZSA9IGZ1bmN0aW9uIHJlcXVpcmVFbnN1cmUoKSB7XG4gXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiBcdH07XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gb24gZXJyb3IgZnVuY3Rpb24gZm9yIGFzeW5jIGxvYWRpbmdcbiBcdF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiBcdHZhciBqc29ucEFycmF5ID0gd2luZG93W1wid2VicGFja0pzb25wZGlzY291cnNlX2NsaWVudFwiXSA9IHdpbmRvd1tcIndlYnBhY2tKc29ucGRpc2NvdXJzZV9jbGllbnRcIl0gfHwgW107XG4gXHR2YXIgb2xkSnNvbnBGdW5jdGlvbiA9IGpzb25wQXJyYXkucHVzaC5iaW5kKGpzb25wQXJyYXkpO1xuIFx0anNvbnBBcnJheS5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2s7XG4gXHRqc29ucEFycmF5ID0ganNvbnBBcnJheS5zbGljZSgpO1xuIFx0Zm9yKHZhciBpID0gMDsgaSA8IGpzb25wQXJyYXkubGVuZ3RoOyBpKyspIHdlYnBhY2tKc29ucENhbGxiYWNrKGpzb25wQXJyYXlbaV0pO1xuIFx0dmFyIHBhcmVudEpzb25wRnVuY3Rpb24gPSBvbGRKc29ucEZ1bmN0aW9uO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9kaXNjb3Vyc2UuanNcIik7XG4iLCIvKiEgKGMpIEFuZHJlYSBHaWFtbWFyY2hpIC0gSVNDICovXG52YXIgc2VsZiA9IHRoaXMgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307XG50cnkge1xuICAoZnVuY3Rpb24gKFVSTFNlYXJjaFBhcmFtcywgcGx1cykge1xuICAgIGlmIChcbiAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoJ3E9JTJCJykuZ2V0KCdxJykgIT09IHBsdXMgfHxcbiAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoe3E6IHBsdXN9KS5nZXQoJ3EnKSAhPT0gcGx1cyB8fFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhbWydxJywgcGx1c11dKS5nZXQoJ3EnKSAhPT0gcGx1cyB8fFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcygncT1cXG4nKS50b1N0cmluZygpICE9PSAncT0lMEEnIHx8XG4gICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKHtxOiAnICYnfSkudG9TdHJpbmcoKSAhPT0gJ3E9KyUyNidcbiAgICApXG4gICAgICB0aHJvdyBVUkxTZWFyY2hQYXJhbXM7XG4gICAgc2VsZi5VUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXM7XG4gIH0oVVJMU2VhcmNoUGFyYW1zLCAnKycpKTtcbn0gY2F0Y2goVVJMU2VhcmNoUGFyYW1zKSB7XG4gIChmdW5jdGlvbiAoT2JqZWN0LCBTdHJpbmcsIGlzQXJyYXkpIHsndXNlIHN0cmljdCc7XG4gICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBmaW5kID0gL1shJ1xcKFxcKX5dfCUyMHwlMDAvZztcbiAgICB2YXIgcGx1cyA9IC9cXCsvZztcbiAgICB2YXIgcmVwbGFjZSA9IHtcbiAgICAgICchJzogJyUyMScsXG4gICAgICBcIidcIjogJyUyNycsXG4gICAgICAnKCc6ICclMjgnLFxuICAgICAgJyknOiAnJTI5JyxcbiAgICAgICd+JzogJyU3RScsXG4gICAgICAnJTIwJzogJysnLFxuICAgICAgJyUwMCc6ICdcXHgwMCdcbiAgICB9O1xuICAgIHZhciBwcm90byA9IHtcbiAgICAgIGFwcGVuZDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgYXBwZW5kVG8odGhpcy5fdW5nYXAsIGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5nYXBba2V5XTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldWzBdIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXRBbGw6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldLnNsaWNlKDApIDogW107XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5fdW5nYXA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl91bmdhcFtrZXldID0gW1N0cmluZyh2YWx1ZSldO1xuICAgICAgfSxcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZWxmLl91bmdhcClcbiAgICAgICAgICBzZWxmLl91bmdhcFtrZXldLmZvckVhY2goaW52b2tlLCBrZXkpO1xuICAgICAgICBmdW5jdGlvbiBpbnZva2UodmFsdWUpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBTdHJpbmcoa2V5KSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fdW5nYXApIHtcbiAgICAgICAgICB2YXIgZW5jb2RlZCA9IGVuY29kZShrZXkpO1xuICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdW5nYXBba2V5XTtcbiAgICAgICAgICAgIGkgPCB2YWx1ZS5sZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcXVlcnkucHVzaChlbmNvZGVkICsgJz0nICsgZW5jb2RlKHZhbHVlW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeS5qb2luKCcmJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG8pXG4gICAgICBkZWZpbmVQcm9wZXJ0eShVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHByb3RvW2tleV1cbiAgICAgIH0pO1xuICAgIHNlbGYuVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xuICAgIGZ1bmN0aW9uIFVSTFNlYXJjaFBhcmFtcyhxdWVyeSkge1xuICAgICAgdmFyIGRpY3QgPSBjcmVhdGUobnVsbCk7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3VuZ2FwJywge3ZhbHVlOiBkaWN0fSk7XG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSAhcXVlcnk6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJzpcbiAgICAgICAgICBpZiAocXVlcnkuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICBwYWlycyA9IHF1ZXJ5LnNwbGl0KCcmJyksXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHZhbHVlLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgIGlmICgtMSA8IGluZGV4KSB7XG4gICAgICAgICAgICAgIGFwcGVuZFRvKFxuICAgICAgICAgICAgICAgIGRpY3QsXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlLnNsaWNlKDAsIGluZGV4KSksXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlLnNsaWNlKGluZGV4ICsgMSkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCl7XG4gICAgICAgICAgICAgIGFwcGVuZFRvKFxuICAgICAgICAgICAgICAgIGRpY3QsXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpc0FycmF5KHF1ZXJ5KTpcbiAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBxdWVyeS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcXVlcnlbaV07XG4gICAgICAgICAgICBhcHBlbmRUbyhkaWN0LCB2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9yRWFjaCcgaW4gcXVlcnk6XG4gICAgICAgICAgcXVlcnkuZm9yRWFjaChhZGRFYWNoLCBkaWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcXVlcnkpXG4gICAgICAgICAgICBhcHBlbmRUbyhkaWN0LCBrZXksIHF1ZXJ5W2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEVhY2godmFsdWUsIGtleSkge1xuICAgICAgYXBwZW5kVG8odGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGFwcGVuZFRvKGRpY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywnKSA6IHZhbHVlO1xuICAgICAgaWYgKGtleSBpbiBkaWN0KVxuICAgICAgICBkaWN0W2tleV0ucHVzaChyZXMpO1xuICAgICAgZWxzZVxuICAgICAgICBkaWN0W2tleV0gPSBbcmVzXTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZShwbHVzLCAnICcpKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoZmluZCwgcmVwbGFjZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVttYXRjaF07XG4gICAgfVxuXG4gIH0oT2JqZWN0LCBTdHJpbmcsIEFycmF5LmlzQXJyYXkpKTtcbn1cblxuKGZ1bmN0aW9uIChVUkxTZWFyY2hQYXJhbXNQcm90bykge1xuXG4gIHZhciBpdGVyYWJsZSA9IGZhbHNlO1xuICB0cnkgeyBpdGVyYWJsZSA9ICEhU3ltYm9sLml0ZXJhdG9yOyB9IGNhdGNoIChvX08pIHt9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ2ZvckVhY2gnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy50b1N0cmluZygpXG4gICAgICAgICAgLnJlcGxhY2UoLz1bXFxzXFxTXSo/KD86JnwkKS9nLCAnPScpXG4gICAgICAgICAgLnNwbGl0KCc9JylcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFuYW1lLmxlbmd0aCB8fCBuYW1lIGluIG5hbWVzKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAobmFtZXNbbmFtZV0gPSBzZWxmLmdldEFsbChuYW1lKSkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgna2V5cycgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkgeyB0aGlzLnB1c2goa2V5KTsgfSk7XG4gICAgfTtcbiAgfVxuXG4gICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgndmFsdWVzJyBpbiBVUkxTZWFyY2hQYXJhbXNQcm90bykpIHtcbiAgICBVUkxTZWFyY2hQYXJhbXNQcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkgeyB0aGlzLnB1c2godmFsdWUpOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ2VudHJpZXMnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgdGhpcy5wdXNoKFtrZXksIHZhbHVlXSk7IH0pO1xuICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXRlcmFibGUgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG9bU3ltYm9sLml0ZXJhdG9yXSA9IFVSTFNlYXJjaFBhcmFtc1Byb3RvLmVudHJpZXM7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgnc29ydCcgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uc29ydCA9IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgICB2YXJcbiAgICAgICAgZW50cmllcyA9IHRoaXMuZW50cmllcygpLFxuICAgICAgICBlbnRyeSA9IGVudHJpZXMubmV4dCgpLFxuICAgICAgICBkb25lID0gZW50cnkuZG9uZSxcbiAgICAgICAga2V5cyA9IFtdLFxuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBpLCBrZXksIHZhbHVlXG4gICAgICA7XG4gICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgdmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAga2V5ID0gdmFsdWVbMF07XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICBpZiAoIShrZXkgaW4gdmFsdWVzKSkge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2tleV0ucHVzaCh2YWx1ZVsxXSk7XG4gICAgICAgIGVudHJ5ID0gZW50cmllcy5uZXh0KCk7XG4gICAgICAgIGRvbmUgPSBlbnRyeS5kb25lO1xuICAgICAgfVxuICAgICAgLy8gbm90IHRoZSBjaGFtcGlvbiBpbiBlZmZpY2llbmN5XG4gICAgICAvLyBidXQgdGhlc2UgdHdvIGJpdHMganVzdCBkbyB0aGUgam9iXG4gICAgICBrZXlzLnNvcnQoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKGtleXNbaV0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdGhpcy5hcHBlbmQoa2V5LCB2YWx1ZXNba2V5XS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0b3Ioc2VsZiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBzZWxmLmZvckVhY2goY2FsbGJhY2ssIGl0ZW1zKTtcbiAgICByZXR1cm4gaXRlcmFibGUgP1xuICAgICAgaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpIDpcbiAgICAgIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgIH1cbiAgICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAoZnVuY3Rpb24gKE9iamVjdCkge1xuICAgIHZhclxuICAgICAgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc1BvbGx1dGUgPSBmdW5jdGlvbiAoc2VhcmNoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmFwcGVuZC5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLl91c3AsIG5hbWUgPyAoJz8nICsgbmFtZSkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsKG5hbWUpIHtcbiAgICAgICAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5kZWxldGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLl91c3AsIG5hbWUgPyAoJz8nICsgbmFtZSkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uc2V0LmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgc2VhcmNoLnNldC5jYWxsKHRoaXMuX3VzcCwgbmFtZSA/ICgnPycgKyBuYW1lKSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNwLCB2YWx1ZSkge1xuICAgICAgICAgIHNwLmFwcGVuZCA9IGFwcGVuZDtcbiAgICAgICAgICBzcC5kZWxldGUgPSBkZWw7XG4gICAgICAgICAgc3Auc2V0ID0gc2V0O1xuICAgICAgICAgIHJldHVybiBkUChzcCwgJ191c3AnLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc0NyZWF0ZSA9IGZ1bmN0aW9uIChwb2xsdXRlU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBzcCkge1xuICAgICAgICAgIGRQKFxuICAgICAgICAgICAgb2JqLCAnX3NlYXJjaFBhcmFtcycsIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHBvbGx1dGVTZWFyY2hQYXJhbXMoc3AsIG9iailcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBzcDtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAoc3ApIHtcbiAgICAgICAgdmFyIGFwcGVuZCA9IHNwLmFwcGVuZDtcbiAgICAgICAgc3AuYXBwZW5kID0gVVJMU2VhcmNoUGFyYW1zUHJvdG8uYXBwZW5kO1xuICAgICAgICBVUkxTZWFyY2hQYXJhbXMuY2FsbChzcCwgc3AuX3VzcC5zZWFyY2guc2xpY2UoMSkpO1xuICAgICAgICBzcC5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICB9LFxuICAgICAgdmVyaWZ5U2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKG9iaiwgQ2xhc3MpIHtcbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgQ2xhc3MpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiJ3NlYXJjaFBhcmFtcycgYWNjZXNzZWQgb24gYW4gb2JqZWN0IHRoYXQgXCIgK1xuICAgICAgICAgIFwiZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBcIiArIENsYXNzLm5hbWVcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1cGdyYWRlQ2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgQ2xhc3NQcm90byA9IENsYXNzLnByb3RvdHlwZSxcbiAgICAgICAgICBzZWFyY2hQYXJhbXMgPSBnT1BEKENsYXNzUHJvdG8sICdzZWFyY2hQYXJhbXMnKSxcbiAgICAgICAgICBocmVmID0gZ09QRChDbGFzc1Byb3RvLCAnaHJlZicpLFxuICAgICAgICAgIHNlYXJjaCA9IGdPUEQoQ2xhc3NQcm90bywgJ3NlYXJjaCcpLFxuICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc1xuICAgICAgICA7XG4gICAgICAgIGlmICghc2VhcmNoUGFyYW1zICYmIHNlYXJjaCAmJiBzZWFyY2guc2V0KSB7XG4gICAgICAgICAgY3JlYXRlU2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zQ3JlYXRlKFxuICAgICAgICAgICAgY3JlYXRlU2VhcmNoUGFyYW1zUG9sbHV0ZShzZWFyY2gpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICAgICAgICAgIENsYXNzUHJvdG8sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGhyZWY6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBocmVmLmdldC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzcCA9IHRoaXMuX3NlYXJjaFBhcmFtcztcbiAgICAgICAgICAgICAgICAgIGhyZWYuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNwKSB1cGRhdGVTZWFyY2hQYXJhbXMoc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2VhcmNoOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2VhcmNoLmdldC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzcCA9IHRoaXMuX3NlYXJjaFBhcmFtcztcbiAgICAgICAgICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoc3ApIHVwZGF0ZVNlYXJjaFBhcmFtcyhzcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZlcmlmeVNlYXJjaFBhcmFtcyh0aGlzLCBDbGFzcyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoUGFyYW1zIHx8IGNyZWF0ZVNlYXJjaFBhcmFtcyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyh0aGlzLnNlYXJjaC5zbGljZSgxKSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzcCkge1xuICAgICAgICAgICAgICAgICAgdmVyaWZ5U2VhcmNoUGFyYW1zKHRoaXMsIENsYXNzKTtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtcyh0aGlzLCBzcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIDtcbiAgICB0cnkge1xuICAgICAgdXBncmFkZUNsYXNzKEhUTUxBbmNob3JFbGVtZW50KTtcbiAgICAgIGlmICgvXmZ1bmN0aW9ufG9iamVjdCQvLnRlc3QodHlwZW9mIFVSTCkgJiYgVVJMLnByb3RvdHlwZSlcbiAgICAgICAgdXBncmFkZUNsYXNzKFVSTCk7XG4gICAgfSBjYXRjaCAobWVoKSB7fVxuICB9KE9iamVjdCkpO1xuXG59KHNlbGYuVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZSwgT2JqZWN0KSk7XG5leHBvcnQgZGVmYXVsdCBzZWxmLlVSTFNlYXJjaFBhcmFtcztcbiIsIi8qKlxuICogQGF1dGhvciBLdWl0b3NcbiAqIEBob21lcGFnZSBodHRwczovL2dpdGh1Yi5jb20va3VpdG9zL1xuICogQHNpbmNlIDIwMTctMTAtMTJcbiAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBMUlVDYWNoZSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IGJ1aWxkU29ydGVkVVJMIGZyb20gJy4vdXRpbHMvYnVpbGRTb3J0ZWRVUkwnO1xuaW1wb3J0IGlzQ2FjaGVMaWtlIGZyb20gJy4vdXRpbHMvaXNDYWNoZUxpa2UnO1xudmFyIEZJVkVfTUlOVVRFUyA9IDEwMDAgKiA2MCAqIDU7XG52YXIgQ0FQQUNJVFkgPSAxMDA7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYWNoZUFkYXB0ZXJFbmhhbmNlcihhZGFwdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5hYmxlZEJ5RGVmYXVsdCwgZW5hYmxlZEJ5RGVmYXVsdCA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIF9iID0gb3B0aW9ucy5jYWNoZUZsYWcsIGNhY2hlRmxhZyA9IF9iID09PSB2b2lkIDAgPyAnY2FjaGUnIDogX2IsIF9jID0gb3B0aW9ucy5kZWZhdWx0Q2FjaGUsIGRlZmF1bHRDYWNoZSA9IF9jID09PSB2b2lkIDAgPyBuZXcgTFJVQ2FjaGUoeyBtYXhBZ2U6IEZJVkVfTUlOVVRFUywgbWF4OiBDQVBBQ0lUWSB9KSA6IF9jO1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciB1cmwgPSBjb25maWcudXJsLCBtZXRob2QgPSBjb25maWcubWV0aG9kLCBwYXJhbXMgPSBjb25maWcucGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyID0gY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIsIGZvcmNlVXBkYXRlID0gY29uZmlnLmZvcmNlVXBkYXRlO1xuICAgICAgICB2YXIgdXNlQ2FjaGUgPSAoY29uZmlnW2NhY2hlRmxhZ10gIT09IHZvaWQgMCAmJiBjb25maWdbY2FjaGVGbGFnXSAhPT0gbnVsbCkgPyBjb25maWdbY2FjaGVGbGFnXSA6IGVuYWJsZWRCeURlZmF1bHQ7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdnZXQnICYmIHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAvLyBpZiBoYWQgcHJvdmlkZSBhIHNwZWNpZmllZCBjYWNoZSwgdGhlbiB1c2UgaXQgaW5zdGVhZFxuICAgICAgICAgICAgdmFyIGNhY2hlXzEgPSBpc0NhY2hlTGlrZSh1c2VDYWNoZSkgPyB1c2VDYWNoZSA6IGRlZmF1bHRDYWNoZTtcbiAgICAgICAgICAgIC8vIGJ1aWxkIHRoZSBpbmRleCBhY2NvcmRpbmcgdG8gdGhlIHVybCBhbmQgcGFyYW1zXG4gICAgICAgICAgICB2YXIgaW5kZXhfMSA9IGJ1aWxkU29ydGVkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKTtcbiAgICAgICAgICAgIHZhciByZXNwb25zZVByb21pc2UgPSBjYWNoZV8xLmdldChpbmRleF8xKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VQcm9taXNlIHx8IGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhc29uXzE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYWRhcHRlcihjb25maWcpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlXzEuZGVsKGluZGV4XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWFzb25fMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7IH0pKCk7XG4gICAgICAgICAgICAgICAgLy8gcHV0IHRoZSBwcm9taXNlIGZvciB0aGUgbm9uLXRyYW5zZm9ybWVkIHJlc3BvbnNlIGludG8gY2FjaGUgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGNhY2hlXzEuc2V0KGluZGV4XzEsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTE9HR0VSX0xFVkVMID09PSAnaW5mbycpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInJlcXVlc3QgY2FjaGVkIGJ5IGNhY2hlIGFkYXB0ZXI6IFwiICsgaW5kZXhfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGFwdGVyKGNvbmZpZyk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlQWRhcHRlckVuaGFuY2VyLmpzLm1hcCIsIi8qKlxuICogQGF1dGhvciBLdWl0b3NcbiAqIEBob21lcGFnZSBodHRwczovL2dpdGh1Yi5jb20va3VpdG9zL1xuICogQHNpbmNlIDIwMTctMDktMjhcbiAqL1xuaW1wb3J0IENhY2hlIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgY2FjaGVBZGFwdGVyRW5oYW5jZXIgZnJvbSAnLi9jYWNoZUFkYXB0ZXJFbmhhbmNlcic7XG5pbXBvcnQgdGhyb3R0bGVBZGFwdGVyRW5oYW5jZXIgZnJvbSAnLi90aHJvdHRsZUFkYXB0ZXJFbmhhbmNlcic7XG5leHBvcnQgeyBDYWNoZSwgY2FjaGVBZGFwdGVyRW5oYW5jZXIsIHRocm90dGxlQWRhcHRlckVuaGFuY2VyLCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXG4gKiBAYXV0aG9yIEt1aXRvc1xuICogQGhvbWVwYWdlIGh0dHBzOi8vZ2l0aHViLmNvbS9rdWl0b3MvXG4gKiBAc2luY2UgMjAxNy0xMC0xMVxuICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgYnVpbGRTb3J0ZWRVUkwgZnJvbSAnLi91dGlscy9idWlsZFNvcnRlZFVSTCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJvdHRsZUFkYXB0ZXJFbmhhbmNlcihhZGFwdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMudGhyZXNob2xkLCB0aHJlc2hvbGQgPSBfYSA9PT0gdm9pZCAwID8gMTAwMCA6IF9hLCBfYiA9IG9wdGlvbnMuY2FjaGUsIGNhY2hlID0gX2IgPT09IHZvaWQgMCA/IG5ldyBMUlVDYWNoZSh7IG1heDogMTAgfSkgOiBfYjtcbiAgICB2YXIgcmVjb3JkQ2FjaGVXaXRoUmVxdWVzdCA9IGZ1bmN0aW9uIChpbmRleCwgY29uZmlnKSB7XG4gICAgICAgIHZhciByZXNwb25zZVByb21pc2UgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIHJlYXNvbl8xO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYWRhcHRlcihjb25maWcpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFByb21pc2UucmVzb2x2ZShyZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZGVsKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlYXNvbl8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pKCk7XG4gICAgICAgIGNhY2hlLnNldChpbmRleCwge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdmFsdWU6IHJlc3BvbnNlUHJvbWlzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgdXJsID0gY29uZmlnLnVybCwgbWV0aG9kID0gY29uZmlnLm1ldGhvZCwgcGFyYW1zID0gY29uZmlnLnBhcmFtcywgcGFyYW1zU2VyaWFsaXplciA9IGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyO1xuICAgICAgICB2YXIgaW5kZXggPSBidWlsZFNvcnRlZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcik7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgY2FjaGVkUmVjb3JkID0gY2FjaGUuZ2V0KGluZGV4KSB8fCB7IHRpbWVzdGFtcDogbm93IH07XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICBpZiAobm93IC0gY2FjaGVkUmVjb3JkLnRpbWVzdGFtcCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VQcm9taXNlID0gY2FjaGVkUmVjb3JkLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkxPR0dFUl9MRVZFTCA9PT0gJ2luZm8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicmVxdWVzdCBjYWNoZWQgYnkgdGhyb3R0bGUgYWRhcHRlcjogXCIgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkQ2FjaGVXaXRoUmVxdWVzdChpbmRleCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRhcHRlcihjb25maWcpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZUFkYXB0ZXJFbmhhbmNlci5qcy5tYXAiLCIvKipcbiAqIEBhdXRob3IgS3VpdG9zXG4gKiBAaG9tZXBhZ2UgaHR0cHM6Ly9naXRodWIuY29tL2t1aXRvcy9cbiAqIEBzaW5jZSAyMDE3LTEwLTEyXG4gKi9cbmltcG9ydCBidWlsZFVSTCBmcm9tICdheGlvcy9saWIvaGVscGVycy9idWlsZFVSTCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFNvcnRlZFVSTCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGJ1aWx0VVJMID0gYnVpbGRVUkwuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICB2YXIgX2EgPSBidWlsdFVSTC5zcGxpdCgnPycpLCB1cmxQYXRoID0gX2FbMF0sIHF1ZXJ5U3RyaW5nID0gX2FbMV07XG4gICAgaWYgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHZhciBwYXJhbXNQYWlyID0gcXVlcnlTdHJpbmcuc3BsaXQoJyYnKTtcbiAgICAgICAgcmV0dXJuIHVybFBhdGggKyBcIj9cIiArIHBhcmFtc1BhaXIuc29ydCgpLmpvaW4oJyYnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWx0VVJMO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRTb3J0ZWRVUkwuanMubWFwIiwiLyoqXG4gKiBAYXV0aG9yIEt1aXRvc1xuICogQGhvbWVwYWdlIGh0dHBzOi8vZ2l0aHViLmNvbS9rdWl0b3MvXG4gKiBAc2luY2UgMjAxOC0wMy0xOVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0NhY2hlTGlrZShjYWNoZSkge1xuICAgIHJldHVybiAhIShjYWNoZS5zZXQgJiYgY2FjaGUuZ2V0ICYmIGNhY2hlLmRlbCAmJlxuICAgICAgICB0eXBlb2YgY2FjaGUuZ2V0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYWNoZS5zZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNhY2hlLmRlbCA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0NhY2hlTGlrZS5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcbnZhciBidG9hID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5idG9hICYmIHdpbmRvdy5idG9hLmJpbmQod2luZG93KSkgfHwgcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J0b2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgdmFyIHhEb21haW4gPSBmYWxzZTtcblxuICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG4gICAgLy8gT25seSBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgY2FsbHMgYW5kIGRvZXNuJ3QgcmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgICAhaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSB7XG4gICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG4gICAgICB4RG9tYWluID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIC8vIElFIHNlbmRzIDEyMjMgaW5zdGVhZCBvZiAyMDQgKGh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXMvMjAxKVxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gMjA0IDogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICB2YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG5cbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vLi4vZGVmYXVsdHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSB1dGlscy5tZXJnZSh7XG4gICAgICB1cmw6IGFyZ3VtZW50c1swXVxuICAgIH0sIGFyZ3VtZW50c1sxXSk7XG4gIH1cblxuICBjb25maWcgPSB1dGlscy5tZXJnZShkZWZhdWx0cywge21ldGhvZDogJ2dldCd9LCB0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIC8vIE5vdGU6IHN0YXR1cyBpcyBub3QgZXhwb3NlZCBieSBYRG9tYWluUmVxdWVzdFxuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KSB7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgaW5kZXggPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDA7XG4gIHZhciBpID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYgKGFMZW4gPCAyKSBmb3IgKDs7KSB7XG4gICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggKz0gaTtcbiAgICBpZiAoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvciAoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZXhlYycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xuXG52YXIgU1BFQ0lFUyA9IHdrcygnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMiAmJiByZXN1bHRbMF0gPT09ICdhJyAmJiByZXN1bHRbMV0gPT09ICdiJztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7XG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MID8gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgfVxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUykgfHxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgZm5zID0gZXhlYyhcbiAgICAgIGRlZmluZWQsXG4gICAgICBTWU1CT0wsXG4gICAgICAnJ1tLRVldLFxuICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgICB2YXIgcnhmbiA9IGZuc1sxXTtcblxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICB9IGVsc2UgaWYgKE9ic2VydmVyICYmICEoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBidWlsdGluRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcblxuIC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cbiAgcmV0dXJuIGJ1aWx0aW5FeGVjLmNhbGwoUiwgUyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS8sXG4gICAgICByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMVtMQVNUX0lOREVYXSAhPT0gMCB8fCByZTJbTEFTVF9JTkRFWF0gIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmVbTEFTVF9JTkRFWF07XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGghJyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKSB7XG4gIHZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuICB2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG4gIHZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG4gIHZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4gIHZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xuICB2YXIgJGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xuICB2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG4gIHZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbiAgdmFyIHByb3BlcnR5RGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbiAgdmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4gIHZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuICB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuICB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbiAgdmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xuICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbiAgdmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbiAgdmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG4gIHZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbiAgdmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xuICB2YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG4gIHZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuICB2YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuICB2YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4gIHZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbiAgdmFyIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpO1xuICB2YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuICB2YXIgQXJyYXlJdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xuICB2YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG4gIHZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG4gIHZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbiAgdmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbiAgdmFyIGFycmF5Q29weVdpdGhpbiA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyk7XG4gIHZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbiAgdmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbiAgdmFyIGRQID0gJERQLmY7XG4gIHZhciBnT1BEID0gJEdPUEQuZjtcbiAgdmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbiAgdmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG4gIHZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuICB2YXIgU0hBUkVEX0JVRkZFUiA9ICdTaGFyZWQnICsgQVJSQVlfQlVGRkVSO1xuICB2YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xuICB2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXlbUFJPVE9UWVBFXTtcbiAgdmFyICRBcnJheUJ1ZmZlciA9ICRidWZmZXIuQXJyYXlCdWZmZXI7XG4gIHZhciAkRGF0YVZpZXcgPSAkYnVmZmVyLkRhdGFWaWV3O1xuICB2YXIgYXJyYXlGb3JFYWNoID0gY3JlYXRlQXJyYXlNZXRob2QoMCk7XG4gIHZhciBhcnJheUZpbHRlciA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpO1xuICB2YXIgYXJyYXlTb21lID0gY3JlYXRlQXJyYXlNZXRob2QoMyk7XG4gIHZhciBhcnJheUV2ZXJ5ID0gY3JlYXRlQXJyYXlNZXRob2QoNCk7XG4gIHZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbiAgdmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG4gIHZhciBhcnJheUluY2x1ZGVzID0gY3JlYXRlQXJyYXlJbmNsdWRlcyh0cnVlKTtcbiAgdmFyIGFycmF5SW5kZXhPZiA9IGNyZWF0ZUFycmF5SW5jbHVkZXMoZmFsc2UpO1xuICB2YXIgYXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXM7XG4gIHZhciBhcnJheUtleXMgPSBBcnJheUl0ZXJhdG9ycy5rZXlzO1xuICB2YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcbiAgdmFyIGFycmF5TGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mO1xuICB2YXIgYXJyYXlSZWR1Y2UgPSBBcnJheVByb3RvLnJlZHVjZTtcbiAgdmFyIGFycmF5UmVkdWNlUmlnaHQgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0O1xuICB2YXIgYXJyYXlKb2luID0gQXJyYXlQcm90by5qb2luO1xuICB2YXIgYXJyYXlTb3J0ID0gQXJyYXlQcm90by5zb3J0O1xuICB2YXIgYXJyYXlTbGljZSA9IEFycmF5UHJvdG8uc2xpY2U7XG4gIHZhciBhcnJheVRvU3RyaW5nID0gQXJyYXlQcm90by50b1N0cmluZztcbiAgdmFyIGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBBcnJheVByb3RvLnRvTG9jYWxlU3RyaW5nO1xuICB2YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG4gIHZhciBUQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG4gIHZhciBUWVBFRF9DT05TVFJVQ1RPUiA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKTtcbiAgdmFyIERFRl9DT05TVFJVQ1RPUiA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBBTExfQ09OU1RSVUNUT1JTID0gJHR5cGVkLkNPTlNUUjtcbiAgdmFyIFRZUEVEX0FSUkFZID0gJHR5cGVkLlRZUEVEO1xuICB2YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xuICB2YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT09IDE7XG4gIH0pO1xuXG4gIHZhciBGT1JDRURfU0VUID0gISFVaW50OEFycmF5ICYmICEhVWludDhBcnJheVtQUk9UT1RZUEVdLnNldCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBpZiAoaXNPYmplY3QoaXQpICYmIFRZUEVEX0FSUkFZIGluIGl0KSByZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiAoQywgbGVuZ3RoKSB7XG4gICAgaWYgKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24gKE8sIGxpc3QpIHtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSwgaW50ZXJuYWwpIHtcbiAgICBkUChpdCwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH0gfSk7XG4gIH07XG5cbiAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3Qoc291cmNlKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspIHtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmIChtYXBwaW5nICYmIGFMZW4gPiAyKSBtYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoLyogLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbiAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSkgOiB2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG8gPSB7XG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qICwgZW5kICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCwgZW5kICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbGlkYXRlKHRoYXQpLmxlbmd0aDtcbiAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IG1pZGRsZSkge1xuICAgICAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheVNvbWUodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIE8gPSB2YWxpZGF0ZSh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcbiAgICAgIHZhciAkYmVnaW4gPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciAkc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyogLCBvZmZzZXQgKi8pIHtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIHNyYyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbiArIG9mZnNldCA+IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldClcbiAgICAgICYmIHRhcmdldFtUWVBFRF9BUlJBWV1cbiAgICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcbiAgICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcbiAgdmFyICRnZXREZXNjID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgaWYgKGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICAmJiBpc09iamVjdChkZXNjKVxuICAgICAgJiYgaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgICAmJiAhaGFzKGRlc2MsICdnZXQnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnc2V0JylcbiAgICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgICAmJiAhZGVzYy5jb25maWd1cmFibGVcbiAgICAgICYmICghaGFzKGRlc2MsICd3cml0YWJsZScpIHx8IGRlc2Mud3JpdGFibGUpXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSlcbiAgICApIHtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmICghQUxMX0NPTlNUUlVDVE9SUykge1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAkc2V0RGVzY1xuICB9KTtcblxuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSkge1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICRzbGljZSxcbiAgICBzZXQ6ICRzZXQsXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTsgfVxuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIENMQU1QRUQgPSAhIUNMQU1QRUQ7XG4gICAgdmFyIE5BTUUgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSc7XG4gICAgdmFyIEdFVFRFUiA9ICdnZXQnICsgS0VZO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIEtFWTtcbiAgICB2YXIgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXTtcbiAgICB2YXIgQmFzZSA9IFR5cGVkQXJyYXkgfHwge307XG4gICAgdmFyIFRBQyA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSk7XG4gICAgdmFyIEZPUkNFRCA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWO1xuICAgIHZhciBPID0ge307XG4gICAgdmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5ICYmIFR5cGVkQXJyYXlbUFJPVE9UWVBFXTtcbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4ZmYgPyAweGZmIDogdmFsdWUgJiAweGZmO1xuICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheSgxKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0pIHx8ICEkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgQmFzZSh0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheSkpIGhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYgKCFMSUJSQVJZKSBUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdO1xuICAgIHZhciBDT1JSRUNUX0lURVJfTkFNRSA9ICEhJG5hdGl2ZUl0ZXJhdG9yXG4gICAgICAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcbiAgICB2YXIgJGl0ZXJhdG9yID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgaGlkZShUeXBlZEFycmF5LCBUWVBFRF9DT05TVFJVQ1RPUiwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBUWVBFRF9BUlJBWSwgTkFNRSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIERFRl9DT05TVFJVQ1RPUiwgVHlwZWRBcnJheSk7XG5cbiAgICBpZiAoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSB7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFU1xuICAgIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IEJhc2Uub2YuY2FsbChUeXBlZEFycmF5LCAxKTsgfSksIE5BTUUsIHtcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QLCBOQU1FLCBwcm90byk7XG5cbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRURfU0VULCBOQU1FLCB7IHNldDogJHNldCB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgIGlmICghTElCUkFSWSAmJiBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgPSBhcnJheVRvU3RyaW5nO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7IHNsaWNlOiAkc2xpY2UgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHsgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZyB9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmICghTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCEnO1xudmFyICRBcnJheUJ1ZmZlciA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdO1xudmFyICREYXRhVmlldyA9IGdsb2JhbFtEQVRBX1ZJRVddO1xudmFyIE1hdGggPSBnbG9iYWwuTWF0aDtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXNcbnZhciBJbmZpbml0eSA9IGdsb2JhbC5JbmZpbml0eTtcbnZhciBCYXNlQnVmZmVyID0gJEFycmF5QnVmZmVyO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcbnZhciBCVUZGRVIgPSAnYnVmZmVyJztcbnZhciBCWVRFX0xFTkdUSCA9ICdieXRlTGVuZ3RoJztcbnZhciBCWVRFX09GRlNFVCA9ICdieXRlT2Zmc2V0JztcbnZhciAkQlVGRkVSID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSO1xudmFyICRMRU5HVEggPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSDtcbnZhciAkT0ZGU0VUID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG5mdW5jdGlvbiBwYWNrSUVFRTc1NCh2YWx1ZSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobkJ5dGVzKTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICB2YXIgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmICh2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiB1bnBhY2tJRUVFNzU0KGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBlTGVuIC0gNztcbiAgdmFyIGkgPSBuQnl0ZXMgLSAxO1xuICB2YXIgcyA9IGJ1ZmZlcltpLS1dO1xuICB2YXIgZSA9IHMgJiAxMjc7XG4gIHZhciBtO1xuICBzID4+PSA3O1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrSTMyKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufVxuZnVuY3Rpb24gcGFja0k4KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMTYoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMzIoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrRjY0KGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufVxuZnVuY3Rpb24gcGFja0YzMihpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn1cblxuZnVuY3Rpb24gYWRkR2V0dGVyKEMsIGtleSwgaW50ZXJuYWwpIHtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykgc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59XG5cbmlmICghJHR5cGVkLkFCVikge1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgobGVuZ3RoKTtcbiAgICB0aGlzLl9iID0gYXJyYXlGaWxsLmNhbGwobmV3IEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBidWZmZXJbJExFTkdUSF07XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyLCA4KTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAkQXJyYXlCdWZmZXIoMSk7XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gJEFycmF5QnVmZmVyLm5hbWUgIT0gQVJSQVlfQlVGRkVSO1xuICB9KSkge1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHRvSW5kZXgobGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSBoaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH1cbiAgICBpZiAoIUxJQlJBUlkpIEFycmF5QnVmZmVyUHJvdG8uY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKTtcbiAgdmFyICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSkgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFRZUEVEID0gdWlkKCd0eXBlZF9hcnJheScpO1xudmFyIFZJRVcgPSB1aWQoJ3ZpZXcnKTtcbnZhciBBQlYgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KTtcbnZhciBDT05TVFIgPSBBQlY7XG52YXIgaSA9IDA7XG52YXIgbCA9IDk7XG52YXIgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlIChpIDwgbCkge1xuICBpZiAoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSkge1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6IEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiBUWVBFRCxcbiAgVklFVzogVklFV1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZmlsdGVyLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNyAvIDE1LjQuNC4yMCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIFNUUklDVCA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyICRuYXRpdmUgPSBbXS5pbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7IGlzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5JykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkbWFwID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ubWFwLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTtcbiIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywgeyBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9IH0pO1xuIiwidmFyIERhdGVQcm90byA9IERhdGUucHJvdG90eXBlO1xudmFyIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRGF0ZVByb3RvW1RPX1NUUklOR107XG52YXIgZ2V0VGltZSA9IERhdGVQcm90by5nZXRUaW1lO1xuaWYgKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcbiIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjggfHwgJyc7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuICAgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG4gICAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuICAgICAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBCYXNlID0gJFJlZ0V4cDtcbnZhciBwcm90byA9ICRSZWdFeHAucHJvdG90eXBlO1xudmFyIHJlMSA9IC9hL2c7XG52YXIgcmUyID0gL2EvZztcbi8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxudmFyIENPUlJFQ1RfTkVXID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7XG4gIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKSB7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZikge1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHA7XG4gICAgdmFyIHBpUkUgPSBpc1JlZ0V4cChwKTtcbiAgICB2YXIgZmlVID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcFxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZilcbiAgICAgICAgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZilcbiAgICAgICwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoaXQpIHsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7KSBwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xucmVxdWlyZSgnLi9fZXhwb3J0Jykoe1xuICB0YXJnZXQ6ICdSZWdFeHAnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiByZWdleHBFeGVjICE9PSAvLi8uZXhlY1xufSwge1xuICBleGVjOiByZWdleHBFeGVjXG59KTtcbiIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgICBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQG1hdGNoXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkbWF0Y2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoIXJ4Lmdsb2JhbCkgcmV0dXJuIHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUykpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBBW25dID0gbWF0Y2hTdHI7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuID09PSAwID8gbnVsbCA6IEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJmAnXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJmAnXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG5cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgIHZhciBjYXB0dXJlO1xuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBjaDtcbiAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gY2g7XG4gICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgIH0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgc2FtZVZhbHVlID0gcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG4vLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc2VhcmNoXG4gICAgZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc2VhcmNoXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkc2VhcmNoLCByZWdleHAsIHRoaXMpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIHByZXZpb3VzTGFzdEluZGV4ID0gcngubGFzdEluZGV4O1xuICAgICAgaWYgKCFzYW1lVmFsdWUocHJldmlvdXNMYXN0SW5kZXgsIDApKSByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgaWYgKCFzYW1lVmFsdWUocngubGFzdEluZGV4LCBwcmV2aW91c0xhc3RJbmRleCkpIHJ4Lmxhc3RJbmRleCA9IHByZXZpb3VzTGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IC0xIDogcmVzdWx0LmluZGV4O1xuICAgIH1cbiAgXTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY2FsbFJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xudmFyICRtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgJFNQTElUID0gJ3NwbGl0JztcbnZhciBMRU5HVEggPSAnbGVuZ3RoJztcbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxudmFyIFNVUFBPUlRTX1kgPSAhIShmdW5jdGlvbiAoKSB7IHRyeSB7IHJldHVybiBuZXcgUmVnRXhwKCd4JywgJ3knKTsgfSBjYXRjaCAoZSkge30gfSkoKTtcblxuLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG4gIGlmIChcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gJHNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogJHNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gJHNwbGl0O1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzcGxpdHRlci5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpXG4gICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09ICRzcGxpdCk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyeC51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKFNVUFBPUlRTX1kgPyAneScgOiAnZycpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoU1VQUE9SVFNfWSA/IHJ4IDogJ14oPzonICsgcnguc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDB4ZmZmZmZmZmYgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gU1VQUE9SVFNfWSA/IHEgOiAwO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTVVBQT1JUU19ZID8gUyA6IFMuc2xpY2UocSkpO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAoZSA9ICRtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmIChyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLkpTRW5jcnlwdCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgQklfUk0gPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuZnVuY3Rpb24gaW50MmNoYXIobikge1xuICAgIHJldHVybiBCSV9STS5jaGFyQXQobik7XG59XG4vLyNyZWdpb24gQklUX09QRVJBVElPTlNcbi8vIChwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCwgeSkge1xuICAgIHJldHVybiB4ICYgeTtcbn1cbi8vIChwdWJsaWMpIHRoaXMgfCBhXG5mdW5jdGlvbiBvcF9vcih4LCB5KSB7XG4gICAgcmV0dXJuIHggfCB5O1xufVxuLy8gKHB1YmxpYykgdGhpcyBeIGFcbmZ1bmN0aW9uIG9wX3hvcih4LCB5KSB7XG4gICAgcmV0dXJuIHggXiB5O1xufVxuLy8gKHB1YmxpYykgdGhpcyAmIH5hXG5mdW5jdGlvbiBvcF9hbmRub3QoeCwgeSkge1xuICAgIHJldHVybiB4ICYgfnk7XG59XG4vLyByZXR1cm4gaW5kZXggb2YgbG93ZXN0IDEtYml0IGluIHgsIHggPCAyXjMxXG5mdW5jdGlvbiBsYml0KHgpIHtcbiAgICBpZiAoeCA9PSAwKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgoeCAmIDB4ZmZmZikgPT0gMCkge1xuICAgICAgICB4ID4+PSAxNjtcbiAgICAgICAgciArPSAxNjtcbiAgICB9XG4gICAgaWYgKCh4ICYgMHhmZikgPT0gMCkge1xuICAgICAgICB4ID4+PSA4O1xuICAgICAgICByICs9IDg7XG4gICAgfVxuICAgIGlmICgoeCAmIDB4ZikgPT0gMCkge1xuICAgICAgICB4ID4+PSA0O1xuICAgICAgICByICs9IDQ7XG4gICAgfVxuICAgIGlmICgoeCAmIDMpID09IDApIHtcbiAgICAgICAgeCA+Pj0gMjtcbiAgICAgICAgciArPSAyO1xuICAgIH1cbiAgICBpZiAoKHggJiAxKSA9PSAwKSB7XG4gICAgICAgICsrcjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG4vLyByZXR1cm4gbnVtYmVyIG9mIDEgYml0cyBpbiB4XG5mdW5jdGlvbiBjYml0KHgpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgd2hpbGUgKHggIT0gMCkge1xuICAgICAgICB4ICY9IHggLSAxO1xuICAgICAgICArK3I7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuLy8jZW5kcmVnaW9uIEJJVF9PUEVSQVRJT05TXG5cbnZhciBiNjRtYXAgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBiNjRwYWQgPSBcIj1cIjtcbmZ1bmN0aW9uIGhleDJiNjQoaCkge1xuICAgIHZhciBpO1xuICAgIHZhciBjO1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIGZvciAoaSA9IDA7IGkgKyAzIDw9IGgubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgYyA9IHBhcnNlSW50KGguc3Vic3RyaW5nKGksIGkgKyAzKSwgMTYpO1xuICAgICAgICByZXQgKz0gYjY0bWFwLmNoYXJBdChjID4+IDYpICsgYjY0bWFwLmNoYXJBdChjICYgNjMpO1xuICAgIH1cbiAgICBpZiAoaSArIDEgPT0gaC5sZW5ndGgpIHtcbiAgICAgICAgYyA9IHBhcnNlSW50KGguc3Vic3RyaW5nKGksIGkgKyAxKSwgMTYpO1xuICAgICAgICByZXQgKz0gYjY0bWFwLmNoYXJBdChjIDw8IDIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpICsgMiA9PSBoLmxlbmd0aCkge1xuICAgICAgICBjID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XG4gICAgICAgIHJldCArPSBiNjRtYXAuY2hhckF0KGMgPj4gMikgKyBiNjRtYXAuY2hhckF0KChjICYgMykgPDwgNCk7XG4gICAgfVxuICAgIHdoaWxlICgocmV0Lmxlbmd0aCAmIDMpID4gMCkge1xuICAgICAgICByZXQgKz0gYjY0cGFkO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8gY29udmVydCBhIGJhc2U2NCBzdHJpbmcgdG8gaGV4XG5mdW5jdGlvbiBiNjR0b2hleChzKSB7XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgdmFyIGk7XG4gICAgdmFyIGsgPSAwOyAvLyBiNjQgc3RhdGUsIDAtM1xuICAgIHZhciBzbG9wID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gYjY0cGFkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdiA9IGI2NG1hcC5pbmRleE9mKHMuY2hhckF0KGkpKTtcbiAgICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoayA9PSAwKSB7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIodiA+PiAyKTtcbiAgICAgICAgICAgIHNsb3AgPSB2ICYgMztcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGsgPT0gMSkge1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKChzbG9wIDw8IDIpIHwgKHYgPj4gNCkpO1xuICAgICAgICAgICAgc2xvcCA9IHYgJiAweGY7XG4gICAgICAgICAgICBrID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrID09IDIpIHtcbiAgICAgICAgICAgIHJldCArPSBpbnQyY2hhcihzbG9wKTtcbiAgICAgICAgICAgIHJldCArPSBpbnQyY2hhcih2ID4+IDIpO1xuICAgICAgICAgICAgc2xvcCA9IHYgJiAzO1xuICAgICAgICAgICAgayA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIoKHNsb3AgPDwgMikgfCAodiA+PiA0KSk7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIodiAmIDB4Zik7XG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoayA9PSAxKSB7XG4gICAgICAgIHJldCArPSBpbnQyY2hhcihzbG9wIDw8IDIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XG5cbi8vIEhleCBKYXZhU2NyaXB0IGRlY29kZXJcbi8vIENvcHlyaWdodCAoYykgMjAwOC0yMDEzIExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0PlxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4vLyBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXG52YXIgZGVjb2RlcjtcbnZhciBIZXggPSB7XG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGRlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGhleCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiO1xuICAgICAgICAgICAgdmFyIGlnbm9yZSA9IFwiIFxcZlxcblxcclxcdFxcdTAwQTBcXHUyMDI4XFx1MjAyOVwiO1xuICAgICAgICAgICAgZGVjb2RlciA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyW2hleC5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhleCA9IGhleC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChpID0gMTA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcltoZXguY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaWdub3JlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcltpZ25vcmUuY2hhckF0KGkpXSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgdmFyIGJpdHMgPSAwO1xuICAgICAgICB2YXIgY2hhcl9jb3VudCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGEuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSBkZWNvZGVyW2NdO1xuICAgICAgICAgICAgaWYgKGMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGNoYXJhY3RlciBhdCBvZmZzZXQgXCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgfD0gYztcbiAgICAgICAgICAgIGlmICgrK2NoYXJfY291bnQgPj0gMikge1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICAgICAgY2hhcl9jb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaXRzIDw8PSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyX2NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZXggZW5jb2RpbmcgaW5jb21wbGV0ZTogNCBiaXRzIG1pc3NpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59O1xuXG4vLyBCYXNlNjQgSmF2YVNjcmlwdCBkZWNvZGVyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxMyBMYXBvIEx1Y2hpbmkgPGxhcG9AbGFwby5pdD5cbi8vIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuLy8gcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuLy8gV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcbi8vIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbi8vIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcbi8vIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIGltbWVkOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCB1bmRlZjogdHJ1ZSwgcmVnZXhkYXNoOiBmYWxzZSAqL1xudmFyIGRlY29kZXIkMTtcbnZhciBCYXNlNjQgPSB7XG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGRlY29kZXIkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gICAgICAgICAgICB2YXIgaWdub3JlID0gXCI9IFxcZlxcblxcclxcdFxcdTAwQTBcXHUyMDI4XFx1MjAyOVwiO1xuICAgICAgICAgICAgZGVjb2RlciQxID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlciQxW2I2NC5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpZ25vcmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyJDFbaWdub3JlLmNoYXJBdChpKV0gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBiaXRzID0gMDtcbiAgICAgICAgdmFyIGNoYXJfY291bnQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSBhLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gZGVjb2RlciQxW2NdO1xuICAgICAgICAgICAgaWYgKGMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGNoYXJhY3RlciBhdCBvZmZzZXQgXCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgfD0gYztcbiAgICAgICAgICAgIGlmICgrK2NoYXJfY291bnQgPj0gNCkge1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDE2KTtcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gYml0cyAmIDB4RkY7XG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICAgICAgY2hhcl9jb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaXRzIDw8PSA2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY2hhcl9jb3VudCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NCBlbmNvZGluZyBpbmNvbXBsZXRlOiBhdCBsZWFzdCAyIGJpdHMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiAxMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gKGJpdHMgPj4gMTYpO1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG4gICAgcmU6IC8tLS0tLUJFR0lOIFteLV0rLS0tLS0oW0EtWmEtejAtOStcXC89XFxzXSspLS0tLS1FTkQgW14tXSstLS0tLXxiZWdpbi1iYXNlNjRbXlxcbl0rXFxuKFtBLVphLXowLTkrXFwvPVxcc10rKT09PT0vLFxuICAgIHVuYXJtb3I6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBtID0gQmFzZTY0LnJlLmV4ZWMoYSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBpZiAobVsxXSkge1xuICAgICAgICAgICAgICAgIGEgPSBtWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobVsyXSkge1xuICAgICAgICAgICAgICAgIGEgPSBtWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnRXhwIG91dCBvZiBzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYXNlNjQuZGVjb2RlKGEpO1xuICAgIH1cbn07XG5cbi8vIEJpZyBpbnRlZ2VyIGJhc2UtMTAgcHJpbnRpbmcgbGlicmFyeVxuLy8gQ29weXJpZ2h0IChjKSAyMDE0IExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0PlxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4vLyBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXG52YXIgbWF4ID0gMTAwMDAwMDAwMDAwMDA7IC8vIGJpZ2dlc3QgaW50ZWdlciB0aGF0IGNhbiBzdGlsbCBmaXQgMl41MyB3aGVuIG11bHRpcGxpZWQgYnkgMjU2XG52YXIgSW50MTAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50MTAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWYgPSBbK3ZhbHVlIHx8IDBdO1xuICAgIH1cbiAgICBJbnQxMC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gKG0sIGMpIHtcbiAgICAgICAgLy8gYXNzZXJ0KG0gPD0gMjU2KVxuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xuICAgICAgICB2YXIgbCA9IGIubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHQgPSBiW2ldICogbSArIGM7XG4gICAgICAgICAgICBpZiAodCA8IG1heCkge1xuICAgICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYyA9IDAgfCAodCAvIG1heCk7XG4gICAgICAgICAgICAgICAgdCAtPSBjICogbWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYltpXSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPiAwKSB7XG4gICAgICAgICAgICBiW2ldID0gYztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW50MTAucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIGFzc2VydChtIDw9IDI1NilcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgdmFyIGwgPSBiLmxlbmd0aDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICB0ID0gYltpXSAtIGM7XG4gICAgICAgICAgICBpZiAodCA8IDApIHtcbiAgICAgICAgICAgICAgICB0ICs9IG1heDtcbiAgICAgICAgICAgICAgICBjID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYltpXSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGJbYi5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICAgICAgYi5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW50MTAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgaWYgKChiYXNlIHx8IDEwKSAhPSAxMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25seSBiYXNlIDEwIGlzIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xuICAgICAgICB2YXIgcyA9IGJbYi5sZW5ndGggLSAxXS50b1N0cmluZygpO1xuICAgICAgICBmb3IgKHZhciBpID0gYi5sZW5ndGggLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcyArPSAobWF4ICsgYltpXSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBJbnQxMC5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgdmFyIHYgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gYi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdiA9IHYgKiBtYXggKyBiW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgSW50MTAucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xuICAgICAgICByZXR1cm4gKGIubGVuZ3RoID09IDEpID8gYlswXSA6IHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gSW50MTA7XG59KCkpO1xuXG4vLyBBU04uMSBKYXZhU2NyaXB0IGRlY29kZXJcbnZhciBlbGxpcHNpcyA9IFwiXFx1MjAyNlwiO1xudmFyIHJlVGltZVMgPSAvXihcXGRcXGQpKDBbMS05XXwxWzAtMl0pKDBbMS05XXxbMTJdXFxkfDNbMDFdKShbMDFdXFxkfDJbMC0zXSkoPzooWzAtNV1cXGQpKD86KFswLTVdXFxkKSg/OlsuLF0oXFxkezEsM30pKT8pPyk/KFp8Wy0rXSg/OlswXVxcZHwxWzAtMl0pKFswLTVdXFxkKT8pPyQvO1xudmFyIHJlVGltZUwgPSAvXihcXGRcXGRcXGRcXGQpKDBbMS05XXwxWzAtMl0pKDBbMS05XXxbMTJdXFxkfDNbMDFdKShbMDFdXFxkfDJbMC0zXSkoPzooWzAtNV1cXGQpKD86KFswLTVdXFxkKSg/OlsuLF0oXFxkezEsM30pKT8pPyk/KFp8Wy0rXSg/OlswXVxcZHwxWzAtMl0pKFswLTVdXFxkKT8pPyQvO1xuZnVuY3Rpb24gc3RyaW5nQ3V0KHN0ciwgbGVuKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPiBsZW4pIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBsZW4pICsgZWxsaXBzaXM7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG52YXIgU3RyZWFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmVhbShlbmMsIHBvcykge1xuICAgICAgICB0aGlzLmhleERpZ2l0cyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiO1xuICAgICAgICBpZiAoZW5jIGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLmVuYyA9IGVuYy5lbmM7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGVuYy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmMgc2hvdWxkIGJlIGFuIGFycmF5IG9yIGEgYmluYXJ5IHN0cmluZ1xuICAgICAgICAgICAgdGhpcy5lbmMgPSBlbmM7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdHJlYW0ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy5lbmMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0aW5nIGJ5dGUgb2Zmc2V0IFwiICsgcG9zICsgXCIgb24gYSBzdHJlYW0gb2YgbGVuZ3RoIFwiICsgdGhpcy5lbmMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGlzLmVuYykgPyB0aGlzLmVuYy5jaGFyQ29kZUF0KHBvcykgOiB0aGlzLmVuY1twb3NdO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5oZXhCeXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGV4RGlnaXRzLmNoYXJBdCgoYiA+PiA0KSAmIDB4RikgKyB0aGlzLmhleERpZ2l0cy5jaGFyQXQoYiAmIDB4Rik7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLmhleER1bXAgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcmF3KSB7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHMgKz0gdGhpcy5oZXhCeXRlKHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgICAgIGlmIChyYXcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGkgJiAweEYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IFwiICBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4RjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBcIiBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLmlzQVNDSUkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldChpKTtcbiAgICAgICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDE3Nikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VTdHJpbmdJU08gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVN0cmluZ1VURiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOykge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldChpKyspO1xuICAgICAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoYyA+IDE5MSkgJiYgKGMgPCAyMjQpKSB7XG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MUYpIDw8IDYpIHwgKHRoaXMuZ2V0KGkrKykgJiAweDNGKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgwRikgPDwgMTIpIHwgKCh0aGlzLmdldChpKyspICYgMHgzRikgPDwgNikgfCAodGhpcy5nZXQoaSsrKSAmIDB4M0YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VTdHJpbmdCTVAgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgdmFyIGhpO1xuICAgICAgICB2YXIgbG87XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDspIHtcbiAgICAgICAgICAgIGhpID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgICAgIGxvID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChoaSA8PCA4KSB8IGxvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVRpbWUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc2hvcnRZZWFyKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5wYXJzZVN0cmluZ0lTTyhzdGFydCwgZW5kKTtcbiAgICAgICAgdmFyIG0gPSAoc2hvcnRZZWFyID8gcmVUaW1lUyA6IHJlVGltZUwpLmV4ZWMocyk7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVW5yZWNvZ25pemVkIHRpbWU6IFwiICsgcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvcnRZZWFyKSB7XG4gICAgICAgICAgICAvLyB0byBhdm9pZCBxdWVyeWluZyB0aGUgdGltZXIsIHVzZSB0aGUgZml4ZWQgcmFuZ2UgWzE5NzAsIDIwNjldXG4gICAgICAgICAgICAvLyBpdCB3aWxsIGNvbmZvcm0gd2l0aCBJVFUgWC40MDAgWy0xMCwgKzQwXSBzbGlkaW5nIHdpbmRvdyB1bnRpbCAyMDMwXG4gICAgICAgICAgICBtWzFdID0gK21bMV07XG4gICAgICAgICAgICBtWzFdICs9ICgrbVsxXSA8IDcwKSA/IDIwMDAgOiAxOTAwO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBtWzFdICsgXCItXCIgKyBtWzJdICsgXCItXCIgKyBtWzNdICsgXCIgXCIgKyBtWzRdO1xuICAgICAgICBpZiAobVs1XSkge1xuICAgICAgICAgICAgcyArPSBcIjpcIiArIG1bNV07XG4gICAgICAgICAgICBpZiAobVs2XSkge1xuICAgICAgICAgICAgICAgIHMgKz0gXCI6XCIgKyBtWzZdO1xuICAgICAgICAgICAgICAgIGlmIChtWzddKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXCIuXCIgKyBtWzddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobVs4XSkge1xuICAgICAgICAgICAgcyArPSBcIiBVVENcIjtcbiAgICAgICAgICAgIGlmIChtWzhdICE9IFwiWlwiKSB7XG4gICAgICAgICAgICAgICAgcyArPSBtWzhdO1xuICAgICAgICAgICAgICAgIGlmIChtWzldKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXCI6XCIgKyBtWzldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VJbnRlZ2VyID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldChzdGFydCk7XG4gICAgICAgIHZhciBuZWcgPSAodiA+IDEyNyk7XG4gICAgICAgIHZhciBwYWQgPSBuZWcgPyAyNTUgOiAwO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIC8vIHNraXAgdW51c2VmdWwgYml0cyAobm90IGFsbG93ZWQgaW4gREVSKVxuICAgICAgICB3aGlsZSAodiA9PSBwYWQgJiYgKytzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5lZyA/IC0xIDogMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG93IGJpdCBsZW5ndGggb2YgaHVnZSBpbnRlZ2Vyc1xuICAgICAgICBpZiAobGVuID4gNCkge1xuICAgICAgICAgICAgcyA9IHY7XG4gICAgICAgICAgICBsZW4gPDw9IDM7XG4gICAgICAgICAgICB3aGlsZSAoKCgrcyBeIHBhZCkgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcyA9ICtzIDw8IDE7XG4gICAgICAgICAgICAgICAgLS1sZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gXCIoXCIgKyBsZW4gKyBcIiBiaXQpXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVjb2RlIHRoZSBpbnRlZ2VyXG4gICAgICAgIGlmIChuZWcpIHtcbiAgICAgICAgICAgIHYgPSB2IC0gMjU2O1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gbmV3IEludDEwKHYpO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQgKyAxOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIG4ubXVsQWRkKDI1NiwgdGhpcy5nZXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzICsgbi50b1N0cmluZygpO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZUJpdFN0cmluZyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHVudXNlZEJpdCA9IHRoaXMuZ2V0KHN0YXJ0KTtcbiAgICAgICAgdmFyIGxlbkJpdCA9ICgoZW5kIC0gc3RhcnQgLSAxKSA8PCAzKSAtIHVudXNlZEJpdDtcbiAgICAgICAgdmFyIGludHJvID0gXCIoXCIgKyBsZW5CaXQgKyBcIiBiaXQpXFxuXCI7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0KGkpO1xuICAgICAgICAgICAgdmFyIHNraXAgPSAoaSA9PSBlbmQgLSAxKSA/IHVudXNlZEJpdCA6IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gNzsgaiA+PSBza2lwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBzICs9IChiID4+IGopICYgMSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50cm8gKyBzdHJpbmdDdXQocywgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50cm8gKyBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZU9jdGV0U3RyaW5nID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG1heExlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5pc0FTQ0lJKHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHRoaXMucGFyc2VTdHJpbmdJU08oc3RhcnQsIGVuZCksIG1heExlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICB2YXIgcyA9IFwiKFwiICsgbGVuICsgXCIgYnl0ZSlcXG5cIjtcbiAgICAgICAgbWF4TGVuZ3RoIC89IDI7IC8vIHdlIHdvcmsgaW4gYnl0ZXNcbiAgICAgICAgaWYgKGxlbiA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBtYXhMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHMgKz0gdGhpcy5oZXhCeXRlKHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBzICs9IGVsbGlwc2lzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZU9JRCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xuICAgICAgICB2YXIgbiA9IG5ldyBJbnQxMCgpO1xuICAgICAgICB2YXIgYml0cyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0KGkpO1xuICAgICAgICAgICAgbi5tdWxBZGQoMTI4LCB2ICYgMHg3Rik7XG4gICAgICAgICAgICBiaXRzICs9IDc7XG4gICAgICAgICAgICBpZiAoISh2ICYgMHg4MCkpIHsgLy8gZmluaXNoZWRcbiAgICAgICAgICAgICAgICBpZiAocyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5zaW1wbGlmeSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEludDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnN1Yig4MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gXCIyLlwiICsgbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBuIDwgODAgPyBuIDwgNDAgPyAwIDogMSA6IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbSArIFwiLlwiICsgKG4gLSBtICogNDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzICs9IFwiLlwiICsgbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dChzLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuID0gbmV3IEludDEwKCk7XG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICBzICs9IFwiLmluY29tcGxldGVcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIHJldHVybiBTdHJlYW07XG59KCkpO1xudmFyIEFTTjEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQVNOMShzdHJlYW0sIGhlYWRlciwgbGVuZ3RoLCB0YWcsIHN1Yikge1xuICAgICAgICBpZiAoISh0YWcgaW5zdGFuY2VvZiBBU04xVGFnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YWcgdmFsdWUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YjtcbiAgICB9XG4gICAgQVNOMS5wcm90b3R5cGUudHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50YWcudGFnQ2xhc3MpIHtcbiAgICAgICAgICAgIGNhc2UgMDogLy8gdW5pdmVyc2FsXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRhZy50YWdOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRU9DXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJPT0xFQU5cIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSU5URUdFUlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJCSVRfU1RSSU5HXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk9DVEVUX1NUUklOR1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJOVUxMXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk9CSkVDVF9JREVOVElGSUVSXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk9iamVjdERlc2NyaXB0b3JcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRVhURVJOQUxcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUkVBTFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MEE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFTlVNRVJBVEVEXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwQjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVNQkVEREVEX1BEVlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MEM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJVVEY4U3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlNFUVVFTkNFXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlNFVFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJOdW1lcmljU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlByaW50YWJsZVN0cmluZ1wiOyAvLyBBU0NJSSBzdWJzZXRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVGVsZXRleFN0cmluZ1wiOyAvLyBha2EgVDYxU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlZpZGVvdGV4U3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIklBNVN0cmluZ1wiOyAvLyBBU0NJSVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJVVENUaW1lXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdlbmVyYWxpemVkVGltZVwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJHcmFwaGljU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlZpc2libGVTdHJpbmdcIjsgLy8gQVNDSUkgc3Vic2V0XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxQjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdlbmVyYWxTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDFDOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVW5pdmVyc2FsU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJNUFN0cmluZ1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJVbml2ZXJzYWxfXCIgKyB0aGlzLnRhZy50YWdOdW1iZXIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJBcHBsaWNhdGlvbl9cIiArIHRoaXMudGFnLnRhZ051bWJlci50b1N0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIltcIiArIHRoaXMudGFnLnRhZ051bWJlci50b1N0cmluZygpICsgXCJdXCI7IC8vIENvbnRleHRcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJQcml2YXRlX1wiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAobWF4TGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4TGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5wb3NDb250ZW50KCk7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLmFicyh0aGlzLmxlbmd0aCk7XG4gICAgICAgIGlmICghdGhpcy50YWcuaXNVbml2ZXJzYWwoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgdGhpcy5zdWIubGVuZ3RoICsgXCIgZWxlbSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wYXJzZU9jdGV0U3RyaW5nKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sIG1heExlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnRhZy50YWdOdW1iZXIpIHtcbiAgICAgICAgICAgIGNhc2UgMHgwMTogLy8gQk9PTEVBTlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5zdHJlYW0uZ2V0KGNvbnRlbnQpID09PSAwKSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiO1xuICAgICAgICAgICAgY2FzZSAweDAyOiAvLyBJTlRFR0VSXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBhcnNlSW50ZWdlcihjb250ZW50LCBjb250ZW50ICsgbGVuKTtcbiAgICAgICAgICAgIGNhc2UgMHgwMzogLy8gQklUX1NUUklOR1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YiA/IFwiKFwiICsgdGhpcy5zdWIubGVuZ3RoICsgXCIgZWxlbSlcIiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhcnNlQml0U3RyaW5nKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sIG1heExlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4MDQ6IC8vIE9DVEVUX1NUUklOR1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YiA/IFwiKFwiICsgdGhpcy5zdWIubGVuZ3RoICsgXCIgZWxlbSlcIiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhcnNlT2N0ZXRTdHJpbmcoY29udGVudCwgY29udGVudCArIGxlbiwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwNTogLy8gTlVMTFxuICAgICAgICAgICAgY2FzZSAweDA2OiAvLyBPQkpFQ1RfSURFTlRJRklFUlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wYXJzZU9JRChjb250ZW50LCBjb250ZW50ICsgbGVuLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgLy8gY2FzZSAweDA3OiAvLyBPYmplY3REZXNjcmlwdG9yXG4gICAgICAgICAgICAvLyBjYXNlIDB4MDg6IC8vIEVYVEVSTkFMXG4gICAgICAgICAgICAvLyBjYXNlIDB4MDk6IC8vIFJFQUxcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwQTogLy8gRU5VTUVSQVRFRFxuICAgICAgICAgICAgLy8gY2FzZSAweDBCOiAvLyBFTUJFRERFRF9QRFZcbiAgICAgICAgICAgIGNhc2UgMHgxMDogLy8gU0VRVUVOQ0VcbiAgICAgICAgICAgIGNhc2UgMHgxMTogLy8gU0VUXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIHRoaXMuc3ViLmxlbmd0aCArIFwiIGVsZW0pXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIobm8gZWxlbSlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDB4MEM6IC8vIFVURjhTdHJpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHRoaXMuc3RyZWFtLnBhcnNlU3RyaW5nVVRGKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4pLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgY2FzZSAweDEyOiAvLyBOdW1lcmljU3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MTM6IC8vIFByaW50YWJsZVN0cmluZ1xuICAgICAgICAgICAgY2FzZSAweDE0OiAvLyBUZWxldGV4U3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MTU6IC8vIFZpZGVvdGV4U3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MTY6IC8vIElBNVN0cmluZ1xuICAgICAgICAgICAgLy8gY2FzZSAweDE5OiAvLyBHcmFwaGljU3RyaW5nXG4gICAgICAgICAgICBjYXNlIDB4MUE6IC8vIFZpc2libGVTdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDB4MUI6IC8vIEdlbmVyYWxTdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDB4MUM6IC8vIFVuaXZlcnNhbFN0cmluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQodGhpcy5zdHJlYW0ucGFyc2VTdHJpbmdJU08oY29udGVudCwgY29udGVudCArIGxlbiksIG1heExlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4MUU6IC8vIEJNUFN0cmluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQodGhpcy5zdHJlYW0ucGFyc2VTdHJpbmdCTVAoY29udGVudCwgY29udGVudCArIGxlbiksIG1heExlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4MTc6IC8vIFVUQ1RpbWVcbiAgICAgICAgICAgIGNhc2UgMHgxODogLy8gR2VuZXJhbGl6ZWRUaW1lXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBhcnNlVGltZShjb250ZW50LCBjb250ZW50ICsgbGVuLCAodGhpcy50YWcudGFnTnVtYmVyID09IDB4MTcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlTmFtZSgpICsgXCJAXCIgKyB0aGlzLnN0cmVhbS5wb3MgKyBcIltoZWFkZXI6XCIgKyB0aGlzLmhlYWRlciArIFwiLGxlbmd0aDpcIiArIHRoaXMubGVuZ3RoICsgXCIsc3ViOlwiICsgKCh0aGlzLnN1YiA9PT0gbnVsbCkgPyBcIm51bGxcIiA6IHRoaXMuc3ViLmxlbmd0aCkgKyBcIl1cIjtcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnRvUHJldHR5U3RyaW5nID0gZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICBpZiAoaW5kZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluZGVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBpbmRlbnQgKyB0aGlzLnR5cGVOYW1lKCkgKyBcIiBAXCIgKyB0aGlzLnN0cmVhbS5wb3M7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICBzICs9IFwiK1wiO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLnRhZy50YWdDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgcyArPSBcIiAoY29uc3RydWN0ZWQpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHRoaXMudGFnLmlzVW5pdmVyc2FsKCkgJiYgKCh0aGlzLnRhZy50YWdOdW1iZXIgPT0gMHgwMykgfHwgKHRoaXMudGFnLnRhZ051bWJlciA9PSAweDA0KSkpICYmICh0aGlzLnN1YiAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHMgKz0gXCIgKGVuY2Fwc3VsYXRlcylcIjtcbiAgICAgICAgfVxuICAgICAgICBzICs9IFwiXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLnN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5kZW50ICs9IFwiICBcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSB0aGlzLnN1Yi5sZW5ndGg7IGkgPCBtYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIHMgKz0gdGhpcy5zdWJbaV0udG9QcmV0dHlTdHJpbmcoaW5kZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnBvc1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9zO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUucG9zQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBvcyArIHRoaXMuaGVhZGVyO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUucG9zRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9zICsgdGhpcy5oZWFkZXIgKyBNYXRoLmFicyh0aGlzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS50b0hleFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLmhleER1bXAodGhpcy5wb3NTdGFydCgpLCB0aGlzLnBvc0VuZCgpLCB0cnVlKTtcbiAgICB9O1xuICAgIEFTTjEuZGVjb2RlTGVuZ3RoID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICB2YXIgYnVmID0gc3RyZWFtLmdldCgpO1xuICAgICAgICB2YXIgbGVuID0gYnVmICYgMHg3RjtcbiAgICAgICAgaWYgKGxlbiA9PSBidWYpIHtcbiAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gcmVhc29uIHRvIHVzZSBJbnQxMCwgYXMgaXQgd291bGQgYmUgYSBodWdlIGJ1ZmZlciBhbnl3YXlzXG4gICAgICAgIGlmIChsZW4gPiA2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb3ZlciA0OCBiaXRzIG5vdCBzdXBwb3J0ZWQgYXQgcG9zaXRpb24gXCIgKyAoc3RyZWFtLnBvcyAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAvLyB1bmRlZmluZWRcbiAgICAgICAgYnVmID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgYnVmID0gKGJ1ZiAqIDI1NikgKyBzdHJlYW0uZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBoZXhhZGVjaW1hbCB2YWx1ZSAoYXMgYSBzdHJpbmcpIG9mIHRoZSBjdXJyZW50IEFTTi4xIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBBU04xLnByb3RvdHlwZS5nZXRIZXhTdHJpbmdWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhleFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuaGVhZGVyICogMjtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoICogMjtcbiAgICAgICAgcmV0dXJuIGhleFN0cmluZy5zdWJzdHIob2Zmc2V0LCBsZW5ndGgpO1xuICAgIH07XG4gICAgQVNOMS5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBzdHJlYW07XG4gICAgICAgIGlmICghKHN0ciBpbnN0YW5jZW9mIFN0cmVhbSkpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBTdHJlYW0oc3RyLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IHN0cjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZWFtU3RhcnQgPSBuZXcgU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIHZhciB0YWcgPSBuZXcgQVNOMVRhZyhzdHJlYW0pO1xuICAgICAgICB2YXIgbGVuID0gQVNOMS5kZWNvZGVMZW5ndGgoc3RyZWFtKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICAgICAgdmFyIGhlYWRlciA9IHN0YXJ0IC0gc3RyZWFtU3RhcnQucG9zO1xuICAgICAgICB2YXIgc3ViID0gbnVsbDtcbiAgICAgICAgdmFyIGdldFN1YiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIGlmIChsZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZpbml0ZSBsZW5ndGhcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBsZW47XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0cmVhbS5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W3JldC5sZW5ndGhdID0gQVNOMS5kZWNvZGUoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5wb3MgIT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRlbnQgc2l6ZSBpcyBub3QgY29ycmVjdCBmb3IgY29udGFpbmVyIHN0YXJ0aW5nIGF0IG9mZnNldCBcIiArIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgbGVuZ3RoXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBBU04xLmRlY29kZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMudGFnLmlzRU9DKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuID0gc3RhcnQgLSBzdHJlYW0ucG9zOyAvLyB1bmRlZmluZWQgbGVuZ3RocyBhcmUgcmVwcmVzZW50ZWQgYXMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4Y2VwdGlvbiB3aGlsZSBkZWNvZGluZyB1bmRlZmluZWQgbGVuZ3RoIGNvbnRlbnQ6IFwiICsgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRhZy50YWdDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgLy8gbXVzdCBoYXZlIHZhbGlkIGNvbnRlbnRcbiAgICAgICAgICAgIHN1YiA9IGdldFN1YigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZy5pc1VuaXZlcnNhbCgpICYmICgodGFnLnRhZ051bWJlciA9PSAweDAzKSB8fCAodGFnLnRhZ051bWJlciA9PSAweDA0KSkpIHtcbiAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBCaXRTdHJpbmcgYW5kIE9jdGV0U3RyaW5nIGFyZSB1c2VkIHRvIGVuY2Fwc3VsYXRlIEFTTi4xXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0YWcudGFnTnVtYmVyID09IDB4MDMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5nZXQoKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCSVQgU1RSSU5HcyB3aXRoIHVudXNlZCBiaXRzIGNhbm5vdCBlbmNhcHN1bGF0ZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViID0gZ2V0U3ViKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YltpXS50YWcuaXNFT0MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRU9DIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBhY3R1YWwgY29udGVudC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGJ1dCBzaWxlbnRseSBpZ25vcmUgd2hlbiB0aGV5IGRvbid0XG4gICAgICAgICAgICAgICAgc3ViID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGVuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2UgY2FuJ3Qgc2tpcCBvdmVyIGFuIGludmFsaWQgdGFnIHdpdGggdW5kZWZpbmVkIGxlbmd0aCBhdCBvZmZzZXQgXCIgKyBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0ucG9zID0gc3RhcnQgKyBNYXRoLmFicyhsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVNOMShzdHJlYW1TdGFydCwgaGVhZGVyLCBsZW4sIHRhZywgc3ViKTtcbiAgICB9O1xuICAgIHJldHVybiBBU04xO1xufSgpKTtcbnZhciBBU04xVGFnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFTTjFUYWcoc3RyZWFtKSB7XG4gICAgICAgIHZhciBidWYgPSBzdHJlYW0uZ2V0KCk7XG4gICAgICAgIHRoaXMudGFnQ2xhc3MgPSBidWYgPj4gNjtcbiAgICAgICAgdGhpcy50YWdDb25zdHJ1Y3RlZCA9ICgoYnVmICYgMHgyMCkgIT09IDApO1xuICAgICAgICB0aGlzLnRhZ051bWJlciA9IGJ1ZiAmIDB4MUY7XG4gICAgICAgIGlmICh0aGlzLnRhZ051bWJlciA9PSAweDFGKSB7IC8vIGxvbmcgdGFnXG4gICAgICAgICAgICB2YXIgbiA9IG5ldyBJbnQxMCgpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGJ1ZiA9IHN0cmVhbS5nZXQoKTtcbiAgICAgICAgICAgICAgICBuLm11bEFkZCgxMjgsIGJ1ZiAmIDB4N0YpO1xuICAgICAgICAgICAgfSB3aGlsZSAoYnVmICYgMHg4MCk7XG4gICAgICAgICAgICB0aGlzLnRhZ051bWJlciA9IG4uc2ltcGxpZnkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBU04xVGFnLnByb3RvdHlwZS5pc1VuaXZlcnNhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnQ2xhc3MgPT09IDB4MDA7XG4gICAgfTtcbiAgICBBU04xVGFnLnByb3RvdHlwZS5pc0VPQyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnQ2xhc3MgPT09IDB4MDAgJiYgdGhpcy50YWdOdW1iZXIgPT09IDB4MDA7XG4gICAgfTtcbiAgICByZXR1cm4gQVNOMVRhZztcbn0oKSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAwNSAgVG9tIFd1XG4vLyBCaXRzIHBlciBkaWdpdFxudmFyIGRiaXRzO1xuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkgJiAweGZmZmZmZikgPT0gMHhlZmNhZmUpO1xuLy8jcmVnaW9uXG52YXIgbG93cHJpbWVzID0gWzIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjksIDMxLCAzNywgNDEsIDQzLCA0NywgNTMsIDU5LCA2MSwgNjcsIDcxLCA3MywgNzksIDgzLCA4OSwgOTcsIDEwMSwgMTAzLCAxMDcsIDEwOSwgMTEzLCAxMjcsIDEzMSwgMTM3LCAxMzksIDE0OSwgMTUxLCAxNTcsIDE2MywgMTY3LCAxNzMsIDE3OSwgMTgxLCAxOTEsIDE5MywgMTk3LCAxOTksIDIxMSwgMjIzLCAyMjcsIDIyOSwgMjMzLCAyMzksIDI0MSwgMjUxLCAyNTcsIDI2MywgMjY5LCAyNzEsIDI3NywgMjgxLCAyODMsIDI5MywgMzA3LCAzMTEsIDMxMywgMzE3LCAzMzEsIDMzNywgMzQ3LCAzNDksIDM1MywgMzU5LCAzNjcsIDM3MywgMzc5LCAzODMsIDM4OSwgMzk3LCA0MDEsIDQwOSwgNDE5LCA0MjEsIDQzMSwgNDMzLCA0MzksIDQ0MywgNDQ5LCA0NTcsIDQ2MSwgNDYzLCA0NjcsIDQ3OSwgNDg3LCA0OTEsIDQ5OSwgNTAzLCA1MDksIDUyMSwgNTIzLCA1NDEsIDU0NywgNTU3LCA1NjMsIDU2OSwgNTcxLCA1NzcsIDU4NywgNTkzLCA1OTksIDYwMSwgNjA3LCA2MTMsIDYxNywgNjE5LCA2MzEsIDY0MSwgNjQzLCA2NDcsIDY1MywgNjU5LCA2NjEsIDY3MywgNjc3LCA2ODMsIDY5MSwgNzAxLCA3MDksIDcxOSwgNzI3LCA3MzMsIDczOSwgNzQzLCA3NTEsIDc1NywgNzYxLCA3NjksIDc3MywgNzg3LCA3OTcsIDgwOSwgODExLCA4MjEsIDgyMywgODI3LCA4MjksIDgzOSwgODUzLCA4NTcsIDg1OSwgODYzLCA4NzcsIDg4MSwgODgzLCA4ODcsIDkwNywgOTExLCA5MTksIDkyOSwgOTM3LCA5NDEsIDk0NywgOTUzLCA5NjcsIDk3MSwgOTc3LCA5ODMsIDk5MSwgOTk3XTtcbnZhciBscGxpbSA9ICgxIDw8IDI2KSAvIGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoIC0gMV07XG4vLyNlbmRyZWdpb25cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG52YXIgQmlnSW50ZWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaWdJbnRlZ2VyKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21OdW1iZXIoYSwgYiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09IG51bGwgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyhhLCAyNTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vI3JlZ2lvbiBQVUJMSUNcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIiArIHRoaXMubmVnYXRlKCkudG9TdHJpbmcoYik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmIChiID09IDE2KSB7XG4gICAgICAgICAgICBrID0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDgpIHtcbiAgICAgICAgICAgIGsgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMikge1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSAzMikge1xuICAgICAgICAgICAgayA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSA0KSB7XG4gICAgICAgICAgICBrID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUmFkaXgoYik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGttID0gKDEgPDwgaykgLSAxO1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdmFyIG0gPSBmYWxzZTtcbiAgICAgICAgdmFyIHIgPSBcIlwiO1xuICAgICAgICB2YXIgaSA9IHRoaXMudDtcbiAgICAgICAgdmFyIHAgPSB0aGlzLkRCIC0gKGkgKiB0aGlzLkRCKSAlIGs7XG4gICAgICAgIGlmIChpLS0gPiAwKSB7XG4gICAgICAgICAgICBpZiAocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzW2ldID4+IHApID4gMCkge1xuICAgICAgICAgICAgICAgIG0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHIgPSBpbnQyY2hhcihkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocCA8IGspIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8IChrIC0gcCk7XG4gICAgICAgICAgICAgICAgICAgIGQgfD0gdGhpc1stLWldID4+IChwICs9IHRoaXMuREIgLSBrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAodGhpc1tpXSA+PiAocCAtPSBrKSkgJiBrbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCArPSB0aGlzLkRCO1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgciArPSBpbnQyY2hhcihkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0gPyByIDogXCIwXCI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbiAgICAvLyAocHVibGljKSAtdGhpc1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuICAgIC8vIChwdWJsaWMpIHx0aGlzfFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuICsgaWYgdGhpcyA+IGEsIC0gaWYgdGhpcyA8IGEsIDAgaWYgZXF1YWxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IHRoaXMucyAtIGEucztcbiAgICAgICAgaWYgKHIgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSB0aGlzLnQ7XG4gICAgICAgIHIgPSBpIC0gYS50O1xuICAgICAgICBpZiAociAhPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucyA8IDApID8gLXIgOiByO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKChyID0gdGhpc1tpXSAtIGFbaV0pICE9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IGJuQml0TGVuZ3RoO1xuICAgIC8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuREIgKiAodGhpcy50IC0gMSkgKyBuYml0cyh0aGlzW3RoaXMudCAtIDFdIF4gKHRoaXMucyAmIHRoaXMuRE0pKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuICAgIC8vIChwdWJsaWMpIHRoaXMgbW9kIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmFicygpLmRpdlJlbVRvKGEsIG51bGwsIHIpO1xuICAgICAgICBpZiAodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkge1xuICAgICAgICAgICAgYS5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvd0ludCA9IGJuTW9kUG93SW50O1xuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0sIDAgPD0gZSA8IDJeMzJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3dJbnQgPSBmdW5jdGlvbiAoZSwgbSkge1xuICAgICAgICB2YXIgejtcbiAgICAgICAgaWYgKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeiA9IG5ldyBNb250Z29tZXJ5KG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cChlLCB6KTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsb25lID0gYm5DbG9uZTtcbiAgICAvLyAocHVibGljKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmNvcHlUbyhyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGludGVnZXJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzWzBdIC0gdGhpcy5EVjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnQgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDwgMzJcbiAgICAgICAgcmV0dXJuICgodGhpc1sxXSAmICgoMSA8PCAoMzIgLSB0aGlzLkRCKSkgLSAxKSkgPDwgdGhpcy5EQikgfCB0aGlzWzBdO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYnl0ZVZhbHVlID0gYm5CeXRlVmFsdWU7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGJ5dGVcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMjQpID4+IDI0O1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hvcnRWYWx1ZSA9IGJuU2hvcnRWYWx1ZTtcbiAgICAvLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgc2hvcnQgKGFzc3VtZXMgREI+PTE2KVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMTYpID4+IDE2O1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2lnbnVtID0gYm5TaWdOdW07XG4gICAgLy8gKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50IDw9IDAgfHwgKHRoaXMudCA9PSAxICYmIHRoaXNbMF0gPD0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbiAgICAvLyAocHVibGljKSBjb252ZXJ0IHRvIGJpZ2VuZGlhbiBieXRlIGFycmF5XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy50O1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICByWzBdID0gdGhpcy5zO1xuICAgICAgICB2YXIgcCA9IHRoaXMuREIgLSAoaSAqIHRoaXMuREIpICUgODtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgaWYgKGktLSA+IDApIHtcbiAgICAgICAgICAgIGlmIChwIDwgdGhpcy5EQiAmJiAoZCA9IHRoaXNbaV0gPj4gcCkgIT0gKHRoaXMucyAmIHRoaXMuRE0pID4+IHApIHtcbiAgICAgICAgICAgICAgICByW2srK10gPSBkIHwgKHRoaXMucyA8PCAodGhpcy5EQiAtIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocCA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8ICg4IC0gcCk7XG4gICAgICAgICAgICAgICAgICAgIGQgfD0gdGhpc1stLWldID4+IChwICs9IHRoaXMuREIgLSA4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAodGhpc1tpXSA+PiAocCAtPSA4KSkgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwICs9IHRoaXMuREI7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChkICYgMHg4MCkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkIHw9IC0yNTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID09IDAgJiYgKHRoaXMucyAmIDB4ODApICE9IChkICYgMHg4MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKytrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcltrKytdID0gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBibkVxdWFscztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpID09IDApO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA8IDApID8gdGhpcyA6IGE7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpID4gMCkgPyB0aGlzIDogYTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYml0d2lzZVRvKGEsIG9wX2FuZCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3Bfb3IsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGJuWG9yO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYml0d2lzZVRvKGEsIG9wX3hvciwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gYm5BbmROb3Q7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfYW5kbm90LCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBibk5vdDtcbiAgICAvLyAocHVibGljKSB+dGhpc1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgcltpXSA9IHRoaXMuRE0gJiB+dGhpc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByLnQgPSB0aGlzLnQ7XG4gICAgICAgIHIucyA9IH50aGlzLnM7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG4gICAgLy8gKHB1YmxpYykgdGhpcyA8PCBuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnJTaGlmdFRvKC1uLCByKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubFNoaWZ0VG8obiwgcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgPj4gblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubFNoaWZ0VG8oLW4sIHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yU2hpZnRUbyhuLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGJuR2V0TG93ZXN0U2V0Qml0O1xuICAgIC8vIChwdWJsaWMpIHJldHVybnMgaW5kZXggb2YgbG93ZXN0IDEtYml0IChvciAtMSBpZiBub25lKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gIT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICogdGhpcy5EQiArIGxiaXQodGhpc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnQgKiB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdENvdW50ID0gYm5CaXRDb3VudDtcbiAgICAvLyAocHVibGljKSByZXR1cm4gbnVtYmVyIG9mIHNldCBiaXRzXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gMDtcbiAgICAgICAgdmFyIHggPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByICs9IGNiaXQodGhpc1tpXSBeIHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUudGVzdEJpdCA9IGJuVGVzdEJpdDtcbiAgICAvLyAocHVibGljKSB0cnVlIGlmZiBudGggYml0IGlzIHNldFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRlc3RCaXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpO1xuICAgICAgICBpZiAoaiA+PSB0aGlzLnQpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zICE9IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKHRoaXNbal0gJiAoMSA8PCAobiAlIHRoaXMuREIpKSkgIT0gMCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zZXRCaXQgPSBiblNldEJpdDtcbiAgICAvLyAocHVibGljKSB0aGlzIHwgKDE8PG4pXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX29yKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gYm5DbGVhckJpdDtcbiAgICAvLyAocHVibGljKSB0aGlzICYgfigxPDxuKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX2FuZG5vdCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgXiAoMTw8bilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX3hvcik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBibkFkZDtcbiAgICAvLyAocHVibGljKSB0aGlzICsgYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYWRkVG8oYSwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBiblN1YnRyYWN0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgLSBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLnN1YlRvKGEsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gYm5NdWx0aXBseTtcbiAgICAvLyAocHVibGljKSB0aGlzICogYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5tdWx0aXBseVRvKGEsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGJuRGl2aWRlO1xuICAgIC8vIChwdWJsaWMpIHRoaXMgLyBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhhLCByLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBiblJlbWFpbmRlcjtcbiAgICAvLyAocHVibGljKSB0aGlzICUgYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuZGl2UmVtVG8oYSwgbnVsbCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG4gICAgLy8gKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHEgPSBuYmkoKTtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhhLCBxLCByKTtcbiAgICAgICAgcmV0dXJuIFtxLCByXTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGJuTW9kUG93O1xuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0gKEhBQyAxNC44NSlcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBmdW5jdGlvbiAoZSwgbSkge1xuICAgICAgICB2YXIgaSA9IGUuYml0TGVuZ3RoKCk7XG4gICAgICAgIHZhciBrO1xuICAgICAgICB2YXIgciA9IG5idigxKTtcbiAgICAgICAgdmFyIHo7XG4gICAgICAgIGlmIChpIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPCAxOCkge1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICAgICAgICBrID0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpIDwgMTQ0KSB7XG4gICAgICAgICAgICBrID0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpIDwgNzY4KSB7XG4gICAgICAgICAgICBrID0gNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGsgPSA2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uaXNFdmVuKCkpIHtcbiAgICAgICAgICAgIHogPSBuZXcgQmFycmV0dChtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVjb21wdXRhdGlvblxuICAgICAgICB2YXIgZyA9IFtdO1xuICAgICAgICB2YXIgbiA9IDM7XG4gICAgICAgIHZhciBrMSA9IGsgLSAxO1xuICAgICAgICB2YXIga20gPSAoMSA8PCBrKSAtIDE7XG4gICAgICAgIGdbMV0gPSB6LmNvbnZlcnQodGhpcyk7XG4gICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgdmFyIGcyID0gbmJpKCk7XG4gICAgICAgICAgICB6LnNxclRvKGdbMV0sIGcyKTtcbiAgICAgICAgICAgIHdoaWxlIChuIDw9IGttKSB7XG4gICAgICAgICAgICAgICAgZ1tuXSA9IG5iaSgpO1xuICAgICAgICAgICAgICAgIHoubXVsVG8oZzIsIGdbbiAtIDJdLCBnW25dKTtcbiAgICAgICAgICAgICAgICBuICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGogPSBlLnQgLSAxO1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdmFyIGlzMSA9IHRydWU7XG4gICAgICAgIHZhciByMiA9IG5iaSgpO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgaSA9IG5iaXRzKGVbal0pIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMCkge1xuICAgICAgICAgICAgaWYgKGkgPj0gazEpIHtcbiAgICAgICAgICAgICAgICB3ID0gKGVbal0gPj4gKGkgLSBrMSkpICYga207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gKGVbal0gJiAoKDEgPDwgKGkgKyAxKSkgLSAxKSkgPDwgKGsxIC0gaSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHcgfD0gZVtqIC0gMV0gPj4gKHRoaXMuREIgKyBpIC0gazEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBrO1xuICAgICAgICAgICAgd2hpbGUgKCh3ICYgMSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHcgPj49IDE7XG4gICAgICAgICAgICAgICAgLS1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpIC09IG4pIDwgMCkge1xuICAgICAgICAgICAgICAgIGkgKz0gdGhpcy5EQjtcbiAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXMxKSB7IC8vIHJldCA9PSAxLCBkb24ndCBib3RoZXIgc3F1YXJpbmcgb3IgbXVsdGlwbHlpbmcgaXRcbiAgICAgICAgICAgICAgICBnW3ddLmNvcHlUbyhyKTtcbiAgICAgICAgICAgICAgICBpczEgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB6LnNxclRvKHIsIHIyKTtcbiAgICAgICAgICAgICAgICAgICAgei5zcXJUbyhyMiwgcik7XG4gICAgICAgICAgICAgICAgICAgIG4gLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHI7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6Lm11bFRvKHIyLCBnW3ddLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqID49IDAgJiYgKGVbal0gJiAoMSA8PCBpKSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgICAgIHQgPSByO1xuICAgICAgICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICAgICAgICByMiA9IHQ7XG4gICAgICAgICAgICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuREIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6LnJldmVydChyKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG4gICAgLy8gKHB1YmxpYykgMS90aGlzICUgbSAoSEFDIDE0LjYxKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICB2YXIgYWMgPSBtLmlzRXZlbigpO1xuICAgICAgICBpZiAoKHRoaXMuaXNFdmVuKCkgJiYgYWMpIHx8IG0uc2lnbnVtKCkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludGVnZXIuWkVSTztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdSA9IG0uY2xvbmUoKTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhciBhID0gbmJ2KDEpO1xuICAgICAgICB2YXIgYiA9IG5idigwKTtcbiAgICAgICAgdmFyIGMgPSBuYnYoMCk7XG4gICAgICAgIHZhciBkID0gbmJ2KDEpO1xuICAgICAgICB3aGlsZSAodS5zaWdudW0oKSAhPSAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodS5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgIHUuclNoaWZ0VG8oMSwgdSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYS5pc0V2ZW4oKSB8fCAhYi5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5hZGRUbyh0aGlzLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuc3ViVG8obSwgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5yU2hpZnRUbygxLCBhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWIuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5zdWJUbyhtLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYi5yU2hpZnRUbygxLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh2LmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgdi5yU2hpZnRUbygxLCB2KTtcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmFkZFRvKHRoaXMsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5zdWJUbyhtLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjLnJTaGlmdFRvKDEsIGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZC5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICBkLnN1YlRvKG0sIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkLnJTaGlmdFRvKDEsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHUuY29tcGFyZVRvKHYpID49IDApIHtcbiAgICAgICAgICAgICAgICB1LnN1YlRvKHYsIHUpO1xuICAgICAgICAgICAgICAgIGlmIChhYykge1xuICAgICAgICAgICAgICAgICAgICBhLnN1YlRvKGMsIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiLnN1YlRvKGQsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdi5zdWJUbyh1LCB2KTtcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5zdWJUbyhhLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZC5zdWJUbyhiLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodi5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuY29tcGFyZVRvKG0pID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkLnN1YnRyYWN0KG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkLnNpZ251bSgpIDwgMCkge1xuICAgICAgICAgICAgZC5hZGRUbyhtLCBkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkLnNpZ251bSgpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuYWRkKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGJuUG93O1xuICAgIC8vIChwdWJsaWMpIHRoaXNeZVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cChlLCBuZXcgTnVsbEV4cCgpKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuICAgIC8vIChwdWJsaWMpIGdjZCh0aGlzLGEpIChIQUMgMTQuNTQpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHggPSAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YXIgeSA9IChhLnMgPCAwKSA/IGEubmVnYXRlKCkgOiBhLmNsb25lKCk7XG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA8IDApIHtcbiAgICAgICAgICAgIHZhciB0ID0geDtcbiAgICAgICAgICAgIHggPSB5O1xuICAgICAgICAgICAgeSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgICB2YXIgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIGlmIChnIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBnKSB7XG4gICAgICAgICAgICBnID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgIHguclNoaWZ0VG8oZywgeCk7XG4gICAgICAgICAgICB5LnJTaGlmdFRvKGcsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh4LnNpZ251bSgpID4gMCkge1xuICAgICAgICAgICAgaWYgKChpID0geC5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbyhpLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSA9IHkuZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkge1xuICAgICAgICAgICAgICAgIHkuclNoaWZ0VG8oaSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHguc3ViVG8oeSwgeCk7XG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbygxLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHkuc3ViVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgeS5yU2hpZnRUbygxLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgIHkubFNoaWZ0VG8oZywgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBibklzUHJvYmFibGVQcmltZTtcbiAgICAvLyAocHVibGljKSB0ZXN0IHByaW1hbGl0eSB3aXRoIGNlcnRhaW50eSA+PSAxLS41XnRcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHggPSB0aGlzLmFicygpO1xuICAgICAgICBpZiAoeC50ID09IDEgJiYgeFswXSA8PSBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbG93cHJpbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhbMF0gPT0gbG93cHJpbWVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAxO1xuICAgICAgICB3aGlsZSAoaSA8IGxvd3ByaW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBtID0gbG93cHJpbWVzW2ldO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbG93cHJpbWVzLmxlbmd0aCAmJiBtIDwgbHBsaW0pIHtcbiAgICAgICAgICAgICAgICBtICo9IGxvd3ByaW1lc1tqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbSA9IHgubW9kSW50KG0pO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG0gJSBsb3dwcmltZXNbaSsrXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHgubWlsbGVyUmFiaW4odCk7XG4gICAgfTtcbiAgICAvLyNlbmRyZWdpb24gUFVCTElDXG4gICAgLy8jcmVnaW9uIFBST1RFQ1RFRFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvcHlUbyA9IGJucENvcHlUbztcbiAgICAvLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvcHlUbyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gdGhpcy50O1xuICAgICAgICByLnMgPSB0aGlzLnM7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tSW50ID0gYm5wRnJvbUludDtcbiAgICAvLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tSW50ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50ID0gMTtcbiAgICAgICAgdGhpcy5zID0gKHggPCAwKSA/IC0xIDogMDtcbiAgICAgICAgaWYgKHggPiAwKSB7XG4gICAgICAgICAgICB0aGlzWzBdID0geDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4IDwgLTEpIHtcbiAgICAgICAgICAgIHRoaXNbMF0gPSB4ICsgdGhpcy5EVjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBibnBGcm9tU3RyaW5nO1xuICAgIC8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHMsIGIpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmIChiID09IDE2KSB7XG4gICAgICAgICAgICBrID0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDgpIHtcbiAgICAgICAgICAgIGsgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMjU2KSB7XG4gICAgICAgICAgICBrID0gODtcbiAgICAgICAgICAgIC8qIGJ5dGUgYXJyYXkgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDIpIHtcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMzIpIHtcbiAgICAgICAgICAgIGsgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gNCkge1xuICAgICAgICAgICAgayA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZyb21SYWRpeChzLCBiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnQgPSAwO1xuICAgICAgICB0aGlzLnMgPSAwO1xuICAgICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgICB2YXIgbWkgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNoID0gMDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgeCA9IChrID09IDgpID8gKCtzW2ldKSAmIDB4ZmYgOiBpbnRBdChzLCBpKTtcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICBtaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWkgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2ggKyBrID4gdGhpcy5EQikge1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50IC0gMV0gfD0gKHggJiAoKDEgPDwgKHRoaXMuREIgLSBzaCkpIC0gMSkpIDw8IHNoO1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50KytdID0gKHggPj4gKHRoaXMuREIgLSBzaCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQgLSAxXSB8PSB4IDw8IHNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2ggKz0gaztcbiAgICAgICAgICAgIGlmIChzaCA+PSB0aGlzLkRCKSB7XG4gICAgICAgICAgICAgICAgc2ggLT0gdGhpcy5EQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoayA9PSA4ICYmICgoK3NbMF0pICYgMHg4MCkgIT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zID0gLTE7XG4gICAgICAgICAgICBpZiAoc2ggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQgLSAxXSB8PSAoKDEgPDwgKHRoaXMuREIgLSBzaCkpIC0gMSkgPDwgc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGFtcCgpO1xuICAgICAgICBpZiAobWkpIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2xhbXAgPSBibnBDbGFtcDtcbiAgICAvLyAocHJvdGVjdGVkKSBjbGFtcCBvZmYgZXhjZXNzIGhpZ2ggd29yZHNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgICB3aGlsZSAodGhpcy50ID4gMCAmJiB0aGlzW3RoaXMudCAtIDFdID09IGMpIHtcbiAgICAgICAgICAgIC0tdGhpcy50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRsU2hpZnRUbyA9IGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpICsgbl0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gdGhpcy50ICsgbjtcbiAgICAgICAgci5zID0gdGhpcy5zO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZHJTaGlmdFRvID0gYm5wRFJTaGlmdFRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBmdW5jdGlvbiAobiwgcikge1xuICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByW2kgLSBuXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gTWF0aC5tYXgodGhpcy50IC0gbiwgMCk7XG4gICAgICAgIHIucyA9IHRoaXMucztcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gYm5wTFNoaWZ0VG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgdmFyIGJzID0gbiAlIHRoaXMuREI7XG4gICAgICAgIHZhciBjYnMgPSB0aGlzLkRCIC0gYnM7XG4gICAgICAgIHZhciBibSA9ICgxIDw8IGNicykgLSAxO1xuICAgICAgICB2YXIgZHMgPSBNYXRoLmZsb29yKG4gLyB0aGlzLkRCKTtcbiAgICAgICAgdmFyIGMgPSAodGhpcy5zIDw8IGJzKSAmIHRoaXMuRE07XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpICsgZHMgKyAxXSA9ICh0aGlzW2ldID4+IGNicykgfCBjO1xuICAgICAgICAgICAgYyA9ICh0aGlzW2ldICYgYm0pIDw8IGJzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBkcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICByW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByW2RzXSA9IGM7XG4gICAgICAgIHIudCA9IHRoaXMudCArIGRzICsgMTtcbiAgICAgICAgci5zID0gdGhpcy5zO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yU2hpZnRUbyA9IGJucFJTaGlmdFRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yU2hpZnRUbyA9IGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgIHIucyA9IHRoaXMucztcbiAgICAgICAgdmFyIGRzID0gTWF0aC5mbG9vcihuIC8gdGhpcy5EQik7XG4gICAgICAgIGlmIChkcyA+PSB0aGlzLnQpIHtcbiAgICAgICAgICAgIHIudCA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJzID0gbiAlIHRoaXMuREI7XG4gICAgICAgIHZhciBjYnMgPSB0aGlzLkRCIC0gYnM7XG4gICAgICAgIHZhciBibSA9ICgxIDw8IGJzKSAtIDE7XG4gICAgICAgIHJbMF0gPSB0aGlzW2RzXSA+PiBicztcbiAgICAgICAgZm9yICh2YXIgaSA9IGRzICsgMTsgaSA8IHRoaXMudDsgKytpKSB7XG4gICAgICAgICAgICByW2kgLSBkcyAtIDFdIHw9ICh0aGlzW2ldICYgYm0pIDw8IGNicztcbiAgICAgICAgICAgIHJbaSAtIGRzXSA9IHRoaXNbaV0gPj4gYnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJzID4gMCkge1xuICAgICAgICAgICAgclt0aGlzLnQgLSBkcyAtIDFdIHw9ICh0aGlzLnMgJiBibSkgPDwgY2JzO1xuICAgICAgICB9XG4gICAgICAgIHIudCA9IHRoaXMudCAtIGRzO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJUbyA9IGJucFN1YlRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gZnVuY3Rpb24gKGEsIHIpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBtID0gTWF0aC5taW4oYS50LCB0aGlzLnQpO1xuICAgICAgICB3aGlsZSAoaSA8IG0pIHtcbiAgICAgICAgICAgIGMgKz0gdGhpc1tpXSAtIGFbaV07XG4gICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudCA8IHRoaXMudCkge1xuICAgICAgICAgICAgYyAtPSBhLnM7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMudCkge1xuICAgICAgICAgICAgICAgIGMgKz0gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYS50KSB7XG4gICAgICAgICAgICAgICAgYyAtPSBhW2ldO1xuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjIC09IGEucztcbiAgICAgICAgfVxuICAgICAgICByLnMgPSAoYyA8IDApID8gLTEgOiAwO1xuICAgICAgICBpZiAoYyA8IC0xKSB7XG4gICAgICAgICAgICByW2krK10gPSB0aGlzLkRWICsgYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID4gMCkge1xuICAgICAgICAgICAgcltpKytdID0gYztcbiAgICAgICAgfVxuICAgICAgICByLnQgPSBpO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VG8gPSBmdW5jdGlvbiAoYSwgcikge1xuICAgICAgICB2YXIgeCA9IHRoaXMuYWJzKCk7XG4gICAgICAgIHZhciB5ID0gYS5hYnMoKTtcbiAgICAgICAgdmFyIGkgPSB4LnQ7XG4gICAgICAgIHIudCA9IGkgKyB5LnQ7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHkudDsgKytpKSB7XG4gICAgICAgICAgICByW2kgKyB4LnRdID0geC5hbSgwLCB5W2ldLCByLCBpLCAwLCB4LnQpO1xuICAgICAgICB9XG4gICAgICAgIHIucyA9IDA7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICAgICAgaWYgKHRoaXMucyAhPSBhLnMpIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlVG8gPSBibnBTcXVhcmVUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpc14yLCByICE9IHRoaXMgKEhBQyAxNC4xNilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmVUbyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgICAgICAgdmFyIGkgPSByLnQgPSAyICogeC50O1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB4LnQgLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0geC5hbShpLCB4W2ldLCByLCAyICogaSwgMCwgMSk7XG4gICAgICAgICAgICBpZiAoKHJbaSArIHgudF0gKz0geC5hbShpICsgMSwgMiAqIHhbaV0sIHIsIDIgKiBpICsgMSwgYywgeC50IC0gaSAtIDEpKSA+PSB4LkRWKSB7XG4gICAgICAgICAgICAgICAgcltpICsgeC50XSAtPSB4LkRWO1xuICAgICAgICAgICAgICAgIHJbaSArIHgudCArIDFdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoci50ID4gMCkge1xuICAgICAgICAgICAgcltyLnQgLSAxXSArPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByLnMgPSAwO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIGRpdmlkZSB0aGlzIGJ5IG0sIHF1b3RpZW50IGFuZCByZW1haW5kZXIgdG8gcSwgciAoSEFDIDE0LjIwKVxuICAgIC8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdlJlbVRvID0gZnVuY3Rpb24gKG0sIHEsIHIpIHtcbiAgICAgICAgdmFyIHBtID0gbS5hYnMoKTtcbiAgICAgICAgaWYgKHBtLnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gICAgICAgIGlmIChwdC50IDwgcG0udCkge1xuICAgICAgICAgICAgaWYgKHEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHEuZnJvbUludCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcHlUbyhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PSBudWxsKSB7XG4gICAgICAgICAgICByID0gbmJpKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSBuYmkoKTtcbiAgICAgICAgdmFyIHRzID0gdGhpcy5zO1xuICAgICAgICB2YXIgbXMgPSBtLnM7XG4gICAgICAgIHZhciBuc2ggPSB0aGlzLkRCIC0gbmJpdHMocG1bcG0udCAtIDFdKTsgLy8gbm9ybWFsaXplIG1vZHVsdXNcbiAgICAgICAgaWYgKG5zaCA+IDApIHtcbiAgICAgICAgICAgIHBtLmxTaGlmdFRvKG5zaCwgeSk7XG4gICAgICAgICAgICBwdC5sU2hpZnRUbyhuc2gsIHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG0uY29weVRvKHkpO1xuICAgICAgICAgICAgcHQuY29weVRvKHIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5cyA9IHkudDtcbiAgICAgICAgdmFyIHkwID0geVt5cyAtIDFdO1xuICAgICAgICBpZiAoeTAgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5dCA9IHkwICogKDEgPDwgdGhpcy5GMSkgKyAoKHlzID4gMSkgPyB5W3lzIC0gMl0gPj4gdGhpcy5GMiA6IDApO1xuICAgICAgICB2YXIgZDEgPSB0aGlzLkZWIC8geXQ7XG4gICAgICAgIHZhciBkMiA9ICgxIDw8IHRoaXMuRjEpIC8geXQ7XG4gICAgICAgIHZhciBlID0gMSA8PCB0aGlzLkYyO1xuICAgICAgICB2YXIgaSA9IHIudDtcbiAgICAgICAgdmFyIGogPSBpIC0geXM7XG4gICAgICAgIHZhciB0ID0gKHEgPT0gbnVsbCkgPyBuYmkoKSA6IHE7XG4gICAgICAgIHkuZGxTaGlmdFRvKGosIHQpO1xuICAgICAgICBpZiAoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgICAgICAgICAgcltyLnQrK10gPSAxO1xuICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgfVxuICAgICAgICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsIHQpO1xuICAgICAgICB0LnN1YlRvKHksIHkpOyAvLyBcIm5lZ2F0aXZlXCIgeSBzbyB3ZSBjYW4gcmVwbGFjZSBzdWIgd2l0aCBhbSBsYXRlclxuICAgICAgICB3aGlsZSAoeS50IDwgeXMpIHtcbiAgICAgICAgICAgIHlbeS50KytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoLS1qID49IDApIHtcbiAgICAgICAgICAgIC8vIEVzdGltYXRlIHF1b3RpZW50IGRpZ2l0XG4gICAgICAgICAgICB2YXIgcWQgPSAoclstLWldID09IHkwKSA/IHRoaXMuRE0gOiBNYXRoLmZsb29yKHJbaV0gKiBkMSArIChyW2kgLSAxXSArIGUpICogZDIpO1xuICAgICAgICAgICAgaWYgKChyW2ldICs9IHkuYW0oMCwgcWQsIHIsIGosIDAsIHlzKSkgPCBxZCkgeyAvLyBUcnkgaXQgb3V0XG4gICAgICAgICAgICAgICAgeS5kbFNoaWZ0VG8oaiwgdCk7XG4gICAgICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocltpXSA8IC0tcWQpIHtcbiAgICAgICAgICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHEgIT0gbnVsbCkge1xuICAgICAgICAgICAgci5kclNoaWZ0VG8oeXMsIHEpO1xuICAgICAgICAgICAgaWYgKHRzICE9IG1zKSB7XG4gICAgICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEsIHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHIudCA9IHlzO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgICAgIGlmIChuc2ggPiAwKSB7XG4gICAgICAgICAgICByLnJTaGlmdFRvKG5zaCwgcik7XG4gICAgICAgIH0gLy8gRGVub3JtYWxpemUgcmVtYWluZGVyXG4gICAgICAgIGlmICh0cyA8IDApIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbiAgICAvLyAocHJvdGVjdGVkKSByZXR1cm4gXCItMS90aGlzICUgMl5EQlwiOyB1c2VmdWwgZm9yIE1vbnQuIHJlZHVjdGlvblxuICAgIC8vIGp1c3RpZmljYXRpb246XG4gICAgLy8gICAgICAgICB4eSA9PSAxIChtb2QgbSlcbiAgICAvLyAgICAgICAgIHh5ID0gIDEra21cbiAgICAvLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4gICAgLy8geFt5KDIteHkpXSA9IDEta14ybV4yXG4gICAgLy8geFt5KDIteHkpXSA9PSAxIChtb2QgbV4yKVxuICAgIC8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbiAgICAvLyBzaG91bGQgcmVkdWNlIHggYW5kIHkoMi14eSkgYnkgbV4yIGF0IGVhY2ggc3RlcCB0byBrZWVwIHNpemUgYm91bmRlZC5cbiAgICAvLyBKUyBtdWx0aXBseSBcIm92ZXJmbG93c1wiIGRpZmZlcmVudGx5IGZyb20gQy9DKyssIHNvIGNhcmUgaXMgbmVlZGVkIGhlcmUuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IHRoaXNbMF07XG4gICAgICAgIGlmICgoeCAmIDEpID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0geCAmIDM7IC8vIHkgPT0gMS94IG1vZCAyXjJcbiAgICAgICAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZikgKiB5KSkgJiAweGY7IC8vIHkgPT0gMS94IG1vZCAyXjRcbiAgICAgICAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZmYpICogeSkpICYgMHhmZjsgLy8geSA9PSAxL3ggbW9kIDJeOFxuICAgICAgICB5ID0gKHkgKiAoMiAtICgoKHggJiAweGZmZmYpICogeSkgJiAweGZmZmYpKSkgJiAweGZmZmY7IC8vIHkgPT0gMS94IG1vZCAyXjE2XG4gICAgICAgIC8vIGxhc3Qgc3RlcCAtIGNhbGN1bGF0ZSBpbnZlcnNlIG1vZCBEViBkaXJlY3RseTtcbiAgICAgICAgLy8gYXNzdW1lcyAxNiA8IERCIDw9IDMyIGFuZCBhc3N1bWVzIGFiaWxpdHkgdG8gaGFuZGxlIDQ4LWJpdCBpbnRzXG4gICAgICAgIHkgPSAoeSAqICgyIC0geCAqIHkgJSB0aGlzLkRWKSkgJSB0aGlzLkRWOyAvLyB5ID09IDEveCBtb2QgMl5kYml0c1xuICAgICAgICAvLyB3ZSByZWFsbHkgd2FudCB0aGUgbmVnYXRpdmUgaW52ZXJzZSwgYW5kIC1EViA8IHkgPCBEVlxuICAgICAgICByZXR1cm4gKHkgPiAwKSA/IHRoaXMuRFYgLSB5IDogLXk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBibnBJc0V2ZW47XG4gICAgLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZmYgdGhpcyBpcyBldmVuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnQgPiAwKSA/ICh0aGlzWzBdICYgMSkgOiB0aGlzLnMpID09IDA7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5leHAgPSBibnBFeHA7XG4gICAgLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uIChlLCB6KSB7XG4gICAgICAgIGlmIChlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHZhciByMiA9IG5iaSgpO1xuICAgICAgICB2YXIgZyA9IHouY29udmVydCh0aGlzKTtcbiAgICAgICAgdmFyIGkgPSBuYml0cyhlKSAtIDE7XG4gICAgICAgIGcuY29weVRvKHIpO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xuICAgICAgICAgICAgaWYgKChlICYgKDEgPDwgaSkpID4gMCkge1xuICAgICAgICAgICAgICAgIHoubXVsVG8ocjIsIGcsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByO1xuICAgICAgICAgICAgICAgIHIgPSByMjtcbiAgICAgICAgICAgICAgICByMiA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuICAgIC8vIChwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaHVua1NpemUgPSBmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLkxOMiAqIHRoaXMuREIgLyBNYXRoLmxvZyhyKSk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1JhZGl4ID0gYm5wVG9SYWRpeDtcbiAgICAvLyAocHJvdGVjdGVkKSBjb252ZXJ0IHRvIHJhZGl4IHN0cmluZ1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvUmFkaXggPSBmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICBiID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT0gMCB8fCBiIDwgMiB8fCBiID4gMzYpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbiAgICAgICAgdmFyIGEgPSBNYXRoLnBvdyhiLCBjcyk7XG4gICAgICAgIHZhciBkID0gbmJ2KGEpO1xuICAgICAgICB2YXIgeSA9IG5iaSgpO1xuICAgICAgICB2YXIgeiA9IG5iaSgpO1xuICAgICAgICB2YXIgciA9IFwiXCI7XG4gICAgICAgIHRoaXMuZGl2UmVtVG8oZCwgeSwgeik7XG4gICAgICAgIHdoaWxlICh5LnNpZ251bSgpID4gMCkge1xuICAgICAgICAgICAgciA9IChhICsgei5pbnRWYWx1ZSgpKS50b1N0cmluZyhiKS5zdWJzdHIoMSkgKyByO1xuICAgICAgICAgICAgeS5kaXZSZW1UbyhkLCB5LCB6KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21SYWRpeCA9IGJucEZyb21SYWRpeDtcbiAgICAvLyAocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVJhZGl4ID0gZnVuY3Rpb24gKHMsIGIpIHtcbiAgICAgICAgdGhpcy5mcm9tSW50KDApO1xuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgICAgICBiID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG4gICAgICAgIHZhciBkID0gTWF0aC5wb3coYiwgY3MpO1xuICAgICAgICB2YXIgbWkgPSBmYWxzZTtcbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHggPSBpbnRBdChzLCBpKTtcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIiAmJiB0aGlzLnNpZ251bSgpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcgPSBiICogdyArIHg7XG4gICAgICAgICAgICBpZiAoKytqID49IGNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kTXVsdGlwbHkoZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsIDApO1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIHcgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYiwgaikpO1xuICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaSkge1xuICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbiAgICAvLyAocHJvdGVjdGVkKSBhbHRlcm5hdGUgY29uc3RydWN0b3JcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxpbnQsUk5HKVxuICAgICAgICAgICAgaWYgKGEgPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tSW50KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKGEsIGMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50ZXN0Qml0KGEgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBNU0Igc2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIG9wX29yLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KDEsIDApO1xuICAgICAgICAgICAgICAgIH0gLy8gZm9yY2Ugb2RkXG4gICAgICAgICAgICAgICAgd2hpbGUgKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQoMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJpdExlbmd0aCgpID4gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxSTkcpXG4gICAgICAgICAgICB2YXIgeCA9IFtdO1xuICAgICAgICAgICAgdmFyIHQgPSBhICYgNztcbiAgICAgICAgICAgIHgubGVuZ3RoID0gKGEgPj4gMykgKyAxO1xuICAgICAgICAgICAgYi5uZXh0Qnl0ZXMoeCk7XG4gICAgICAgICAgICBpZiAodCA+IDApIHtcbiAgICAgICAgICAgICAgICB4WzBdICY9ICgoMSA8PCB0KSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeFswXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcoeCwgMjU2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYml0d2lzZVRvID0gYm5wQml0d2lzZVRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIG9wIGEgKGJpdHdpc2UpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0d2lzZVRvID0gZnVuY3Rpb24gKGEsIG9wLCByKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgdmFyIG0gPSBNYXRoLm1pbihhLnQsIHRoaXMudCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgICAgIHJbaV0gPSBvcCh0aGlzW2ldLCBhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS50IDwgdGhpcy50KSB7XG4gICAgICAgICAgICBmID0gYS5zICYgdGhpcy5ETTtcbiAgICAgICAgICAgIGZvciAoaSA9IG07IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHJbaV0gPSBvcCh0aGlzW2ldLCBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGYgPSB0aGlzLnMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgZm9yIChpID0gbTsgaSA8IGEudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcltpXSA9IG9wKGYsIGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci50ID0gYS50O1xuICAgICAgICB9XG4gICAgICAgIHIucyA9IG9wKHRoaXMucywgYS5zKTtcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2hhbmdlQml0ID0gYm5wQ2hhbmdlQml0O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgb3AgKDE8PG4pXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2hhbmdlQml0ID0gZnVuY3Rpb24gKG4sIG9wKSB7XG4gICAgICAgIHZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xuICAgICAgICB0aGlzLmJpdHdpc2VUbyhyLCBvcCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkVG8gPSBibnBBZGRUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyArIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGRUbyA9IGZ1bmN0aW9uIChhLCByKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICB2YXIgbSA9IE1hdGgubWluKGEudCwgdGhpcy50KTtcbiAgICAgICAgd2hpbGUgKGkgPCBtKSB7XG4gICAgICAgICAgICBjICs9IHRoaXNbaV0gKyBhW2ldO1xuICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnQgPCB0aGlzLnQpIHtcbiAgICAgICAgICAgIGMgKz0gYS5zO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnQpIHtcbiAgICAgICAgICAgICAgICBjICs9IHRoaXNbaV07XG4gICAgICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGEudCkge1xuICAgICAgICAgICAgICAgIGMgKz0gYVtpXTtcbiAgICAgICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyArPSBhLnM7XG4gICAgICAgIH1cbiAgICAgICAgci5zID0gKGMgPCAwKSA/IC0xIDogMDtcbiAgICAgICAgaWYgKGMgPiAwKSB7XG4gICAgICAgICAgICByW2krK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAtMSkge1xuICAgICAgICAgICAgcltpKytdID0gdGhpcy5EViArIGM7XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gaTtcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZE11bHRpcGx5ID0gYm5wRE11bHRpcGx5O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgKj0gbiwgdGhpcyA+PSAwLCAxIDwgbiA8IERWXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZE11bHRpcGx5ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpc1t0aGlzLnRdID0gdGhpcy5hbSgwLCBuIC0gMSwgdGhpcywgMCwgMCwgdGhpcy50KTtcbiAgICAgICAgKyt0aGlzLnQ7XG4gICAgICAgIHRoaXMuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRBZGRPZmZzZXQgPSBibnBEQWRkT2Zmc2V0O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgKz0gbiA8PCB3IHdvcmRzLCB0aGlzID49IDBcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gZnVuY3Rpb24gKG4sIHcpIHtcbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnQgPD0gdykge1xuICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbd10gKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXNbd10gPj0gdGhpcy5EVikge1xuICAgICAgICAgICAgdGhpc1t3XSAtPSB0aGlzLkRWO1xuICAgICAgICAgICAgaWYgKCsrdyA+PSB0aGlzLnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCsrXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3RoaXNbd107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gbG93ZXIgbiB3b3JkcyBvZiBcInRoaXMgKiBhXCIsIGEudCA8PSBuXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGZ1bmN0aW9uIChhLCBuLCByKSB7XG4gICAgICAgIHZhciBpID0gTWF0aC5taW4odGhpcy50ICsgYS50LCBuKTtcbiAgICAgICAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICAgICAgICByLnQgPSBpO1xuICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgIHJbLS1pXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IHIudCAtIHRoaXMudDsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgcltpICsgdGhpcy50XSA9IHRoaXMuYW0oMCwgYVtpXSwgciwgaSwgMCwgdGhpcy50KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gTWF0aC5taW4oYS50LCBuKTsgaSA8IGo7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hbSgwLCBhW2ldLCByLCBpLCAwLCBuIC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlVcHBlclRvID0gYm5wTXVsdGlwbHlVcHBlclRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuICAgIC8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVVwcGVyVG8gPSBmdW5jdGlvbiAoYSwgbiwgcikge1xuICAgICAgICAtLW47XG4gICAgICAgIHZhciBpID0gci50ID0gdGhpcy50ICsgYS50IC0gbjtcbiAgICAgICAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IE1hdGgubWF4KG4gLSB0aGlzLnQsIDApOyBpIDwgYS50OyArK2kpIHtcbiAgICAgICAgICAgIHJbdGhpcy50ICsgaSAtIG5dID0gdGhpcy5hbShuIC0gaSwgYVtpXSwgciwgMCwgMCwgdGhpcy50ICsgaSAtIG4pO1xuICAgICAgICB9XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICAgICAgci5kclNoaWZ0VG8oMSwgcik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnQgPSBibnBNb2RJbnQ7XG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyAlIG4sIG4gPCAyXjI2XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW50ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGQgPSB0aGlzLkRWICUgbjtcbiAgICAgICAgdmFyIHIgPSAodGhpcy5zIDwgMCkgPyBuIC0gMSA6IDA7XG4gICAgICAgIGlmICh0aGlzLnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAoZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgciA9IHRoaXNbMF0gJSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSAoZCAqIHIgKyB0aGlzW2ldKSAlIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubWlsbGVyUmFiaW4gPSBibnBNaWxsZXJSYWJpbjtcbiAgICAvLyAocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgIHZhciBrID0gbjEuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIGlmIChrIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG4gICAgICAgIHQgPSAodCArIDEpID4+IDE7XG4gICAgICAgIGlmICh0ID4gbG93cHJpbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdCA9IGxvd3ByaW1lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBuYmkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIFBpY2sgYmFzZXMgYXQgcmFuZG9tLCBpbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0IDJcbiAgICAgICAgICAgIGEuZnJvbUludChsb3dwcmltZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbG93cHJpbWVzLmxlbmd0aCldKTtcbiAgICAgICAgICAgIHZhciB5ID0gYS5tb2RQb3cociwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkubW9kUG93SW50KDIsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGJuU3F1YXJlO1xuICAgIC8vIChwdWJsaWMpIHRoaXNeMlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5zcXVhcmVUbyhyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyNyZWdpb24gQVNZTkNcbiAgICAvLyBQdWJsaWMgQVBJIG1ldGhvZFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdjZGEgPSBmdW5jdGlvbiAoYSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHggPSAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YXIgeSA9IChhLnMgPCAwKSA/IGEubmVnYXRlKCkgOiBhLmNsb25lKCk7XG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA8IDApIHtcbiAgICAgICAgICAgIHZhciB0ID0geDtcbiAgICAgICAgICAgIHggPSB5O1xuICAgICAgICAgICAgeSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgICB2YXIgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KCk7XG4gICAgICAgIGlmIChnIDwgMCkge1xuICAgICAgICAgICAgY2FsbGJhY2soeCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBnKSB7XG4gICAgICAgICAgICBnID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDApIHtcbiAgICAgICAgICAgIHguclNoaWZ0VG8oZywgeCk7XG4gICAgICAgICAgICB5LnJTaGlmdFRvKGcsIHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdvcmtob3JzZSBvZiB0aGUgYWxnb3JpdGhtLCBnZXRzIGNhbGxlZCAyMDAgLSA4MDAgdGltZXMgcGVyIDUxMiBiaXQga2V5Z2VuLlxuICAgICAgICB2YXIgZ2NkYTEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICB4LnJTaGlmdFRvKGksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeS5yU2hpZnRUbyhpLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgeC5zdWJUbyh5LCB4KTtcbiAgICAgICAgICAgICAgICB4LnJTaGlmdFRvKDEsIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeS5zdWJUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICB5LnJTaGlmdFRvKDEsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoeC5zaWdudW0oKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHkubFNoaWZ0VG8oZywgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBjYWxsYmFjayh5KTsgfSwgMCk7IC8vIGVzY2FwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChnY2RhMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQoZ2NkYTEsIDEwKTtcbiAgICB9O1xuICAgIC8vIChwcm90ZWN0ZWQpIGFsdGVybmF0ZSBjb25zdHJ1Y3RvclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21OdW1iZXJBc3luYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgYikge1xuICAgICAgICAgICAgaWYgKGEgPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tSW50KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKGEsIGMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50ZXN0Qml0KGEgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCBvcF9vciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCgxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJucF8xID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgYm5wZm4xXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJucF8xLmRBZGRPZmZzZXQoMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibnBfMS5iaXRMZW5ndGgoKSA+IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJucF8xLnN1YlRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIGJucF8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYm5wXzEuaXNQcm9iYWJsZVByaW1lKGIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soKTsgfSwgMCk7IC8vIGVzY2FwZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChibnBmbjFfMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYm5wZm4xXzEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHggPSBbXTtcbiAgICAgICAgICAgIHZhciB0ID0gYSAmIDc7XG4gICAgICAgICAgICB4Lmxlbmd0aCA9IChhID4+IDMpICsgMTtcbiAgICAgICAgICAgIGIubmV4dEJ5dGVzKHgpO1xuICAgICAgICAgICAgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgeFswXSAmPSAoKDEgPDwgdCkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHhbMF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKHgsIDI1Nik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCaWdJbnRlZ2VyO1xufSgpKTtcbi8vI3JlZ2lvbiBSRURVQ0VSU1xuLy8jcmVnaW9uIE51bGxFeHBcbnZhciBOdWxsRXhwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bGxFeHAoKSB7XG4gICAgfVxuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuICAgIE51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IG5Ob3A7XG4gICAgTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICAvLyBOdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IG5NdWxUbztcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICB9O1xuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLnNxclRvID0gblNxclRvO1xuICAgIE51bGxFeHAucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICB9O1xuICAgIHJldHVybiBOdWxsRXhwO1xufSgpKTtcbi8vIE1vZHVsYXIgcmVkdWN0aW9uIHVzaW5nIFwiY2xhc3NpY1wiIGFsZ29yaXRobVxudmFyIENsYXNzaWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xhc3NpYyhtKSB7XG4gICAgICAgIHRoaXMubSA9IG07XG4gICAgfVxuICAgIC8vIENsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHgucyA8IDAgfHwgeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQgPSBjUmV2ZXJ0O1xuICAgIENsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gY1JlZHVjZTtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB4LmRpdlJlbVRvKHRoaXMubSwgbnVsbCwgeCk7XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGNNdWxUbztcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGZ1bmN0aW9uICh4LCByKSB7XG4gICAgICAgIHguc3F1YXJlVG8ocik7XG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH07XG4gICAgcmV0dXJuIENsYXNzaWM7XG59KCkpO1xuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gTW9udGdvbWVyeVxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbnZhciBNb250Z29tZXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICAgICAgICB0aGlzLm0gPSBtO1xuICAgICAgICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICAgICAgICB0aGlzLm1wbCA9IHRoaXMubXAgJiAweDdmZmY7XG4gICAgICAgIHRoaXMubXBoID0gdGhpcy5tcCA+PiAxNTtcbiAgICAgICAgdGhpcy51bSA9ICgxIDw8IChtLkRCIC0gMTUpKSAtIDE7XG4gICAgICAgIHRoaXMubXQyID0gMiAqIG0udDtcbiAgICB9XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IG1vbnRDb252ZXJ0O1xuICAgIC8vIHhSIG1vZCBtXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHguYWJzKCkuZGxTaGlmdFRvKHRoaXMubS50LCByKTtcbiAgICAgICAgci5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHIpO1xuICAgICAgICBpZiAoeC5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkge1xuICAgICAgICAgICAgdGhpcy5tLnN1YlRvKHIsIHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0ID0gbW9udFJldmVydDtcbiAgICAvLyB4L1IgbW9kIG1cbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB4LmNvcHlUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbiAgICAvLyB4ID0geC9SIG1vZCBtIChIQUMgMTQuMzIpXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgd2hpbGUgKHgudCA8PSB0aGlzLm10Mikge1xuICAgICAgICAgICAgLy8gcGFkIHggc28gYW0gaGFzIGVub3VnaCByb29tIGxhdGVyXG4gICAgICAgICAgICB4W3gudCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm0udDsgKytpKSB7XG4gICAgICAgICAgICAvLyBmYXN0ZXIgd2F5IG9mIGNhbGN1bGF0aW5nIHUwID0geFtpXSptcCBtb2QgRFZcbiAgICAgICAgICAgIHZhciBqID0geFtpXSAmIDB4N2ZmZjtcbiAgICAgICAgICAgIHZhciB1MCA9IChqICogdGhpcy5tcGwgKyAoKChqICogdGhpcy5tcGggKyAoeFtpXSA+PiAxNSkgKiB0aGlzLm1wbCkgJiB0aGlzLnVtKSA8PCAxNSkpICYgeC5ETTtcbiAgICAgICAgICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgICAgICAgICAgaiA9IGkgKyB0aGlzLm0udDtcbiAgICAgICAgICAgIHhbal0gKz0gdGhpcy5tLmFtKDAsIHUwLCB4LCBpLCAwLCB0aGlzLm0udCk7XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUgY2FycnlcbiAgICAgICAgICAgIHdoaWxlICh4W2pdID49IHguRFYpIHtcbiAgICAgICAgICAgICAgICB4W2pdIC09IHguRFY7XG4gICAgICAgICAgICAgICAgeFsrK2pdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeC5jbGFtcCgpO1xuICAgICAgICB4LmRyU2hpZnRUbyh0aGlzLm0udCwgeCk7XG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHtcbiAgICAgICAgICAgIHguc3ViVG8odGhpcy5tLCB4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG87XG4gICAgLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIC8vIE1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gbW9udFNxclRvO1xuICAgIC8vIHIgPSBcInheMi9SIG1vZCBtXCI7IHggIT0gclxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICByZXR1cm4gTW9udGdvbWVyeTtcbn0oKSk7XG4vLyNlbmRyZWdpb24gTW9udGdvbWVyeVxuLy8jcmVnaW9uIEJhcnJldHRcbi8vIEJhcnJldHQgbW9kdWxhciByZWR1Y3Rpb25cbnZhciBCYXJyZXR0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhcnJldHQobSkge1xuICAgICAgICB0aGlzLm0gPSBtO1xuICAgICAgICAvLyBzZXR1cCBCYXJyZXR0XG4gICAgICAgIHRoaXMucjIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5xMyA9IG5iaSgpO1xuICAgICAgICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oMiAqIG0udCwgdGhpcy5yMik7XG4gICAgICAgIHRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbiAgICB9XG4gICAgLy8gQmFycmV0dC5wcm90b3R5cGUuY29udmVydCA9IGJhcnJldHRDb252ZXJ0O1xuICAgIEJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoeC5zIDwgMCB8fCB4LnQgPiAyICogdGhpcy5tLnQpIHtcbiAgICAgICAgICAgIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgICAgICB4LmNvcHlUbyhyKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGJhcnJldHRSZXZlcnQ7XG4gICAgQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBiYXJyZXR0UmVkdWNlO1xuICAgIC8vIHggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG4gICAgQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeC5kclNoaWZ0VG8odGhpcy5tLnQgLSAxLCB0aGlzLnIyKTtcbiAgICAgICAgaWYgKHgudCA+IHRoaXMubS50ICsgMSkge1xuICAgICAgICAgICAgeC50ID0gdGhpcy5tLnQgKyAxO1xuICAgICAgICAgICAgeC5jbGFtcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXUubXVsdGlwbHlVcHBlclRvKHRoaXMucjIsIHRoaXMubS50ICsgMSwgdGhpcy5xMyk7XG4gICAgICAgIHRoaXMubS5tdWx0aXBseUxvd2VyVG8odGhpcy5xMywgdGhpcy5tLnQgKyAxLCB0aGlzLnIyKTtcbiAgICAgICAgd2hpbGUgKHguY29tcGFyZVRvKHRoaXMucjIpIDwgMCkge1xuICAgICAgICAgICAgeC5kQWRkT2Zmc2V0KDEsIHRoaXMubS50ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgeC5zdWJUbyh0aGlzLnIyLCB4KTtcbiAgICAgICAgd2hpbGUgKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkge1xuICAgICAgICAgICAgeC5zdWJUbyh0aGlzLm0sIHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGJhcnJldHRNdWxUbztcbiAgICAvLyByID0geCp5IG1vZCBtOyB4LHkgIT0gclxuICAgIEJhcnJldHQucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvO1xuICAgIC8vIHIgPSB4XjIgbW9kIG07IHggIT0gclxuICAgIEJhcnJldHQucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICByZXR1cm4gQmFycmV0dDtcbn0oKSk7XG4vLyNlbmRyZWdpb25cbi8vI2VuZHJlZ2lvbiBSRURVQ0VSU1xuLy8gcmV0dXJuIG5ldywgdW5zZXQgQmlnSW50ZWdlclxuZnVuY3Rpb24gbmJpKCkgeyByZXR1cm4gbmV3IEJpZ0ludGVnZXIobnVsbCk7IH1cbmZ1bmN0aW9uIHBhcnNlQmlnSW50KHN0ciwgcikge1xuICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihzdHIsIHIpO1xufVxuLy8gYW06IENvbXB1dGUgd19qICs9ICh4KnRoaXNfaSksIHByb3BhZ2F0ZSBjYXJyaWVzLFxuLy8gYyBpcyBpbml0aWFsIGNhcnJ5LCByZXR1cm5zIGZpbmFsIGNhcnJ5LlxuLy8gYyA8IDMqZHZhbHVlLCB4IDwgMipkdmFsdWUsIHRoaXNfaSA8IGR2YWx1ZVxuLy8gV2UgbmVlZCB0byBzZWxlY3QgdGhlIGZhc3Rlc3Qgb25lIHRoYXQgd29ya3MgaW4gdGhpcyBlbnZpcm9ubWVudC5cbi8vIGFtMTogdXNlIGEgc2luZ2xlIG11bHQgYW5kIGRpdmlkZSB0byBnZXQgdGhlIGhpZ2ggYml0cyxcbi8vIG1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSAyNiBiZWNhdXNlXG4vLyBtYXggaW50ZXJuYWwgdmFsdWUgPSAyKmR2YWx1ZV4yLTIqZHZhbHVlICg8IDJeNTMpXG5mdW5jdGlvbiBhbTEoaSwgeCwgdywgaiwgYywgbikge1xuICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgdiA9IHggKiB0aGlzW2krK10gKyB3W2pdICsgYztcbiAgICAgICAgYyA9IE1hdGguZmxvb3IodiAvIDB4NDAwMDAwMCk7XG4gICAgICAgIHdbaisrXSA9IHYgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGksIHgsIHcsIGosIGMsIG4pIHtcbiAgICB2YXIgeGwgPSB4ICYgMHg3ZmZmO1xuICAgIHZhciB4aCA9IHggPj4gMTU7XG4gICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICAgIHZhciBsID0gdGhpc1tpXSAmIDB4N2ZmZjtcbiAgICAgICAgdmFyIGggPSB0aGlzW2krK10gPj4gMTU7XG4gICAgICAgIHZhciBtID0geGggKiBsICsgaCAqIHhsO1xuICAgICAgICBsID0geGwgKiBsICsgKChtICYgMHg3ZmZmKSA8PCAxNSkgKyB3W2pdICsgKGMgJiAweDNmZmZmZmZmKTtcbiAgICAgICAgYyA9IChsID4+PiAzMCkgKyAobSA+Pj4gMTUpICsgeGggKiBoICsgKGMgPj4+IDMwKTtcbiAgICAgICAgd1tqKytdID0gbCAmIDB4M2ZmZmZmZmY7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuLy8gQWx0ZXJuYXRlbHksIHNldCBtYXggZGlnaXQgYml0cyB0byAyOCBzaW5jZSBzb21lXG4vLyBicm93c2VycyBzbG93IGRvd24gd2hlbiBkZWFsaW5nIHdpdGggMzItYml0IG51bWJlcnMuXG5mdW5jdGlvbiBhbTMoaSwgeCwgdywgaiwgYywgbikge1xuICAgIHZhciB4bCA9IHggJiAweDNmZmY7XG4gICAgdmFyIHhoID0geCA+PiAxNDtcbiAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzW2ldICYgMHgzZmZmO1xuICAgICAgICB2YXIgaCA9IHRoaXNbaSsrXSA+PiAxNDtcbiAgICAgICAgdmFyIG0gPSB4aCAqIGwgKyBoICogeGw7XG4gICAgICAgIGwgPSB4bCAqIGwgKyAoKG0gJiAweDNmZmYpIDw8IDE0KSArIHdbal0gKyBjO1xuICAgICAgICBjID0gKGwgPj4gMjgpICsgKG0gPj4gMTQpICsgeGggKiBoO1xuICAgICAgICB3W2orK10gPSBsICYgMHhmZmZmZmZmO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cbmlmIChqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PSBcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiKSkge1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICAgIGRiaXRzID0gMzA7XG59XG5lbHNlIGlmIChqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSAhPSBcIk5ldHNjYXBlXCIpKSB7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gICAgZGJpdHMgPSAyNjtcbn1cbmVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMztcbiAgICBkYml0cyA9IDI4O1xufVxuQmlnSW50ZWdlci5wcm90b3R5cGUuREIgPSBkYml0cztcbkJpZ0ludGVnZXIucHJvdG90eXBlLkRNID0gKCgxIDw8IGRiaXRzKSAtIDEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMSA8PCBkYml0cyk7XG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMiwgQklfRlApO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjEgPSBCSV9GUCAtIGRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyICogZGJpdHMgLSBCSV9GUDtcbi8vIERpZ2l0IGNvbnZlcnNpb25zXG52YXIgQklfUkMgPSBbXTtcbnZhciBycjtcbnZhciB2djtcbnJyID0gXCIwXCIuY2hhckNvZGVBdCgwKTtcbmZvciAodnYgPSAwOyB2diA8PSA5OyArK3Z2KSB7XG4gICAgQklfUkNbcnIrK10gPSB2djtcbn1cbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikge1xuICAgIEJJX1JDW3JyKytdID0gdnY7XG59XG5yciA9IFwiQVwiLmNoYXJDb2RlQXQoMCk7XG5mb3IgKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIHtcbiAgICBCSV9SQ1tycisrXSA9IHZ2O1xufVxuZnVuY3Rpb24gaW50QXQocywgaSkge1xuICAgIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgICByZXR1cm4gKGMgPT0gbnVsbCkgPyAtMSA6IGM7XG59XG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkge1xuICAgIHZhciByID0gbmJpKCk7XG4gICAgci5mcm9tSW50KGkpO1xuICAgIHJldHVybiByO1xufVxuLy8gcmV0dXJucyBiaXQgbGVuZ3RoIG9mIHRoZSBpbnRlZ2VyIHhcbmZ1bmN0aW9uIG5iaXRzKHgpIHtcbiAgICB2YXIgciA9IDE7XG4gICAgdmFyIHQ7XG4gICAgaWYgKCh0ID0geCA+Pj4gMTYpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gMTY7XG4gICAgfVxuICAgIGlmICgodCA9IHggPj4gOCkgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSA4O1xuICAgIH1cbiAgICBpZiAoKHQgPSB4ID4+IDQpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gNDtcbiAgICB9XG4gICAgaWYgKCh0ID0geCA+PiAyKSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDI7XG4gICAgfVxuICAgIGlmICgodCA9IHggPj4gMSkgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBwcm5nNC5qcyAtIHVzZXMgQXJjZm91ciBhcyBhIFBSTkdcbnZhciBBcmNmb3VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFyY2ZvdXIoKSB7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuaiA9IDA7XG4gICAgICAgIHRoaXMuUyA9IFtdO1xuICAgIH1cbiAgICAvLyBBcmNmb3VyLnByb3RvdHlwZS5pbml0ID0gQVJDNGluaXQ7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcmNmb3VyIGNvbnRleHQgZnJvbSBrZXksIGFuIGFycmF5IG9mIGludHMsIGVhY2ggZnJvbSBbMC4uMjU1XVxuICAgIEFyY2ZvdXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5TW2ldID0gaTtcbiAgICAgICAgfVxuICAgICAgICBqID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgICAgICBqID0gKGogKyB0aGlzLlNbaV0gKyBrZXlbaSAlIGtleS5sZW5ndGhdKSAmIDI1NTtcbiAgICAgICAgICAgIHQgPSB0aGlzLlNbaV07XG4gICAgICAgICAgICB0aGlzLlNbaV0gPSB0aGlzLlNbal07XG4gICAgICAgICAgICB0aGlzLlNbal0gPSB0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuaiA9IDA7XG4gICAgfTtcbiAgICAvLyBBcmNmb3VyLnByb3RvdHlwZS5uZXh0ID0gQVJDNG5leHQ7XG4gICAgQXJjZm91ci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHRoaXMuaSA9ICh0aGlzLmkgKyAxKSAmIDI1NTtcbiAgICAgICAgdGhpcy5qID0gKHRoaXMuaiArIHRoaXMuU1t0aGlzLmldKSAmIDI1NTtcbiAgICAgICAgdCA9IHRoaXMuU1t0aGlzLmldO1xuICAgICAgICB0aGlzLlNbdGhpcy5pXSA9IHRoaXMuU1t0aGlzLmpdO1xuICAgICAgICB0aGlzLlNbdGhpcy5qXSA9IHQ7XG4gICAgICAgIHJldHVybiB0aGlzLlNbKHQgKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTVdO1xuICAgIH07XG4gICAgcmV0dXJuIEFyY2ZvdXI7XG59KCkpO1xuLy8gUGx1ZyBpbiB5b3VyIFJORyBjb25zdHJ1Y3RvciBoZXJlXG5mdW5jdGlvbiBwcm5nX25ld3N0YXRlKCkge1xuICAgIHJldHVybiBuZXcgQXJjZm91cigpO1xufVxuLy8gUG9vbCBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0IGFuZCBncmVhdGVyIHRoYW4gMzIuXG4vLyBBbiBhcnJheSBvZiBieXRlcyB0aGUgc2l6ZSBvZiB0aGUgcG9vbCB3aWxsIGJlIHBhc3NlZCB0byBpbml0KClcbnZhciBybmdfcHNpemUgPSAyNTY7XG5cbi8vIFJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIC0gcmVxdWlyZXMgYSBQUk5HIGJhY2tlbmQsIGUuZy4gcHJuZzQuanNcbnZhciBybmdfc3RhdGU7XG52YXIgcm5nX3Bvb2wgPSBudWxsO1xudmFyIHJuZ19wcHRyO1xuLy8gSW5pdGlhbGl6ZSB0aGUgcG9vbCB3aXRoIGp1bmsgaWYgbmVlZGVkLlxuaWYgKHJuZ19wb29sID09IG51bGwpIHtcbiAgICBybmdfcG9vbCA9IFtdO1xuICAgIHJuZ19wcHRyID0gMDtcbiAgICB2YXIgdCA9IHZvaWQgMDtcbiAgICBpZiAod2luZG93LmNyeXB0byAmJiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICAvLyBFeHRyYWN0IGVudHJvcHkgKDIwNDggYml0cykgZnJvbSBSTkcgaWYgYXZhaWxhYmxlXG4gICAgICAgIHZhciB6ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHopO1xuICAgICAgICBmb3IgKHQgPSAwOyB0IDwgei5sZW5ndGg7ICsrdCkge1xuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB6W3RdICYgMjU1O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZSBtb3VzZSBldmVudHMgZm9yIGVudHJvcHksIGlmIHdlIGRvIG5vdCBoYXZlIGVub3VnaCBlbnRyb3B5IGJ5IHRoZSB0aW1lXG4gICAgLy8gd2UgbmVlZCBpdCwgZW50cm9weSB3aWxsIGJlIGdlbmVyYXRlZCBieSBNYXRoLnJhbmRvbS5cbiAgICB2YXIgb25Nb3VzZU1vdmVMaXN0ZW5lcl8xID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHRoaXMuY291bnQgPSB0aGlzLmNvdW50IHx8IDA7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ID49IDI1NiB8fCBybmdfcHB0ciA+PSBybmdfcHNpemUpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlTGlzdGVuZXJfMSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2luZG93LmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmRldGFjaEV2ZW50KFwib25tb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmVMaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG1vdXNlQ29vcmRpbmF0ZXMgPSBldi54ICsgZXYueTtcbiAgICAgICAgICAgIHJuZ19wb29sW3JuZ19wcHRyKytdID0gbW91c2VDb29yZGluYXRlcyAmIDI1NTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gU29tZXRpbWVzIEZpcmVmb3ggd2lsbCBkZW55IHBlcm1pc3Npb24gdG8gYWNjZXNzIGV2ZW50IHByb3BlcnRpZXMgZm9yIHNvbWUgcmVhc29uLiBJZ25vcmUuXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudChcIm9ubW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlTGlzdGVuZXJfMSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcm5nX2dldF9ieXRlKCkge1xuICAgIGlmIChybmdfc3RhdGUgPT0gbnVsbCkge1xuICAgICAgICBybmdfc3RhdGUgPSBwcm5nX25ld3N0YXRlKCk7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG1heSBub3QgaGF2ZSBjb2xsZWN0ZWQgZW5vdWdoIGVudHJvcHkuICBJZiBub3QsIGZhbGwgYmFjayB0byBNYXRoLnJhbmRvbVxuICAgICAgICB3aGlsZSAocm5nX3BwdHIgPCBybmdfcHNpemUpIHtcbiAgICAgICAgICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKDY1NTM2ICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICBybmdfcG9vbFtybmdfcHB0cisrXSA9IHJhbmRvbSAmIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBybmdfc3RhdGUuaW5pdChybmdfcG9vbCk7XG4gICAgICAgIGZvciAocm5nX3BwdHIgPSAwOyBybmdfcHB0ciA8IHJuZ19wb29sLmxlbmd0aDsgKytybmdfcHB0cikge1xuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHJdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBybmdfcHB0ciA9IDA7XG4gICAgfVxuICAgIC8vIFRPRE86IGFsbG93IHJlc2VlZGluZyBhZnRlciBmaXJzdCByZXF1ZXN0XG4gICAgcmV0dXJuIHJuZ19zdGF0ZS5uZXh0KCk7XG59XG52YXIgU2VjdXJlUmFuZG9tID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlY3VyZVJhbmRvbSgpIHtcbiAgICB9XG4gICAgU2VjdXJlUmFuZG9tLnByb3RvdHlwZS5uZXh0Qnl0ZXMgPSBmdW5jdGlvbiAoYmEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYmFbaV0gPSBybmdfZ2V0X2J5dGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlY3VyZVJhbmRvbTtcbn0oKSk7XG5cbi8vIERlcGVuZHMgb24ganNibi5qcyBhbmQgcm5nLmpzXG4vLyBmdW5jdGlvbiBsaW5lYnJrKHMsbikge1xuLy8gICB2YXIgcmV0ID0gXCJcIjtcbi8vICAgdmFyIGkgPSAwO1xuLy8gICB3aGlsZShpICsgbiA8IHMubGVuZ3RoKSB7XG4vLyAgICAgcmV0ICs9IHMuc3Vic3RyaW5nKGksaStuKSArIFwiXFxuXCI7XG4vLyAgICAgaSArPSBuO1xuLy8gICB9XG4vLyAgIHJldHVybiByZXQgKyBzLnN1YnN0cmluZyhpLHMubGVuZ3RoKTtcbi8vIH1cbi8vIGZ1bmN0aW9uIGJ5dGUySGV4KGIpIHtcbi8vICAgaWYoYiA8IDB4MTApXG4vLyAgICAgcmV0dXJuIFwiMFwiICsgYi50b1N0cmluZygxNik7XG4vLyAgIGVsc2Vcbi8vICAgICByZXR1cm4gYi50b1N0cmluZygxNik7XG4vLyB9XG5mdW5jdGlvbiBwa2NzMXBhZDEocywgbikge1xuICAgIGlmIChuIDwgcy5sZW5ndGggKyAyMikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWVzc2FnZSB0b28gbG9uZyBmb3IgUlNBXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IG4gLSBzLmxlbmd0aCAtIDY7XG4gICAgdmFyIGZpbGxlciA9IFwiXCI7XG4gICAgZm9yICh2YXIgZiA9IDA7IGYgPCBsZW47IGYgKz0gMikge1xuICAgICAgICBmaWxsZXIgKz0gXCJmZlwiO1xuICAgIH1cbiAgICB2YXIgbSA9IFwiMDAwMVwiICsgZmlsbGVyICsgXCIwMFwiICsgcztcbiAgICByZXR1cm4gcGFyc2VCaWdJbnQobSwgMTYpO1xufVxuLy8gUEtDUyMxICh0eXBlIDIsIHJhbmRvbSkgcGFkIGlucHV0IHN0cmluZyBzIHRvIG4gYnl0ZXMsIGFuZCByZXR1cm4gYSBiaWdpbnRcbmZ1bmN0aW9uIHBrY3MxcGFkMihzLCBuKSB7XG4gICAgaWYgKG4gPCBzLmxlbmd0aCArIDExKSB7IC8vIFRPRE86IGZpeCBmb3IgdXRmLThcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk1lc3NhZ2UgdG9vIGxvbmcgZm9yIFJTQVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBiYSA9IFtdO1xuICAgIHZhciBpID0gcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpID49IDAgJiYgbiA+IDApIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaS0tKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHsgLy8gZW5jb2RlIHVzaW5nIHV0Zi04XG4gICAgICAgICAgICBiYVstLW5dID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyA+IDEyNykgJiYgKGMgPCAyMDQ4KSkge1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFbLS1uXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgYmFbLS1uXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIGJhWy0tbl0gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmFbLS1uXSA9IDA7XG4gICAgdmFyIHJuZyA9IG5ldyBTZWN1cmVSYW5kb20oKTtcbiAgICB2YXIgeCA9IFtdO1xuICAgIHdoaWxlIChuID4gMikgeyAvLyByYW5kb20gbm9uLXplcm8gcGFkXG4gICAgICAgIHhbMF0gPSAwO1xuICAgICAgICB3aGlsZSAoeFswXSA9PSAwKSB7XG4gICAgICAgICAgICBybmcubmV4dEJ5dGVzKHgpO1xuICAgICAgICB9XG4gICAgICAgIGJhWy0tbl0gPSB4WzBdO1xuICAgIH1cbiAgICBiYVstLW5dID0gMjtcbiAgICBiYVstLW5dID0gMDtcbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYmEpO1xufVxuLy8gXCJlbXB0eVwiIFJTQSBrZXkgY29uc3RydWN0b3JcbnZhciBSU0FLZXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUlNBS2V5KCkge1xuICAgICAgICB0aGlzLm4gPSBudWxsO1xuICAgICAgICB0aGlzLmUgPSAwO1xuICAgICAgICB0aGlzLmQgPSBudWxsO1xuICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB0aGlzLnEgPSBudWxsO1xuICAgICAgICB0aGlzLmRtcDEgPSBudWxsO1xuICAgICAgICB0aGlzLmRtcTEgPSBudWxsO1xuICAgICAgICB0aGlzLmNvZWZmID0gbnVsbDtcbiAgICB9XG4gICAgLy8jcmVnaW9uIFBST1RFQ1RFRFxuICAgIC8vIHByb3RlY3RlZFxuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZG9QdWJsaWMgPSBSU0FEb1B1YmxpYztcbiAgICAvLyBQZXJmb3JtIHJhdyBwdWJsaWMgb3BlcmF0aW9uIG9uIFwieFwiOiByZXR1cm4geF5lIChtb2QgbilcbiAgICBSU0FLZXkucHJvdG90eXBlLmRvUHVibGljID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgubW9kUG93SW50KHRoaXMuZSwgdGhpcy5uKTtcbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZG9Qcml2YXRlID0gUlNBRG9Qcml2YXRlO1xuICAgIC8vIFBlcmZvcm0gcmF3IHByaXZhdGUgb3BlcmF0aW9uIG9uIFwieFwiOiByZXR1cm4geF5kIChtb2QgbilcbiAgICBSU0FLZXkucHJvdG90eXBlLmRvUHJpdmF0ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh0aGlzLnAgPT0gbnVsbCB8fCB0aGlzLnEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHgubW9kUG93KHRoaXMuZCwgdGhpcy5uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZS1jYWxjdWxhdGUgYW55IG1pc3NpbmcgQ1JUIHBhcmFtc1xuICAgICAgICB2YXIgeHAgPSB4Lm1vZCh0aGlzLnApLm1vZFBvdyh0aGlzLmRtcDEsIHRoaXMucCk7XG4gICAgICAgIHZhciB4cSA9IHgubW9kKHRoaXMucSkubW9kUG93KHRoaXMuZG1xMSwgdGhpcy5xKTtcbiAgICAgICAgd2hpbGUgKHhwLmNvbXBhcmVUbyh4cSkgPCAwKSB7XG4gICAgICAgICAgICB4cCA9IHhwLmFkZCh0aGlzLnApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4cC5zdWJ0cmFjdCh4cSkubXVsdGlwbHkodGhpcy5jb2VmZikubW9kKHRoaXMucCkubXVsdGlwbHkodGhpcy5xKS5hZGQoeHEpO1xuICAgIH07XG4gICAgLy8jZW5kcmVnaW9uIFBST1RFQ1RFRFxuICAgIC8vI3JlZ2lvbiBQVUJMSUNcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLnNldFB1YmxpYyA9IFJTQVNldFB1YmxpYztcbiAgICAvLyBTZXQgdGhlIHB1YmxpYyBrZXkgZmllbGRzIE4gYW5kIGUgZnJvbSBoZXggc3RyaW5nc1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2V0UHVibGljID0gZnVuY3Rpb24gKE4sIEUpIHtcbiAgICAgICAgaWYgKE4gIT0gbnVsbCAmJiBFICE9IG51bGwgJiYgTi5sZW5ndGggPiAwICYmIEUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5uID0gcGFyc2VCaWdJbnQoTiwgMTYpO1xuICAgICAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgUlNBIHB1YmxpYyBrZXlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZW5jcnlwdCA9IFJTQUVuY3J5cHQ7XG4gICAgLy8gUmV0dXJuIHRoZSBQS0NTIzEgUlNBIGVuY3J5cHRpb24gb2YgXCJ0ZXh0XCIgYXMgYW4gZXZlbi1sZW5ndGggaGV4IHN0cmluZ1xuICAgIFJTQUtleS5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciBtID0gcGtjczFwYWQyKHRleHQsICh0aGlzLm4uYml0TGVuZ3RoKCkgKyA3KSA+PiAzKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSB0aGlzLmRvUHVibGljKG0pO1xuICAgICAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoKGgubGVuZ3RoICYgMSkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCIgKyBoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGUgPSBSU0FTZXRQcml2YXRlO1xuICAgIC8vIFNldCB0aGUgcHJpdmF0ZSBrZXkgZmllbGRzIE4sIGUsIGFuZCBkIGZyb20gaGV4IHN0cmluZ3NcbiAgICBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGUgPSBmdW5jdGlvbiAoTiwgRSwgRCkge1xuICAgICAgICBpZiAoTiAhPSBudWxsICYmIEUgIT0gbnVsbCAmJiBOLmxlbmd0aCA+IDAgJiYgRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChOLCAxNik7XG4gICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgICAgICB0aGlzLmQgPSBwYXJzZUJpZ0ludChELCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBSU0EgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZUV4ID0gUlNBU2V0UHJpdmF0ZUV4O1xuICAgIC8vIFNldCB0aGUgcHJpdmF0ZSBrZXkgZmllbGRzIE4sIGUsIGQgYW5kIENSVCBwYXJhbXMgZnJvbSBoZXggc3RyaW5nc1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZUV4ID0gZnVuY3Rpb24gKE4sIEUsIEQsIFAsIFEsIERQLCBEUSwgQykge1xuICAgICAgICBpZiAoTiAhPSBudWxsICYmIEUgIT0gbnVsbCAmJiBOLmxlbmd0aCA+IDAgJiYgRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChOLCAxNik7XG4gICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgICAgICB0aGlzLmQgPSBwYXJzZUJpZ0ludChELCAxNik7XG4gICAgICAgICAgICB0aGlzLnAgPSBwYXJzZUJpZ0ludChQLCAxNik7XG4gICAgICAgICAgICB0aGlzLnEgPSBwYXJzZUJpZ0ludChRLCAxNik7XG4gICAgICAgICAgICB0aGlzLmRtcDEgPSBwYXJzZUJpZ0ludChEUCwgMTYpO1xuICAgICAgICAgICAgdGhpcy5kbXExID0gcGFyc2VCaWdJbnQoRFEsIDE2KTtcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSBwYXJzZUJpZ0ludChDLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBSU0EgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZ2VuZXJhdGUgPSBSU0FHZW5lcmF0ZTtcbiAgICAvLyBHZW5lcmF0ZSBhIG5ldyByYW5kb20gcHJpdmF0ZSBrZXkgQiBiaXRzIGxvbmcsIHVzaW5nIHB1YmxpYyBleHB0IEVcbiAgICBSU0FLZXkucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKEIsIEUpIHtcbiAgICAgICAgdmFyIHJuZyA9IG5ldyBTZWN1cmVSYW5kb20oKTtcbiAgICAgICAgdmFyIHFzID0gQiA+PiAxO1xuICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XG4gICAgICAgIHZhciBlZSA9IG5ldyBCaWdJbnRlZ2VyKEUsIDE2KTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMucCA9IG5ldyBCaWdJbnRlZ2VyKEIgLSBxcywgMSwgcm5nKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2QoZWUpLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCAmJiB0aGlzLnAuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xID0gbmV3IEJpZ0ludGVnZXIocXMsIDEsIHJuZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKGVlKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDAgJiYgdGhpcy5xLmlzUHJvYmFibGVQcmltZSgxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucC5jb21wYXJlVG8odGhpcy5xKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnA7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5xO1xuICAgICAgICAgICAgICAgIHRoaXMucSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcDEgPSB0aGlzLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICAgICAgdmFyIHExID0gdGhpcy5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgICAgIHZhciBwaGkgPSBwMS5tdWx0aXBseShxMSk7XG4gICAgICAgICAgICBpZiAocGhpLmdjZChlZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uID0gdGhpcy5wLm11bHRpcGx5KHRoaXMucSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kID0gZWUubW9kSW52ZXJzZShwaGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG1wMSA9IHRoaXMuZC5tb2QocDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG1xMSA9IHRoaXMuZC5tb2QocTEpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZmYgPSB0aGlzLnEubW9kSW52ZXJzZSh0aGlzLnApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLmRlY3J5cHQgPSBSU0FEZWNyeXB0O1xuICAgIC8vIFJldHVybiB0aGUgUEtDUyMxIFJTQSBkZWNyeXB0aW9uIG9mIFwiY3RleHRcIi5cbiAgICAvLyBcImN0ZXh0XCIgaXMgYW4gZXZlbi1sZW5ndGggaGV4IHN0cmluZyBhbmQgdGhlIG91dHB1dCBpcyBhIHBsYWluIHN0cmluZy5cbiAgICBSU0FLZXkucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoY3RleHQpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUJpZ0ludChjdGV4dCwgMTYpO1xuICAgICAgICB2YXIgbSA9IHRoaXMuZG9Qcml2YXRlKGMpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGtjczF1bnBhZDIobSwgKHRoaXMubi5iaXRMZW5ndGgoKSArIDcpID4+IDMpO1xuICAgIH07XG4gICAgLy8gR2VuZXJhdGUgYSBuZXcgcmFuZG9tIHByaXZhdGUga2V5IEIgYml0cyBsb25nLCB1c2luZyBwdWJsaWMgZXhwdCBFXG4gICAgUlNBS2V5LnByb3RvdHlwZS5nZW5lcmF0ZUFzeW5jID0gZnVuY3Rpb24gKEIsIEUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBybmcgPSBuZXcgU2VjdXJlUmFuZG9tKCk7XG4gICAgICAgIHZhciBxcyA9IEIgPj4gMTtcbiAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xuICAgICAgICB2YXIgZWUgPSBuZXcgQmlnSW50ZWdlcihFLCAxNik7XG4gICAgICAgIHZhciByc2EgPSB0aGlzO1xuICAgICAgICAvLyBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBub24tZGVzY3JpcHQgbmFtZXMgYmVjYXVzZSB0aGV5IHdlcmUgb3JpZ2luYWxseSBmb3IoOzspIGxvb3BzLlxuICAgICAgICAvLyBJIGRvbid0IGtub3cgYWJvdXQgY3J5cHRvZ3JhcGh5IHRvIGdpdmUgdGhlbSBiZXR0ZXIgbmFtZXMgdGhhbiBsb29wMS00LlxuICAgICAgICB2YXIgbG9vcDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9vcDQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJzYS5wLmNvbXBhcmVUbyhyc2EucSkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHJzYS5wO1xuICAgICAgICAgICAgICAgICAgICByc2EucCA9IHJzYS5xO1xuICAgICAgICAgICAgICAgICAgICByc2EucSA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwMSA9IHJzYS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgICAgICAgICB2YXIgcTEgPSByc2EucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgICAgICAgICAgdmFyIHBoaSA9IHAxLm11bHRpcGx5KHExKTtcbiAgICAgICAgICAgICAgICBpZiAocGhpLmdjZChlZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5uID0gcnNhLnAubXVsdGlwbHkocnNhLnEpO1xuICAgICAgICAgICAgICAgICAgICByc2EuZCA9IGVlLm1vZEludmVyc2UocGhpKTtcbiAgICAgICAgICAgICAgICAgICAgcnNhLmRtcDEgPSByc2EuZC5tb2QocDEpO1xuICAgICAgICAgICAgICAgICAgICByc2EuZG1xMSA9IHJzYS5kLm1vZChxMSk7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5jb2VmZiA9IHJzYS5xLm1vZEludmVyc2UocnNhLnApO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soKTsgfSwgMCk7IC8vIGVzY2FwZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wMSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBsb29wMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByc2EucSA9IG5iaSgpO1xuICAgICAgICAgICAgICAgIHJzYS5xLmZyb21OdW1iZXJBc3luYyhxcywgMSwgcm5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2RhKGVlLCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwICYmIHJzYS5xLmlzUHJvYmFibGVQcmltZSgxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3A0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDMsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbG9vcDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnNhLnAgPSBuYmkoKTtcbiAgICAgICAgICAgICAgICByc2EucC5mcm9tTnVtYmVyQXN5bmMoQiAtIHFzLCAxLCBybmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcnNhLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZGEoZWUsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDAgJiYgcnNhLnAuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDMsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDIsIDApO1xuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KGxvb3AxLCAwKTtcbiAgICB9O1xuICAgIFJTQUtleS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uICh0ZXh0LCBkaWdlc3RNZXRob2QsIGRpZ2VzdE5hbWUpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IGdldERpZ2VzdEhlYWRlcihkaWdlc3ROYW1lKTtcbiAgICAgICAgdmFyIGRpZ2VzdCA9IGhlYWRlciArIGRpZ2VzdE1ldGhvZCh0ZXh0KS50b1N0cmluZygpO1xuICAgICAgICB2YXIgbSA9IHBrY3MxcGFkMShkaWdlc3QsIHRoaXMubi5iaXRMZW5ndGgoKSAvIDQpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHRoaXMuZG9Qcml2YXRlKG0pO1xuICAgICAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoKGgubGVuZ3RoICYgMSkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCIgKyBoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSU0FLZXkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uICh0ZXh0LCBzaWduYXR1cmUsIGRpZ2VzdE1ldGhvZCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlQmlnSW50KHNpZ25hdHVyZSwgMTYpO1xuICAgICAgICB2YXIgbSA9IHRoaXMuZG9QdWJsaWMoYyk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bnBhZGRlZCA9IG0udG9TdHJpbmcoMTYpLnJlcGxhY2UoL14xZiswMC8sIFwiXCIpO1xuICAgICAgICB2YXIgZGlnZXN0ID0gcmVtb3ZlRGlnZXN0SGVhZGVyKHVucGFkZGVkKTtcbiAgICAgICAgcmV0dXJuIGRpZ2VzdCA9PSBkaWdlc3RNZXRob2QodGV4dCkudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBSU0FLZXk7XG59KCkpO1xuLy8gVW5kbyBQS0NTIzEgKHR5cGUgMiwgcmFuZG9tKSBwYWRkaW5nIGFuZCwgaWYgdmFsaWQsIHJldHVybiB0aGUgcGxhaW50ZXh0XG5mdW5jdGlvbiBwa2NzMXVucGFkMihkLCBuKSB7XG4gICAgdmFyIGIgPSBkLnRvQnl0ZUFycmF5KCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYi5sZW5ndGggJiYgYltpXSA9PSAwKSB7XG4gICAgICAgICsraTtcbiAgICB9XG4gICAgaWYgKGIubGVuZ3RoIC0gaSAhPSBuIC0gMSB8fCBiW2ldICE9IDIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgICsraTtcbiAgICB3aGlsZSAoYltpXSAhPSAwKSB7XG4gICAgICAgIGlmICgrK2kgPj0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHdoaWxlICgrK2kgPCBiLmxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IGJbaV0gJiAyNTU7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7IC8vIHV0Zi04IGRlY29kZVxuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgPiAxOTEpICYmIChjIDwgMjI0KSkge1xuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMzEpIDw8IDYpIHwgKGJbaSArIDFdICYgNjMpKTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDE1KSA8PCAxMikgfCAoKGJbaSArIDFdICYgNjMpIDw8IDYpIHwgKGJbaSArIDJdICYgNjMpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NDcjcGFnZS00M1xudmFyIERJR0VTVF9IRUFERVJTID0ge1xuICAgIG1kMjogXCIzMDIwMzAwYzA2MDgyYTg2NDg4NmY3MGQwMjAyMDUwMDA0MTBcIixcbiAgICBtZDU6IFwiMzAyMDMwMGMwNjA4MmE4NjQ4ODZmNzBkMDIwNTA1MDAwNDEwXCIsXG4gICAgc2hhMTogXCIzMDIxMzAwOTA2MDUyYjBlMDMwMjFhMDUwMDA0MTRcIixcbiAgICBzaGEyMjQ6IFwiMzAyZDMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjA0MDUwMDA0MWNcIixcbiAgICBzaGEyNTY6IFwiMzAzMTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAxMDUwMDA0MjBcIixcbiAgICBzaGEzODQ6IFwiMzA0MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAyMDUwMDA0MzBcIixcbiAgICBzaGE1MTI6IFwiMzA1MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAzMDUwMDA0NDBcIixcbiAgICByaXBlbWQxNjA6IFwiMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0XCIsXG59O1xuZnVuY3Rpb24gZ2V0RGlnZXN0SGVhZGVyKG5hbWUpIHtcbiAgICByZXR1cm4gRElHRVNUX0hFQURFUlNbbmFtZV0gfHwgXCJcIjtcbn1cbmZ1bmN0aW9uIHJlbW92ZURpZ2VzdEhlYWRlcihzdHIpIHtcbiAgICBmb3IgKHZhciBuYW1lXzEgaW4gRElHRVNUX0hFQURFUlMpIHtcbiAgICAgICAgaWYgKERJR0VTVF9IRUFERVJTLmhhc093blByb3BlcnR5KG5hbWVfMSkpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBESUdFU1RfSEVBREVSU1tuYW1lXzFdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGhlYWRlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3RyLnN1YnN0cigwLCBsZW4pID09IGhlYWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8vIFJldHVybiB0aGUgUEtDUyMxIFJTQSBlbmNyeXB0aW9uIG9mIFwidGV4dFwiIGFzIGEgQmFzZTY0LWVuY29kZWQgc3RyaW5nXG4vLyBmdW5jdGlvbiBSU0FFbmNyeXB0QjY0KHRleHQpIHtcbi8vICB2YXIgaCA9IHRoaXMuZW5jcnlwdCh0ZXh0KTtcbi8vICBpZihoKSByZXR1cm4gaGV4MmI2NChoKTsgZWxzZSByZXR1cm4gbnVsbDtcbi8vIH1cbi8vIHB1YmxpY1xuLy8gUlNBS2V5LnByb3RvdHlwZS5lbmNyeXB0X2I2NCA9IFJTQUVuY3J5cHRCNjQ7XG5cbi8qIVxuQ29weXJpZ2h0IChjKSAyMDExLCBZYWhvbyEgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuQ29kZSBsaWNlbnNlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2U6XG5odHRwOi8vZGV2ZWxvcGVyLnlhaG9vLmNvbS95dWkvbGljZW5zZS5odG1sXG52ZXJzaW9uOiAyLjkuMFxuKi9cbnZhciBZQUhPTyA9IHt9O1xuWUFIT08ubGFuZyA9IHtcbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHRvIHNldCB1cCB0aGUgcHJvdG90eXBlLCBjb25zdHJ1Y3RvciBhbmQgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzIHRvXG4gICAgICogc3VwcG9ydCBhbiBpbmhlcml0YW5jZSBzdHJhdGVneSB0aGF0IGNhbiBjaGFpbiBjb25zdHJ1Y3RvcnMgYW5kIG1ldGhvZHMuXG4gICAgICogU3RhdGljIG1lbWJlcnMgd2lsbCBub3QgYmUgaW5oZXJpdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBleHRlbmRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViYyAgIHRoZSBvYmplY3QgdG8gbW9kaWZ5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjIHRoZSBvYmplY3QgdG8gaW5oZXJpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgIGFkZGl0aW9uYWwgcHJvcGVydGllcy9tZXRob2RzIHRvIGFkZCB0byB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNsYXNzIHByb3RvdHlwZS4gIFRoZXNlIHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZyBpdGVtcyBvYnRhaW5lZCBmcm9tIHRoZSBzdXBlcmNsYXNzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwcmVzZW50LlxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24oc3ViYywgc3VwZXJjLCBvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCEgc3VwZXJjIHx8ICEgc3ViYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWUFIT08ubGFuZy5leHRlbmQgZmFpbGVkLCBwbGVhc2UgY2hlY2sgdGhhdCBcIiArXG4gICAgICAgICAgICAgICAgXCJhbGwgZGVwZW5kZW5jaWVzIGFyZSBpbmNsdWRlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIEYucHJvdG90eXBlID0gc3VwZXJjLnByb3RvdHlwZTtcbiAgICAgICAgc3ViYy5wcm90b3R5cGUgPSBuZXcgRigpO1xuICAgICAgICBzdWJjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YmM7XG4gICAgICAgIHN1YmMuc3VwZXJjbGFzcyA9IHN1cGVyYy5wcm90b3R5cGU7XG5cbiAgICAgICAgaWYgKHN1cGVyYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgc3VwZXJjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1cGVyYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpIGluIG92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgIHN1YmMucHJvdG90eXBlW2ldID0gb3ZlcnJpZGVzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSUUgd2lsbCBub3QgZW51bWVyYXRlIG5hdGl2ZSBmdW5jdGlvbnMgaW4gYSBkZXJpdmVkIG9iamVjdCBldmVuIGlmIHRoZVxuICAgICAgICAgICAgICogZnVuY3Rpb24gd2FzIG92ZXJyaWRkZW4uICBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3Igc3BlY2lmaWMgZnVuY3Rpb25zXG4gICAgICAgICAgICAgKiB3ZSBjYXJlIGFib3V0IG9uIHRoZSBPYmplY3QgcHJvdG90eXBlLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IF9JRUVudW1GaXhcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHIgIHRoZSBvYmplY3QgdG8gcmVjZWl2ZSB0aGUgYXVnbWVudGF0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzICB0aGUgb2JqZWN0IHRoYXQgc3VwcGxpZXMgdGhlIHByb3BlcnRpZXMgdG8gYXVnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIF9JRUVudW1GaXggPSBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgICAgIEFERCA9IFtcInRvU3RyaW5nXCIsIFwidmFsdWVPZlwiXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKC9NU0lFLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9JRUVudW1GaXggPSBmdW5jdGlvbihyLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQURELmxlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuYW1lID0gQUREW2ldLCBmID0gc1tmbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nICYmIGYgIT0gT2JqZWN0LnByb3RvdHlwZVtmbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcltmbmFtZV0gPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge30gICAgICAgICAgICBfSUVFbnVtRml4KHN1YmMucHJvdG90eXBlLCBvdmVycmlkZXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyogYXNuMS0xLjAuMTMuanMgKGMpIDIwMTMtMjAxNyBLZW5qaSBVcnVzaGltYSB8IGtqdXIuZ2l0aHViLmNvbS9qc3JzYXNpZ24vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGZpbGVPdmVydmlld1xuICogQG5hbWUgYXNuMS0xLjAuanNcbiAqIEBhdXRob3IgS2VuamkgVXJ1c2hpbWEga2VuamkudXJ1c2hpbWFAZ21haWwuY29tXG4gKiBAdmVyc2lvbiBhc24xIDEuMC4xMyAoMjAxNy1KdW4tMDIpXG4gKiBAc2luY2UganNyc2FzaWduIDIuMVxuICogQGxpY2Vuc2UgPGEgaHJlZj1cImh0dHBzOi8va2p1ci5naXRodWIuaW8vanNyc2FzaWduL2xpY2Vuc2UvXCI+TUlUIExpY2Vuc2U8L2E+XG4gKi9cblxuLyoqXG4gKiBranVyJ3MgY2xhc3MgbGlicmFyeSBuYW1lIHNwYWNlXG4gKiA8cD5cbiAqIFRoaXMgbmFtZSBzcGFjZSBwcm92aWRlcyBmb2xsb3dpbmcgbmFtZSBzcGFjZXM6XG4gKiA8dWw+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMX0gLSBBU04uMSBwcmltaXRpdmUgaGV4YWRlY2ltYWwgZW5jb2RlcjwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS54NTA5fSAtIEFTTi4xIHN0cnVjdHVyZSBmb3IgWC41MDkgY2VydGlmaWNhdGUgYW5kIENSTDwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuY3J5cHRvfSAtIEphdmEgQ3J5cHRvZ3JhcGhpYyBFeHRlbnNpb24oSkNFKSBzdHlsZSBNZXNzYWdlRGlnZXN0L1NpZ25hdHVyZVxuICogY2xhc3MgYW5kIHV0aWxpdGllczwvbGk+XG4gKiA8L3VsPlxuICogPC9wPlxuICogTk9URTogUGxlYXNlIGlnbm9yZSBtZXRob2Qgc3VtbWFyeSBhbmQgZG9jdW1lbnQgb2YgdGhpcyBuYW1lc3BhY2UuIFRoaXMgY2F1c2VkIGJ5IGEgYnVnIG9mIGpzZG9jMi5cbiAqIEBuYW1lIEtKVVJcbiAqIEBuYW1lc3BhY2Uga2p1cidzIGNsYXNzIGxpYnJhcnkgbmFtZSBzcGFjZVxuICovXG52YXIgS0pVUiA9IHt9O1xuXG4vKipcbiAqIGtqdXIncyBBU04uMSBjbGFzcyBsaWJyYXJ5IG5hbWUgc3BhY2VcbiAqIDxwPlxuICogVGhpcyBpcyBJVFUtVCBYLjY5MCBBU04uMSBERVIgZW5jb2RlciBjbGFzcyBsaWJyYXJ5IGFuZFxuICogY2xhc3Mgc3RydWN0dXJlIGFuZCBtZXRob2RzIGlzIHZlcnkgc2ltaWxhciB0b1xuICogb3JnLmJvdW5jeWNhc3RsZS5hc24xIHBhY2thZ2Ugb2ZcbiAqIHdlbGwga25vd24gQm91bmN5Q2FzbHRlIENyeXB0b2dyYXBoeSBMaWJyYXJ5LlxuICogPGg0PlBST1ZJRElORyBBU04uMSBQUklNSVRJVkVTPC9oND5cbiAqIEhlcmUgYXJlIEFTTi4xIERFUiBwcmltaXRpdmUgY2xhc3Nlcy5cbiAqIDx1bD5cbiAqIDxsaT4weDAxIHtAbGluayBLSlVSLmFzbjEuREVSQm9vbGVhbn08L2xpPlxuICogPGxpPjB4MDIge0BsaW5rIEtKVVIuYXNuMS5ERVJJbnRlZ2VyfTwvbGk+XG4gKiA8bGk+MHgwMyB7QGxpbmsgS0pVUi5hc24xLkRFUkJpdFN0cmluZ308L2xpPlxuICogPGxpPjB4MDQge0BsaW5rIEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZ308L2xpPlxuICogPGxpPjB4MDUge0BsaW5rIEtKVVIuYXNuMS5ERVJOdWxsfTwvbGk+XG4gKiA8bGk+MHgwNiB7QGxpbmsgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXJ9PC9saT5cbiAqIDxsaT4weDBhIHtAbGluayBLSlVSLmFzbjEuREVSRW51bWVyYXRlZH08L2xpPlxuICogPGxpPjB4MGMge0BsaW5rIEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxMiB7QGxpbmsgS0pVUi5hc24xLkRFUk51bWVyaWNTdHJpbmd9PC9saT5cbiAqIDxsaT4weDEzIHtAbGluayBLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxNCB7QGxpbmsgS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmd9PC9saT5cbiAqIDxsaT4weDE2IHtAbGluayBLSlVSLmFzbjEuREVSSUE1U3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxNyB7QGxpbmsgS0pVUi5hc24xLkRFUlVUQ1RpbWV9PC9saT5cbiAqIDxsaT4weDE4IHtAbGluayBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lfTwvbGk+XG4gKiA8bGk+MHgzMCB7QGxpbmsgS0pVUi5hc24xLkRFUlNlcXVlbmNlfTwvbGk+XG4gKiA8bGk+MHgzMSB7QGxpbmsgS0pVUi5hc24xLkRFUlNldH08L2xpPlxuICogPC91bD5cbiAqIDxoND5PVEhFUiBBU04uMSBDTEFTU0VTPC9oND5cbiAqIDx1bD5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkFTTjFPYmplY3R9PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nfTwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWV9PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZH08L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0fTwvbGk+XG4gKiA8L3VsPlxuICogPGg0PlNVQiBOQU1FIFNQQUNFUzwvaDQ+XG4gKiA8dWw+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jYWRlc30gLSBDQWRFUyBsb25nIHRlcm0gc2lnbmF0dXJlIGZvcm1hdDwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jbXN9IC0gQ3J5cHRvZ3JhcGhpYyBNZXNzYWdlIFN5bnRheDwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jc3J9IC0gQ2VydGlmaWNhdGUgU2lnbmluZyBSZXF1ZXN0IChDU1IvUEtDUyMxMCk8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEudHNwfSAtIFJGQyAzMTYxIFRpbWVzdGFtcGluZyBQcm90b2NvbCBGb3JtYXQ8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEueDUwOX0gLSBSRkMgNTI4MCBYLjUwOSBjZXJ0aWZpY2F0ZSBhbmQgQ1JMPC9saT5cbiAqIDwvdWw+XG4gKiA8L3A+XG4gKiBOT1RFOiBQbGVhc2UgaWdub3JlIG1ldGhvZCBzdW1tYXJ5IGFuZCBkb2N1bWVudCBvZiB0aGlzIG5hbWVzcGFjZS5cbiAqIFRoaXMgY2F1c2VkIGJ5IGEgYnVnIG9mIGpzZG9jMi5cbiAqIEBuYW1lIEtKVVIuYXNuMVxuICogQG5hbWVzcGFjZVxuICovXG5pZiAodHlwZW9mIEtKVVIuYXNuMSA9PSBcInVuZGVmaW5lZFwiIHx8ICFLSlVSLmFzbjEpIEtKVVIuYXNuMSA9IHt9O1xuXG4vKipcbiAqIEFTTjEgdXRpbGl0aWVzIGNsYXNzXG4gKiBAbmFtZSBLSlVSLmFzbjEuQVNOMVV0aWxcbiAqIEBjbGFzcyBBU04xIHV0aWxpdGllcyBjbGFzc1xuICogQHNpbmNlIGFzbjEgMS4wLjJcbiAqL1xuS0pVUi5hc24xLkFTTjFVdGlsID0gbmV3IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW50ZWdlclRvQnl0ZUhleCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIGggPSBpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKChoLmxlbmd0aCAlIDIpID09IDEpIGggPSAnMCcgKyBoO1xuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuICAgIHRoaXMuYmlnSW50VG9NaW5Ud29zQ29tcGxlbWVudHNIZXggPSBmdW5jdGlvbihiaWdJbnRlZ2VyVmFsdWUpIHtcbiAgICAgICAgdmFyIGggPSBiaWdJbnRlZ2VyVmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaC5zdWJzdHIoMCwgMSkgIT0gJy0nKSB7XG4gICAgICAgICAgICBpZiAoaC5sZW5ndGggJSAyID09IDEpIHtcbiAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEgaC5tYXRjaCgvXlswLTddLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9ICcwMCcgKyBoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoUG9zID0gaC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB2YXIgeG9yTGVuID0gaFBvcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoeG9yTGVuICUgMiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgeG9yTGVuICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghIGgubWF0Y2goL15bMC03XS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHhvckxlbiArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoTWFzayA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4b3JMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGhNYXNrICs9ICdmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaU1hc2sgPSBuZXcgQmlnSW50ZWdlcihoTWFzaywgMTYpO1xuICAgICAgICAgICAgdmFyIGJpTmVnID0gYmlNYXNrLnhvcihiaWdJbnRlZ2VyVmFsdWUpLmFkZChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgICAgICBoID0gYmlOZWcudG9TdHJpbmcoMTYpLnJlcGxhY2UoL14tLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0IFBFTSBzdHJpbmcgZnJvbSBoZXhhZGVjaW1hbCBkYXRhIGFuZCBoZWFkZXIgc3RyaW5nXG4gICAgICogQG5hbWUgZ2V0UEVNU3RyaW5nRnJvbUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUhleCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgUEVNIGJvZHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGVtSGVhZGVyIFBFTSBoZWFkZXIgc3RyaW5nIChleC4gJ1JTQSBQUklWQVRFIEtFWScpXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBQRU0gZm9ybWF0dGVkIHN0cmluZyBvZiBpbnB1dCBkYXRhXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhpcyBtZXRob2QgY29udmVydHMgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBQRU0gc3RyaW5nIHdpdGhcbiAgICAgKiBhIHNwZWNpZmllZCBoZWFkZXIuIEl0cyBsaW5lIGJyZWFrIHdpbGwgYmUgQ1JMRihcIlxcclxcblwiKS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwZW0gID0gS0pVUi5hc24xLkFTTjFVdGlsLmdldFBFTVN0cmluZ0Zyb21IZXgoJzYxNjE2MScsICdSU0EgUFJJVkFURSBLRVknKTtcbiAgICAgKiAvLyB2YWx1ZSBvZiBwZW0gd2lsbCBiZTpcbiAgICAgKiAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cbiAgICAgKiBZV0ZoXG4gICAgICogLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UEVNU3RyaW5nRnJvbUhleCA9IGZ1bmN0aW9uKGRhdGFIZXgsIHBlbUhlYWRlcikge1xuICAgICAgICByZXR1cm4gaGV4dG9wZW0oZGF0YUhleCwgcGVtSGVhZGVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgQVNOMU9iamVjdCBzcGVjaWZlZCBieSBKU09OIHBhcmFtZXRlcnNcbiAgICAgKiBAbmFtZSBuZXdPYmplY3RcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW0gSlNPTiBwYXJhbWV0ZXIgdG8gZ2VuZXJhdGUgQVNOMU9iamVjdFxuICAgICAqIEByZXR1cm4ge0tKVVIuYXNuMS5BU04xT2JqZWN0fSBnZW5lcmF0ZWQgb2JqZWN0XG4gICAgICogQHNpbmNlIGFzbjEgMS4wLjNcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBnZW5lcmF0ZSBhbnkgQVNOMU9iamVjdCBzcGVjaWZpZWQgYnkgSlNPTiBwYXJhbVxuICAgICAqIGluY2x1ZGluZyBBU04uMSBwcmltaXRpdmUgb3Igc3RydWN0dXJlZC5cbiAgICAgKiBHZW5lcmFsbHkgJ3BhcmFtJyBjYW4gYmUgZGVzY3JpYmVkIGFzIGZvbGxvd3M6XG4gICAgICogPGJsb2NrcXVvdGU+XG4gICAgICoge1RZUEUtT0YtQVNOT0JKOiBBU04xT0JKLVBBUkFNRVRFUn1cbiAgICAgKiA8L2Jsb2NrcXVvdGU+XG4gICAgICogJ1RZUEUtT0YtQVNOMU9CSicgY2FuIGJlIG9uZSBvZiBmb2xsb3dpbmcgc3ltYm9sczpcbiAgICAgKiA8dWw+XG4gICAgICogPGxpPidib29sJyAtIERFUkJvb2xlYW48L2xpPlxuICAgICAqIDxsaT4naW50JyAtIERFUkludGVnZXI8L2xpPlxuICAgICAqIDxsaT4nYml0c3RyJyAtIERFUkJpdFN0cmluZzwvbGk+XG4gICAgICogPGxpPidvY3RzdHInIC0gREVST2N0ZXRTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4nbnVsbCcgLSBERVJOdWxsPC9saT5cbiAgICAgKiA8bGk+J29pZCcgLSBERVJPYmplY3RJZGVudGlmaWVyPC9saT5cbiAgICAgKiA8bGk+J2VudW0nIC0gREVSRW51bWVyYXRlZDwvbGk+XG4gICAgICogPGxpPid1dGY4c3RyJyAtIERFUlVURjhTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4nbnVtc3RyJyAtIERFUk51bWVyaWNTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4ncHJuc3RyJyAtIERFUlByaW50YWJsZVN0cmluZzwvbGk+XG4gICAgICogPGxpPid0ZWxzdHInIC0gREVSVGVsZXRleFN0cmluZzwvbGk+XG4gICAgICogPGxpPidpYTVzdHInIC0gREVSSUE1U3RyaW5nPC9saT5cbiAgICAgKiA8bGk+J3V0Y3RpbWUnIC0gREVSVVRDVGltZTwvbGk+XG4gICAgICogPGxpPidnZW50aW1lJyAtIERFUkdlbmVyYWxpemVkVGltZTwvbGk+XG4gICAgICogPGxpPidzZXEnIC0gREVSU2VxdWVuY2U8L2xpPlxuICAgICAqIDxsaT4nc2V0JyAtIERFUlNldDwvbGk+XG4gICAgICogPGxpPid0YWcnIC0gREVSVGFnZ2VkT2JqZWN0PC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbmV3T2JqZWN0KHsncHJuc3RyJzogJ2FhYSd9KTtcbiAgICAgKiBuZXdPYmplY3QoeydzZXEnOiBbeydpbnQnOiAzfSwgeydwcm5zdHInOiAnYWFhJ31dfSlcbiAgICAgKiAvLyBBU04uMSBUYWdnZWQgT2JqZWN0XG4gICAgICogbmV3T2JqZWN0KHsndGFnJzogeyd0YWcnOiAnYTEnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAnZXhwbGljaXQnOiB0cnVlLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAnb2JqJzogeydzZXEnOiBbeydpbnQnOiAzfSwgeydwcm5zdHInOiAnYWFhJ31dfX19KTtcbiAgICAgKiAvLyBtb3JlIHNpbXBsZSByZXByZXNlbnRhdGlvbiBvZiBBU04uMSBUYWdnZWQgT2JqZWN0XG4gICAgICogbmV3T2JqZWN0KHsndGFnJzogWydhMScsXG4gICAgICogICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICogICAgICAgICAgICAgICAgICAgIHsnc2VxJzogW1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHsnaW50JzogM30sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgeydwcm5zdHInOiAnYWFhJ31dfVxuICAgICAqICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgKi9cbiAgICB0aGlzLm5ld09iamVjdCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHZhciBfS0pVUiA9IEtKVVIsXG4gICAgICAgICAgICBfS0pVUl9hc24xID0gX0tKVVIuYXNuMSxcbiAgICAgICAgICAgIF9ERVJCb29sZWFuID0gX0tKVVJfYXNuMS5ERVJCb29sZWFuLFxuICAgICAgICAgICAgX0RFUkludGVnZXIgPSBfS0pVUl9hc24xLkRFUkludGVnZXIsXG4gICAgICAgICAgICBfREVSQml0U3RyaW5nID0gX0tKVVJfYXNuMS5ERVJCaXRTdHJpbmcsXG4gICAgICAgICAgICBfREVST2N0ZXRTdHJpbmcgPSBfS0pVUl9hc24xLkRFUk9jdGV0U3RyaW5nLFxuICAgICAgICAgICAgX0RFUk51bGwgPSBfS0pVUl9hc24xLkRFUk51bGwsXG4gICAgICAgICAgICBfREVST2JqZWN0SWRlbnRpZmllciA9IF9LSlVSX2FzbjEuREVST2JqZWN0SWRlbnRpZmllcixcbiAgICAgICAgICAgIF9ERVJFbnVtZXJhdGVkID0gX0tKVVJfYXNuMS5ERVJFbnVtZXJhdGVkLFxuICAgICAgICAgICAgX0RFUlVURjhTdHJpbmcgPSBfS0pVUl9hc24xLkRFUlVURjhTdHJpbmcsXG4gICAgICAgICAgICBfREVSTnVtZXJpY1N0cmluZyA9IF9LSlVSX2FzbjEuREVSTnVtZXJpY1N0cmluZyxcbiAgICAgICAgICAgIF9ERVJQcmludGFibGVTdHJpbmcgPSBfS0pVUl9hc24xLkRFUlByaW50YWJsZVN0cmluZyxcbiAgICAgICAgICAgIF9ERVJUZWxldGV4U3RyaW5nID0gX0tKVVJfYXNuMS5ERVJUZWxldGV4U3RyaW5nLFxuICAgICAgICAgICAgX0RFUklBNVN0cmluZyA9IF9LSlVSX2FzbjEuREVSSUE1U3RyaW5nLFxuICAgICAgICAgICAgX0RFUlVUQ1RpbWUgPSBfS0pVUl9hc24xLkRFUlVUQ1RpbWUsXG4gICAgICAgICAgICBfREVSR2VuZXJhbGl6ZWRUaW1lID0gX0tKVVJfYXNuMS5ERVJHZW5lcmFsaXplZFRpbWUsXG4gICAgICAgICAgICBfREVSU2VxdWVuY2UgPSBfS0pVUl9hc24xLkRFUlNlcXVlbmNlLFxuICAgICAgICAgICAgX0RFUlNldCA9IF9LSlVSX2FzbjEuREVSU2V0LFxuICAgICAgICAgICAgX0RFUlRhZ2dlZE9iamVjdCA9IF9LSlVSX2FzbjEuREVSVGFnZ2VkT2JqZWN0LFxuICAgICAgICAgICAgX25ld09iamVjdCA9IF9LSlVSX2FzbjEuQVNOMVV0aWwubmV3T2JqZWN0O1xuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFyYW0pO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggIT0gMSlcbiAgICAgICAgICAgIHRocm93IFwia2V5IG9mIHBhcmFtIHNoYWxsIGJlIG9ubHkgb25lLlwiO1xuICAgICAgICB2YXIga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBpZiAoXCI6Ym9vbDppbnQ6Yml0c3RyOm9jdHN0cjpudWxsOm9pZDplbnVtOnV0ZjhzdHI6bnVtc3RyOnBybnN0cjp0ZWxzdHI6aWE1c3RyOnV0Y3RpbWU6Z2VudGltZTpzZXE6c2V0OnRhZzpcIi5pbmRleE9mKFwiOlwiICsga2V5ICsgXCI6XCIpID09IC0xKVxuICAgICAgICAgICAgdGhyb3cgXCJ1bmRlZmluZWQga2V5OiBcIiArIGtleTtcblxuICAgICAgICBpZiAoa2V5ID09IFwiYm9vbFwiKSAgICByZXR1cm4gbmV3IF9ERVJCb29sZWFuKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiaW50XCIpICAgICByZXR1cm4gbmV3IF9ERVJJbnRlZ2VyKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiYml0c3RyXCIpICByZXR1cm4gbmV3IF9ERVJCaXRTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJvY3RzdHJcIikgIHJldHVybiBuZXcgX0RFUk9jdGV0U3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwibnVsbFwiKSAgICByZXR1cm4gbmV3IF9ERVJOdWxsKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwib2lkXCIpICAgICByZXR1cm4gbmV3IF9ERVJPYmplY3RJZGVudGlmaWVyKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiZW51bVwiKSAgICByZXR1cm4gbmV3IF9ERVJFbnVtZXJhdGVkKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwidXRmOHN0clwiKSByZXR1cm4gbmV3IF9ERVJVVEY4U3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwibnVtc3RyXCIpICByZXR1cm4gbmV3IF9ERVJOdW1lcmljU3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwicHJuc3RyXCIpICByZXR1cm4gbmV3IF9ERVJQcmludGFibGVTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJ0ZWxzdHJcIikgIHJldHVybiBuZXcgX0RFUlRlbGV0ZXhTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJpYTVzdHJcIikgIHJldHVybiBuZXcgX0RFUklBNVN0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcInV0Y3RpbWVcIikgcmV0dXJuIG5ldyBfREVSVVRDVGltZShwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcImdlbnRpbWVcIikgcmV0dXJuIG5ldyBfREVSR2VuZXJhbGl6ZWRUaW1lKHBhcmFtW2tleV0pO1xuXG4gICAgICAgIGlmIChrZXkgPT0gXCJzZXFcIikge1xuICAgICAgICAgICAgdmFyIHBhcmFtTGlzdCA9IHBhcmFtW2tleV07XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXNuMU9iaiA9IF9uZXdPYmplY3QocGFyYW1MaXN0W2ldKTtcbiAgICAgICAgICAgICAgICBhLnB1c2goYXNuMU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJTZXF1ZW5jZSh7J2FycmF5JzogYX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1MaXN0ID0gcGFyYW1ba2V5XTtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhc24xT2JqID0gX25ld09iamVjdChwYXJhbUxpc3RbaV0pO1xuICAgICAgICAgICAgICAgIGEucHVzaChhc24xT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgX0RFUlNldCh7J2FycmF5JzogYX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSA9PSBcInRhZ1wiKSB7XG4gICAgICAgICAgICB2YXIgdGFnUGFyYW0gPSBwYXJhbVtrZXldO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YWdQYXJhbSkgPT09ICdbb2JqZWN0IEFycmF5XScgJiZcbiAgICAgICAgICAgICAgICB0YWdQYXJhbS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBfbmV3T2JqZWN0KHRhZ1BhcmFtWzJdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJUYWdnZWRPYmplY3Qoe3RhZzogdGFnUGFyYW1bMF0sXG4gICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0OiB0YWdQYXJhbVsxXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqOiBvYmp9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1BhcmFtID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRhZ1BhcmFtLmV4cGxpY2l0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtLmV4cGxpY2l0ID0gdGFnUGFyYW0uZXhwbGljaXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ1BhcmFtLnRhZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbS50YWcgPSB0YWdQYXJhbS50YWc7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ1BhcmFtLm9iaiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm9iaiBzaGFsbCBiZSBzcGVjaWZpZWQgZm9yICd0YWcnLlwiO1xuICAgICAgICAgICAgICAgIG5ld1BhcmFtLm9iaiA9IF9uZXdPYmplY3QodGFnUGFyYW0ub2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJUYWdnZWRPYmplY3QobmV3UGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdldCBlbmNvZGVkIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04xT2JqZWN0IHNwZWNpZmVkIGJ5IEpTT04gcGFyYW1ldGVyc1xuICAgICAqIEBuYW1lIGpzb25Ub0FTTjFIRVhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW0gSlNPTiBwYXJhbWV0ZXIgdG8gZ2VuZXJhdGUgQVNOMU9iamVjdFxuICAgICAqIEByZXR1cm4gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTjFPYmplY3RcbiAgICAgKiBAc2luY2UgYXNuMSAxLjAuNFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEFzIGZvciBBU04uMSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgSlNPTiBvYmplY3QsXG4gICAgICogcGxlYXNlIHNlZSB7QGxpbmsgbmV3T2JqZWN0fS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGpzb25Ub0FTTjFIRVgoeydwcm5zdHInOiAnYWFhJ30pO1xuICAgICAqL1xuICAgIHRoaXMuanNvblRvQVNOMUhFWCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHZhciBhc24xT2JqID0gdGhpcy5uZXdPYmplY3QocGFyYW0pO1xuICAgICAgICByZXR1cm4gYXNuMU9iai5nZXRFbmNvZGVkSGV4KCk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogZ2V0IGRvdCBub3RlZCBvaWQgbnVtYmVyIHN0cmluZyBmcm9tIGhleGFkZWNpbWFsIHZhbHVlIG9mIE9JRFxuICogQG5hbWUgb2lkSGV4VG9JbnRcbiAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGhleCBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllclxuICogQHJldHVybiB7U3RyaW5nfSBkb3Qgbm90ZWQgc3RyaW5nIG9mIG9iamVjdCBpZGVudGlmaWVyXG4gKiBAc2luY2UganNyc2FzaWduIDQuOC4zIGFzbjEgMS4wLjdcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzdGF0aWMgbWV0aG9kIGNvbnZlcnRzIGZyb20gaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBBU04uMSB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllciB0byBvaWQgbnVtYmVyIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKiBLSlVSLmFzbjEuQVNOMVV0aWwub2lkSGV4VG9JbnQoJzU1MDQwNicpICZyYXJyOyBcIjIuNS40LjZcIlxuICovXG5LSlVSLmFzbjEuQVNOMVV0aWwub2lkSGV4VG9JbnQgPSBmdW5jdGlvbihoZXgpIHtcbiAgICB2YXIgcyA9IFwiXCI7XG4gICAgdmFyIGkwMSA9IHBhcnNlSW50KGhleC5zdWJzdHIoMCwgMiksIDE2KTtcbiAgICB2YXIgaTAgPSBNYXRoLmZsb29yKGkwMSAvIDQwKTtcbiAgICB2YXIgaTEgPSBpMDEgJSA0MDtcbiAgICB2YXIgcyA9IGkwICsgXCIuXCIgKyBpMTtcblxuICAgIHZhciBiaW5idWYgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICAgICAgdmFyIGJpbiA9IChcIjAwMDAwMDAwXCIgKyB2YWx1ZS50b1N0cmluZygyKSkuc2xpY2UoLSA4KTtcbiAgICAgICAgYmluYnVmID0gYmluYnVmICsgYmluLnN1YnN0cigxLCA3KTtcbiAgICAgICAgaWYgKGJpbi5zdWJzdHIoMCwgMSkgPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHZhciBiaSA9IG5ldyBCaWdJbnRlZ2VyKGJpbmJ1ZiwgMik7XG4gICAgICAgICAgICBzID0gcyArIFwiLlwiICsgYmkudG9TdHJpbmcoMTApO1xuICAgICAgICAgICAgYmluYnVmID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogZ2V0IGhleGFkZWNpbWFsIHZhbHVlIG9mIG9iamVjdCBpZGVudGlmaWVyIGZyb20gZG90IG5vdGVkIG9pZCB2YWx1ZVxuICogQG5hbWUgb2lkSW50VG9IZXhcbiAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG9pZFN0cmluZyBkb3Qgbm90ZWQgc3RyaW5nIG9mIG9iamVjdCBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGhleGFkZWNpbWFsIHZhbHVlIG9mIG9iamVjdCBpZGVudGlmaWVyXG4gKiBAc2luY2UganNyc2FzaWduIDQuOC4zIGFzbjEgMS4wLjdcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzdGF0aWMgbWV0aG9kIGNvbnZlcnRzIGZyb20gb2JqZWN0IGlkZW50aWZpZXIgdmFsdWUgc3RyaW5nLlxuICogdG8gaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0LlxuICogQGV4YW1wbGVcbiAqIEtKVVIuYXNuMS5BU04xVXRpbC5vaWRJbnRUb0hleChcIjIuNS40LjZcIikgJnJhcnI7IFwiNTUwNDA2XCJcbiAqL1xuS0pVUi5hc24xLkFTTjFVdGlsLm9pZEludFRvSGV4ID0gZnVuY3Rpb24ob2lkU3RyaW5nKSB7XG4gICAgdmFyIGl0b3ggPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBoID0gaS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoLmxlbmd0aCA9PSAxKSBoID0gJzAnICsgaDtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcblxuICAgIHZhciByb2lkdG94ID0gZnVuY3Rpb24ocm9pZCkge1xuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihyb2lkLCAxMCk7XG4gICAgICAgIHZhciBiID0gYmkudG9TdHJpbmcoMik7XG4gICAgICAgIHZhciBwYWRMZW4gPSA3IC0gYi5sZW5ndGggJSA3O1xuICAgICAgICBpZiAocGFkTGVuID09IDcpIHBhZExlbiA9IDA7XG4gICAgICAgIHZhciBiUGFkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkTGVuOyBpKyspIGJQYWQgKz0gJzAnO1xuICAgICAgICBiID0gYlBhZCArIGI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGggLSAxOyBpICs9IDcpIHtcbiAgICAgICAgICAgIHZhciBiOCA9IGIuc3Vic3RyKGksIDcpO1xuICAgICAgICAgICAgaWYgKGkgIT0gYi5sZW5ndGggLSA3KSBiOCA9ICcxJyArIGI4O1xuICAgICAgICAgICAgaCArPSBpdG94KHBhcnNlSW50KGI4LCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcblxuICAgIGlmICghIG9pZFN0cmluZy5tYXRjaCgvXlswLTkuXSskLykpIHtcbiAgICAgICAgdGhyb3cgXCJtYWxmb3JtZWQgb2lkIHN0cmluZzogXCIgKyBvaWRTdHJpbmc7XG4gICAgfVxuICAgIHZhciBoID0gJyc7XG4gICAgdmFyIGEgPSBvaWRTdHJpbmcuc3BsaXQoJy4nKTtcbiAgICB2YXIgaTAgPSBwYXJzZUludChhWzBdKSAqIDQwICsgcGFyc2VJbnQoYVsxXSk7XG4gICAgaCArPSBpdG94KGkwKTtcbiAgICBhLnNwbGljZSgwLCAyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaCArPSByb2lkdG94KGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gaDtcbn07XG5cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBBYnN0cmFjdCBBU04uMSBDbGFzc2VzXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vKipcbiAqIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBlbmNvZGVyIG9iamVjdFxuICogQG5hbWUgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBjbGFzcyBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgZW5jb2RlciBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNNb2RpZmllZCBmbGFnIHdoZXRoZXIgaW50ZXJuYWwgZGF0YSB3YXMgY2hhbmdlZFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGhUTFYgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMVlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGhUIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgdGFnKFQpXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaEwgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViBsZW5ndGgoTClcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBoViBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIHZhbHVlKFYpXG4gKiBAZGVzY3JpcHRpb25cbiAqL1xuS0pVUi5hc24xLkFTTjFPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaFYgPSAnJztcblxuICAgIC8qKlxuICAgICAqIGdldCBoZXhhZGVjaW1hbCBBU04uMSBUTFYgbGVuZ3RoKEwpIGJ5dGVzIGZyb20gVExWIHZhbHVlKFYpXG4gICAgICogQG5hbWUgZ2V0TGVuZ3RoSGV4RnJvbVZhbHVlXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xT2JqZWN0I1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViBsZW5ndGgoTClcbiAgICAgKi9cbiAgICB0aGlzLmdldExlbmd0aEhleEZyb21WYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaFYgPT0gXCJ1bmRlZmluZWRcIiB8fCB0aGlzLmhWID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IFwidGhpcy5oViBpcyBudWxsIG9yIHVuZGVmaW5lZC5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oVi5sZW5ndGggJSAyID09IDEpIHtcbiAgICAgICAgICAgIHRocm93IFwidmFsdWUgaGV4IG11c3QgYmUgZXZlbiBsZW5ndGg6IG49XCIgKyBoVi5sZW5ndGggKyBcIix2PVwiICsgdGhpcy5oVjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IHRoaXMuaFYubGVuZ3RoIC8gMjtcbiAgICAgICAgdmFyIGhOID0gbi50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoTi5sZW5ndGggJSAyID09IDEpIHtcbiAgICAgICAgICAgIGhOID0gXCIwXCIgKyBoTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8IDEyOCkge1xuICAgICAgICAgICAgcmV0dXJuIGhOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhObGVuID0gaE4ubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIGlmIChoTmxlbiA+IDE1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJBU04uMSBsZW5ndGggdG9vIGxvbmcgdG8gcmVwcmVzZW50IGJ5IDh4OiBuID0gXCIgKyBuLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZWFkID0gMTI4ICsgaE5sZW47XG4gICAgICAgICAgICByZXR1cm4gaGVhZC50b1N0cmluZygxNikgKyBoTjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViBieXRlc1xuICAgICAqIEBuYW1lIGdldEVuY29kZWRIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFPYmplY3QjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWXG4gICAgICovXG4gICAgdGhpcy5nZXRFbmNvZGVkSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmhUTFYgPT0gbnVsbCB8fCB0aGlzLmlzTW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaFYgPSB0aGlzLmdldEZyZXNoVmFsdWVIZXgoKTtcbiAgICAgICAgICAgIHRoaXMuaEwgPSB0aGlzLmdldExlbmd0aEhleEZyb21WYWx1ZSgpO1xuICAgICAgICAgICAgdGhpcy5oVExWID0gdGhpcy5oVCArIHRoaXMuaEwgKyB0aGlzLmhWO1xuICAgICAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAvL2FsZXJ0KFwiZmlyc3QgdGltZTogXCIgKyB0aGlzLmhUTFYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhUTFY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdldCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIHZhbHVlKFYpIGJ5dGVzXG4gICAgICogQG5hbWUgZ2V0VmFsdWVIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFPYmplY3QjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIHZhbHVlKFYpIGJ5dGVzXG4gICAgICovXG4gICAgdGhpcy5nZXRWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldEVuY29kZWRIZXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbn07XG5cbi8vID09IEJFR0lOIERFUkFic3RyYWN0U3RyaW5nID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgc3RyaW5nIGNsYXNzZXNcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBzdHJpbmcgY2xhc3Nlc1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzIGludGVybmFsIHN0cmluZyBvZiB2YWx1ZVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPnN0ciAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIHN0cmluZzwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIGdldCBzdHJpbmcgdmFsdWUgb2YgdGhpcyBzdHJpbmcgb2JqZWN0XG4gICAgICogQG5hbWUgZ2V0U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyB2YWx1ZSBvZiB0aGlzIHN0cmluZyBvYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLmdldFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBzdHJpbmdcbiAgICAgKiBAbmFtZSBzZXRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdTIHZhbHVlIGJ5IGEgc3RyaW5nIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0U3RyaW5nID0gZnVuY3Rpb24obmV3Uykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBuZXdTO1xuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgICAqIEBuYW1lIHNldFN0cmluZ0hleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld0hleFN0cmluZyB2YWx1ZSBieSBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldFN0cmluZ0hleCA9IGZ1bmN0aW9uKG5ld0hleFN0cmluZykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBudWxsO1xuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydzdHInXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhwYXJhbXNbJ3N0ciddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydoZXgnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZ0hleChwYXJhbXNbJ2hleCddKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vID09IEVORCAgIERFUkFic3RyYWN0U3RyaW5nID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyA9PSBCRUdJTiBERVJBYnN0cmFjdFRpbWUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKlxuICogYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIEdlbmVyYWxpemVkL1VUQ1RpbWUgY2xhc3NcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWVcbiAqIEBjbGFzcyBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgR2VuZXJhbGl6ZWQvVVRDVGltZSBjbGFzc1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICcxMzA0MzAyMzU5NTlaJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5BU04xT2JqZWN0IC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG5cbiAgICAvLyAtLS0gUFJJVkFURSBNRVRIT0RTIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdGhpcy5sb2NhbERhdGVUb1VUQyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdXRjID0gZC5nZXRUaW1lKCkgKyAoZC5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApO1xuICAgICAgICB2YXIgdXRjRGF0ZSA9IG5ldyBEYXRlKHV0Yyk7XG4gICAgICAgIHJldHVybiB1dGNEYXRlO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIGZvcm1hdCBkYXRlIHN0cmluZyBieSBEYXRhIG9iamVjdFxuICAgICAqIEBuYW1lIGZvcm1hdERhdGVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFic3RyYWN0VGltZTtcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVPYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAndXRjJyBvciAnZ2VuJ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aE1pbGxpcyBmbGFnIGZvciB3aXRoIG1pbGxpc2VjdGlvbnMgb3Igbm90XG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogJ3dpdGhNaWxsaXMnIGZsYWcgaXMgc3VwcG9ydGVkIGZyb20gYXNuMSAxLjAuNi5cbiAgICAgKi9cbiAgICB0aGlzLmZvcm1hdERhdGUgPSBmdW5jdGlvbihkYXRlT2JqZWN0LCB0eXBlLCB3aXRoTWlsbGlzKSB7XG4gICAgICAgIHZhciBwYWQgPSB0aGlzLnplcm9QYWRkaW5nO1xuICAgICAgICB2YXIgZCA9IHRoaXMubG9jYWxEYXRlVG9VVEMoZGF0ZU9iamVjdCk7XG4gICAgICAgIHZhciB5ZWFyID0gU3RyaW5nKGQuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgIGlmICh0eXBlID09ICd1dGMnKSB5ZWFyID0geWVhci5zdWJzdHIoMiwgMik7XG4gICAgICAgIHZhciBtb250aCA9IHBhZChTdHJpbmcoZC5nZXRNb250aCgpICsgMSksIDIpO1xuICAgICAgICB2YXIgZGF5ID0gcGFkKFN0cmluZyhkLmdldERhdGUoKSksIDIpO1xuICAgICAgICB2YXIgaG91ciA9IHBhZChTdHJpbmcoZC5nZXRIb3VycygpKSwgMik7XG4gICAgICAgIHZhciBtaW4gPSBwYWQoU3RyaW5nKGQuZ2V0TWludXRlcygpKSwgMik7XG4gICAgICAgIHZhciBzZWMgPSBwYWQoU3RyaW5nKGQuZ2V0U2Vjb25kcygpKSwgMik7XG4gICAgICAgIHZhciBzID0geWVhciArIG1vbnRoICsgZGF5ICsgaG91ciArIG1pbiArIHNlYztcbiAgICAgICAgaWYgKHdpdGhNaWxsaXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgaWYgKG1pbGxpcyAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNNaWxsaXMgPSBwYWQoU3RyaW5nKG1pbGxpcyksIDMpO1xuICAgICAgICAgICAgICAgIHNNaWxsaXMgPSBzTWlsbGlzLnJlcGxhY2UoL1swXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgcyA9IHMgKyBcIi5cIiArIHNNaWxsaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMgKyBcIlpcIjtcbiAgICB9O1xuXG4gICAgdGhpcy56ZXJvUGFkZGluZyA9IGZ1bmN0aW9uKHMsIGxlbikge1xuICAgICAgICBpZiAocy5sZW5ndGggPj0gbGVuKSByZXR1cm4gcztcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheShsZW4gLSBzLmxlbmd0aCArIDEpLmpvaW4oJzAnKSArIHM7XG4gICAgfTtcblxuICAgIC8vIC0tLSBQVUJMSUMgTUVUSE9EUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKlxuICAgICAqIGdldCBzdHJpbmcgdmFsdWUgb2YgdGhpcyBzdHJpbmcgb2JqZWN0XG4gICAgICogQG5hbWUgZ2V0U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgdmFsdWUgb2YgdGhpcyB0aW1lIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMuZ2V0U3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIHN0cmluZ1xuICAgICAqIEBuYW1lIHNldFN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdTIHZhbHVlIGJ5IGEgc3RyaW5nIHRvIHNldCBzdWNoIGxpa2UgXCIxMzA0MzAyMzU5NTlaXCJcbiAgICAgKi9cbiAgICB0aGlzLnNldFN0cmluZyA9IGZ1bmN0aW9uKG5ld1MpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zID0gbmV3UztcbiAgICAgICAgdGhpcy5oViA9IHN0b2hleChuZXdTKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgRGF0ZSBvYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeURhdGVWYWx1ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0geWVhciB5ZWFyIG9mIGRhdGUgKGV4LiAyMDEzKVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbW9udGggbW9udGggb2YgZGF0ZSBiZXR3ZWVuIDEgYW5kIDEyIChleC4gMTIpXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBkYXkgZGF5IG9mIG1vbnRoXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBob3VyIGhvdXJzIG9mIGRhdGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG1pbiBtaW51dGVzIG9mIGRhdGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHNlYyBzZWNvbmRzIG9mIGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5RGF0ZVZhbHVlID0gZnVuY3Rpb24oeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpIHtcbiAgICAgICAgdmFyIGRhdGVPYmplY3QgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciwgbWluLCBzZWMsIDApKTtcbiAgICAgICAgdGhpcy5zZXRCeURhdGUoZGF0ZU9iamVjdCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcbi8vID09IEVORCAgIERFUkFic3RyYWN0VGltZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyA9PSBCRUdJTiBERVJBYnN0cmFjdFN0cnVjdHVyZWQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKlxuICogYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIHN0cnVjdHVyZWQgY2xhc3NcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWRcbiAqIEBjbGFzcyBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgc3RydWN0dXJlZCBjbGFzc1xuICogQHByb3BlcnR5IHtBcnJheX0gYXNuMUFycmF5IGludGVybmFsIGFycmF5IG9mIEFTTjFPYmplY3RcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGFycmF5IG9mIEFTTjFPYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeUFTTjFPYmplY3RBcnJheVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFzbjFPYmplY3RBcnJheSBhcnJheSBvZiBBU04xT2JqZWN0IHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlBU04xT2JqZWN0QXJyYXkgPSBmdW5jdGlvbihhc24xT2JqZWN0QXJyYXkpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hc24xQXJyYXkgPSBhc24xT2JqZWN0QXJyYXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFwcGVuZCBhbiBBU04xT2JqZWN0IHRvIGludGVybmFsIGFycmF5XG4gICAgICogQG5hbWUgYXBwZW5kQVNOMU9iamVjdFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QVNOMU9iamVjdH0gYXNuMU9iamVjdCB0byBhZGRcbiAgICAgKi9cbiAgICB0aGlzLmFwcGVuZEFTTjFPYmplY3QgPSBmdW5jdGlvbihhc24xT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXNuMUFycmF5LnB1c2goYXNuMU9iamVjdCk7XG4gICAgfTtcblxuICAgIHRoaXMuYXNuMUFycmF5ID0gbmV3IEFycmF5KCk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snYXJyYXknXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmFzbjFBcnJheSA9IHBhcmFtc1snYXJyYXknXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBBU04uMSBPYmplY3QgQ2xhc3Nlc1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBCb29sZWFuXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQm9vbGVhblxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgQm9vbGVhblxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuQVNOMU9iamVjdCAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUkJvb2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICBLSlVSLmFzbjEuREVSQm9vbGVhbi5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDFcIjtcbiAgICB0aGlzLmhUTFYgPSBcIjAxMDFmZlwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJCb29sZWFuLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgSW50ZWdlclxuICogQG5hbWUgS0pVUi5hc24xLkRFUkludGVnZXJcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEludGVnZXJcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5pbnQgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgaW50ZWdlciB2YWx1ZTwvbGk+XG4gKiA8bGk+YmlnaW50IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IEJpZ0ludGVnZXIgb2JqZWN0PC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPC91bD5cbiAqIE5PVEU6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5LSlVSLmFzbjEuREVSSW50ZWdlciA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJJbnRlZ2VyLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwMlwiO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IFRvbSBXdSdzIEJpZ0ludGVnZXIgb2JqZWN0XG4gICAgICogQG5hbWUgc2V0QnlCaWdJbnRlZ2VyXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJJbnRlZ2VyI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QmlnSW50ZWdlcn0gYmlnSW50ZWdlclZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyID0gZnVuY3Rpb24oYmlnSW50ZWdlclZhbHVlKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaFYgPSBLSlVSLmFzbjEuQVNOMVV0aWwuYmlnSW50VG9NaW5Ud29zQ29tcGxlbWVudHNIZXgoYmlnSW50ZWdlclZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGludGVnZXIgdmFsdWVcbiAgICAgKiBAbmFtZSBzZXRCeUludGVnZXJcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkludGVnZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGludGVnZXIgdmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUludGVnZXIgPSBmdW5jdGlvbihpbnRWYWx1ZSkge1xuICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihTdHJpbmcoaW50VmFsdWUpLCAxMCk7XG4gICAgICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyKGJpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGludGVnZXIgdmFsdWVcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSSW50ZWdlciNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGludGVnZXIgdmFsdWVcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA8YnIvPlxuICAgICAqIE5PVEU6IFZhbHVlIHNoYWxsIGJlIHJlcHJlc2VudGVkIGJ5IG1pbmltdW0gb2N0ZXQgbGVuZ3RoIG9mXG4gICAgICogdHdvJ3MgY29tcGxlbWVudCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcigxMjMpO1xuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7J2ludCc6IDEyM30pO1xuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7J2hleCc6ICcxZmFkJ30pO1xuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVIZXggPSBmdW5jdGlvbihuZXdIZXhTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5oViA9IG5ld0hleFN0cmluZztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydiaWdpbnQnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5QmlnSW50ZWdlcihwYXJhbXNbJ2JpZ2ludCddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydpbnQnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXNbJ2ludCddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlJbnRlZ2VyKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaGV4J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUhleChwYXJhbXNbJ2hleCddKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSSW50ZWdlciwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIGVuY29kZWQgQml0U3RyaW5nIHByaW1pdGl2ZVxuICogQG5hbWUgS0pVUi5hc24xLkRFUkJpdFN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgZW5jb2RlZCBCaXRTdHJpbmcgcHJpbWl0aXZlXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+YmluIC0gc3BlY2lmeSBiaW5hcnkgc3RyaW5nIChleC4gJzEwMTExJyk8L2xpPlxuICogPGxpPmFycmF5IC0gc3BlY2lmeSBhcnJheSBvZiBib29sZWFuIChleC4gW3RydWUsZmFsc2UsdHJ1ZSx0cnVlXSk8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIHZhbHVlKFYpIGluY2x1ZGluZyB1bnVzZWQgYml0czwvbGk+XG4gKiA8bGk+b2JqIC0gc3BlY2lmeSB7QGxpbmsgS0pVUi5hc24xLkFTTjFVdGlsLm5ld09iamVjdH1cbiAqIGFyZ3VtZW50IGZvciBcIkJpdFN0cmluZyBlbmNhcHN1bGF0ZXNcIiBzdHJ1Y3R1cmUuPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFMTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuPGJyLz5cbiAqIE5PVEUyOiAnb2JqJyBwYXJhbWV0ZXIgaGF2ZSBiZWVuIHN1cHBvcnRlZCBzaW5jZVxuICogYXNuMSAxLjAuMTEsIGpzcnNhc2lnbiA2LjEuMSAoMjAxNi1TZXAtMjUpLjxici8+XG4gKiBAZXhhbXBsZVxuICogLy8gZGVmYXVsdCBjb25zdHJ1Y3RvclxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKCk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggYmluYXJ5IHN0cmluZ1xuICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKHtiaW46IFwiMTAxMVwifSk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggYm9vbGVhbiBhcnJheVxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKHthcnJheTogW3RydWUsZmFsc2UsdHJ1ZSx0cnVlXX0pO1xuICogLy8gaW5pdGlhbGl6ZSB3aXRoIGhleGFkZWNpbWFsIHN0cmluZyAoMDQgaXMgdW51c2VkIGJpdHMpXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZyh7aGV4OiBcIjA0YmFjMFwifSk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggQVNOMVV0aWwubmV3T2JqZWN0IGFyZ3VtZW50IGZvciBlbmNhcHN1bGF0ZWRcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZyh7b2JqOiB7c2VxOiBbe2ludDogM30sIHtwcm5zdHI6ICdhYWEnfV19fSk7XG4gKiAvLyBhYm92ZSBnZW5lcmF0ZXMgYSBBU04uMSBkYXRhIGxpa2UgdGhpczpcbiAqIC8vIEJJVCBTVFJJTkcsIGVuY2Fwc3VsYXRlcyB7XG4gKiAvLyAgIFNFUVVFTkNFIHtcbiAqIC8vICAgICBJTlRFR0VSIDNcbiAqIC8vICAgICBQcmludGFibGVTdHJpbmcgJ2FhYSdcbiAqIC8vICAgICB9XG4gKiAvLyAgIH1cbiAqL1xuS0pVUi5hc24xLkRFUkJpdFN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGFyYW1zLm9iaiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbyA9IEtKVVIuYXNuMS5BU04xVXRpbC5uZXdPYmplY3QocGFyYW1zLm9iaik7XG4gICAgICAgIHBhcmFtcy5oZXggPSBcIjAwXCIgKyBvLmdldEVuY29kZWRIZXgoKTtcbiAgICB9XG4gICAgS0pVUi5hc24xLkRFUkJpdFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDNcIjtcblxuICAgIC8qKlxuICAgICAqIHNldCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZyBpbmNsdWRpbmcgdW51c2VkIGJpdHNcbiAgICAgKiBAbmFtZSBzZXRIZXhWYWx1ZUluY2x1ZGluZ1VudXNlZEJpdHNcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3SGV4U3RyaW5nSW5jbHVkaW5nVW51c2VkQml0c1xuICAgICAqL1xuICAgIHRoaXMuc2V0SGV4VmFsdWVJbmNsdWRpbmdVbnVzZWRCaXRzID0gZnVuY3Rpb24obmV3SGV4U3RyaW5nSW5jbHVkaW5nVW51c2VkQml0cykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nSW5jbHVkaW5nVW51c2VkQml0cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IEFTTi4xIHZhbHVlKFYpIGJ5IHVudXNlZCBiaXQgYW5kIGhleGFkZWNpbWFsIHN0cmluZyBvZiB2YWx1ZVxuICAgICAqIEBuYW1lIHNldFVudXNlZEJpdHNBbmRIZXhWYWx1ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gdW51c2VkQml0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoVmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLnNldFVudXNlZEJpdHNBbmRIZXhWYWx1ZSA9IGZ1bmN0aW9uKHVudXNlZEJpdHMsIGhWYWx1ZSkge1xuICAgICAgICBpZiAodW51c2VkQml0cyA8IDAgfHwgNyA8IHVudXNlZEJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IFwidW51c2VkIGJpdHMgc2hhbGwgYmUgZnJvbSAwIHRvIDc6IHUgPSBcIiArIHVudXNlZEJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhVbnVzZWRCaXRzID0gXCIwXCIgKyB1bnVzZWRCaXRzO1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhWID0gaFVudXNlZEJpdHMgKyBoVmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCBBU04uMSBERVIgQml0U3RyaW5nIGJ5IGJpbmFyeSBzdHJpbmc8YnIvPlxuICAgICAqIEBuYW1lIHNldEJ5QmluYXJ5U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJpbmFyeVN0cmluZyBiaW5hcnkgdmFsdWUgc3RyaW5nIChpLmUuICcxMDExMScpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogSXRzIHVudXNlZCBiaXRzIHdpbGwgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJ5IGxlbmd0aCBvZlxuICAgICAqICdiaW5hcnlWYWx1ZScuIDxici8+XG4gICAgICogTk9URTogVHJhaWxpbmcgemVyb3MgJzAnIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZygpO1xuICAgICAqIG8uc2V0QnlCb29sZWFuQXJyYXkoXCIwMTAxMVwiKTtcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5QmluYXJ5U3RyaW5nID0gZnVuY3Rpb24oYmluYXJ5U3RyaW5nKSB7XG4gICAgICAgIGJpbmFyeVN0cmluZyA9IGJpbmFyeVN0cmluZy5yZXBsYWNlKC8wKyQvLCAnJyk7XG4gICAgICAgIHZhciB1bnVzZWRCaXRzID0gOCAtIGJpbmFyeVN0cmluZy5sZW5ndGggJSA4O1xuICAgICAgICBpZiAodW51c2VkQml0cyA9PSA4KSB1bnVzZWRCaXRzID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdW51c2VkQml0czsgaSsrKSB7XG4gICAgICAgICAgICBiaW5hcnlTdHJpbmcgKz0gJzAnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aCAtIDE7IGkgKz0gOCkge1xuICAgICAgICAgICAgdmFyIGIgPSBiaW5hcnlTdHJpbmcuc3Vic3RyKGksIDgpO1xuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChiLCAyKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBpZiAoeC5sZW5ndGggPT0gMSkgeCA9ICcwJyArIHg7XG4gICAgICAgICAgICBoICs9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oViA9ICcwJyArIHVudXNlZEJpdHMgKyBoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgQVNOLjEgVExWIHZhbHVlKFYpIGJ5IGFuIGFycmF5IG9mIGJvb2xlYW48YnIvPlxuICAgICAqIEBuYW1lIHNldEJ5Qm9vbGVhbkFycmF5XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHthcnJheX0gYm9vbGVhbkFycmF5IGFycmF5IG9mIGJvb2xlYW4gKGV4LiBbdHJ1ZSwgZmFsc2UsIHRydWVdKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE5PVEU6IFRyYWlsaW5nIGZhbHNlcyB3aWxsIGJlIGlnbm9yZWQgaW4gdGhlIEFTTi4xIERFUiBPYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcbiAgICAgKiBvLnNldEJ5Qm9vbGVhbkFycmF5KFtmYWxzZSwgdHJ1ZSwgZmFsc2UsIHRydWUsIHRydWVdKTtcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5Qm9vbGVhbkFycmF5ID0gZnVuY3Rpb24oYm9vbGVhbkFycmF5KSB7XG4gICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbGVhbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYm9vbGVhbkFycmF5W2ldID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzICs9ICcxJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcyArPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRCeUJpbmFyeVN0cmluZyhzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgYW4gYXJyYXkgb2YgZmFsc2VzIHdpdGggc3BlY2lmaWVkIGxlbmd0aDxici8+XG4gICAgICogQG5hbWUgbmV3RmFsc2VBcnJheVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBuTGVuZ3RoIGxlbmd0aCBvZiBhcnJheSB0byBnZW5lcmF0ZVxuICAgICAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBvZiBib29sZWFuIGZhbHNlc1xuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoaXMgc3RhdGljIG1ldGhvZCBtYXkgYmUgdXNlZnVsIHRvIGluaXRpYWxpemUgYm9vbGVhbiBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZygpO1xuICAgICAqIG8ubmV3RmFsc2VBcnJheSgzKSAmcmFycjsgW2ZhbHNlLCBmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgdGhpcy5uZXdGYWxzZUFycmF5ID0gZnVuY3Rpb24obkxlbmd0aCkge1xuICAgICAgICB2YXIgYSA9IG5ldyBBcnJheShuTGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFbaV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09IFwic3RyaW5nXCIgJiYgcGFyYW1zLnRvTG93ZXJDYXNlKCkubWF0Y2goL15bMC05YS1mXSskLykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGV4VmFsdWVJbmNsdWRpbmdVbnVzZWRCaXRzKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaGV4J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRIZXhWYWx1ZUluY2x1ZGluZ1VudXNlZEJpdHMocGFyYW1zWydoZXgnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snYmluJ10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUJpbmFyeVN0cmluZyhwYXJhbXNbJ2JpbiddKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydhcnJheSddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlCb29sZWFuQXJyYXkocGFyYW1zWydhcnJheSddKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQml0U3RyaW5nLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgT2N0ZXRTdHJpbmc8YnIvPlxuICogQG5hbWUgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBPY3RldFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIEFTTi4xIE9jdGV0U3RyaW5nIHNpbXBsZSB0eXBlLjxici8+XG4gKiBTdXBwb3J0ZWQgXCJwYXJhbXNcIiBhdHRyaWJ1dGVzIGFyZTpcbiAqIDx1bD5cbiAqIDxsaT5zdHIgLSB0byBzZXQgYSBzdHJpbmcgYXMgYSB2YWx1ZTwvbGk+XG4gKiA8bGk+aGV4IC0gdG8gc2V0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIGFzIGEgdmFsdWU8L2xpPlxuICogPGxpPm9iaiAtIHRvIHNldCBhIGVuY2Fwc3VsYXRlZCBBU04uMSB2YWx1ZSBieSBKU09OIG9iamVjdFxuICogd2hpY2ggaXMgZGVmaW5lZCBpbiB7QGxpbmsgS0pVUi5hc24xLkFTTjFVdGlsLm5ld09iamVjdH08L2xpPlxuICogPC91bD5cbiAqIE5PVEU6IEEgcGFyYW1ldGVyICdvYmonIGhhdmUgYmVlbiBzdXBwb3J0ZWRcbiAqIGZvciBcIk9DVEVUIFNUUklORywgZW5jYXBzdWxhdGVzXCIgc3RydWN0dXJlLlxuICogc2luY2UgYXNuMSAxLjAuMTEsIGpzcnNhc2lnbiA2LjEuMSAoMjAxNi1TZXAtMjUpLlxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKiBAZXhhbXBsZVxuICogLy8gZGVmYXVsdCBjb25zdHJ1Y3RvclxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcoKTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBzdHJpbmdcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtzdHI6IFwiYWFhXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBoZXhhZGVjaW1hbCBzdHJpbmdcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtoZXg6IFwiNjE2MTYxXCJ9KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBBU04xVXRpbC5uZXdPYmplY3QgYXJndW1lbnRcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtvYmo6IHtzZXE6IFt7aW50OiAzfSwge3BybnN0cjogJ2FhYSd9XX19KTtcbiAqIC8vIGFib3ZlIGdlbmVyYXRlcyBhIEFTTi4xIGRhdGEgbGlrZSB0aGlzOlxuICogLy8gT0NURVQgU1RSSU5HLCBlbmNhcHN1bGF0ZXMge1xuICogLy8gICBTRVFVRU5DRSB7XG4gKiAvLyAgICAgSU5URUdFUiAzXG4gKiAvLyAgICAgUHJpbnRhYmxlU3RyaW5nICdhYWEnXG4gKiAvLyAgICAgfVxuICogLy8gICB9XG4gKi9cbktKVVIuYXNuMS5ERVJPY3RldFN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGFyYW1zLm9iaiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbyA9IEtKVVIuYXNuMS5BU04xVXRpbC5uZXdPYmplY3QocGFyYW1zLm9iaik7XG4gICAgICAgIHBhcmFtcy5oZXggPSBvLmdldEVuY29kZWRIZXgoKTtcbiAgICB9XG4gICAgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjA0XCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE51bGxcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJOdWxsXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBOdWxsXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5BU04xT2JqZWN0IC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSTnVsbCA9IGZ1bmN0aW9uKCkge1xuICAgIEtKVVIuYXNuMS5ERVJOdWxsLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwNVwiO1xuICAgIHRoaXMuaFRMViA9IFwiMDUwMFwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJOdWxsLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgT2JqZWN0SWRlbnRpZmllclxuICogQG5hbWUgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXJcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE9iamVjdElkZW50aWZpZXJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydvaWQnOiAnMi41LjQuNSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPm9pZCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIG9pZCBzdHJpbmcgKGV4LiAyLjUuNC4xMyk8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbktKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIGl0b3ggPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBoID0gaS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoLmxlbmd0aCA9PSAxKSBoID0gJzAnICsgaDtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICB2YXIgcm9pZHRveCA9IGZ1bmN0aW9uKHJvaWQpIHtcbiAgICAgICAgdmFyIGggPSAnJztcbiAgICAgICAgdmFyIGJpID0gbmV3IEJpZ0ludGVnZXIocm9pZCwgMTApO1xuICAgICAgICB2YXIgYiA9IGJpLnRvU3RyaW5nKDIpO1xuICAgICAgICB2YXIgcGFkTGVuID0gNyAtIGIubGVuZ3RoICUgNztcbiAgICAgICAgaWYgKHBhZExlbiA9PSA3KSBwYWRMZW4gPSAwO1xuICAgICAgICB2YXIgYlBhZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbjsgaSsrKSBiUGFkICs9ICcwJztcbiAgICAgICAgYiA9IGJQYWQgKyBiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoIC0gMTsgaSArPSA3KSB7XG4gICAgICAgICAgICB2YXIgYjggPSBiLnN1YnN0cihpLCA3KTtcbiAgICAgICAgICAgIGlmIChpICE9IGIubGVuZ3RoIC0gNykgYjggPSAnMScgKyBiODtcbiAgICAgICAgICAgIGggKz0gaXRveChwYXJzZUludChiOCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG5cbiAgICBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDZcIjtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgICAqIEBuYW1lIHNldFZhbHVlSGV4XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdIZXhTdHJpbmcgaGV4YWRlY2ltYWwgdmFsdWUgb2YgT0lEIGJ5dGVzXG4gICAgICovXG4gICAgdGhpcy5zZXRWYWx1ZUhleCA9IGZ1bmN0aW9uKG5ld0hleFN0cmluZykge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBudWxsO1xuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBPSUQgc3RyaW5nPGJyLz5cbiAgICAgKiBAbmFtZSBzZXRWYWx1ZU9pZFN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2lkU3RyaW5nIE9JRCBzdHJpbmcgKGV4LiAyLjUuNC4xMylcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIoKTtcbiAgICAgKiBvLnNldFZhbHVlT2lkU3RyaW5nKFwiMi41LjQuMTNcIik7XG4gICAgICovXG4gICAgdGhpcy5zZXRWYWx1ZU9pZFN0cmluZyA9IGZ1bmN0aW9uKG9pZFN0cmluZykge1xuICAgICAgICBpZiAoISBvaWRTdHJpbmcubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgICAgICB0aHJvdyBcIm1hbGZvcm1lZCBvaWQgc3RyaW5nOiBcIiArIG9pZFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICB2YXIgYSA9IG9pZFN0cmluZy5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgaTAgPSBwYXJzZUludChhWzBdKSAqIDQwICsgcGFyc2VJbnQoYVsxXSk7XG4gICAgICAgIGggKz0gaXRveChpMCk7XG4gICAgICAgIGEuc3BsaWNlKDAsIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGggKz0gcm9pZHRveChhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnMgPSBudWxsO1xuICAgICAgICB0aGlzLmhWID0gaDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgT0lEIG5hbWVcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZU5hbWVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9pZE5hbWUgT0lEIG5hbWUgKGV4LiAnc2VydmVyQXV0aCcpXG4gICAgICogQHNpbmNlIDEuMC4xXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogT0lEIG5hbWUgc2hhbGwgYmUgZGVmaW5lZCBpbiAnS0pVUi5hc24xLng1MDkuT0lELm5hbWUyb2lkTGlzdCcuXG4gICAgICogT3RoZXJ3aXNlIHJhaXNlIGVycm9yLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllcigpO1xuICAgICAqIG8uc2V0VmFsdWVOYW1lKFwic2VydmVyQXV0aFwiKTtcbiAgICAgKi9cbiAgICB0aGlzLnNldFZhbHVlTmFtZSA9IGZ1bmN0aW9uKG9pZE5hbWUpIHtcbiAgICAgICAgdmFyIG9pZCA9IEtKVVIuYXNuMS54NTA5Lk9JRC5uYW1lMm9pZChvaWROYW1lKTtcbiAgICAgICAgaWYgKG9pZCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcob2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiREVST2JqZWN0SWRlbnRpZmllciBvaWROYW1lIHVuZGVmaW5lZDogXCIgKyBvaWROYW1lO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLm1hdGNoKC9eWzAtMl0uWzAtOS5dKyQvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcocGFyYW1zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZU5hbWUocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMub2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcocGFyYW1zLm9pZCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KHBhcmFtcy5oZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVOYW1lKHBhcmFtcy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIEVudW1lcmF0ZWRcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBFbnVtZXJhdGVkXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+aW50IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGludGVnZXIgdmFsdWU8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKiBAZXhhbXBsZVxuICogbmV3IEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkKDEyMyk7XG4gKiBuZXcgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQoe2ludDogMTIzfSk7XG4gKiBuZXcgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQoe2hleDogJzFmYWQnfSk7XG4gKi9cbktKVVIuYXNuMS5ERVJFbnVtZXJhdGVkID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcIjBhXCI7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgVG9tIFd1J3MgQmlnSW50ZWdlciBvYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeUJpZ0ludGVnZXJcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCaWdJbnRlZ2VyfSBiaWdJbnRlZ2VyVmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUJpZ0ludGVnZXIgPSBmdW5jdGlvbihiaWdJbnRlZ2VyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oViA9IEtKVVIuYXNuMS5BU04xVXRpbC5iaWdJbnRUb01pblR3b3NDb21wbGVtZW50c0hleChiaWdJbnRlZ2VyVmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxuICAgICAqIEBuYW1lIHNldEJ5SW50ZWdlclxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGludGVnZXIgdmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUludGVnZXIgPSBmdW5jdGlvbihpbnRWYWx1ZSkge1xuICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihTdHJpbmcoaW50VmFsdWUpLCAxMCk7XG4gICAgICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyKGJpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGludGVnZXIgdmFsdWVcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGludGVnZXIgdmFsdWVcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA8YnIvPlxuICAgICAqIE5PVEU6IFZhbHVlIHNoYWxsIGJlIHJlcHJlc2VudGVkIGJ5IG1pbmltdW0gb2N0ZXQgbGVuZ3RoIG9mXG4gICAgICogdHdvJ3MgY29tcGxlbWVudCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLnNldFZhbHVlSGV4ID0gZnVuY3Rpb24obmV3SGV4U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmc7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snaW50J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUludGVnZXIocGFyYW1zWydpbnQnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2hleCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVIZXgocGFyYW1zWydoZXgnXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBVVEY4U3RyaW5nXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSVVRGOFN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVVRGOFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUlVURjhTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSVVRGOFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIwY1wiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE51bWVyaWNTdHJpbmdcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBOdW1lcmljU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjEyXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUk51bWVyaWNTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgUHJpbnRhYmxlU3RyaW5nXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBQcmludGFibGVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJQcmludGFibGVTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjEzXCI7XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBUZWxldGV4U3RyaW5nXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSVGVsZXRleFN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVGVsZXRleFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSVGVsZXRleFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxNFwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJUZWxldGV4U3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIElBNVN0cmluZ1xuICogQG5hbWUgS0pVUi5hc24xLkRFUklBNVN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgSUE1U3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSSUE1U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUklBNVN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxNlwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJJQTVTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgVVRDVGltZVxuICogQG5hbWUgS0pVUi5hc24xLkRFUlVUQ1RpbWVcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFVUQ1RpbWVcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnMTMwNDMwMjM1OTU5Wid9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZVxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+c3RyIC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgc3RyaW5nIChleC4nMTMwNDMwMjM1OTU5WicpPC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPGxpPmRhdGUgLSBzcGVjaWZ5IERhdGUgb2JqZWN0LjwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKiA8aDQ+RVhBTVBMRVM8L2g0PlxuICogQGV4YW1wbGVcbiAqIGQxID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKCk7XG4gKiBkMS5zZXRTdHJpbmcoJzEzMDQzMDEyNTk1OVonKTtcbiAqXG4gKiBkMiA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSh7J3N0cic6ICcxMzA0MzAxMjU5NTlaJ30pO1xuICogZDMgPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoeydkYXRlJzogbmV3IERhdGUoRGF0ZS5VVEMoMjAxNSwgMCwgMzEsIDAsIDAsIDAsIDApKX0pO1xuICogZDQgPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoJzEzMDQzMDEyNTk1OVonKTtcbiAqL1xuS0pVUi5hc24xLkRFUlVUQ1RpbWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSVVRDVGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxN1wiO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgRGF0ZSBvYmplY3Q8YnIvPlxuICAgICAqIEBuYW1lIHNldEJ5RGF0ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSVVRDVGltZSNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVPYmplY3QgRGF0ZSBvYmplY3QgdG8gc2V0IEFTTi4xIHZhbHVlKFYpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKCk7XG4gICAgICogby5zZXRCeURhdGUobmV3IERhdGUoXCIyMDE2LzEyLzMxXCIpKTtcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5RGF0ZSA9IGZ1bmN0aW9uKGRhdGVPYmplY3QpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kYXRlID0gZGF0ZU9iamVjdDtcbiAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ3V0YycpO1xuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0ZSA9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB0aGlzLnMgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsICd1dGMnKTtcbiAgICAgICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJhbXMuc3RyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcy5zdHIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJzdHJpbmdcIiAmJiBwYXJhbXMubWF0Y2goL15bMC05XXsxMn1aJC8pKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5oZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmdIZXgocGFyYW1zLmhleCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRCeURhdGUocGFyYW1zLmRhdGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJVVENUaW1lLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBHZW5lcmFsaXplZFRpbWVcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWVcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEdlbmVyYWxpemVkVGltZVxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICcyMDEzMDQzMDIzNTk1OVonfSlcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gd2l0aE1pbGxpcyBmbGFnIHRvIHNob3cgbWlsbGlzZWNvbmRzIG9yIG5vdFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZVxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+c3RyIC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgc3RyaW5nIChleC4nMjAxMzA0MzAyMzU5NTlaJyk8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8bGk+ZGF0ZSAtIHNwZWNpZnkgRGF0ZSBvYmplY3QuPC9saT5cbiAqIDxsaT5taWxsaXMgLSBzcGVjaWZ5IGZsYWcgdG8gc2hvdyBtaWxsaXNlY29uZHMgKGZyb20gMS4wLjYpPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFMTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKiBOT1RFMjogJ3dpdGhNaWxsaXMnIHByb3BlcnR5IGlzIHN1cHBvcnRlZCBmcm9tIGFzbjEgMS4wLjYuXG4gKi9cbktKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjE4XCI7XG4gICAgdGhpcy53aXRoTWlsbGlzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBEYXRlIG9iamVjdFxuICAgICAqIEBuYW1lIHNldEJ5RGF0ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZU9iamVjdCBEYXRlIG9iamVjdCB0byBzZXQgQVNOLjEgdmFsdWUoVilcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFdoZW4geW91IHNwZWNpZnkgVVRDIHRpbWUsIHVzZSAnRGF0ZS5VVEMnIG1ldGhvZCBsaWtlIHRoaXM6PGJyLz5cbiAgICAgKiBvMSA9IG5ldyBERVJVVENUaW1lKCk7XG4gICAgICogbzEuc2V0QnlEYXRlKGRhdGUpO1xuICAgICAqXG4gICAgICogZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKDIwMTUsIDAsIDMxLCAyMywgNTksIDU5LCAwKSk7ICMyMDE1SkFOMzEgMjM6NTk6NTlcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5RGF0ZSA9IGZ1bmN0aW9uKGRhdGVPYmplY3QpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kYXRlID0gZGF0ZU9iamVjdDtcbiAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ2dlbicsIHRoaXMud2l0aE1pbGxpcyk7XG4gICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsICdnZW4nLCB0aGlzLndpdGhNaWxsaXMpO1xuICAgICAgICAgICAgdGhpcy5oViA9IHN0b2hleCh0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zdHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zLnN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcInN0cmluZ1wiICYmIHBhcmFtcy5tYXRjaCgvXlswLTldezE0fVokLykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZ0hleChwYXJhbXMuaGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5RGF0ZShwYXJhbXMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5taWxsaXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMud2l0aE1pbGxpcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZSwgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgU2VxdWVuY2VcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJTZXF1ZW5jZVxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgU2VxdWVuY2VcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWRcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPmFycmF5IC0gc3BlY2lmeSBhcnJheSBvZiBBU04xT2JqZWN0IHRvIHNldCBlbGVtZW50cyBvZiBjb250ZW50PC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuS0pVUi5hc24xLkRFUlNlcXVlbmNlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlNlcXVlbmNlLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjMwXCI7XG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hc24xQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhc24xT2JqID0gdGhpcy5hc24xQXJyYXlbaV07XG4gICAgICAgICAgICBoICs9IGFzbjFPYmouZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaFYgPSBoO1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJTZXF1ZW5jZSwgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgU2V0XG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSU2V0XG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBTZXRcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWRcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPmFycmF5IC0gc3BlY2lmeSBhcnJheSBvZiBBU04xT2JqZWN0IHRvIHNldCBlbGVtZW50cyBvZiBjb250ZW50PC9saT5cbiAqIDxsaT5zb3J0ZmxhZyAtIGZsYWcgZm9yIHNvcnQgKGRlZmF1bHQ6IHRydWUpLiBBU04uMSBCRVIgaXMgbm90IHNvcnRlZCBpbiAnU0VUIE9GJy48L2xpPlxuICogPC91bD5cbiAqIE5PVEUxOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC48YnIvPlxuICogTk9URTI6IHNvcnRmbGFnIGlzIHN1cHBvcnRlZCBzaW5jZSAxLjAuNS5cbiAqL1xuS0pVUi5hc24xLkRFUlNldCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJTZXQuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMzFcIjtcbiAgICB0aGlzLnNvcnRGbGFnID0gdHJ1ZTsgLy8gaXRlbSBzaGFsbCBiZSBzb3J0ZWQgb25seSBpbiBBU04uMSBERVJcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFzbjFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFzbjFPYmogPSB0aGlzLmFzbjFBcnJheVtpXTtcbiAgICAgICAgICAgIGEucHVzaChhc24xT2JqLmdldEVuY29kZWRIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc29ydEZsYWcgPT0gdHJ1ZSkgYS5zb3J0KCk7XG4gICAgICAgIHRoaXMuaFYgPSBhLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5zb3J0ZmxhZyAhPSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBwYXJhbXMuc29ydGZsYWcgPT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNvcnRGbGFnID0gZmFsc2U7XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJTZXQsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFRhZ2dlZE9iamVjdFxuICogQG5hbWUgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVGFnZ2VkT2JqZWN0XG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogUGFyYW1ldGVyICd0YWdOb05leCcgaXMgQVNOLjEgdGFnKFQpIHZhbHVlIGZvciB0aGlzIG9iamVjdC5cbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgZmluZCAnWzFdJyB0YWcgaW4gYSBBU04uMSBkdW1wLFxuICogJ3RhZ05vSGV4JyB3aWxsIGJlICdhMScuXG4gKiA8YnIvPlxuICogQXMgZm9yIG9wdGlvbmFsIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5ICpBTlkqIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5leHBsaWNpdCAtIHNwZWNpZnkgdHJ1ZSBpZiB0aGlzIGlzIGV4cGxpY2l0IHRhZyBvdGhlcndpc2UgZmFsc2VcbiAqICAgICAoZGVmYXVsdCBpcyAndHJ1ZScpLjwvbGk+XG4gKiA8bGk+dGFnIC0gc3BlY2lmeSB0YWcgKGRlZmF1bHQgaXMgJ2EwJyB3aGljaCBtZWFucyBbMF0pPC9saT5cbiAqIDxsaT5vYmogLSBzcGVjaWZ5IEFTTjFPYmplY3Qgd2hpY2ggaXMgdGFnZ2VkPC9saT5cbiAqIDwvdWw+XG4gKiBAZXhhbXBsZVxuICogZDEgPSBuZXcgS0pVUi5hc24xLkRFUlVURjhTdHJpbmcoeydzdHInOidhJ30pO1xuICogZDIgPSBuZXcgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdCh7J29iaic6IGQxfSk7XG4gKiBoZXggPSBkMi5nZXRFbmNvZGVkSGV4KCk7XG4gKi9cbktKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3QgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0LnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCJhMFwiO1xuICAgIHRoaXMuaFYgPSAnJztcbiAgICB0aGlzLmlzRXhwbGljaXQgPSB0cnVlO1xuICAgIHRoaXMuYXNuMU9iamVjdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYW4gQVNOMU9iamVjdFxuICAgICAqIEBuYW1lIHNldFN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0I1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFeHBsaWNpdEZsYWcgZmxhZyBmb3IgZXhwbGljaXQvaW1wbGljaXQgdGFnXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB0YWdOb0hleCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgdGFnXG4gICAgICogQHBhcmFtIHtBU04xT2JqZWN0fSBhc24xT2JqZWN0IEFTTi4xIHRvIGVuY2Fwc3VsYXRlXG4gICAgICovXG4gICAgdGhpcy5zZXRBU04xT2JqZWN0ID0gZnVuY3Rpb24oaXNFeHBsaWNpdEZsYWcsIHRhZ05vSGV4LCBhc24xT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuaFQgPSB0YWdOb0hleDtcbiAgICAgICAgdGhpcy5pc0V4cGxpY2l0ID0gaXNFeHBsaWNpdEZsYWc7XG4gICAgICAgIHRoaXMuYXNuMU9iamVjdCA9IGFzbjFPYmplY3Q7XG4gICAgICAgIGlmICh0aGlzLmlzRXhwbGljaXQpIHtcbiAgICAgICAgICAgIHRoaXMuaFYgPSB0aGlzLmFzbjFPYmplY3QuZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhWID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaFRMViA9IGFzbjFPYmplY3QuZ2V0RW5jb2RlZEhleCgpO1xuICAgICAgICAgICAgdGhpcy5oVExWID0gdGhpcy5oVExWLnJlcGxhY2UoL14uLi8sIHRhZ05vSGV4KTtcbiAgICAgICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1sndGFnJ10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5oVCA9IHBhcmFtc1sndGFnJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ2V4cGxpY2l0J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5pc0V4cGxpY2l0ID0gcGFyYW1zWydleHBsaWNpdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydvYmonXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmFzbjFPYmplY3QgPSBwYXJhbXNbJ29iaiddO1xuICAgICAgICAgICAgdGhpcy5zZXRBU04xT2JqZWN0KHRoaXMuaXNFeHBsaWNpdCwgdGhpcy5oVCwgdGhpcy5hc24xT2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0LCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEpTRW5jcnlwdFJTQUtleSB0aGF0IGV4dGVuZHMgVG9tIFd1J3MgUlNBIGtleSBvYmplY3QuXG4gKiBUaGlzIG9iamVjdCBpcyBqdXN0IGEgZGVjb3JhdG9yIGZvciBwYXJzaW5nIHRoZSBrZXkgcGFyYW1ldGVyXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleSAtIFRoZSBrZXkgaW4gc3RyaW5nIGZvcm1hdCwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAqIHRoZSBwYXJhbWV0ZXJzIG5lZWRlZCB0byBidWlsZCBhIFJTQUtleSBvYmplY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpTRW5jcnlwdFJTQUtleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNFbmNyeXB0UlNBS2V5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTRW5jcnlwdFJTQUtleShrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLy8gQ2FsbCB0aGUgc3VwZXIgY29uc3RydWN0b3IuXG4gICAgICAgIC8vICBSU0FLZXkuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gSWYgYSBrZXkga2V5IHdhcyBwcm92aWRlZC5cbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmluZy4uLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZUtleShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoSlNFbmNyeXB0UlNBS2V5Lmhhc1ByaXZhdGVLZXlQcm9wZXJ0eShrZXkpIHx8XG4gICAgICAgICAgICAgICAgSlNFbmNyeXB0UlNBS2V5Lmhhc1B1YmxpY0tleVByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlcyBmb3IgdGhlIGtleS5cbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZVByb3BlcnRpZXNGcm9tKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcGFyc2UgYSBwZW0gZW5jb2RlZCBzdHJpbmcgY29udGFpbmluZyBib3RoIGEgcHVibGljIG9yIHByaXZhdGUga2V5LlxuICAgICAqIFRoZSBtZXRob2Qgd2lsbCB0cmFuc2xhdGUgdGhlIHBlbSBlbmNvZGVkIHN0cmluZyBpbiBhIGRlciBlbmNvZGVkIHN0cmluZyBhbmRcbiAgICAgKiB3aWxsIHBhcnNlIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5IHBhcmFtZXRlcnMuIFRoaXMgbWV0aG9kIGFjY2VwdHMgcHVibGljIGtleVxuICAgICAqIGluIHRoZSByc2FlbmNyeXB0aW9uIHBrY3MgIzEgZm9ybWF0IChvaWQ6IDEuMi44NDAuMTEzNTQ5LjEuMS4xKS5cbiAgICAgKlxuICAgICAqIEB0b2RvIENoZWNrIGhvdyBtYW55IHJzYSBmb3JtYXRzIHVzZSB0aGUgc2FtZSBmb3JtYXQgb2YgcGtjcyAjMS5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgaXMgZGVmaW5lZCBhczpcbiAgICAgKiBQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBhbGdvcml0aG0gICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAgICAgKiAgIFB1YmxpY0tleSAgICAgICBCSVQgU1RSSU5HXG4gICAgICogfVxuICAgICAqIFdoZXJlIEFsZ29yaXRobUlkZW50aWZpZXIgaXM6XG4gICAgICogQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgYWxnb3JpdGhtICAgICAgIE9CSkVDVCBJREVOVElGSUVSLCAgICAgdGhlIE9JRCBvZiB0aGUgZW5jIGFsZ29yaXRobVxuICAgICAqICAgcGFyYW1ldGVycyAgICAgIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTCAoTlVMTCBmb3IgUEtDUyAjMSlcbiAgICAgKiB9XG4gICAgICogYW5kIFB1YmxpY0tleSBpcyBhIFNFUVVFTkNFIGVuY2Fwc3VsYXRlZCBpbiBhIEJJVCBTVFJJTkdcbiAgICAgKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIG1vZHVsdXMgICAgICAgICAgIElOVEVHRVIsICAtLSBuXG4gICAgICogICBwdWJsaWNFeHBvbmVudCAgICBJTlRFR0VSICAgLS0gZVxuICAgICAqIH1cbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRvIGV4YW1pbmUgdGhlIHN0cnVjdHVyZSBvZiB0aGUga2V5cyBvYnRhaW5lZCBmcm9tIG9wZW5zc2wgdXNpbmdcbiAgICAgKiBhbiBhc24uMSBkdW1wZXIgYXMgdGhlIG9uZSB1c2VkIGhlcmUgdG8gcGFyc2UgdGhlIGNvbXBvbmVudHM6IGh0dHA6Ly9sYXBvLml0L2FzbjFqcy9cbiAgICAgKiBAYXJndW1lbnQge3N0cmluZ30gcGVtIHRoZSBwZW0gZW5jb2RlZCBzdHJpbmcsIGNhbiBpbmNsdWRlIHRoZSBCRUdJTi9FTkQgaGVhZGVyL2Zvb3RlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5wYXJzZUtleSA9IGZ1bmN0aW9uIChwZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtb2R1bHVzID0gMDtcbiAgICAgICAgICAgIHZhciBwdWJsaWNfZXhwb25lbnQgPSAwO1xuICAgICAgICAgICAgdmFyIHJlSGV4ID0gL15cXHMqKD86WzAtOUEtRmEtZl1bMC05QS1GYS1mXVxccyopKyQvO1xuICAgICAgICAgICAgdmFyIGRlciA9IHJlSGV4LnRlc3QocGVtKSA/IEhleC5kZWNvZGUocGVtKSA6IEJhc2U2NC51bmFybW9yKHBlbSk7XG4gICAgICAgICAgICB2YXIgYXNuMSA9IEFTTjEuZGVjb2RlKGRlcik7XG4gICAgICAgICAgICAvLyBGaXhlcyBhIGJ1ZyB3aXRoIE9wZW5TU0wgMS4wKyBwcml2YXRlIGtleXNcbiAgICAgICAgICAgIGlmIChhc24xLnN1Yi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBhc24xID0gYXNuMS5zdWJbMl0uc3ViWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzbjEuc3ViLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBwcml2YXRlIGtleS5cbiAgICAgICAgICAgICAgICBtb2R1bHVzID0gYXNuMS5zdWJbMV0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5uID0gcGFyc2VCaWdJbnQobW9kdWx1cywgMTYpO1xuICAgICAgICAgICAgICAgIHB1YmxpY19leHBvbmVudCA9IGFzbjEuc3ViWzJdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGludFxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KHB1YmxpY19leHBvbmVudCwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBwcml2YXRlX2V4cG9uZW50ID0gYXNuMS5zdWJbM10uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5kID0gcGFyc2VCaWdJbnQocHJpdmF0ZV9leHBvbmVudCwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBwcmltZTEgPSBhc24xLnN1Yls0XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBwYXJzZUJpZ0ludChwcmltZTEsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWUyID0gYXNuMS5zdWJbNV0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5xID0gcGFyc2VCaWdJbnQocHJpbWUyLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50MSA9IGFzbjEuc3ViWzZdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxuICAgICAgICAgICAgICAgIHRoaXMuZG1wMSA9IHBhcnNlQmlnSW50KGV4cG9uZW50MSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudDIgPSBhc24xLnN1Yls3XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmRtcTEgPSBwYXJzZUJpZ0ludChleHBvbmVudDIsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgY29lZmZpY2llbnQgPSBhc24xLnN1Yls4XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmID0gcGFyc2VCaWdJbnQoY29lZmZpY2llbnQsIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFzbjEuc3ViLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBwdWJsaWMga2V5LlxuICAgICAgICAgICAgICAgIHZhciBiaXRfc3RyaW5nID0gYXNuMS5zdWJbMV07XG4gICAgICAgICAgICAgICAgdmFyIHNlcXVlbmNlID0gYml0X3N0cmluZy5zdWJbMF07XG4gICAgICAgICAgICAgICAgbW9kdWx1cyA9IHNlcXVlbmNlLnN1YlswXS5nZXRIZXhTdHJpbmdWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubiA9IHBhcnNlQmlnSW50KG1vZHVsdXMsIDE2KTtcbiAgICAgICAgICAgICAgICBwdWJsaWNfZXhwb25lbnQgPSBzZXF1ZW5jZS5zdWJbMV0uZ2V0SGV4U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChwdWJsaWNfZXhwb25lbnQsIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGUgcnNhIHBhcmFtZXRlcnMgaW4gYSBoZXggZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByc2Ega2V5LlxuICAgICAqXG4gICAgICogVGhlIHRyYW5zbGF0aW9uIGZvbGxvdyB0aGUgQVNOLjEgbm90YXRpb24gOlxuICAgICAqIFJTQVByaXZhdGVLZXkgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIHZlcnNpb24gICAgICAgICAgIFZlcnNpb24sXG4gICAgICogICBtb2R1bHVzICAgICAgICAgICBJTlRFR0VSLCAgLS0gblxuICAgICAqICAgcHVibGljRXhwb25lbnQgICAgSU5URUdFUiwgIC0tIGVcbiAgICAgKiAgIHByaXZhdGVFeHBvbmVudCAgIElOVEVHRVIsICAtLSBkXG4gICAgICogICBwcmltZTEgICAgICAgICAgICBJTlRFR0VSLCAgLS0gcFxuICAgICAqICAgcHJpbWUyICAgICAgICAgICAgSU5URUdFUiwgIC0tIHFcbiAgICAgKiAgIGV4cG9uZW50MSAgICAgICAgIElOVEVHRVIsICAtLSBkIG1vZCAocDEpXG4gICAgICogICBleHBvbmVudDIgICAgICAgICBJTlRFR0VSLCAgLS0gZCBtb2QgKHEtMSlcbiAgICAgKiAgIGNvZWZmaWNpZW50ICAgICAgIElOVEVHRVIsICAtLSAoaW52ZXJzZSBvZiBxKSBtb2QgcFxuICAgICAqIH1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgREVSIEVuY29kZWQgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnNhIHByaXZhdGUga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFByaXZhdGVCYXNlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFycmF5OiBbXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgaW50OiAwIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5uIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGludDogdGhpcy5lIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5wIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5xIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kbXAxIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kbXExIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5jb2VmZiB9KVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VxID0gbmV3IEtKVVIuYXNuMS5ERVJTZXF1ZW5jZShvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHNlcS5nZXRFbmNvZGVkSGV4KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBiYXNlNjQgKHBlbSkgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBERVIgZW5jb2RlZCByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQcml2YXRlQmFzZUtleUI2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhleDJiNjQodGhpcy5nZXRQcml2YXRlQmFzZUtleSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZSByc2EgcGFyYW1ldGVycyBpbiBhIGhleCBlbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJzYSBwdWJsaWMga2V5LlxuICAgICAqIFRoZSByZXByZXNlbnRhdGlvbiBmb2xsb3cgdGhlIEFTTi4xIG5vdGF0aW9uIDpcbiAgICAgKiBQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBhbGdvcml0aG0gICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAgICAgKiAgIFB1YmxpY0tleSAgICAgICBCSVQgU1RSSU5HXG4gICAgICogfVxuICAgICAqIFdoZXJlIEFsZ29yaXRobUlkZW50aWZpZXIgaXM6XG4gICAgICogQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgYWxnb3JpdGhtICAgICAgIE9CSkVDVCBJREVOVElGSUVSLCAgICAgdGhlIE9JRCBvZiB0aGUgZW5jIGFsZ29yaXRobVxuICAgICAqICAgcGFyYW1ldGVycyAgICAgIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTCAoTlVMTCBmb3IgUEtDUyAjMSlcbiAgICAgKiB9XG4gICAgICogYW5kIFB1YmxpY0tleSBpcyBhIFNFUVVFTkNFIGVuY2Fwc3VsYXRlZCBpbiBhIEJJVCBTVFJJTkdcbiAgICAgKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIG1vZHVsdXMgICAgICAgICAgIElOVEVHRVIsICAtLSBuXG4gICAgICogICBwdWJsaWNFeHBvbmVudCAgICBJTlRFR0VSICAgLS0gZVxuICAgICAqIH1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBERVIgRW5jb2RlZCBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByc2EgcHVibGljIGtleVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQdWJsaWNCYXNlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlyc3Rfc2VxdWVuY2UgPSBuZXcgS0pVUi5hc24xLkRFUlNlcXVlbmNlKHtcbiAgICAgICAgICAgIGFycmF5OiBbXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyKHsgb2lkOiBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCIgfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJOdWxsKClcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZWNvbmRfc2VxdWVuY2UgPSBuZXcgS0pVUi5hc24xLkRFUlNlcXVlbmNlKHtcbiAgICAgICAgICAgIGFycmF5OiBbXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgYmlnaW50OiB0aGlzLm4gfSksXG4gICAgICAgICAgICAgICAgbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgaW50OiB0aGlzLmUgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBiaXRfc3RyaW5nID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoe1xuICAgICAgICAgICAgaGV4OiBcIjAwXCIgKyBzZWNvbmRfc2VxdWVuY2UuZ2V0RW5jb2RlZEhleCgpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2VxID0gbmV3IEtKVVIuYXNuMS5ERVJTZXF1ZW5jZSh7XG4gICAgICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgICAgIGZpcnN0X3NlcXVlbmNlLFxuICAgICAgICAgICAgICAgIGJpdF9zdHJpbmdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXEuZ2V0RW5jb2RlZEhleCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYmFzZTY0IChwZW0pIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgREVSIGVuY29kZWQgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiB3aXRob3V0IGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHVibGljQmFzZUtleUI2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhleDJiNjQodGhpcy5nZXRQdWJsaWNCYXNlS2V5KCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogd3JhcCB0aGUgc3RyaW5nIGluIGJsb2NrIG9mIHdpZHRoIGNoYXJzLiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgcnNhIGtleXMgaXMgNjRcbiAgICAgKiBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHBlbSBlbmNvZGVkIHN0cmluZyB3aXRob3V0IGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD02NF0gLSB0aGUgbGVuZ3RoIHRoZSBzdHJpbmcgaGFzIHRvIGJlIHdyYXBwZWQgYXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LndvcmR3cmFwID0gZnVuY3Rpb24gKHN0ciwgd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCA2NDtcbiAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZ2V4ID0gXCIoLnsxLFwiICsgd2lkdGggKyBcIn0pKCArfCRcXG4/KXwoLnsxLFwiICsgd2lkdGggKyBcIn0pXCI7XG4gICAgICAgIHJldHVybiBzdHIubWF0Y2goUmVnRXhwKHJlZ2V4LCBcImdcIikpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcGVtIGVuY29kZWQgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcGVtIGVuY29kZWQgcHJpdmF0ZSBrZXkgd2l0aCBoZWFkZXIvZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleSA9IFwiLS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLVxcblwiO1xuICAgICAgICBrZXkgKz0gSlNFbmNyeXB0UlNBS2V5LndvcmR3cmFwKHRoaXMuZ2V0UHJpdmF0ZUJhc2VLZXlCNjQoKSkgKyBcIlxcblwiO1xuICAgICAgICBrZXkgKz0gXCItLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLVwiO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHBlbSBlbmNvZGVkIHB1YmxpYyBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcGVtIGVuY29kZWQgcHVibGljIGtleSB3aXRoIGhlYWRlci9mb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXkgPSBcIi0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuXCI7XG4gICAgICAgIGtleSArPSBKU0VuY3J5cHRSU0FLZXkud29yZHdyYXAodGhpcy5nZXRQdWJsaWNCYXNlS2V5QjY0KCkpICsgXCJcXG5cIjtcbiAgICAgICAga2V5ICs9IFwiLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXCI7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcGFyYW1ldGVycyB0byBwb3B1bGF0ZSB0aGUgcnNhIG1vZHVsdXNcbiAgICAgKiBhbmQgcHVibGljIGV4cG9uZW50IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmo9e31dIC0gQW4gb2JqZWN0IHRoYXQgbWF5IGNvbnRhaW4gdGhlIHR3byBwdWJsaWMga2V5XG4gICAgICogcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYm90aCB0aGUgbW9kdWx1cyBhbmQgdGhlIHB1YmxpYyBleHBvbmVudFxuICAgICAqIHByb3BlcnRpZXMgKG4gYW5kIGUpXG4gICAgICogQHRvZG8gY2hlY2sgZm9yIHR5cGVzIG9mIG4gYW5kIGUuIE4gc2hvdWxkIGJlIGEgcGFyc2VhYmxlIGJpZ0ludCBvYmplY3QsIEUgc2hvdWxkXG4gICAgICogYmUgYSBwYXJzZWFibGUgaW50ZWdlciBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5oYXNQdWJsaWNLZXlQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgb2JqID0gb2JqIHx8IHt9O1xuICAgICAgICByZXR1cm4gKG9iai5oYXNPd25Qcm9wZXJ0eShcIm5cIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImVcIikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIG9iamVjdCBjb250YWlucyBBTEwgdGhlIHBhcmFtZXRlcnMgb2YgYW4gUlNBIGtleS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iaj17fV0gLSBBbiBvYmplY3QgdGhhdCBtYXkgY29udGFpbiBuaW5lIHJzYSBrZXlcbiAgICAgKiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBjb250YWlucyBhbGwgdGhlIHBhcmFtZXRlcnMgbmVlZGVkXG4gICAgICogQHRvZG8gY2hlY2sgZm9yIHR5cGVzIG9mIHRoZSBwYXJhbWV0ZXJzIGFsbCB0aGUgcGFyYW1ldGVycyBidXQgdGhlIHB1YmxpYyBleHBvbmVudFxuICAgICAqIHNob3VsZCBiZSBwYXJzZWFibGUgYmlnaW50IG9iamVjdHMsIHRoZSBwdWJsaWMgZXhwb25lbnQgc2hvdWxkIGJlIGEgcGFyc2VhYmxlIGludGVnZXIgbnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkuaGFzUHJpdmF0ZUtleVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBvYmogPSBvYmogfHwge307XG4gICAgICAgIHJldHVybiAob2JqLmhhc093blByb3BlcnR5KFwiblwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiZVwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiZFwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwicFwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwicVwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiZG1wMVwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiZG1xMVwiKSAmJlxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFwiY29lZmZcIikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIHByb3BlcnRpZXMgb2Ygb2JqIGluIHRoZSBjdXJyZW50IHJzYSBvYmplY3QuIE9iaiBzaG91bGQgQVQgTEVBU1RcbiAgICAgKiBpbmNsdWRlIHRoZSBtb2R1bHVzIGFuZCBwdWJsaWMgZXhwb25lbnQgKG4sIGUpIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgY29udGFpbmluZyByc2EgcGFyYW1ldGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5wYXJzZVByb3BlcnRpZXNGcm9tID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0aGlzLm4gPSBvYmoubjtcbiAgICAgICAgdGhpcy5lID0gb2JqLmU7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoXCJkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmQgPSBvYmouZDtcbiAgICAgICAgICAgIHRoaXMucCA9IG9iai5wO1xuICAgICAgICAgICAgdGhpcy5xID0gb2JqLnE7XG4gICAgICAgICAgICB0aGlzLmRtcDEgPSBvYmouZG1wMTtcbiAgICAgICAgICAgIHRoaXMuZG1xMSA9IG9iai5kbXExO1xuICAgICAgICAgICAgdGhpcy5jb2VmZiA9IG9iai5jb2VmZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEpTRW5jcnlwdFJTQUtleTtcbn0oUlNBS2V5KSk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucyA9IHt9XSAtIEFuIG9iamVjdCB0byBjdXN0b21pemUgSlNFbmNyeXB0IGJlaGF2aW91clxuICogcG9zc2libGUgcGFyYW1ldGVycyBhcmU6XG4gKiAtIGRlZmF1bHRfa2V5X3NpemUgICAgICAgIHtudW1iZXJ9ICBkZWZhdWx0OiAxMDI0IHRoZSBrZXkgc2l6ZSBpbiBiaXRcbiAqIC0gZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQge3N0cmluZ30gIGRlZmF1bHQ6ICcwMTAwMDEnIHRoZSBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGV4cG9uZW50XG4gKiAtIGxvZyAgICAgICAgICAgICAgICAgICAgIHtib29sZWFufSBkZWZhdWx0OiBmYWxzZSB3aGV0aGVyIGxvZyB3YXJuL2Vycm9yIG9yIG5vdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBKU0VuY3J5cHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNFbmNyeXB0KG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuZGVmYXVsdF9rZXlfc2l6ZSA9IHBhcnNlSW50KG9wdGlvbnMuZGVmYXVsdF9rZXlfc2l6ZSwgMTApIHx8IDEwMjQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQgPSBvcHRpb25zLmRlZmF1bHRfcHVibGljX2V4cG9uZW50IHx8IFwiMDEwMDAxXCI7IC8vIDY1NTM3IGRlZmF1bHQgb3BlbnNzbCBwdWJsaWMgZXhwb25lbnQgZm9yIHJzYSBrZXkgdHlwZVxuICAgICAgICB0aGlzLmxvZyA9IG9wdGlvbnMubG9nIHx8IGZhbHNlO1xuICAgICAgICAvLyBUaGUgcHJpdmF0ZSBhbmQgcHVibGljIGtleS5cbiAgICAgICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gc2V0IHRoZSByc2Ega2V5IHBhcmFtZXRlciAob25lIG1ldGhvZCBpcyBlbm91Z2ggdG8gc2V0IGJvdGggdGhlIHB1YmxpY1xuICAgICAqIGFuZCB0aGUgcHJpdmF0ZSBrZXksIHNpbmNlIHRoZSBwcml2YXRlIGtleSBjb250YWlucyB0aGUgcHVibGljIGtleSBwYXJhbWVudGVycylcbiAgICAgKiBMb2cgYSB3YXJuaW5nIGlmIGxvZ3MgYXJlIGVuYWJsZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleSB0aGUgcGVtIGVuY29kZWQgc3RyaW5nIG9yIGFuIG9iamVjdCAod2l0aCBvciB3aXRob3V0IGhlYWRlci9mb290ZXIpXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5sb2cgJiYgdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkEga2V5IHdhcyBhbHJlYWR5IHNldCwgb3ZlcnJpZGluZyBleGlzdGluZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXkgPSBuZXcgSlNFbmNyeXB0UlNBS2V5KGtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIHNldEtleSwgZm9yIGFwaSBjb21wYXRpYmlsaXR5XG4gICAgICogQHNlZSBzZXRLZXlcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5zZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKHByaXZrZXkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBrZXkuXG4gICAgICAgIHRoaXMuc2V0S2V5KHByaXZrZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBzZXRLZXksIGZvciBhcGkgY29tcGF0aWJpbGl0eVxuICAgICAqIEBzZWUgc2V0S2V5XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuc2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKHB1YmtleSkge1xuICAgICAgICAvLyBTZXRzIHRoZSBwdWJsaWMga2V5LlxuICAgICAgICB0aGlzLnNldEtleShwdWJrZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3MgZGVjcnlwdCwgZGVjcnlwdCB0aGUgc3RyaW5nIHVzaW5nIHRoZSBwcml2YXRlXG4gICAgICogY29tcG9uZW50cyBvZiB0aGUgcnNhIGtleSBvYmplY3QuIE5vdGUgdGhhdCBpZiB0aGUgb2JqZWN0IHdhcyBub3Qgc2V0IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIG9uIHRoZSBmbHkgKGJ5IHRoZSBnZXRLZXkgbWV0aG9kKSB1c2luZyB0aGUgcGFyYW1ldGVycyBwYXNzZWQgaW4gdGhlIEpTRW5jcnlwdCBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgYmFzZTY0IGVuY29kZWQgY3J5cHRlZCBzdHJpbmcgdG8gZGVjcnlwdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRlY3J5cHRlZCBzdHJpbmdcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGRlY3J5cHRlZCBzdHJpbmcuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS5kZWNyeXB0KGI2NHRvaGV4KHN0cikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIFJTQUtleSBvYmplY3QncyBlbmNyeXB0LCBlbmNyeXB0IHRoZSBzdHJpbmcgdXNpbmcgdGhlIHB1YmxpY1xuICAgICAqIGNvbXBvbmVudHMgb2YgdGhlIHJzYSBrZXkgb2JqZWN0LiBOb3RlIHRoYXQgaWYgdGhlIG9iamVjdCB3YXMgbm90IHNldCB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBvbiB0aGUgZmx5IChieSB0aGUgZ2V0S2V5IG1ldGhvZCkgdXNpbmcgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIGluIHRoZSBKU0VuY3J5cHQgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gZW5jcnlwdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVuY3J5cHRlZCBzdHJpbmcgZW5jb2RlZCBpbiBiYXNlNjRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGVuY3J5cHRlZCBzdHJpbmcuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4MmI2NCh0aGlzLmdldEtleSgpLmVuY3J5cHQoc3RyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3h5IG1ldGhvZCBmb3IgUlNBS2V5IG9iamVjdCdzIHNpZ24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHNpZ25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaWdlc3RNZXRob2QgaGFzaCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlnZXN0TmFtZSB0aGUgbmFtZSBvZiB0aGUgaGFzaCBhbGdvcml0aG1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBzaWduYXR1cmUgZW5jb2RlZCBpbiBiYXNlNjRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKHN0ciwgZGlnZXN0TWV0aG9kLCBkaWdlc3ROYW1lKSB7XG4gICAgICAgIC8vIHJldHVybiB0aGUgUlNBIHNpZ25hdHVyZSBvZiAnc3RyJyBpbiAnaGV4JyBmb3JtYXQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4MmI2NCh0aGlzLmdldEtleSgpLnNpZ24oc3RyLCBkaWdlc3RNZXRob2QsIGRpZ2VzdE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3MgdmVyaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB2ZXJpZnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgZW5jb2RlZCBpbiBiYXNlNjQgdG8gY29tcGFyZSB0aGUgc3RyaW5nIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlnZXN0TWV0aG9kIGhhc2ggbWV0aG9kXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZGF0YSBhbmQgc2lnbmF0dXJlIG1hdGNoXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKHN0ciwgc2lnbmF0dXJlLCBkaWdlc3RNZXRob2QpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBkZWNyeXB0ZWQgJ2RpZ2VzdCcgb2YgdGhlIHNpZ25hdHVyZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLnZlcmlmeShzdHIsIGI2NHRvaGV4KHNpZ25hdHVyZSksIGRpZ2VzdE1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHRlciBmb3IgdGhlIGN1cnJlbnQgSlNFbmNyeXB0UlNBS2V5IG9iamVjdC4gSWYgaXQgZG9lc24ndCBleGlzdHMgYSBuZXcgb2JqZWN0XG4gICAgICogd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZFxuICAgICAqIEBwYXJhbSB7Y2FsbGJhY2t9IFtjYl0gdGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBpZiB3ZSB3YW50IHRoZSBrZXkgdG8gYmUgZ2VuZXJhdGVkXG4gICAgICogaW4gYW4gYXN5bmMgZmFzaGlvblxuICAgICAqIEByZXR1cm5zIHtKU0VuY3J5cHRSU0FLZXl9IHRoZSBKU0VuY3J5cHRSU0FLZXkgb2JqZWN0XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIG5ldyBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgICAgICAgLy8gR2V0IGEgbmV3IHByaXZhdGUga2V5LlxuICAgICAgICAgICAgdGhpcy5rZXkgPSBuZXcgSlNFbmNyeXB0UlNBS2V5KCk7XG4gICAgICAgICAgICBpZiAoY2IgJiYge30udG9TdHJpbmcuY2FsbChjYikgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIikge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5LmdlbmVyYXRlQXN5bmModGhpcy5kZWZhdWx0X2tleV9zaXplLCB0aGlzLmRlZmF1bHRfcHVibGljX2V4cG9uZW50LCBjYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGtleS5cbiAgICAgICAgICAgIHRoaXMua2V5LmdlbmVyYXRlKHRoaXMuZGVmYXVsdF9rZXlfc2l6ZSwgdGhpcy5kZWZhdWx0X3B1YmxpY19leHBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5XG4gICAgICogSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0cyBhIG5ldyBrZXkgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5IFdJVEggaGVhZGVyIGFuZCBmb290ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmdldFByaXZhdGVLZXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleVxuICAgICAqIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdHMgYSBuZXcga2V5IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleSBXSVRIT1VUIGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleUI2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwcml2YXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMga2V5LlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS5nZXRQcml2YXRlQmFzZUtleUI2NCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICAgKiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IGtleSB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBXSVRIIGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmdldFB1YmxpY0tleSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICAgKiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IGtleSB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBXSVRIT1VUIGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0UHVibGljS2V5QjY0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpLmdldFB1YmxpY0Jhc2VLZXlCNjQoKTtcbiAgICB9O1xuICAgIEpTRW5jcnlwdC52ZXJzaW9uID0gXCIzLjAuMC1yYy4xXCI7XG4gICAgcmV0dXJuIEpTRW5jcnlwdDtcbn0oKSk7XG5cbndpbmRvdy5KU0VuY3J5cHQgPSBKU0VuY3J5cHQ7XG5cbmV4cG9ydHMuSlNFbmNyeXB0ID0gSlNFbmNyeXB0O1xuZXhwb3J0cy5kZWZhdWx0ID0gSlNFbmNyeXB0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcblxuLy8gVGhpcyB3aWxsIGJlIGEgcHJvcGVyIGl0ZXJhYmxlICdNYXAnIGluIGVuZ2luZXMgdGhhdCBzdXBwb3J0IGl0LFxuLy8gb3IgYSBmYWtleS1mYWtlIFBzZXVkb01hcCBpbiBvbGRlciB2ZXJzaW9ucy5cbnZhciBNYXAgPSByZXF1aXJlKCdwc2V1ZG9tYXAnKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xudmFyIFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcblxuLy8gdXNlIHN5bWJvbHMgaWYgcG9zc2libGUsIG90aGVyd2lzZSBqdXN0IF9wcm9wc1xudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvY2Vzcy5lbnYuX25vZGVMUlVDYWNoZUZvcmNlTm9TeW1ib2wgIT09ICcxJ1xudmFyIG1ha2VTeW1ib2xcbmlmIChoYXNTeW1ib2wpIHtcbiAgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gU3ltYm9sKGtleSlcbiAgfVxufSBlbHNlIHtcbiAgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gJ18nICsga2V5XG4gIH1cbn1cblxudmFyIE1BWCA9IG1ha2VTeW1ib2woJ21heCcpXG52YXIgTEVOR1RIID0gbWFrZVN5bWJvbCgnbGVuZ3RoJylcbnZhciBMRU5HVEhfQ0FMQ1VMQVRPUiA9IG1ha2VTeW1ib2woJ2xlbmd0aENhbGN1bGF0b3InKVxudmFyIEFMTE9XX1NUQUxFID0gbWFrZVN5bWJvbCgnYWxsb3dTdGFsZScpXG52YXIgTUFYX0FHRSA9IG1ha2VTeW1ib2woJ21heEFnZScpXG52YXIgRElTUE9TRSA9IG1ha2VTeW1ib2woJ2Rpc3Bvc2UnKVxudmFyIE5PX0RJU1BPU0VfT05fU0VUID0gbWFrZVN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKVxudmFyIExSVV9MSVNUID0gbWFrZVN5bWJvbCgnbHJ1TGlzdCcpXG52YXIgQ0FDSEUgPSBtYWtlU3ltYm9sKCdjYWNoZScpXG5cbmZ1bmN0aW9uIG5haXZlTGVuZ3RoICgpIHsgcmV0dXJuIDEgfVxuXG4vLyBscnVMaXN0IGlzIGEgeWFsbGlzdCB3aGVyZSB0aGUgaGVhZCBpcyB0aGUgeW91bmdlc3Rcbi8vIGl0ZW0sIGFuZCB0aGUgdGFpbCBpcyB0aGUgb2xkZXN0LiAgdGhlIGxpc3QgY29udGFpbnMgdGhlIEhpdFxuLy8gb2JqZWN0cyBhcyB0aGUgZW50cmllcy5cbi8vIEVhY2ggSGl0IG9iamVjdCBoYXMgYSByZWZlcmVuY2UgdG8gaXRzIFlhbGxpc3QuTm9kZS4gIFRoaXNcbi8vIG5ldmVyIGNoYW5nZXMuXG4vL1xuLy8gY2FjaGUgaXMgYSBNYXAgKG9yIFBzZXVkb01hcCkgdGhhdCBtYXRjaGVzIHRoZSBrZXlzIHRvXG4vLyB0aGUgWWFsbGlzdC5Ob2RlIG9iamVjdC5cbmZ1bmN0aW9uIExSVUNhY2hlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMUlVDYWNoZSkpIHtcbiAgICByZXR1cm4gbmV3IExSVUNhY2hlKG9wdGlvbnMpXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdmFyIG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4XG4gIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgaWYgKCFtYXggfHxcbiAgICAgICEodHlwZW9mIG1heCA9PT0gJ251bWJlcicpIHx8XG4gICAgICBtYXggPD0gMCkge1xuICAgIHRoaXNbTUFYXSA9IEluZmluaXR5XG4gIH1cblxuICB2YXIgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICBpZiAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgbGMgPSBuYWl2ZUxlbmd0aFxuICB9XG4gIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbGNcblxuICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDBcbiAgdGhpc1tESVNQT1NFXSA9IG9wdGlvbnMuZGlzcG9zZVxuICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgdGhpcy5yZXNldCgpXG59XG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbWF4Jywge1xuICBzZXQ6IGZ1bmN0aW9uIChtTCkge1xuICAgIGlmICghbUwgfHwgISh0eXBlb2YgbUwgPT09ICdudW1iZXInKSB8fCBtTCA8PSAwKSB7XG4gICAgICBtTCA9IEluZmluaXR5XG4gICAgfVxuICAgIHRoaXNbTUFYXSA9IG1MXG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdhbGxvd1N0YWxlJywge1xuICBzZXQ6IGZ1bmN0aW9uIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdtYXhBZ2UnLCB7XG4gIHNldDogZnVuY3Rpb24gKG1BKSB7XG4gICAgaWYgKCFtQSB8fCAhKHR5cGVvZiBtQSA9PT0gJ251bWJlcicpIHx8IG1BIDwgMCkge1xuICAgICAgbUEgPSAwXG4gICAgfVxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYX0FHRV1cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbGVuZ3RoQ2FsY3VsYXRvcicsIHtcbiAgc2V0OiBmdW5jdGlvbiAobEMpIHtcbiAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG4gICAgfVxuICAgIGlmIChsQyAhPT0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0pIHtcbiAgICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbENcbiAgICAgIHRoaXNbTEVOR1RIXSA9IDBcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgICBoaXQubGVuZ3RoID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0oaGl0LnZhbHVlLCBoaXQua2V5KVxuICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdpdGVtQ291bnQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbkxSVUNhY2hlLnByb3RvdHlwZS5yZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICB2YXIgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgd2Fsa2VyID0gcHJldlxuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdGVwIChzZWxmLCBmbiwgbm9kZSwgdGhpc3ApIHtcbiAgdmFyIGhpdCA9IG5vZGUudmFsdWVcbiAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgIGRlbChzZWxmLCBub2RlKVxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pIHtcbiAgICAgIGhpdCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuICBpZiAoaGl0KSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKVxuICB9XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHZhciBuZXh0ID0gd2Fsa2VyLm5leHRcbiAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICB3YWxrZXIgPSBuZXh0XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsua2V5XG4gIH0sIHRoaXMpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsudmFsdWVcbiAgfSwgdGhpcylcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpc1tESVNQT1NFXSAmJlxuICAgICAgdGhpc1tMUlVfTElTVF0gJiZcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gIHRoaXNbTEVOR1RIXSA9IDAgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGZ1bmN0aW9uIChoaXQpIHtcbiAgICBpZiAoIWlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpLnRvQXJyYXkoKS5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICByZXR1cm4gaFxuICB9KVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcExydSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5MUlVDYWNoZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIChuLCBvcHRzKSB7XG4gIHZhciBzdHIgPSAnTFJVQ2FjaGUgeydcbiAgdmFyIGV4dHJhcyA9IGZhbHNlXG5cbiAgdmFyIGFzID0gdGhpc1tBTExPV19TVEFMRV1cbiAgaWYgKGFzKSB7XG4gICAgc3RyICs9ICdcXG4gIGFsbG93U3RhbGU6IHRydWUnXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIG1heCA9IHRoaXNbTUFYXVxuICBpZiAobWF4ICYmIG1heCAhPT0gSW5maW5pdHkpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBtYXg6ICcgKyB1dGlsLmluc3BlY3QobWF4LCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBtYXhBZ2UgPSB0aGlzW01BWF9BR0VdXG4gIGlmIChtYXhBZ2UpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBtYXhBZ2U6ICcgKyB1dGlsLmluc3BlY3QobWF4QWdlLCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBsYyA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdXG4gIGlmIChsYyAmJiBsYyAhPT0gbmFpdmVMZW5ndGgpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBsZW5ndGg6ICcgKyB1dGlsLmluc3BlY3QodGhpc1tMRU5HVEhdLCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBkaWRGaXJzdCA9IGZhbHNlXG4gIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoZGlkRmlyc3QpIHtcbiAgICAgIHN0ciArPSAnLFxcbiAgJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXh0cmFzKSB7XG4gICAgICAgIHN0ciArPSAnLFxcbidcbiAgICAgIH1cbiAgICAgIGRpZEZpcnN0ID0gdHJ1ZVxuICAgICAgc3RyICs9ICdcXG4gICdcbiAgICB9XG4gICAgdmFyIGtleSA9IHV0aWwuaW5zcGVjdChpdGVtLmtleSkuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgJylcbiAgICB2YXIgdmFsID0geyB2YWx1ZTogaXRlbS52YWx1ZSB9XG4gICAgaWYgKGl0ZW0ubWF4QWdlICE9PSBtYXhBZ2UpIHtcbiAgICAgIHZhbC5tYXhBZ2UgPSBpdGVtLm1heEFnZVxuICAgIH1cbiAgICBpZiAobGMgIT09IG5haXZlTGVuZ3RoKSB7XG4gICAgICB2YWwubGVuZ3RoID0gaXRlbS5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGlzU3RhbGUodGhpcywgaXRlbSkpIHtcbiAgICAgIHZhbC5zdGFsZSA9IHRydWVcbiAgICB9XG5cbiAgICB2YWwgPSB1dGlsLmluc3BlY3QodmFsLCBvcHRzKS5zcGxpdCgnXFxuJykuam9pbignXFxuICAnKVxuICAgIHN0ciArPSBrZXkgKyAnID0+ICcgKyB2YWxcbiAgfSlcblxuICBpZiAoZGlkRmlyc3QgfHwgZXh0cmFzKSB7XG4gICAgc3RyICs9ICdcXG4nXG4gIH1cbiAgc3RyICs9ICd9J1xuXG4gIHJldHVybiBzdHJcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICB2YXIgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgdmFyIGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KVxuICAgIHZhciBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAvLyBzcGxpdCBvdXQgaW50byAyIGlmcyBmb3IgYmV0dGVyIGNvdmVyYWdlIHRyYWNraW5nXG4gICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pIHtcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaXRlbS5ub3cgPSBub3dcbiAgICBpdGVtLm1heEFnZSA9IG1heEFnZVxuICAgIGl0ZW0udmFsdWUgPSB2YWx1ZVxuICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgIGl0ZW0ubGVuZ3RoID0gbGVuXG4gICAgdGhpcy5nZXQoa2V5KVxuICAgIHRyaW0odGhpcylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdmFyIGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdClcbiAgdGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZClcbiAgdHJpbSh0aGlzKVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2VcbiAgdmFyIGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gIGlmIChpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gIGlmICghbm9kZSkgcmV0dXJuIG51bGxcbiAgZGVsKHRoaXMsIG5vZGUpXG4gIHJldHVybiBub2RlLnZhbHVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIC8vIHJlc2V0IHRoZSBjYWNoZVxuICB0aGlzLnJlc2V0KClcblxuICB2YXIgbm93ID0gRGF0ZS5ub3coKVxuICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICBmb3IgKHZhciBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgdmFyIGhpdCA9IGFycltsXVxuICAgIHZhciBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgaWYgKGV4cGlyZXNBdCA9PT0gMCkge1xuICAgICAgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgLy8gZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBydW5lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpc1tDQUNIRV0uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGdldChzZWxmLCBrZXksIGZhbHNlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXQgKHNlbGYsIGtleSwgZG9Vc2UpIHtcbiAgdmFyIG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KVxuICBpZiAobm9kZSkge1xuICAgIHZhciBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoaXQpIGhpdCA9IGhpdC52YWx1ZVxuICB9XG4gIHJldHVybiBoaXRcbn1cblxuZnVuY3Rpb24gaXNTdGFsZSAoc2VsZiwgaGl0KSB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZltNQVhfQUdFXSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgc3RhbGUgPSBmYWxzZVxuICB2YXIgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIGlmIChoaXQubWF4QWdlKSB7XG4gICAgc3RhbGUgPSBkaWZmID4gaGl0Lm1heEFnZVxuICB9IGVsc2Uge1xuICAgIHN0YWxlID0gc2VsZltNQVhfQUdFXSAmJiAoZGlmZiA+IHNlbGZbTUFYX0FHRV0pXG4gIH1cbiAgcmV0dXJuIHN0YWxlXG59XG5cbmZ1bmN0aW9uIHRyaW0gKHNlbGYpIHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAodmFyIHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7XG4gICAgICBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICB2YXIgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBkZWwoc2VsZiwgd2Fsa2VyKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWwgKHNlbGYsIG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChzZWxmW0RJU1BPU0VdKSB7XG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcbiAgICB9XG4gICAgc2VsZltMRU5HVEhdIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSlcbiAgICBzZWxmW0xSVV9MSVNUXS5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cbn1cblxuLy8gY2xhc3N5LCBzaW5jZSBWOCBwcmVmZXJzIHByZWRpY3RhYmxlIG9iamVjdHMuXG5mdW5jdGlvbiBFbnRyeSAoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICB0aGlzLmtleSA9IGtleVxuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5ub3cgPSBub3dcbiAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMFxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogUHJvbWlzZVdpbmRvd1xuICogaHR0cHM6Ly9naXRodWIuY29tL2FtZXJjaWVyL3Byb21pc2Utd2luZG93XG4gKiBAaWdub3JlXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciByb290ID0gd2luZG93LFxuICAgICAgcHJvdG90eXBlLFxuICAgICAgaHRtbCA9IHJvb3QuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIC8qKlxuICAgKiBNZXJnZSB0aGUgY29udGVudHMgb2YgdHdvIG9yIG1vcmUgb2JqZWN0cyB0b2dldGhlciBpbnRvIHRoZSBmaXJzdCBvYmplY3QuXG4gICAqXG4gICAqICAgICBtZXJnZSggdGFyZ2V0IFssIG9iamVjdDEgXSBbLCBvYmplY3ROIF0gKVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0ICBBbiBvYmplY3QgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIG5ldyBwcm9wZXJ0aWVzIGlmXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWwgb2JqZWN0cyBhcmUgcGFzc2VkIGluLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0MSBBbiBvYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gbWVyZ2UgaW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3ROIEFuIG9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBtZXJnZSBpbi5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBmaXJzdCBvYmplY3QuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgZXh0ZW5kZWQgPSBhcmd1bWVudHNbMF0sIGtleSwgaTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGtleSBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgZXh0ZW5kZWRba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRlbmRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBwc2V1ZG8tdW5pcXVlIFN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbC5cbiAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIGEgcHNldWRvLXVuaXF1ZSBzdHJpbmcgcHJlZml4ZWQgd2l0aCB0aGUgZ2l2ZW4gcHJlZml4LCBpZiBhbnkuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVW5pcXVlU3RyaW5nKHByZWZpeCkge1xuICAgIHJldHVybiBwcmVmaXggKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIFwiLVwiICsgTWF0aC5mbG9vcigxMGUxMiAqIE1hdGgucmFuZG9tKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQcm9taXNlV2luZG93IG9iamVjdFxuICAgKlxuICAgKiBEdXJpbmcgdGhlIGxpZmVjeWNsZSBvZiB0aGlzIG9iamVjdCwgcG9wdXAgd2luZG93cyBjYW4gYmUgb3BlbmVkLCBjbG9zZWQsXG4gICAqIGFuZCByZW9wZW5lZCBhZ2Fpbi4gSG93ZXZlciwgaXQnXG4gICAqXG4gICAqIEluc3RhbmNpYXRpbmcgdGhpcyBwcm90b3R5cGUgZG9lcyBub3QgaW1tZWRpYXRlbHkgb3BlbnMgYSBuZXcgcG9wdXAgd2luZG93LlxuICAgKiBUbyBvcGVuIHRoZSB3aW5kb3csIHVzZSBgb3BlbigpYCBvbiB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgIHVyaSAgICAgICAgICAgICAgICAgICAgRGVzdGluYXRpb24gVVJJXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgIGNvbmZpZyAgICAgICAgICAgICAgICAgQ29uZmlndXJhdGlvbiBvYmplY3QuIFNlZSBkZXNjcmlwdGlvbiBiZWxvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9ICAgY29uZmlnLndpZHRoICAgICAgICAgICBXaWR0aCBvZiB0aGUgcG9wdXAgd2luZG93LiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9ICAgY29uZmlnLmhlaWdodCAgICAgICAgICBIZWlnaHQgb2YgdGhlIHBvcHVwIHdpbmRvdy4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQgaGVpZ2h0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcucHJvbWlzZVByb3ZpZGVyIFByb21pc2UgcHJvdmlkZXIuIFNob3VsZCByZXR1cm4gYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyAzIGZpZWxkczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGBwcm9taXNlYCB7UHJvbWlzZX0gIGEgbmV3IFByb21pc2Ugb2JqZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgcmVzb2x2ZWAge0Z1bmN0aW9ufSB0aGUgbWV0aG9kIHRvIHJlc29sdmUgdGhlIGdpdmVuIFByb21pc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGByZWplY3RgICB7RnVuY3Rpb259IHRoZSBtZXRob2QgdG8gcmVqZWN0IHRoZSBnaXZlbiBQcm9taXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5vblBvc3RNZXNzYWdlICAgSGFuZGxlciBmb3IgcmVjZWl2aW5nIGEgcG9zdE1lc3NhZ2UgZnJvbSB0aGUgb3BlbmVkIHdpbmRvdy4gRGVmYXVsdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIHJlc29sdmVzIHRoZSBwcm9taXNlIHdpdGggdGhlIGRhdGEgcGFzc2VkIGluIHRoZSBwb3N0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSwgZXhjZXB0IGlmIHRoaXMgZGF0YSBjb250YWlucyBhbiBgZXJyb3JgIGZpZWxkLiBJbiB0aGlzIGNhc2UsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQgcmVqZWN0cyB0aGUgUHJvbWlzZSB3aXRoIHRoZSB2YWx1ZSBvZiB0aGF0IGZpZWxkLiBJbiBhbGwgY2FzZXMsIGNsb3Nlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBwb3B1cCB3aW5kb3cuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5vblBvc3RNZXNzYWdlLmV2ZW50IEV2ZW50IFRoZSBwb3N0TWVzc2FnZSBldmVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gICBjb25maWcud2F0Y2hlckRlbGF5ICAgIFRoZXJlIGlzIG5vIHByb2dyYW1tYXRpYyB3YXkgb2Yga25vd2luZyB3aGVuIGEgcG9wdXAgd2luZG93IGlzIGNsb3NlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlaXRoZXIgbWFudWFsbHkgb3IgcHJvZ3JhbWF0aWNhbGx5KS4gRm9yIHRoaXMgcmVhc29uLCBldmVyeSB0aW1lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZVdpbmRvdyBvcGVucyBhIHBvcHVwLCBhIG5ldyB3YXRjaGVyIGlzIGNyZWF0ZWQuIFRoZSB3YXRjaGVyIGNoZWNrc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ3VsYXJseSBpZiB0aGUgd2luZG93IGlzIHN0aWxsIG9wZW4uIFRoaXMgdmFsdWUgZGVmaW5lcyBhdCB3aGljaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsIHRoaXMgY2hlY2sgaXMgZG9uZS4gRGVmYXVsdHMgdG8gMTAwbXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgIGNvbmZpZy53aW5kb3dOYW1lICAgICAgTmFtZSB0byBiZSBnaW52ZW4gdG8gdGhlIHBvcHVwIHdpbmRvdy4gU2VlIGB3aW5kb3cub3BlbmAgcmVmZXJlbmNlcyBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLiBJZiBgbnVsbGAsIGEgcmFuZG9tIG5hbWUgaXMgZ2VuZXJhdGVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gICBjb25maWcud2luZG93ICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHdpbmRvdyBjb25maWd1cmF0aW9uIHNldHRpbmdzLiBTY3JvbGxiYXJzIGFyZSBlbmFibGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgZGVmYXVsdC4gQWxsIGB3aW5kb3cub3BlbmAgcHRpb25zIGFyZSBhY2NlcHRlZCwgYnV0IHBsZWFzZSBub3RlIHRoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW55IG9mIHRoZW0gaGF2ZSBubyBlZmZlY3QgaW4gbW9zdCBtb2Rlcm4gYnJvd3NlcnMuIFNlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvb3BlbiBmb3IgbW9yZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5vbkNsb3NlICAgICAgICAgRnVuY3Rpb24gYmVpbmcgY2FsbGVkIHdoZW5ldmVyIHRoZSBwb3B1cCBpcyBiZWluZyBjbG9zZWQgKGVpdGhlciBhZnRlciBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdCBtZXNzYWdlIGhhcyBiZWVuIHJlY2VpdmVkLCBvciB3aW5kb3cgaGFzIGJlZW4gY2xvc2VkIGJ5IHVzZXIsIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYC5jbG9zZSgpYCBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGNsb3NlcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1cCB3aW5kb3cgYnkgY2FsbGluZyBgdGhpcy5fd2luZG93LmNsb3NlKClgKS5cbiAgICogQHBhcmFtIHtSZWdFeHB9IGNvbmZpZy5vcmlnaW5SZWdleHAgICAgICBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIHRoZSBvcmlnaW4gcGFydCBvZiBhbiBVUkkuIERlZmF1bHRzIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYG5ldyBSZWdFeHAoJ15bXjovP10rOi8vW14vXSonKWAuIElmIGRvZXNuJ3QgbWF0Y2ggKGV4OiByZWxhdGl2ZSBVUklzKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2UgYGxvY2F0aW9uLm9yaWdpbmAuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gUHJvbWlzZVdpbmRvdyh1cmksIGNvbmZpZykge1xuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHRoaXMuY29uZmlnID0gZXh0ZW5kKHt9LCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRDb25maWcsIGNvbmZpZyk7XG4gICAgdGhpcy5jb25maWcud2luZG93TmFtZSA9IHRoaXMuY29uZmlnLndpbmRvd05hbWUgfHwgZ2VuZXJhdGVVbmlxdWVTdHJpbmcoJ3Byb21pc2Utd2luZG93LScpO1xuICAgIHRoaXMuX29uUG9zdE1lc3NhZ2UgPSB0aGlzLl9vblBvc3RNZXNzYWdlLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgUHJvbWlzZSBwcm92aWRlciBmcm9tIGEgUHJvbWlzZS9BKyBjb25zdHJ1Y3RvciB0byBiZSB1c2VkIHdpdGhcbiAgICogYGNvbmZpZy5wcm9taXNlUHJvdmlkZXJgLlxuICAgKlxuICAgKiAgICAgbmV3IFByb21pc2VXaW5kb3coLi4uLCB7XG4gICAqICAgICAgIC4uLixcbiAgICogICAgICAgcHJvbWlzZVByb3ZpZGVyOiBQcm9taXNlV2luZG93LmdldEFQbHVzUHJvbWlzZVByb3ZpZGVyKE15Q3VzdG9tUHJvbWlzZSlcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gQ3VzdG9tUHJvbWlzZSBQcm9taXNlL0ErIGNvbnRydWN0b3JcbiAgICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgYSBwcm9taXNlIHByb3ZpZGVyXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIFByb21pc2VXaW5kb3cuZ2V0QVBsdXNQcm9taXNlUHJvdmlkZXIgPSBmdW5jdGlvbiBnZXRBUGx1c1Byb21pc2VQcm92aWRlcihDdXN0b21Qcm9taXNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHByb21pc2VQcm92aWRlcigpIHtcbiAgICAgIHZhciBtb2R1bGUgPSB7fTtcbiAgICAgIG1vZHVsZS5wcm9taXNlID0gbmV3IEN1c3RvbVByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG1vZHVsZS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgbW9kdWxlLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yOlxuICAgKlxuICAgKiAgICAgbmV3IFByb21pc2VXaW5kb3codXJpLCBjb25maWcpLm9wZW4oKVxuICAgKlxuICAgKiBVc2UgdGhpcyBtZXRob2Qgb25seSBpZiB5b3UgbmV2ZXIgbmVlZCB0byBjbG9zZSB0aGUgd2luZG93IHByb2dyYW1hdGljYWxseS5cbiAgICogSWYgeW91IGRvLCBwbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIGNsYXNzaWMgd2F5OlxuICAgKlxuICAgKiAgICAgdmFyIHcgPSBuZXcgUHJvbWlzZVdpbmRvdyh1cmksIGNvbmZpZylcbiAgICogICAgIHcub3BlbigpO1xuICAgKiAgICAgLy8gLi4uXG4gICAqICAgICB3LmNsb3NlKCk7XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgYSBQcm9taXNlIGVxdWl2YWxlbnQgdG8gdGhlIG9uZSByZXR1cm5lZCBieSBgb3BlbigpYFxuICAgKiBAc3RhdGljXG4gICAqL1xuICBQcm9taXNlV2luZG93Lm9wZW4gPSBmdW5jdGlvbiBvcGVuKHVyaSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlV2luZG93KHVyaSwgY29uZmlnKS5vcGVuKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgY29uZmlndXJhdGlvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgUHJvbWlzZVdpbmRvdy5kZWZhdWx0Q29uZmlnID0ge1xuICAgIHdpZHRoOiBodG1sLmNsaWVudFdpZHRoLFxuICAgIGhlaWdodDogaHRtbC5jbGllbnRIZWlnaHQsXG4gICAgd2luZG93OiB7XG4gICAgICBzY3JvbGxiYXJzOiB0cnVlXG4gICAgfSxcbiAgICB3YXRjaGVyRGVsYXk6IDEwMCxcbiAgICBwcm9taXNlUHJvdmlkZXI6IG51bGwsXG4gICAgb25Qb3N0TWVzc2FnZTogZnVuY3Rpb24gb25Qb3N0TWVzc2FnZShldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRhdGEuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KGV2ZW50LmRhdGEuZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZShldmVudC5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9LFxuICAgIHdpbmRvd05hbWU6IG51bGwsXG4gICAgb25DbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl93aW5kb3cuY2xvc2UoKTtcbiAgICB9LFxuICAgIG9yaWdpblJlZ2V4cDogbmV3IFJlZ0V4cCgnXlteOi8/XSs6Ly9bXi9dKicpXG4gIH07XG5cbiAgLy8gQ29uZmlndXJlIGRlZmF1bHQgUHJvbWlzZSBwcm92aWRlciBmcm9tIGN1cnJlbnQgaW52aXJvbm1lbnRcbiAgaWYgKHJvb3QuUHJvbWlzZSkge1xuICAgIFByb21pc2VXaW5kb3cuZGVmYXVsdENvbmZpZy5wcm9taXNlUHJvdmlkZXIgPSBQcm9taXNlV2luZG93LmdldEFQbHVzUHJvbWlzZVByb3ZpZGVyKHJvb3QuUHJvbWlzZSk7XG4gIH1cbiAgZWxzZSBpZiAocm9vdC5SU1ZQKSB7XG4gICAgUHJvbWlzZVdpbmRvdy5kZWZhdWx0Q29uZmlnLnByb21pc2VQcm92aWRlciA9IFByb21pc2VXaW5kb3cuZ2V0QVBsdXNQcm9taXNlUHJvdmlkZXIocm9vdC5SU1ZQLlByb21pc2UpO1xuICB9XG4gIGVsc2UgaWYgKHJvb3QuUSkge1xuICAgIFByb21pc2VXaW5kb3cuZGVmYXVsdENvbmZpZy5wcm9taXNlUHJvdmlkZXIgPSBQcm9taXNlV2luZG93LmdldEFQbHVzUHJvbWlzZVByb3ZpZGVyKHJvb3QuUS5Qcm9taXNlKTtcbiAgfVxuICBlbHNlIGlmIChyb290LmpRdWVyeSkge1xuICAgIFByb21pc2VXaW5kb3cuZGVmYXVsdENvbmZpZy5wcm9taXNlUHJvdmlkZXIgPSBmdW5jdGlvbiBwcm9taXNlUHJvdmlkZXIoKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSByb290LmpRdWVyeS5EZWZlcnJlZCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogZGVmZXJyZWQucHJvbWlzZSgpLFxuICAgICAgICByZXNvbHZlOiBkZWZlcnJlZC5yZXNvbHZlLFxuICAgICAgICByZWplY3Q6IGRlZmVycmVkLnJlamVjdFxuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIFByb21pc2VXaW5kb3cuZGVmYXVsdENvbmZpZy5wcm9taXNlUHJvdmlkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcm9taXNlUHJvdmlkZXIgaW4gUHJvbWlzZVdpbmRvdyBjb25maWd1cmF0aW9uJyk7XG4gICAgfTtcbiAgfVxuXG4gIHByb3RvdHlwZSA9IFByb21pc2VXaW5kb3cucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIGEgYm9vbGVhblxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdmFsdWUgaXMgYSBib29sZWFuLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX2lzQm9vbGVhbiA9IGZ1bmN0aW9uIF9pc0Jvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGNvbmZpZyB2YWx1ZSBpbnRvIGEgdmFsdWUgY29tcGF0aWJsZSB3aXRoIGB3aW5kb3cub3BlbmAuXG4gICAqIElmIHZhbHVlIGlzIGEgYm9vbGVhbiwgY29udmVydCBpdCB0byAneWVzJyBvciAnbm8nLCBvdGhlcndpc2Ugc2ltcGx5XG4gICAqIGNhc3RzIGl0IGludG8gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29udmVydGVkIHZhbHVlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fc2VyaWFsaXplRmVhdHVyZVZhbHVlID0gZnVuY3Rpb24gX3NlcmlhbGl6ZUZlYXR1cmVWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/ICd5ZXMnIDogJ25vJztcbiAgICB9XG4gICAgcmV0dXJuICcnICsgdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGVmdCBhbmQgdG9wIHBvc2l0aW9uIGluIHRoZSBzY3JlZW4gZm9yIGEgcmVjdGFuZ2xlLCB0YWtpbmdcbiAgICogZHVhbC1zY3JlZW4gcG9zaXRpb24gaW50byBhY2NvdW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHJldHVybiB7T2JqZWN0fSBwb3NpdGlvbiBBIG5ldyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlLCBjZW50ZXJlZFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBvc2l0aW9uLmxlZnQgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyZWQgcmVjdGFuZ2xlXG4gICAqIEByZXR1cm4ge051bWJlcn0gcG9zaXRpb24udG9wIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlcmVkIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBvc2l0aW9uLndpZHRoIFRoZSB3aWR0aCBvZiB0aGUgY2VudGVyZWQgcmVjdGFuZ2xlXG4gICAqIEByZXR1cm4ge051bWJlcn0gcG9zaXRpb24uaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGNlbnRlcmVkIHJlY3RhbmdsZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX2dldENlbnRlcmVkUG9zaXRpb24gPSBmdW5jdGlvbiBfZ2V0Q2VudGVyZWRQb3NpdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGR1YWxTY3JlZW5MZWZ0ID0gcm9vdC5zY3JlZW5MZWZ0ICE9PSB1bmRlZmluZWQgPyByb290LnNjcmVlbkxlZnQgOiBzY3JlZW4ubGVmdCxcbiAgICAgICAgZHVhbFNjcmVlblRvcCA9IHJvb3Quc2NyZWVuVG9wICE9PSB1bmRlZmluZWQgPyByb290LnNjcmVlblRvcCA6IHNjcmVlbi50b3AsXG4gICAgICAgIHcgPSByb290LmlubmVyV2lkdGggfHwgaHRtbC5jbGllbnRXaWR0aCB8fCBzY3JlZW4ud2lkdGgsXG4gICAgICAgIGggPSByb290LmlubmVySGVpZ2h0IHx8IGh0bWwuY2xpZW50SGVpZ2h0IHx8IHNjcmVlbi5oZWlnaHQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogKHcgLyAyKSAtICh3aWR0aCAvIDIpICsgZHVhbFNjcmVlbkxlZnQsXG4gICAgICB0b3A6ICAoaCAvIDIpIC0gKGhlaWdodCAvIDIpICsgZHVhbFNjcmVlblRvcCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHdpbmRvdyBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyB3aW5kb3cgZmVhdHVyZXMgY29tcGF0aWJsZSB3aXRoIGB3aW5kb3cub3BlbmBcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9nZXRGZWF0dXJlcyA9IGZ1bmN0aW9uIF9nZXRGZWF0dXJlcygpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5fZ2V0Q2VudGVyZWRQb3NpdGlvbih0aGlzLmNvbmZpZy53aWR0aCwgdGhpcy5jb25maWcuaGVpZ2h0KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jb25maWcud2luZG93KSB7XG4gICAgICBpZiAodGhpcy5jb25maWcud2luZG93Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLmNvbmZpZy53aW5kb3dba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uZmlnKVxuICAgICAgLm1hcChmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGtleSArICc9JyArIHRoaXMuX3NlcmlhbGl6ZUZlYXR1cmVWYWx1ZShrZXksIGNvbmZpZ1trZXldKTsgfS5iaW5kKHRoaXMpKVxuICAgICAgLmpvaW4oJywnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQcm9taXNlLCB1c2luZyBgY29uZmlnLnByb21pc2VQcm92aWRlcmAsIGFuZCBzYXZlIHJlamVjdCBhbmRcbiAgICogcmVzb2x2ZSBtZXRob2RzIGZvciBsYXRlci5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyB0aGUgbmV3IFByb21pc2Ugb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGNvbmZpZ3VyZWRcbiAgICogICAgICAgICAgICAgICAgICAgUHJvbWlzZSBQcm92aWRlci5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9jcmVhdGVQcm9taXNlID0gZnVuY3Rpb24gX2NyZWF0ZVByb21pc2UoKSB7XG4gICAgdmFyIG1vZHVsZSA9IHRoaXMuY29uZmlnLnByb21pc2VQcm92aWRlcigpO1xuICAgIHRoaXMuX3Jlc29sdmUgPSBtb2R1bGUucmVzb2x2ZTtcbiAgICB0aGlzLl9yZWplY3QgPSBtb2R1bGUucmVqZWN0O1xuICAgIHJldHVybiBtb2R1bGUucHJvbWlzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHdpbmRvdyBpcyBhbGl2ZSBvciBub3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHdpbmRvdyBpcyBhbGl2ZSwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9pc1dpbmRvd0FsaXZlID0gZnVuY3Rpb24gX2lzV2luZG93QWxpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvdyAmJiAhdGhpcy5fd2luZG93LmNsb3NlZDtcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBwb3B1cCB3aW5kb3cgd2F0Y2hlci5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9zdGFydFdhdGNoZXIgPSBmdW5jdGlvbiBfc3RhcnRXYXRjaGVyKCkge1xuICAgIGlmICh0aGlzLl93YXRjaGVyUnVubmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYXRjaGVyIGlzIGFscmVhZHkgc3RhcnRlZCcpO1xuICAgIH1cbiAgICB0aGlzLl93YXRjaGVyID0gcm9vdC5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fd2F0Y2hlclJ1bm5pbmcgJiYgIXRoaXMuX2lzV2luZG93QWxpdmUoKSkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy53YXRjaGVyRGVsYXkpO1xuICAgIHRoaXMuX3dhdGNoZXJSdW5uaW5nID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcHMgdGhlIHBvcHVwIHdpbmRvdyB3YXRjaGVyLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX3N0b3BXYXRjaGVyID0gZnVuY3Rpb24gX3N0b3BXYXRjaGVyKCkge1xuICAgIGlmICghdGhpcy5fd2F0Y2hlclJ1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2F0Y2hlciBpcyBhbHJlYWR5IHN0b3BwZWQnKTtcbiAgICB9XG4gICAgdGhpcy5fd2F0Y2hlclJ1bm5pbmcgPSBmYWxzZTtcbiAgICByb290LmNsZWFySW50ZXJ2YWwodGhpcy5fd2F0Y2hlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBwb3N0IG1lc3NhZ2UgZXZlbnRzLiBJZiBhbmQgb25seSBvZiB0aGUgZXZlbnQgaGFzIGJlZW5cbiAgICogZ2VuZXJhdGVkIGZyb20gdGhlIG9wZW5lZCBwb3B1cCB3aW5kb3csIGl0IHByb3BhZ2F0ZXMgaXQgdG8gdGhlIGNvbmZpZ3VyZWRcbiAgICogcG9zdCBtZXNzYWdlIGhhbmRsZXIgKGBjb25maWcub25Qb3N0TWVzc2FnZWApLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgcG9zdE1lc3NhZ2UgZXZlbnRcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9vblBvc3RNZXNzYWdlID0gZnVuY3Rpb24gX29uUG9zdE1lc3NhZ2UoZXZlbnQpIHtcbiAgICB2YXIgZXhwZWN0ZWRPcmlnaW5NYXRjaGVzID0gdGhpcy5jb25maWcub3JpZ2luUmVnZXhwLmV4ZWModGhpcy51cmkpO1xuICAgIHZhciBleHBlY3RlZE9yaWdpbiA9IGV4cGVjdGVkT3JpZ2luTWF0Y2hlcyAmJiBleHBlY3RlZE9yaWdpbk1hdGNoZXNbMF0gfHwgbG9jYXRpb24ub3JpZ2luO1xuICAgIGlmICh0aGlzLl93aW5kb3cgPT09IGV2ZW50LnNvdXJjZSAmJiBldmVudC5vcmlnaW4gPT09IGV4cGVjdGVkT3JpZ2luKSB7XG4gICAgICB0aGlzLmNvbmZpZy5vblBvc3RNZXNzYWdlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgVVJJXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgVGhlIG5ldyBVUklcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB3aW5kb3cgaXMgb3BlblxuICAgKiBAcmV0dXJuIHtQcm9taXNlV2luZG93fSBSZXR1cm5zIHRoaXMgb2JqZWN0IHRvIGFsbG93IGNoYWluaW5nXG4gICAqL1xuICBwcm90b3R5cGUuc2V0VVJJID0gZnVuY3Rpb24gc2V0VVJJKHVyaSkge1xuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjaGFuZ2UgdGhlIFVSSSB3aGlsZSB0aGUgd2luZG93IGlzIG9wZW4nKTtcbiAgICB9XG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9wZW5zIGEgbmV3IHBvcHVwIHdpbmRvdy5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIG5ldyBgUHJvbWlzZWAgb2JqZWN0LiBUaGlzIHByb21pc2Ugd2lsbCBiZTpcbiAgICogICAgICAgICAgICAgICAgICAgLSByZWplY3RlZCB3aXRoIGBcImJsb2NrZWRcImAgbWVzc2FnZSBpZiB0aGUgcG9wdXAgd2luZG93XG4gICAqICAgICAgICAgICAgICAgICAgICAgZG9lcyBub3Qgb3BlbiBmb3IgYW55IHJlYXNvbiAocG9wdXAgYmxvY2tlciwgZXRjLi4uKVxuICAgKiAgICAgICAgICAgICAgICAgICAtIHJlamVjdGVkIHdpdGggYFwiY2xvc2VkXCJgIGlmIGNsb3NlZCBlaXRoZXIgbWFudWFsbHkgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICB0aGUgdXNlciwgb3IgcHJvZ3JhbWF0aWNhbGx5XG4gICAqICAgICAgICAgICAgICAgICAgIC0gcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgaWYgdGhlIHdlYiBwYWdlIG9wZW5lZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBwb3B1cCBzZW5kcyBhIHBvc3QgbWVzc2FnZSB3aXRoIGEgYGVycm9yYCBkYXRhIGZpZWxkLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHJlc29sdmVkIHdpdGggdGhlIGdpdmVuIGRhdGEgaWYgdGhlIHdlYiBwYWdlIG9wZW5lZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBwb3B1cCBzZW5kcyBhIHBvc3QgbWVzc2FnZSB3aXRob3V0IGEgYGVycm9yYCBkYXRhXG4gICAqICAgICAgICAgICAgICAgICAgICAgZmllbGQuXG4gICAqL1xuICBwcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2luZG93IGlzIGFscmVhZHkgb3BlbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3dpbmRvd09wZW4gPSB0cnVlO1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fY3JlYXRlUHJvbWlzZSgpO1xuICAgIHRoaXMuX3dpbmRvdyA9IHJvb3Qub3BlbihcbiAgICAgIHRoaXMudXJpLFxuICAgICAgdGhpcy5jb25maWcud2luZG93TmFtZSxcbiAgICAgIHRoaXMuX2dldEZlYXR1cmVzKClcbiAgICApO1xuICAgIGlmICghdGhpcy5fd2luZG93KSB7XG4gICAgICB0aGlzLl9yZWplY3QoXCJibG9ja2VkXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Qb3N0TWVzc2FnZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9zdGFydFdhdGNoZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgcG9wdXAgd2luZG93LlxuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgcHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpbmRvdyBpcyBhbHJlYWR5IGNsb3NlZCcpO1xuICAgIH1cbiAgICB0aGlzLl9zdG9wV2F0Y2hlcigpO1xuICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Qb3N0TWVzc2FnZSk7XG4gICAgaWYgKHRoaXMuX2lzV2luZG93QWxpdmUoKSkge1xuICAgICAgdGhpcy5jb25maWcub25DbG9zZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9yZWplY3QoXCJjbG9zZWRcIik7XG4gICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgICB0aGlzLl93aW5kb3dPcGVuID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB3aW5kb3cgaXMgb3BlbiBvciBub3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHdpbmRvdyBpcyBvcGVuZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgcHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd2luZG93T3BlbjtcbiAgfTtcblxuICAvLyBFeHBvcnRzIFByb21pc2VXaW5kb3cgdG8gdGhlIGdsb2JhbCBzY29wZVxuICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3Byb21pc2Utd2luZG93JywgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gUHJvbWlzZVdpbmRvdyB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFByb21pc2VXaW5kb3c7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5Qcm9taXNlV2luZG93ID0gUHJvbWlzZVdpbmRvdztcbiAgfVxuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG59KSgpO1xuIiwiaWYgKHByb2Nlc3MuZW52Lm5wbV9wYWNrYWdlX25hbWUgPT09ICdwc2V1ZG9tYXAnICYmXG4gICAgcHJvY2Vzcy5lbnYubnBtX2xpZmVjeWNsZV9zY3JpcHQgPT09ICd0ZXN0JylcbiAgcHJvY2Vzcy5lbnYuVEVTVF9QU0VVRE9NQVAgPSAndHJ1ZSdcblxuaWYgKHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgIXByb2Nlc3MuZW52LlRFU1RfUFNFVURPTUFQKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gTWFwXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcHNldWRvbWFwJylcbn1cbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxubW9kdWxlLmV4cG9ydHMgPSBQc2V1ZG9NYXBcblxuZnVuY3Rpb24gUHNldWRvTWFwIChzZXQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBzZXVkb01hcCkpIC8vIHdoeXl5eXl5eVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJ1Y3RvciBQc2V1ZG9NYXAgcmVxdWlyZXMgJ25ldydcIilcblxuICB0aGlzLmNsZWFyKClcblxuICBpZiAoc2V0KSB7XG4gICAgaWYgKChzZXQgaW5zdGFuY2VvZiBQc2V1ZG9NYXApIHx8XG4gICAgICAgICh0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIHNldCBpbnN0YW5jZW9mIE1hcCkpXG4gICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKVxuICAgICAgfSwgdGhpcylcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNldCkpXG4gICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAoa3YpIHtcbiAgICAgICAgdGhpcy5zZXQoa3ZbMF0sIGt2WzFdKVxuICAgICAgfSwgdGhpcylcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50JylcbiAgfVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBPYmplY3Qua2V5cyh0aGlzLl9kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgIT09ICdzaXplJylcbiAgICAgIGZuLmNhbGwodGhpc3AsIHRoaXMuX2RhdGFba10udmFsdWUsIHRoaXMuX2RhdGFba10ua2V5KVxuICB9LCB0aGlzKVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrKSB7XG4gIHJldHVybiAhIWZpbmQodGhpcy5fZGF0YSwgaylcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaykge1xuICB2YXIgcmVzID0gZmluZCh0aGlzLl9kYXRhLCBrKVxuICByZXR1cm4gcmVzICYmIHJlcy52YWx1ZVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrLCB2KSB7XG4gIHNldCh0aGlzLl9kYXRhLCBrLCB2KVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrKSB7XG4gIHZhciByZXMgPSBmaW5kKHRoaXMuX2RhdGEsIGspXG4gIGlmIChyZXMpIHtcbiAgICBkZWxldGUgdGhpcy5fZGF0YVtyZXMuX2luZGV4XVxuICAgIHRoaXMuX2RhdGEuc2l6ZS0tXG4gIH1cbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIGRhdGEuc2l6ZSA9IDBcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19kYXRhJywge1xuICAgIHZhbHVlOiBkYXRhLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBzZXVkb01hcC5wcm90b3R5cGUsICdzaXplJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zaXplXG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKG4pIHt9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pXG5cblBzZXVkb01hcC5wcm90b3R5cGUudmFsdWVzID1cblBzZXVkb01hcC5wcm90b3R5cGUua2V5cyA9XG5Qc2V1ZG9NYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3JzIGFyZSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyB2ZXJzaW9uJylcbn1cblxuLy8gRWl0aGVyIGlkZW50aWNhbCwgb3IgYm90aCBOYU5cbmZ1bmN0aW9uIHNhbWUgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSAhPT0gYSAmJiBiICE9PSBiXG59XG5cbmZ1bmN0aW9uIEVudHJ5IChrLCB2LCBpKSB7XG4gIHRoaXMua2V5ID0ga1xuICB0aGlzLnZhbHVlID0gdlxuICB0aGlzLl9pbmRleCA9IGlcbn1cblxuZnVuY3Rpb24gZmluZCAoZGF0YSwgaykge1xuICBmb3IgKHZhciBpID0gMCwgcyA9ICdfJyArIGssIGtleSA9IHM7XG4gICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgICAgIGtleSA9IHMgKyBpKyspIHtcbiAgICBpZiAoc2FtZShkYXRhW2tleV0ua2V5LCBrKSlcbiAgICAgIHJldHVybiBkYXRhW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQgKGRhdGEsIGssIHYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIHMgPSAnXycgKyBrLCBrZXkgPSBzO1xuICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICAgICBrZXkgPSBzICsgaSsrKSB7XG4gICAgaWYgKHNhbWUoZGF0YVtrZXldLmtleSwgaykpIHtcbiAgICAgIGRhdGFba2V5XS52YWx1ZSA9IHZcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBkYXRhLnNpemUrK1xuICBkYXRhW2tleV0gPSBuZXcgRW50cnkoaywgdiwga2V5KVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMgfHwgKHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiICYmIHNlbGYpO1xuICB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbCwgcmV0KSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLCByZWosIGNiKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcHVzaCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0IChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZilcbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWRcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIE5vZGUgKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdClcbiAgfVxuXG4gIHRoaXMubGlzdCA9IGxpc3RcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzXG4gICAgdGhpcy5wcmV2ID0gcHJldlxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGxcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpc1xuICAgIHRoaXMubmV4dCA9IG5leHRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cbn1cbiIsImltcG9ydCBEaXNjb3Vyc2VBdXRoIGZyb20gJy4vZGlzY291cnNlQXV0aCc7XG5pbXBvcnQgRGlzY291cnNlQXBpIGZyb20gJy4vZGlzY291cnNlQXBpJztcbmltcG9ydCBQcm9taXNlV2luZG93IGZyb20gJ3Byb21pc2Utd2luZG93JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlzY291cnNlQ2xpZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuX3JlcXVpcmVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuX2Zvcm1hdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5hdXRoID0gbmV3IERpc2NvdXJzZUF1dGgodGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLmFwaSA9IG5ldyBEaXNjb3Vyc2VBcGkodGhpcy5vcHRpb25zLmFwaUJhc2VVcmwpO1xuICB9XG5cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBhd2FpdCB0aGlzLmF1dGguaW5pdCgpO1xuICB9XG5cbiAgX3JlcXVpcmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHx8XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAodHlwZW9mIG9wdGlvbnMuYXBwTmFtZSA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5hcHBOYW1lLmxlbmd0aCA+IDApIHx8XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuYXBwTmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICh0eXBlb2Ygb3B0aW9ucy5hcGlCYXNlVXJsID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmFwaUJhc2VVcmwubGVuZ3RoID4gMCkgfHxcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucy5hcGlCYXNlVXJsIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgKG9wdGlvbnMuc2NvcGVzIGluc3RhbmNlb2YgQXJyYXkgJiYgb3B0aW9ucy5zY29wZXMubGVuZ3RoID4gMCkgfHxcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucy5zY29wZXMgbXVzdCBiZSBhIG5vbi1lbXB0eSBhcnJheScpO1xuICB9XG5cbiAgX2Zvcm1hdE9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGZvcm1hdHRlZE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcblxuICAgIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICAgIGZvcm1hdHRlZE9wdGlvbnMuYXBpQmFzZVVybCA9IG9wdGlvbnMuYXBpQmFzZVVybC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgIGZvcm1hdHRlZE9wdGlvbnMuc2NvcGVzID0gb3B0aW9ucy5zY29wZXMuam9pbignLCcpO1xuICAgIHJldHVybiBmb3JtYXR0ZWRPcHRpb25zO1xuICB9XG5cbiAgZ2V0QXBpQmFzZVVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFwaUJhc2VVcmw7XG4gIH1cblxuICBhc3luYyBpc0xvZ2dlZEluKCkge1xuICAgIGlmICghdGhpcy5hdXRoLl9oYXNVc2VyQXBpS2V5KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fcmVmcmVzaEN1cnJlbnRVc2VyKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VyKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjdXJyZW50VXNlcicpKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VyTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VXNlcigpWyd1c2VybmFtZSddO1xuICB9XG5cbiAgZ2V0Q3VycmVudFVzZXJEaXNwbGF5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VXNlcigpWyduYW1lJ107XG4gIH1cblxuICBpc0N1cnJlbnRVc2VyU2lsZW5jZWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmdldEN1cnJlbnRVc2VyKClbJ2Nhbl9jcmVhdGVfdG9waWMnXTtcbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VyQXZhdGFyVXJsKHNpemUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdGhpcy5vcHRpb25zLmFwaUJhc2VVcmwsXG4gICAgICB0aGlzLmdldEN1cnJlbnRVc2VyKClbJ2F2YXRhcl90ZW1wbGF0ZSddLnJlcGxhY2UoJ3tzaXplfScsIChzaXplIHx8IDExMCkpXG4gICAgXS5qb2luKCcvJyk7XG4gIH1cblxuICBnZXRDdXJyZW50VXNlck5vdGlmaWNhdGlvbnNVcmwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMub3B0aW9ucy5hcGlCYXNlVXJsLFxuICAgICAgJ3UnLFxuICAgICAgdGhpcy5nZXRDdXJyZW50VXNlck5hbWUoKSxcbiAgICAgICdub3RpZmljYXRpb25zJ1xuICAgIF0uam9pbignLycpO1xuICB9XG5cbiAgYXN5bmMgX3JlZnJlc2hDdXJyZW50VXNlcigpIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2N1cnJlbnRVc2VyJywgSlNPTi5zdHJpbmdpZnkoYXdhaXQgdGhpcy5hcGkuZ2V0Q3VycmVudFNlc3Npb25Vc2VyKCkpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgdGhpcy5sb2dvdXQoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGxvZ2dlZCBpbi4nKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBsb2dpbigpIHtcbiAgICBpZiAoYXdhaXQgdGhpcy5pc0xvZ2dlZEluKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlV2luZG93Lm9wZW4oYXdhaXQgdGhpcy5hdXRoLl9nZXRMb2dpblVybCgpLCB7XG4gICAgICB3aWR0aDogNzAwLFxuICAgICAgaGVpZ2h0OiA2NTAsXG4gICAgICBvcmlnaW5SZWdleHA6IG5ldyBSZWdFeHAoJ14nICsgbG9jYXRpb24ub3JpZ2luKVxuICAgIH0pLnRoZW4oYXN5bmMgZGF0YSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmFwaS5fc2V0VXNlckFwaUtleShkYXRhLnJlc3VsdC5rZXkpO1xuICAgICAgYXdhaXQgdGhpcy5fcmVmcmVzaEN1cnJlbnRVc2VyKCk7XG4gICAgfSxcblxuICAgIC8vIEVycm9yXG4gICAgKGVycm9yKSA9PiB7XG4gICAgICBzd2l0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Rpc2NvdXJzZUxvZ2luQ2FuY2VsZWQnKSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiBwb3B1cCB3aW5kb3cgY2xvc2VkIGJ5IHRoZSB1c2VyJyk7XG4gICAgICAgIGNhc2UgJ2Jsb2NrZWQnOlxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdkaXNjb3Vyc2VMb2dpbkJsb2NrZWQnKSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiBwb3B1cCB3aW5kb3cgYmxvY2tlZCBieSB0aGUgYnJvd3NlcicpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gcG9wdXAgd2luZG93IHJldHVybmVkIGFuIGVycm9yOiAnLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSkudGhlbigoKSA9PiBkaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZGlzY291cnNlTG9nZ2VkSW4nKSkpO1xuICB9XG5cbiAgYXN5bmMgbG9nb3V0KCkge1xuICAgIGF3YWl0IHRoaXMuYXBpLmxvZ291dCh0aGlzLmdldEN1cnJlbnRVc2VyTmFtZSgpKTtcbiAgICB0aGlzLmF1dGguX2NsZWFyQXV0aERhdGEoKTtcbiAgICBkaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZGlzY291cnNlTG9nZ2VkT3V0JykpO1xuICB9XG59XG4iLCJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgY2FjaGVBZGFwdGVyRW5oYW5jZXIsIHRocm90dGxlQWRhcHRlckVuaGFuY2VyIH0gZnJvbSAnYXhpb3MtZXh0ZW5zaW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpc2NvdXJzZUFwaSB7XG4gIGNvbnN0cnVjdG9yKGFwaUJhc2VVcmwpIHtcbiAgICB0aGlzLmFwaUJhc2VVcmwgPSBhcGlCYXNlVXJsO1xuICAgIHRoaXMuYXBpID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgIGJhc2VVUkw6IHRoaXMuYXBpQmFzZVVybCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBhZGFwdGVyOiB0aHJvdHRsZUFkYXB0ZXJFbmhhbmNlcihcbiAgICAgICAgY2FjaGVBZGFwdGVyRW5oYW5jZXIoYXhpb3MuZGVmYXVsdHMuYWRhcHRlciksXG4gICAgICAgIHsgdGhyZXNob2xkOiA1MDAgfSAvLyAxMjAgcmVxcy9taW5cbiAgICAgIClcbiAgICB9KTtcblxuICAgIHRoaXMuX3NldFVzZXJBcGlLZXkobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfYXBpX2tleScpKTtcbiAgfVxuXG4gIGFzeW5jIF9nZXRDYWxsUmVzdWx0KGVuZHBvaW50LCBwcm9wLCBub2NhY2hlID0gZmFsc2UpIHtcbiAgICBsZXQgcmVzcG9uc2U7XG5cbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSAoYXdhaXQgdGhpcy5hcGkuZ2V0KGVuZHBvaW50LCB7IGZvcmNlVXBkYXRlOiBub2NhY2hlIH0pKS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChwcm9wKSB7XG4gICAgICByZXNwb25zZSA9IHByb3Auc3BsaXQoJy4nKS5yZWR1Y2UoKHJldHVybmVkUmVzcG9uc2UsIGN1cnJlbnRQcm9wKSA9PlxuICAgICAgICByZXR1cm5lZFJlc3BvbnNlW2N1cnJlbnRQcm9wXSwgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIGFzeW5jIF9wb3N0Q2FsbFJlc3VsdChlbmRwb2ludCwgcGF5bG9hZCkge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5hcGkucG9zdChlbmRwb2ludCwgcGF5bG9hZCkpLmRhdGE7XG4gIH1cblxuICBhc3luYyBfc2V0VXNlckFwaUtleSh1c2VyQXBpS2V5KSB7XG4gICAgaWYgKCF1c2VyQXBpS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXBpLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydVc2VyLUFwaS1LZXknXSA9IHVzZXJBcGlLZXk7XG4gICAgYXdhaXQgdGhpcy5fc2V0Q3NyZlRva2VuKCk7XG4gIH1cblxuICBhc3luYyBfc2V0Q3NyZlRva2VuKCkge1xuICAgIHRoaXMuYXBpLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydYLUNTUkYtVG9rZW4nXSA9IGF3YWl0IHRoaXMuX2dldENhbGxSZXN1bHQoJy9zZXNzaW9uL2NzcmYuanNvbicsICdjc3JmJyk7XG4gIH1cblxuICBfZW5mb3JjZVVzZXJBcGlLZXkoKSB7XG4gICAgdGhpcy5hcGkuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1VzZXItQXBpLUtleSddIHx8IHRocm93IG5ldyBFcnJvcignVXNlciBBUEkga2V5IG5vdCBzZXQnKTtcbiAgfVxuXG4gIGFzeW5jIGdldEN1cnJlbnRTZXNzaW9uVXNlcigpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0Q2FsbFJlc3VsdCgnL3Nlc3Npb24vY3VycmVudC5qc29uJywgJ2N1cnJlbnRfdXNlcicsIHRydWUpO1xuICB9XG5cbiAgYXN5bmMgZ2V0TGF0ZXN0UG9zdHMoZGVzY2VuZGluZykge1xuICAgIGxldCBwb3N0cztcblxuICAgIHRyeSB7XG4gICAgICBwb3N0cyA9IGF3YWl0IHRoaXMuX2dldENhbGxSZXN1bHQoJy9wb3N0cy5qc29uJywgJ2xhdGVzdF9wb3N0cycpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICBwb3N0cyA9IHBvc3RzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zdHMuZmlsdGVyKHBvc3QgPT4gcG9zdC5wb3N0X3R5cGUgPT09IDEpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UG9zdHNJblRvcGljKHRvcGljSWQsIGRlc2NlbmRpbmcsIG5vY2FjaGUpIHtcbiAgICBsZXQgcG9zdHMgPSBhd2FpdCB0aGlzLl9nZXRDYWxsUmVzdWx0KCcvdC8nICsgdG9waWNJZCArICcvcG9zdHMuanNvbj9pbmNsdWRlX3Jhdz10cnVlJyxcbiAgICAgICdwb3N0X3N0cmVhbS5wb3N0cycsIG5vY2FjaGUpO1xuXG4gICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgIHBvc3RzID0gcG9zdHMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3N0cy5maWx0ZXIocG9zdCA9PiBwb3N0LnBvc3RfdHlwZSA9PT0gMSk7XG4gIH1cblxuICBhc3luYyBnZXRUb3BpYyh0b3BpY0lkLCBkZXNjZW5kaW5nKSB7XG4gICAgbGV0IHRvcGljID0gYXdhaXQgdGhpcy5fZ2V0Q2FsbFJlc3VsdCgnL3QvJyArIHRvcGljSWQgKyAnLmpzb24/aW5jbHVkZV9yYXc9dHJ1ZScpO1xuXG4gICAgdG9waWMucG9zdF9zdHJlYW0ucG9zdHMgPSB0b3BpYy5wb3N0X3N0cmVhbS5wb3N0cy5maWx0ZXIocG9zdCA9PiBwb3N0LnBvc3RfdHlwZSA9PT0gMSk7XG5cbiAgICBpZiAoZGVzY2VuZGluZykge1xuICAgICAgdG9waWMucG9zdF9zdHJlYW0ucG9zdHMgPSB0b3BpYy5wb3N0X3N0cmVhbS5wb3N0cy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvcGljO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHVibGljVXNlckZpZWxkcyh1c2VybmFtZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRDYWxsUmVzdWx0KCcvdS8nICsgdXNlcm5hbWUgKyAnLmpzb24/c3RhdHM9ZmFsc2UnLCAndXNlci51c2VyX2ZpZWxkcycpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHVibGljVXNlckZpZWxkKHVzZXJuYW1lLCBmaWVsZCkge1xuICAgIGNvbnN0IHVzZXJGaWVsZHMgPSBhd2FpdCB0aGlzLmdldFB1YmxpY1VzZXJGaWVsZHModXNlcm5hbWUpO1xuXG4gICAgcmV0dXJuIHVzZXJGaWVsZHMgJiYgdXNlckZpZWxkc1tmaWVsZF07XG4gIH1cblxuICBhc3luYyBwb3N0TWVzc2FnZSh0b3BpY0lkLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5fZW5mb3JjZVVzZXJBcGlLZXkoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcG9zdENhbGxSZXN1bHQoJy9wb3N0cy5qc29uJywge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICB0b3BpY19pZDogdG9waWNJZCxcbiAgICAgIHJhdzogbWVzc2FnZVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIHJlc3BvbnNlLmhpZGRlbiAmJiBQcm9taXNlLnJlamVjdChyZXNwb25zZS5oaWRkZW5fcmVhc29uX2lkKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiBQcm9taXNlLnJlamVjdChlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycykpO1xuICB9XG5cbiAgYXN5bmMgbG9nb3V0KHVzZXJuYW1lKSB7XG4gICAgdGhpcy5fZW5mb3JjZVVzZXJBcGlLZXkoKTtcbiAgICAvLyBhd2FpdCB0aGlzLmFwaS5kZWxldGUoJy9zZXNzaW9uLycgKyB1c2VybmFtZSk7IC8vIE5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgYXdhaXQgdGhpcy5hcGkucG9zdCgnL3VzZXItYXBpLWtleS9yZXZva2UnKTtcbiAgICBkZWxldGUgdGhpcy5hcGkuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1VzZXItQXBpLUtleSddO1xuICAgIGRlbGV0ZSB0aGlzLmFwaS5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnWC1DU1JGLVRva2VuJ107XG4gIH1cbn1cbiIsImltcG9ydCBLZXlNYW5hZ2VyIGZyb20gJy4va2V5TWFuYWdlcic7XG5pbXBvcnQgVVJMU2VhcmNoUGFyYW1zIGZyb20gJ0B1bmdhcC91cmwtc2VhcmNoLXBhcmFtcyc7IC8vIHBvbHlmaWxsXG4vLyBpbXBvcnQgTW9iaWxlRGV0ZWN0IGZyb20gJ21vYmlsZS1kZXRlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXNjb3Vyc2VBdXRoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuYXBwSWQgPSB0aGlzLl9zbHVnaWZ5KG9wdGlvbnMuYXBwTmFtZSk7XG4gICAgdGhpcy5rbSA9IG5ldyBLZXlNYW5hZ2VyKHRoaXMuYXBwSWQpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBhc3luYyBpbml0KCkge1xuICAgIGF3YWl0IHRoaXMua20uZ2V0S2V5cygpO1xuICAgIHRoaXMuX2hhc1VzZXJBcGlLZXkoKSB8fCB0aGlzLl9tYW5hZ2VQYXlsb2FkKCk7XG4gIH1cblxuICBfaGFzVXNlckFwaUtleSgpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfYXBpX2tleScpICE9PSBudWxsO1xuICB9XG5cbiAgYXN5bmMgX2dldExvZ2luVXJsKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgYXBwbGljYXRpb25fbmFtZTogdGhpcy5vcHRpb25zLmFwcE5hbWUsXG4gICAgICBwdWJsaWNfa2V5OiBhd2FpdCB0aGlzLmttLmdldFB1YmxpY0tleSgpLFxuICAgICAgbm9uY2U6IHRoaXMuX2dlbmVyYXRlU3RvcmVkUmFuZG9tKCdub25jZScpLFxuICAgICAgY2xpZW50X2lkOiB0aGlzLl9nZXRTdG9yZWRSYW5kb20oJ2NsaWVudElkJykgfHwgdGhpcy5fZ2VuZXJhdGVTdG9yZWRSYW5kb20oJ2NsaWVudElkJyksXG4gICAgICBhdXRoX3JlZGlyZWN0OiBsb2NhdGlvbi5ocmVmLFxuICAgICAgc2NvcGVzOiB0aGlzLm9wdGlvbnMuc2NvcGVzXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFwaUJhc2VVcmwgKyAnL3VzZXItYXBpLWtleS9uZXc/JyArIHRoaXMuX3NlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpO1xuICB9XG5cbiAgX3NlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1zKVxuICAgICAgLm1hcCgoaykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KGspICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trXSkpXG4gICAgICAuam9pbignJicpO1xuICB9O1xuXG4gIF9nZW5lcmF0ZVN0b3JlZFJhbmRvbShuYW1lKSB7XG4gICAgY29uc3Qgc3RvcmVkUmFuZG9tID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc3Vic3RyKDIpO1xuXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5hcHBJZCArICdfJyArIG5hbWUsIHN0b3JlZFJhbmRvbSk7XG4gICAgcmV0dXJuIHN0b3JlZFJhbmRvbTtcbiAgfVxuXG4gIF9nZXRTdG9yZWRSYW5kb20obmFtZSkge1xuICAgIGNvbnN0IHN0b3JlZFJhbmRvbSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuYXBwSWQgKyAnXycgKyBuYW1lKTtcblxuICAgIHJldHVybiBzdG9yZWRSYW5kb207XG4gIH1cblxuICBfcmVtb3ZlU3RvcmVkUmFuZG9tKG5hbWUpIHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmFwcElkICsgJ18nICsgbmFtZSk7XG4gIH1cblxuICBfZ2V0VXNlckFwaUtleSgpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfYXBpX2tleScpO1xuICB9XG5cbiAgX2NsZWFyQXV0aERhdGEoKSB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXJfYXBpX2tleScpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdjdXJyZW50VXNlcicpO1xuICAgIHRoaXMuX3JlbW92ZVN0b3JlZFJhbmRvbSgnY2xpZW50SWQnKTtcbiAgfVxuXG4gIF9tYW5hZ2VQYXlsb2FkKCkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCB8fCB3aW5kb3cubG9jYXRpb24uaGFzaC5zcGxpdCgnPycpWzFdKTtcblxuICAgIGlmICh1cmwuaGFzKCdwYXlsb2FkJykgJiYgb3BlbmVyKSB7XG4gICAgICB0aGlzLmttLmRlY3J5cHRQYXlsb2FkKHVybC5nZXQoJ3BheWxvYWQnKSkudGhlbihwYXlsb2FkT2JqZWN0ID0+IHtcbiAgICAgICAgcGF5bG9hZE9iamVjdC5ub25jZSA9PT0gdGhpcy5fZ2V0U3RvcmVkUmFuZG9tKCdub25jZScpIHx8XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmV0dXJuZWQgcGF5bG9hZCBpcyBpbnZhbGlkLicpO1xuICAgICAgICBwYXlsb2FkT2JqZWN0LmFwaSA9PT0gMyB8fFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgQVBJIHZlcnNpb246ICcgKyBwYXlsb2FkT2JqZWN0LmFwaSArICcuIERpc2NvdXJzZS1qcyB3b3JrcyB3aXRoIEFQSSB2ZXJzaW9uIDMuJyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyX2FwaV9rZXknLCBwYXlsb2FkT2JqZWN0LmtleSk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVN0b3JlZFJhbmRvbSgnbm9uY2UnKTtcbiAgICAgICAgb3BlbmVyLnBvc3RNZXNzYWdlKHsgcmVzdWx0OiBwYXlsb2FkT2JqZWN0IH0sIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdmFyIG1kID0gbmV3IE1vYmlsZURldGVjdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICBfc2x1Z2lmeSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnLScpXG4gICAgICAucmVwbGFjZSgvW15cXHdcXC1dKy9nLCAnJylcbiAgICAgIC5yZXBsYWNlKC9cXC1cXC0rL2csICctJylcbiAgICAgIC5yZXBsYWNlKC9eLSsvLCAnJylcbiAgICAgIC5yZXBsYWNlKC8tKyQvLCAnJyk7XG4gIH1cbn1cbiIsImxldCBmb3JnZSA9IHJlcXVpcmUoJy4vdmVuZG9yL2ZvcmdlLXBraScpO1xuXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4ge1xuICBjb25zdCBnZW5lcmF0ZSA9IChhcHBJZCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmb3JnZS5yc2EuZ2VuZXJhdGVLZXlQYWlyKHtcbiAgICAgICAgd29ya2VyU2NyaXB0OiAnL3ByaW1lLXdvcmtlci5taW4uanMnXG4gICAgICB9LFxuICAgICAgKGVycm9yLCBnZW5lcmF0ZWRLZXlwYWlyKSA9PiB7XG4gICAgICAgIGdlbmVyYXRlZEtleXBhaXIgPyAoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGtleXBhaXIgPSB7XG4gICAgICAgICAgICBwdWJsaWM6IGZvcmdlLnBraS5wdWJsaWNLZXlUb1BlbShnZW5lcmF0ZWRLZXlwYWlyLnB1YmxpY0tleSwgNzIpLnJlcGxhY2UoL1xcci9nLCAnJyksXG4gICAgICAgICAgICBwcml2YXRlOiBmb3JnZS5wa2kucHJpdmF0ZUtleVRvUGVtKGdlbmVyYXRlZEtleXBhaXIucHJpdmF0ZUtleSwgNzIpLnJlcGxhY2UoL1xcci9nLCAnJylcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYXBwSWQgKyAnX3B1YmxpY0tleScsIGtleXBhaXIucHVibGljKTtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhcHBJZCArICdfcHJpdmF0ZUtleScsIGtleXBhaXIucHJpdmF0ZSk7XG4gICAgICAgICAgcmVzb2x2ZShrZXlwYWlyKTtcbiAgICAgICAgfSkoKSA6IHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4geyBnZW5lcmF0ZSB9O1xufSkoKTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihhcHBJZCkge1xuICAgIHRoaXMuYXBwSWQgPSBhcHBJZDtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlTmV3S2V5cGFpcigpIHtcbiAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgLypcbiAgICAgICAgd2VicGFja0NodW5rTmFtZTogXCJrZXlHZW5lcmF0b3JcIixcbiAgICAgICAgd2VicGFja1ByZWxvYWQ6IHRydWVcbiAgICAgICovXG4gICAgICAnLi9rZXlHZW5lcmF0b3InKS50aGVuKCh7IGRlZmF1bHQ6IGtleUdlbmVyYXRvciB9KSA9PiB7XG4gICAgICByZXR1cm4ga2V5R2VuZXJhdG9yLmdlbmVyYXRlKHRoaXMuYXBwSWQpLnRoZW4oKGtleXBhaXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGtleXBhaXI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEtleXNGcm9tU3RvcmFnZSgpIHx8IGF3YWl0IHRoaXMuZ2VuZXJhdGVOZXdLZXlwYWlyKCk7XG4gIH1cblxuICByZWFkS2V5c0Zyb21TdG9yYWdlKCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuYXBwSWQgKyAnX3B1YmxpY0tleScpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmFwcElkICsgJ19wcml2YXRlS2V5Jyk7XG5cbiAgICByZXR1cm4gKHB1YmxpY0tleSAmJiBwcml2YXRlS2V5KSA/XG4gICAgICB7XG4gICAgICAgIHB1YmxpYzogcHVibGljS2V5LFxuICAgICAgICBwcml2YXRlOiBwcml2YXRlS2V5XG4gICAgICB9IDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldFB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0S2V5cygpKVsncHVibGljJ107XG4gIH1cblxuICBhc3luYyBnZXRQcml2YXRlS2V5KCkge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRLZXlzKCkpWydwcml2YXRlJ107XG4gIH1cblxuICBhc3luYyBkZWNyeXB0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJpdmF0ZUtleSgpLnRoZW4ocHJpdmF0ZUtleSA9PiB7XG4gICAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgICAvKlxuICAgICAgICAgIHdlYnBhY2tDaHVua05hbWU6IFwianNlbmNyeXB0XCIsXG4gICAgICAgICAgd2VicGFja1ByZWxvYWQ6IHRydWVcbiAgICAgICAgKi9cbiAgICAgICAgJ2pzZW5jcnlwdCcpLnRoZW4oKHsgZGVmYXVsdDogSnNlbmNyeXB0IH0pID0+IHtcbiAgICAgICAgY29uc3QganNlbmNyeXB0ID0gbmV3IEpzZW5jcnlwdCgpO1xuXG4gICAgICAgIGpzZW5jcnlwdC5zZXRQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc2VuY3J5cHQuZGVjcnlwdChwYXlsb2FkKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZvcmdlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImZvcmdlXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnM6IHtcbiAgICB1c2VQdXJlSmF2YVNjcmlwdDogZmFsc2VcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE4IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgYmFzZU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxuLyogVXRpbGl0aWVzIEFQSSAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnV0aWwgPSBmb3JnZS51dGlsIHx8IHt9O1xuXG4vLyBkZWZpbmUgc2V0SW1tZWRpYXRlIGFuZCBuZXh0VGlja1xuKGZ1bmN0aW9uKCkge1xuICAvLyB1c2UgbmF0aXZlIG5leHRUaWNrICh1bmxlc3Mgd2UncmUgaW4gd2VicGFjaylcbiAgLy8gd2VicGFjayAob3IgYmV0dGVyIG5vZGUtbGlicy1icm93c2VyIHBvbHlmaWxsKSBzZXRzIHByb2Nlc3MuYnJvd3Nlci5cbiAgLy8gdGhpcyB3YXkgd2UgY2FuIGRldGVjdCB3ZWJwYWNrIHByb3Blcmx5XG4gIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrICYmICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB1dGlsLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggbmV4dFRpY2ssIG9sZGVyIHZlcnNpb25zIG9mIG5vZGVcbiAgICAgIC8vICh0aG9zZSB3L28gc2V0SW1tZWRpYXRlKSB3b24ndCB0b3RhbGx5IHN0YXJ2ZSBJT1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSB1dGlsLm5leHRUaWNrO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwb2x5ZmlsbCBuZXh0VGljayB3aXRoIG5hdGl2ZSBzZXRJbW1lZGlhdGVcbiAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbW1lZGlhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpOyB9O1xuICAgIHV0aWwubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBOb3RlOiBBIHBvbHlmaWxsIHVwZ3JhZGUgcGF0dGVybiBpcyB1c2VkIGhlcmUgdG8gYWxsb3cgY29tYmluaW5nXG4gIHBvbHlmaWxscy4gRm9yIGV4YW1wbGUsIE11dGF0aW9uT2JzZXJ2ZXIgaXMgZmFzdCwgYnV0IGJsb2NrcyBVSSB1cGRhdGVzLFxuICBzbyBpdCBuZWVkcyB0byBhbGxvdyBVSSB1cGRhdGVzIHBlcmlvZGljYWxseSwgc28gaXQgZmFsbHMgYmFjayBvblxuICBwb3N0TWVzc2FnZSBvciBzZXRUaW1lb3V0LiAqL1xuXG4gIC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dFxuICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH07XG5cbiAgLy8gdXBncmFkZSBwb2x5ZmlsbCB0byB1c2UgcG9zdE1lc3NhZ2VcbiAgaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG1zZyA9ICdmb3JnZS5zZXRJbW1lZGlhdGUnO1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAvLyBvbmx5IHNlbmQgbWVzc2FnZSB3aGVuIG9uZSBoYXNuJ3QgYmVlbiBzZW50IGluXG4gICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICBpZihjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBpZihldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhID09PSBtc2cpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfVxuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgaWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gcG9seWZpbGwgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGF0dHIgPSB0cnVlO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0pLm9ic2VydmUoZGl2LCB7YXR0cmlidXRlczogdHJ1ZX0pO1xuICAgIHZhciBvbGRTZXRJbW1lZGlhdGUgPSB1dGlsLnNldEltbWVkaWF0ZTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZihEYXRlLm5vdygpIC0gbm93ID4gMTUpIHtcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgb2xkU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG9ic2VydmVyIHdoZW4gaXQgaGFzbid0IGJlZW4gdHJpZ2dlcmVkIGluXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHR1cm4gb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2EnLCBhdHRyID0gIWF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHV0aWwubmV4dFRpY2sgPSB1dGlsLnNldEltbWVkaWF0ZTtcbn0pKCk7XG5cbi8vIGNoZWNrIGlmIHJ1bm5pbmcgdW5kZXIgTm9kZS5qc1xudXRpbC5pc05vZGVqcyA9XG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcblxuLy8gZGVmaW5lIGlzQXJyYXlcbnV0aWwuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJcbnV0aWwuaXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJWaWV3XG51dGlsLmlzQXJyYXlCdWZmZXJWaWV3ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAmJiB1dGlsLmlzQXJyYXlCdWZmZXIoeC5idWZmZXIpICYmIHguYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgYSBiaXRzIHBhcmFtIGlzIDgsIDE2LCAyNCwgb3IgMzIuIFVzZWQgdG8gdmFsaWRhdGUgaW5wdXQgZm9yXG4gKiBhbGdvcml0aG1zIHdoZXJlIGJpdCBtYW5pcHVsYXRpb24sIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIGFuZC9vciBhbGdvcml0aG1cbiAqIGRlc2lnbiBvbmx5IGFsbG93IGZvciBieXRlIG9wZXJhdGlvbnMgb2YgYSBsaW1pdGVkIHNpemUuXG4gKlxuICogQHBhcmFtIG4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogVGhyb3cgRXJyb3IgaWYgbiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCaXRzUGFyYW0obikge1xuICBpZighKG4gPT09IDggfHwgbiA9PT0gMTYgfHwgbiA9PT0gMjQgfHwgbiA9PT0gMzIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IDgsIDE2LCAyNCwgb3IgMzIgYml0cyBzdXBwb3J0ZWQ6ICcgKyBuKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBzZXQgQnl0ZUJ1ZmZlciB0byBiZXN0IGF2YWlsYWJsZSBiYWNraW5nXG51dGlsLkJ5dGVCdWZmZXIgPSBCeXRlU3RyaW5nQnVmZmVyO1xuXG4vKiogQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBmb3IgYSBiaW5hcnkgc3RyaW5nIGJhY2tlZCBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gW2JdIHRoZSBieXRlcyB0byB3cmFwIChlaXRoZXIgZW5jb2RlZCBhcyBzdHJpbmcsIG9uZSBieXRlIHBlclxuICogICAgICAgICAgY2hhcmFjdGVyLCBvciBhcyBhbiBBcnJheUJ1ZmZlciBvciBUeXBlZCBBcnJheSkuXG4gKi9cbmZ1bmN0aW9uIEJ5dGVTdHJpbmdCdWZmZXIoYikge1xuICAvLyBUT0RPOiB1cGRhdGUgdG8gbWF0Y2ggRGF0YUJ1ZmZlciBBUElcblxuICAvLyB0aGUgZGF0YSBpbiB0aGlzIGJ1ZmZlclxuICB0aGlzLmRhdGEgPSAnJztcbiAgLy8gdGhlIHBvaW50ZXIgZm9yIHJlYWRpbmcgZnJvbSB0aGlzIGJ1ZmZlclxuICB0aGlzLnJlYWQgPSAwO1xuXG4gIGlmKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuZGF0YSA9IGI7XG4gIH0gZWxzZSBpZih1dGlsLmlzQXJyYXlCdWZmZXIoYikgfHwgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhiKSkge1xuICAgIGlmKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGIgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb252ZXJ0IG5hdGl2ZSBidWZmZXIgdG8gZm9yZ2UgYnVmZmVyXG4gICAgICAvLyBGSVhNRTogc3VwcG9ydCBuYXRpdmUgYnVmZmVycyBpbnRlcm5hbGx5IGluc3RlYWRcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhpcy5wdXRCeXRlKGFycltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihiIGluc3RhbmNlb2YgQnl0ZVN0cmluZ0J1ZmZlciB8fFxuICAgICh0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIuZGF0YSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgYi5yZWFkID09PSAnbnVtYmVyJykpIHtcbiAgICAvLyBjb3B5IGV4aXN0aW5nIGJ1ZmZlclxuICAgIHRoaXMuZGF0YSA9IGIuZGF0YTtcbiAgICB0aGlzLnJlYWQgPSBiLnJlYWQ7XG4gIH1cblxuICAvLyB1c2VkIGZvciB2OCBvcHRpbWl6YXRpb25cbiAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xufVxudXRpbC5CeXRlU3RyaW5nQnVmZmVyID0gQnl0ZVN0cmluZ0J1ZmZlcjtcblxuLyogTm90ZTogVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gZm9yIFY4LWJhc2VkIGJyb3dzZXJzLiBXaGVuIFY4IGNvbmNhdGVuYXRlc1xuICBhIHN0cmluZywgdGhlIHN0cmluZ3MgYXJlIG9ubHkgam9pbmVkIGxvZ2ljYWxseSB1c2luZyBhIFwiY29ucyBzdHJpbmdcIiBvclxuICBcImNvbnN0cnVjdGVkL2NvbmNhdGVuYXRlZCBzdHJpbmdcIi4gVGhlc2UgY29udGFpbmVycyBrZWVwIHJlZmVyZW5jZXMgdG8gb25lXG4gIGFub3RoZXIgYW5kIGNhbiByZXN1bHQgaW4gdmVyeSBsYXJnZSBtZW1vcnkgdXNhZ2UuIEZvciBleGFtcGxlLCBpZiBhIDJNQlxuICBzdHJpbmcgaXMgY29uc3RydWN0ZWQgYnkgY29uY2F0ZW5hdGluZyA0IGJ5dGVzIHRvZ2V0aGVyIGF0IGEgdGltZSwgdGhlXG4gIG1lbW9yeSB1c2FnZSB3aWxsIGJlIH40NE1COyBzbyB+MjJ4IGluY3JlYXNlLiBUaGUgc3RyaW5ncyBhcmUgb25seSBqb2luZWRcbiAgdG9nZXRoZXIgd2hlbiBhbiBvcGVyYXRpb24gcmVxdWlyaW5nIHRoZWlyIGpvaW5pbmcgdGFrZXMgcGxhY2UsIHN1Y2ggYXNcbiAgc3Vic3RyKCkuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYWRkaW5nIGRhdGEgdG8gdGhpcyBidWZmZXIgdG8gZW5zdXJlXG4gIHRoZXNlIHR5cGVzIG9mIHN0cmluZ3MgYXJlIHBlcmlvZGljYWxseSBqb2luZWQgdG8gcmVkdWNlIHRoZSBtZW1vcnlcbiAgZm9vdHByaW50LiAqL1xudmFyIF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCA9IDQwOTY7XG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nID0gZnVuY3Rpb24oeCkge1xuICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCArPSB4O1xuICBpZih0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCA+IF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCkge1xuICAgIC8vIHRoaXMgc3Vic3RyKCkgc2hvdWxkIGNhdXNlIHRoZSBjb25zdHJ1Y3RlZCBzdHJpbmcgdG8gam9pblxuICAgIHRoaXMuZGF0YS5zdWJzdHIoMCwgMSk7XG4gICAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShiKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyIE4gdGltZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyBvZiB2YWx1ZSBiIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgYiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gIHZhciBkID0gdGhpcy5kYXRhO1xuICB3aGlsZShuID4gMCkge1xuICAgIGlmKG4gJiAxKSB7XG4gICAgICBkICs9IGI7XG4gICAgfVxuICAgIG4gPj4+PSAxO1xuICAgIGlmKG4gPiAwKSB7XG4gICAgICBiICs9IGI7XG4gICAgfVxuICB9XG4gIHRoaXMuZGF0YSA9IGQ7XG4gIHRoaXMuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcobik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgKGFzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcpIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdGhpcy5kYXRhICs9IGJ5dGVzO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKGJ5dGVzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgVVRGLTE2IGVuY29kZWQgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyh1dGlsLmVuY29kZVV0Zjgoc3RyKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYW4gbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgYnl0ZXMgPSAnJztcbiAgZG8ge1xuICAgIG4gLT0gODtcbiAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IG4pICYgMHhGRik7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhieXRlcyk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgLy8gcHV0SW50IGNoZWNrcyBuXG4gIGlmKGkgPCAwKSB7XG4gICAgaSArPSAyIDw8IChuIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBnaXZlbiBidWZmZXIgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gcHV0IGludG8gdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnVmZmVyLmdldEJ5dGVzKCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBmcm9tIHRoaXMgYnVmZmVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IDEuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAyNCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNik7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAzKSA8PCAyNCk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlXG4gKiByZWFkIHBvaW50ZXIgYnkgY2VpbChuLzgpLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIHJ2YWwgPSAwO1xuICBkbyB7XG4gICAgLy8gVE9ETzogVXNlIChydmFsICogMHgxMDApIGlmIGFkZGluZyBzdXBwb3J0IGZvciAzMyB0byA1MyBiaXRzLlxuICAgIHJ2YWwgPSAocnZhbCA8PCA4KSArIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbiAgICBuIC09IDg7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciwgdXNpbmdcbiAqIHR3bydzIGNvbXBsZW1lbnQsIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0U2lnbmVkSW50ID0gZnVuY3Rpb24obikge1xuICAvLyBnZXRJbnQgY2hlY2tzIG5cbiAgdmFyIHggPSB0aGlzLmdldEludChuKTtcbiAgdmFyIG1heCA9IDIgPDwgKG4gLSAyKTtcbiAgaWYoeCA+PSBtYXgpIHtcbiAgICB4IC09IG1heCA8PCAxO1xuICB9XG4gIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlcyBvdXQgaW50byBhIFVURi04IHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIFVURi04IHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZihjb3VudCkge1xuICAgIC8vIHJlYWQgY291bnQgYnl0ZXNcbiAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpO1xuICAgIHRoaXMucmVhZCArPSBjb3VudDtcbiAgfSBlbHNlIGlmKGNvdW50ID09PSAwKSB7XG4gICAgcnZhbCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgYWxsIGJ5dGVzLCBvcHRpbWl6ZSB0byBvbmx5IGNvcHkgd2hlbiBuZWVkZWRcbiAgICBydmFsID0gKHRoaXMucmVhZCA9PT0gMCkgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYnl0ZXMgZnJvbSB0aGlzIGJ1ZmZlciB3aXRob3V0IG1vZGlmeWluZ1xuICogdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZXQsIG9taXQgdG8gZ2V0IGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgc3RyaW5nIGZ1bGwgb2YgVVRGLTggZW5jb2RlZCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgcmV0dXJuICh0eXBlb2YoY291bnQpID09PSAndW5kZWZpbmVkJyA/XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCkgOlxuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyBpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cigwLCB0aGlzLnJlYWQgKyBpKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShiKSArXG4gICAgdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQgKyBpICsgMSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5kYXRhLmxlbmd0aCAtIDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjb3B5LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGMgPSB1dGlsLmNyZWF0ZUJ1ZmZlcih0aGlzLmRhdGEpO1xuICBjLnJlYWQgPSB0aGlzLnJlYWQ7XG4gIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9ICcnO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hvcnRlbnMgdGhpcyBidWZmZXIgYnkgdHJpbWluZyBieXRlcyBvZmYgb2YgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byB0cmltIG9mZi5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoKCkgLSBjb3VudCk7XG4gIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHIodGhpcy5yZWFkLCBsZW4pO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYiA9IHRoaXMuZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmKGIgPCAxNikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgVVRGLTE2IHN0cmluZyAoc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICpcbiAqIEByZXR1cm4gYSBVVEYtMTYgc3RyaW5nLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgodGhpcy5ieXRlcygpKTtcbn07XG5cbi8qKiBFbmQgQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqIEJ1ZmZlciB3L1VJbnQ4QXJyYXkgYmFja2luZyAqL1xuXG4vKipcbiAqIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxuICpcbiAqIENvbnN0cnVjdG9yIGZvciBhbiBBcnJheUJ1ZmZlci1iYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogVGhlIGJ1ZmZlciBtYXkgYmUgY29uc3RydWN0ZWQgZnJvbSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBhXG4gKiBUeXBlZEFycmF5LlxuICpcbiAqIElmIGEgc3RyaW5nIGlzIGdpdmVuLCBpdHMgZW5jb2Rpbmcgc2hvdWxkIGJlIHByb3ZpZGVkIGFzIGFuIG9wdGlvbixcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGRlZmF1bHQgdG8gJ2JpbmFyeScuIEEgJ2JpbmFyeScgc3RyaW5nIGlzIGVuY29kZWQgc3VjaFxuICogdGhhdCBlYWNoIGNoYXJhY3RlciBpcyBvbmUgYnl0ZSBpbiBsZW5ndGggYW5kIHNpemUuXG4gKlxuICogSWYgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBUeXBlZEFycmF5IGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWRcbiAqICpkaXJlY3RseSogd2l0aG91dCBhbnkgY29weWluZy4gTm90ZSB0aGF0LCBpZiBhIHdyaXRlIHRvIHRoZSBidWZmZXIgcmVxdWlyZXNcbiAqIG1vcmUgc3BhY2UsIHRoZSBidWZmZXIgd2lsbCBhbGxvY2F0ZSBhIG5ldyBiYWNraW5nIEFycmF5QnVmZmVyIHRvXG4gKiBhY2NvbW1vZGF0ZS4gVGhlIHN0YXJ0aW5nIHJlYWQgYW5kIHdyaXRlIG9mZnNldHMgZm9yIHRoZSBidWZmZXIgbWF5IGJlXG4gKiBnaXZlbiBhcyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBbYl0gdGhlIGluaXRpYWwgYnl0ZXMgZm9yIHRoaXMgYnVmZmVyLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW3JlYWRPZmZzZXRdIHRoZSBzdGFydGluZyByZWFkIG9mZnNldCB0byB1c2UgKGRlZmF1bHQ6IDApLlxuICogICAgICAgICAgW3dyaXRlT2Zmc2V0XSB0aGUgc3RhcnRpbmcgd3JpdGUgb2Zmc2V0IHRvIHVzZSAoZGVmYXVsdDogdGhlXG4gKiAgICAgICAgICAgIGxlbmd0aCBvZiB0aGUgZmlyc3QgcGFyYW1ldGVyKS5cbiAqICAgICAgICAgIFtncm93U2l6ZV0gdGhlIG1pbmltdW0gYW1vdW50LCBpbiBieXRlcywgdG8gZ3JvdyB0aGUgYnVmZmVyIGJ5IHRvXG4gKiAgICAgICAgICAgIGFjY29tbW9kYXRlIHdyaXRlcyAoZGVmYXVsdDogMTAyNCkuXG4gKiAgICAgICAgICBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyAoJ2JpbmFyeScsICd1dGY4JywgJ3V0ZjE2JywgJ2hleCcpIGZvciB0aGVcbiAqICAgICAgICAgICAgZmlyc3QgcGFyYW1ldGVyLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICovXG5mdW5jdGlvbiBEYXRhQnVmZmVyKGIsIG9wdGlvbnMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvaW50ZXJzIGZvciByZWFkIGZyb20vd3JpdGUgdG8gYnVmZmVyXG4gIHRoaXMucmVhZCA9IG9wdGlvbnMucmVhZE9mZnNldCB8fCAwO1xuICB0aGlzLmdyb3dTaXplID0gb3B0aW9ucy5ncm93U2l6ZSB8fCAxMDI0O1xuXG4gIHZhciBpc0FycmF5QnVmZmVyID0gdXRpbC5pc0FycmF5QnVmZmVyKGIpO1xuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGIpO1xuICBpZihpc0FycmF5QnVmZmVyIHx8IGlzQXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgLy8gdXNlIEFycmF5QnVmZmVyIGRpcmVjdGx5XG4gICAgaWYoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGp1c3QgcmVhZC93cml0ZSBvZmZzZXQgYmFzZWQgb24gdGhlIHR5cGUgb2Ygdmlld1xuICAgICAgLy8gb3Igc3BlY2lmeSB0aGF0IHRoaXMgbXVzdCBiZSBkb25lIGluIHRoZSBvcHRpb25zIC4uLiB0aGF0IHRoZVxuICAgICAgLy8gb2Zmc2V0cyBhcmUgYnl0ZS1iYXNlZFxuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMud3JpdGUgPSAoJ3dyaXRlT2Zmc2V0JyBpbiBvcHRpb25zID9cbiAgICAgIG9wdGlvbnMud3JpdGVPZmZzZXQgOiB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB0byBlbXB0eSBhcnJheSBidWZmZXIgYW5kIGFkZCBhbnkgZ2l2ZW4gYnl0ZXMgdXNpbmcgcHV0Qnl0ZXNcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIHRoaXMud3JpdGUgPSAwO1xuXG4gIGlmKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wdXRCeXRlcyhiKTtcbiAgfVxuXG4gIGlmKCd3cml0ZU9mZnNldCcgaW4gb3B0aW9ucykge1xuICAgIHRoaXMud3JpdGUgPSBvcHRpb25zLndyaXRlT2Zmc2V0O1xuICB9XG59XG51dGlsLkRhdGFCdWZmZXIgPSBEYXRhQnVmZmVyO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndyaXRlIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogRW5zdXJlcyB0aGlzIGJ1ZmZlciBoYXMgZW5vdWdoIGVtcHR5IHNwYWNlIHRvIGFjY29tbW9kYXRlIHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGJ5dGVzLiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgbWF5IGJlIGdpdmVuIHRoYXQgaW5kaWNhdGVzIGEgbWluaW11bVxuICogYW1vdW50IHRvIGdyb3cgdGhlIGJ1ZmZlciBpZiBuZWNlc3NhcnkuIElmIHRoZSBwYXJhbWV0ZXIgaXMgbm90IGdpdmVuLFxuICogdGhlIGJ1ZmZlciB3aWxsIGJlIGdyb3duIGJ5IHNvbWUgcHJldmlvdXNseS1zcGVjaWZpZWQgZGVmYXVsdCBhbW91bnRcbiAqIG9yIGhldXJpc3RpYy5cbiAqXG4gKiBAcGFyYW0gYW1vdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gYWNjb21tb2RhdGUuXG4gKiBAcGFyYW0gW2dyb3dTaXplXSB0aGUgbWluaW11bSBhbW91bnQsIGluIGJ5dGVzLCB0byBncm93IHRoZSBidWZmZXIgYnkgaWZcbiAqICAgICAgICAgIG5lY2Vzc2FyeS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5hY2NvbW1vZGF0ZSA9IGZ1bmN0aW9uKGFtb3VudCwgZ3Jvd1NpemUpIHtcbiAgaWYodGhpcy5sZW5ndGgoKSA+PSBhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm93U2l6ZSA9IE1hdGgubWF4KGdyb3dTaXplIHx8IHRoaXMuZ3Jvd1NpemUsIGFtb3VudCk7XG5cbiAgLy8gZ3JvdyBidWZmZXJcbiAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KFxuICAgIHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5ieXRlT2Zmc2V0LCB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICsgZ3Jvd1NpemUpO1xuICBkc3Quc2V0KHNyYyk7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QuYnVmZmVyKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgxKTtcbiAgdGhpcy5kYXRhLnNldFVpbnQ4KHRoaXMud3JpdGUrKywgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUobik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB0aGlzLmRhdGEuc2V0VWludDgoYik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYnl0ZXMgaW4gdGhpcyBidWZmZXIuIFRoZSBieXRlcyBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcsIGFuXG4gKiBBcnJheUJ1ZmZlciwgYSBEYXRhVmlldywgb3IgYSBUeXBlZEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gcHV0LlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyICgnYmluYXJ5JywgJ3V0ZjgnLFxuICogICAgICAgICAgJ3V0ZjE2JywgJ2hleCcpLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcywgZW5jb2RpbmcpIHtcbiAgaWYodXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gc3JjLmJ5dGVMZW5ndGggLSBzcmMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmFjY29tbW9kYXRlKGxlbik7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLndyaXRlICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmKHV0aWwuaXNBcnJheUJ1ZmZlcihieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIHRoaXMuYWNjb21tb2RhdGUoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyKTtcbiAgICBkc3Quc2V0KHNyYywgdGhpcy53cml0ZSk7XG4gICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGJ5dGVzIGlzIGEgdXRpbC5EYXRhQnVmZmVyIG9yIGVxdWl2YWxlbnRcbiAgaWYoYnl0ZXMgaW5zdGFuY2VvZiB1dGlsLkRhdGFCdWZmZXIgfHxcbiAgICAodHlwZW9mIGJ5dGVzID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBieXRlcy5yZWFkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYnl0ZXMud3JpdGUgPT09ICdudW1iZXInICYmXG4gICAgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcy5kYXRhKSkpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuZGF0YS5ieXRlTGVuZ3RoLCBieXRlcy5yZWFkLCBieXRlcy5sZW5ndGgoKSk7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmRhdGEuYnl0ZUxlbmd0aCwgdGhpcy53cml0ZSk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMud3JpdGUgKz0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZihieXRlcyBpbnN0YW5jZW9mIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlcikge1xuICAgIC8vIGNvcHkgYmluYXJ5IHN0cmluZyBhbmQgcHJvY2VzcyBhcyB0aGUgc2FtZSBhcyBhIHN0cmluZyBwYXJhbWV0ZXIgYmVsb3dcbiAgICBieXRlcyA9IGJ5dGVzLmRhdGE7XG4gICAgZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgfVxuXG4gIC8vIHN0cmluZyBjb252ZXJzaW9uXG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ2JpbmFyeSc7XG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmlldztcblxuICAgIC8vIGRlY29kZSBmcm9tIHN0cmluZ1xuICAgIGlmKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gMikpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5oZXguZGVjb2RlKGJ5dGVzLCB2aWV3LCB0aGlzLndyaXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZihlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJ5dGVzLmxlbmd0aCAvIDQpICogMyk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTggYnl0ZXNcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAvLyBlbmNvZGUgYXMgVVRGLTggdGhlbiBkZWNvZGUgc3RyaW5nIGFzIHJhdyBiaW5hcnlcbiAgICAgIGJ5dGVzID0gdXRpbC5lbmNvZGVVdGY4KGJ5dGVzKTtcbiAgICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIHN0cmluZyBhcyByYXcgYmluYXJ5XG4gICAgaWYoZW5jb2RpbmcgPT09ICdiaW5hcnknIHx8IGVuY29kaW5nID09PSAncmF3Jykge1xuICAgICAgLy8gb25lIGJ5dGUgcGVyIGNoYXJhY3RlclxuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShieXRlcy5sZW5ndGgpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5yYXcuZGVjb2RlKHZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTE2IGJ5dGVzXG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGYxNicpIHtcbiAgICAgIC8vIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCAqIDIpO1xuICAgICAgdmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC50ZXh0LnV0ZjE2LmVuY29kZSh2aWV3KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxuXG4gIHRocm93IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogJyArIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogUHV0cyB0aGUgZ2l2ZW4gYnVmZmVyIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHB1dCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHRoaXMucHV0Qnl0ZXMoYnVmZmVyKTtcbiAgYnVmZmVyLmNsZWFyKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyBmb3IgdGhlIHN0cmluZyAoZGVmYXVsdDogJ3V0ZjE2JykuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoc3RyLCAndXRmMTYnKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpID4+IDggJiAweEZGRkYpO1xuICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlLCBpID4+IDE2ICYgMHhGRik7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGEuc2V0SW50MzIodGhpcy53cml0ZSwgaSk7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDB4RkYpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgMHhGRkZGLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGksIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGFuIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuIC8gOCk7XG4gIGRvIHtcbiAgICBuIC09IDg7XG4gICAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSsrLCAoaSA+PiBuKSAmIDB4RkYpO1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHRoaXMuYWNjb21tb2RhdGUobiAvIDgpO1xuICBpZihpIDwgMCkge1xuICAgIGkgKz0gMiA8PCAobiAtIDEpO1xuICB9XG4gIHJldHVybiB0aGlzLnB1dEludChpLCBuKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgZnJvbSB0aGlzIGJ1ZmZlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSAxLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQsIHRydWUpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQgKyAxLCB0cnVlKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkLCB0cnVlKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGVcbiAqIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICAvLyBUT0RPOiBVc2UgKHJ2YWwgKiAweDEwMCkgaWYgYWRkaW5nIHN1cHBvcnQgZm9yIDMzIHRvIDUzIGJpdHMuXG4gICAgcnZhbCA9IChydmFsIDw8IDgpICsgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xuICAgIG4gLT0gODtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLCB1c2luZ1xuICogdHdvJ3MgY29tcGxlbWVudCwgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIC8vIGdldEludCBjaGVja3MgblxuICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICB2YXIgbWF4ID0gMiA8PCAobiAtIDIpO1xuICBpZih4ID49IG1heCkge1xuICAgIHggLT0gbWF4IDw8IDE7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIFJlYWRzIGJ5dGVzIG91dCBpbnRvIGEgVVRGLTggc3RyaW5nIGFuZCBjbGVhcnMgdGhlbSBmcm9tIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZCwgdW5kZWZpbmVkIG9yIG51bGwgZm9yIGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgVVRGLTggc3RyaW5nIG9mIGJ5dGVzLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlIHRoaXMgbWV0aG9kLCBpdCBpcyBwb29ybHkgbmFtZWQgYW5kXG4gIC8vIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScpIHJlcGxhY2VzIGl0XG4gIC8vIGFkZCBhIHRvVHlwZWRBcnJheSgpL3RvQXJyYXlCdWZmZXIoKSBmdW5jdGlvblxuICB2YXIgcnZhbDtcbiAgaWYoY291bnQpIHtcbiAgICAvLyByZWFkIGNvdW50IGJ5dGVzXG4gICAgY291bnQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBjb3VudCk7XG4gICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB0aGlzLnJlYWQgKz0gY291bnQ7XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMCkge1xuICAgIHJ2YWwgPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGFsbCBieXRlcywgb3B0aW1pemUgdG8gb25seSBjb3B5IHdoZW4gbmVlZGVkXG4gICAgcnZhbCA9ICh0aGlzLnJlYWQgPT09IDApID8gdGhpcy5kYXRhIDogdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dCBtb2RpZnlpbmdcbiAqIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIFVURi04IGVuY29kZWQgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkLCBhZGQgXCJnZXRTdHJpbmcoKVwiXG4gIHJldHVybiAodHlwZW9mKGNvdW50KSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpIDpcbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEuc2V0VWludDgoaSwgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMud3JpdGUgLSAxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY29weS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgdXRpbC5EYXRhQnVmZmVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLnJlYWQpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QpO1xuICAgIHRoaXMud3JpdGUgLT0gdGhpcy5yZWFkO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0ZW5zIHRoaXMgYnVmZmVyIGJ5IHRyaW1pbmcgYnl0ZXMgb2ZmIG9mIHRoZSBlbmQgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gdHJpbSBvZmYuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHRoaXMud3JpdGUgPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEuYnl0ZUxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGIgPSB0aGlzLmRhdGEuZ2V0VWludDgoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBzdHJpbmcsIHVzaW5nIHRoZSBnaXZlbiBlbmNvZGluZy4gSWYgbm9cbiAqIGVuY29kaW5nIGlzIGdpdmVuLCAndXRmOCcgKFVURi04KSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyB0byB1c2U6ICdiaW5hcnknLCAndXRmOCcsICd1dGYxNicsICdoZXgnLFxuICogICAgICAgICAgJ2Jhc2U2NCcgKGRlZmF1bHQ6ICd1dGY4JykuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgdGhpcy5yZWFkLCB0aGlzLmxlbmd0aCgpKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gZW5jb2RlIHRvIHN0cmluZ1xuICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LnJhdy5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmhleC5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUodmlldyk7XG4gIH1cblxuICAvLyBkZWNvZGUgdG8gdGV4dFxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgcmV0dXJuIHV0aWwudGV4dC51dGY4LmRlY29kZSh2aWV3KTtcbiAgfVxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmMTYuZGVjb2RlKHZpZXcpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9VSW50OEFycmF5IGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYnVmZmVyIHRoYXQgc3RvcmVzIGJ5dGVzLiBBIHZhbHVlIG1heSBiZSBnaXZlbiB0byBwdXQgaW50byB0aGVcbiAqIGJ1ZmZlciB0aGF0IGlzIGVpdGhlciBhIHN0cmluZyBvZiBieXRlcyBvciBhIFVURi0xNiBzdHJpbmcgdGhhdCB3aWxsXG4gKiBiZSBlbmNvZGVkIHVzaW5nIFVURi04ICh0byBkbyB0aGUgbGF0dGVyLCBzcGVjaWZ5ICd1dGY4JyBhcyB0aGUgZW5jb2RpbmcpLlxuICpcbiAqIEBwYXJhbSBbaW5wdXRdIHRoZSBieXRlcyB0byB3cmFwIChhcyBhIHN0cmluZykgb3IgYSBVVEYtMTYgc3RyaW5nIHRvIGVuY29kZVxuICogICAgICAgICAgYXMgVVRGLTguXG4gKiBAcGFyYW0gW2VuY29kaW5nXSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICovXG51dGlsLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGlucHV0LCBlbmNvZGluZykge1xuICAvLyBUT0RPOiBkZXByZWNhdGUsIHVzZSBuZXcgQnl0ZUJ1ZmZlcigpIGluc3RlYWRcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAncmF3JztcbiAgaWYoaW5wdXQgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgaW5wdXQgPSB1dGlsLmVuY29kZVV0ZjgoaW5wdXQpO1xuICB9XG4gIHJldHVybiBuZXcgdXRpbC5CeXRlQnVmZmVyKGlucHV0KTtcbn07XG5cbi8qKlxuICogRmlsbHMgYSBzdHJpbmcgd2l0aCBhIHBhcnRpY3VsYXIgdmFsdWUuIElmIHlvdSB3YW50IHRoZSBzdHJpbmcgdG8gYmUgYSBieXRlXG4gKiBzdHJpbmcsIHBhc3MgaW4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGVCeXRlKS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY2hhcmFjdGVyIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoLCB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICogICAgICAgICAgdG8gZmlsbCB0aGUgc3RyaW5nIHdpdGggYSBieXRlIHZhbHVlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHZhbHVlIGMgdG8gZmlsbCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbGxlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZmlsbFN0cmluZyA9IGZ1bmN0aW9uKGMsIG4pIHtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgcyArPSBjO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYyArPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBwZXIgYnl0ZSBYT1IgYmV0d2VlbiB0d28gYnl0ZSBzdHJpbmdzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYVxuICogc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzMSBmaXJzdCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gczIgc2Vjb25kIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gWE9SLlxuICpcbiAqIEByZXR1cm4gdGhlIFhPUidkIHJlc3VsdC5cbiAqL1xudXRpbC54b3JCeXRlcyA9IGZ1bmN0aW9uKHMxLCBzMiwgbikge1xuICB2YXIgczMgPSAnJztcbiAgdmFyIGIgPSAnJztcbiAgdmFyIHQgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB2YXIgYyA9IDA7XG4gIGZvcig7IG4gPiAwOyAtLW4sICsraSkge1xuICAgIGIgPSBzMS5jaGFyQ29kZUF0KGkpIF4gczIuY2hhckNvZGVBdChpKTtcbiAgICBpZihjID49IDEwKSB7XG4gICAgICBzMyArPSB0O1xuICAgICAgdCA9ICcnO1xuICAgICAgYyA9IDA7XG4gICAgfVxuICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICArK2M7XG4gIH1cbiAgczMgKz0gdDtcbiAgcmV0dXJuIHMzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5oZXhUb0J5dGVzID0gZnVuY3Rpb24oaGV4KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmRlY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBydmFsID0gJyc7XG4gIHZhciBpID0gMDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEgPT0gMSkge1xuICAgIC8vIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgY29udmVydCBmaXJzdCBjaGFyYWN0ZXIgYWxvbmVcbiAgICBpID0gMTtcbiAgICBydmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4WzBdLCAxNikpO1xuICB9XG4gIC8vIGNvbnZlcnQgMiBjaGFyYWN0ZXJzICgxIGJ5dGUpIGF0IGEgdGltZVxuICBmb3IoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gaGV4LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5ieXRlc1RvSGV4ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5oZXguZW5jb2RlIGluc3RlYWQuXCJcbiAgcmV0dXJuIHV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKS50b0hleCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiAzMi1iaXQgaW50ZWdlciB0byA0LWJpZy1lbmRpYW4gYnl0ZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGkgdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBzdHJpbmcuXG4gKi9cbnV0aWwuaW50MzJUb0J5dGVzID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLy8gYmFzZTY0IGNoYXJhY3RlcnMsIHJldmVyc2UgbWFwcGluZ1xudmFyIF9iYXNlNjQgPVxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xudmFyIF9iYXNlNjRJZHggPSBbXG4vKjQzIC00MyA9IDAqL1xuLyonKycsICAxLCAgMiwgIDMsJy8nICovXG4gICA2MiwgLTEsIC0xLCAtMSwgNjMsXG5cbi8qJzAnLCcxJywnMicsJzMnLCc0JywnNScsJzYnLCc3JywnOCcsJzknICovXG4gICA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksIDYwLCA2MSxcblxuLyoxNSwgMTYsIDE3LCc9JywgMTksIDIwLCAyMSAqL1xuICAtMSwgLTEsIC0xLCA2NCwgLTEsIC0xLCAtMSxcblxuLyo2NSAtIDQzID0gMjIqL1xuLyonQScsJ0InLCdDJywnRCcsJ0UnLCdGJywnRycsJ0gnLCdJJywnSicsJ0snLCdMJywnTScsICovXG4gICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLFxuXG4vKidOJywnTycsJ1AnLCdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJyAqL1xuICAgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsXG5cbi8qOTEgLSA0MyA9IDQ4ICovXG4vKjQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMgKi9cbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcblxuLyo5NyAtIDQzID0gNTQqL1xuLyonYScsJ2InLCdjJywnZCcsJ2UnLCdmJywnZycsJ2gnLCdpJywnaicsJ2snLCdsJywnbScgKi9cbiAgIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LFxuXG4vKiduJywnbycsJ3AnLCdxJywncicsJ3MnLCd0JywndScsJ3YnLCd3JywneCcsJ3knLCd6JyAqL1xuICAgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTFcbl07XG5cbi8vIGJhc2U1OCBjaGFyYWN0ZXJzIChCaXRjb2luIGFscGhhYmV0KVxudmFyIF9iYXNlNTggPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG5cbi8qKlxuICogQmFzZTY0IGVuY29kZXMgYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcyB0byBiYXNlNjQtZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dC5cbiAqL1xudXRpbC5lbmNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQgZGVjb2RlcyBhIHN0cmluZyBpbnRvIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlNjQtZW5jb2RlZCBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZGVjb2RlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgaW5zdGVhZC5cIlxuXG4gIC8vIHJlbW92ZSBhbGwgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcblxuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCkpO1xuICAgIGlmKGVuYzMgIT09IDY0KSB7XG4gICAgICAvLyBkZWNvZGVkIGF0IGxlYXN0IDIgYnl0ZXNcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFVURi04IGVuY29kZXMgdGhlIGdpdmVuIFVURi0xNiBlbmNvZGVkIHN0cmluZyAoYSBzdGFuZGFyZCBKYXZhU2NyaXB0XG4gKiBzdHJpbmcpLiBOb24tQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlIGVuY29kZWQgYXMgbXVsdGlwbGUgYnl0ZXMgYWNjb3JkaW5nXG4gKiB0byBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmVuY29kZVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIFVURi04IGVuY29kZWQgc3RyaW5nIGludG8gYSBVVEYtMTYgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgVVRGLTE2IGVuY29kZWQgc3RyaW5nIChzdGFuZGFyZCBKYXZhU2NyaXB0IHN0cmluZykuXG4gKi9cbnV0aWwuZGVjb2RlVXRmOCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn07XG5cbi8vIGJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyB0b29sc1xuLy8gRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG51dGlsLmJpbmFyeSA9IHtcbiAgcmF3OiB7fSxcbiAgaGV4OiB7fSxcbiAgYmFzZTY0OiB7fSxcbiAgYmFzZTU4OiB7fSxcbiAgYmFzZU4gOiB7XG4gICAgZW5jb2RlOiBiYXNlTi5lbmNvZGUsXG4gICAgZGVjb2RlOiBiYXNlTi5kZWNvZGVcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgVWludDhBcnJheSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy4gVGhpcyBlbmNvZGluZyB1c2VzXG4gKiBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1IGZvciBlYWNoIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5iaW5hcnkucmF3LmVuY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuIFRoaXMgZW5jb2RpbmcgdXNlc1xuICogYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgYmluYXJ5LWVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LnJhdy5kZWNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSAnYmluYXJ5JyBzdHJpbmcsIEFycmF5QnVmZmVyLCBEYXRhVmlldywgVHlwZWRBcnJheSwgb3JcbiAqIEJ5dGVCdWZmZXIgYXMgYSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuYmluYXJ5LmhleC5lbmNvZGUgPSB1dGlsLmJ5dGVzVG9IZXg7XG5cbi8qKlxuICogRGVjb2RlcyBhIGhleC1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGhleCB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5oZXguZGVjb2RlID0gZnVuY3Rpb24oaGV4LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBpID0gMCwgaiA9IG9mZnNldDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEpIHtcbiAgICAvLyBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGNvbnZlcnQgZmlyc3QgY2hhcmFjdGVyIGFsb25lXG4gICAgaSA9IDE7XG4gICAgb3V0W2orK10gPSBwYXJzZUludChoZXhbMF0sIDE2KTtcbiAgfVxuICAvLyBjb252ZXJ0IDIgY2hhcmFjdGVycyAoMSBieXRlKSBhdCBhIHRpbWVcbiAgZm9yKDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgIG91dFtqKytdID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEJhc2U2NC1lbmNvZGVzIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dCBzdHJpbmcuXG4gKi9cbnV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCBpbnB1dC5ieXRlTGVuZ3RoKSB7XG4gICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgY2hyMyA9IGlucHV0W2krK107XG5cbiAgICAvLyBlbmNvZGUgNCBjaGFyYWN0ZXIgZ3JvdXBcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KGNocjEgPj4gMik7XG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpKTtcbiAgICBpZihpc05hTihjaHIyKSkge1xuICAgICAgbGluZSArPSAnPT0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKTtcbiAgICAgIGxpbmUgKz0gaXNOYU4oY2hyMykgPyAnPScgOiBfYmFzZTY0LmNoYXJBdChjaHIzICYgNjMpO1xuICAgIH1cblxuICAgIGlmKG1heGxpbmUgJiYgbGluZS5sZW5ndGggPiBtYXhsaW5lKSB7XG4gICAgICBvdXRwdXQgKz0gbGluZS5zdWJzdHIoMCwgbWF4bGluZSkgKyAnXFxyXFxuJztcbiAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cihtYXhsaW5lKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0ICs9IGxpbmU7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZTY0LWVuY29kZWQgaW5wdXQgc3RyaW5nLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDQpICogMyk7XG4gIH1cblxuICAvLyByZW1vdmUgYWxsIG5vbi1iYXNlNjQgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dFtqKytdID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICBpZihlbmMzICE9PSA2NCkge1xuICAgICAgLy8gZGVjb2RlZCBhdCBsZWFzdCAyIGJ5dGVzXG4gICAgICBvdXRbaisrXSA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xuICAgICAgaWYoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgLy8gZGVjb2RlZCAzIGJ5dGVzXG4gICAgICAgIG91dFtqKytdID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSByZXN1bHQgaXMgdGhlIGV4YWN0IGRlY29kZWQgbGVuZ3RoXG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQuc3ViYXJyYXkoMCwgaik7XG59O1xuXG4vLyBhZGQgc3VwcG9ydCBmb3IgYmFzZTU4IGVuY29kaW5nL2RlY29kaW5nIHdpdGggQml0Y29pbiBhbHBoYWJldFxudXRpbC5iaW5hcnkuYmFzZTU4LmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlTi5lbmNvZGUoaW5wdXQsIF9iYXNlNTgsIG1heGxpbmUpO1xufTtcbnV0aWwuYmluYXJ5LmJhc2U1OC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZU4uZGVjb2RlKGlucHV0LCBfYmFzZTU4LCBtYXhsaW5lKTtcbn07XG5cbi8vIHRleHQgZW5jb2RpbmcvZGVjb2RpbmcgdG9vbHNcbi8vIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxudXRpbC50ZXh0ID0ge1xuICB1dGY4OiB7fSxcbiAgdXRmMTY6IHt9XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtOCBpbiBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwudGV4dC51dGY4LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgc3RyID0gdXRpbC5lbmNvZGVVdGY4KHN0cik7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi04IGNvbnRlbnRzIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgVWludDhBcnJheSB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAqL1xudXRpbC50ZXh0LnV0ZjguZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWwuZGVjb2RlVXRmOChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKSk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtMTYgaW4gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLnRleHQudXRmMTYuZW5jb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCAqIDIpO1xuICB9XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KG91dC5idWZmZXIpO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIHZhciBrID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgdmlld1trKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaiArPSAyO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi0xNiBjb250ZW50cyBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gKi9cbnV0aWwudGV4dC51dGYxNi5kZWNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnl0ZXMuYnVmZmVyKSk7XG59O1xuXG4vKipcbiAqIERlZmxhdGVzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIGEgZmxhc2ggaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBieXRlcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSByYXcgdHJ1ZSB0byByZXR1cm4gb25seSByYXcgZGVmbGF0ZSBkYXRhLCBmYWxzZSB0byBpbmNsdWRlIHpsaWJcbiAqICAgICAgICAgIGhlYWRlciBhbmQgdHJhaWxlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLlxuICovXG51dGlsLmRlZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgYnl0ZXMgPSB1dGlsLmRlY29kZTY0KGFwaS5kZWZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsKTtcblxuICAvLyBzdHJpcCB6bGliIGhlYWRlciBhbmQgdHJhaWxlciBpZiBuZWNlc3NhcnlcbiAgaWYocmF3KSB7XG4gICAgLy8gemxpYiBoZWFkZXIgaXMgMiBieXRlcyAoQ01GLEZMRykgd2hlcmUgRkxHIGluZGljYXRlcyB0aGF0XG4gICAgLy8gdGhlcmUgaXMgYSA0LWJ5dGUgRElDVCAoYWxkZXItMzIpIGJsb2NrIGJlZm9yZSB0aGUgZGF0YSBpZlxuICAgIC8vIGl0cyA1dGggYml0IGlzIHNldFxuICAgIHZhciBzdGFydCA9IDI7XG4gICAgdmFyIGZsZyA9IGJ5dGVzLmNoYXJDb2RlQXQoMSk7XG4gICAgaWYoZmxnICYgMHgyMCkge1xuICAgICAgc3RhcnQgPSA2O1xuICAgIH1cbiAgICAvLyB6bGliIHRyYWlsZXIgaXMgNCBieXRlcyBvZiBhZGxlci0zMlxuICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKHN0YXJ0LCBieXRlcy5sZW5ndGggLSA0KTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn07XG5cbi8qKlxuICogSW5mbGF0ZXMgdGhlIGdpdmVuIGRhdGEgdXNpbmcgYSBmbGFzaCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBkYXRhLlxuICogQHBhcmFtIHJhdyB0cnVlIGlmIHRoZSBpbmNvbWluZyBkYXRhIGhhcyBubyB6bGliIGhlYWRlciBvciB0cmFpbGVyIGFuZCBpc1xuICogICAgICAgICAgcmF3IERFRkxBVEUgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbmZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLCBudWxsIG9uIGVycm9yLlxuICovXG51dGlsLmluZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgLy8gVE9ETzogYWRkIHpsaWIgaGVhZGVyIGFuZCB0cmFpbGVyIGlmIG5lY2Vzc2FyeS9wb3NzaWJsZVxuICB2YXIgcnZhbCA9IGFwaS5pbmZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsO1xuICByZXR1cm4gKHJ2YWwgPT09IG51bGwpID8gbnVsbCA6IHV0aWwuZGVjb2RlNjQocnZhbCk7XG59O1xuXG4vKipcbiAqIFNldHMgYSBzdG9yYWdlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0gb2JqIHRoZSBzdG9yYWdlIG9iamVjdCwgbnVsbCB0byByZW1vdmUuXG4gKi9cbnZhciBfc2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQsIG9iaikge1xuICBpZighYXBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gIH1cblxuICB2YXIgcnZhbDtcbiAgaWYob2JqID09PSBudWxsKSB7XG4gICAgcnZhbCA9IGFwaS5yZW1vdmVJdGVtKGlkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBqc29uLWVuY29kZSBhbmQgYmFzZTY0LWVuY29kZSBvYmplY3RcbiAgICBvYmogPSB1dGlsLmVuY29kZTY0KEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIHJ2YWwgPSBhcGkuc2V0SXRlbShpZCwgb2JqKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBwb3RlbnRpYWwgZmxhc2ggZXJyb3JcbiAgaWYodHlwZW9mKHJ2YWwpICE9PSAndW5kZWZpbmVkJyAmJiBydmFsLnJ2YWwgIT09IHRydWUpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocnZhbC5lcnJvci5tZXNzYWdlKTtcbiAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgZXJyb3IubmFtZSA9IHJ2YWwuZXJyb3IubmFtZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIGEgc3RvcmFnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIHN0b3JhZ2Ugb2JqZWN0IGVudHJ5IG9yIG51bGwgaWYgbm9uZSBleGlzdHMuXG4gKi9cbnZhciBfZ2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQpIHtcbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBleGlzdGluZyBlbnRyeVxuICB2YXIgcnZhbCA9IGFwaS5nZXRJdGVtKGlkKTtcblxuICAvKiBOb3RlOiBXZSBjaGVjayBhcGkuaW5pdCBiZWNhdXNlIHdlIGNhbid0IGRvIChhcGkgPT0gbG9jYWxTdG9yYWdlKVxuICAgIG9uIElFIGJlY2F1c2Ugb2YgXCJDbGFzcyBkb2Vzbid0IHN1cHBvcnQgQXV0b21hdGlvblwiIGV4Y2VwdGlvbi4gT25seVxuICAgIHRoZSBmbGFzaCBhcGkgaGFzIGFuIGluaXQgbWV0aG9kIHNvIHRoaXMgd29ya3MgdG9vLCBidXQgd2UgbmVlZCBhXG4gICAgYmV0dGVyIHNvbHV0aW9uIGluIHRoZSBmdXR1cmUuICovXG5cbiAgLy8gZmxhc2ggcmV0dXJucyBpdGVtIHdyYXBwZWQgaW4gYW4gb2JqZWN0LCBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gIGlmKGFwaS5pbml0KSB7XG4gICAgaWYocnZhbC5ydmFsID09PSBudWxsKSB7XG4gICAgICBpZihydmFsLmVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihydmFsLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gbm8gZXJyb3IsIGJ1dCBhbHNvIG5vIGl0ZW1cbiAgICAgIHJ2YWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsID0gcnZhbC5ydmFsO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSBkZWNvZGluZ1xuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgLy8gYmFzZTY0LWRlY29kZSBhbmQganNvbi1kZWNvZGUgZGF0YVxuICAgIHJ2YWwgPSBKU09OLnBhcnNlKHV0aWwuZGVjb2RlNjQocnZhbCkpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFN0b3JlcyBhbiBpdGVtIGluIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKi9cbnZhciBfc2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgZGF0YSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogPT09IG51bGwpIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc3RvcmFnZSBvYmplY3RcbiAgICBvYmogPSB7fTtcbiAgfVxuICAvLyB1cGRhdGUga2V5XG4gIG9ialtrZXldID0gZGF0YTtcblxuICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgb2JqKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnZhciBfZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIHJ2YWwgPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIC8vIHJldHVybiBkYXRhIGF0IGtleVxuICAgIHJ2YWwgPSAoa2V5IGluIHJ2YWwpID8gcnZhbFtrZXldIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKi9cbnZhciBfcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogIT09IG51bGwgJiYga2V5IGluIG9iaikge1xuICAgIC8vIHJlbW92ZSBrZXlcbiAgICBkZWxldGUgb2JqW2tleV07XG5cbiAgICAvLyBzZWUgaWYgZW50cnkgaGFzIG5vIGtleXMgcmVtYWluaW5nXG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKGVtcHR5KSB7XG4gICAgICAvLyByZW1vdmUgZW50cnkgZW50aXJlbHkgaWYgbm8ga2V5cyBhcmUgbGVmdFxuICAgICAgb2JqID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqL1xudmFyIF9jbGVhckl0ZW1zID0gZnVuY3Rpb24oYXBpLCBpZCkge1xuICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBudWxsKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBzdG9yYWdlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBmdW5jIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICogQHBhcmFtIGFyZ3MgdGhlIGFyZ3VtZW50cyBmb3IgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIGxvY2F0aW9uIHRoZSBsb2NhdGlvbiBhcmd1bWVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXG4gKi9cbnZhciBfY2FsbFN0b3JhZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIGxvY2F0aW9uKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBkZWZhdWx0IHN0b3JhZ2UgdHlwZXNcbiAgaWYodHlwZW9mKGxvY2F0aW9uKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhdGlvbiA9IFsnd2ViJywgJ2ZsYXNoJ107XG4gIH1cblxuICAvLyBhcHBseSBzdG9yYWdlIHR5cGVzIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcbiAgdmFyIHR5cGU7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciBleGNlcHRpb24gPSBudWxsO1xuICBmb3IodmFyIGlkeCBpbiBsb2NhdGlvbikge1xuICAgIHR5cGUgPSBsb2NhdGlvbltpZHhdO1xuICAgIHRyeSB7XG4gICAgICBpZih0eXBlID09PSAnZmxhc2gnIHx8IHR5cGUgPT09ICdib3RoJykge1xuICAgICAgICBpZihhcmdzWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGFzaCBsb2NhbCBzdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSAodHlwZSA9PT0gJ2ZsYXNoJyk7XG4gICAgICB9XG4gICAgICBpZih0eXBlID09PSAnd2ViJyB8fCB0eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgYXJnc1swXSA9IGxvY2FsU3RvcmFnZTtcbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgIGV4Y2VwdGlvbiA9IGV4O1xuICAgIH1cbiAgICBpZihkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZighZG9uZSkge1xuICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTdG9yZXMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFRoZSBhdmFpbGFibGUgdHlwZXMgb2YgbG9jYWwgc3RvcmFnZSBpbmNsdWRlICdmbGFzaCcsICd3ZWInLCBhbmQgJ2JvdGgnLlxuICpcbiAqIFRoZSB0eXBlICdmbGFzaCcgcmVmZXJzIHRvIGZsYXNoIGxvY2FsIHN0b3JhZ2UgKFNoYXJlZE9iamVjdCkuIEluIG9yZGVyXG4gKiB0byB1c2UgZmxhc2ggbG9jYWwgc3RvcmFnZSwgdGhlICdhcGknIHBhcmFtZXRlciBtdXN0IGJlIHZhbGlkLiBUaGUgdHlwZVxuICogJ3dlYicgcmVmZXJzIHRvIFdlYlN0b3JhZ2UsIGlmIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci4gVGhlIHR5cGUgJ2JvdGgnXG4gKiByZWZlcnMgdG8gc3RvcmluZyB1c2luZyBib3RoICdmbGFzaCcgYW5kICd3ZWInLCBub3QganVzdCBvbmUgb3IgdGhlXG4gKiBvdGhlci5cbiAqXG4gKiBUaGUgbG9jYXRpb24gYXJyYXkgc2hvdWxkIGxpc3QgdGhlIHN0b3JhZ2UgdHlwZXMgdG8gdXNlIGluIG9yZGVyIG9mXG4gKiBwcmVmZXJlbmNlOlxuICpcbiAqIFsnZmxhc2gnXTogZmxhc2ggb25seSBzdG9yYWdlXG4gKiBbJ3dlYiddOiB3ZWIgb25seSBzdG9yYWdlXG4gKiBbJ2JvdGgnXTogdHJ5IHRvIHN0b3JlIGluIGJvdGhcbiAqIFsnZmxhc2gnLCd3ZWInXTogc3RvcmUgaW4gZmxhc2ggZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnd2ViJ1xuICogWyd3ZWInLCdmbGFzaCddOiBzdG9yZSBpbiB3ZWIgZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnZmxhc2gnXG4gKlxuICogVGhlIGxvY2F0aW9uIGFycmF5IGRlZmF1bHRzIHRvOiBbJ3dlYicsICdmbGFzaCddXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLCBudWxsIHRvIHVzZSBvbmx5IFdlYlN0b3JhZ2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLnNldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9zZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSwgbnVsbCB0byB1c2Ugb25seSBXZWJTdG9yYWdlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnV0aWwuZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9nZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5yZW1vdmVJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfcmVtb3ZlSXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UgaWYgZmxhc2ggaXMgYXZhaWxhYmxlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwuY2xlYXJJdGVtcyA9IGZ1bmN0aW9uKGFwaSwgaWQsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9jbGVhckl0ZW1zLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBzY2hlbWUsIGhvc3QsIGFuZCBwb3J0IGZyb20gYW4gaHR0cChzKSB1cmwuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgdXJsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgdXJsIG9iamVjdCBvciBudWxsIGlmIHRoZSB1cmwgaXMgaW52YWxpZC5cbiAqL1xudXRpbC5wYXJzZVVybCA9IGZ1bmN0aW9uKHN0cikge1xuICAvLyBGSVhNRTogdGhpcyByZWdleCBsb29rcyBhIGJpdCBicm9rZW5cbiAgdmFyIHJlZ2V4ID0gL14oaHR0cHM/KTpcXC9cXC8oW146Jl5cXC9dKik6PyhcXGQqKSguKikkL2c7XG4gIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gIHZhciBtID0gcmVnZXguZXhlYyhzdHIpO1xuICB2YXIgdXJsID0gKG0gPT09IG51bGwpID8gbnVsbCA6IHtcbiAgICBmdWxsOiBzdHIsXG4gICAgc2NoZW1lOiBtWzFdLFxuICAgIGhvc3Q6IG1bMl0sXG4gICAgcG9ydDogbVszXSxcbiAgICBwYXRoOiBtWzRdXG4gIH07XG4gIGlmKHVybCkge1xuICAgIHVybC5mdWxsSG9zdCA9IHVybC5ob3N0O1xuICAgIGlmKHVybC5wb3J0KSB7XG4gICAgICBpZih1cmwucG9ydCAhPT0gODAgJiYgdXJsLnNjaGVtZSA9PT0gJ2h0dHAnKSB7XG4gICAgICAgIHVybC5mdWxsSG9zdCArPSAnOicgKyB1cmwucG9ydDtcbiAgICAgIH0gZWxzZSBpZih1cmwucG9ydCAhPT0gNDQzICYmIHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgICAgdXJsLmZ1bGxIb3N0ICs9ICc6JyArIHVybC5wb3J0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih1cmwuc2NoZW1lID09PSAnaHR0cCcpIHtcbiAgICAgIHVybC5wb3J0ID0gODA7XG4gICAgfSBlbHNlIGlmKHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgIHVybC5wb3J0ID0gNDQzO1xuICAgIH1cbiAgICB1cmwuZnVsbCA9IHVybC5zY2hlbWUgKyAnOi8vJyArIHVybC5mdWxsSG9zdDtcbiAgfVxuICByZXR1cm4gdXJsO1xufTtcblxuLyogU3RvcmFnZSBmb3IgcXVlcnkgdmFyaWFibGVzICovXG52YXIgX3F1ZXJ5VmFyaWFibGVzID0gbnVsbDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB3aW5kb3cgbG9jYXRpb24gcXVlcnkgdmFyaWFibGVzLiBRdWVyeSBpcyBwYXJzZWQgb24gdGhlIGZpcnN0XG4gKiBjYWxsIGFuZCB0aGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgb24gc3Vic2VxdWVudCBjYWxscy4gVGhlIG1hcHBpbmdcbiAqIGlzIGZyb20ga2V5cyB0byBhbiBhcnJheSBvZiB2YWx1ZXMuIFBhcmFtZXRlcnMgd2l0aG91dCB2YWx1ZXMgd2lsbCBoYXZlXG4gKiBhbiBvYmplY3Qga2V5IHNldCBidXQgbm8gdmFsdWUgYWRkZWQgdG8gdGhlIHZhbHVlIGFycmF5LiBWYWx1ZXMgYXJlXG4gKiB1bmVzY2FwZWQuXG4gKlxuICogLi4uP2sxPXYxJmsyPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCJdLFxuICogICBcImsyXCI6IFtcInYyXCJdXG4gKiB9XG4gKlxuICogLi4uP2sxPXYxJmsxPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCIsIFwidjJcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazI6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl0sXG4gKiAgIFwiazJcIjogW11cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW11cbiAqIH1cbiAqXG4gKiBAcGFyYW0gcXVlcnkgdGhlIHF1ZXJ5IHN0cmluZyB0byBwYXJzZSAob3B0aW9uYWwsIGRlZmF1bHQgdG8gY2FjaGVkXG4gKiAgICAgICAgICByZXN1bHRzIGZyb20gcGFyc2luZyB3aW5kb3cgbG9jYXRpb24gc2VhcmNoIHF1ZXJ5KS5cbiAqXG4gKiBAcmV0dXJuIG9iamVjdCBtYXBwaW5nIGtleXMgdG8gdmFyaWFibGVzLlxuICovXG51dGlsLmdldFF1ZXJ5VmFyaWFibGVzID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24ocSkge1xuICAgIHZhciBydmFsID0ge307XG4gICAgdmFyIGt2cGFpcnMgPSBxLnNwbGl0KCcmJyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGt2cGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb3MgPSBrdnBhaXJzW2ldLmluZGV4T2YoJz0nKTtcbiAgICAgIHZhciBrZXk7XG4gICAgICB2YXIgdmFsO1xuICAgICAgaWYocG9zID4gMCkge1xuICAgICAgICBrZXkgPSBrdnBhaXJzW2ldLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICB2YWwgPSBrdnBhaXJzW2ldLnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGt2cGFpcnNbaV07XG4gICAgICAgIHZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZighKGtleSBpbiBydmFsKSkge1xuICAgICAgICBydmFsW2tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIC8vIGRpc2FsbG93IG92ZXJyaWRpbmcgb2JqZWN0IHByb3RvdHlwZSBrZXlzXG4gICAgICBpZighKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgcnZhbFtrZXldLnB1c2godW5lc2NhcGUodmFsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gICB2YXIgcnZhbDtcbiAgIGlmKHR5cGVvZihxdWVyeSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgIC8vIHNldCBjYWNoZWQgdmFyaWFibGVzIGlmIG5lZWRlZFxuICAgICBpZihfcXVlcnlWYXJpYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICBpZih0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgICAgICAvLyBwYXJzZSB3aW5kb3cgc2VhcmNoIHF1ZXJ5XG4gICAgICAgICAgX3F1ZXJ5VmFyaWFibGVzID0gcGFyc2Uod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gcXVlcnkgdmFyaWFibGVzIGF2YWlsYWJsZVxuICAgICAgICAgIF9xdWVyeVZhcmlhYmxlcyA9IHt9O1xuICAgICAgIH1cbiAgICAgfVxuICAgICBydmFsID0gX3F1ZXJ5VmFyaWFibGVzO1xuICAgfSBlbHNlIHtcbiAgICAgLy8gcGFyc2UgZ2l2ZW4gcXVlcnlcbiAgICAgcnZhbCA9IHBhcnNlKHF1ZXJ5KTtcbiAgIH1cbiAgIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBmcmFnbWVudCBpbnRvIGEgcGF0aCBhbmQgcXVlcnkuIFRoaXMgbWV0aG9kIHdpbGwgdGFrZSBhIFVSSVxuICogZnJhZ21lbnQgYW5kIGJyZWFrIGl0IHVwIGFzIGlmIGl0IHdlcmUgdGhlIG1haW4gVVJJLiBGb3IgZXhhbXBsZTpcbiAqICAgIC9iYXIvYmF6P2E9MSZiPTJcbiAqIHJlc3VsdHMgaW46XG4gKiAgICB7XG4gKiAgICAgICBwYXRoOiBbXCJiYXJcIiwgXCJiYXpcIl0sXG4gKiAgICAgICBxdWVyeToge1wiazFcIjogW1widjFcIl0sIFwiazJcIjogW1widjJcIl19XG4gKiAgICB9XG4gKlxuICogQHJldHVybiBvYmplY3Qgd2l0aCBhIHBhdGggYXJyYXkgYW5kIHF1ZXJ5IG9iamVjdC5cbiAqL1xudXRpbC5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgLy8gZGVmYXVsdCB0byB3aG9sZSBmcmFnbWVudFxuICB2YXIgZnAgPSBmcmFnbWVudDtcbiAgdmFyIGZxID0gJyc7XG4gIC8vIHNwbGl0IGludG8gcGF0aCBhbmQgcXVlcnkgaWYgcG9zc2libGUgYXQgdGhlIGZpcnN0ICc/J1xuICB2YXIgcG9zID0gZnJhZ21lbnQuaW5kZXhPZignPycpO1xuICBpZihwb3MgPiAwKSB7XG4gICAgZnAgPSBmcmFnbWVudC5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICBmcSA9IGZyYWdtZW50LnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgfVxuICAvLyBzcGxpdCBwYXRoIGJhc2VkIG9uICcvJyBhbmQgaWdub3JlIGZpcnN0IGVsZW1lbnQgaWYgZW1wdHlcbiAgdmFyIHBhdGggPSBmcC5zcGxpdCgnLycpO1xuICBpZihwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aFswXSA9PT0gJycpIHtcbiAgICBwYXRoLnNoaWZ0KCk7XG4gIH1cbiAgLy8gY29udmVydCBxdWVyeSBpbnRvIG9iamVjdFxuICB2YXIgcXVlcnkgPSAoZnEgPT09ICcnKSA/IHt9IDogdXRpbC5nZXRRdWVyeVZhcmlhYmxlcyhmcSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoU3RyaW5nOiBmcCxcbiAgICBxdWVyeVN0cmluZzogZnEsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnlcbiAgfTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSByZXF1ZXN0IG91dCBvZiBhIFVSSS1saWtlIHJlcXVlc3Qgc3RyaW5nLiBUaGlzIGlzIGludGVuZGVkIHRvXG4gKiBiZSB1c2VkIHdoZXJlIGEgZnJhZ21lbnQgaWQgKGFmdGVyIGEgVVJJICcjJykgaXMgcGFyc2VkIGFzIGEgVVJJIHdpdGhcbiAqIHBhdGggYW5kIHF1ZXJ5IHBhcnRzLiBUaGUgc3RyaW5nIHNob3VsZCBoYXZlIGEgcGF0aCBiZWdpbm5pbmcgYW5kXG4gKiBkZWxpbWl0ZWQgYnkgJy8nIGFuZCBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzIGZvbGxvd2luZyBhICc/Jy4gVGhlXG4gKiBxdWVyeSBzaG91bGQgYmUgYSBzdGFuZGFyZCBVUkwgc2V0IG9mIGtleSB2YWx1ZSBwYWlycyBkZWxpbWl0ZWQgYnlcbiAqICcmJy4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRoZSBpbml0aWFsICcvJyBvbiB0aGUgcGF0aCBpcyBub3RcbiAqIHJlcXVpcmVkLiBUaGUgcmVxdWVzdCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgQVBJLCAoZnVsbHkgZGVzY3JpYmVkXG4gKiBpbiB0aGUgbWV0aG9kIGNvZGUpOlxuICogICAge1xuICogICAgICAgcGF0aDogPHRoZSBwYXRoIHN0cmluZyBwYXJ0Pi5cbiAqICAgICAgIHF1ZXJ5OiA8dGhlIHF1ZXJ5IHN0cmluZyBwYXJ0PixcbiAqICAgICAgIGdldFBhdGgoaSk6IGdldCBwYXJ0IG9yIGFsbCBvZiB0aGUgc3BsaXQgcGF0aCBhcnJheSxcbiAqICAgICAgIGdldFF1ZXJ5KGssIGkpOiBnZXQgcGFydCBvciBhbGwgb2YgYSBxdWVyeSBrZXkgYXJyYXksXG4gKiAgICAgICBnZXRRdWVyeUxhc3QoaywgX2RlZmF1bHQpOiBnZXQgbGFzdCBlbGVtZW50IG9mIGEgcXVlcnkga2V5IGFycmF5LlxuICogICAgfVxuICpcbiAqIEByZXR1cm4gb2JqZWN0IHdpdGggcmVxdWVzdCBwYXJhbWV0ZXJzLlxuICovXG51dGlsLm1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxU3RyaW5nKSB7XG4gIHZhciBmcmFnID0gdXRpbC5wYXJzZUZyYWdtZW50KHJlcVN0cmluZyk7XG4gIHZhciByZXEgPSB7XG4gICAgLy8gZnVsbCBwYXRoIHN0cmluZ1xuICAgIHBhdGg6IGZyYWcucGF0aFN0cmluZyxcbiAgICAvLyBmdWxsIHF1ZXJ5IHN0cmluZ1xuICAgIHF1ZXJ5OiBmcmFnLnF1ZXJ5U3RyaW5nLFxuICAgIC8qKlxuICAgICAqIEdldCBwYXRoIG9yIGVsZW1lbnQgaW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHBhdGggaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHBhdGggb3IgcGFydCBvZiBwYXRoIGlmIGkgcHJvdmlkZWQuXG4gICAgICovXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuICh0eXBlb2YoaSkgPT09ICd1bmRlZmluZWQnKSA/IGZyYWcucGF0aCA6IGZyYWcucGF0aFtpXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBxdWVyeSwgdmFsdWVzIGZvciBhIGtleSwgb3IgdmFsdWUgZm9yIGEga2V5IGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGsgb3B0aW9uYWwgcXVlcnkga2V5LlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHF1ZXJ5IGtleSBpbmRleC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gcXVlcnksIHZhbHVlcyBmb3IgYSBrZXksIG9yIHZhbHVlIGZvciBhIGtleSBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRRdWVyeTogZnVuY3Rpb24oaywgaSkge1xuICAgICAgdmFyIHJ2YWw7XG4gICAgICBpZih0eXBlb2YoaykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJ2YWwgPSBmcmFnLnF1ZXJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IGZyYWcucXVlcnlba107XG4gICAgICAgIGlmKHJ2YWwgJiYgdHlwZW9mKGkpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICBydmFsID0gcnZhbFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcbiAgICBnZXRRdWVyeUxhc3Q6IGZ1bmN0aW9uKGssIF9kZWZhdWx0KSB7XG4gICAgICB2YXIgcnZhbDtcbiAgICAgIHZhciB2YWxzID0gcmVxLmdldFF1ZXJ5KGspO1xuICAgICAgaWYodmFscykge1xuICAgICAgICBydmFsID0gdmFsc1t2YWxzLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IF9kZWZhdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIFVSSSBvdXQgb2YgYSBwYXRoLCBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzLCBhbmQgYVxuICogZnJhZ21lbnQuIFVzZXMgalF1ZXJ5LnBhcmFtKCkgaW50ZXJuYWxseSBmb3IgcXVlcnkgc3RyaW5nIGNyZWF0aW9uLlxuICogSWYgdGhlIHBhdGggaXMgYW4gYXJyYXksIGl0IHdpbGwgYmUgam9pbmVkIHdpdGggJy8nLlxuICpcbiAqIEBwYXJhbSBwYXRoIHN0cmluZyBwYXRoIG9yIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gcXVlcnkgb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycy4gKG9wdGlvbmFsKVxuICogQHBhcmFtIGZyYWdtZW50IGZyYWdtZW50IHN0cmluZy4gKG9wdGlvbmFsKVxuICpcbiAqIEByZXR1cm4gc3RyaW5nIG9iamVjdCB3aXRoIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAqL1xudXRpbC5tYWtlTGluayA9IGZ1bmN0aW9uKHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCkge1xuICAvLyBqb2luIHBhdGggcGFydHMgaWYgbmVlZGVkXG4gIHBhdGggPSBqUXVlcnkuaXNBcnJheShwYXRoKSA/IHBhdGguam9pbignLycpIDogcGF0aDtcblxuICB2YXIgcXN0ciA9IGpRdWVyeS5wYXJhbShxdWVyeSB8fCB7fSk7XG4gIGZyYWdtZW50ID0gZnJhZ21lbnQgfHwgJyc7XG4gIHJldHVybiBwYXRoICtcbiAgICAoKHFzdHIubGVuZ3RoID4gMCkgPyAoJz8nICsgcXN0cikgOiAnJykgK1xuICAgICgoZnJhZ21lbnQubGVuZ3RoID4gMCkgPyAoJyMnICsgZnJhZ21lbnQpIDogJycpO1xufTtcblxuLyoqXG4gKiBGb2xsb3dzIGEgcGF0aCBvZiBrZXlzIGRlZXAgaW50byBhbiBvYmplY3QgaGllcmFyY2h5IGFuZCBzZXQgYSB2YWx1ZS5cbiAqIElmIGEga2V5IGRvZXMgbm90IGV4aXN0IG9yIGl0J3MgdmFsdWUgaXMgbm90IGFuIG9iamVjdCwgY3JlYXRlIGFuXG4gKiBvYmplY3QgaW4gaXQncyBwbGFjZS4gVGhpcyBjYW4gYmUgZGVzdHJ1Y3RpdmUgdG8gYSBvYmplY3QgdHJlZSBpZlxuICogbGVhZiBub2RlcyBhcmUgZ2l2ZW4gYXMgbm9uLWZpbmFsIHBhdGgga2V5cy5cbiAqIFVzZWQgdG8gYXZvaWQgZXhjZXB0aW9ucyBmcm9tIG1pc3NpbmcgcGFydHMgb2YgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtIG9iamVjdCB0aGUgc3RhcnRpbmcgb2JqZWN0LlxuICogQHBhcmFtIGtleXMgYW4gYXJyYXkgb2Ygc3RyaW5nIGtleXMuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHNldC5cbiAqL1xudXRpbC5zZXRQYXRoID0gZnVuY3Rpb24ob2JqZWN0LCBrZXlzLCB2YWx1ZSkge1xuICAvLyBuZWVkIHRvIHN0YXJ0IGF0IGFuIG9iamVjdFxuICBpZih0eXBlb2Yob2JqZWN0KSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICB2YXIgbmV4dCA9IGtleXNbaSsrXTtcbiAgICAgIGlmKGkgPT0gbGVuKSB7XG4gICAgICAgIC8vIGxhc3RcbiAgICAgICAgb2JqZWN0W25leHRdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3JlXG4gICAgICAgIHZhciBoYXNOZXh0ID0gKG5leHQgaW4gb2JqZWN0KTtcbiAgICAgICAgaWYoIWhhc05leHQgfHxcbiAgICAgICAgICAoaGFzTmV4dCAmJiB0eXBlb2Yob2JqZWN0W25leHRdKSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgKGhhc05leHQgJiYgb2JqZWN0W25leHRdID09PSBudWxsKSkge1xuICAgICAgICAgIG9iamVjdFtuZXh0XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtuZXh0XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9sbG93cyBhIHBhdGggb2Yga2V5cyBkZWVwIGludG8gYW4gb2JqZWN0IGhpZXJhcmNoeSBhbmQgcmV0dXJuIGEgdmFsdWUuXG4gKiBJZiBhIGtleSBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGFuIG9iamVjdCBpbiBpdCdzIHBsYWNlLlxuICogVXNlZCB0byBhdm9pZCBleGNlcHRpb25zIGZyb20gbWlzc2luZyBwYXJ0cyBvZiB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBzdGFydGluZyBvYmplY3QuXG4gKiBAcGFyYW0ga2V5cyBhbiBhcnJheSBvZiBzdHJpbmcga2V5cy5cbiAqIEBwYXJhbSBfZGVmYXVsdCB2YWx1ZSB0byByZXR1cm4gaWYgcGF0aCBub3QgZm91bmQuXG4gKlxuICogQHJldHVybiB0aGUgdmFsdWUgYXQgdGhlIHBhdGggaWYgZm91bmQsIGVsc2UgZGVmYXVsdCBpZiBnaXZlbiwgZWxzZVxuICogICAgICAgICB1bmRlZmluZWQuXG4gKi9cbnV0aWwuZ2V0UGF0aCA9IGZ1bmN0aW9uKG9iamVjdCwga2V5cywgX2RlZmF1bHQpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHZhciBoYXNOZXh0ID0gdHJ1ZTtcbiAgd2hpbGUoaGFzTmV4dCAmJiBpIDwgbGVuICYmXG4gICAgdHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0ID0ga2V5c1tpKytdO1xuICAgIGhhc05leHQgPSBuZXh0IGluIG9iamVjdDtcbiAgICBpZihoYXNOZXh0KSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbbmV4dF07XG4gICAgfVxuICB9XG4gIHJldHVybiAoaGFzTmV4dCA/IG9iamVjdCA6IF9kZWZhdWx0KTtcbn07XG5cbi8qKlxuICogRm9sbG93IGEgcGF0aCBvZiBrZXlzIGRlZXAgaW50byBhbiBvYmplY3QgaGllcmFyY2h5IGFuZCBkZWxldGUgdGhlXG4gKiBsYXN0IG9uZS4gSWYgYSBrZXkgZG9lcyBub3QgZXhpc3QsIGRvIG5vdGhpbmcuXG4gKiBVc2VkIHRvIGF2b2lkIGV4Y2VwdGlvbnMgZnJvbSBtaXNzaW5nIHBhcnRzIG9mIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgdGhlIHN0YXJ0aW5nIG9iamVjdC5cbiAqIEBwYXJhbSBrZXlzIGFuIGFycmF5IG9mIHN0cmluZyBrZXlzLlxuICovXG51dGlsLmRlbGV0ZVBhdGggPSBmdW5jdGlvbihvYmplY3QsIGtleXMpIHtcbiAgLy8gbmVlZCB0byBzdGFydCBhdCBhbiBvYmplY3RcbiAgaWYodHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgdmFyIG5leHQgPSBrZXlzW2krK107XG4gICAgICBpZihpID09IGxlbikge1xuICAgICAgICAvLyBsYXN0XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbmV4dF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3JlXG4gICAgICAgIGlmKCEobmV4dCBpbiBvYmplY3QpIHx8XG4gICAgICAgICAgKHR5cGVvZihvYmplY3RbbmV4dF0pICE9PSAnb2JqZWN0JykgfHxcbiAgICAgICAgICAob2JqZWN0W25leHRdID09PSBudWxsKSkge1xuICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3RbbmV4dF07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBlbXB0eS5cbiAqXG4gKiBUYWtlbiBmcm9tOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QtZnJvbS1qc29uLzY3OTkzNyM2Nzk5MzdcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY2hlY2suXG4gKi9cbnV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgd2l0aCBzaW1wbGUgcHJpbnRmLXN0eWxlIGludGVycG9sYXRpb24uXG4gKlxuICogJSU6IGxpdGVyYWwgJyUnXG4gKiAlcywlbzogY29udmVydCBuZXh0IGFyZ3VtZW50IGludG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGZvcm1hdCB0aGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSAuLi4gYXJndW1lbnRzIHRvIGludGVycG9sYXRlIGludG8gdGhlIGZvcm1hdCBzdHJpbmcuXG4gKi9cbnV0aWwuZm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gIHZhciByZSA9IC8lLi9nO1xuICAvLyBjdXJyZW50IG1hdGNoXG4gIHZhciBtYXRjaDtcbiAgLy8gY3VycmVudCBwYXJ0XG4gIHZhciBwYXJ0O1xuICAvLyBjdXJyZW50IGFyZyBpbmRleFxuICB2YXIgYXJnaSA9IDA7XG4gIC8vIGNvbGxlY3RlZCBwYXJ0cyB0byByZWNvbWJpbmUgbGF0ZXJcbiAgdmFyIHBhcnRzID0gW107XG4gIC8vIGxhc3QgaW5kZXggZm91bmRcbiAgdmFyIGxhc3QgPSAwO1xuICAvLyBsb29wIHdoaWxlIG1hdGNoZXMgcmVtYWluXG4gIHdoaWxlKChtYXRjaCA9IHJlLmV4ZWMoZm9ybWF0KSkpIHtcbiAgICBwYXJ0ID0gZm9ybWF0LnN1YnN0cmluZyhsYXN0LCByZS5sYXN0SW5kZXggLSAyKTtcbiAgICAvLyBkb24ndCBhZGQgZW1wdHkgc3RyaW5ncyAoaWUsIHBhcnRzIGJldHdlZW4gJXMlcylcbiAgICBpZihwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGxhc3QgPSByZS5sYXN0SW5kZXg7XG4gICAgLy8gc3dpdGNoIG9uICUgY29kZVxuICAgIHZhciBjb2RlID0gbWF0Y2hbMF1bMV07XG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICBjYXNlICdzJzpcbiAgICBjYXNlICdvJzpcbiAgICAgIC8vIGNoZWNrIGlmIGVub3VnaCBhcmd1bWVudHMgd2VyZSBnaXZlblxuICAgICAgaWYoYXJnaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChhcmd1bWVudHNbYXJnaSsrICsgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaCgnPD8+Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBGSVhNRTogZG8gcHJvcGVyIGZvcm1hdGluZyBmb3IgbnVtYmVycywgZXRjXG4gICAgLy9jYXNlICdmJzpcbiAgICAvL2Nhc2UgJ2QnOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcGFydHMucHVzaCgnJScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhcnRzLnB1c2goJzwlJyArIGNvZGUgKyAnPz4nKTtcbiAgICB9XG4gIH1cbiAgLy8gYWRkIHRyYWlsaW5nIHBhcnQgb2YgZm9ybWF0IHN0cmluZ1xuICBwYXJ0cy5wdXNoKGZvcm1hdC5zdWJzdHJpbmcobGFzdCkpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0NS9qYXZhc2NyaXB0LW51bWJlcmZvcm1hdC0tcG9ydGVkLWZyb20tcGhwL1xuICovXG51dGlsLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCkge1xuICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vY3Jlc3RpZGcuY29tKVxuICAvLyArICAgICBidWdmaXggYnk6IEJlbmphbWluIEx1cHRvblxuICAvLyArICAgICBidWdmaXggYnk6IEFsbGFuIEplbnNlbiAoaHR0cDovL3d3dy53aW50ZXJuZXQubm8pXG4gIC8vICsgICAgcmV2aXNlZCBieTogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuICAvLyAqICAgICBleGFtcGxlIDE6IG51bWJlcl9mb3JtYXQoMTIzNC41Njc4LCAyLCAnLicsICcnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjM0LjU3XG5cbiAgdmFyIG4gPSBudW1iZXIsIGMgPSBpc05hTihkZWNpbWFscyA9IE1hdGguYWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHM7XG4gIHZhciBkID0gZGVjX3BvaW50ID09PSB1bmRlZmluZWQgPyAnLCcgOiBkZWNfcG9pbnQ7XG4gIHZhciB0ID0gdGhvdXNhbmRzX3NlcCA9PT0gdW5kZWZpbmVkID9cbiAgICcuJyA6IHRob3VzYW5kc19zZXAsIHMgPSBuIDwgMCA/ICctJyA6ICcnO1xuICB2YXIgaSA9IHBhcnNlSW50KChuID0gTWF0aC5hYnMoK24gfHwgMCkudG9GaXhlZChjKSksIDEwKSArICcnO1xuICB2YXIgaiA9IChpLmxlbmd0aCA+IDMpID8gaS5sZW5ndGggJSAzIDogMDtcbiAgcmV0dXJuIHMgKyAoaiA/IGkuc3Vic3RyKDAsIGopICsgdCA6ICcnKSArXG4gICAgaS5zdWJzdHIoaikucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csICckMScgKyB0KSArXG4gICAgKGMgPyBkICsgTWF0aC5hYnMobiAtIGkpLnRvRml4ZWQoYykuc2xpY2UoMikgOiAnJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBieXRlIHNpemUuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0OS9mb3JtYXQtaHVtYW5pemUtZmlsZS1ieXRlLXNpemUtcHJlc2VudGF0aW9uLWluLWphdmFzY3JpcHQvXG4gKi9cbnV0aWwuZm9ybWF0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYoc2l6ZSA+PSAxMDczNzQxODI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDczNzQxODI0LCAyLCAnLicsICcnKSArICcgR2lCJztcbiAgfSBlbHNlIGlmKHNpemUgPj0gMTA0ODU3Nikge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA0ODU3NiwgMiwgJy4nLCAnJykgKyAnIE1pQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwMjQpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwMjQsIDApICsgJyBLaUInO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplLCAwKSArICcgYnl0ZXMnO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IG9yIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBvciBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSA0LWJ5dGUgSVB2NiBvciAxNi1ieXRlIElQdjYgYWRkcmVzcyBvciBudWxsIGlmIHRoZSBhZGRyZXNzIGNhbid0XG4gKiAgICAgICAgIGJlIHBhcnNlZC5cbiAqL1xudXRpbC5ieXRlc0Zyb21JUCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlmKGlwLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc0Zyb21JUHY0KGlwKTtcbiAgfVxuICBpZihpcC5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NihpcCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlwID0gaXAuc3BsaXQoJy4nKTtcbiAgaWYoaXAubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaXAubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbnVtID0gcGFyc2VJbnQoaXBbaV0sIDEwKTtcbiAgICBpZihpc05hTihudW0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYi5wdXRCeXRlKG51bSk7XG4gIH1cbiAgcmV0dXJuIGIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW50byBieXRlcyAoaW4gbmV0d29yayBvcmRlcikuXG4gKlxuICogQHBhcmFtIGlwIHRoZSBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSAxNi1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NiA9IGZ1bmN0aW9uKGlwKSB7XG4gIHZhciBibGFua3MgPSAwO1xuICBpcCA9IGlwLnNwbGl0KCc6JykuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICBpZihlLmxlbmd0aCA9PT0gMCkgKytibGFua3M7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICB2YXIgemVyb3MgPSAoOCAtIGlwLmxlbmd0aCArIGJsYW5rcykgKiAyO1xuICB2YXIgYiA9IHV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICBpZighaXBbaV0gfHwgaXBbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBiLmZpbGxXaXRoQnl0ZSgwLCB6ZXJvcyk7XG4gICAgICB6ZXJvcyA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGJ5dGVzID0gdXRpbC5oZXhUb0J5dGVzKGlwW2ldKTtcbiAgICBpZihieXRlcy5sZW5ndGggPCAyKSB7XG4gICAgICBiLnB1dEJ5dGUoMCk7XG4gICAgfVxuICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciAxNi1ieXRlcyBpbnRvXG4gKiBhbiBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmUgaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiA0IG9yIDE2IGJ5dGVzLFxuICogICAgICAgICByZXNwZWN0aXZlbHksIGFyZSBnaXZlbiwgb3RoZXJ3aXNlIG51bGwuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYoYnl0ZXMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjQoYnl0ZXMpO1xuICB9XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gMTYpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc1RvSVB2NihieXRlcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpcCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpcC5wdXNoKGJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICB9XG4gIHJldHVybiBpcC5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDE2LWJ5dGVzIGludG8gYW4gSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZXMgbXVzdCBiZVxuICogaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NiA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgdmFyIHplcm9Hcm91cHMgPSBbXTtcbiAgdmFyIHplcm9NYXhHcm91cCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBoZXggPSB1dGlsLmJ5dGVzVG9IZXgoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0pO1xuICAgIC8vIGNhbm9uaWNhbGl6ZSB6ZXJvIHJlcHJlc2VudGF0aW9uXG4gICAgd2hpbGUoaGV4WzBdID09PSAnMCcgJiYgaGV4ICE9PSAnMCcpIHtcbiAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGlmKGhleCA9PT0gJzAnKSB7XG4gICAgICB2YXIgbGFzdCA9IHplcm9Hcm91cHNbemVyb0dyb3Vwcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBpZHggPSBpcC5sZW5ndGg7XG4gICAgICBpZighbGFzdCB8fCBpZHggIT09IGxhc3QuZW5kICsgMSkge1xuICAgICAgICB6ZXJvR3JvdXBzLnB1c2goe3N0YXJ0OiBpZHgsIGVuZDogaWR4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0LmVuZCA9IGlkeDtcbiAgICAgICAgaWYoKGxhc3QuZW5kIC0gbGFzdC5zdGFydCkgPlxuICAgICAgICAgICh6ZXJvR3JvdXBzW3plcm9NYXhHcm91cF0uZW5kIC0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLnN0YXJ0KSkge1xuICAgICAgICAgIHplcm9NYXhHcm91cCA9IHplcm9Hcm91cHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpcC5wdXNoKGhleCk7XG4gIH1cbiAgaWYoemVyb0dyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGdyb3VwID0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdO1xuICAgIC8vIG9ubHkgc2hvcnRlbiBncm91cCBvZiBsZW5ndGggPiAwXG4gICAgaWYoZ3JvdXAuZW5kIC0gZ3JvdXAuc3RhcnQgPiAwKSB7XG4gICAgICBpcC5zcGxpY2UoZ3JvdXAuc3RhcnQsIGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ICsgMSwgJycpO1xuICAgICAgaWYoZ3JvdXAuc3RhcnQgPT09IDApIHtcbiAgICAgICAgaXAudW5zaGlmdCgnJyk7XG4gICAgICB9XG4gICAgICBpZihncm91cC5lbmQgPT09IDcpIHtcbiAgICAgICAgaXAucHVzaCgnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpcC5qb2luKCc6Jyk7XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHByb2Nlc3NlcyB0aGF0IGNhbiBiZSBydW4gY29uY3VycmVudGx5LiBJZlxuICogY3JlYXRpbmcgV2ViIFdvcmtlcnMsIGtlZXAgaW4gbWluZCB0aGF0IHRoZSBtYWluIEphdmFTY3JpcHQgcHJvY2VzcyBuZWVkc1xuICogaXRzIG93biBjb3JlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIHVwZGF0ZSB0cnVlIHRvIGZvcmNlIGFuIHVwZGF0ZSAobm90IHVzZSB0aGUgY2FjaGVkIHZhbHVlKS5cbiAqIEBwYXJhbSBjYWxsYmFjayhlcnIsIG1heCkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnV0aWwuZXN0aW1hdGVDb3JlcyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoJ2NvcmVzJyBpbiB1dGlsICYmICFvcHRpb25zLnVwZGF0ZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICdoYXJkd2FyZUNvbmN1cnJlbmN5JyBpbiBuYXZpZ2F0b3IgJiZcbiAgICBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSA+IDApIHtcbiAgICB1dGlsLmNvcmVzID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gd29ya2VycyBub3QgYXZhaWxhYmxlXG4gICAgdXRpbC5jb3JlcyA9IDE7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNhbid0IGVzdGltYXRlLCBkZWZhdWx0IHRvIDJcbiAgICB1dGlsLmNvcmVzID0gMjtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cblxuICAvLyBjcmVhdGUgd29ya2VyIGNvbmN1cnJlbmN5IGVzdGltYXRpb24gY29kZSBhcyBibG9iXG4gIHZhciBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnLFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBydW4gd29ya2VyIGZvciA0IG1zXG4gICAgICAgIHZhciBzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBldCA9IHN0ICsgNDtcbiAgICAgICAgd2hpbGUoRGF0ZS5ub3coKSA8IGV0KTtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7c3Q6IHN0LCBldDogZXR9KTtcbiAgICAgIH0pO1xuICAgIH0udG9TdHJpbmcoKSxcbiAgJykoKSddLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSkpO1xuXG4gIC8vIHRha2UgNSBzYW1wbGVzIHVzaW5nIDE2IHdvcmtlcnNcbiAgc2FtcGxlKFtdLCA1LCAxNik7XG5cbiAgZnVuY3Rpb24gc2FtcGxlKG1heCwgc2FtcGxlcywgbnVtV29ya2Vycykge1xuICAgIGlmKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIGdldCBvdmVybGFwIGF2ZXJhZ2VcbiAgICAgIHZhciBhdmcgPSBNYXRoLmZsb29yKG1heC5yZWR1Y2UoZnVuY3Rpb24oYXZnLCB4KSB7XG4gICAgICAgIHJldHVybiBhdmcgKyB4O1xuICAgICAgfSwgMCkgLyBtYXgubGVuZ3RoKTtcbiAgICAgIHV0aWwuY29yZXMgPSBNYXRoLm1heCgxLCBhdmcpO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgICB9XG4gICAgbWFwKG51bVdvcmtlcnMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgbWF4LnB1c2gocmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpKTtcbiAgICAgIHNhbXBsZShtYXgsIHNhbXBsZXMgLSAxLCBudW1Xb3JrZXJzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcChudW1Xb3JrZXJzLCBjYWxsYmFjaykge1xuICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZS5kYXRhKTtcbiAgICAgICAgaWYocmVzdWx0cy5sZW5ndGggPT09IG51bVdvcmtlcnMpIHtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgICB3b3JrZXJzW2ldLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3b3JrZXJzLnB1c2god29ya2VyKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5wb3N0TWVzc2FnZShpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWR1Y2UobnVtV29ya2VycywgcmVzdWx0cykge1xuICAgIC8vIGZpbmQgb3ZlcmxhcHBpbmcgdGltZSB3aW5kb3dzXG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IG51bVdvcmtlcnM7ICsrbikge1xuICAgICAgdmFyIHIxID0gcmVzdWx0c1tuXTtcbiAgICAgIHZhciBvdmVybGFwID0gb3ZlcmxhcHNbbl0gPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgICAgaWYobiA9PT0gaSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByMiA9IHJlc3VsdHNbaV07XG4gICAgICAgIGlmKChyMS5zdCA+IHIyLnN0ICYmIHIxLnN0IDwgcjIuZXQpIHx8XG4gICAgICAgICAgKHIyLnN0ID4gcjEuc3QgJiYgcjIuc3QgPCByMS5ldCkpIHtcbiAgICAgICAgICBvdmVybGFwLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZ2V0IG1heGltdW0gb3ZlcmxhcHMgLi4uIGRvbid0IGluY2x1ZGUgb3ZlcmxhcHBpbmcgd29ya2VyIGl0c2VsZlxuICAgIC8vIGFzIHRoZSBtYWluIEpTIHByb2Nlc3Mgd2FzIGFsc28gYmVpbmcgc2NoZWR1bGVkIGR1cmluZyB0aGUgd29yayBhbmRcbiAgICAvLyB3b3VsZCBoYXZlIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgZXN0aW1hdGUgYW55d2F5XG4gICAgcmV0dXJuIG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbihtYXgsIG92ZXJsYXApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIG92ZXJsYXAubGVuZ3RoKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBOdW1iZXIgT25lLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBbiBBUEkgZm9yIHN0b3JpbmcgZGF0YSB1c2luZyB0aGUgQWJzdHJhY3QgU3ludGF4IE5vdGF0aW9uIE51bWJlciBPbmVcbiAqIGZvcm1hdCB1c2luZyBERVIgKERpc3Rpbmd1aXNoZWQgRW5jb2RpbmcgUnVsZXMpIGVuY29kaW5nLiBUaGlzIGVuY29kaW5nIGlzXG4gKiBjb21tb25seSB1c2VkIHRvIHN0b3JlIGRhdGEgZm9yIFBLSSwgaS5lLiBYLjUwOSBDZXJ0aWZpY2F0ZXMsIGFuZCB0aGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBleGlzdHMgZm9yIHRoYXQgcHVycG9zZS5cbiAqXG4gKiBBYnN0cmFjdCBTeW50YXggTm90YXRpb24gTnVtYmVyIE9uZSAoQVNOLjEpIGlzIHVzZWQgdG8gZGVmaW5lIHRoZSBhYnN0cmFjdFxuICogc3ludGF4IG9mIGluZm9ybWF0aW9uIHdpdGhvdXQgcmVzdHJpY3RpbmcgdGhlIHdheSB0aGUgaW5mb3JtYXRpb24gaXMgZW5jb2RlZFxuICogZm9yIHRyYW5zbWlzc2lvbi4gSXQgcHJvdmlkZXMgYSBzdGFuZGFyZCB0aGF0IGFsbG93cyBmb3Igb3BlbiBzeXN0ZW1zXG4gKiBjb21tdW5pY2F0aW9uLiBBU04uMSBkZWZpbmVzIHRoZSBzeW50YXggb2YgaW5mb3JtYXRpb24gZGF0YSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNpbXBsZSBkYXRhIHR5cGVzIGFzIHdlbGwgYXMgYSBub3RhdGlvbiBmb3IgZGVzY3JpYmluZyB0aGVtIGFuZCBzcGVjaWZ5aW5nXG4gKiB2YWx1ZXMgZm9yIHRoZW0uXG4gKlxuICogVGhlIFJTQSBhbGdvcml0aG0gY3JlYXRlcyBwdWJsaWMgYW5kIHByaXZhdGUga2V5cyB0aGF0IGFyZSBvZnRlbiBzdG9yZWQgaW5cbiAqIFguNTA5IG9yIFBLQ1MjWCBmb3JtYXRzIC0tIHdoaWNoIHVzZSBBU04uMSAoZW5jb2RlZCBpbiBERVIgZm9ybWF0KS4gVGhpc1xuICogY2xhc3MgcHJvdmlkZXMgdGhlIG1vc3QgYmFzaWMgZnVuY3Rpb25hbGl0eSByZXF1aXJlZCB0byBzdG9yZSBhbmQgbG9hZCBEU0FcbiAqIGtleXMgdGhhdCBhcmUgZW5jb2RlZCBhY2NvcmRpbmcgdG8gQVNOLjEuXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIGJpbmFyeSBlbmNvZGluZ3MgZm9yIEFTTi4xIGFyZSBCRVIgKEJhc2ljIEVuY29kaW5nIFJ1bGVzKVxuICogYW5kIERFUiAoRGlzdGluZ3Vpc2hlZCBFbmNvZGluZyBSdWxlcykuIERFUiBpcyBqdXN0IGEgc3Vic2V0IG9mIEJFUiB0aGF0XG4gKiBoYXMgc3RyaWN0ZXIgcmVxdWlyZW1lbnRzIGZvciBob3cgZGF0YSBtdXN0IGJlIGVuY29kZWQuXG4gKlxuICogRWFjaCBBU04uMSBzdHJ1Y3R1cmUgaGFzIGEgdGFnIChhIGJ5dGUgaWRlbnRpZnlpbmcgdGhlIEFTTi4xIHN0cnVjdHVyZSB0eXBlKVxuICogYW5kIGEgYnl0ZSBhcnJheSBmb3IgdGhlIHZhbHVlIG9mIHRoaXMgQVNOMSBzdHJ1Y3R1cmUgd2hpY2ggbWF5IGJlIGRhdGEgb3IgYVxuICogbGlzdCBvZiBBU04uMSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEVhY2ggQVNOLjEgc3RydWN0dXJlIHVzaW5nIEJFUiBpcyAoVGFnLUxlbmd0aC1WYWx1ZSk6XG4gKlxuICogfCBieXRlIDAgfCBieXRlcyBYIHwgYnl0ZXMgWSB8XG4gKiB8LS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS1cbiAqIHwgIHRhZyAgIHwgbGVuZ3RoICB8ICB2YWx1ZSAgfFxuICpcbiAqIEFTTi4xIGFsbG93cyBmb3IgdGFncyB0byBiZSBvZiBcIkhpZ2gtdGFnLW51bWJlciBmb3JtXCIgd2hpY2ggYWxsb3dzIGEgdGFnIHRvXG4gKiBiZSB0d28gb3IgbW9yZSBvY3RldHMsIGJ1dCB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBjbGFzcy4gQSB0YWcgaXNcbiAqIG9ubHkgMSBieXRlLiBCaXRzIDEtNSBnaXZlIHRoZSB0YWcgbnVtYmVyIChpZSB0aGUgZGF0YSB0eXBlIHdpdGhpbiBhXG4gKiBwYXJ0aWN1bGFyICdjbGFzcycpLCA2IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgQVNOLjEgdmFsdWUgaXNcbiAqIGNvbnN0cnVjdGVkIGZyb20gb3RoZXIgQVNOLjEgdmFsdWVzLCBhbmQgYml0cyA3IGFuZCA4IGdpdmUgdGhlICdjbGFzcycuIElmXG4gKiBiaXRzIDcgYW5kIDggYXJlIGJvdGggemVybywgdGhlIGNsYXNzIGlzIFVOSVZFUlNBTC4gSWYgb25seSBiaXQgNyBpcyBzZXQsXG4gKiB0aGVuIHRoZSBjbGFzcyBpcyBBUFBMSUNBVElPTi4gSWYgb25seSBiaXQgOCBpcyBzZXQsIHRoZW4gdGhlIGNsYXNzIGlzXG4gKiBDT05URVhUX1NQRUNJRklDLiBJZiBib3RoIGJpdHMgNyBhbmQgOCBhcmUgc2V0LCB0aGVuIHRoZSBjbGFzcyBpcyBQUklWQVRFLlxuICogVGhlIHRhZyBudW1iZXJzIGZvciB0aGUgZGF0YSB0eXBlcyBmb3IgdGhlIGNsYXNzIFVOSVZFUlNBTCBhcmUgbGlzdGVkIGJlbG93OlxuICpcbiAqIFVOSVZFUlNBTCAwIFJlc2VydmVkIGZvciB1c2UgYnkgdGhlIGVuY29kaW5nIHJ1bGVzXG4gKiBVTklWRVJTQUwgMSBCb29sZWFuIHR5cGVcbiAqIFVOSVZFUlNBTCAyIEludGVnZXIgdHlwZVxuICogVU5JVkVSU0FMIDMgQml0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA0IE9jdGV0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA1IE51bGwgdHlwZVxuICogVU5JVkVSU0FMIDYgT2JqZWN0IGlkZW50aWZpZXIgdHlwZVxuICogVU5JVkVSU0FMIDcgT2JqZWN0IGRlc2NyaXB0b3IgdHlwZVxuICogVU5JVkVSU0FMIDggRXh0ZXJuYWwgdHlwZSBhbmQgSW5zdGFuY2Utb2YgdHlwZVxuICogVU5JVkVSU0FMIDkgUmVhbCB0eXBlXG4gKiBVTklWRVJTQUwgMTAgRW51bWVyYXRlZCB0eXBlXG4gKiBVTklWRVJTQUwgMTEgRW1iZWRkZWQtcGR2IHR5cGVcbiAqIFVOSVZFUlNBTCAxMiBVVEY4U3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCAxMyBSZWxhdGl2ZSBvYmplY3QgaWRlbnRpZmllciB0eXBlXG4gKiBVTklWRVJTQUwgMTQtMTUgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSBlZGl0aW9uc1xuICogVU5JVkVSU0FMIDE2IFNlcXVlbmNlIGFuZCBTZXF1ZW5jZS1vZiB0eXBlc1xuICogVU5JVkVSU0FMIDE3IFNldCBhbmQgU2V0LW9mIHR5cGVzXG4gKiBVTklWRVJTQUwgMTgtMjIsIDI1LTMwIENoYXJhY3RlciBzdHJpbmcgdHlwZXNcbiAqIFVOSVZFUlNBTCAyMy0yNCBUaW1lIHR5cGVzXG4gKlxuICogVGhlIGxlbmd0aCBvZiBhbiBBU04uMSBzdHJ1Y3R1cmUgaXMgc3BlY2lmaWVkIGFmdGVyIHRoZSB0YWcgaWRlbnRpZmllci5cbiAqIFRoZXJlIGlzIGEgZGVmaW5pdGUgZm9ybSBhbmQgYW4gaW5kZWZpbml0ZSBmb3JtLiBUaGUgaW5kZWZpbml0ZSBmb3JtIG1heVxuICogYmUgdXNlZCBpZiB0aGUgZW5jb2RpbmcgaXMgY29uc3RydWN0ZWQgYW5kIG5vdCBhbGwgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICogVGhlIGluZGVmaW5pdGUgZm9ybSBpcyBlbmNvZGVkIHVzaW5nIGEgbGVuZ3RoIGJ5dGUgd2l0aCBvbmx5IHRoZSA4dGggYml0XG4gKiBzZXQuIFRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdGVkIG9iamVjdCBpcyBtYXJrZWQgdXNpbmcgZW5kLW9mLWNvbnRlbnRzXG4gKiBvY3RldHMgKHR3byB6ZXJvIGJ5dGVzKS5cbiAqXG4gKiBUaGUgZGVmaW5pdGUgZm9ybSBsb29rcyBsaWtlIHRoaXM6XG4gKlxuICogVGhlIGxlbmd0aCBtYXkgdGFrZSB1cCAxIG9yIG1vcmUgYnl0ZXMsIGl0IGRlcGVuZHMgb24gdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHZhbHVlIG9mIHRoZSBBU04uMSBzdHJ1Y3R1cmUuIERFUiBlbmNvZGluZyByZXF1aXJlcyB0aGF0IGlmIHRoZSBBU04uMVxuICogc3RydWN0dXJlIGhhcyBhIHZhbHVlIHRoYXQgaGFzIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxMjcsIG1vcmUgdGhhbiAxIGJ5dGVcbiAqIHdpbGwgYmUgdXNlZCB0byBzdG9yZSBpdHMgbGVuZ3RoLCBvdGhlcndpc2UganVzdCBvbmUgYnl0ZSB3aWxsIGJlIHVzZWQuXG4gKiBUaGlzIGlzIHN0cmljdC5cbiAqXG4gKiBJbiB0aGUgY2FzZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIEFTTi4xIHZhbHVlIGlzIGxlc3MgdGhhbiAxMjcsIDEgb2N0ZXRcbiAqIChieXRlKSBpcyB1c2VkIHRvIHN0b3JlIHRoZSBcInNob3J0IGZvcm1cIiBsZW5ndGguIFRoZSA4dGggYml0IGhhcyBhIHZhbHVlIG9mXG4gKiAwIGluZGljYXRpbmcgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBhbmQgbm90IFwibG9uZyBmb3JtXCIgYW5kIGJpdHMgNy0xXG4gKiBnaXZlIHRoZSBsZW5ndGggb2YgdGhlIGRhdGEuIChUaGUgOHRoIGJpdCBpcyB0aGUgbGVmdC1tb3N0LCBtb3N0IHNpZ25pZmljYW50XG4gKiBiaXQ6IGFsc28ga25vd24gYXMgYmlnIGVuZGlhbiBvciBuZXR3b3JrIGZvcm1hdCkuXG4gKlxuICogSW4gdGhlIGNhc2UgdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZSBBU04uMSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMTI3LCAyIHRvXG4gKiAxMjcgb2N0ZXRzIChieXRlcykgYXJlIHVzZWQgdG8gc3RvcmUgdGhlIFwibG9uZyBmb3JtXCIgbGVuZ3RoLiBUaGUgZmlyc3RcbiAqIGJ5dGUncyA4dGggYml0IGlzIHNldCB0byAxIHRvIGluZGljYXRlIHRoZSBsZW5ndGggaXMgXCJsb25nIGZvcm0uXCIgQml0cyA3LTFcbiAqIGdpdmUgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG9jdGV0cy4gQWxsIGZvbGxvd2luZyBvY3RldHMgYXJlIGluIGJhc2UgMjU2XG4gKiB3aXRoIHRoZSBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0ICh0eXBpY2FsIGJpZy1lbmRpYW4gYmluYXJ5IHVuc2lnbmVkXG4gKiBpbnRlZ2VyIHN0b3JhZ2UpLiBTbywgZm9yIGluc3RhbmNlLCBpZiB0aGUgbGVuZ3RoIG9mIGEgdmFsdWUgd2FzIDI1NywgdGhlXG4gKiBmaXJzdCBieXRlIHdvdWxkIGJlIHNldCB0bzpcbiAqXG4gKiAxMDAwMDAxMCA9IDEzMCA9IDB4ODIuXG4gKlxuICogVGhpcyBpbmRpY2F0ZXMgdGhlcmUgYXJlIDIgb2N0ZXRzIChiYXNlIDI1NikgZm9yIHRoZSBsZW5ndGguIFRoZSBzZWNvbmQgYW5kXG4gKiB0aGlyZCBieXRlcyAodGhlIG9jdGV0cyBqdXN0IG1lbnRpb25lZCkgd291bGQgc3RvcmUgdGhlIGxlbmd0aCBpbiBiYXNlIDI1NjpcbiAqXG4gKiBvY3RldCAyOiAwMDAwMDAwMSA9IDEgKiAyNTZeMSA9IDI1NlxuICogb2N0ZXQgMzogMDAwMDAwMDEgPSAxICogMjU2XjAgPSAxXG4gKiB0b3RhbCA9IDI1N1xuICpcbiAqIFRoZSBhbGdvcml0aG0gZm9yIGNvbnZlcnRpbmcgYSBqcyBpbnRlZ2VyIHZhbHVlIG9mIDI1NyB0byBiYXNlLTI1NiBpczpcbiAqXG4gKiB2YXIgdmFsdWUgPSAyNTc7XG4gKiB2YXIgYnl0ZXMgPSBbXTtcbiAqIGJ5dGVzWzBdID0gKHZhbHVlID4+PiA4KSAmIDB4RkY7IC8vIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdFxuICogYnl0ZXNbMV0gPSB2YWx1ZSAmIDB4RkY7ICAgICAgICAvLyBsZWFzdCBzaWduaWZpY2FudCBieXRlIGxhc3RcbiAqXG4gKiBPbiB0aGUgQVNOLjEgVU5JVkVSU0FMIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIHR5cGU6XG4gKlxuICogQW4gT0lEIGNhbiBiZSB3cml0dGVuIGxpa2U6IFwidmFsdWUxLnZhbHVlMi52YWx1ZTMuLi52YWx1ZU5cIlxuICpcbiAqIFRoZSBERVIgZW5jb2RpbmcgcnVsZXM6XG4gKlxuICogVGhlIGZpcnN0IGJ5dGUgaGFzIHRoZSB2YWx1ZSA0MCAqIHZhbHVlMSArIHZhbHVlMi5cbiAqIFRoZSBmb2xsb3dpbmcgYnl0ZXMsIGlmIGFueSwgZW5jb2RlIHRoZSByZW1haW5pbmcgdmFsdWVzLiBFYWNoIHZhbHVlIGlzXG4gKiBlbmNvZGVkIGluIGJhc2UgMTI4LCBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0IChiaWcgZW5kaWFuKSwgd2l0aCBhc1xuICogZmV3IGRpZ2l0cyBhcyBwb3NzaWJsZSwgYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiBlYWNoIGJ5dGUgc2V0XG4gKiB0byAxIGV4Y2VwdCB0aGUgbGFzdCBpbiBlYWNoIHZhbHVlJ3MgZW5jb2RpbmcuIEZvciBleGFtcGxlOiBHaXZlbiB0aGVcbiAqIE9JRCBcIjEuMi44NDAuMTEzNTQ5XCIsIGl0cyBERVIgZW5jb2RpbmcgaXMgKHJlbWVtYmVyIGVhY2ggYnl0ZSBleGNlcHQgdGhlXG4gKiBsYXN0IG9uZSBpbiBlYWNoIGVuY29kaW5nIGlzIE9SJ2Qgd2l0aCAweDgwKTpcbiAqXG4gKiBieXRlIDE6IDQwICogMSArIDIgPSA0MiA9IDB4MkEuXG4gKiBieXRlcyAyLTM6IDEyOCAqIDYgKyA3MiA9IDg0MCA9IDYgNzIgPSA2IDcyID0gMHgwNjQ4ID0gMHg4NjQ4XG4gKiBieXRlcyA0LTY6IDE2Mzg0ICogNiArIDEyOCAqIDExOSArIDEzID0gNiAxMTkgMTMgPSAweDA2NzcwRCA9IDB4ODZGNzBEXG4gKlxuICogVGhlIGZpbmFsIHZhbHVlIGlzOiAweDJBODY0ODg2RjcwRC5cbiAqIFRoZSBmdWxsIE9JRCAoaW5jbHVkaW5nIEFTTi4xIHRhZyBhbmQgbGVuZ3RoIG9mIDYgYnl0ZXMpIGlzOlxuICogMHgwNjA2MkE4NjQ4ODZGNzBEXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLyogQVNOLjEgQVBJICovXG52YXIgYXNuMSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYXNuMSA9IGZvcmdlLmFzbjEgfHwge307XG5cbi8qKlxuICogQVNOLjEgY2xhc3Nlcy5cbiAqL1xuYXNuMS5DbGFzcyA9IHtcbiAgVU5JVkVSU0FMOiAgICAgICAgMHgwMCxcbiAgQVBQTElDQVRJT046ICAgICAgMHg0MCxcbiAgQ09OVEVYVF9TUEVDSUZJQzogMHg4MCxcbiAgUFJJVkFURTogICAgICAgICAgMHhDMFxufTtcblxuLyoqXG4gKiBBU04uMSB0eXBlcy4gTm90IGFsbCB0eXBlcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb24sIG9ubHlcbiAqIHRob3NlIG5lY2Vzc2FyeSB0byBpbXBsZW1lbnQgYSBzaW1wbGUgUEtJIGFyZSBpbXBsZW1lbnRlZC5cbiAqL1xuYXNuMS5UeXBlID0ge1xuICBOT05FOiAgICAgICAgICAgICAwLFxuICBCT09MRUFOOiAgICAgICAgICAxLFxuICBJTlRFR0VSOiAgICAgICAgICAyLFxuICBCSVRTVFJJTkc6ICAgICAgICAzLFxuICBPQ1RFVFNUUklORzogICAgICA0LFxuICBOVUxMOiAgICAgICAgICAgICA1LFxuICBPSUQ6ICAgICAgICAgICAgICA2LFxuICBPREVTQzogICAgICAgICAgICA3LFxuICBFWFRFUk5BTDogICAgICAgICA4LFxuICBSRUFMOiAgICAgICAgICAgICA5LFxuICBFTlVNRVJBVEVEOiAgICAgIDEwLFxuICBFTUJFRERFRDogICAgICAgIDExLFxuICBVVEY4OiAgICAgICAgICAgIDEyLFxuICBST0lEOiAgICAgICAgICAgIDEzLFxuICBTRVFVRU5DRTogICAgICAgIDE2LFxuICBTRVQ6ICAgICAgICAgICAgIDE3LFxuICBQUklOVEFCTEVTVFJJTkc6IDE5LFxuICBJQTVTVFJJTkc6ICAgICAgIDIyLFxuICBVVENUSU1FOiAgICAgICAgIDIzLFxuICBHRU5FUkFMSVpFRFRJTUU6IDI0LFxuICBCTVBTVFJJTkc6ICAgICAgIDMwXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRhZ0NsYXNzIHRoZSB0YWcgY2xhc3MgZm9yIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0gdHlwZSB0aGUgZGF0YSB0eXBlICh0YWcgbnVtYmVyKSBmb3IgdGhlIG9iamVjdC5cbiAqIEBwYXJhbSBjb25zdHJ1Y3RlZCB0cnVlIGlmIHRoZSBhc24xIG9iamVjdCBpcyBpbiBjb25zdHJ1Y3RlZCBmb3JtLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBmb3IgdGhlIG9iamVjdCwgaWYgaXQgaXMgbm90IGNvbnN0cnVjdGVkLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYml0U3RyaW5nQ29udGVudHNdIHRoZSBwbGFpbiBCSVQgU1RSSU5HIGNvbnRlbnQgaW5jbHVkaW5nIHBhZGRpbmdcbiAqICAgICAgICAgICAgYnl0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5jcmVhdGUgPSBmdW5jdGlvbih0YWdDbGFzcywgdHlwZSwgY29uc3RydWN0ZWQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIC8qIEFuIGFzbjEgb2JqZWN0IGhhcyBhIHRhZ0NsYXNzLCBhIHR5cGUsIGEgY29uc3RydWN0ZWQgZmxhZywgYW5kIGFcbiAgICB2YWx1ZS4gVGhlIHZhbHVlJ3MgdHlwZSBkZXBlbmRzIG9uIHRoZSBjb25zdHJ1Y3RlZCBmbGFnLiBJZlxuICAgIGNvbnN0cnVjdGVkLCBpdCB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIG90aGVyIGFzbjEgb2JqZWN0cy4gSWYgbm90LFxuICAgIGl0IHdpbGwgY29udGFpbiB0aGUgQVNOLjEgdmFsdWUgYXMgYW4gYXJyYXkgb2YgYnl0ZXMgZm9ybWF0dGVkXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBBU04uMSBkYXRhIHR5cGUuICovXG5cbiAgLy8gcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXNcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKHZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdG1wLnB1c2godmFsdWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHRtcDtcbiAgfVxuXG4gIHZhciBvYmogPSB7XG4gICAgdGFnQ2xhc3M6IHRhZ0NsYXNzLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29uc3RydWN0ZWQ6IGNvbnN0cnVjdGVkLFxuICAgIGNvbXBvc2VkOiBjb25zdHJ1Y3RlZCB8fCBmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xuICBpZihvcHRpb25zICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb3B0aW9ucykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICBvYmouYml0U3RyaW5nQ29udGVudHMgPSBvcHRpb25zLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgIC8vIFRPRE86IGFkZCByZWFkb25seSBmbGFnIHRvIGF2b2lkIHRoaXMgb3ZlcmhlYWRcbiAgICAvLyBzYXZlIGNvcHkgdG8gZGV0ZWN0IGNoYW5nZXNcbiAgICBvYmoub3JpZ2luYWwgPSBhc24xLmNvcHkob2JqKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgYW4gYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSBvYmplY3QuXG4gKiBAcGFyYW0gW29wdGlvbnNdIGNvcHkgb3B0aW9uczpcbiAqICAgICAgICAgIFtleGNsdWRlQml0U3RyaW5nQ29udGVudHNdIHRydWUgdG8gbm90IGNvcHkgYml0U3RyaW5nQ29udGVudHNcbiAqXG4gKiBAcmV0dXJuIHRoZSBhIGNvcHkgb2YgdGhlIGFzbjEgb2JqZWN0LlxuICovXG5hc24xLmNvcHkgPSBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGNvcHk7XG5cbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICBjb3B5ID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgY29weS5wdXNoKGFzbjEuY29weShvYmpbaV0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICBpZih0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgY29weSA9IHtcbiAgICB0YWdDbGFzczogb2JqLnRhZ0NsYXNzLFxuICAgIHR5cGU6IG9iai50eXBlLFxuICAgIGNvbnN0cnVjdGVkOiBvYmouY29uc3RydWN0ZWQsXG4gICAgY29tcG9zZWQ6IG9iai5jb21wb3NlZCxcbiAgICB2YWx1ZTogYXNuMS5jb3B5KG9iai52YWx1ZSwgb3B0aW9ucylcbiAgfTtcbiAgaWYob3B0aW9ucyAmJiAhb3B0aW9ucy5leGNsdWRlQml0U3RyaW5nQ29udGVudHMpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgY29weS5iaXRTdHJpbmdDb250ZW50cyA9IG9iai5iaXRTdHJpbmdDb250ZW50cztcbiAgfVxuICByZXR1cm4gY29weTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgYXNuMSBvYmplY3RzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBOb3RlIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcnVuIGluIGNvbnN0YW50IHRpbWUuXG4gKlxuICogQHBhcmFtIG9iajEgdGhlIGZpcnN0IGFzbjEgb2JqZWN0LlxuICogQHBhcmFtIG9iajIgdGhlIHNlY29uZCBhc24xIG9iamVjdC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gY29tcGFyZSBvcHRpb25zOlxuICogICAgICAgICAgW2luY2x1ZGVCaXRTdHJpbmdDb250ZW50c10gdHJ1ZSB0byBjb21wYXJlIGJpdFN0cmluZ0NvbnRlbnRzXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBhc24xIG9iamVjdHMgYXJlIGVxdWFsLlxuICovXG5hc24xLmVxdWFscyA9IGZ1bmN0aW9uKG9iajEsIG9iajIsIG9wdGlvbnMpIHtcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iajEpKSB7XG4gICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShvYmoyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZihvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iajEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKCFhc24xLmVxdWFscyhvYmoxW2ldLCBvYmoyW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgIT09IHR5cGVvZiBvYmoyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIH1cblxuICB2YXIgZXF1YWwgPSBvYmoxLnRhZ0NsYXNzID09PSBvYmoyLnRhZ0NsYXNzICYmXG4gICAgb2JqMS50eXBlID09PSBvYmoyLnR5cGUgJiZcbiAgICBvYmoxLmNvbnN0cnVjdGVkID09PSBvYmoyLmNvbnN0cnVjdGVkICYmXG4gICAgb2JqMS5jb21wb3NlZCA9PT0gb2JqMi5jb21wb3NlZCAmJlxuICAgIGFzbjEuZXF1YWxzKG9iajEudmFsdWUsIG9iajIudmFsdWUpO1xuICBpZihvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgZXF1YWwgPSBlcXVhbCAmJiAob2JqMS5iaXRTdHJpbmdDb250ZW50cyA9PT0gb2JqMi5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH1cblxuICByZXR1cm4gZXF1YWw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGIgdGhlIEJFUi1lbmNvZGVkIEFTTi4xIGJ5dGUgYnVmZmVyLCBzdGFydGluZyB3aXRoIHRoZSBmaXJzdFxuICogICAgICAgICAgbGVuZ3RoIGJ5dGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbmFzbjEuZ2V0QmVyVmFsdWVMZW5ndGggPSBmdW5jdGlvbihiKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIHZhciBiMiA9IGIuZ2V0Qnl0ZSgpO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgbGVuZ3RoID0gYi5nZXRJbnQoKGIyICYgMHg3RikgPDwgMyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJ5dGUgYnVmZmVyIGhhcyBlbm91Z2ggYnl0ZXMuIFRocm93cyBhbiBFcnJvciBpZiBub3QuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgbXVzdCBoYXZlLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgbikge1xuICBpZihuID4gcmVtYWluaW5nKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHBhcnNlIERFUi4nKTtcbiAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICBlcnJvci5yZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgZXJyb3IucmVxdWVzdGVkID0gbjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbnZhciBfZ2V0VmFsdWVMZW5ndGggPSBmdW5jdGlvbihieXRlcywgcmVtYWluaW5nKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIC8vIGZyb21EZXIgYWxyZWFkeSBjaGVja2VkIHRoYXQgdGhpcyBieXRlIGV4aXN0c1xuICB2YXIgYjIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIHJlbWFpbmluZy0tO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgdmFyIGxvbmdGb3JtQnl0ZXMgPSBiMiAmIDB4N0Y7XG4gICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIGxvbmdGb3JtQnl0ZXMpO1xuICAgIGxlbmd0aCA9IGJ5dGVzLmdldEludChsb25nRm9ybUJ5dGVzIDw8IDMpO1xuICB9XG4gIC8vIEZJWE1FOiB0aGlzIHdpbGwgb25seSBoYXBwZW4gZm9yIDMyIGJpdCBnZXRJbnQgd2l0aCBoaWdoIGJpdCBzZXRcbiAgaWYobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgbGVuZ3RoOiAnICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gYXNuMSBvYmplY3QgZnJvbSBhIGJ5dGUgYnVmZmVyIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICogQHBhcmFtIFtvcHRpb25zXSBvYmplY3Qgd2l0aCBvcHRpb25zIG9yIGJvb2xlYW4gc3RyaWN0IGZsYWdcbiAqICAgICAgICAgIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbZGVjb2RlQml0U3RyaW5nc10gdHJ1ZSB0byBhdHRlbXB0IHRvIGRlY29kZSB0aGUgY29udGVudCBvZlxuICogICAgICAgICAgICBCSVQgU1RSSU5HcyAobm90IE9DVEVUIFNUUklOR3MpIHVzaW5nIHN0cmljdCBtb2RlLiBOb3RlIHRoYXRcbiAqICAgICAgICAgICAgd2l0aG91dCBzY2hlbWEgc3VwcG9ydCB0byB1bmRlcnN0YW5kIHRoZSBkYXRhIGNvbnRleHQgdGhpcyBjYW5cbiAqICAgICAgICAgICAgZXJyb25lb3VzbHkgZGVjb2RlIHZhbHVlcyB0aGF0IGhhcHBlbiB0byBiZSB2YWxpZCBBU04uMS4gVGhpc1xuICogICAgICAgICAgICBmbGFnIHdpbGwgYmUgZGVwcmVjYXRlZCBvciByZW1vdmVkIGFzIHNvb24gYXMgc2NoZW1hIHN1cHBvcnQgaXNcbiAqICAgICAgICAgICAgYXZhaWxhYmxlLiAoZGVmYXVsdDogdHJ1ZSlcbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuZnJvbURlciA9IGZ1bmN0aW9uKGJ5dGVzLCBvcHRpb25zKSB7XG4gIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdDogb3B0aW9ucyxcbiAgICAgIGRlY29kZUJpdFN0cmluZ3M6IHRydWVcbiAgICB9O1xuICB9XG4gIGlmKCEoJ3N0cmljdCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnN0cmljdCA9IHRydWU7XG4gIH1cbiAgaWYoISgnZGVjb2RlQml0U3RyaW5ncycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmRlY29kZUJpdFN0cmluZ3MgPSB0cnVlO1xuICB9XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIHJldHVybiBfZnJvbURlcihieXRlcywgYnl0ZXMubGVuZ3RoKCksIDAsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBhbiBhc24xIG9iamVjdCBmcm9tIGEgYnl0ZSBidWZmZXIgaW4gREVSIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gcmVtYWluaW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGZvciB0aGlzIGNodW5rLlxuICogQHBhcmFtIGRlcHRoIHRoZSBjdXJyZW50IHBhcnNpbmcgZGVwdGguXG4gKiBAcGFyYW0gb3B0aW9ucyBvYmplY3Qgd2l0aCBzYW1lIG9wdGlvbnMgYXMgZnJvbURlcigpLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBhc24xIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGgsIG9wdGlvbnMpIHtcbiAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvbnN1bXB0aW9uIGNhbGN1bGF0aW9uc1xuICB2YXIgc3RhcnQ7XG5cbiAgLy8gbWluaW11bSBsZW5ndGggZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmUgaXMgMlxuICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG5cbiAgLy8gZ2V0IHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgLy8gY29uc3VtZWQgb25lIGJ5dGVcbiAgcmVtYWluaW5nLS07XG5cbiAgLy8gZ2V0IHRoZSB0YWcgY2xhc3NcbiAgdmFyIHRhZ0NsYXNzID0gKGIxICYgMHhDMCk7XG5cbiAgLy8gZ2V0IHRoZSB0eXBlIChiaXRzIDEtNSlcbiAgdmFyIHR5cGUgPSBiMSAmIDB4MUY7XG5cbiAgLy8gZ2V0IHRoZSB2YXJpYWJsZSB2YWx1ZSBsZW5ndGggYW5kIGFkanVzdCByZW1haW5pbmcgYnl0ZXNcbiAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgdmFyIGxlbmd0aCA9IF9nZXRWYWx1ZUxlbmd0aChieXRlcywgcmVtYWluaW5nKTtcbiAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG5cbiAgLy8gZW5zdXJlIHRoZXJlIGFyZSBlbm91Z2ggYnl0ZXMgdG8gZ2V0IHRoZSB2YWx1ZVxuICBpZihsZW5ndGggIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICBpZihvcHRpb25zLnN0cmljdCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHJlYWQgQVNOLjEgdmFsdWUuJyk7XG4gICAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIGVycm9yLnJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICAgIGVycm9yLnJlcXVlc3RlZCA9IGxlbmd0aDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBOb3RlOiBiZSBsZW5pZW50IHdpdGggdHJ1bmNhdGVkIHZhbHVlcyBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIC8vIHZhbHVlIHN0b3JhZ2VcbiAgdmFyIHZhbHVlO1xuICAvLyBwb3NzaWJsZSBCSVQgU1RSSU5HIGNvbnRlbnRzIHN0b3JhZ2VcbiAgdmFyIGJpdFN0cmluZ0NvbnRlbnRzO1xuXG4gIC8vIGNvbnN0cnVjdGVkIGZsYWcgaXMgYml0IDYgKDMyID0gMHgyMCkgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGNvbnN0cnVjdGVkID0gKChiMSAmIDB4MjApID09PSAweDIwKTtcbiAgaWYoY29uc3RydWN0ZWQpIHtcbiAgICAvLyBwYXJzZSBjaGlsZCBhc24xIG9iamVjdHMgZnJvbSB0aGUgdmFsdWVcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGlmKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhc24xIG9iamVjdCBvZiBpbmRlZmluaXRlIGxlbmd0aCwgcmVhZCB1bnRpbCBlbmQgdGFnXG4gICAgICBmb3IoOzspIHtcbiAgICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuICAgICAgICBpZihieXRlcy5ieXRlcygyKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAwKSkge1xuICAgICAgICAgIGJ5dGVzLmdldEJ5dGVzKDIpO1xuICAgICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIHZhbHVlLnB1c2goX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBvcHRpb25zKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJzaW5nIGFzbjEgb2JqZWN0IG9mIGRlZmluaXRlIGxlbmd0aFxuICAgICAgd2hpbGUobGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCBsZW5ndGgsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgbGVuZ3RoIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYSBCSVQgU1RSSU5HLCBzYXZlIHRoZSBjb250ZW50cyBpbmNsdWRpbmcgcGFkZGluZ1xuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRhZ0NsYXNzID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCAmJlxuICAgIHR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICBiaXRTdHJpbmdDb250ZW50cyA9IGJ5dGVzLmJ5dGVzKGxlbmd0aCk7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgaWYgYSBub24tY29uc3RydWN0ZWQgdmFsdWUgc2hvdWxkIGJlIGRlY29kZWQgYXMgYSBjb21wb3NlZFxuICAvLyB2YWx1ZSB0aGF0IGNvbnRhaW5zIG90aGVyIEFTTi4xIG9iamVjdHMuIEJJVCBTVFJJTkdzIChhbmQgT0NURVQgU1RSSU5HcylcbiAgLy8gY2FuIGJlIHVzZWQgdGhpcyB3YXkuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5kZWNvZGVCaXRTdHJpbmdzICYmXG4gICAgdGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMICYmXG4gICAgLy8gRklYTUU6IE9DVEVUIFNUUklOR3Mgbm90IHlldCBzdXBwb3J0ZWQgaGVyZVxuICAgIC8vIC4uIG90aGVyIHBhcnRzIG9mIGZvcmdlIGV4cGVjdCB0byBkZWNvZGUgT0NURVQgU1RSSU5HcyBtYW51YWxseVxuICAgICh0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HIC8qfHwgdHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKi8pICYmXG4gICAgbGVuZ3RoID4gMSkge1xuICAgIC8vIHNhdmUgcmVhZCBwb3NpdGlvblxuICAgIHZhciBzYXZlZFJlYWQgPSBieXRlcy5yZWFkO1xuICAgIHZhciBzYXZlZFJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICBpZih0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgICAvKiBUaGUgZmlyc3Qgb2N0ZXQgZ2l2ZXMgdGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgIGJpdCBzdHJpbmcgaXMgbGVzcyB0aGFuIHRoZSBuZXh0IG11bHRpcGxlIG9mIGVpZ2h0ICh0aGlzIGlzIGNhbGxlZFxuICAgICAgICB0aGUgXCJudW1iZXIgb2YgdW51c2VkIGJpdHNcIikuXG5cbiAgICAgICAgVGhlIHNlY29uZCBhbmQgZm9sbG93aW5nIG9jdGV0cyBnaXZlIHRoZSB2YWx1ZSBvZiB0aGUgYml0IHN0cmluZ1xuICAgICAgICBjb252ZXJ0ZWQgdG8gYW4gb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDEpO1xuICAgICAgdW51c2VkID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICAgICAgcmVtYWluaW5nLS07XG4gICAgfVxuICAgIC8vIGlmIGFsbCBiaXRzIGFyZSB1c2VkLCBtYXliZSB0aGUgQklUL09DVEVUIFNUUklORyBob2xkcyBBU04uMSBvYmpzXG4gICAgaWYodW51c2VkID09PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhdHRlbXB0IHRvIHBhcnNlIGNoaWxkIGFzbjEgb2JqZWN0IGZyb20gdGhlIHZhbHVlXG4gICAgICAgIC8vIChzdG9yZWQgaW4gYXJyYXkgdG8gc2lnbmFsIGNvbXBvc2VkIHZhbHVlKVxuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3ViT3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBlbmZvcmNlIHN0cmljdCBtb2RlIHRvIGF2b2lkIHBhcnNpbmcgQVNOLjEgZnJvbSBwbGFpbiBkYXRhXG4gICAgICAgICAgdmVyYm9zZTogb3B0aW9ucy52ZXJib3NlLFxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wb3NlZCA9IF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoICsgMSwgc3ViT3B0aW9ucyk7XG4gICAgICAgIHZhciB1c2VkID0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHVzZWQ7XG4gICAgICAgIGlmKHR5cGUgPT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgICAgIHVzZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBkYXRhIGFsbCBkZWNvZGVkIGFuZCB0aGUgY2xhc3MgaW5kaWNhdGVzIFVOSVZFUlNBTCBvclxuICAgICAgICAvLyBDT05URVhUX1NQRUNJRklDIHRoZW4gYXNzdW1lIHdlJ3ZlIGdvdCBhbiBlbmNhcHN1bGF0ZWQgQVNOLjEgb2JqZWN0XG4gICAgICAgIHZhciB0YyA9IGNvbXBvc2VkLnRhZ0NsYXNzO1xuICAgICAgICBpZih1c2VkID09PSBsZW5ndGggJiZcbiAgICAgICAgICAodGMgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8IHRjID09PSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMpKSB7XG4gICAgICAgICAgdmFsdWUgPSBbY29tcG9zZWRdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJlc3RvcmUgcmVhZCBwb3NpdGlvblxuICAgICAgYnl0ZXMucmVhZCA9IHNhdmVkUmVhZDtcbiAgICAgIHJlbWFpbmluZyA9IHNhdmVkUmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBhc24xIG5vdCBjb25zdHJ1Y3RlZCBvciBjb21wb3NlZCwgZ2V0IHJhdyB2YWx1ZVxuICAgIC8vIFRPRE86IGRvIERFUiB0byBPSUQgY29udmVyc2lvbiBhbmQgdmljZS12ZXJzYSBpbiAudG9EZXI/XG5cbiAgICBpZihsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tY29uc3RydWN0ZWQgQVNOLjEgb2JqZWN0IG9mIGluZGVmaW5pdGUgbGVuZ3RoLicpO1xuICAgICAgfVxuICAgICAgLy8gYmUgbGVuaWVudCBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cblxuICAgIGlmKHR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgICBmb3IoOyBsZW5ndGggPiAwOyBsZW5ndGggLT0gMikge1xuICAgICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG4gICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXMuZ2V0SW50MTYoKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGJ5dGVzLmdldEJ5dGVzKGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlXG4gIHZhciBhc24xT3B0aW9ucyA9IGJpdFN0cmluZ0NvbnRlbnRzID09PSB1bmRlZmluZWQgPyAgbnVsbCA6IHtcbiAgICBiaXRTdHJpbmdDb250ZW50czogYml0U3RyaW5nQ29udGVudHNcbiAgfTtcblxuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhc24xIG9iamVjdFxuICByZXR1cm4gYXNuMS5jcmVhdGUodGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgYXNuMU9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhc24xIG9iamVjdCB0byBhIGJ1ZmZlciBvZiBieXRlcyBpbiBERVIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBhc24xIHRoZSBhc24xIG9iamVjdCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ1ZmZlciBvZiBieXRlcy5cbiAqL1xuYXNuMS50b0RlciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGJ1aWxkIHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IG9iai50YWdDbGFzcyB8IG9iai50eXBlO1xuXG4gIC8vIGZvciBzdG9yaW5nIHRoZSBBU04uMSB2YWx1ZVxuICB2YXIgdmFsdWUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZSBCSVQgU1RSSU5HIGNvbnRlbnRzIGlmIGF2YWlsYWJsZSBhbmQgZGF0YSBub3QgY2hhbmdlZFxuICB2YXIgdXNlQml0U3RyaW5nQ29udGVudHMgPSBmYWxzZTtcbiAgaWYoJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvYmopIHtcbiAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IHRydWU7XG4gICAgaWYob2JqLm9yaWdpbmFsKSB7XG4gICAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGFzbjEuZXF1YWxzKG9iaiwgb2JqLm9yaWdpbmFsKTtcbiAgICB9XG4gIH1cblxuICBpZih1c2VCaXRTdHJpbmdDb250ZW50cykge1xuICAgIHZhbHVlLnB1dEJ5dGVzKG9iai5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH0gZWxzZSBpZihvYmouY29tcG9zZWQpIHtcbiAgICAvLyBpZiBjb21wb3NlZCwgdXNlIGVhY2ggY2hpbGQgYXNuMSBvYmplY3QncyBERVIgYnl0ZXMgYXMgdmFsdWVcbiAgICAvLyB0dXJuIG9uIDZ0aCBiaXQgKDB4MjAgPSAzMikgdG8gaW5kaWNhdGUgYXNuMSBpcyBjb25zdHJ1Y3RlZFxuICAgIC8vIGZyb20gb3RoZXIgYXNuMSBvYmplY3RzXG4gICAgaWYob2JqLmNvbnN0cnVjdGVkKSB7XG4gICAgICBiMSB8PSAweDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0eXBlIGlzIGEgYml0IHN0cmluZywgYWRkIHVudXNlZCBiaXRzIG9mIDB4MDBcbiAgICAgIHZhbHVlLnB1dEJ5dGUoMHgwMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGFsbCBvZiB0aGUgY2hpbGQgREVSIGJ5dGVzIHRvZ2V0aGVyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYob2JqLnZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUucHV0QnVmZmVyKGFzbjEudG9EZXIob2JqLnZhbHVlW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBhc24xLnZhbHVlIGRpcmVjdGx5XG4gICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUucHV0SW50MTYob2JqLnZhbHVlLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgaW50ZWdlciBpcyBtaW5pbWFsbHktZW5jb2RlZFxuICAgICAgLy8gVE9ETzogc2hvdWxkIGFsbCBsZWFkaW5nIGJ5dGVzIGJlIHN0cmlwcGVkIHZzIGp1c3Qgb25lP1xuICAgICAgLy8gLi4gZXggJzAwIDAwIDAxJyA9PiAnMDEnP1xuICAgICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSICYmXG4gICAgICAgIG9iai52YWx1ZS5sZW5ndGggPiAxICYmXG4gICAgICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAoKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAwICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAwKSB8fFxuICAgICAgICAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAweEZGICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICAgICAgdmFsdWUucHV0Qnl0ZXMob2JqLnZhbHVlLnN1YnN0cigxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5wdXRCeXRlcyhvYmoudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCB0YWcgYnl0ZVxuICBieXRlcy5wdXRCeXRlKGIxKTtcblxuICAvLyB1c2UgXCJzaG9ydCBmb3JtXCIgZW5jb2RpbmdcbiAgaWYodmFsdWUubGVuZ3RoKCkgPD0gMTI3KSB7XG4gICAgLy8gb25lIGJ5dGUgZGVzY3JpYmVzIHRoZSBsZW5ndGhcbiAgICAvLyBiaXQgOCA9IDAgYW5kIGJpdHMgNy0xID0gbGVuZ3RoXG4gICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZS5sZW5ndGgoKSAmIDB4N0YpO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBcImxvbmcgZm9ybVwiIGVuY29kaW5nXG4gICAgLy8gMiB0byAxMjcgYnl0ZXMgZGVzY3JpYmUgdGhlIGxlbmd0aFxuICAgIC8vIGZpcnN0IGJ5dGU6IGJpdCA4ID0gMSBhbmQgYml0cyA3LTEgPSAjIG9mIGFkZGl0aW9uYWwgYnl0ZXNcbiAgICAvLyBvdGhlciBieXRlczogbGVuZ3RoIGluIGJhc2UgMjU2LCBiaWctZW5kaWFuXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCgpO1xuICAgIHZhciBsZW5CeXRlcyA9ICcnO1xuICAgIGRvIHtcbiAgICAgIGxlbkJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuICYgMHhGRik7XG4gICAgICBsZW4gPSBsZW4gPj4+IDg7XG4gICAgfSB3aGlsZShsZW4gPiAwKTtcblxuICAgIC8vIHNldCBmaXJzdCBieXRlIHRvICMgYnl0ZXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIGFuZCB0dXJuIG9uXG4gICAgLy8gYml0IDggdG8gaW5kaWNhdGUgbG9uZy1mb3JtIGxlbmd0aCBpcyB1c2VkXG4gICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5sZW5ndGggfCAweDgwKTtcblxuICAgIC8vIGNvbmNhdGVuYXRlIGxlbmd0aCBieXRlcyBpbiByZXZlcnNlIHNpbmNlIHRoZXkgd2VyZSBnZW5lcmF0ZWRcbiAgICAvLyBsaXR0bGUgZW5kaWFuIGFuZCB3ZSBuZWVkIGJpZyBlbmRpYW5cbiAgICBmb3IodmFyIGkgPSBsZW5CeXRlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb25jYXRlbmF0ZSB2YWx1ZSBieXRlc1xuICBieXRlcy5wdXRCdWZmZXIodmFsdWUpO1xuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZyB0byBhIGJ5dGUgYnVmZmVyLiBUaGUgYnl0ZSBidWZmZXJcbiAqIGNvbnRhaW5zIG9ubHkgdGhlIERFUi1lbmNvZGVkIHZhbHVlLCBub3QgYW55IHRhZyBvciBsZW5ndGggYnl0ZXMuXG4gKlxuICogQHBhcmFtIG9pZCB0aGUgT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUgYnVmZmVyLlxuICovXG5hc24xLm9pZFRvRGVyID0gZnVuY3Rpb24ob2lkKSB7XG4gIC8vIHNwbGl0IE9JRCBpbnRvIGluZGl2aWR1YWwgdmFsdWVzXG4gIHZhciB2YWx1ZXMgPSBvaWQuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyBmaXJzdCBieXRlIGlzIDQwICogdmFsdWUxICsgdmFsdWUyXG4gIGJ5dGVzLnB1dEJ5dGUoNDAgKiBwYXJzZUludCh2YWx1ZXNbMF0sIDEwKSArIHBhcnNlSW50KHZhbHVlc1sxXSwgMTApKTtcbiAgLy8gb3RoZXIgYnl0ZXMgYXJlIGVhY2ggdmFsdWUgaW4gYmFzZSAxMjggd2l0aCA4dGggYml0IHNldCBleGNlcHQgZm9yXG4gIC8vIHRoZSBsYXN0IGJ5dGUgZm9yIGVhY2ggdmFsdWVcbiAgdmFyIGxhc3QsIHZhbHVlQnl0ZXMsIHZhbHVlLCBiO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gcHJvZHVjZSB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBob3cgbWFueVxuICAgIC8vIGJ5dGVzIGl0IHdpbGwgdGFrZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICBsYXN0ID0gdHJ1ZTtcbiAgICB2YWx1ZUJ5dGVzID0gW107XG4gICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZXNbaV0sIDEwKTtcbiAgICBkbyB7XG4gICAgICBiID0gdmFsdWUgJiAweDdGO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBsYXN0LCB0aGVuIHR1cm4gb24gOHRoIGJpdFxuICAgICAgaWYoIWxhc3QpIHtcbiAgICAgICAgYiB8PSAweDgwO1xuICAgICAgfVxuICAgICAgdmFsdWVCeXRlcy5wdXNoKGIpO1xuICAgICAgbGFzdCA9IGZhbHNlO1xuICAgIH0gd2hpbGUodmFsdWUgPiAwKTtcblxuICAgIC8vIGFkZCB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIChuZWVkcyB0byBiZSBpbiBiaWcgZW5kaWFuKVxuICAgIGZvcih2YXIgbiA9IHZhbHVlQnl0ZXMubGVuZ3RoIC0gMTsgbiA+PSAwOyAtLW4pIHtcbiAgICAgIGJ5dGVzLnB1dEJ5dGUodmFsdWVCeXRlc1tuXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIGJ5dGUgYnVmZmVyIHRvIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy4gVGhlXG4gKiBieXRlIGJ1ZmZlciBzaG91bGQgY29udGFpbiBvbmx5IHRoZSBERVItZW5jb2RlZCB2YWx1ZSwgbm90IGFueSB0YWcgb3JcbiAqIGxlbmd0aCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy5cbiAqL1xuYXNuMS5kZXJUb09pZCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhciBvaWQ7XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIC8vIGZpcnN0IGJ5dGUgaXMgNDAgKiB2YWx1ZTEgKyB2YWx1ZTJcbiAgdmFyIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIG9pZCA9IE1hdGguZmxvb3IoYiAvIDQwKSArICcuJyArIChiICUgNDApO1xuXG4gIC8vIG90aGVyIGJ5dGVzIGFyZSBlYWNoIHZhbHVlIGluIGJhc2UgMTI4IHdpdGggOHRoIGJpdCBzZXQgZXhjZXB0IGZvclxuICAvLyB0aGUgbGFzdCBieXRlIGZvciBlYWNoIHZhbHVlXG4gIHZhciB2YWx1ZSA9IDA7XG4gIHdoaWxlKGJ5dGVzLmxlbmd0aCgpID4gMCkge1xuICAgIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gICAgdmFsdWUgPSB2YWx1ZSA8PCA3O1xuICAgIC8vIG5vdCB0aGUgbGFzdCBieXRlIGZvciB0aGUgdmFsdWVcbiAgICBpZihiICYgMHg4MCkge1xuICAgICAgdmFsdWUgKz0gYiAmIDB4N0Y7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxhc3QgYnl0ZVxuICAgICAgb2lkICs9ICcuJyArICh2YWx1ZSArIGIpO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvaWQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVVRDVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogTm90ZTogR2VuZXJhbGl6ZWRUaW1lIGhhcyA0IGRpZ2l0cyBmb3IgdGhlIHllYXIgYW5kIGlzIHVzZWQgZm9yIFguNTA5XG4gKiBkYXRlcyBwYXN0IDIwNDkuIFBhcnNpbmcgdGhhdCBzdHJ1Y3R1cmUgaGFzbid0IGJlZW4gaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSB1dGMgdGhlIFVUQ1RpbWUgdmFsdWUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkYXRlLlxuICovXG5hc24xLnV0Y1RpbWVUb0RhdGUgPSBmdW5jdGlvbih1dGMpIHtcbiAgLyogVGhlIGZvbGxvd2luZyBmb3JtYXRzIGNhbiBiZSB1c2VkOlxuXG4gICAgWVlNTUREaGhtbVpcbiAgICBZWU1NRERoaG1tK2hoJ21tJ1xuICAgIFlZTU1ERGhobW0taGgnbW0nXG4gICAgWVlNTUREaGhtbXNzWlxuICAgIFlZTU1ERGhobW1zcytoaCdtbSdcbiAgICBZWU1NRERoaG1tc3MtaGgnbW0nXG5cbiAgICBXaGVyZTpcblxuICAgIFlZIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gZGlnaXRzIG9mIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIFogaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBHTVQsICsgaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpc1xuICAgIGxhdGVyIHRoYW4gR01ULCBhbmQgLSBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIGVhcmxpZXIgdGhhbiBHTVRcbiAgICBoaCcgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gaG91cnNcbiAgICBtbScgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gbWludXRlcyAqL1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgLy8gaWYgWVkgPj0gNTAgdXNlIDE5eHgsIGlmIFlZIDwgNTAgdXNlIDIweHhcbiAgdmFyIHllYXIgPSBwYXJzZUludCh1dGMuc3Vic3RyKDAsIDIpLCAxMCk7XG4gIHllYXIgPSAoeWVhciA+PSA1MCkgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xuICB2YXIgTU0gPSBwYXJzZUludCh1dGMuc3Vic3RyKDIsIDIpLCAxMCkgLSAxOyAvLyB1c2UgMC0xMSBmb3IgbW9udGhcbiAgdmFyIEREID0gcGFyc2VJbnQodXRjLnN1YnN0cig0LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludCh1dGMuc3Vic3RyKDYsIDIpLCAxMCk7XG4gIHZhciBtbSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoOCwgMiksIDEwKTtcbiAgdmFyIHNzID0gMDtcblxuICAvLyBub3QganVzdCBZWU1NRERoaG1tWlxuICBpZih1dGMubGVuZ3RoID4gMTEpIHtcbiAgICAvLyBnZXQgY2hhcmFjdGVyIGFmdGVyIG1pbnV0ZXNcbiAgICB2YXIgYyA9IHV0Yy5jaGFyQXQoMTApO1xuICAgIHZhciBlbmQgPSAxMDtcblxuICAgIC8vIHNlZSBpZiBzZWNvbmRzIGFyZSBwcmVzZW50XG4gICAgaWYoYyAhPT0gJysnICYmIGMgIT09ICctJykge1xuICAgICAgLy8gZ2V0IHNlY29uZHNcbiAgICAgIHNzID0gcGFyc2VJbnQodXRjLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgICAgIGVuZCArPSAyO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBkYXRlXG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgTU0sIEREKTtcbiAgZGF0ZS5zZXRVVENIb3VycyhoaCwgbW0sIHNzLCAwKTtcblxuICBpZihlbmQpIHtcbiAgICAvLyBnZXQgKy8tIGFmdGVyIGVuZCBvZiB0aW1lXG4gICAgYyA9IHV0Yy5jaGFyQXQoZW5kKTtcbiAgICBpZihjID09PSAnKycgfHwgYyA9PT0gJy0nKSB7XG4gICAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgMSwgMiksIDEwKTtcbiAgICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgNCwgMiksIDEwKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIG9mZnNldCBpbiBtaWxsaXNlY29uZHNcbiAgICAgIHZhciBvZmZzZXQgPSBoaG9mZnNldCAqIDYwICsgbW1vZmZzZXQ7XG4gICAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAgIC8vIGFwcGx5IG9mZnNldFxuICAgICAgaWYoYyA9PT0gJysnKSB7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSAtIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogQHBhcmFtIGdlbnRpbWUgdGhlIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUuXG4gKi9cbmFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlID0gZnVuY3Rpb24oZ2VudGltZSkge1xuICAvKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgY2FuIGJlIHVzZWQ6XG5cbiAgICBZWVlZTU1EREhITU1TU1xuICAgIFlZWVlNTURESEhNTVNTLmZmZlxuICAgIFlZWVlNTURESEhNTVNTWlxuICAgIFlZWVlNTURESEhNTVNTLmZmZlpcbiAgICBZWVlZTU1EREhITU1TUytoaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy5mZmYraGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MtaGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MuZmZmLWhoJ21tJ1xuXG4gICAgV2hlcmU6XG5cbiAgICBZWVlZIGlzIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIC5mZmYgaXMgdGhlIHNlY29uZCBmcmFjdGlvbiwgYWNjdXJhdGUgdG8gdGhyZWUgZGVjaW1hbCBwbGFjZXNcbiAgICBaIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXMgR01ULCArIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXNcbiAgICBsYXRlciB0aGFuIEdNVCwgYW5kIC0gaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBlYXJsaWVyIHRoYW4gR01UXG4gICAgaGgnIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIGhvdXJzXG4gICAgbW0nIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIG1pbnV0ZXMgKi9cbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gIHZhciBZWVlZID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMCwgNCksIDEwKTtcbiAgdmFyIE1NID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoNCwgMiksIDEwKSAtIDE7IC8vIHVzZSAwLTExIGZvciBtb250aFxuICB2YXIgREQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig2LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig4LCAyKSwgMTApO1xuICB2YXIgbW0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgdmFyIHNzID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMTIsIDIpLCAxMCk7XG4gIHZhciBmZmYgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGlzVVRDID0gZmFsc2U7XG5cbiAgaWYoZ2VudGltZS5jaGFyQXQoZ2VudGltZS5sZW5ndGggLSAxKSA9PT0gJ1onKSB7XG4gICAgaXNVVEMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGVuZCA9IGdlbnRpbWUubGVuZ3RoIC0gNSwgYyA9IGdlbnRpbWUuY2hhckF0KGVuZCk7XG4gIGlmKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcbiAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICB2YXIgaGhvZmZzZXQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cihlbmQgKyAxLCAyKSwgMTApO1xuICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDQsIDIpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBpZihjID09PSAnKycpIHtcbiAgICAgIG9mZnNldCAqPSAtMTtcbiAgICB9XG5cbiAgICBpc1VUQyA9IHRydWU7XG4gIH1cblxuICAvLyBjaGVjayBmb3Igc2Vjb25kIGZyYWN0aW9uXG4gIGlmKGdlbnRpbWUuY2hhckF0KDE0KSA9PT0gJy4nKSB7XG4gICAgZmZmID0gcGFyc2VGbG9hdChnZW50aW1lLnN1YnN0cigxNCksIDEwKSAqIDEwMDA7XG4gIH1cblxuICBpZihpc1VUQykge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldEhvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkYXRlIHRvIGEgVVRDVGltZSB2YWx1ZS5cbiAqXG4gKiBOb3RlOiBHZW5lcmFsaXplZFRpbWUgaGFzIDQgZGlnaXRzIGZvciB0aGUgeWVhciBhbmQgaXMgdXNlZCBmb3IgWC41MDlcbiAqIGRhdGVzIHBhc3QgMjA0OS4gQ29udmVydGluZyB0byBhIEdlbmVyYWxpemVkVGltZSBoYXNuJ3QgYmVlblxuICogaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgVVRDVGltZSB2YWx1ZS5cbiAqL1xuYXNuMS5kYXRlVG9VdGNUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWU1NRERoaG1tc3NaXG4gIHZhciBmb3JtYXQgPSBbXTtcbiAgZm9ybWF0LnB1c2goKCcnICsgZGF0ZS5nZXRVVENGdWxsWWVhcigpKS5zdWJzdHIoMikpO1xuICBmb3JtYXQucHVzaCgnJyArIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDSG91cnMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENNaW51dGVzKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDU2Vjb25kcygpKTtcblxuICAvLyBlbnN1cmUgMiBkaWdpdHMgYXJlIHVzZWQgZm9yIGVhY2ggZm9ybWF0IGVudHJ5XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBmb3JtYXQubGVuZ3RoOyArK2kpIHtcbiAgICBpZihmb3JtYXRbaV0ubGVuZ3RoIDwgMikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gZm9ybWF0W2ldO1xuICB9XG4gIHJ2YWwgKz0gJ1onO1xuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gYSBHZW5lcmFsaXplZFRpbWUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBHZW5lcmFsaXplZFRpbWUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKi9cbmFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWVlZTU1EREhITU1TU1pcbiAgdmFyIGZvcm1hdCA9IFtdO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuXG4gIC8vIGVuc3VyZSAyIGRpZ2l0cyBhcmUgdXNlZCBmb3IgZWFjaCBmb3JtYXQgZW50cnlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBmb3JtYXRbaV07XG4gIH1cbiAgcnZhbCArPSAnWic7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgamF2YXNjcmlwdCBpbnRlZ2VyIHRvIGEgREVSLWVuY29kZWQgYnl0ZSBidWZmZXIgdG8gYmUgdXNlZFxuICogYXMgdGhlIHZhbHVlIGZvciBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIHggdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBidWZmZXIuXG4gKi9cbmFzbjEuaW50ZWdlclRvRGVyID0gZnVuY3Rpb24oeCkge1xuICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGlmKHggPj0gLTB4ODAgJiYgeCA8IDB4ODApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgOCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwICYmIHggPCAweDgwMDApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgMTYpO1xuICB9XG4gIGlmKHggPj0gLTB4ODAwMDAwICYmIHggPCAweDgwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAyNCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwMDAwMCAmJiB4IDwgMHg4MDAwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAzMik7XG4gIH1cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIGVycm9yLmludGVnZXIgPSB4O1xuICB0aHJvdyBlcnJvcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBieXRlIGJ1ZmZlciB0byBhIGphdmFzY3JpcHQgaW50ZWdlci4gVGhpcyBpc1xuICogdHlwaWNhbGx5IHVzZWQgdG8gZGVjb2RlIHRoZSB2YWx1ZSBvZiBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG5hc24xLmRlclRvSW50ZWdlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8vIHdyYXAgaW4gYnVmZmVyIGlmIG5lZWRlZFxuICBpZih0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gIH1cblxuICB2YXIgbiA9IGJ5dGVzLmxlbmd0aCgpICogODtcbiAgaWYobiA+IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLmdldFNpZ25lZEludChuKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGdpdmVuIEFTTi4xIG9iamVjdCBpcyBhdCBsZWFzdCBhIHN1cGVyIHNldCBvZiB0aGVcbiAqIGdpdmVuIEFTTi4xIHN0cnVjdHVyZS4gT25seSB0YWcgY2xhc3NlcyBhbmQgdHlwZXMgYXJlIGNoZWNrZWQuIEFuXG4gKiBvcHRpb25hbCBtYXAgbWF5IGFsc28gYmUgcHJvdmlkZWQgdG8gY2FwdHVyZSBBU04uMSB2YWx1ZXMgd2hpbGUgdGhlXG4gKiBzdHJ1Y3R1cmUgaXMgY2hlY2tlZC5cbiAqXG4gKiBUbyBjYXB0dXJlIGFuIEFTTi4xIHZhbHVlLCBzZXQgYW4gb2JqZWN0IGluIHRoZSB2YWxpZGF0b3IncyAnY2FwdHVyZSdcbiAqIHBhcmFtZXRlciB0byB0aGUga2V5IHRvIHVzZSBpbiB0aGUgY2FwdHVyZSBtYXAuIFRvIGNhcHR1cmUgdGhlIGZ1bGxcbiAqIEFTTi4xIG9iamVjdCwgc3BlY2lmeSAnY2FwdHVyZUFzbjEnLiBUbyBjYXB0dXJlIEJJVCBTVFJJTkcgYnl0ZXMsIGluY2x1ZGluZ1xuICogdGhlIGxlYWRpbmcgdW51c2VkIGJpdHMgY291bnRlciBieXRlLCBzcGVjaWZ5ICdjYXB0dXJlQml0U3RyaW5nQ29udGVudHMnLlxuICogVG8gY2FwdHVyZSBCSVQgU1RSSU5HIGJ5dGVzLCB3aXRob3V0IHRoZSBsZWFkaW5nIHVudXNlZCBiaXRzIGNvdW50ZXIgYnl0ZSxcbiAqIHNwZWNpZnkgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZScuXG4gKlxuICogT2JqZWN0cyBpbiB0aGUgdmFsaWRhdG9yIG1heSBzZXQgYSBmaWVsZCAnb3B0aW9uYWwnIHRvIHRydWUgdG8gaW5kaWNhdGVcbiAqIHRoYXQgaXQgaXNuJ3QgbmVjZXNzYXJ5IHRvIHBhc3MgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gdiB0aGUgQVNOLjEgc3RydWN0dXJlIHZhbGlkYXRvci5cbiAqIEBwYXJhbSBjYXB0dXJlIGFuIG9wdGlvbmFsIG1hcCB0byBjYXB0dXJlIHZhbHVlcyBpbi5cbiAqIEBwYXJhbSBlcnJvcnMgYW4gb3B0aW9uYWwgYXJyYXkgZm9yIHN0b3JpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gKi9cbmFzbjEudmFsaWRhdGUgPSBmdW5jdGlvbihvYmosIHYsIGNhcHR1cmUsIGVycm9ycykge1xuICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gIC8vIGVuc3VyZSB0YWcgY2xhc3MgYW5kIHR5cGUgYXJlIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICBpZigob2JqLnRhZ0NsYXNzID09PSB2LnRhZ0NsYXNzIHx8IHR5cGVvZih2LnRhZ0NsYXNzKSA9PT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgKG9iai50eXBlID09PSB2LnR5cGUgfHwgdHlwZW9mKHYudHlwZSkgPT09ICd1bmRlZmluZWQnKSkge1xuICAgIC8vIGVuc3VyZSBjb25zdHJ1Y3RlZCBmbGFnIGlzIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICAgIGlmKG9iai5jb25zdHJ1Y3RlZCA9PT0gdi5jb25zdHJ1Y3RlZCB8fFxuICAgICAgdHlwZW9mKHYuY29uc3RydWN0ZWQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcnZhbCA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBzdWIgdmFsdWVzXG4gICAgICBpZih2LnZhbHVlICYmIGZvcmdlLnV0aWwuaXNBcnJheSh2LnZhbHVlKSkge1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgJiYgaSA8IHYudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBydmFsID0gdi52YWx1ZVtpXS5vcHRpb25hbCB8fCBmYWxzZTtcbiAgICAgICAgICBpZihvYmoudmFsdWVbal0pIHtcbiAgICAgICAgICAgIHJ2YWwgPSBhc24xLnZhbGlkYXRlKG9iai52YWx1ZVtqXSwgdi52YWx1ZVtpXSwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHYudmFsdWVbaV0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgcnZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCFydmFsICYmIGVycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAgICAgICAnVGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIHR5cGUgXCInICtcbiAgICAgICAgICAgICAgdi50eXBlICsgJ1wiIGV4cGVjdGVkIHZhbHVlIGxlbmd0aCBcIicgK1xuICAgICAgICAgICAgICB2LnZhbHVlLmxlbmd0aCArICdcIiwgZ290IFwiJyArXG4gICAgICAgICAgICAgIG9iai52YWx1ZS5sZW5ndGggKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocnZhbCAmJiBjYXB0dXJlKSB7XG4gICAgICAgIGlmKHYuY2FwdHVyZSkge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlXSA9IG9iai52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVBc24xKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVBc24xXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50cyAmJiAnYml0U3RyaW5nQ29udGVudHMnIGluIG9iaikge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nQ29udGVudHNdID0gb2JqLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb2JqKSB7XG4gICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgIGlmKG9iai5iaXRTdHJpbmdDb250ZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCB1bnVzZWQgYml0cyB3aXRoIGRhdGEgc2hpZnRpbmdcbiAgICAgICAgICAgIHZhciB1bnVzZWQgPSBvYmouYml0U3RyaW5nQ29udGVudHMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmKHVudXNlZCAhPT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZSBvbmx5IHN1cHBvcnRlZCBmb3IgemVybyB1bnVzZWQgYml0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdWYWx1ZV0gPSBvYmouYml0U3RyaW5nQ29udGVudHMuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgY29uc3RydWN0ZWQgXCInICsgdi5jb25zdHJ1Y3RlZCArICdcIiwgZ290IFwiJyArXG4gICAgICAgIG9iai5jb25zdHJ1Y3RlZCArICdcIicpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgIGlmKG9iai50YWdDbGFzcyAhPT0gdi50YWdDbGFzcykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIGdvdCBcIicgK1xuICAgICAgICBvYmoudGFnQ2xhc3MgKyAnXCInKTtcbiAgICB9XG4gICAgaWYob2JqLnR5cGUgIT09IHYudHlwZSkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdHlwZSBcIicgKyB2LnR5cGUgKyAnXCIsIGdvdCBcIicgKyBvYmoudHlwZSArICdcIicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8vIHJlZ2V4IGZvciB0ZXN0aW5nIGZvciBub24tbGF0aW4gY2hhcmFjdGVyc1xudmFyIF9ub25MYXRpblJlZ2V4ID0gL1teXFxcXHUwMDAwLVxcXFx1MDBmZl0vO1xuXG4vKipcbiAqIFByZXR0eSBwcmludHMgYW4gQVNOLjEgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIG9iamVjdCB0byB3cml0ZSBvdXQuXG4gKiBAcGFyYW0gbGV2ZWwgdGhlIGxldmVsIGluIHRoZSB0cmVlLlxuICogQHBhcmFtIGluZGVudGF0aW9uIHRoZSBpbmRlbnRhdGlvbiB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nLlxuICovXG5hc24xLnByZXR0eVByaW50ID0gZnVuY3Rpb24ob2JqLCBsZXZlbCwgaW5kZW50YXRpb24pIHtcbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBzZXQgZGVmYXVsdCBsZXZlbCBhbmQgaW5kZW50YXRpb25cbiAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuICBpbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uIHx8IDI7XG5cbiAgLy8gc3RhcnQgbmV3IGxpbmUgZm9yIGRlZXAgbGV2ZWxzXG4gIGlmKGxldmVsID4gMCkge1xuICAgIHJ2YWwgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBjcmVhdGUgaW5kZW50XG4gIHZhciBpbmRlbnQgPSAnJztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxldmVsICogaW5kZW50YXRpb247ICsraSkge1xuICAgIGluZGVudCArPSAnICc7XG4gIH1cblxuICAvLyBwcmludCBjbGFzczp0eXBlXG4gIHJ2YWwgKz0gaW5kZW50ICsgJ1RhZzogJztcbiAgc3dpdGNoKG9iai50YWdDbGFzcykge1xuICBjYXNlIGFzbjEuQ2xhc3MuVU5JVkVSU0FMOlxuICAgIHJ2YWwgKz0gJ1VuaXZlcnNhbDonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuQVBQTElDQVRJT046XG4gICAgcnZhbCArPSAnQXBwbGljYXRpb246JztcbiAgICBicmVhaztcbiAgY2FzZSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUM6XG4gICAgcnZhbCArPSAnQ29udGV4dC1TcGVjaWZpYzonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuUFJJVkFURTpcbiAgICBydmFsICs9ICdQcml2YXRlOic7XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZihvYmoudGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMKSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcblxuICAgIC8vIGtub3duIHR5cGVzXG4gICAgc3dpdGNoKG9iai50eXBlKSB7XG4gICAgY2FzZSBhc24xLlR5cGUuTk9ORTpcbiAgICAgIHJ2YWwgKz0gJyAoTm9uZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk9PTEVBTjpcbiAgICAgIHJ2YWwgKz0gJyAoQm9vbGVhbiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSU5URUdFUjpcbiAgICAgIHJ2YWwgKz0gJyAoSW50ZWdlciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQklUU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCaXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PQ1RFVFNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoT2N0ZXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5OVUxMOlxuICAgICAgcnZhbCArPSAnIChOdWxsKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PSUQ6XG4gICAgICBydmFsICs9ICcgKE9iamVjdCBJZGVudGlmaWVyKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PREVTQzpcbiAgICAgIHJ2YWwgKz0gJyAoT2JqZWN0IERlc2NyaXB0b3IpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkVYVEVSTkFMOlxuICAgICAgcnZhbCArPSAnIChFeHRlcm5hbCBvciBJbnN0YW5jZSBvZiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUkVBTDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVhbCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU5VTUVSQVRFRDpcbiAgICAgIHJ2YWwgKz0gJyAoRW51bWVyYXRlZCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU1CRURERUQ6XG4gICAgICBydmFsICs9ICcgKEVtYmVkZGVkIFBEViknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRGODpcbiAgICAgIHJ2YWwgKz0gJyAoVVRGOCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUk9JRDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVsYXRpdmUgT2JqZWN0IElkZW50aWZpZXIpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlNFUVVFTkNFOlxuICAgICAgcnZhbCArPSAnIChTZXF1ZW5jZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuU0VUOlxuICAgICAgcnZhbCArPSAnIChTZXQpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoUHJpbnRhYmxlIFN0cmluZyknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSUE1U3RyaW5nOlxuICAgICAgcnZhbCArPSAnIChJQTVTdHJpbmcgKEFTQ0lJKSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRDVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoVVRDIHRpbWUpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoR2VuZXJhbGl6ZWQgdGltZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk1QU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCTVAgU3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcbiAgfVxuXG4gIHJ2YWwgKz0gJ1xcbic7XG4gIHJ2YWwgKz0gaW5kZW50ICsgJ0NvbnN0cnVjdGVkOiAnICsgb2JqLmNvbnN0cnVjdGVkICsgJ1xcbic7XG5cbiAgaWYob2JqLmNvbXBvc2VkKSB7XG4gICAgdmFyIHN1YnZhbHVlcyA9IDA7XG4gICAgdmFyIHN1YiA9ICcnO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKG9iai52YWx1ZVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YnZhbHVlcyArPSAxO1xuICAgICAgICBzdWIgKz0gYXNuMS5wcmV0dHlQcmludChvYmoudmFsdWVbaV0sIGxldmVsICsgMSwgaW5kZW50YXRpb24pO1xuICAgICAgICBpZigoaSArIDEpIDwgb2JqLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHN1YiArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcnZhbCArPSBpbmRlbnQgKyAnU3ViIHZhbHVlczogJyArIHN1YnZhbHVlcyArIHN1YjtcbiAgfSBlbHNlIHtcbiAgICBydmFsICs9IGluZGVudCArICdWYWx1ZTogJztcbiAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLk9JRCkge1xuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQob2JqLnZhbHVlKTtcbiAgICAgIHJ2YWwgKz0gb2lkO1xuICAgICAgaWYoZm9yZ2UucGtpICYmIGZvcmdlLnBraS5vaWRzKSB7XG4gICAgICAgIGlmKG9pZCBpbiBmb3JnZS5wa2kub2lkcykge1xuICAgICAgICAgIHJ2YWwgKz0gJyAoJyArIGZvcmdlLnBraS5vaWRzW29pZF0gKyAnKSAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuSU5URUdFUikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnZhbCArPSBhc24xLmRlclRvSW50ZWdlcihvYmoudmFsdWUpO1xuICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICAgIC8vIFRPRE86IHNoaWZ0IGJpdHMgYXMgbmVlZGVkIHRvIGRpc3BsYXkgd2l0aG91dCBwYWRkaW5nXG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyByZW1vdmUgdW51c2VkIGJpdHMgZmllbGRcbiAgICAgICAgcnZhbCArPSAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZS5zbGljZSgxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsICs9ICcobm9uZSknO1xuICAgICAgfVxuICAgICAgLy8gc2hvdyB1bnVzZWQgYml0IGNvdW50XG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdW51c2VkID0gb2JqLnZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmKHVudXNlZCA9PSAxKSB7XG4gICAgICAgICAgcnZhbCArPSAnICgxIHVudXNlZCBiaXQgc2hvd24pJztcbiAgICAgICAgfSBlbHNlIGlmKHVudXNlZCA+IDEpIHtcbiAgICAgICAgICBydmFsICs9ICcgKCcgKyB1bnVzZWQgKyAnIHVudXNlZCBiaXRzIHNob3duKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgaWYoIV9ub25MYXRpblJlZ2V4LnRlc3Qob2JqLnZhbHVlKSkge1xuICAgICAgICBydmFsICs9ICcoJyArIG9iai52YWx1ZSArICcpICc7XG4gICAgICB9XG4gICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICBydmFsICs9IGZvcmdlLnV0aWwuZGVjb2RlVXRmOChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORyB8fFxuICAgICAgb2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JQTVTdHJpbmcpIHtcbiAgICAgIHJ2YWwgKz0gb2JqLnZhbHVlO1xuICAgIH0gZWxzZSBpZihfbm9uTGF0aW5SZWdleC50ZXN0KG9iai52YWx1ZSkpIHtcbiAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBydmFsICs9ICdbbnVsbF0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsICs9IG9iai52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogT2JqZWN0IElEcyBmb3IgQVNOLjEuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG52YXIgb2lkcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLm9pZHMgPSBmb3JnZS5vaWRzID0gZm9yZ2Uub2lkcyB8fCB7fTtcblxuLy8gc2V0IGlkIHRvIG5hbWUgbWFwcGluZyBhbmQgbmFtZSB0byBpZCBtYXBwaW5nXG5mdW5jdGlvbiBfSU4oaWQsIG5hbWUpIHtcbiAgb2lkc1tpZF0gPSBuYW1lO1xuICBvaWRzW25hbWVdID0gaWQ7XG59XG4vLyBzZXQgaWQgdG8gbmFtZSBtYXBwaW5nIG9ubHlcbmZ1bmN0aW9uIF9JXyhpZCwgbmFtZSkge1xuICBvaWRzW2lkXSA9IG5hbWU7XG59XG5cbi8vIGFsZ29yaXRobSBPSURzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xJywgJ3JzYUVuY3J5cHRpb24nKTtcbi8vIE5vdGU6IG1kMiAmIG1kNCBub3QgaW1wbGVtZW50ZWRcbi8vX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMicsICdtZDJXaXRoUlNBRW5jcnlwdGlvbicpO1xuLy9fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4zJywgJ21kNFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS40JywgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS41JywgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuNycsICdSU0FFUy1PQUVQJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS44JywgJ21nZjEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjknLCAncFNwZWNpZmllZCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTAnLCAnUlNBU1NBLVBTUycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTEnLCAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEyJywgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMycsICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbicpO1xuXG5fSU4oJzEuMi44NDAuMTAwNDAuNC4zJywgJ2RzYS13aXRoLXNoYTEnKTtcblxuX0lOKCcxLjMuMTQuMy4yLjcnLCAnZGVzQ0JDJyk7XG5cbl9JTignMS4zLjE0LjMuMi4yNicsICdzaGExJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjEnLCAnc2hhMjU2Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjInLCAnc2hhMzg0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjMnLCAnc2hhNTEyJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuNScsICdtZDUnKTtcblxuLy8gcGtjcyM3IGNvbnRlbnQgdHlwZXNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjEnLCAnZGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuMicsICdzaWduZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy4zJywgJ2VudmVsb3BlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjQnLCAnc2lnbmVkQW5kRW52ZWxvcGVkRGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuNScsICdkaWdlc3RlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjYnLCAnZW5jcnlwdGVkRGF0YScpO1xuXG4vLyBwa2NzIzkgb2lkc1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMScsICdlbWFpbEFkZHJlc3MnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjInLCAndW5zdHJ1Y3R1cmVkTmFtZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMycsICdjb250ZW50VHlwZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNCcsICdtZXNzYWdlRGlnZXN0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS41JywgJ3NpZ25pbmdUaW1lJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS42JywgJ2NvdW50ZXJTaWduYXR1cmUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjcnLCAnY2hhbGxlbmdlUGFzc3dvcmQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjgnLCAndW5zdHJ1Y3R1cmVkQWRkcmVzcycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMTQnLCAnZXh0ZW5zaW9uUmVxdWVzdCcpO1xuXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMCcsICdmcmllbmRseU5hbWUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIxJywgJ2xvY2FsS2V5SWQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIyLjEnLCAneDUwOUNlcnRpZmljYXRlJyk7XG5cbi8vIHBrY3MjMTIgc2FmZSBiYWdzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4xJywgJ2tleUJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMicsICdwa2NzOFNocm91ZGVkS2V5QmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4zJywgJ2NlcnRCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjQnLCAnY3JsQmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS41JywgJ3NlY3JldEJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuNicsICdzYWZlQ29udGVudHNCYWcnKTtcblxuLy8gcGFzc3dvcmQtYmFzZWQtZW5jcnlwdGlvbiBmb3IgcGtjcyMxMlxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTMnLCAncGtjczVQQkVTMicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTInLCAncGtjczVQQktERjInKTtcblxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMScsICdwYmVXaXRoU0hBQW5kMTI4Qml0UkM0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS4yJywgJ3BiZVdpdGhTSEFBbmQ0MEJpdFJDNCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMycsICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS40JywgJ3BiZVdpdGhTSEFBbmQyLUtleVRyaXBsZURFUy1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjUnLCAncGJlV2l0aFNIQUFuZDEyOEJpdFJDMi1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjYnLCAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQycpO1xuXG4vLyBobWFjIE9JRHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMi43JywgJ2htYWNXaXRoU0hBMScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjgnLCAnaG1hY1dpdGhTSEEyMjQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi45JywgJ2htYWNXaXRoU0hBMjU2Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuMTAnLCAnaG1hY1dpdGhTSEEzODQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi4xMScsICdobWFjV2l0aFNIQTUxMicpO1xuXG4vLyBzeW1tZXRyaWMga2V5IGFsZ29yaXRobSBvaWRzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjMuNycsICdkZXMtRURFMy1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuMicsICdhZXMxMjgtQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjIyJywgJ2FlczE5Mi1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuNDInLCAnYWVzMjU2LUNCQycpO1xuXG4vLyBjZXJ0aWZpY2F0ZSBpc3N1ZXIvc3ViamVjdCBPSURzXG5fSU4oJzIuNS40LjMnLCAnY29tbW9uTmFtZScpO1xuX0lOKCcyLjUuNC41JywgJ3NlcmlhbE5hbWUnKTtcbl9JTignMi41LjQuNicsICdjb3VudHJ5TmFtZScpO1xuX0lOKCcyLjUuNC43JywgJ2xvY2FsaXR5TmFtZScpO1xuX0lOKCcyLjUuNC44JywgJ3N0YXRlT3JQcm92aW5jZU5hbWUnKTtcbl9JTignMi41LjQuMTAnLCAnb3JnYW5pemF0aW9uTmFtZScpO1xuX0lOKCcyLjUuNC4xMScsICdvcmdhbml6YXRpb25hbFVuaXROYW1lJyk7XG5fSU4oJzIuNS40LjEzJywgJ2Rlc2NyaXB0aW9uJyk7XG5cbi8vIFguNTA5IGV4dGVuc2lvbiBPSURzXG5fSU4oJzIuMTYuODQwLjEuMTEzNzMwLjEuMScsICduc0NlcnRUeXBlJyk7XG5fSV8oJzIuNS4yOS4xJywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zNVxuX0lfKCcyLjUuMjkuMicsICdrZXlBdHRyaWJ1dGVzJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS4zJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zMlxuX0lfKCcyLjUuMjkuNCcsICdrZXlVc2FnZVJlc3RyaWN0aW9uJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS41JywgJ3BvbGljeU1hcHBpbmcnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMzXG5fSV8oJzIuNS4yOS42JywgJ3N1YnRyZWVzQ29uc3RyYWludCcpOyAvLyBvYnNvbGV0ZSB1c2UgLjMwXG5fSV8oJzIuNS4yOS43JywgJ3N1YmplY3RBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xN1xuX0lfKCcyLjUuMjkuOCcsICdpc3N1ZXJBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xOFxuX0lfKCcyLjUuMjkuOScsICdzdWJqZWN0RGlyZWN0b3J5QXR0cmlidXRlcycpO1xuX0lfKCcyLjUuMjkuMTAnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JXygnMi41LjI5LjExJywgJ25hbWVDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzBcbl9JXygnMi41LjI5LjEyJywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zNlxuX0lfKCcyLjUuMjkuMTMnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JTignMi41LjI5LjE0JywgJ3N1YmplY3RLZXlJZGVudGlmaWVyJyk7XG5fSU4oJzIuNS4yOS4xNScsICdrZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuMTYnLCAncHJpdmF0ZUtleVVzYWdlUGVyaW9kJyk7XG5fSU4oJzIuNS4yOS4xNycsICdzdWJqZWN0QWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTgnLCAnaXNzdWVyQWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTknLCAnYmFzaWNDb25zdHJhaW50cycpO1xuX0lfKCcyLjUuMjkuMjAnLCAnY1JMTnVtYmVyJyk7XG5fSV8oJzIuNS4yOS4yMScsICdjUkxSZWFzb24nKTtcbl9JXygnMi41LjI5LjIyJywgJ2V4cGlyYXRpb25EYXRlJyk7XG5fSV8oJzIuNS4yOS4yMycsICdpbnN0cnVjdGlvbkNvZGUnKTtcbl9JXygnMi41LjI5LjI0JywgJ2ludmFsaWRpdHlEYXRlJyk7XG5fSV8oJzIuNS4yOS4yNScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMxXG5fSV8oJzIuNS4yOS4yNicsICdpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnQnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjI4XG5fSV8oJzIuNS4yOS4yNycsICdkZWx0YUNSTEluZGljYXRvcicpO1xuX0lfKCcyLjUuMjkuMjgnLCAnaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50Jyk7XG5fSV8oJzIuNS4yOS4yOScsICdjZXJ0aWZpY2F0ZUlzc3VlcicpO1xuX0lfKCcyLjUuMjkuMzAnLCAnbmFtZUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zMScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTtcbl9JTignMi41LjI5LjMyJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTtcbl9JXygnMi41LjI5LjMzJywgJ3BvbGljeU1hcHBpbmdzJyk7XG5fSV8oJzIuNS4yOS4zNCcsICdwb2xpY3lDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzZcbl9JTignMi41LjI5LjM1JywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTtcbl9JXygnMi41LjI5LjM2JywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zNycsICdleHRLZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuNDYnLCAnZnJlc2hlc3RDUkwnKTtcbl9JXygnMi41LjI5LjU0JywgJ2luaGliaXRBbnlQb2xpY3knKTtcblxuLy8gZXh0S2V5VXNhZ2UgcHVycG9zZXNcbl9JTignMS4zLjYuMS40LjEuMTExMjkuMi40LjInLCAndGltZXN0YW1wTGlzdCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjEuMScsICdhdXRob3JpdHlJbmZvQWNjZXNzJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy4xJywgJ3NlcnZlckF1dGgnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjInLCAnY2xpZW50QXV0aCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuMycsICdjb2RlU2lnbmluZycpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuNCcsICdlbWFpbFByb3RlY3Rpb24nKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjgnLCAndGltZVN0YW1waW5nJyk7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlIG1lc3NhZ2UgZGlnZXN0cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAyMDExLTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZCA9IGZvcmdlLm1kIHx8IHt9O1xuZm9yZ2UubWQuYWxnb3JpdGhtcyA9IGZvcmdlLm1kLmFsZ29yaXRobXMgfHwge307XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQW4gQVBJIGZvciBnZXR0aW5nIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gYnl0ZXMuIFRoZSBieXRlcyBhcmVcbiAqIGdlbmVyYXRlZCB1c2luZyB0aGUgRm9ydHVuYSBhbGdvcml0aG0gZGV2aXNlZCBieSBCcnVjZSBTY2huZWllciBhbmRcbiAqIE5pZWxzIEZlcmd1c29uLlxuICpcbiAqIEdldHRpbmcgc3Ryb25nIHJhbmRvbSBieXRlcyBpcyBub3QgeWV0IGVhc3kgdG8gZG8gaW4gamF2YXNjcmlwdC4gVGhlIG9ubHlcbiAqIHRydWlzaCByYW5kb20gZW50cm9weSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgaXMgZnJvbSB0aGUgbW91c2UsIGtleWJvYXJkLCBvclxuICogZnJvbSB0aW1pbmcgd2l0aCByZXNwZWN0IHRvIHBhZ2UgbG9hZHMsIGV0Yy4gVGhpcyBnZW5lcmF0b3IgbWFrZXMgYSBwb29yXG4gKiBhdHRlbXB0IGF0IHByb3ZpZGluZyByYW5kb20gYnl0ZXMgd2hlbiB0aG9zZSBzb3VyY2VzIGhhdmVuJ3QgeWV0IHByb3ZpZGVkXG4gKiBlbm91Z2ggZW50cm9weSB0byBpbml0aWFsbHkgc2VlZCBvciB0byByZXNlZWQgdGhlIFBSTkcuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnJhbmRvbSBhbHJlYWR5IGRlZmluZWRcbmlmKGZvcmdlLnJhbmRvbSAmJiBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG4gIHJldHVybjtcbn1cblxuKGZ1bmN0aW9uKGpRdWVyeSkge1xuXG4vLyB0aGUgZGVmYXVsdCBwcm5nIHBsdWdpbiwgdXNlcyBBRVMtMTI4XG52YXIgcHJuZ19hZXMgPSB7fTtcbnZhciBfcHJuZ19hZXNfb3V0cHV0ID0gbmV3IEFycmF5KDQpO1xudmFyIF9wcm5nX2Flc19idWZmZXIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xucHJuZ19hZXMuZm9ybWF0S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIGNvbnZlcnQgdGhlIGtleSBpbnRvIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgdG1wID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoa2V5KTtcbiAga2V5ID0gbmV3IEFycmF5KDQpO1xuICBrZXlbMF0gPSB0bXAuZ2V0SW50MzIoKTtcbiAga2V5WzFdID0gdG1wLmdldEludDMyKCk7XG4gIGtleVsyXSA9IHRtcC5nZXRJbnQzMigpO1xuICBrZXlbM10gPSB0bXAuZ2V0SW50MzIoKTtcblxuICAvLyByZXR1cm4gdGhlIGV4cGFuZGVkIGtleVxuICByZXR1cm4gZm9yZ2UuYWVzLl9leHBhbmRLZXkoa2V5LCBmYWxzZSk7XG59O1xucHJuZ19hZXMuZm9ybWF0U2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgLy8gY29udmVydCBzZWVkIGludG8gMzItYml0IGludGVnZXJzXG4gIHZhciB0bXAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzZWVkKTtcbiAgc2VlZCA9IG5ldyBBcnJheSg0KTtcbiAgc2VlZFswXSA9IHRtcC5nZXRJbnQzMigpO1xuICBzZWVkWzFdID0gdG1wLmdldEludDMyKCk7XG4gIHNlZWRbMl0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgc2VlZFszXSA9IHRtcC5nZXRJbnQzMigpO1xuICByZXR1cm4gc2VlZDtcbn07XG5wcm5nX2Flcy5jaXBoZXIgPSBmdW5jdGlvbihrZXksIHNlZWQpIHtcbiAgZm9yZ2UuYWVzLl91cGRhdGVCbG9jayhrZXksIHNlZWQsIF9wcm5nX2Flc19vdXRwdXQsIGZhbHNlKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzBdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzFdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzJdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzNdKTtcbiAgcmV0dXJuIF9wcm5nX2Flc19idWZmZXIuZ2V0Qnl0ZXMoKTtcbn07XG5wcm5nX2Flcy5pbmNyZW1lbnQgPSBmdW5jdGlvbihzZWVkKSB7XG4gIC8vIEZJWE1FOiBkbyB3ZSBjYXJlIGFib3V0IGNhcnJ5IG9yIHNpZ25lZCBpc3N1ZXM/XG4gICsrc2VlZFszXTtcbiAgcmV0dXJuIHNlZWQ7XG59O1xucHJuZ19hZXMubWQgPSBmb3JnZS5tZC5zaGEyNTY7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HLlxuICovXG5mdW5jdGlvbiBzcGF3blBybmcoKSB7XG4gIHZhciBjdHggPSBmb3JnZS5wcm5nLmNyZWF0ZShwcm5nX2Flcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgcmFuZG9tIGJ5dGVzLiBJZiBhIG5hdGl2ZSBzZWN1cmUgY3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZSwgdGhpc1xuICAgKiBtZXRob2QgdHJpZXMgdG8gbWFrZSB0aGUgYnl0ZXMgbW9yZSB1bnByZWRpY3RhYmxlIGJ5IGRyYXdpbmcgZnJvbSBkYXRhIHRoYXRcbiAgICogY2FuIGJlIGNvbGxlY3RlZCBmcm9tIHRoZSB1c2VyIG9mIHRoZSBicm93c2VyLCBlZzogbW91c2UgbW92ZW1lbnQuXG4gICAqXG4gICAqIElmIGEgY2FsbGJhY2sgaXMgZ2l2ZW4sIHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwgYnl0ZXMpXSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgcmFuZG9tIGJ5dGVzIGluIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGN0eC5nZW5lcmF0ZShjb3VudCwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHJhbmRvbSBieXRlcyBhc3luY2hyb25vdXNseS4gSWYgYSBuYXRpdmUgc2VjdXJlIGNyeXB0byBBUEkgaXNcbiAgICogdW5hdmFpbGFibGUsIHRoaXMgbWV0aG9kIHRyaWVzIHRvIG1ha2UgdGhlIGJ5dGVzIG1vcmUgdW5wcmVkaWN0YWJsZSBieVxuICAgKiBkcmF3aW5nIGZyb20gZGF0YSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgZnJvbSB0aGUgdXNlciBvZiB0aGUgYnJvd3NlcixcbiAgICogZWc6IG1vdXNlIG1vdmVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMgaW4gYSBzdHJpbmcuXG4gICAqL1xuICBjdHguZ2V0Qnl0ZXNTeW5jID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICByZXR1cm4gY3R4LmdlbmVyYXRlKGNvdW50KTtcbiAgfTtcblxuICByZXR1cm4gY3R4O1xufVxuXG4vLyBjcmVhdGUgZGVmYXVsdCBwcm5nIGNvbnRleHRcbnZhciBfY3R4ID0gc3Bhd25Qcm5nKCk7XG5cbi8vIGFkZCBvdGhlciBzb3VyY2VzIG9mIGVudHJvcHkgb25seSBpZiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpcyBub3Rcbi8vIGF2YWlsYWJsZSAtLSBvdGhlcndpc2UgdGhpcyBzb3VyY2Ugd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVzZWQgYnkgdGhlIHBybmdcbnZhciBnZXRSYW5kb21WYWx1ZXMgPSBudWxsO1xuaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIF9jcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcbiAgaWYoX2NyeXB0byAmJiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIGdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgfTtcbiAgfVxufVxuaWYoZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCB8fFxuICAoIWZvcmdlLnV0aWwuaXNOb2RlanMgJiYgIWdldFJhbmRvbVZhbHVlcykpIHtcbiAgLy8gaWYgdGhpcyBpcyBhIHdlYiB3b3JrZXIsIGRvIG5vdCB1c2Ugd2VhayBlbnRyb3B5LCBpbnN0ZWFkIHJlZ2lzdGVyIHRvXG4gIC8vIHJlY2VpdmUgc3Ryb25nIGVudHJvcHkgYXN5bmNocm9ub3VzbHkgZnJvbSB0aGUgbWFpbiB0aHJlYWRcbiAgaWYodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgd2luZG93LmRvY3VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBGSVhNRTpcbiAgfVxuXG4gIC8vIGdldCBsb2FkIHRpbWUgZW50cm9weVxuICBfY3R4LmNvbGxlY3RJbnQoK25ldyBEYXRlKCksIDMyKTtcblxuICAvLyBhZGQgc29tZSBlbnRyb3B5IGZyb20gbmF2aWdhdG9yIG9iamVjdFxuICBpZih0eXBlb2YobmF2aWdhdG9yKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgX25hdkJ5dGVzID0gJyc7XG4gICAgZm9yKHZhciBrZXkgaW4gbmF2aWdhdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZih0eXBlb2YobmF2aWdhdG9yW2tleV0pID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgX25hdkJ5dGVzICs9IG5hdmlnYXRvcltrZXldO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLyogU29tZSBuYXZpZ2F0b3Iga2V5cyBtaWdodCBub3QgYmUgYWNjZXNzaWJsZSwgZS5nLiB0aGUgZ2VvbG9jYXRpb25cbiAgICAgICAgICBhdHRyaWJ1dGUgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0b3VjaGVkIGluIE1vemlsbGEgY2hyb21lOi8vXG4gICAgICAgICAgY29udGV4dC5cblxuICAgICAgICAgIFNpbGVudGx5IGlnbm9yZSB0aGlzIGFuZCBqdXN0IGRvbid0IHVzZSB0aGlzIGFzIGEgc291cmNlIG9mXG4gICAgICAgICAgZW50cm9weS4gKi9cbiAgICAgIH1cbiAgICB9XG4gICAgX2N0eC5jb2xsZWN0KF9uYXZCeXRlcyk7XG4gICAgX25hdkJ5dGVzID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFkZCBtb3VzZSBhbmQga2V5Ym9hcmQgY29sbGVjdG9ycyBpZiBqcXVlcnkgaXMgYXZhaWxhYmxlXG4gIGlmKGpRdWVyeSkge1xuICAgIC8vIHNldCB1cCBtb3VzZSBlbnRyb3B5IGNhcHR1cmVcbiAgICBqUXVlcnkoKS5tb3VzZW1vdmUoZnVuY3Rpb24oZSkge1xuICAgICAgLy8gYWRkIG1vdXNlIGNvb3Jkc1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WCwgMTYpO1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WSwgMTYpO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IHVwIGtleWJvYXJkIGVudHJvcHkgY2FwdHVyZVxuICAgIGpRdWVyeSgpLmtleXByZXNzKGZ1bmN0aW9uKGUpIHtcbiAgICAgIF9jdHguY29sbGVjdEludChlLmNoYXJDb2RlLCA4KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiBSYW5kb20gQVBJICovXG5pZighZm9yZ2UucmFuZG9tKSB7XG4gIGZvcmdlLnJhbmRvbSA9IF9jdHg7XG59IGVsc2Uge1xuICAvLyBleHRlbmQgZm9yZ2UucmFuZG9tIHdpdGggX2N0eFxuICBmb3IodmFyIGtleSBpbiBfY3R4KSB7XG4gICAgZm9yZ2UucmFuZG9tW2tleV0gPSBfY3R4W2tleV07XG4gIH1cbn1cblxuLy8gZXhwb3NlIHNwYXduIFBSTkdcbmZvcmdlLnJhbmRvbS5jcmVhdGVJbnN0YW5jZSA9IHNwYXduUHJuZztcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG5cbn0pKHR5cGVvZihqUXVlcnkpICE9PSAndW5kZWZpbmVkJyA/IGpRdWVyeSA6IG51bGwpO1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgUlNBIGFsZ29yaXRobXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBvbmx5IGFsZ29yaXRobSBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBQS0kgaXMgUlNBLlxuICpcbiAqIEFuIFJTQSBrZXkgaXMgb2Z0ZW4gc3RvcmVkIGluIEFTTi4xIERFUiBmb3JtYXQuIFRoZSBTdWJqZWN0UHVibGljS2V5SW5mb1xuICogQVNOLjEgc3RydWN0dXJlIGlzIGNvbXBvc2VkIG9mIGFuIGFsZ29yaXRobSBvZiB0eXBlIEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIGFuZCBhIHN1YmplY3RQdWJsaWNLZXkgb2YgdHlwZSBiaXQgc3RyaW5nLlxuICpcbiAqIFRoZSBBbGdvcml0aG1JZGVudGlmaWVyIGNvbnRhaW5zIGFuIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIGFuZCBwYXJhbWV0ZXJzXG4gKiBmb3IgdGhlIGFsZ29yaXRobSwgaWYgYW55LiBJbiB0aGUgY2FzZSBvZiBSU0EsIHRoZXJlIGFyZW4ndCBhbnkuXG4gKlxuICogU3ViamVjdFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgYWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgQklUIFNUUklOR1xuICogfVxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRm9yIGFuIFJTQSBwdWJsaWMga2V5LCB0aGUgc3ViamVjdFB1YmxpY0tleSBpczpcbiAqXG4gKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAqICAgbW9kdWx1cyAgICAgICAgICAgIElOVEVHRVIsICAgIC0tIG5cbiAqICAgcHVibGljRXhwb25lbnQgICAgIElOVEVHRVIgICAgIC0tIGVcbiAqIH1cbiAqXG4gKiBQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIHByaXZhdGVLZXlBbGdvcml0aG0gICAgICAgUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHByaXZhdGVLZXkgICAgICAgICAgICAgICAgUHJpdmF0ZUtleSxcbiAqICAgYXR0cmlidXRlcyAgICAgICAgICAgWzBdICBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICogUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIFByaXZhdGVLZXkgOjo9IE9DVEVUIFNUUklOR1xuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEFuIFJTQSBwcml2YXRlIGtleSBhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiBSU0FQcml2YXRlS2V5IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gVmVyc2lvbixcbiAqICAgbW9kdWx1cyBJTlRFR0VSLCAtLSBuXG4gKiAgIHB1YmxpY0V4cG9uZW50IElOVEVHRVIsIC0tIGVcbiAqICAgcHJpdmF0ZUV4cG9uZW50IElOVEVHRVIsIC0tIGRcbiAqICAgcHJpbWUxIElOVEVHRVIsIC0tIHBcbiAqICAgcHJpbWUyIElOVEVHRVIsIC0tIHFcbiAqICAgZXhwb25lbnQxIElOVEVHRVIsIC0tIGQgbW9kIChwLTEpXG4gKiAgIGV4cG9uZW50MiBJTlRFR0VSLCAtLSBkIG1vZCAocS0xKVxuICogICBjb2VmZmljaWVudCBJTlRFR0VSIC0tIChpbnZlcnNlIG9mIHEpIG1vZCBwXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICpcbiAqIFRoZSBPSUQgZm9yIHRoZSBSU0Ega2V5IGFsZ29yaXRobSBpczogMS4yLjg0MC4xMTM1NDkuMS4xLjFcbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmlmKHR5cGVvZiBCaWdJbnRlZ2VyID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcjtcbn1cblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKlxuICogUlNBIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24sIHNlZSBSRkMgMjMxMy5cbiAqL1xuZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2kucnNhID0gZm9yZ2UucnNhID0gZm9yZ2UucnNhIHx8IHt9O1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gZm9yIGZpbmRpbmcgcHJpbWVzLCB3aGljaCBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgUHJpdmF0ZUtleUluZm8gc3RydWN0dXJlXG52YXIgcHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdQcml2YXRlS2V5SW5mby52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5VmVyc2lvbidcbiAgfSwge1xuICAgIC8vIHByaXZhdGVLZXlBbGdvcml0aG1cbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlPaWQnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIFByaXZhdGVLZXlcbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5J1xuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBSU0EgcHJpdmF0ZSBrZXlcbnZhciByc2FQcml2YXRlS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQcml2YXRlS2V5XG4gIG5hbWU6ICdSU0FQcml2YXRlS2V5JyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlWZXJzaW9uJ1xuICB9LCB7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5tb2R1bHVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5TW9kdWx1cydcbiAgfSwge1xuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnB1YmxpY0V4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHVibGljRXhwb25lbnQnXG4gIH0sIHtcbiAgICAvLyBwcml2YXRlRXhwb25lbnQgKGQpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHJpdmF0ZUV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHJpdmF0ZUV4cG9uZW50J1xuICB9LCB7XG4gICAgLy8gcHJpbWUxIChwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnByaW1lMScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVByaW1lMSdcbiAgfSwge1xuICAgIC8vIHByaW1lMiAocSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wcmltZTInLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQcmltZTInXG4gIH0sIHtcbiAgICAvLyBleHBvbmVudDEgKGQgbW9kIChwLTEpKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmV4cG9uZW50MScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUV4cG9uZW50MSdcbiAgfSwge1xuICAgIC8vIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkuZXhwb25lbnQyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5RXhwb25lbnQyJ1xuICB9LCB7XG4gICAgLy8gY29lZmZpY2llbnQgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmNvZWZmaWNpZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5Q29lZmZpY2llbnQnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcnNhUHVibGljS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgbmFtZTogJ1JTQVB1YmxpY0tleScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5Lm1vZHVsdXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3B1YmxpY0tleU1vZHVsdXMnXG4gIH0sIHtcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5LmV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwdWJsaWNLZXlFeHBvbmVudCdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gU3ViamVjdFB1YmxpY0tleUluZm8gc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcHVibGljS2V5VmFsaWRhdG9yID0gZm9yZ2UucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdzdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAncHVibGljS2V5T2lkJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXknLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIFJTQVB1YmxpY0tleVxuICAgICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXkuUlNBUHVibGljS2V5JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ3JzYVB1YmxpY0tleSdcbiAgICB9XVxuICB9XVxufTtcblxuLyoqXG4gKiBXcmFwIGRpZ2VzdCBpbiBEaWdlc3RJbmZvIG9iamVjdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgRU1TQS1QS0NTMS12MV81LUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcuXG4gKlxuICogRGlnZXN0SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBkaWdlc3RBbGdvcml0aG0gRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZGlnZXN0IERpZ2VzdFxuICogfVxuICpcbiAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSAocmVhZHkgZm9yIFJTQSBlbmNyeXRpb24pXG4gKi9cbnZhciBlbXNhUGtjczF2MTVlbmNvZGUgPSBmdW5jdGlvbihtZCkge1xuICAvLyBnZXQgdGhlIG9pZCBmb3IgdGhlIGFsZ29yaXRobVxuICB2YXIgb2lkO1xuICBpZihtZC5hbGdvcml0aG0gaW4gcGtpLm9pZHMpIHtcbiAgICBvaWQgPSBwa2kub2lkc1ttZC5hbGdvcml0aG1dO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gbWQuYWxnb3JpdGhtO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHZhciBvaWRCeXRlcyA9IGFzbjEub2lkVG9EZXIob2lkKS5nZXRCeXRlcygpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgZGlnZXN0IGluZm9cbiAgdmFyIGRpZ2VzdEluZm8gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHZhciBkaWdlc3RBbGdvcml0aG0gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIGRpZ2VzdEFsZ29yaXRobS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSwgb2lkQnl0ZXMpKTtcbiAgZGlnZXN0QWxnb3JpdGhtLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpKTtcbiAgdmFyIGRpZ2VzdCA9IGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgZmFsc2UsIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICBkaWdlc3RJbmZvLnZhbHVlLnB1c2goZGlnZXN0QWxnb3JpdGhtKTtcbiAgZGlnZXN0SW5mby52YWx1ZS5wdXNoKGRpZ2VzdCk7XG5cbiAgLy8gZW5jb2RlIGRpZ2VzdCBpbmZvXG4gIHJldHVybiBhc24xLnRvRGVyKGRpZ2VzdEluZm8pLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHheYyBtb2QgbiAoUlNBIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBvcGVyYXRpb24pLlxuICpcbiAqIEBwYXJhbSB4IHRoZSBudW1iZXIgdG8gcmFpc2UgYW5kIG1vZC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBwdWJsaWMsIGZhbHNlIGlmIHByaXZhdGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0IG9mIHheYyBtb2Qgbi5cbiAqL1xudmFyIF9tb2RQb3cgPSBmdW5jdGlvbih4LCBrZXksIHB1Yikge1xuICBpZihwdWIpIHtcbiAgICByZXR1cm4geC5tb2RQb3coa2V5LmUsIGtleS5uKTtcbiAgfVxuXG4gIGlmKCFrZXkucCB8fCAha2V5LnEpIHtcbiAgICAvLyBhbGxvdyBjYWxjdWxhdGlvbiB3aXRob3V0IENSVCBwYXJhbXMgKHNsb3cpXG4gICAgcmV0dXJuIHgubW9kUG93KGtleS5kLCBrZXkubik7XG4gIH1cblxuICAvLyBwcmUtY29tcHV0ZSBkUCwgZFEsIGFuZCBxSW52IGlmIG5lY2Vzc2FyeVxuICBpZigha2V5LmRQKSB7XG4gICAga2V5LmRQID0ga2V5LmQubW9kKGtleS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKSk7XG4gIH1cbiAgaWYoIWtleS5kUSkge1xuICAgIGtleS5kUSA9IGtleS5kLm1vZChrZXkucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpO1xuICB9XG4gIGlmKCFrZXkucUludikge1xuICAgIGtleS5xSW52ID0ga2V5LnEubW9kSW52ZXJzZShrZXkucCk7XG4gIH1cblxuICAvKiBDaGluZXNlIHJlbWFpbmRlciB0aGVvcmVtIChDUlQpIHN0YXRlczpcblxuICAgIFN1cHBvc2UgbjEsIG4yLCAuLi4sIG5rIGFyZSBwb3NpdGl2ZSBpbnRlZ2VycyB3aGljaCBhcmUgcGFpcndpc2VcbiAgICBjb3ByaW1lIChuMSBhbmQgbjIgaGF2ZSBubyBjb21tb24gZmFjdG9ycyBvdGhlciB0aGFuIDEpLiBGb3IgYW55XG4gICAgaW50ZWdlcnMgeDEsIHgyLCAuLi4sIHhrIHRoZXJlIGV4aXN0cyBhbiBpbnRlZ2VyIHggc29sdmluZyB0aGVcbiAgICBzeXN0ZW0gb2Ygc2ltdWx0YW5lb3VzIGNvbmdydWVuY2VzICh3aGVyZSB+PSBtZWFucyBtb2R1bGFybHlcbiAgICBjb25ncnVlbnQgc28gYSB+PSBiIG1vZCBuIG1lYW5zIGEgbW9kIG4gPSBiIG1vZCBuKTpcblxuICAgIHggfj0geDEgbW9kIG4xXG4gICAgeCB+PSB4MiBtb2QgbjJcbiAgICAuLi5cbiAgICB4IH49IHhrIG1vZCBua1xuXG4gICAgVGhpcyBzeXN0ZW0gb2YgY29uZ3J1ZW5jZXMgaGFzIGEgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4XG4gICAgYmV0d2VlbiAwIGFuZCBuIC0gMS4gRnVydGhlcm1vcmUsIGVhY2ggeGsgc29sdXRpb24gYW5kIHggaXRzZWxmXG4gICAgaXMgY29uZ3J1ZW50IG1vZHVsbyB0aGUgcHJvZHVjdCBuID0gbjEqbjIqLi4uKm5rLlxuICAgIFNvIHgxIG1vZCBuID0geDIgbW9kIG4gPSB4ayBtb2QgbiA9IHggbW9kIG4uXG5cbiAgICBUaGUgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4IGNhbiBiZSBzb2x2ZWQgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgZXF1YXRpb246XG5cbiAgICB4ID0gc3VtKHhpKnJpKnNpKSBtb2QgbiB3aGVyZSByaSA9IG4vbmkgYW5kIHNpID0gcmleLTEgbW9kIG5pLlxuXG4gICAgV2hlcmUgeCBpcyBsZXNzIHRoYW4gbiwgeGkgPSB4IG1vZCBuaS5cblxuICAgIEZvciBSU0Egd2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggayA9IDIuIFRoZSBtb2R1bHVzIG4gPSBwcSwgd2hlcmVcbiAgICBwIGFuZCBxIGFyZSBjb3ByaW1lLiBUaGUgUlNBIGRlY3J5cHRpb24gYWxnb3JpdGhtIGlzOlxuXG4gICAgeSA9IHheZCBtb2QgblxuXG4gICAgR2l2ZW4gdGhlIGFib3ZlOlxuXG4gICAgeDEgPSB4XmQgbW9kIHBcbiAgICByMSA9IG4vcCA9IHFcbiAgICBzMSA9IHFeLTEgbW9kIHBcbiAgICB4MiA9IHheZCBtb2QgcVxuICAgIHIyID0gbi9xID0gcFxuICAgIHMyID0gcF4tMSBtb2QgcVxuXG4gICAgU28geSA9ICh4MXIxczEgKyB4MnIyczIpIG1vZCBuXG4gICAgICAgICA9ICgoeF5kIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kIG1vZCBxKXAocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBBY2NvcmRpbmcgdG8gRmVybWF0J3MgTGl0dGxlIFRoZW9yZW0sIGlmIHRoZSBtb2R1bHVzIFAgaXMgcHJpbWUsXG4gICAgZm9yIGFueSBpbnRlZ2VyIEEgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgUCwgQV4oUC0xKSB+PSAxIG1vZCBQLlxuICAgIFNpbmNlIEEgaXMgbm90IGRpdmlzaWJsZSBieSBQIGl0IGZvbGxvd3MgdGhhdCBpZjpcbiAgICBOIH49IE0gbW9kIChQIC0gMSksIHRoZW4gQV5OIG1vZCBQID0gQV5NIG1vZCBQLiBUaGVyZWZvcmU6XG5cbiAgICBBXk4gbW9kIFAgPSBBXihNIG1vZCAoUCAtIDEpKSBtb2QgUC4gKFRoZSBsYXR0ZXIgdGFrZXMgbGVzcyBlZmZvcnRcbiAgICB0byBjYWxjdWxhdGUpLiBJbiBvcmRlciB0byBjYWxjdWxhdGUgeF5kIG1vZCBwIG1vcmUgcXVpY2tseSB0aGVcbiAgICBleHBvbmVudCBkIG1vZCAocCAtIDEpIGlzIHN0b3JlZCBpbiB0aGUgUlNBIHByaXZhdGUga2V5ICh0aGUgc2FtZVxuICAgIGlzIGRvbmUgZm9yIHheZCBtb2QgcSkuIFRoZXNlIHZhbHVlcyBhcmUgcmVmZXJyZWQgdG8gYXMgZFAgYW5kIGRRXG4gICAgcmVzcGVjdGl2ZWx5LiBUaGVyZWZvcmUgd2Ugbm93IGhhdmU6XG5cbiAgICB5ID0gKCh4XmRQIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kUSBtb2QgcSlwKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgU2luY2Ugd2UnbGwgYmUgcmVkdWNpbmcgeF5kUCBieSBtb2R1bG8gcCAoc2FtZSBmb3IgcSkgd2UgY2FuIGFsc29cbiAgICByZWR1Y2UgeCBieSBwIChhbmQgcSByZXNwZWN0aXZlbHkpIGJlZm9yZSBoYW5kLiBUaGVyZWZvcmUsIGxldFxuXG4gICAgeHAgPSAoKHggbW9kIHApXmRQIG1vZCBwKSwgYW5kXG4gICAgeHEgPSAoKHggbW9kIHEpXmRRIG1vZCBxKSwgeWllbGRpbmc6XG5cbiAgICB5ID0gKHhwKnEqKHFeLTEgbW9kIHApICsgeHEqcCoocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBUaGlzIGNhbiBiZSBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW1wbGUgYWxnb3JpdGhtIHRoYXQgb25seVxuICAgIHJlcXVpcmVzIDEgaW52ZXJzZSAodGhlIHEgaW52ZXJzZSBpcyB1c2VkKSB0byBiZSB1c2VkIGFuZCBzdG9yZWQuXG4gICAgVGhlIGFsZ29yaXRobSBpcyBjYWxsZWQgR2FybmVyJ3MgYWxnb3JpdGhtLiBJZiBxSW52IGlzIHRoZVxuICAgIGludmVyc2Ugb2YgcSwgd2Ugc2ltcGx5IGNhbGN1bGF0ZTpcblxuICAgIHkgPSAocUludiooeHAgLSB4cSkgbW9kIHApICogcSArIHhxXG5cbiAgICBIb3dldmVyLCB0aGVyZSBhcmUgdHdvIGZ1cnRoZXIgY29tcGxpY2F0aW9ucy4gRmlyc3QsIHdlIG5lZWQgdG9cbiAgICBlbnN1cmUgdGhhdCB4cCA+IHhxIHRvIHByZXZlbnQgc2lnbmVkIEJpZ0ludGVnZXJzIGZyb20gYmVpbmcgdXNlZFxuICAgIHNvIHdlIGFkZCBwIHVudGlsIHRoaXMgaXMgdHJ1ZSAoc2luY2Ugd2Ugd2lsbCBiZSBtb2QnaW5nIHdpdGhcbiAgICBwIGFueXdheSkuIFRoZW4sIHRoZXJlIGlzIGEga25vd24gdGltaW5nIGF0dGFjayBvbiBhbGdvcml0aG1zXG4gICAgdXNpbmcgdGhlIENSVC4gVG8gbWl0aWdhdGUgdGhpcyByaXNrLCBcImNyeXB0b2dyYXBoaWMgYmxpbmRpbmdcIlxuICAgIHNob3VsZCBiZSB1c2VkLiBUaGlzIHJlcXVpcmVzIHNpbXBseSBnZW5lcmF0aW5nIGEgcmFuZG9tIG51bWJlciByXG4gICAgYmV0d2VlbiAwIGFuZCBuLTEgYW5kIGl0cyBpbnZlcnNlIGFuZCBtdWx0aXBseWluZyB4IGJ5IHJeZSBiZWZvcmVcbiAgICBjYWxjdWxhdGluZyB5IGFuZCB0aGVuIG11bHRpcGx5aW5nIHkgYnkgcl4tMSBhZnRlcndhcmRzLiBOb3RlIHRoYXRcbiAgICByIG11c3QgYmUgY29wcmltZSB3aXRoIG4gKGdjZChyLCBuKSA9PT0gMSkgaW4gb3JkZXIgdG8gaGF2ZSBhblxuICAgIGludmVyc2UuXG4gICovXG5cbiAgLy8gY3J5cHRvZ3JhcGhpYyBibGluZGluZ1xuICB2YXIgcjtcbiAgZG8ge1xuICAgIHIgPSBuZXcgQmlnSW50ZWdlcihcbiAgICAgIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KSksXG4gICAgICAxNik7XG4gIH0gd2hpbGUoci5jb21wYXJlVG8oa2V5Lm4pID49IDAgfHwgIXIuZ2NkKGtleS5uKS5lcXVhbHMoQmlnSW50ZWdlci5PTkUpKTtcbiAgeCA9IHgubXVsdGlwbHkoci5tb2RQb3coa2V5LmUsIGtleS5uKSkubW9kKGtleS5uKTtcblxuICAvLyBjYWxjdWxhdGUgeHAgYW5kIHhxXG4gIHZhciB4cCA9IHgubW9kKGtleS5wKS5tb2RQb3coa2V5LmRQLCBrZXkucCk7XG4gIHZhciB4cSA9IHgubW9kKGtleS5xKS5tb2RQb3coa2V5LmRRLCBrZXkucSk7XG5cbiAgLy8geHAgbXVzdCBiZSBsYXJnZXIgdGhhbiB4cSB0byBhdm9pZCBzaWduZWQgYml0IHVzYWdlXG4gIHdoaWxlKHhwLmNvbXBhcmVUbyh4cSkgPCAwKSB7XG4gICAgeHAgPSB4cC5hZGQoa2V5LnApO1xuICB9XG5cbiAgLy8gZG8gbGFzdCBzdGVwXG4gIHZhciB5ID0geHAuc3VidHJhY3QoeHEpXG4gICAgLm11bHRpcGx5KGtleS5xSW52KS5tb2Qoa2V5LnApXG4gICAgLm11bHRpcGx5KGtleS5xKS5hZGQoeHEpO1xuXG4gIC8vIHJlbW92ZSBlZmZlY3Qgb2YgcmFuZG9tIGZvciBjcnlwdG9ncmFwaGljIGJsaW5kaW5nXG4gIHkgPSB5Lm11bHRpcGx5KHIubW9kSW52ZXJzZShrZXkubikpLm1vZChrZXkubik7XG5cbiAgcmV0dXJuIHk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnc2lnbicgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICdlbmNyeXB0JyBvbiBhIHB1YmxpYyBrZXkgb2JqZWN0IGluc3RlYWQuXG4gKlxuICogUGVyZm9ybXMgUlNBIGVuY3J5cHRpb24uXG4gKlxuICogVGhlIHBhcmFtZXRlciBidCBjb250cm9scyB3aGV0aGVyIHRvIHB1dCBwYWRkaW5nIGJ5dGVzIGJlZm9yZSB0aGVcbiAqIG1lc3NhZ2UgcGFzc2VkIGluLiBTZXQgYnQgdG8gZWl0aGVyIHRydWUgb3IgZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nXG4gKiBjb21wbGV0ZWx5IChpbiBvcmRlciB0byBoYW5kbGUgZS5nLiBFTVNBLVBTUyBlbmNvZGluZyBzZXBlcmF0ZWx5IGJlZm9yZSksXG4gKiBzaWduYWxpbmcgd2hldGhlciB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYSBwdWJsaWMga2V5IG9wZXJhdGlvblxuICogKGkuZS4gZW5jcnlwdGluZyBkYXRhKSBvciBub3QsIGkuZS4gcHJpdmF0ZSBrZXkgb3BlcmF0aW9uIChkYXRhIHNpZ25pbmcpLlxuICpcbiAqIEZvciBQS0NTIzEgdjEuNSBwYWRkaW5nIHBhc3MgaW4gdGhlIGJsb2NrIHR5cGUgdG8gdXNlLCBpLmUuIGVpdGhlciAweDAxXG4gKiAoZm9yIHNpZ25pbmcpIG9yIDB4MDIgKGZvciBlbmNyeXB0aW9uKS4gVGhlIGtleSBvcGVyYXRpb24gbW9kZSAocHJpdmF0ZVxuICogb3IgcHVibGljKSBpcyBkZXJpdmVkIGZyb20gdGhpcyBmbGFnIGluIHRoYXQgY2FzZSkuXG4gKlxuICogQHBhcmFtIG0gdGhlIG1lc3NhZ2UgdG8gZW5jcnlwdCBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gYnQgZm9yIFBLQ1MjMSB2MS41IHBhZGRpbmcsIHRoZSBibG9jayB0eXBlIHRvIHVzZVxuICogICAoMHgwMSBmb3IgcHJpdmF0ZSBrZXksIDB4MDIgZm9yIHB1YmxpYyksXG4gKiAgIHRvIGRpc2FibGUgcGFkZGluZzogdHJ1ZSA9IHB1YmxpYyBrZXksIGZhbHNlID0gcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgZW5jcnlwdGVkIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICovXG5wa2kucnNhLmVuY3J5cHQgPSBmdW5jdGlvbihtLCBrZXksIGJ0KSB7XG4gIHZhciBwdWIgPSBidDtcbiAgdmFyIGViO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgaWYoYnQgIT09IGZhbHNlICYmIGJ0ICE9PSB0cnVlKSB7XG4gICAgLy8gbGVnYWN5LCBkZWZhdWx0IHRvIFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAgICBwdWIgPSAoYnQgPT09IDB4MDIpO1xuICAgIGViID0gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCk7XG4gIH0gZWxzZSB7XG4gICAgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGViLnB1dEJ5dGVzKG0pO1xuICB9XG5cbiAgLy8gbG9hZCBlbmNyeXB0aW9uIGJsb2NrIGFzIGJpZyBpbnRlZ2VyICd4J1xuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB4ID0gbmV3IEJpZ0ludGVnZXIoZWIudG9IZXgoKSwgMTYpO1xuXG4gIC8vIGRvIFJTQSBlbmNyeXB0aW9uXG4gIHZhciB5ID0gX21vZFBvdyh4LCBrZXksIHB1Yik7XG5cbiAgLy8gY29udmVydCB5IGludG8gdGhlIGVuY3J5cHRlZCBkYXRhIGJ5dGUgc3RyaW5nLCBpZiB5IGlzIHNob3J0ZXIgaW5cbiAgLy8gYnl0ZXMgdGhhbiBrLCB0aGVuIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGVkXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHloZXggPSB5LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh5aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlZC5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWQucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHloZXgpKTtcbiAgcmV0dXJuIGVkLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnZGVjcnlwdCcgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICd2ZXJpZnknIG9uIGEgcHVibGljIGtleSBvYmplY3QgaW5zdGVhZC5cbiAqXG4gKiBQZXJmb3JtcyBSU0EgZGVjcnlwdGlvbi5cbiAqXG4gKiBUaGUgcGFyYW1ldGVyIG1sIGNvbnRyb2xzIHdoZXRoZXIgdG8gYXBwbHkgUEtDUyMxIHYxLjUgcGFkZGluZ1xuICogb3Igbm90LiAgU2V0IG1sID0gZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nIHJlbW92YWwgY29tcGxldGVseVxuICogKGluIG9yZGVyIHRvIGhhbmRsZSBlLmcuIEVNU0EtUFNTIGxhdGVyIG9uKSBhbmQgc2ltcGx5IHBhc3MgYmFja1xuICogdGhlIFJTQSBlbmNyeXB0aW9uIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBlZCB0aGUgZW5jcnlwdGVkIGRhdGEgdG8gZGVjcnlwdCBpbiBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgZm9yIGEgcHVibGljIGtleSBvcGVyYXRpb24sIGZhbHNlIGZvciBwcml2YXRlLlxuICogQHBhcmFtIG1sIHRoZSBtZXNzYWdlIGxlbmd0aCwgaWYga25vd24sIGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNyeXB0ZWQgbWVzc2FnZSBhcyBhIGJ5dGUgc3RyaW5nLlxuICovXG5wa2kucnNhLmRlY3J5cHQgPSBmdW5jdGlvbihlZCwga2V5LCBwdWIsIG1sKSB7XG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLy8gZXJyb3IgaWYgdGhlIGxlbmd0aCBvZiB0aGUgZW5jcnlwdGVkIGRhdGEgRUQgaXMgbm90IGtcbiAgaWYoZWQubGVuZ3RoICE9PSBrKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlZC5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWQgPSBrO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY29udmVydCBlbmNyeXB0ZWQgZGF0YSBpbnRvIGEgYmlnIGludGVnZXJcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeSA9IG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVkKS50b0hleCgpLCAxNik7XG5cbiAgLy8geSBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgbW9kdWx1cyBvciBpdCB3YXNuJ3QgdGhlIHJlc3VsdCBvZlxuICAvLyBhIHByZXZpb3VzIG1vZCBvcGVyYXRpb24gKGVuY3J5cHRpb24pIHVzaW5nIHRoYXQgbW9kdWx1c1xuICBpZih5LmNvbXBhcmVUbyhrZXkubikgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIC8vIGRvIFJTQSBkZWNyeXB0aW9uXG4gIHZhciB4ID0gX21vZFBvdyh5LCBrZXksIHB1Yik7XG5cbiAgLy8gY3JlYXRlIHRoZSBlbmNyeXB0aW9uIGJsb2NrLCBpZiB4IGlzIHNob3J0ZXIgaW4gYnl0ZXMgdGhhbiBrLCB0aGVuXG4gIC8vIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGViXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHhoZXggPSB4LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh4aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlYi5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWIucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHhoZXgpKTtcblxuICBpZihtbCAhPT0gZmFsc2UpIHtcbiAgICAvLyBsZWdhY3ksIGRlZmF1bHQgdG8gUEtDUyMxIHYxLjUgcGFkZGluZ1xuICAgIHJldHVybiBfZGVjb2RlUGtjczFfdjFfNShlYi5nZXRCeXRlcygpLCBrZXksIHB1Yik7XG4gIH1cblxuICAvLyByZXR1cm4gbWVzc2FnZVxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSU0Ega2V5LXBhaXIgZ2VuZXJhdGlvbiBzdGF0ZSBvYmplY3QuIEl0IGlzIHVzZWQgdG8gYWxsb3dcbiAqIGtleS1nZW5lcmF0aW9uIHRvIGJlIHBlcmZvcm1lZCBpbiBzdGVwcy4gSXQgYWxzbyBhbGxvd3MgZm9yIGEgVUkgdG9cbiAqIGRpc3BsYXkgcHJvZ3Jlc3MgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgc2l6ZSBmb3IgdGhlIHByaXZhdGUga2V5IGluIGJpdHMsIGRlZmF1bHRzIHRvIDIwNDguXG4gKiBAcGFyYW0gZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcgKDB4MTAwMDEpLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdGF0ZSBvYmplY3QgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBrZXktcGFpci5cbiAqL1xucGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlID0gZnVuY3Rpb24oYml0cywgZSwgb3B0aW9ucykge1xuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG5cbiAgLy8gc2V0IGRlZmF1bHQgYml0c1xuICBpZih0eXBlb2YoYml0cykgPT09ICdzdHJpbmcnKSB7XG4gICAgYml0cyA9IHBhcnNlSW50KGJpdHMsIDEwKTtcbiAgfVxuICBiaXRzID0gYml0cyB8fCAyMDQ4O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBwcm5nID0gb3B0aW9ucy5wcm5nIHx8IGZvcmdlLnJhbmRvbTtcbiAgdmFyIHJuZyA9IHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGIgPSBwcm5nLmdldEJ5dGVzU3luYyh4Lmxlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4W2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcblxuICAvLyBjcmVhdGUgUFJJTUVJTkMgYWxnb3JpdGhtIHN0YXRlXG4gIHZhciBydmFsO1xuICBpZihhbGdvcml0aG0gPT09ICdQUklNRUlOQycpIHtcbiAgICBydmFsID0ge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBzdGF0ZTogMCxcbiAgICAgIGJpdHM6IGJpdHMsXG4gICAgICBybmc6IHJuZyxcbiAgICAgIGVJbnQ6IGUgfHwgNjU1MzcsXG4gICAgICBlOiBuZXcgQmlnSW50ZWdlcihudWxsKSxcbiAgICAgIHA6IG51bGwsXG4gICAgICBxOiBudWxsLFxuICAgICAgcUJpdHM6IGJpdHMgPj4gMSxcbiAgICAgIHBCaXRzOiBiaXRzIC0gKGJpdHMgPj4gMSksXG4gICAgICBwcVN0YXRlOiAwLFxuICAgICAgbnVtOiBudWxsLFxuICAgICAga2V5czogbnVsbFxuICAgIH07XG4gICAgcnZhbC5lLmZyb21JbnQocnZhbC5lSW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IGdlbmVyYXRpb24gYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBydW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gZm9yIGF0IG1vc3QgbiBzZWNvbmRzXG4gKiAoYXBwcm94aW1hdGVseSkgdXNpbmcgdGhlIGdpdmVuIHN0YXRlLiBXaGVuIGtleS1nZW5lcmF0aW9uIGhhcyBjb21wbGV0ZWQsXG4gKiB0aGUga2V5cyB3aWxsIGJlIHN0b3JlZCBpbiBzdGF0ZS5rZXlzLlxuICpcbiAqIFRvIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIHVwZGF0ZSBhIFVJIHdoaWxlIGdlbmVyYXRpbmcgYSBrZXkgb3IgdG8gcHJldmVudFxuICogY2F1c2luZyBicm93c2VyIGxvY2t1cHMvd2FybmluZ3MsIHNldCBcIm5cIiB0byBhIHZhbHVlIG90aGVyIHRoYW4gMC4gQVxuICogc2ltcGxlIHBhdHRlcm4gZm9yIGdlbmVyYXRpbmcgYSBrZXkgYW5kIHNob3dpbmcgYSBwcm9ncmVzcyBpbmRpY2F0b3IgaXM6XG4gKlxuICogdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKDIwNDgpO1xuICogdmFyIHN0ZXAgPSBmdW5jdGlvbigpIHtcbiAqICAgLy8gc3RlcCBrZXktZ2VuZXJhdGlvbiwgcnVuIGFsZ29yaXRobSBmb3IgMTAwIG1zLCByZXBlYXRcbiAqICAgaWYoIWZvcmdlLnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUoc3RhdGUsIDEwMCkpIHtcbiAqICAgICBzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuICogICB9IGVsc2Uge1xuICogICAgIC8vIGtleS1nZW5lcmF0aW9uIGNvbXBsZXRlXG4gKiAgICAgLy8gVE9ETzogdHVybiBvZmYgcHJvZ3Jlc3MgaW5kaWNhdG9yIGhlcmVcbiAqICAgICAvLyBUT0RPOiB1c2UgdGhlIGdlbmVyYXRlZCBrZXktcGFpciBpbiBcInN0YXRlLmtleXNcIlxuICogICB9XG4gKiB9O1xuICogLy8gVE9ETzogdHVybiBvbiBwcm9ncmVzcyBpbmRpY2F0b3IgaGVyZVxuICogc2V0VGltZW91dChzdGVwLCAwKTtcbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIHVzZS5cbiAqIEBwYXJhbSBuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gcnVuIHRoZSBhbGdvcml0aG0gZm9yLCAwXG4gKiAgICAgICAgICB0byBydW4gdGhlIGFsZ29yaXRobSB0byBjb21wbGV0aW9uLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUga2V5LWdlbmVyYXRpb24gY29tcGxldGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbikge1xuICAvLyBzZXQgZGVmYXVsdCBhbGdvcml0aG0gaWYgbm90IHNldFxuICBpZighKCdhbGdvcml0aG0nIGluIHN0YXRlKSkge1xuICAgIHN0YXRlLmFsZ29yaXRobSA9ICdQUklNRUlOQyc7XG4gIH1cblxuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG4gIC8vIFRPRE86IGFic3RyYWN0IGFzIFBSSU1FSU5DIGFsZ29yaXRobVxuXG4gIC8vIGRvIGtleSBnZW5lcmF0aW9uIChiYXNlZCBvbiBUb20gV3UncyByc2EuanMsIHNlZSBqc2JuLmpzIGxpY2Vuc2UpXG4gIC8vIHdpdGggc29tZSBtaW5vciBvcHRpbWl6YXRpb25zIGFuZCBkZXNpZ25lZCB0byBydW4gaW4gc3RlcHNcblxuICAvLyBsb2NhbCBzdGF0ZSB2YXJzXG4gIHZhciBUSElSVFkgPSBuZXcgQmlnSW50ZWdlcihudWxsKTtcbiAgVEhJUlRZLmZyb21JbnQoMzApO1xuICB2YXIgZGVsdGFJZHggPSAwO1xuICB2YXIgb3Bfb3IgPSBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4fHk7IH07XG5cbiAgLy8ga2VlcCBzdGVwcGluZyB1bnRpbCB0aW1lIGxpbWl0IGlzIHJlYWNoZWQgb3IgZG9uZVxuICB2YXIgdDEgPSArbmV3IERhdGUoKTtcbiAgdmFyIHQyO1xuICB2YXIgdG90YWwgPSAwO1xuICB3aGlsZShzdGF0ZS5rZXlzID09PSBudWxsICYmIChuIDw9IDAgfHwgdG90YWwgPCBuKSkge1xuICAgIC8vIGdlbmVyYXRlIHAgb3IgcVxuICAgIGlmKHN0YXRlLnN0YXRlID09PSAwKSB7XG4gICAgICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybTpcblxuICAgICAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xLCB3aGVyZSB0aGVyZSBhcmUgOCB2YWx1ZXMgZm9yIGlcblxuICAgICAgICBXaGVuIHdlIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciwgd2UgYWx3YXlzIGFsaWduIGl0IGF0IDMwayArIDEuIEVhY2hcbiAgICAgICAgdGltZSB0aGUgbnVtYmVyIGlzIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlXG4gICAgICAgIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlciB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgICAgIHZhciBiaXRzID0gKHN0YXRlLnAgPT09IG51bGwpID8gc3RhdGUucEJpdHMgOiBzdGF0ZS5xQml0cztcbiAgICAgIHZhciBiaXRzMSA9IGJpdHMgLSAxO1xuXG4gICAgICAvLyBnZXQgYSByYW5kb20gbnVtYmVyXG4gICAgICBpZihzdGF0ZS5wcVN0YXRlID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHN0YXRlLnJuZyk7XG4gICAgICAgIC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgaWYoIXN0YXRlLm51bS50ZXN0Qml0KGJpdHMxKSkge1xuICAgICAgICAgIHN0YXRlLm51bS5iaXR3aXNlVG8oXG4gICAgICAgICAgICBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYml0czEpLCBvcF9vciwgc3RhdGUubnVtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGlnbiBudW1iZXIgb24gMzBrKzEgYm91bmRhcnlcbiAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoMzEgLSBzdGF0ZS5udW0ubW9kKFRISVJUWSkuYnl0ZVZhbHVlKCksIDApO1xuICAgICAgICBkZWx0YUlkeCA9IDA7XG5cbiAgICAgICAgKytzdGF0ZS5wcVN0YXRlO1xuICAgICAgfSBlbHNlIGlmKHN0YXRlLnBxU3RhdGUgPT09IDEpIHtcbiAgICAgICAgLy8gdHJ5IHRvIG1ha2UgdGhlIG51bWJlciBhIHByaW1lXG4gICAgICAgIGlmKHN0YXRlLm51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgICAgICAvLyBvdmVyZmxvdywgdHJ5IGFnYWluXG4gICAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgICAgLy8gZG8gcHJpbWFsaXR5IHRlc3RcbiAgICAgICAgfSBlbHNlIGlmKHN0YXRlLm51bS5pc1Byb2JhYmxlUHJpbWUoXG4gICAgICAgICAgX2dldE1pbGxlclJhYmluVGVzdHMoc3RhdGUubnVtLmJpdExlbmd0aCgpKSkpIHtcbiAgICAgICAgICArK3N0YXRlLnBxU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0IG5leHQgcG90ZW50aWFsIHByaW1lXG4gICAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoR0NEXzMwX0RFTFRBW2RlbHRhSWR4KysgJSA4XSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5wcVN0YXRlID09PSAyKSB7XG4gICAgICAgIC8vIGVuc3VyZSBudW1iZXIgaXMgY29wcmltZSB3aXRoIGVcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9XG4gICAgICAgICAgKHN0YXRlLm51bS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAgICAgLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT09IDApID8gMyA6IDA7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMykge1xuICAgICAgICAvLyBzdG9yZSBwIG9yIHFcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgIGlmKHN0YXRlLnAgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5wID0gc3RhdGUubnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIHN0YXRlIGlmIGJvdGggcCBhbmQgcSBhcmUgcmVhZHlcbiAgICAgICAgaWYoc3RhdGUucCAhPT0gbnVsbCAmJiBzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5udW0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gMSkge1xuICAgICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBzdGF0ZS5wO1xuICAgICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgICAgc3RhdGUucSA9IHN0YXRlLm51bTtcbiAgICAgIH1cbiAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSAyKSB7XG4gICAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICBzdGF0ZS5xMSA9IHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIGVuc3VyZSBlIGFuZCBwaGkgYXJlIGNvcHJpbWVcbiAgICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PT0gMCkge1xuICAgICAgICAvLyBwaGkgYW5kIGUgYXJlIGNvcHJpbWUsIGFkdmFuY2VcbiAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBoaSBhbmQgZSBhcmVuJ3QgY29wcmltZSwgc28gZ2VuZXJhdGUgYSBuZXcgcCBhbmQgcVxuICAgICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDQpIHtcbiAgICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcblxuICAgICAgLy8gZW5zdXJlIG4gaXMgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICAgIGlmKHN0YXRlLm4uYml0TGVuZ3RoKCkgPT09IHN0YXRlLmJpdHMpIHtcbiAgICAgICAgLy8gc3VjY2VzcywgYWR2YW5jZVxuICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDUpIHtcbiAgICAgIC8vIHNldCBrZXlzXG4gICAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgICAgc3RhdGUua2V5cyA9IHtcbiAgICAgICAgcHJpdmF0ZUtleTogcGtpLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgICAgc3RhdGUucS5tb2RJbnZlcnNlKHN0YXRlLnApKSxcbiAgICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGltaW5nXG4gICAgdDIgPSArbmV3IERhdGUoKTtcbiAgICB0b3RhbCArPSB0MiAtIHQxO1xuICAgIHQxID0gdDI7XG4gIH1cblxuICByZXR1cm4gc3RhdGUua2V5cyAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIFJTQSBwdWJsaWMtcHJpdmF0ZSBrZXkgcGFpciBpbiBhIHNpbmdsZSBjYWxsLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgaW4gc3RlcHMgKHRvIGFsbG93IGZvciBwcm9ncmVzcyB1cGRhdGVzIGFuZCB0b1xuICogcHJldmVudCBibG9ja2luZyBvciB3YXJuaW5ncyBpbiBzbG93IGJyb3dzZXJzKSB0aGVuIHVzZSB0aGUga2V5LXBhaXJcbiAqIGdlbmVyYXRpb24gc3RhdGUgZnVuY3Rpb25zLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgYXN5bmNocm9ub3VzbHkgKGVpdGhlciB0aHJvdWdoIHdlYi13b3JrZXJzLCBpZlxuICogYXZhaWxhYmxlLCBvciBieSBicmVha2luZyB1cCB0aGUgd29yayBvbiB0aGUgbWFpbiB0aHJlYWQpLCBwYXNzIGFcbiAqIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBbYml0c10gdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIFtlXSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb24sIGlmIGdpdmVuIHRoZW4gJ2JpdHMnXG4gKiAgICAgICAgICBhbmQgJ2UnIG11c3QgKm5vdCogYmUgZ2l2ZW46XG4gKiAgICAgICAgICBiaXRzIHRoZSBzaXplIGZvciB0aGUgcHJpdmF0ZSBrZXkgaW4gYml0cywgKGRlZmF1bHQ6IDIwNDgpLlxuICogICAgICAgICAgZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgKGRlZmF1bHQ6IDY1NTM3ICgweDEwMDAxKSkuXG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIpLlxuICogICAgICAgICAgd29ya0xvYWQgdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgICAgICBudW1iZXJzIGZvciBlYWNoIHdlYiB3b3JrZXIgdG8gY2hlY2sgcGVyIHdvcmsgYXNzaWdubWVudCxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXlwYWlyKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKlxuICogQHJldHVybiBhbiBvYmplY3Qgd2l0aCBwcml2YXRlS2V5IGFuZCBwdWJsaWNLZXkgcHJvcGVydGllcy5cbiAqL1xucGtpLnJzYS5nZW5lcmF0ZUtleVBhaXIgPSBmdW5jdGlvbihiaXRzLCBlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyAoYml0cyksIChvcHRpb25zKSwgKGNhbGxiYWNrKVxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYodHlwZW9mIGJpdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0gYml0cztcbiAgICAgIGJpdHMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBiaXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGJpdHM7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyAoYml0cywgZSksIChiaXRzLCBvcHRpb25zKSwgKGJpdHMsIGNhbGxiYWNrKSwgKG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIGlmKHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgaWYodHlwZW9mIGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBlO1xuICAgICAgICBlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmKHR5cGVvZiBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICBvcHRpb25zID0gZTtcbiAgICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGJpdHM7XG4gICAgICBjYWxsYmFjayA9IGU7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgLy8gKGJpdHMsIGUsIG9wdGlvbnMpLCAoYml0cywgZSwgY2FsbGJhY2spLCAoYml0cywgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgaWYodHlwZW9mIGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBlO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKGJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGJpdHMgPSBvcHRpb25zLmJpdHMgfHwgMjA0ODtcbiAgfVxuICBpZihlID09PSB1bmRlZmluZWQpIHtcbiAgICBlID0gb3B0aW9ucy5lIHx8IDB4MTAwMDE7XG4gIH1cblxuICAvLyBpZiBuYXRpdmUgY29kZSBpcyBwZXJtaXR0ZWQgYW5kIGEgY2FsbGJhY2sgaXMgZ2l2ZW4sIHVzZSBuYXRpdmVcbiAgLy8ga2V5IGdlbmVyYXRpb24gY29kZSBpZiBhdmFpbGFibGUgYW5kIGlmIHBhcmFtZXRlcnMgYXJlIGFjY2VwdGFibGVcbiAgaWYoIWZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQgJiYgY2FsbGJhY2sgJiZcbiAgICBiaXRzID49IDI1NiAmJiBiaXRzIDw9IDE2Mzg0ICYmIChlID09PSAweDEwMDAxIHx8IGUgPT09IDMpKSB7XG4gICAgaWYoX2RldGVjdFN1YnRsZUNyeXB0bygnZ2VuZXJhdGVLZXknKSAmJiBfZGV0ZWN0U3VidGxlQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgLy8gdXNlIHN0YW5kYXJkIG5hdGl2ZSBnZW5lcmF0ZUtleVxuICAgICAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgcHVibGljRXhwb25lbnQ6IF9pbnRUb1VpbnQ4QXJyYXkoZSksXG4gICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9XG4gICAgICB9LCB0cnVlIC8qIGtleSBjYW4gYmUgZXhwb3J0ZWQqLywgWydzaWduJywgJ3ZlcmlmeSddKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocGFpcikge1xuICAgICAgICByZXR1cm4gd2luZG93LmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdwa2NzOCcsIHBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAvLyBhdm9pZGluZyBjYXRjaChmdW5jdGlvbihlcnIpIHsuLi59KSB0byBzdXBwb3J0IElFIDw9IDhcbiAgICAgIH0pLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocGtjczgpIHtcbiAgICAgICAgaWYocGtjczgpIHtcbiAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoXG4gICAgICAgICAgICBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGtjczgpKSk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGtpLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmKF9kZXRlY3RTdWJ0bGVNc0NyeXB0bygnZ2VuZXJhdGVLZXknKSAmJlxuICAgICAgX2RldGVjdFN1YnRsZU1zQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgdmFyIGdlbk9wID0gd2luZG93Lm1zQ3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgIHB1YmxpY0V4cG9uZW50OiBfaW50VG9VaW50OEFycmF5KGUpLFxuICAgICAgICBoYXNoOiB7bmFtZTogJ1NIQS0yNTYnfVxuICAgICAgfSwgdHJ1ZSAvKiBrZXkgY2FuIGJlIGV4cG9ydGVkKi8sIFsnc2lnbicsICd2ZXJpZnknXSk7XG4gICAgICBnZW5PcC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgcGFpciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgdmFyIGV4cG9ydE9wID0gd2luZG93Lm1zQ3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXG4gICAgICAgICAgJ3BrY3M4JywgcGFpci5wcml2YXRlS2V5KTtcbiAgICAgICAgZXhwb3J0T3Aub25jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgcGtjczggPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKFxuICAgICAgICAgICAgYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHBrY3M4KSkpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBraS5zZXRSc2FQdWJsaWNLZXkocHJpdmF0ZUtleS5uLCBwcml2YXRlS2V5LmUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGV4cG9ydE9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGdlbk9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25cbiAgdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKGJpdHMsIGUsIG9wdGlvbnMpO1xuICBpZighY2FsbGJhY2spIHtcbiAgICBwa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlKHN0YXRlLCAwKTtcbiAgICByZXR1cm4gc3RhdGUua2V5cztcbiAgfVxuICBfZ2VuZXJhdGVLZXlQYWlyKHN0YXRlLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gUlNBIHB1YmxpYyBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzIGFuZCBleHBvbmVudC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbW9kdWx1cy5cbiAqIEBwYXJhbSBlIHRoZSBleHBvbmVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kuc2V0UnNhUHVibGljS2V5ID0gcGtpLnJzYS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbihuLCBlKSB7XG4gIHZhciBrZXkgPSB7XG4gICAgbjogbixcbiAgICBlOiBlXG4gIH07XG5cbiAgLyoqXG4gICAqIEVuY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwdWJsaWMga2V5LiBOZXdlciBhcHBsaWNhdGlvbnNcbiAgICogc2hvdWxkIHVzZSB0aGUgJ1JTQS1PQUVQJyBkZWNyeXB0aW9uIHNjaGVtZSwgJ1JTQUVTLVBLQ1MxLVYxXzUnIGlzIGZvclxuICAgKiBsZWdhY3kgYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgYnl0ZSBzdHJpbmcgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgZW5jcnlwdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBRVMtUEtDUzEtVjFfNScgKGRlZmF1bHQpLFxuICAgKiAgICAgICAgICAnUlNBLU9BRVAnLFxuICAgKiAgICAgICAgICAnUkFXJywgJ05PTkUnLCBvciBudWxsIHRvIHBlcmZvcm0gcmF3IFJTQSBlbmNyeXB0aW9uLFxuICAgKiAgICAgICAgICBhbiBvYmplY3Qgd2l0aCBhbiAnZW5jb2RlJyBwcm9wZXJ0eSBzZXQgdG8gYSBmdW5jdGlvblxuICAgKiAgICAgICAgICB3aXRoIHRoZSBzaWduYXR1cmUgJ2Z1bmN0aW9uKGRhdGEsIGtleSknIHRoYXQgcmV0dXJuc1xuICAgKiAgICAgICAgICBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVuY29kZWQgZGF0YS5cbiAgICogQHBhcmFtIHNjaGVtZU9wdGlvbnMgYW55IHNjaGVtZS1zcGVjaWZpYyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBlbmNyeXB0ZWQgYnl0ZSBzdHJpbmcuXG4gICAqL1xuICBrZXkuZW5jcnlwdCA9IGZ1bmN0aW9uKGRhdGEsIHNjaGVtZSwgc2NoZW1lT3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjaGVtZSA9ICdSU0FFUy1QS0NTMS1WMV81JztcbiAgICB9XG5cbiAgICBpZihzY2hlbWUgPT09ICdSU0FFUy1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uKG0sIGtleSwgcHViKSB7XG4gICAgICAgICAgcmV0dXJuIF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgMHgwMikuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24obSwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmVuY29kZV9yc2Ffb2FlcChrZXksIG0sIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7IGVuY29kZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gZTsgfSB9O1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRvIHNjaGVtZS1iYXNlZCBlbmNvZGluZyB0aGVuIHJzYSBlbmNyeXB0aW9uXG4gICAgdmFyIGUgPSBzY2hlbWUuZW5jb2RlKGRhdGEsIGtleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChlLCBrZXksIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFnYWluc3QgdGhlIGdpdmVuIGRpZ2VzdC5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSwgaW4gd2hpY2ggY2FzZSBvbmNlIFJTQS1kZWNyeXB0ZWQsIHRoZVxuICAgKiBzaWduYXR1cmUgaXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaG9sZHMgYSBEaWdlc3RJbmZvLlxuICAgKlxuICAgKiBEaWdlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gICAqICAgZGlnZXN0IERpZ2VzdFxuICAgKiB9XG4gICAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAgICpcbiAgICogVG8gcGVyZm9ybSBQU1Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiwgcHJvdmlkZSBhbiBpbnN0YW5jZVxuICAgKiBvZiBGb3JnZSBQU1Mgb2JqZWN0IGFzIHRoZSBzY2hlbWUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gZGlnZXN0IHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLFxuICAgKiAgICAgICAgICBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBzY2hlbWUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBU1NBLVBLQ1MxLVYxXzUnIG9yIHVuZGVmaW5lZCBmb3IgUlNBU1NBIFBLQ1MjMSB2MS41LFxuICAgKiAgICAgICAgICBhIEZvcmdlIFBTUyBvYmplY3QgZm9yIFJTQVNTQS1QU1MsXG4gICAqICAgICAgICAgICdOT05FJyBvciBudWxsIGZvciBub25lLCBEaWdlc3RJbmZvIHdpbGwgbm90IGJlIGV4cGVjdGVkLCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICAga2V5LnZlcmlmeSA9IGZ1bmN0aW9uKGRpZ2VzdCwgc2lnbmF0dXJlLCBzY2hlbWUpIHtcbiAgICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgc2NoZW1lID0gJ1JTQVNTQS1QS0NTMS1WMV81JztcbiAgICAgfVxuXG4gICAgIGlmKHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgIC8vIHJlbW92ZSBwYWRkaW5nXG4gICAgICAgICAgIGQgPSBfZGVjb2RlUGtjczFfdjFfNShkLCBrZXksIHRydWUpO1xuICAgICAgICAgICAvLyBkIGlzIEFTTi4xIEJFUi1lbmNvZGVkIERpZ2VzdEluZm9cbiAgICAgICAgICAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihkKTtcbiAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgZ2l2ZW4gZGlnZXN0IHRvIHRoZSBkZWNyeXB0ZWQgb25lXG4gICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IG9iai52YWx1ZVsxXS52YWx1ZTtcbiAgICAgICAgIH1cbiAgICAgICB9O1xuICAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnTk9ORScgfHwgc2NoZW1lID09PSAnTlVMTCcgfHwgc2NoZW1lID09PSBudWxsKSB7XG4gICAgICAgc2NoZW1lID0ge1xuICAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbihkaWdlc3QsIGQpIHtcbiAgICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICAgZCA9IF9kZWNvZGVQa2NzMV92MV81KGQsIGtleSwgdHJ1ZSk7XG4gICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IGQ7XG4gICAgICAgICB9XG4gICAgICAgfTtcbiAgICAgfVxuXG4gICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmcsIHRoZW4gdmVyaWZ5IC0tIHdoaWNoIGRvZXMgZGVjb2RpbmdcbiAgICAgdmFyIGQgPSBwa2kucnNhLmRlY3J5cHQoc2lnbmF0dXJlLCBrZXksIHRydWUsIGZhbHNlKTtcbiAgICAgcmV0dXJuIHNjaGVtZS52ZXJpZnkoZGlnZXN0LCBkLCBrZXkubi5iaXRMZW5ndGgoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBSU0EgcHJpdmF0ZSBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzLCBleHBvbmVudCwgcHJpbWVzLFxuICogcHJpbWUgZXhwb25lbnRzLCBhbmQgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBtb2R1bHVzLlxuICogQHBhcmFtIGUgdGhlIHB1YmxpYyBleHBvbmVudC5cbiAqIEBwYXJhbSBkIHRoZSBwcml2YXRlIGV4cG9uZW50ICgoaW52ZXJzZSBvZiBlKSBtb2QgbikuXG4gKiBAcGFyYW0gcCB0aGUgZmlyc3QgcHJpbWUuXG4gKiBAcGFyYW0gcSB0aGUgc2Vjb25kIHByaW1lLlxuICogQHBhcmFtIGRQIGV4cG9uZW50MSAoZCBtb2QgKHAtMSkpLlxuICogQHBhcmFtIGRRIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpLlxuICogQHBhcmFtIHFJbnYgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kuc2V0UnNhUHJpdmF0ZUtleSA9IHBraS5yc2Euc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uKFxuICBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnYpIHtcbiAgdmFyIGtleSA9IHtcbiAgICBuOiBuLFxuICAgIGU6IGUsXG4gICAgZDogZCxcbiAgICBwOiBwLFxuICAgIHE6IHEsXG4gICAgZFA6IGRQLFxuICAgIGRROiBkUSxcbiAgICBxSW52OiBxSW52XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwcml2YXRlIGtleS4gVGhlIGRlY3J5cHRpb24gc2NoZW1lXG4gICAqIG11c3QgbWF0Y2ggdGhlIG9uZSB1c2VkIHRvIGVuY3J5cHQgdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBieXRlIHN0cmluZyB0byBkZWNyeXB0LlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBkZWNyeXB0aW9uIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FFUy1QS0NTMS1WMV81JyAoZGVmYXVsdCksXG4gICAqICAgICAgICAgICdSU0EtT0FFUCcsXG4gICAqICAgICAgICAgICdSQVcnLCAnTk9ORScsIG9yIG51bGwgdG8gcGVyZm9ybSByYXcgUlNBIGRlY3J5cHRpb24uXG4gICAqIEBwYXJhbSBzY2hlbWVPcHRpb25zIGFueSBzY2hlbWUtc3BlY2lmaWMgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZGVjcnlwdGVkIGJ5dGUgc3RyaW5nLlxuICAgKi9cbiAga2V5LmRlY3J5cHQgPSBmdW5jdGlvbihkYXRhLCBzY2hlbWUsIHNjaGVtZU9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2hlbWUgPSAnUlNBRVMtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgLy8gZG8gcnNhIGRlY3J5cHRpb24gdy9vIGFueSBkZWNvZGluZ1xuICAgIHZhciBkID0gcGtpLnJzYS5kZWNyeXB0KGRhdGEsIGtleSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIGlmKHNjaGVtZSA9PT0gJ1JTQUVTLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7IGRlY29kZTogX2RlY29kZVBrY3MxX3YxXzUgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24oZCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmRlY29kZV9yc2Ffb2FlcChrZXksIGQsIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7IGRlY29kZTogZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lOiBcIicgKyBzY2hlbWUgKyAnXCIuJyk7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIGFjY29yZGluZyB0byBzY2hlbWVcbiAgICByZXR1cm4gc2NoZW1lLmRlY29kZShkLCBrZXksIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhlIGdpdmVuIGRpZ2VzdCwgcHJvZHVjaW5nIGEgc2lnbmF0dXJlLlxuICAgKlxuICAgKiBQS0NTIzEgc3VwcG9ydHMgbXVsdGlwbGUgKGN1cnJlbnRseSB0d28pIHNpZ25hdHVyZSBzY2hlbWVzOlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSBhbmQgUlNBU1NBLVBTUy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIFwib2xkIHNjaGVtZVwiLCBpLmUuXG4gICAqIFJTQVNTQS1QS0NTMS1WMV81LiBJbiBvcmRlciB0byBnZW5lcmF0ZSBhIFBTUyBzaWduYXR1cmUsIHByb3ZpZGVcbiAgICogYW4gaW5zdGFuY2Ugb2YgRm9yZ2UgUFNTIG9iamVjdCBhcyB0aGUgc2NoZW1lIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBzaWduYXR1cmUgc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQVNTQS1QS0NTMS1WMV81JyBvciB1bmRlZmluZWQgZm9yIFJTQVNTQSBQS0NTIzEgdjEuNSxcbiAgICogICAgICAgICAgYSBGb3JnZSBQU1Mgb2JqZWN0IGZvciBSU0FTU0EtUFNTLFxuICAgKiAgICAgICAgICAnTk9ORScgb3IgbnVsbCBmb3Igbm9uZSwgRGlnZXN0SW5mbyB3aWxsIG5vdCBiZSB1c2VkIGJ1dFxuICAgKiAgICAgICAgICAgIFBLQ1MjMSB2MS41IHBhZGRpbmcgd2lsbCBzdGlsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBzaWduYXR1cmUgYXMgYSBieXRlIHN0cmluZy5cbiAgICovXG4gIGtleS5zaWduID0gZnVuY3Rpb24obWQsIHNjaGVtZSkge1xuICAgIC8qIE5vdGU6IFRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBSU0Egb3BlcmF0aW9ucyBpcyBiZWluZ1xuICAgICAgdHJhbnNpdGlvbmVkIGF3YXkgZnJvbSBhIFBLQ1MjMSB2MS41IGhhcmQtY29kZWQgc2NoZW1lLiBTb21lIGxlZ2FjeVxuICAgICAgY29kZSBsaWtlIHRoZSB1c2Ugb2YgYW4gZW5jb2RpbmcgYmxvY2sgaWRlbnRpZmllciAnYnQnIHdpbGwgZXZlbnR1YWxseVxuICAgICAgYmUgcmVtb3ZlZC4gKi9cblxuICAgIC8vIHByaXZhdGUga2V5IG9wZXJhdGlvblxuICAgIHZhciBidCA9IGZhbHNlO1xuXG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkIHx8IHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0geyBlbmNvZGU6IGVtc2FQa2NzMXYxNWVuY29kZSB9O1xuICAgICAgYnQgPSAweDAxO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdOT05FJyB8fCBzY2hlbWUgPT09ICdOVUxMJyB8fCBzY2hlbWUgPT09IG51bGwpIHtcbiAgICAgIHNjaGVtZSA9IHsgZW5jb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIG1kOyB9IH07XG4gICAgICBidCA9IDB4MDE7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIGFuZCB0aGVuIGVuY3J5cHRcbiAgICB2YXIgZCA9IHNjaGVtZS5lbmNvZGUobWQsIGtleS5uLmJpdExlbmd0aCgpKTtcbiAgICByZXR1cm4gcGtpLnJzYS5lbmNyeXB0KGQsIGtleSwgYnQpO1xuICB9O1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFdyYXBzIGFuIFJTQVByaXZhdGVLZXkgQVNOLjEgb2JqZWN0IGluIGFuIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kud3JhcFJzYVByaXZhdGVLZXkgPSBmdW5jdGlvbihyc2FLZXkpIHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uICgwKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcigwKS5nZXRCeXRlcygpKSxcbiAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgIF0pLFxuICAgIC8vIFByaXZhdGVLZXlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgIGFzbjEudG9EZXIocnNhS2V5KS5nZXRCeXRlcygpKVxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByaXZhdGUga2V5IGZyb20gYW4gQVNOLjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGEgUHJpdmF0ZUtleUluZm8gY29udGFpbmluZyBhblxuICogICAgICAgICAgUlNBUHJpdmF0ZUtleSBvciBhbiBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUZyb21Bc24xID0gZnVuY3Rpb24ob2JqKSB7XG4gIC8vIGdldCBQcml2YXRlS2V5SW5mb1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKGFzbjEudmFsaWRhdGUob2JqLCBwcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgb2JqID0gYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleSkpO1xuICB9XG5cbiAgLy8gZ2V0IFJTQVByaXZhdGVLZXlcbiAgY2FwdHVyZSA9IHt9O1xuICBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2FQcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYW4gUlNBUHJpdmF0ZUtleS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBOb3RlOiBWZXJzaW9uIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuICAvLyBjYXB0dXJlLnByaXZhdGVLZXlWZXJzaW9uXG4gIC8vIEZJWE1FOiBpbmVmZmljaWVudCwgZ2V0IGEgQmlnSW50ZWdlciB0aGF0IHVzZXMgYnl0ZSBzdHJpbmdzXG4gIHZhciBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnY7XG4gIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlNb2R1bHVzKS50b0hleCgpO1xuICBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5UHVibGljRXhwb25lbnQpLnRvSGV4KCk7XG4gIGQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcml2YXRlRXhwb25lbnQpLnRvSGV4KCk7XG4gIHAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTEpLnRvSGV4KCk7XG4gIHEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTIpLnRvSGV4KCk7XG4gIGRQID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5RXhwb25lbnQxKS50b0hleCgpO1xuICBkUSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUV4cG9uZW50MikudG9IZXgoKTtcbiAgcUludiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUNvZWZmaWNpZW50KS50b0hleCgpO1xuXG4gIC8vIHNldCBwcml2YXRlIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVByaXZhdGVLZXkoXG4gICAgbmV3IEJpZ0ludGVnZXIobiwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGUsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKHEsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkUCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGRRLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocUludiwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwcml2YXRlIGtleSB0byBhbiBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGFuIFJTQVByaXZhdGVLZXkuXG4gKi9cbnBraS5wcml2YXRlS2V5VG9Bc24xID0gcGtpLnByaXZhdGVLZXlUb1JTQVByaXZhdGVLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gUlNBUHJpdmF0ZUtleVxuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIHZlcnNpb24gKDAgPSBvbmx5IDIgcHJpbWVzLCAxIG11bHRpcGxlIHByaW1lcylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkubikpLFxuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5lKSksXG4gICAgLy8gcHJpdmF0ZUV4cG9uZW50IChkKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kKSksXG4gICAgLy8gcHJpdmF0ZUtleVByaW1lMSAocClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucCkpLFxuICAgIC8vIHByaXZhdGVLZXlQcmltZTIgKHEpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LnEpKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQxIChkUClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFApKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQyIChkUSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFEpKSxcbiAgICAvLyBjb2VmZmljaWVudCAocUludilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucUludikpXG4gIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgZnJvbSBhbiBBU04uMSBTdWJqZWN0UHVibGljS2V5SW5mbyBvciBSU0FQdWJsaWNLZXkuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvIG9yIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgLy8gZ2V0IFN1YmplY3RQdWJsaWNLZXlJbmZvXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoYXNuMS52YWxpZGF0ZShvYmosIHB1YmxpY0tleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIC8vIGdldCBvaWRcbiAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gICAgaWYob2lkICE9PSBwa2kub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIFVua25vd24gT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIG9iaiA9IGNhcHR1cmUucnNhUHVibGljS2V5O1xuICB9XG5cbiAgLy8gZ2V0IFJTQSBwYXJhbXNcbiAgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgcnNhUHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQdWJsaWNLZXkuJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gRklYTUU6IGluZWZmaWNpZW50LCBnZXQgYSBCaWdJbnRlZ2VyIHRoYXQgdXNlcyBieXRlIHN0cmluZ3NcbiAgdmFyIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnB1YmxpY0tleU1vZHVsdXMpLnRvSGV4KCk7XG4gIHZhciBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wdWJsaWNLZXlFeHBvbmVudCkudG9IZXgoKTtcblxuICAvLyBzZXQgcHVibGljIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVB1YmxpY0tleShcbiAgICBuZXcgQmlnSW50ZWdlcihuLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZSwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICovXG5wa2kucHVibGljS2V5VG9Bc24xID0gcGtpLnB1YmxpY0tleVRvU3ViamVjdFB1YmxpY0tleUluZm8gPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMucnNhRW5jcnlwdGlvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgXSksXG4gICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgW1xuICAgICAgcGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSlcbiAgICBdKVxuICBdKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBSU0FQdWJsaWNLZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1JTQVB1YmxpY0tleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5uKSksXG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmUpKVxuICBdKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gbSB0aGUgbWVzc2FnZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBidCB0aGUgYmxvY2sgdHlwZSB0byB1c2UsIGkuZS4gZWl0aGVyIDB4MDEgKGZvciBzaWduaW5nKSBvciAweDAyXG4gKiAgICAgICAgICAoZm9yIGVuY3J5cHRpb24pLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhZGRlZCBieXRlIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCkge1xuICB2YXIgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgKi9cbiAgaWYobS5sZW5ndGggPiAoayAtIDExKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyBmb3IgUEtDUyMxIHYxLjUgcGFkZGluZy4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBtLmxlbmd0aDtcbiAgICBlcnJvci5tYXggPSBrIC0gMTE7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvKiBBIGJsb2NrIHR5cGUgQlQsIGEgcGFkZGluZyBzdHJpbmcgUFMsIGFuZCB0aGUgZGF0YSBEIHNoYWxsIGJlXG4gICAgZm9ybWF0dGVkIGludG8gYW4gb2N0ZXQgc3RyaW5nIEVCLCB0aGUgZW5jcnlwdGlvbiBibG9jazpcblxuICAgIEVCID0gMDAgfHwgQlQgfHwgUFMgfHwgMDAgfHwgRFxuXG4gICAgVGhlIGJsb2NrIHR5cGUgQlQgc2hhbGwgYmUgYSBzaW5nbGUgb2N0ZXQgaW5kaWNhdGluZyB0aGUgc3RydWN0dXJlIG9mXG4gICAgdGhlIGVuY3J5cHRpb24gYmxvY2suIEZvciB0aGlzIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50IGl0IHNoYWxsIGhhdmVcbiAgICB2YWx1ZSAwMCwgMDEsIG9yIDAyLiBGb3IgYSBwcml2YXRlLWtleSBvcGVyYXRpb24sIHRoZSBibG9jayB0eXBlXG4gICAgc2hhbGwgYmUgMDAgb3IgMDEuIEZvciBhIHB1YmxpYy1rZXkgb3BlcmF0aW9uLCBpdCBzaGFsbCBiZSAwMi5cblxuICAgIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBzaGFsbCBjb25zaXN0IG9mIGstMy18fER8fCBvY3RldHMuIEZvciBibG9ja1xuICAgIHR5cGUgMDAsIHRoZSBvY3RldHMgc2hhbGwgaGF2ZSB2YWx1ZSAwMDsgZm9yIGJsb2NrIHR5cGUgMDEsIHRoZXlcbiAgICBzaGFsbCBoYXZlIHZhbHVlIEZGOyBhbmQgZm9yIGJsb2NrIHR5cGUgMDIsIHRoZXkgc2hhbGwgYmVcbiAgICBwc2V1ZG9yYW5kb21seSBnZW5lcmF0ZWQgYW5kIG5vbnplcm8uIFRoaXMgbWFrZXMgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBlbmNyeXB0aW9uIGJsb2NrIEVCIGVxdWFsIHRvIGsuICovXG5cbiAgLy8gYnVpbGQgdGhlIGVuY3J5cHRpb24gYmxvY2tcbiAgZWIucHV0Qnl0ZSgweDAwKTtcbiAgZWIucHV0Qnl0ZShidCk7XG5cbiAgLy8gY3JlYXRlIHRoZSBwYWRkaW5nXG4gIHZhciBwYWROdW0gPSBrIC0gMyAtIG0ubGVuZ3RoO1xuICB2YXIgcGFkQnl0ZTtcbiAgLy8gcHJpdmF0ZSBrZXkgb3BcbiAgaWYoYnQgPT09IDB4MDAgfHwgYnQgPT09IDB4MDEpIHtcbiAgICBwYWRCeXRlID0gKGJ0ID09PSAweDAwKSA/IDB4MDAgOiAweEZGO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgZWIucHV0Qnl0ZShwYWRCeXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcHVibGljIGtleSBvcFxuICAgIC8vIHBhZCB3aXRoIHJhbmRvbSBub24temVybyB2YWx1ZXNcbiAgICB3aGlsZShwYWROdW0gPiAwKSB7XG4gICAgICB2YXIgbnVtWmVyb3MgPSAwO1xuICAgICAgdmFyIHBhZEJ5dGVzID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKHBhZE51bSk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFkTnVtOyArK2kpIHtcbiAgICAgICAgcGFkQnl0ZSA9IHBhZEJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmKHBhZEJ5dGUgPT09IDApIHtcbiAgICAgICAgICArK251bVplcm9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGViLnB1dEJ5dGUocGFkQnl0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhZE51bSA9IG51bVplcm9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIHplcm8gZm9sbG93ZWQgYnkgbWVzc2FnZVxuICBlYi5wdXRCeXRlKDB4MDApO1xuICBlYi5wdXRCeXRlcyhtKTtcblxuICByZXR1cm4gZWI7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gZW0gdGhlIG1lc3NhZ2UgdG8gZGVjb2RlLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBhIHB1YmxpYyBrZXksIGZhbHNlIGlmIGl0IGlzIHByaXZhdGUuXG4gKiBAcGFyYW0gbWwgdGhlIG1lc3NhZ2UgbGVuZ3RoLCBpZiBzcGVjaWZpZWQuXG4gKlxuICogQHJldHVybiB0aGUgZGVjb2RlZCBieXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZVBrY3MxX3YxXzUoZW0sIGtleSwgcHViLCBtbCkge1xuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIC8qIEl0IGlzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgb2NjdXJzOlxuXG4gICAgMS4gVGhlIGVuY3J5cHRpb24gYmxvY2sgRUIgY2Fubm90IGJlIHBhcnNlZCB1bmFtYmlndW91c2x5LlxuICAgIDIuIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBjb25zaXN0cyBvZiBmZXdlciB0aGFuIGVpZ2h0IG9jdGV0c1xuICAgICAgb3IgaXMgaW5jb25zaXNlbnQgd2l0aCB0aGUgYmxvY2sgdHlwZSBCVC5cbiAgICAzLiBUaGUgZGVjcnlwdGlvbiBwcm9jZXNzIGlzIGEgcHVibGljLWtleSBvcGVyYXRpb24gYW5kIHRoZSBibG9ja1xuICAgICAgdHlwZSBCVCBpcyBub3QgMDAgb3IgMDEsIG9yIHRoZSBkZWNyeXB0aW9uIHByb2Nlc3MgaXMgYVxuICAgICAgcHJpdmF0ZS1rZXkgb3BlcmF0aW9uIGFuZCB0aGUgYmxvY2sgdHlwZSBpcyBub3QgMDIuXG4gICAqL1xuXG4gIC8vIHBhcnNlIHRoZSBlbmNyeXB0aW9uIGJsb2NrXG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVtKTtcbiAgdmFyIGZpcnN0ID0gZWIuZ2V0Qnl0ZSgpO1xuICB2YXIgYnQgPSBlYi5nZXRCeXRlKCk7XG4gIGlmKGZpcnN0ICE9PSAweDAwIHx8XG4gICAgKHB1YiAmJiBidCAhPT0gMHgwMCAmJiBidCAhPT0gMHgwMSkgfHxcbiAgICAoIXB1YiAmJiBidCAhPSAweDAyKSB8fFxuICAgIChwdWIgJiYgYnQgPT09IDB4MDAgJiYgdHlwZW9mKG1sKSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICB2YXIgcGFkTnVtID0gMDtcbiAgaWYoYnQgPT09IDB4MDApIHtcbiAgICAvLyBjaGVjayBhbGwgcGFkZGluZyBieXRlcyBmb3IgMHgwMFxuICAgIHBhZE51bSA9IGsgLSAzIC0gbWw7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICBpZihlYi5nZXRCeXRlKCkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDEpIHtcbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBieXRlIHRoYXQgaXNuJ3QgMHhGRiwgc2hvdWxkIGJlIGFmdGVyIGFsbCBwYWRkaW5nXG4gICAgcGFkTnVtID0gMDtcbiAgICB3aGlsZShlYi5sZW5ndGgoKSA+IDEpIHtcbiAgICAgIGlmKGViLmdldEJ5dGUoKSAhPT0gMHhGRikge1xuICAgICAgICAtLWViLnJlYWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgKytwYWROdW07XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDIpIHtcbiAgICAvLyBsb29rIGZvciAweDAwIGJ5dGVcbiAgICBwYWROdW0gPSAwO1xuICAgIHdoaWxlKGViLmxlbmd0aCgpID4gMSkge1xuICAgICAgaWYoZWIuZ2V0Qnl0ZSgpID09PSAweDAwKSB7XG4gICAgICAgIC0tZWIucmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BhZE51bTtcbiAgICB9XG4gIH1cblxuICAvLyB6ZXJvIG11c3QgYmUgMHgwMCBhbmQgcGFkTnVtIG11c3QgYmUgKGsgLSAzIC0gbWVzc2FnZSBsZW5ndGgpXG4gIHZhciB6ZXJvID0gZWIuZ2V0Qnl0ZSgpO1xuICBpZih6ZXJvICE9PSAweDAwIHx8IHBhZE51bSAhPT0gKGsgLSAzIC0gZWIubGVuZ3RoKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gYXN5bmNocm9ub3VzbHksIGVpdGhlciBpbiB0aGUgYmFja2dyb3VuZFxuICogdmlhIFdlYiBXb3JrZXJzLCBvciB1c2luZyB0aGUgbWFpbiB0aHJlYWQgYW5kIHNldEltbWVkaWF0ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGtleS1wYWlyIGdlbmVyYXRpb24gc3RhdGUuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb246XG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIsIC0xIHRvIHVzZSBlc3RpbWF0ZWQgY29yZXMgbWludXMgb25lKS5cbiAqICAgICAgICAgIHdvcmtMb2FkIHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgICAgICAgbnVtYmVycyBmb3IgZWFjaCB3ZWIgd29ya2VyIHRvIGNoZWNrIHBlciB3b3JrIGFzc2lnbm1lbnQsXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiAxMDApLlxuICogQHBhcmFtIGNhbGxiYWNrKGVyciwga2V5cGFpcikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9nZW5lcmF0ZUtleVBhaXIoc3RhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgb3B0cyA9IHtcbiAgICBhbGdvcml0aG06IHtcbiAgICAgIG5hbWU6IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdQUklNRUlOQycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHdvcmtlcnM6IG9wdGlvbnMud29ya2VycyB8fCAyLFxuICAgICAgICB3b3JrTG9hZDogb3B0aW9ucy53b3JrTG9hZCB8fCAxMDAsXG4gICAgICAgIHdvcmtlclNjcmlwdDogb3B0aW9ucy53b3JrZXJTY3JpcHRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmKCdwcm5nJyBpbiBvcHRpb25zKSB7XG4gICAgb3B0cy5wcm5nID0gb3B0aW9ucy5wcm5nO1xuICB9XG5cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyBmaW5kIHAgYW5kIHRoZW4gcSAoZG9uZSBpbiBzZXJpZXMgdG8gc2ltcGxpZnkpXG4gICAgZ2V0UHJpbWUoc3RhdGUucEJpdHMsIGZ1bmN0aW9uKGVyciwgbnVtKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wID0gbnVtO1xuICAgICAgaWYoc3RhdGUucSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmluaXNoKGVyciwgc3RhdGUucSk7XG4gICAgICB9XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByaW1lKGJpdHMsIGNhbGxiYWNrKSB7XG4gICAgZm9yZ2UucHJpbWUuZ2VuZXJhdGVQcm9iYWJsZVByaW1lKGJpdHMsIG9wdHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaChlcnIsIG51bSkge1xuICAgIGlmKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgLy8gc2V0IHFcbiAgICBzdGF0ZS5xID0gbnVtO1xuXG4gICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICBpZihzdGF0ZS5wLmNvbXBhcmVUbyhzdGF0ZS5xKSA8IDApIHtcbiAgICAgIHZhciB0bXAgPSBzdGF0ZS5wO1xuICAgICAgc3RhdGUucCA9IHN0YXRlLnE7XG4gICAgICBzdGF0ZS5xID0gdG1wO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBwIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucCA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBxIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICBzdGF0ZS5wMSA9IHN0YXRlLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgIHN0YXRlLnExID0gc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuXG4gICAgLy8gZW5zdXJlIGUgYW5kIHBoaSBhcmUgY29wcmltZVxuICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgLy8gcGhpIGFuZCBlIGFyZW4ndCBjb3ByaW1lLCBzbyBnZW5lcmF0ZSBhIG5ldyBwIGFuZCBxXG4gICAgICBzdGF0ZS5wID0gc3RhdGUucSA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgc3RhdGUubiA9IHN0YXRlLnAubXVsdGlwbHkoc3RhdGUucSk7XG4gICAgaWYoc3RhdGUubi5iaXRMZW5ndGgoKSAhPT0gc3RhdGUuYml0cykge1xuICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgIHN0YXRlLnEgPSBudWxsO1xuICAgICAgZ2V0UHJpbWUoc3RhdGUucUJpdHMsIGZpbmlzaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGtleXNcbiAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgIHN0YXRlLmtleXMgPSB7XG4gICAgICBwcml2YXRlS2V5OiBwa2kucnNhLnNldFByaXZhdGVLZXkoXG4gICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgIGQubW9kKHN0YXRlLnAxKSwgZC5tb2Qoc3RhdGUucTEpLFxuICAgICAgICBzdGF0ZS5xLm1vZEludmVyc2Uoc3RhdGUucCkpLFxuICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgIH07XG5cbiAgICBjYWxsYmFjayhudWxsLCBzdGF0ZS5rZXlzKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcG9zaXRpdmUgQmlnSW50ZWdlciBpbnRvIDIncy1jb21wbGVtZW50IGJpZy1lbmRpYW4gYnl0ZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJpZyBpbnRlZ2VyIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9iblRvQnl0ZXMoYikge1xuICAvLyBwcmVwZW5kIDB4MDAgaWYgZmlyc3QgYnl0ZSA+PSAweDgwXG4gIHZhciBoZXggPSBiLnRvU3RyaW5nKDE2KTtcbiAgaWYoaGV4WzBdID49ICc4Jykge1xuICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gIH1cbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGhleCk7XG5cbiAgLy8gZW5zdXJlIGludGVnZXIgaXMgbWluaW1hbGx5LWVuY29kZWRcbiAgaWYoYnl0ZXMubGVuZ3RoID4gMSAmJlxuICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICgoYnl0ZXMuY2hhckNvZGVBdCgwKSA9PT0gMCAmJlxuICAgIChieXRlcy5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDApIHx8XG4gICAgLy8gbGVhZGluZyAweEZGIGZvciBuZWdhdGl2ZSBpbnRlZ2VyXG4gICAgKGJ5dGVzLmNoYXJDb2RlQXQoMCkgPT09IDB4RkYgJiZcbiAgICAoYnl0ZXMuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICByZXR1cm4gYnl0ZXMuc3Vic3RyKDEpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgTWlsbGVyLVJhYmluIHRlc3RzIHRvIGdlbmVyYXRlIGFcbiAqIHByaW1lIHdpdGggYW4gZXJyb3IgcHJvYmFiaWxpdHkgb2YgKDEvMileODAuXG4gKlxuICogU2VlIEhhbmRib29rIG9mIEFwcGxpZWQgQ3J5cHRvZ3JhcGh5IENoYXB0ZXIgNCwgVGFibGUgNC40LlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gX2dldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgU3VidGxlQ3J5cHRvIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gZm4gdGhlIGZlYXR1cmUgKGZ1bmN0aW9uKSB0byBkZXRlY3QuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGRldGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9kZXRlY3RTdWJ0bGVDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvLnN1YnRsZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LmNyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgZGVwcmVjYXRlZCBNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIG91dGRhdGVkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgdXNlZCBhZnRlclxuICogY2hlY2tpbmcgZm9yIHRoZSBtb2Rlcm4sIHN0YW5kYXJkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8gPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gX2ludFRvVWludDhBcnJheSh4KSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4LnRvU3RyaW5nKDE2KSk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIF9wcml2YXRlS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGFsZ29yaXRobSBcIicgKyBqd2sua3R5ICsgJ1wiOyBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLm4pLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLnApLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2sucSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcCksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5xaSkpO1xufVxuXG5mdW5jdGlvbiBfcHVibGljS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2subiksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5lKSk7XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRUb0JpZ0ludChiNjQpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS51dGlsLmRlY29kZTY0KGI2NCkpLCAxNik7XG59XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQWR2YW5jZWQgRW5jcnlwdGlvbiBTdGFuZGFyZCAoQUVTKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBwdWJsaWMgZG9tYWluIGxpYnJhcnkgJ2pzY3J5cHRvJyB3aGljaFxuICogd2FzIHdyaXR0ZW4gYnk6XG4gKlxuICogRW1pbHkgU3RhcmsgKGVzdGFya0BzdGFuZm9yZC5lZHUpXG4gKiBNaWtlIEhhbWJ1cmcgKG1oYW1idXJnQHN0YW5mb3JkLmVkdSlcbiAqIERhbiBCb25laCAoZGFib0Bjcy5zdGFuZm9yZC5lZHUpXG4gKlxuICogUGFydHMgb2YgdGhpcyBjb2RlIGFyZSBiYXNlZCBvbiB0aGUgT3BlblNTTCBpbXBsZW1lbnRhdGlvbiBvZiBBRVM6XG4gKiBodHRwOi8vd3d3Lm9wZW5zc2wub3JnXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIEFFUyBBUEkgKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYWVzID0gZm9yZ2UuYWVzIHx8IHt9O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKiBjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZGVjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBRVMgY2lwaGVyIGFsZ29yaXRobSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBtb2RlIGZhY3RvcnkgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybiB0aGUgQUVTIGFsZ29yaXRobSBvYmplY3QuXG4gKi9cbmZvcmdlLmFlcy5BbGdvcml0aG0gPSBmdW5jdGlvbihuYW1lLCBtb2RlKSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5uYW1lID0gbmFtZTtcbiAgc2VsZi5tb2RlID0gbmV3IG1vZGUoe1xuICAgIGJsb2NrU2l6ZTogMTYsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX3csIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl93LCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIEFFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5hZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdG1wO1xuXG4gIC8qIE5vdGU6IFRoZSBrZXkgbWF5IGJlIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYSBieXRlXG4gICAgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMuIElmIHRoZSBrZXkgaXMgaW4gYnl0ZXMsIHRoZW5cbiAgICBpdCBtdXN0IGJlIDE2LCAyNCwgb3IgMzIgYnl0ZXMgaW4gbGVuZ3RoLiBJZiBpdCBpcyBpbiAzMi1iaXRcbiAgICBpbnRlZ2VycywgaXQgbXVzdCBiZSA0LCA2LCBvciA4IGludGVnZXJzIGxvbmcuICovXG5cbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgaW50ZWdlciBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdG1wID0ga2V5O1xuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAga2V5LnB1dEJ5dGUodG1wW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb252ZXJ0IGtleSBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSkge1xuICAgIHRtcCA9IGtleTtcbiAgICBrZXkgPSBbXTtcblxuICAgIC8vIGtleSBsZW5ndGhzIG9mIDE2LCAyNCwgMzIgYnl0ZXMgYWxsb3dlZFxuICAgIHZhciBsZW4gPSB0bXAubGVuZ3RoKCk7XG4gICAgaWYobGVuID09PSAxNiB8fCBsZW4gPT09IDI0IHx8IGxlbiA9PT0gMzIpIHtcbiAgICAgIGxlbiA9IGxlbiA+Pj4gMjtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBrZXkucHVzaCh0bXAuZ2V0SW50MzIoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2V5IG11c3QgYmUgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzIGJ5IG5vd1xuICBpZighZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgfHxcbiAgICAhKGtleS5sZW5ndGggPT09IDQgfHwga2V5Lmxlbmd0aCA9PT0gNiB8fCBrZXkubGVuZ3RoID09PSA4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgcGFyYW1ldGVyLicpO1xuICB9XG5cbiAgLy8gZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYWx3YXlzIHVzZWQgZm9yIHRoZXNlIG1vZGVzXG4gIHZhciBtb2RlID0gdGhpcy5tb2RlLm5hbWU7XG4gIHZhciBlbmNyeXB0T3AgPSAoWydDRkInLCAnT0ZCJywgJ0NUUicsICdHQ00nXS5pbmRleE9mKG1vZGUpICE9PSAtMSk7XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvblxuICB0aGlzLl93ID0gX2V4cGFuZEtleShrZXksIG9wdGlvbnMuZGVjcnlwdCAmJiAhZW5jcnlwdE9wKTtcbiAgdGhpcy5faW5pdCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEV4cGFuZHMgYSBrZXkuIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byBleHBhbmQsIGFzIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZXhwYW5kIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXkuXG4gKi9cbmZvcmdlLmFlcy5fZXhwYW5kS2V5ID0gZnVuY3Rpb24oa2V5LCBkZWNyeXB0KSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJldHVybiBfZXhwYW5kS2V5KGtleSwgZGVjcnlwdCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2suIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIHcgdGhlIGV4cGFuZGVkIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaW5wdXQgYW4gYXJyYXkgb2YgYmxvY2stc2l6ZSAzMi1iaXQgd29yZHMuXG4gKiBAcGFyYW0gb3V0cHV0IGFuIGFycmF5IG9mIGJsb2NrLXNpemUgMzItYml0IHdvcmRzLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0LCBmYWxzZSB0byBlbmNyeXB0LlxuICovXG5mb3JnZS5hZXMuX3VwZGF0ZUJsb2NrID0gX3VwZGF0ZUJsb2NrO1xuXG4vKiogUmVnaXN0ZXIgQUVTIGFsZ29yaXRobXMgKiovXG5cbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNCQycsIGZvcmdlLmNpcGhlci5tb2Rlcy5jYmMpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1DRkInLCBmb3JnZS5jaXBoZXIubW9kZXMuY2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNUUicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jdHIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1HQ00nLCBmb3JnZS5jaXBoZXIubW9kZXMuZ2NtKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuYWVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogQUVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgaW5pdCA9IGZhbHNlOyAvLyBub3QgeWV0IGluaXRpYWxpemVkXG52YXIgTmIgPSA0OyAgICAgICAvLyBudW1iZXIgb2Ygd29yZHMgY29tcHJpc2luZyB0aGUgc3RhdGUgKEFFUyA9IDQpXG52YXIgc2JveDsgICAgICAgICAvLyBub24tbGluZWFyIHN1YnN0aXR1dGlvbiB0YWJsZSB1c2VkIGluIGtleSBleHBhbnNpb25cbnZhciBpc2JveDsgICAgICAgIC8vIGludmVyc2lvbiBvZiBzYm94XG52YXIgcmNvbjsgICAgICAgICAvLyByb3VuZCBjb25zdGFudCB3b3JkIGFycmF5XG52YXIgbWl4OyAgICAgICAgICAvLyBtaXgtY29sdW1ucyB0YWJsZVxudmFyIGltaXg7ICAgICAgICAgLy8gaW52ZXJzZSBtaXgtY29sdW1ucyB0YWJsZVxuXG4vKipcbiAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uLCBpZTogcHJlY29tcHV0ZXMgdGFibGVzIHRvIG9wdGltaXplIGZvciBzcGVlZC5cbiAqXG4gKiBPbmUgd2F5IHRvIHVuZGVyc3RhbmQgaG93IEFFUyB3b3JrcyBpcyB0byBpbWFnaW5lIHRoYXQgJ2FkZGl0aW9uJyBhbmRcbiAqICdtdWx0aXBsaWNhdGlvbicgYXJlIGludGVyZmFjZXMgdGhhdCByZXF1aXJlIGNlcnRhaW4gbWF0aGVtYXRpY2FsXG4gKiBwcm9wZXJ0aWVzIHRvIGhvbGQgdHJ1ZSAoaWU6IHRoZXkgYXJlIGFzc29jaWF0aXZlKSBidXQgdGhleSBtaWdodCBoYXZlXG4gKiBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIGFuZCBwcm9kdWNlIGRpZmZlcmVudCBraW5kcyBvZiByZXN1bHRzIC4uLlxuICogcHJvdmlkZWQgdGhhdCB0aGVpciBtYXRoZW1hdGljYWwgcHJvcGVydGllcyByZW1haW4gdHJ1ZS4gQUVTIGRlZmluZXNcbiAqIGl0cyBvd24gbWV0aG9kcyBvZiBhZGRpdGlvbiBhbmQgbXVsdGlwbGljYXRpb24gYnV0IGtlZXBzIHNvbWUgaW1wb3J0YW50XG4gKiBwcm9wZXJ0aWVzIHRoZSBzYW1lLCBpZTogYXNzb2NpYXRpdml0eSBhbmQgZGlzdHJpYnV0aXZpdHkuIFRoZVxuICogZXhwbGFuYXRpb24gYmVsb3cgdHJpZXMgdG8gc2hlZCBzb21lIGxpZ2h0IG9uIGhvdyBBRVMgZGVmaW5lcyBhZGRpdGlvblxuICogYW5kIG11bHRpcGxpY2F0aW9uIG9mIGJ5dGVzIGFuZCAzMi1iaXQgd29yZHMgaW4gb3JkZXIgdG8gcGVyZm9ybSBpdHNcbiAqIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24gYWxnb3JpdGhtcy5cbiAqXG4gKiBUaGUgYmFzaWNzOlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHZpZXdzIGJ5dGVzIGFzIGJpbmFyeSByZXByZXNlbnRhdGlvbnMgb2YgcG9seW5vbWlhbHNcbiAqIHRoYXQgaGF2ZSBlaXRoZXIgMSBvciAwIGFzIHRoZSBjb2VmZmljaWVudHMuIEl0IGRlZmluZXMgdGhlIGFkZGl0aW9uXG4gKiBvciBzdWJ0cmFjdGlvbiBvZiB0d28gYnl0ZXMgYXMgdGhlIFhPUiBvcGVyYXRpb24uIEl0IGFsc28gZGVmaW5lcyB0aGVcbiAqIG11bHRpcGxpY2F0aW9uIG9mIHR3byBieXRlcyBhcyBhIGZpbml0ZSBmaWVsZCByZWZlcnJlZCB0byBhcyBHRigyXjgpXG4gKiAoTm90ZTogJ0dGJyBtZWFucyBcIkdhbG9pcyBGaWVsZFwiIHdoaWNoIGlzIGEgZmllbGQgdGhhdCBjb250YWlucyBhIGZpbml0ZVxuICogbnVtYmVyIG9mIGVsZW1lbnRzIHNvIEdGKDJeOCkgaGFzIDI1NiBlbGVtZW50cykuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IGFueSB0d28gYnl0ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGJpbmFyeSBwb2x5bm9taWFscztcbiAqIHdoZW4gdGhleSBtdWx0aXBsaWVkIHRvZ2V0aGVyIGFuZCBtb2R1bGFybHkgcmVkdWNlZCBieSBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiB0aGUgOHRoIGRlZ3JlZSwgdGhlIHJlc3VsdHMgYXJlIHRoZSBmaWVsZCBHRigyXjgpLiBUaGVcbiAqIHNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgdGhhdCBBRVMgdXNlcyBpbiBoZXhhZGVjaW1hbCBpcyAweDExYi5cbiAqIFRoaXMgbXVsdGlwbGljYXRpb24gaXMgYXNzb2NpYXRpdmUgd2l0aCAweDAxIGFzIHRoZSBpZGVudGl0eTpcbiAqXG4gKiAoYiAqIDB4MDEgPSBHRihiLCAweDAxKSA9IGIpLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gR0YoYiwgMHgwMikgY2FuIGJlIHBlcmZvcm1lZCBhdCB0aGUgYnl0ZSBsZXZlbCBieSBsZWZ0XG4gKiBzaGlmdGluZyBiIG9uY2UgYW5kIHRoZW4gWE9SJ2luZyBpdCAodG8gcGVyZm9ybSB0aGUgbW9kdWxhciByZWR1Y3Rpb24pXG4gKiB3aXRoIDB4MTFiIGlmIGIgaXMgPj0gMTI4LiBSZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB0aGUgbXVsdGlwbGljYXRpb25cbiAqIG9mIDB4MDIgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IHRoZSBtdWx0aXBsaWNhdGlvbiBvZiBhbnkgdHdvIGJ5dGVzLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgbXVsdGlwbHlpbmcgMHg1NyBhbmQgMHgxMywgZGVub3RlZCBhcyBHRigweDU3LCAweDEzKSwgY2FuXG4gKiBiZSBwZXJmb3JtZWQgYnkgZmFjdG9yaW5nIDB4MTMgaW50byAweDAxLCAweDAyLCBhbmQgMHgxMC4gVGhlbiB0aGVzZVxuICogZmFjdG9ycyBjYW4gZWFjaCBiZSBtdWx0aXBsaWVkIGJ5IDB4NTcgYW5kIHRoZW4gYWRkZWQgdG9nZXRoZXIuIFRvIGRvXG4gKiB0aGUgbXVsdGlwbGljYXRpb24sIHZhbHVlcyBmb3IgMHg1NyBtdWx0aXBsaWVkIGJ5IGVhY2ggb2YgdGhlc2UgMyBmYWN0b3JzXG4gKiBjYW4gYmUgcHJlY29tcHV0ZWQgYW5kIHN0b3JlZCBpbiBhIHRhYmxlLiBUbyBhZGQgdGhlbSwgdGhlIHZhbHVlcyBmcm9tXG4gKiB0aGUgdGFibGUgYXJlIFhPUidkIHRvZ2V0aGVyLlxuICpcbiAqIEFFUyBhbHNvIGRlZmluZXMgYWRkaXRpb24gYW5kIG11bHRpcGxpY2F0aW9uIG9mIHdvcmRzLCB0aGF0IGlzIDQtYnl0ZVxuICogbnVtYmVycyByZXByZXNlbnRlZCBhcyBwb2x5bm9taWFscyBvZiAzIGRlZ3JlZXMgd2hlcmUgdGhlIGNvZWZmaWNpZW50c1xuICogYXJlIHRoZSB2YWx1ZXMgb2YgdGhlIGJ5dGVzLlxuICpcbiAqIFRoZSB3b3JkIFthMCwgYTEsIGEyLCBhM10gaXMgYSBwb2x5bm9taWFsIGEzeF4zICsgYTJ4XjIgKyBhMXggKyBhMC5cbiAqXG4gKiBBZGRpdGlvbiBpcyBwZXJmb3JtZWQgYnkgWE9SJ2luZyBsaWtlIHBvd2VycyBvZiB4LiBNdWx0aXBsaWNhdGlvblxuICogaXMgcGVyZm9ybWVkIGluIHR3byBzdGVwcywgdGhlIGZpcnN0IGlzIGFuIGFsZ2VicmlhYyBleHBhbnNpb24gYXNcbiAqIHlvdSB3b3VsZCBkbyBub3JtYWxseSAod2hlcmUgYWRkaXRpb24gaXMgWE9SKS4gQnV0IHRoZSByZXN1bHQgaXNcbiAqIGEgcG9seW5vbWlhbCBsYXJnZXIgdGhhbiAzIGRlZ3JlZXMgYW5kIHRodXMgaXQgY2Fubm90IGZpdCBpbiBhIHdvcmQuIFNvXG4gKiBuZXh0IHRoZSByZXN1bHQgaXMgbW9kdWxhcmx5IHJlZHVjZWQgYnkgYW4gQUVTLXNwZWNpZmljIHBvbHlub21pYWwgb2ZcbiAqIGRlZ3JlZSA0IHdoaWNoIHdpbGwgYWx3YXlzIHByb2R1Y2UgYSBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiA0IGRlZ3JlZXNcbiAqIHN1Y2ggdGhhdCBpdCB3aWxsIGZpdCBpbiBhIHdvcmQuIEluIEFFUywgdGhpcyBwb2x5bm9taWFsIGlzIHheNCArIDEuXG4gKlxuICogVGhlIG1vZHVsYXIgcHJvZHVjdCBvZiB0d28gcG9seW5vbWlhbHMgJ2EnIGFuZCAnYicgaXMgdGh1czpcbiAqXG4gKiBkKHgpID0gZDN4XjMgKyBkMnheMiArIGQxeCArIGQwXG4gKiB3aXRoXG4gKiBkMCA9IEdGKGEwLCBiMCkgXiBHRihhMywgYjEpIF4gR0YoYTIsIGIyKSBeIEdGKGExLCBiMylcbiAqIGQxID0gR0YoYTEsIGIwKSBeIEdGKGEwLCBiMSkgXiBHRihhMywgYjIpIF4gR0YoYTIsIGIzKVxuICogZDIgPSBHRihhMiwgYjApIF4gR0YoYTEsIGIxKSBeIEdGKGEwLCBiMikgXiBHRihhMywgYjMpXG4gKiBkMyA9IEdGKGEzLCBiMCkgXiBHRihhMiwgYjEpIF4gR0YoYTEsIGIyKSBeIEdGKGEwLCBiMylcbiAqXG4gKiBBcyBhIG1hdHJpeDpcbiAqXG4gKiBbZDBdID0gW2EwIGEzIGEyIGExXVtiMF1cbiAqIFtkMV0gICBbYTEgYTAgYTMgYTJdW2IxXVxuICogW2QyXSAgIFthMiBhMSBhMCBhM11bYjJdXG4gKiBbZDNdICAgW2EzIGEyIGExIGEwXVtiM11cbiAqXG4gKiBTcGVjaWFsIHBvbHlub21pYWxzIGRlZmluZWQgYnkgQUVTICgweDAyID09IHswMn0pOlxuICogYSh4KSAgICA9IHswM314XjMgKyB7MDF9eF4yICsgezAxfXggKyB7MDJ9XG4gKiBhXi0xKHgpID0gezBifXheMyArIHswZH14XjIgKyB7MDl9eCArIHswZX0uXG4gKlxuICogVGhlc2UgcG9seW5vbWlhbHMgYXJlIHVzZWQgaW4gdGhlIE1peENvbHVtbnMoKSBhbmQgSW52ZXJzZU1peENvbHVtbnMoKVxuICogb3BlcmF0aW9ucywgcmVzcGVjdGl2ZWx5LCB0byBjYXVzZSBlYWNoIGVsZW1lbnQgaW4gdGhlIHN0YXRlIHRvIGFmZmVjdFxuICogdGhlIG91dHB1dCAocmVmZXJyZWQgdG8gYXMgZGlmZnVzaW5nKS5cbiAqXG4gKiBSb3RXb3JkKCkgdXNlczogYTAgPSBhMSA9IGEyID0gezAwfSBhbmQgYTMgPSB7MDF9LCB3aGljaCBpcyB0aGVcbiAqIHBvbHlub21pYWwgeDMuXG4gKlxuICogVGhlIFNoaWZ0Um93cygpIG1ldGhvZCBtb2RpZmllcyB0aGUgbGFzdCAzIHJvd3MgaW4gdGhlIHN0YXRlICh3aGVyZVxuICogdGhlIHN0YXRlIGlzIDQgd29yZHMgd2l0aCA0IGJ5dGVzIHBlciB3b3JkKSBieSBzaGlmdGluZyBieXRlcyBjeWNsaWNhbGx5LlxuICogVGhlIDFzdCBieXRlIGluIHRoZSBzZWNvbmQgcm93IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHJvdy4gVGhlIDFzdFxuICogYW5kIDJuZCBieXRlcyBpbiB0aGUgdGhpcmQgcm93IGFyZSBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoZSByb3cuIFRoZSAxc3QsXG4gKiAybmQsIGFuZCAzcmQgYnl0ZXMgYXJlIG1vdmVkIGluIHRoZSBmb3VydGggcm93LlxuICpcbiAqIE1vcmUgZGV0YWlscyBvbiBob3cgQUVTIGFyaXRobWV0aWMgd29ya3M6XG4gKlxuICogSW4gdGhlIHBvbHlub21pYWwgcmVwcmVzZW50YXRpb24gb2YgYmluYXJ5IG51bWJlcnMsIFhPUiBwZXJmb3JtcyBhZGRpdGlvblxuICogYW5kIHN1YnRyYWN0aW9uIGFuZCBtdWx0aXBsaWNhdGlvbiBpbiBHRigyXjgpIGRlbm90ZWQgYXMgR0YoYSwgYilcbiAqIGNvcnJlc3BvbmRzIHdpdGggdGhlIG11bHRpcGxpY2F0aW9uIG9mIHBvbHlub21pYWxzIG1vZHVsbyBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiBkZWdyZWUgOC4gSW4gb3RoZXIgd29yZHMsIGZvciBBRVMsIEdGKGEsIGIpIHdpbGwgbXVsdGlwbHlcbiAqIHBvbHlub21pYWwgJ2EnIHdpdGggcG9seW5vbWlhbCAnYicgYW5kIHRoZW4gZG8gYSBtb2R1bGFyIHJlZHVjdGlvbiBieVxuICogYW4gQUVTLXNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgb2YgZGVncmVlIDguXG4gKlxuICogQSBwb2x5bm9taWFsIGlzIGlycmVkdWNpYmxlIGlmIGl0cyBvbmx5IGRpdmlzb3JzIGFyZSBvbmUgYW5kIGl0c2VsZi4gRm9yXG4gKiB0aGUgQUVTIGFsZ29yaXRobSwgdGhpcyBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIGlzOlxuICpcbiAqIG0oeCkgPSB4XjggKyB4XjQgKyB4XjMgKyB4ICsgMSxcbiAqXG4gKiBvciB7MDF9ezFifSBpbiBoZXhhZGVjaW1hbCBub3RhdGlvbiwgd2hlcmUgZWFjaCBjb2VmZmljaWVudCBpcyBhIGJpdDpcbiAqIDEwMDAxMTAxMSA9IDI4MyA9IDB4MTFiLlxuICpcbiAqIEZvciBleGFtcGxlLCBHRigweDU3LCAweDgzKSA9IDB4YzEgYmVjYXVzZVxuICpcbiAqIDB4NTcgPSA4NyAgPSAwMTAxMDExMSA9IHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiAweDg1ID0gMTMxID0gMTAwMDAxMDEgPSB4XjcgKyB4ICsgMVxuICpcbiAqICh4XjYgKyB4XjQgKyB4XjIgKyB4ICsgMSkgKiAoeF43ICsgeCArIDEpXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNyArXG4gKiAgICB4XjcgKyB4XjUgKyB4XjMgKyB4XjIgKyB4ICtcbiAqICAgIHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNiArIHheNSArIHheNCArIHheMyArIDEgPSB5XG4gKiAgICB5IG1vZHVsbyAoeF44ICsgeF40ICsgeF4zICsgeCArIDEpXG4gKiA9ICB4XjcgKyB4XjYgKyAxLlxuICpcbiAqIFRoZSBtb2R1bGFyIHJlZHVjdGlvbiBieSBtKHgpIGd1YXJhbnRlZXMgdGhlIHJlc3VsdCB3aWxsIGJlIGEgYmluYXJ5XG4gKiBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiBkZWdyZWUgOCwgc28gdGhhdCBpdCBjYW4gZml0IGluIGEgYnl0ZS5cbiAqXG4gKiBUaGUgb3BlcmF0aW9uIHRvIG11bHRpcGx5IGEgYmluYXJ5IHBvbHlub21pYWwgYiB3aXRoIHggKHRoZSBwb2x5bm9taWFsXG4gKiB4IGluIGJpbmFyeSByZXByZXNlbnRhdGlvbiBpcyAwMDAwMDAxMCkgaXM6XG4gKlxuICogYl83eF44ICsgYl82eF43ICsgYl81eF42ICsgYl80eF41ICsgYl8zeF40ICsgYl8yeF4zICsgYl8xeF4yICsgYl8weF4xXG4gKlxuICogVG8gZ2V0IEdGKGIsIHgpIHdlIG11c3QgcmVkdWNlIHRoYXQgYnkgbSh4KS4gSWYgYl83IGlzIDAgKHRoYXQgaXMgdGhlXG4gKiBtb3N0IHNpZ25pZmljYW50IGJpdCBpcyAwIGluIGIpIHRoZW4gdGhlIHJlc3VsdCBpcyBhbHJlYWR5IHJlZHVjZWQuIElmXG4gKiBpdCBpcyAxLCB0aGVuIHdlIGNhbiByZWR1Y2UgaXQgYnkgc3VidHJhY3RpbmcgbSh4KSB2aWEgYW4gWE9SLlxuICpcbiAqIEl0IGZvbGxvd3MgdGhhdCBtdWx0aXBsaWNhdGlvbiBieSB4ICgwMDAwMDAxMCBvciAweDAyKSBjYW4gYmUgaW1wbGVtZW50ZWRcbiAqIGJ5IHBlcmZvcm1pbmcgYSBsZWZ0IHNoaWZ0IGZvbGxvd2VkIGJ5IGEgY29uZGl0aW9uYWwgYml0d2lzZSBYT1Igd2l0aFxuICogMHgxYi4gVGhpcyBvcGVyYXRpb24gb24gYnl0ZXMgaXMgZGVub3RlZCBieSB4dGltZSgpLiBNdWx0aXBsaWNhdGlvbiBieVxuICogaGlnaGVyIHBvd2VycyBvZiB4IGNhbiBiZSBpbXBsZW1lbnRlZCBieSByZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB4dGltZSgpLlxuICpcbiAqIEJ5IGFkZGluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cywgbXVsdGlwbGljYXRpb24gYnkgYW55IGNvbnN0YW50IGNhbiBiZVxuICogaW1wbGVtZW50ZWQuIEZvciBpbnN0YW5jZTpcbiAqXG4gKiBHRigweDU3LCAweDEzKSA9IDB4ZmUgYmVjYXVzZTpcbiAqXG4gKiB4dGltZShiKSA9IChiICYgMTI4KSA/IChiIDw8IDEgXiAweDExYikgOiAoYiA8PCAxKVxuICpcbiAqIE5vdGU6IFdlIFhPUiB3aXRoIDB4MTFiIGluc3RlYWQgb2YgMHgxYiBiZWNhdXNlIGluIGphdmFzY3JpcHQgb3VyXG4gKiBkYXRhdHlwZSBmb3IgYiBjYW4gYmUgbGFyZ2VyIHRoYW4gMSBieXRlLCBzbyBhIGxlZnQgc2hpZnQgd2lsbCBub3RcbiAqIGF1dG9tYXRpY2FsbHkgZWxpbWluYXRlIGJpdHMgdGhhdCBvdmVyZmxvdyBhIGJ5dGUgLi4uIGJ5IFhPUidpbmcgdGhlXG4gKiBvdmVyZmxvdyBiaXQgd2l0aCAxICh0aGUgZXh0cmEgb25lIGZyb20gMHgxMWIpIHdlIHplcm8gaXQgb3V0LlxuICpcbiAqIEdGKDB4NTcsIDB4MDIpID0geHRpbWUoMHg1NykgPSAweGFlXG4gKiBHRigweDU3LCAweDA0KSA9IHh0aW1lKDB4YWUpID0gMHg0N1xuICogR0YoMHg1NywgMHgwOCkgPSB4dGltZSgweDQ3KSA9IDB4OGVcbiAqIEdGKDB4NTcsIDB4MTApID0geHRpbWUoMHg4ZSkgPSAweDA3XG4gKlxuICogR0YoMHg1NywgMHgxMykgPSBHRigweDU3LCAoMHgwMSBeIDB4MDIgXiAweDEwKSlcbiAqXG4gKiBBbmQgYnkgdGhlIGRpc3RyaWJ1dGl2ZSBwcm9wZXJ0eSAoc2luY2UgWE9SIGlzIGFkZGl0aW9uIGFuZCBHRigpIGlzXG4gKiBtdWx0aXBsaWNhdGlvbik6XG4gKlxuICogPSBHRigweDU3LCAweDAxKSBeIEdGKDB4NTcsIDB4MDIpIF4gR0YoMHg1NywgMHgxMClcbiAqID0gMHg1NyBeIDB4YWUgXiAweDA3XG4gKiA9IDB4ZmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gIGluaXQgPSB0cnVlO1xuXG4gIC8qIFBvcHVsYXRlIHRoZSBSY29uIHRhYmxlLiBUaGVzZSBhcmUgdGhlIHZhbHVlcyBnaXZlbiBieVxuICAgIFt4XihpLTEpLHswMH0sezAwfSx7MDB9XSB3aGVyZSB4XihpLTEpIGFyZSBwb3dlcnMgb2YgeCAoYW5kIHggPSAweDAyKVxuICAgIGluIHRoZSBmaWVsZCBvZiBHRigyXjgpLCB3aGVyZSBpIHN0YXJ0cyBhdCAxLlxuXG4gICAgcmNvblswXSA9IFsweDAwLCAweDAwLCAweDAwLCAweDAwXVxuICAgIHJjb25bMV0gPSBbMHgwMSwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMS0xKSA9IDJeMCA9IDFcbiAgICByY29uWzJdID0gWzB4MDIsIDB4MDAsIDB4MDAsIDB4MDBdIDJeKDItMSkgPSAyXjEgPSAyXG4gICAgLi4uXG4gICAgcmNvbls5XSAgPSBbMHgxQiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oOS0xKSAgPSAyXjggPSAweDFCXG4gICAgcmNvblsxMF0gPSBbMHgzNiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMTAtMSkgPSAyXjkgPSAweDM2XG5cbiAgICBXZSBvbmx5IHN0b3JlIHRoZSBmaXJzdCBieXRlIGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgb25lIHVzZWQuXG4gICovXG4gIHJjb24gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxQiwgMHgzNl07XG5cbiAgLy8gY29tcHV0ZSB4dGltZSB0YWJsZSB3aGljaCBtYXBzIGkgb250byBHRihpLCAweDAyKVxuICB2YXIgeHRpbWUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgeHRpbWVbaV0gPSBpIDw8IDE7XG4gICAgeHRpbWVbaSArIDEyOF0gPSAoaSArIDEyOCkgPDwgMSBeIDB4MTFCO1xuICB9XG5cbiAgLy8gY29tcHV0ZSBhbGwgb3RoZXIgdGFibGVzXG4gIHNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgaXNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgbWl4ID0gbmV3IEFycmF5KDQpO1xuICBpbWl4ID0gbmV3IEFycmF5KDQpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgbWl4W2ldID0gbmV3IEFycmF5KDI1Nik7XG4gICAgaW1peFtpXSA9IG5ldyBBcnJheSgyNTYpO1xuICB9XG4gIHZhciBlID0gMCwgZWkgPSAwLCBlMiwgZTQsIGU4LCBzeCwgc3gyLCBtZSwgaW1lO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAvKiBXZSBuZWVkIHRvIGdlbmVyYXRlIHRoZSBTdWJCeXRlcygpIHNib3ggYW5kIGlzYm94IHRhYmxlcyBzbyB0aGF0XG4gICAgICB3ZSBjYW4gcGVyZm9ybSBieXRlIHN1YnN0aXR1dGlvbnMuIFRoaXMgcmVxdWlyZXMgdXMgdG8gdHJhdmVyc2VcbiAgICAgIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gR0YsIGZpbmQgdGhlaXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZXMsXG4gICAgICBhbmQgYXBwbHkgdG8gZWFjaCB0aGUgZm9sbG93aW5nIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjpcblxuICAgICAgYmknID0gYmkgXiBiKGkgKyA0KSBtb2QgOCBeIGIoaSArIDUpIG1vZCA4IF4gYihpICsgNikgbW9kIDggXlxuICAgICAgICAgICAgYihpICsgNykgbW9kIDggXiBjaVxuICAgICAgZm9yIDAgPD0gaSA8IDgsIHdoZXJlIGJpIGlzIHRoZSBpdGggYml0IG9mIHRoZSBieXRlLCBhbmQgY2kgaXMgdGhlXG4gICAgICBpdGggYml0IG9mIGEgYnl0ZSBjIHdpdGggdGhlIHZhbHVlIHs2M30gb3IgezAxMTAwMDExfS5cblxuICAgICAgSXQgaXMgcG9zc2libGUgdG8gdHJhdmVyc2UgZXZlcnkgcG9zc2libGUgdmFsdWUgaW4gYSBHYWxvaXMgZmllbGRcbiAgICAgIHVzaW5nIHdoYXQgaXMgcmVmZXJyZWQgdG8gYXMgYSAnZ2VuZXJhdG9yJy4gVGhlcmUgYXJlIG1hbnlcbiAgICAgIGdlbmVyYXRvcnMgKDEyOCBvdXQgb2YgMjU2KTogMyw1LDYsOSwxMSw4MiB0byBuYW1lIGEgZmV3LiBUbyBmdWxseVxuICAgICAgdHJhdmVyc2UgR0Ygd2UgaXRlcmF0ZSAyNTUgdGltZXMsIG11bHRpcGx5aW5nIGJ5IG91ciBnZW5lcmF0b3JcbiAgICAgIGVhY2ggdGltZS5cblxuICAgICAgT24gZWFjaCBpdGVyYXRpb24gd2UgY2FuIGRldGVybWluZSB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBmb3JcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQuXG5cbiAgICAgIFN1cHBvc2UgdGhlcmUgaXMgYW4gZWxlbWVudCBpbiBHRiAnZScuIEZvciBhIGdpdmVuIGdlbmVyYXRvciAnZycsXG4gICAgICBlID0gZ154LiBUaGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiBlIGlzIGdeKDI1NSAtIHgpLiBJdCB0dXJuc1xuICAgICAgb3V0IHRoYXQgaWYgdXNlIHRoZSBpbnZlcnNlIG9mIGEgZ2VuZXJhdG9yIGFzIGFub3RoZXIgZ2VuZXJhdG9yXG4gICAgICBpdCB3aWxsIHByb2R1Y2UgYWxsIG9mIHRoZSBjb3JyZXNwb25kaW5nIG11bHRpcGxpY2F0aXZlIGludmVyc2VzXG4gICAgICBhdCB0aGUgc2FtZSB0aW1lLiBGb3IgdGhpcyByZWFzb24sIHdlIGNob29zZSA1IGFzIG91ciBpbnZlcnNlXG4gICAgICBnZW5lcmF0b3IgYmVjYXVzZSBpdCBvbmx5IHJlcXVpcmVzIDIgbXVsdGlwbGllcyBhbmQgMSBhZGQgYW5kIGl0c1xuICAgICAgaW52ZXJzZSwgODIsIHJlcXVpcmVzIHJlbGF0aXZlbHkgZmV3IG9wZXJhdGlvbnMgYXMgd2VsbC5cblxuICAgICAgSW4gb3JkZXIgdG8gYXBwbHkgdGhlIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiwgdGhlIG11bHRpcGxpY2F0aXZlXG4gICAgICBpbnZlcnNlICdlaScgb2YgJ2UnIGNhbiBiZSByZXBlYXRlZGx5IFhPUidkICg0IHRpbWVzKSB3aXRoIGFcbiAgICAgIGJpdC1jeWNsaW5nIG9mICdlaScuIFRvIGRvIHRoaXMgJ2VpJyBpcyBmaXJzdCBzdG9yZWQgaW4gJ3MnIGFuZFxuICAgICAgJ3gnLiBUaGVuICdzJyBpcyBsZWZ0IHNoaWZ0ZWQgYW5kIHRoZSBoaWdoIGJpdCBvZiAncycgaXMgbWFkZSB0aGVcbiAgICAgIGxvdyBiaXQuIFRoZSByZXN1bHRpbmcgdmFsdWUgaXMgc3RvcmVkIGluICdzJy4gVGhlbiAneCcgaXMgWE9SJ2RcbiAgICAgIHdpdGggJ3MnIGFuZCBzdG9yZWQgaW4gJ3gnLiBPbiBlYWNoIHN1YnNlcXVlbnQgaXRlcmF0aW9uIHRoZSBzYW1lXG4gICAgICBvcGVyYXRpb24gaXMgcGVyZm9ybWVkLiBXaGVuIDQgaXRlcmF0aW9ucyBhcmUgY29tcGxldGUsICd4JyBpc1xuICAgICAgWE9SJ2Qgd2l0aCAnYycgKDB4NjMpIGFuZCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgaXMgc3RvcmVkIGluICd4Jy5cbiAgICAgIEZvciBleGFtcGxlOlxuXG4gICAgICBzID0gMDEwMDAwMDFcbiAgICAgIHggPSAwMTAwMDAwMVxuXG4gICAgICBpdGVyYXRpb24gMTogcyA9IDEwMDAwMDEwLCB4IF49IHNcbiAgICAgIGl0ZXJhdGlvbiAyOiBzID0gMDAwMDAxMDEsIHggXj0gc1xuICAgICAgaXRlcmF0aW9uIDM6IHMgPSAwMDAwMTAxMCwgeCBePSBzXG4gICAgICBpdGVyYXRpb24gNDogcyA9IDAwMDEwMTAwLCB4IF49IHNcbiAgICAgIHggXj0gMHg2M1xuXG4gICAgICBUaGlzIGNhbiBiZSBkb25lIHdpdGggYSBsb29wIHdoZXJlIHMgPSAocyA8PCAxKSB8IChzID4+IDcpLiBIb3dldmVyLFxuICAgICAgaXQgY2FuIGFsc28gYmUgZG9uZSBieSB1c2luZyBhIHNpbmdsZSAxNi1iaXQgKGluIHRoaXMgY2FzZSAzMi1iaXQpXG4gICAgICBudW1iZXIgJ3N4Jy4gU2luY2UgWE9SIGlzIGFuIGFzc29jaWF0aXZlIG9wZXJhdGlvbiwgd2UgY2FuIHNldCAnc3gnXG4gICAgICB0byAnZWknIGFuZCB0aGVuIFhPUiBpdCB3aXRoICdzeCcgbGVmdC1zaGlmdGVkIDEsMiwzLCBhbmQgNCB0aW1lcy5cbiAgICAgIFRoZSBtb3N0IHNpZ25pZmljYW50IGJpdHMgd2lsbCBmbG93IGludG8gdGhlIGhpZ2ggOCBiaXQgcG9zaXRpb25zXG4gICAgICBhbmQgYmUgY29ycmVjdGx5IFhPUidkIHdpdGggb25lIGFub3RoZXIuIEFsbCB0aGF0IHJlbWFpbnMgd2lsbCBiZVxuICAgICAgdG8gY3ljbGUgdGhlIGhpZ2ggOCBiaXRzIGJ5IFhPUidpbmcgdGhlbSBhbGwgd2l0aCB0aGUgbG93ZXIgOCBiaXRzXG4gICAgICBhZnRlcndhcmRzLlxuXG4gICAgICBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIHBvcHVsYXRpbmcgc2JveCBhbmQgaXNib3ggd2UgY2FuIHByZWNvbXB1dGVcbiAgICAgIHRoZSBtdWx0aXBsaWNhdGlvbiB3ZSdsbCBuZWVkIHRvIGRvIHRvIGRvIE1peENvbHVtbnMoKSBsYXRlci5cbiAgICAqL1xuXG4gICAgLy8gYXBwbHkgYWZmaW5lIHRyYW5zZm9ybWF0aW9uXG4gICAgc3ggPSBlaSBeIChlaSA8PCAxKSBeIChlaSA8PCAyKSBeIChlaSA8PCAzKSBeIChlaSA8PCA0KTtcbiAgICBzeCA9IChzeCA+PiA4KSBeIChzeCAmIDI1NSkgXiAweDYzO1xuXG4gICAgLy8gdXBkYXRlIHRhYmxlc1xuICAgIHNib3hbZV0gPSBzeDtcbiAgICBpc2JveFtzeF0gPSBlO1xuXG4gICAgLyogTWl4aW5nIGNvbHVtbnMgaXMgZG9uZSB1c2luZyBtYXRyaXggbXVsdGlwbGljYXRpb24uIFRoZSBjb2x1bW5zXG4gICAgICB0aGF0IGFyZSB0byBiZSBtaXhlZCBhcmUgZWFjaCBhIHNpbmdsZSB3b3JkIGluIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgVGhlIHN0YXRlIGhhcyBOYiBjb2x1bW5zICg0IGNvbHVtbnMpLiBUaGVyZWZvcmUgZWFjaCBjb2x1bW4gaXMgYVxuICAgICAgNCBieXRlIHdvcmQuIFNvIHRvIG1peCB0aGUgY29sdW1ucyBpbiBhIHNpbmdsZSBjb2x1bW4gJ2MnIHdoZXJlXG4gICAgICBpdHMgcm93cyBhcmUgcjAsIHIxLCByMiwgYW5kIHIzLCB3ZSB1c2UgdGhlIGZvbGxvd2luZyBtYXRyaXhcbiAgICAgIG11bHRpcGxpY2F0aW9uOlxuXG4gICAgICBbMiAzIDEgMV0qW3IwLGNdPVtyJzAsY11cbiAgICAgIFsxIDIgMyAxXSBbcjEsY10gW3InMSxjXVxuICAgICAgWzEgMSAyIDNdIFtyMixjXSBbcicyLGNdXG4gICAgICBbMyAxIDEgMl0gW3IzLGNdIFtyJzMsY11cblxuICAgICAgcjAsIHIxLCByMiwgYW5kIHIzIGFyZSBlYWNoIDEgYnl0ZSBvZiBvbmUgb2YgdGhlIHdvcmRzIGluIHRoZVxuICAgICAgc3RhdGUgKGEgY29sdW1uKS4gVG8gZG8gbWF0cml4IG11bHRpcGxpY2F0aW9uIGZvciBlYWNoIG1peGVkXG4gICAgICBjb2x1bW4gYycgd2UgbXVsdGlwbHkgdGhlIGNvcnJlc3BvbmRpbmcgcm93IGZyb20gdGhlIGxlZnQgbWF0cml4XG4gICAgICB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBmcm9tIHRoZSByaWdodCBtYXRyaXguIEluIHRvdGFsLCB3ZVxuICAgICAgZ2V0IDQgZXF1YXRpb25zOlxuXG4gICAgICByMCxjJyA9IDIqcjAsYyArIDMqcjEsYyArIDEqcjIsYyArIDEqcjMsY1xuICAgICAgcjEsYycgPSAxKnIwLGMgKyAyKnIxLGMgKyAzKnIyLGMgKyAxKnIzLGNcbiAgICAgIHIyLGMnID0gMSpyMCxjICsgMSpyMSxjICsgMipyMixjICsgMypyMyxjXG4gICAgICByMyxjJyA9IDMqcjAsYyArIDEqcjEsYyArIDEqcjIsYyArIDIqcjMsY1xuXG4gICAgICBBcyB1c3VhbCwgdGhlIG11bHRpcGxpY2F0aW9uIGlzIGFzIHByZXZpb3VzbHkgZGVmaW5lZCBhbmQgdGhlXG4gICAgICBhZGRpdGlvbiBpcyBYT1IuIEluIG9yZGVyIHRvIG9wdGltaXplIG1peGluZyBjb2x1bW5zIHdlIGNhbiBzdG9yZVxuICAgICAgdGhlIG11bHRpcGxpY2F0aW9uIHJlc3VsdHMgaW4gdGFibGVzLiBJZiB5b3UgdGhpbmsgb2YgdGhlIHdob2xlXG4gICAgICBjb2x1bW4gYXMgYSB3b3JkIChpdCBtaWdodCBoZWxwIHRvIHZpc3VhbGl6ZSBieSBtZW50YWxseSByb3RhdGluZ1xuICAgICAgdGhlIGVxdWF0aW9ucyBhYm92ZSBieSBjb3VudGVyY2xvY2t3aXNlIDkwIGRlZ3JlZXMpIHRoZW4geW91IGNhblxuICAgICAgc2VlIHRoYXQgaXQgd291bGQgYmUgdXNlZnVsIHRvIG1hcCB0aGUgbXVsdGlwbGljYXRpb25zIHBlcmZvcm1lZCBvblxuICAgICAgZWFjaCBieXRlIChyMCwgcjEsIHIyLCByMykgb250byBhIHdvcmQgYXMgd2VsbC4gRm9yIGluc3RhbmNlLCB3ZVxuICAgICAgY291bGQgbWFwIDIqcjAsMSpyMCwxKnIwLDMqcjAgb250byBhIHdvcmQgYnkgc3RvcmluZyAyKnIwIGluIHRoZVxuICAgICAgaGlnaGVzdCA4IGJpdHMgYW5kIDMqcjAgaW4gdGhlIGxvd2VzdCA4IGJpdHMgKHdpdGggdGhlIG90aGVyIHR3b1xuICAgICAgcmVzcGVjdGl2ZWx5IGluIHRoZSBtaWRkbGUpLiBUaGlzIG1lYW5zIHRoYXQgYSB0YWJsZSBjYW4gYmVcbiAgICAgIGNvbnN0cnVjdGVkIHRoYXQgdXNlcyByMCBhcyBhbiBpbmRleCB0byB0aGUgd29yZC4gV2UgY2FuIGRvIHRoZVxuICAgICAgc2FtZSB3aXRoIHIxLCByMiwgYW5kIHIzLCBjcmVhdGluZyBhIHRvdGFsIG9mIDQgdGFibGVzLlxuXG4gICAgICBUbyBjb25zdHJ1Y3QgYSBmdWxsIGMnLCB3ZSBjYW4ganVzdCBsb29rIHVwIGVhY2ggYnl0ZSBvZiBjIGluXG4gICAgICB0aGVpciByZXNwZWN0aXZlIHRhYmxlcyBhbmQgWE9SIHRoZSByZXN1bHRzIHRvZ2V0aGVyLlxuXG4gICAgICBBbHNvLCB0byBidWlsZCBlYWNoIHRhYmxlIHdlIG9ubHkgaGF2ZSB0byBjYWxjdWxhdGUgdGhlIHdvcmRcbiAgICAgIGZvciAyLDEsMSwzIGZvciBldmVyeSBieXRlIC4uLiB3aGljaCB3ZSBjYW4gZG8gb24gZWFjaCBpdGVyYXRpb25cbiAgICAgIG9mIHRoaXMgbG9vcCBzaW5jZSB3ZSB3aWxsIGl0ZXJhdGUgb3ZlciBldmVyeSBieXRlLiBBZnRlciB3ZSBoYXZlXG4gICAgICBjYWxjdWxhdGVkIDIsMSwxLDMgd2UgY2FuIGdldCB0aGUgcmVzdWx0cyBmb3IgdGhlIG90aGVyIHRhYmxlc1xuICAgICAgYnkgY3ljbGluZyB0aGUgYnl0ZSBhdCB0aGUgZW5kIHRvIHRoZSBiZWdpbm5pbmcuIEZvciBpbnN0YW5jZVxuICAgICAgd2UgY2FuIHRha2UgdGhlIHJlc3VsdCBvZiB0YWJsZSAyLDEsMSwzIGFuZCBwcm9kdWNlIHRhYmxlIDMsMiwxLDFcbiAgICAgIGJ5IG1vdmluZyB0aGUgcmlnaHQgbW9zdCBieXRlIHRvIHRoZSBsZWZ0IG1vc3QgcG9zaXRpb24ganVzdCBsaWtlXG4gICAgICBob3cgeW91IGNhbiBpbWFnaW5lIHRoZSAzIG1vdmVkIG91dCBvZiAyLDEsMSwzIGFuZCB0byB0aGUgZnJvbnRcbiAgICAgIHRvIHByb2R1Y2UgMywyLDEsMS5cblxuICAgICAgVGhlcmUgaXMgYW5vdGhlciBvcHRpbWl6YXRpb24gaW4gdGhhdCB0aGUgc2FtZSBtdWx0aXBsZXMgb2ZcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQgd2UgbmVlZCBpbiBvcmRlciB0byBhZHZhbmNlIG91ciBnZW5lcmF0b3JcbiAgICAgIHRvIHRoZSBuZXh0IGl0ZXJhdGlvbiBjYW4gYmUgcmV1c2VkIGluIHBlcmZvcm1pbmcgdGhlIDIsMSwxLDNcbiAgICAgIGNhbGN1bGF0aW9uLiBXZSBhbHNvIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZSBtaXggY29sdW1uIHRhYmxlcyxcbiAgICAgIHdpdGggZSw5LGQsYiBiZWluZyB0aGUgaW52ZXJzZSBvZiAyLDEsMSwzLlxuXG4gICAgICBXaGVuIHdlJ3JlIGRvbmUsIGFuZCB3ZSBuZWVkIHRvIGFjdHVhbGx5IG1peCBjb2x1bW5zLCB0aGUgZmlyc3RcbiAgICAgIGJ5dGUgb2YgZWFjaCBzdGF0ZSB3b3JkIHNob3VsZCBiZSBwdXQgdGhyb3VnaCBtaXhbMF0gKDIsMSwxLDMpLFxuICAgICAgdGhlIHNlY29uZCB0aHJvdWdoIG1peFsxXSAoMywyLDEsMSkgYW5kIHNvIGZvcnRoLiBUaGVuIHRoZXkgc2hvdWxkXG4gICAgICBiZSBYT1InZCB0b2dldGhlciB0byBwcm9kdWNlIHRoZSBmdWxseSBtaXhlZCBjb2x1bW4uXG4gICAgKi9cblxuICAgIC8vIGNhbGN1bGF0ZSBtaXggYW5kIGltaXggdGFibGUgdmFsdWVzXG4gICAgc3gyID0geHRpbWVbc3hdO1xuICAgIGUyID0geHRpbWVbZV07XG4gICAgZTQgPSB4dGltZVtlMl07XG4gICAgZTggPSB4dGltZVtlNF07XG4gICAgbWUgPVxuICAgICAgKHN4MiA8PCAyNCkgXiAgLy8gMlxuICAgICAgKHN4IDw8IDE2KSBeICAgLy8gMVxuICAgICAgKHN4IDw8IDgpIF4gICAgLy8gMVxuICAgICAgKHN4IF4gc3gyKTsgICAgLy8gM1xuICAgIGltZSA9XG4gICAgICAoZTIgXiBlNCBeIGU4KSA8PCAyNCBeICAvLyBFICgxNClcbiAgICAgIChlIF4gZTgpIDw8IDE2IF4gICAgICAgIC8vIDlcbiAgICAgIChlIF4gZTQgXiBlOCkgPDwgOCBeICAgIC8vIEQgKDEzKVxuICAgICAgKGUgXiBlMiBeIGU4KTsgICAgICAgICAgLy8gQiAoMTEpXG4gICAgLy8gcHJvZHVjZSBlYWNoIG9mIHRoZSBtaXggdGFibGVzIGJ5IHJvdGF0aW5nIHRoZSAyLDEsMSwzIHZhbHVlXG4gICAgZm9yKHZhciBuID0gMDsgbiA8IDQ7ICsrbikge1xuICAgICAgbWl4W25dW2VdID0gbWU7XG4gICAgICBpbWl4W25dW3N4XSA9IGltZTtcbiAgICAgIC8vIGN5Y2xlIHRoZSByaWdodCBtb3N0IGJ5dGUgdG8gdGhlIGxlZnQgbW9zdCBwb3NpdGlvblxuICAgICAgLy8gaWU6IDIsMSwxLDMgYmVjb21lcyAzLDIsMSwxXG4gICAgICBtZSA9IG1lIDw8IDI0IHwgbWUgPj4+IDg7XG4gICAgICBpbWUgPSBpbWUgPDwgMjQgfCBpbWUgPj4+IDg7XG4gICAgfVxuXG4gICAgLy8gZ2V0IG5leHQgZWxlbWVudCBhbmQgaW52ZXJzZVxuICAgIGlmKGUgPT09IDApIHtcbiAgICAgIC8vIDEgaXMgdGhlIGludmVyc2Ugb2YgMVxuICAgICAgZSA9IGVpID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZSA9IDJlICsgMioyKjIqKDEwZSkpID0gbXVsdGlwbHkgZSBieSA4MiAoY2hvc2VuIGdlbmVyYXRvcilcbiAgICAgIC8vIGVpID0gZWkgKyAyKjIqZWkgPSBtdWx0aXBseSBlaSBieSA1IChpbnZlcnNlIGdlbmVyYXRvcilcbiAgICAgIGUgPSBlMiBeIHh0aW1lW3h0aW1lW3h0aW1lW2UyIF4gZThdXV07XG4gICAgICBlaSBePSB4dGltZVt4dGltZVtlaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleSBzY2hlZHVsZSB1c2luZyB0aGUgQUVTIGtleSBleHBhbnNpb24gYWxnb3JpdGhtLlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHRha2VzIHRoZSBDaXBoZXIgS2V5LCBLLCBhbmQgcGVyZm9ybXMgYSBLZXkgRXhwYW5zaW9uXG4gKiByb3V0aW5lIHRvIGdlbmVyYXRlIGEga2V5IHNjaGVkdWxlLiBUaGUgS2V5IEV4cGFuc2lvbiBnZW5lcmF0ZXMgYSB0b3RhbFxuICogb2YgTmIqKE5yICsgMSkgd29yZHM6IHRoZSBhbGdvcml0aG0gcmVxdWlyZXMgYW4gaW5pdGlhbCBzZXQgb2YgTmIgd29yZHMsXG4gKiBhbmQgZWFjaCBvZiB0aGUgTnIgcm91bmRzIHJlcXVpcmVzIE5iIHdvcmRzIG9mIGtleSBkYXRhLiBUaGUgcmVzdWx0aW5nXG4gKiBrZXkgc2NoZWR1bGUgY29uc2lzdHMgb2YgYSBsaW5lYXIgYXJyYXkgb2YgNC1ieXRlIHdvcmRzLCBkZW5vdGVkIFt3aSBdLFxuICogd2l0aCBpIGluIHRoZSByYW5nZSAwIOKJpCBpIDwgTmIoTnIgKyAxKS5cbiAqXG4gKiBLZXlFeHBhbnNpb24oYnl0ZSBrZXlbNCpOa10sIHdvcmQgd1tOYiooTnIrMSldLCBOaylcbiAqIEFFUy0xMjggKE5iPTQsIE5rPTQsIE5yPTEwKVxuICogQUVTLTE5MiAoTmI9NCwgTms9NiwgTnI9MTIpXG4gKiBBRVMtMjU2IChOYj00LCBOaz04LCBOcj0xNClcbiAqIE5vdGU6IE5yPU5rKzYuXG4gKlxuICogTmIgaXMgdGhlIG51bWJlciBvZiBjb2x1bW5zICgzMi1iaXQgd29yZHMpIGNvbXByaXNpbmcgdGhlIFN0YXRlIChvclxuICogbnVtYmVyIG9mIGJ5dGVzIGluIGEgYmxvY2spLiBGb3IgQUVTLCBOYj00LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBzY2hlZHVsZSAoYXMgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gbW9kaWZ5IHRoZSBrZXkgc2NoZWR1bGUgdG8gZGVjcnlwdCwgZmFsc2Ugbm90IHRvLlxuICpcbiAqIEByZXR1cm4gdGhlIGdlbmVyYXRlZCBrZXkgc2NoZWR1bGUuXG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRLZXkoa2V5LCBkZWNyeXB0KSB7XG4gIC8vIGNvcHkgdGhlIGtleSdzIHdvcmRzIHRvIGluaXRpYWxpemUgdGhlIGtleSBzY2hlZHVsZVxuICB2YXIgdyA9IGtleS5zbGljZSgwKTtcblxuICAvKiBSb3RXb3JkKCkgd2lsbCByb3RhdGUgYSB3b3JkLCBtb3ZpbmcgdGhlIGZpcnN0IGJ5dGUgdG8gdGhlIGxhc3RcbiAgICBieXRlJ3MgcG9zaXRpb24gKHNoaWZ0aW5nIHRoZSBvdGhlciBieXRlcyBsZWZ0KS5cblxuICAgIFdlIHdpbGwgYmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgUmNvbiBhdCBpIC8gTmsuICdpJyB3aWxsIGl0ZXJhdGVcbiAgICBmcm9tIE5rIHRvIChOYiAqIE5yKzEpLiBOayA9IDQgKDQgYnl0ZSBrZXkpLCBOYiA9IDQgKDQgd29yZHMgaW5cbiAgICBhIGJsb2NrKSwgTnIgPSBOayArIDYgKDEwKS4gVGhlcmVmb3JlICdpJyB3aWxsIGl0ZXJhdGUgZnJvbVxuICAgIDQgdG8gNDQgKGV4Y2x1c2l2ZSkuIEVhY2ggdGltZSB3ZSBpdGVyYXRlIDQgdGltZXMsIGkgLyBOayB3aWxsXG4gICAgaW5jcmVhc2UgYnkgMS4gV2UgdXNlIGEgY291bnRlciBpTmsgdG8ga2VlcCB0cmFjayBvZiB0aGlzLlxuICAgKi9cblxuICAvLyBnbyB0aHJvdWdoIHRoZSByb3VuZHMgZXhwYW5kaW5nIHRoZSBrZXlcbiAgdmFyIHRlbXAsIGlOayA9IDE7XG4gIHZhciBOayA9IHcubGVuZ3RoO1xuICB2YXIgTnIxID0gTmsgKyA2ICsgMTtcbiAgdmFyIGVuZCA9IE5iICogTnIxO1xuICBmb3IodmFyIGkgPSBOazsgaSA8IGVuZDsgKytpKSB7XG4gICAgdGVtcCA9IHdbaSAtIDFdO1xuICAgIGlmKGkgJSBOayA9PT0gMCkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQoUm90V29yZCh0ZW1wKSkgXiBSY29uW2kgLyBOa11cbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDE2ICYgMjU1XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gOCAmIDI1NV0gPDwgMTYgXlxuICAgICAgICBzYm94W3RlbXAgJiAyNTVdIDw8IDggXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSBeIChyY29uW2lOa10gPDwgMjQpO1xuICAgICAgaU5rKys7XG4gICAgfSBlbHNlIGlmKE5rID4gNiAmJiAoaSAlIE5rID09PSA0KSkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQodGVtcClcbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gMTYgJiAyNTVdIDw8IDE2IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiA4ICYgMjU1XSA8PCA4IF5cbiAgICAgICAgc2JveFt0ZW1wICYgMjU1XTtcbiAgICB9XG4gICAgd1tpXSA9IHdbaSAtIE5rXSBeIHRlbXA7XG4gIH1cblxuICAgLyogV2hlbiB3ZSBhcmUgdXBkYXRpbmcgYSBjaXBoZXIgYmxvY2sgd2UgYWx3YXlzIHVzZSB0aGUgY29kZSBwYXRoIGZvclxuICAgICBlbmNyeXB0aW9uIHdoZXRoZXIgd2UgYXJlIGRlY3J5cHRpbmcgb3Igbm90ICh0byBzaG9ydGVuIGNvZGUgYW5kXG4gICAgIHNpbXBsaWZ5IHRoZSBnZW5lcmF0aW9uIG9mIGxvb2sgdXAgdGFibGVzKS4gSG93ZXZlciwgYmVjYXVzZSB0aGVyZVxuICAgICBhcmUgZGlmZmVyZW5jZXMgaW4gdGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtLCBvdGhlciB0aGFuIGp1c3Qgc3dhcHBpbmdcbiAgICAgaW4gZGlmZmVyZW50IGxvb2sgdXAgdGFibGVzLCB3ZSBtdXN0IHRyYW5zZm9ybSBvdXIga2V5IHNjaGVkdWxlIHRvXG4gICAgIGFjY291bnQgZm9yIHRoZXNlIGNoYW5nZXM6XG5cbiAgICAgMS4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGdldHMgaXRzIGtleSByb3VuZHMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgMi4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGFkZHMgdGhlIHJvdW5kIGtleSBiZWZvcmUgbWl4aW5nIGNvbHVtbnNcbiAgICAgICBpbnN0ZWFkIG9mIGFmdGVyd2FyZHMuXG5cbiAgICAgV2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgb3VyIGtleSBzY2hlZHVsZSB0byBoYW5kbGUgdGhlIGZpcnN0IGNhc2UsXG4gICAgIHdlIGNhbiBqdXN0IHRyYXZlcnNlIHRoZSBrZXkgc2NoZWR1bGUgaW4gcmV2ZXJzZSBvcmRlciB3aGVuIGRlY3J5cHRpbmcuXG5cbiAgICAgVGhlIHNlY29uZCBjYXNlIHJlcXVpcmVzIGEgbGl0dGxlIHdvcmsuXG5cbiAgICAgVGhlIHRhYmxlcyB3ZSBidWlsdCBmb3IgcGVyZm9ybWluZyByb3VuZHMgd2lsbCB0YWtlIGFuIGlucHV0IGFuZCB0aGVuXG4gICAgIHBlcmZvcm0gU3ViQnl0ZXMoKSBhbmQgTWl4Q29sdW1ucygpIG9yLCBmb3IgdGhlIGRlY3J5cHQgdmVyc2lvbixcbiAgICAgSW52U3ViQnl0ZXMoKSBhbmQgSW52TWl4Q29sdW1ucygpLiBCdXQgdGhlIGRlY3J5cHQgYWxnb3JpdGhtIHJlcXVpcmVzXG4gICAgIHVzIHRvIEFkZFJvdW5kS2V5KCkgYmVmb3JlIEludk1peENvbHVtbnMoKS4gVGhpcyBtZWFucyB3ZSdsbCBuZWVkIHRvXG4gICAgIGFwcGx5IHNvbWUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByb3VuZCBrZXkgdG8gaW52ZXJzZS1taXggaXRzIGNvbHVtbnNcbiAgICAgc28gdGhleSdsbCBiZSBjb3JyZWN0IGZvciBtb3ZpbmcgQWRkUm91bmRLZXkoKSB0byBhZnRlciB0aGUgc3RhdGUgaGFzXG4gICAgIGhhZCBpdHMgY29sdW1ucyBpbnZlcnNlLW1peGVkLlxuXG4gICAgIFRvIGludmVyc2UtbWl4IHRoZSBjb2x1bW5zIG9mIHRoZSBzdGF0ZSB3aGVuIHdlJ3JlIGRlY3J5cHRpbmcgd2UgdXNlIGFcbiAgICAgbG9va3VwIHRhYmxlIHRoYXQgd2lsbCBhcHBseSBJbnZTdWJCeXRlcygpIGFuZCBJbnZNaXhDb2x1bW5zKCkgYXQgdGhlXG4gICAgIHNhbWUgdGltZS4gSG93ZXZlciwgdGhlIHJvdW5kIGtleSdzIGJ5dGVzIGFyZSBub3QgaW52ZXJzZS1zdWJzdGl0dXRlZFxuICAgICBpbiB0aGUgZGVjcnlwdGlvbiBhbGdvcml0aG0uIFRvIGdldCBhcm91bmQgdGhpcyBwcm9ibGVtLCB3ZSBjYW4gZmlyc3RcbiAgICAgc3Vic3RpdHV0ZSB0aGUgYnl0ZXMgaW4gdGhlIHJvdW5kIGtleSBzbyB0aGF0IHdoZW4gd2UgYXBwbHkgdGhlXG4gICAgIHRyYW5zZm9ybWF0aW9uIHZpYSB0aGUgSW52U3ViQnl0ZXMoKStJbnZNaXhDb2x1bW5zKCkgdGFibGUsIGl0IHdpbGxcbiAgICAgdW5kbyBvdXIgc3Vic3RpdHV0aW9uIGxlYXZpbmcgdXMgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUgdGhhdCB3ZVxuICAgICB3YW50IC0tIGFuZCB0aGVuIGludmVyc2UtbWl4IHRoYXQgdmFsdWUuXG5cbiAgICAgVGhpcyBjaGFuZ2Ugd2lsbCBjb3JyZWN0bHkgYWx0ZXIgb3VyIGtleSBzY2hlZHVsZSBzbyB0aGF0IHdlIGNhbiBYT1JcbiAgICAgZWFjaCByb3VuZCBrZXkgd2l0aCBvdXIgYWxyZWFkeSB0cmFuc2Zvcm1lZCBkZWNyeXB0aW9uIHN0YXRlLiBUaGlzXG4gICAgIGFsbG93cyB1cyB0byB1c2UgdGhlIHNhbWUgY29kZSBwYXRoIGFzIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobS5cblxuICAgICBXZSBtYWtlIG9uZSBtb3JlIGNoYW5nZSB0byB0aGUgZGVjcnlwdGlvbiBrZXkuIFNpbmNlIHRoZSBkZWNyeXB0aW9uXG4gICAgIGFsZ29yaXRobSBydW5zIGluIHJldmVyc2UgZnJvbSB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0sIHdlIHJldmVyc2VcbiAgICAgdGhlIG9yZGVyIG9mIHRoZSByb3VuZCBrZXlzIHRvIGF2b2lkIGhhdmluZyB0byBpdGVyYXRlIG92ZXIgdGhlIGtleVxuICAgICBzY2hlZHVsZSBiYWNrd2FyZHMgd2hlbiBydW5uaW5nIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBsYXRlciBpblxuICAgICBkZWNyeXB0aW9uIG1vZGUuIEluIGFkZGl0aW9uIHRvIHJldmVyc2luZyB0aGUgb3JkZXIgb2YgdGhlIHJvdW5kIGtleXMsXG4gICAgIHdlIGFsc28gc3dhcCBlYWNoIHJvdW5kIGtleSdzIDJuZCBhbmQgNHRoIHJvd3MuIFNlZSB0aGUgY29tbWVudHNcbiAgICAgc2VjdGlvbiB3aGVyZSByb3VuZHMgYXJlIHBlcmZvcm1lZCBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoeSB0aGlzIGlzXG4gICAgIGRvbmUuIFRoZXNlIGNoYW5nZXMgYXJlIGRvbmUgaW5saW5lIHdpdGggdGhlIG90aGVyIHN1YnN0aXR1dGlvblxuICAgICBkZXNjcmliZWQgYWJvdmUuXG4gICovXG4gIGlmKGRlY3J5cHQpIHtcbiAgICB2YXIgdG1wO1xuICAgIHZhciBtMCA9IGltaXhbMF07XG4gICAgdmFyIG0xID0gaW1peFsxXTtcbiAgICB2YXIgbTIgPSBpbWl4WzJdO1xuICAgIHZhciBtMyA9IGltaXhbM107XG4gICAgdmFyIHduZXcgPSB3LnNsaWNlKDApO1xuICAgIGVuZCA9IHcubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIHdpID0gZW5kIC0gTmI7IGkgPCBlbmQ7IGkgKz0gTmIsIHdpIC09IE5iKSB7XG4gICAgICAvLyBkbyBub3Qgc3ViIHRoZSBmaXJzdCBvciBsYXN0IHJvdW5kIGtleSAocm91bmQga2V5cyBhcmUgTmJcbiAgICAgIC8vIHdvcmRzKSBhcyBubyBjb2x1bW4gbWl4aW5nIGlzIHBlcmZvcm1lZCBiZWZvcmUgdGhleSBhcmUgYWRkZWQsXG4gICAgICAvLyBidXQgZG8gY2hhbmdlIHRoZSBrZXkgb3JkZXJcbiAgICAgIGlmKGkgPT09IDAgfHwgaSA9PT0gKGVuZCAtIE5iKSkge1xuICAgICAgICB3bmV3W2ldID0gd1t3aV07XG4gICAgICAgIHduZXdbaSArIDFdID0gd1t3aSArIDNdO1xuICAgICAgICB3bmV3W2kgKyAyXSA9IHdbd2kgKyAyXTtcbiAgICAgICAgd25ld1tpICsgM10gPSB3W3dpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWJzdGl0dXRlIGVhY2ggcm91bmQga2V5IGJ5dGUgYmVjYXVzZSB0aGUgaW52ZXJzZS1taXhcbiAgICAgICAgLy8gdGFibGUgd2lsbCBpbnZlcnNlLXN1YnN0aXR1dGUgaXQgKGVmZmVjdGl2ZWx5IGNhbmNlbCB0aGVcbiAgICAgICAgLy8gc3Vic3RpdHV0aW9uIGJlY2F1c2Ugcm91bmQga2V5IGJ5dGVzIGFyZW4ndCBzdWInZCBpblxuICAgICAgICAvLyBkZWNyeXB0aW9uIG1vZGUpIGFuZCBzd2FwIGluZGV4ZXMgMyBhbmQgMVxuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgTmI7ICsrbikge1xuICAgICAgICAgIHRtcCA9IHdbd2kgKyBuXTtcbiAgICAgICAgICB3bmV3W2kgKyAoMyYtbildID1cbiAgICAgICAgICAgIG0wW3Nib3hbdG1wID4+PiAyNF1dIF5cbiAgICAgICAgICAgIG0xW3Nib3hbdG1wID4+PiAxNiAmIDI1NV1dIF5cbiAgICAgICAgICAgIG0yW3Nib3hbdG1wID4+PiA4ICYgMjU1XV0gXlxuICAgICAgICAgICAgbTNbc2JveFt0bXAgJiAyNTVdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3ID0gd25ldztcbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDE2IGJ5dGVzKSB1c2luZyBBRVMuIFRoZSB1cGRhdGUgd2lsbCBlaXRoZXJcbiAqIGVuY3J5cHQgb3IgZGVjcnlwdCB0aGUgYmxvY2suXG4gKlxuICogQHBhcmFtIHcgdGhlIGtleSBzY2hlZHVsZS5cbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgYmxvY2sgKGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSB1cGRhdGVkIG91dHB1dCBibG9jay5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZGVjcnlwdCB0aGUgYmxvY2ssIGZhbHNlIHRvIGVuY3J5cHQgaXQuXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayh3LCBpbnB1dCwgb3V0cHV0LCBkZWNyeXB0KSB7XG4gIC8qXG4gIENpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBmb3Igcm91bmQgPSAxIHN0ZXAgMSB0byBOcuKAkzFcbiAgICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgICAgTWl4Q29sdW1ucyhzdGF0ZSlcbiAgICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W3JvdW5kKk5iLCAocm91bmQrMSkqTmItMV0pXG4gICAgZW5kIGZvclxuICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuXG4gIEludkNpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIGZvciByb3VuZCA9IE5yLTEgc3RlcCAtMSBkb3dudG8gMVxuICAgICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgICAgSW52U3ViQnl0ZXMoc3RhdGUpXG4gICAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tyb3VuZCpOYiwgKHJvdW5kKzEpKk5iLTFdKVxuICAgICAgSW52TWl4Q29sdW1ucyhzdGF0ZSlcbiAgICBlbmQgZm9yXG4gICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgIEludlN1YkJ5dGVzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuICAqL1xuXG4gIC8vIEVuY3J5cHQ6IEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAvLyBEZWNyeXB0OiBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICB2YXIgTnIgPSB3Lmxlbmd0aCAvIDQgLSAxO1xuICB2YXIgbTAsIG0xLCBtMiwgbTMsIHN1YjtcbiAgaWYoZGVjcnlwdCkge1xuICAgIG0wID0gaW1peFswXTtcbiAgICBtMSA9IGltaXhbMV07XG4gICAgbTIgPSBpbWl4WzJdO1xuICAgIG0zID0gaW1peFszXTtcbiAgICBzdWIgPSBpc2JveDtcbiAgfSBlbHNlIHtcbiAgICBtMCA9IG1peFswXTtcbiAgICBtMSA9IG1peFsxXTtcbiAgICBtMiA9IG1peFsyXTtcbiAgICBtMyA9IG1peFszXTtcbiAgICBzdWIgPSBzYm94O1xuICB9XG4gIHZhciBhLCBiLCBjLCBkLCBhMiwgYjIsIGMyO1xuICBhID0gaW5wdXRbMF0gXiB3WzBdO1xuICBiID0gaW5wdXRbZGVjcnlwdCA/IDMgOiAxXSBeIHdbMV07XG4gIGMgPSBpbnB1dFsyXSBeIHdbMl07XG4gIGQgPSBpbnB1dFtkZWNyeXB0ID8gMSA6IDNdIF4gd1szXTtcbiAgdmFyIGkgPSAzO1xuXG4gIC8qIEluIG9yZGVyIHRvIHNoYXJlIGNvZGUgd2UgZm9sbG93IHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB3aGVuIGJvdGhcbiAgICBlbmNyeXB0aW5nIGFuZCBkZWNyeXB0aW5nLiBUbyBhY2NvdW50IGZvciB0aGUgY2hhbmdlcyByZXF1aXJlZCBpbiB0aGVcbiAgICBkZWNyeXB0aW9uIGFsZ29yaXRobSwgd2UgdXNlIGRpZmZlcmVudCBsb29rdXAgdGFibGVzIHdoZW4gZGVjcnlwdGluZ1xuICAgIGFuZCB1c2UgYSBtb2RpZmllZCBrZXkgc2NoZWR1bGUgdG8gYWNjb3VudCBmb3IgdGhlIGRpZmZlcmVuY2UgaW4gdGhlXG4gICAgb3JkZXIgb2YgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHJvdW5kcy4gV2UgYWxzbyBnZXRcbiAgICBrZXkgcm91bmRzIGluIHJldmVyc2Ugb3JkZXIgKHJlbGF0aXZlIHRvIGVuY3J5cHRpb24pLiAqL1xuICBmb3IodmFyIHJvdW5kID0gMTsgcm91bmQgPCBOcjsgKytyb3VuZCkge1xuICAgIC8qIEFzIGRlc2NyaWJlZCBhYm92ZSwgd2UnbGwgYmUgdXNpbmcgdGFibGUgbG9va3VwcyB0byBwZXJmb3JtIHRoZVxuICAgICAgY29sdW1uIG1peGluZy4gRWFjaCBjb2x1bW4gaXMgc3RvcmVkIGFzIGEgd29yZCBpbiB0aGUgc3RhdGUgKHRoZVxuICAgICAgYXJyYXkgJ2lucHV0JyBoYXMgb25lIGNvbHVtbiBhcyBhIHdvcmQgYXQgZWFjaCBpbmRleCkuIEluIG9yZGVyIHRvXG4gICAgICBtaXggYSBjb2x1bW4sIHdlIHBlcmZvcm0gdGhlc2UgdHJhbnNmb3JtYXRpb25zIG9uIGVhY2ggcm93IGluIGMsXG4gICAgICB3aGljaCBpcyAxIGJ5dGUgaW4gZWFjaCB3b3JkLiBUaGUgbmV3IGNvbHVtbiBmb3IgYzAgaXMgYycwOlxuXG4gICAgICAgICAgICAgICBtMCAgICAgIG0xICAgICAgbTIgICAgICBtM1xuICAgICAgcjAsYycwID0gMipyMCxjMCArIDMqcjEsYzAgKyAxKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjEsYycwID0gMSpyMCxjMCArIDIqcjEsYzAgKyAzKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjIsYycwID0gMSpyMCxjMCArIDEqcjEsYzAgKyAyKnIyLGMwICsgMypyMyxjMFxuICAgICAgcjMsYycwID0gMypyMCxjMCArIDEqcjEsYzAgKyAxKnIyLGMwICsgMipyMyxjMFxuXG4gICAgICBTbyB1c2luZyBtaXggdGFibGVzIHdoZXJlIGMwIGlzIGEgd29yZCB3aXRoIHIwIGJlaW5nIGl0cyB1cHBlclxuICAgICAgOCBiaXRzIGFuZCByMyBiZWluZyBpdHMgbG93ZXIgOCBiaXRzOlxuXG4gICAgICBtMFtjMCA+PiAyNF0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsyKnIwLDEqcjAsMSpyMCwzKnIwXVxuICAgICAgLi4uXG4gICAgICBtM1tjMCAmIDI1NV0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsxKnIzLDEqcjMsMypyMywyKnIzXVxuXG4gICAgICBUaGVyZWZvcmUgdG8gbWl4IHRoZSBjb2x1bW5zIGluIGVhY2ggd29yZCBpbiB0aGUgc3RhdGUgd2VcbiAgICAgIGRvIHRoZSBmb2xsb3dpbmcgKCYgMjU1IG9taXR0ZWQgZm9yIGJyZXZpdHkpOlxuICAgICAgYycwLHIwID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cbiAgICAgIGMnMCxyMSA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG4gICAgICBjJzAscjIgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuICAgICAgYycwLHIzID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cblxuICAgICAgSG93ZXZlciwgYmVmb3JlIG1peGluZywgdGhlIGFsZ29yaXRobSByZXF1aXJlcyB1cyB0byBwZXJmb3JtXG4gICAgICBTaGlmdFJvd3MoKS4gVGhlIFNoaWZ0Um93cygpIHRyYW5zZm9ybWF0aW9uIGN5Y2xpY2FsbHkgc2hpZnRzIHRoZVxuICAgICAgbGFzdCAzIHJvd3Mgb2YgdGhlIHN0YXRlIG92ZXIgZGlmZmVyZW50IG9mZnNldHMuIFRoZSBmaXJzdCByb3dcbiAgICAgIChyID0gMCkgaXMgbm90IHNoaWZ0ZWQuXG5cbiAgICAgIHMnX3IsYyA9IHNfciwoYyArIHNoaWZ0KHIsIE5iKSBtb2QgTmJcbiAgICAgIGZvciAwIDwgciA8IDQgYW5kIDAgPD0gYyA8IE5iIGFuZFxuICAgICAgc2hpZnQoMSwgNCkgPSAxXG4gICAgICBzaGlmdCgyLCA0KSA9IDJcbiAgICAgIHNoaWZ0KDMsIDQpID0gMy5cblxuICAgICAgVGhpcyBjYXVzZXMgdGhlIGZpcnN0IGJ5dGUgaW4gciA9IDEgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDIgYnl0ZXMgaW4gciA9IDIgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDMgYnl0ZXMgaW4gciA9IDMgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdzpcblxuICAgICAgcjE6IFtjMCBjMSBjMiBjM10gPT4gW2MxIGMyIGMzIGMwXVxuICAgICAgcjI6IFtjMCBjMSBjMiBjM10gICAgW2MyIGMzIGMwIGMxXVxuICAgICAgcjM6IFtjMCBjMSBjMiBjM10gICAgW2MzIGMwIGMxIGMyXVxuXG4gICAgICBXZSBjYW4gbWFrZSB0aGVzZSBzdWJzdGl0dXRpb25zIGlubGluZSB3aXRoIG91ciBjb2x1bW4gbWl4aW5nIHRvXG4gICAgICBnZW5lcmF0ZSBhbiB1cGRhdGVkIHNldCBvZiBlcXVhdGlvbnMgdG8gcHJvZHVjZSBlYWNoIHdvcmQgaW4gdGhlXG4gICAgICBzdGF0ZSAobm90ZSB0aGUgY29sdW1ucyBoYXZlIGNoYW5nZWQgcG9zaXRpb25zKTpcblxuICAgICAgYzAgYzEgYzIgYzMgPT4gYzAgYzEgYzIgYzNcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMxIGMyIGMzIGMwICAoY3ljbGVkIDEgYnl0ZSlcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMyIGMzIGMwIGMxICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMyBjMCBjMSBjMiAgKGN5Y2xlZCAzIGJ5dGVzKVxuXG4gICAgICBUaGVyZWZvcmU6XG5cbiAgICAgIGMnMCA9IDIqcjAsYzAgKyAzKnIxLGMxICsgMSpyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAyKnIxLGMxICsgMypyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAxKnIxLGMxICsgMipyMixjMiArIDMqcjMsYzNcbiAgICAgIGMnMCA9IDMqcjAsYzAgKyAxKnIxLGMxICsgMSpyMixjMiArIDIqcjMsYzNcblxuICAgICAgYycxID0gMipyMCxjMSArIDMqcjEsYzIgKyAxKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDIqcjEsYzIgKyAzKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDEqcjEsYzIgKyAyKnIyLGMzICsgMypyMyxjMFxuICAgICAgYycxID0gMypyMCxjMSArIDEqcjEsYzIgKyAxKnIyLGMzICsgMipyMyxjMFxuXG4gICAgICAuLi4gYW5kIHNvIGZvcnRoIGZvciBjJzIgYW5kIGMnMy4gVGhlIGltcG9ydGFudCBkaXN0aW5jdGlvbiBpc1xuICAgICAgdGhhdCB0aGUgY29sdW1ucyBhcmUgY3ljbGluZywgd2l0aCBjMCBiZWluZyB1c2VkIHdpdGggdGhlIG0wXG4gICAgICBtYXAgd2hlbiBjYWxjdWxhdGluZyBjMCwgYnV0IGMxIGJlaW5nIHVzZWQgd2l0aCB0aGUgbTAgbWFwIHdoZW5cbiAgICAgIGNhbGN1bGF0aW5nIGMxIC4uLiBhbmQgc28gZm9ydGguXG5cbiAgICAgIFdoZW4gcGVyZm9ybWluZyB0aGUgaW52ZXJzZSB3ZSB0cmFuc2Zvcm0gdGhlIG1pcnJvciBpbWFnZSBhbmRcbiAgICAgIHNraXAgdGhlIGJvdHRvbSByb3csIGluc3RlYWQgb2YgdGhlIHRvcCBvbmUsIGFuZCBtb3ZlIHVwd2FyZHM6XG5cbiAgICAgIGMzIGMyIGMxIGMwID0+IGMwIGMzIGMyIGMxICAoY3ljbGVkIDMgYnl0ZXMpICpzYW1lIGFzIGVuY3J5cHRpb25cbiAgICAgIGMzIGMyIGMxIGMwICAgIGMxIGMwIGMzIGMyICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMiBjMSBjMCBjMyAgKGN5Y2xlZCAxIGJ5dGUpICAqc2FtZSBhcyBlbmNyeXB0aW9uXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMyBjMiBjMSBjMFxuXG4gICAgICBJZiB5b3UgY29tcGFyZSB0aGUgcmVzdWx0aW5nIG1hdHJpY2VzIGZvciBTaGlmdFJvd3MoKStNaXhDb2x1bW5zKClcbiAgICAgIGFuZCBmb3IgSW52U2hpZnRSb3dzKCkrSW52TWl4Q29sdW1ucygpIHRoZSAybmQgYW5kIDR0aCBjb2x1bW5zIGFyZVxuICAgICAgZGlmZmVyZW50IChpbiBlbmNyeXB0IG1vZGUgdnMuIGRlY3J5cHQgbW9kZSkuIFNvIGluIG9yZGVyIHRvIHVzZVxuICAgICAgdGhlIHNhbWUgY29kZSB0byBoYW5kbGUgYm90aCBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLCB3ZSB3aWxsXG4gICAgICBuZWVkIHRvIGRvIHNvbWUgbWFwcGluZy5cblxuICAgICAgSWYgaW4gZW5jcnlwdGlvbiBtb2RlIHdlIGxldCBhPWMwLCBiPWMxLCBjPWMyLCBkPWMzLCBhbmQgcjxOPiBiZVxuICAgICAgYSByb3cgbnVtYmVyIGluIHRoZSBzdGF0ZSwgdGhlbiB0aGUgcmVzdWx0aW5nIG1hdHJpeCBpbiBlbmNyeXB0aW9uXG4gICAgICBtb2RlIGZvciBhcHBseWluZyB0aGUgYWJvdmUgdHJhbnNmb3JtYXRpb25zIHdvdWxkIGJlOlxuXG4gICAgICByMTogYSBiIGMgZFxuICAgICAgcjI6IGIgYyBkIGFcbiAgICAgIHIzOiBjIGQgYSBiXG4gICAgICByNDogZCBhIGIgY1xuXG4gICAgICBJZiB3ZSBkaWQgdGhlIHNhbWUgaW4gZGVjcnlwdGlvbiBtb2RlIHdlIHdvdWxkIGdldDpcblxuICAgICAgcjE6IGEgZCBjIGJcbiAgICAgIHIyOiBiIGEgZCBjXG4gICAgICByMzogYyBiIGEgZFxuICAgICAgcjQ6IGQgYyBiIGFcblxuICAgICAgSWYgaW5zdGVhZCB3ZSBzd2FwIGQgYW5kIGIgKHNldCBiPWMzIGFuZCBkPWMxKSwgdGhlbiB3ZSBnZXQ6XG5cbiAgICAgIHIxOiBhIGIgYyBkXG4gICAgICByMjogZCBhIGIgY1xuICAgICAgcjM6IGMgZCBhIGJcbiAgICAgIHI0OiBiIGMgZCBhXG5cbiAgICAgIE5vdyB0aGUgMXN0IGFuZCAzcmQgcm93cyBhcmUgdGhlIHNhbWUgYXMgdGhlIGVuY3J5cHRpb24gbWF0cml4LiBBbGxcbiAgICAgIHdlIG5lZWQgdG8gZG8gdGhlbiB0byBtYWtlIHRoZSBtYXBwaW5nIGV4YWN0bHkgdGhlIHNhbWUgaXMgdG8gc3dhcFxuICAgICAgdGhlIDJuZCBhbmQgNHRoIHJvd3Mgd2hlbiBpbiBkZWNyeXB0aW9uIG1vZGUuIFRvIGRvIHRoaXMgd2l0aG91dFxuICAgICAgaGF2aW5nIHRvIGRvIGl0IG9uIGVhY2ggaXRlcmF0aW9uLCB3ZSBzd2FwcGVkIHRoZSAybmQgYW5kIDR0aCByb3dzXG4gICAgICBpbiB0aGUgZGVjcnlwdGlvbiBrZXkgc2NoZWR1bGUuIFdlIGFsc28gaGF2ZSB0byBkbyB0aGUgc3dhcCBhYm92ZVxuICAgICAgd2hlbiB3ZSBmaXJzdCBwdWxsIGluIHRoZSBpbnB1dCBhbmQgd2hlbiB3ZSBzZXQgdGhlIGZpbmFsIG91dHB1dC4gKi9cbiAgICBhMiA9XG4gICAgICBtMFthID4+PiAyNF0gXlxuICAgICAgbTFbYiA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2MgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2QgJiAyNTVdIF4gd1srK2ldO1xuICAgIGIyID1cbiAgICAgIG0wW2IgPj4+IDI0XSBeXG4gICAgICBtMVtjID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbZCA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYSAmIDI1NV0gXiB3WysraV07XG4gICAgYzIgPVxuICAgICAgbTBbYyA+Pj4gMjRdIF5cbiAgICAgIG0xW2QgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMlthID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1tiICYgMjU1XSBeIHdbKytpXTtcbiAgICBkID1cbiAgICAgIG0wW2QgPj4+IDI0XSBeXG4gICAgICBtMVthID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbYiA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYyAmIDI1NV0gXiB3WysraV07XG4gICAgYSA9IGEyO1xuICAgIGIgPSBiMjtcbiAgICBjID0gYzI7XG4gIH1cblxuICAvKlxuICAgIEVuY3J5cHQ6XG4gICAgU3ViQnl0ZXMoc3RhdGUpXG4gICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W05yKk5iLCAoTnIrMSkqTmItMV0pXG5cbiAgICBEZWNyeXB0OlxuICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICBJbnZTdWJCeXRlcyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICovXG4gICAvLyBOb3RlOiByb3dzIGFyZSBzaGlmdGVkIGlubGluZVxuICBvdXRwdXRbMF0gPVxuICAgIChzdWJbYSA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltiID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2MgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2QgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0W2RlY3J5cHQgPyAzIDogMV0gPVxuICAgIChzdWJbYiA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltjID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2QgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2EgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0WzJdID1cbiAgICAoc3ViW2MgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbZCA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YlthID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltiICYgMjU1XSkgXiB3WysraV07XG4gIG91dHB1dFtkZWNyeXB0ID8gMSA6IDNdID1cbiAgICAoc3ViW2QgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbYSA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YltiID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltjICYgMjU1XSkgXiB3WysraV07XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBBRVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqICAgICAgICAgIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbW9kZSA9IChvcHRpb25zLm1vZGUgfHwgJ0NCQycpLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBhbGdvcml0aG0gPSAnQUVTLScgKyBtb2RlO1xuXG4gIHZhciBjaXBoZXI7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGlibGUgc3RhcnQgQVBJXG4gIHZhciBzdGFydCA9IGNpcGhlci5zdGFydDtcbiAgY2lwaGVyLnN0YXJ0ID0gZnVuY3Rpb24oaXYsIG9wdGlvbnMpIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogc3VwcG9ydCBzZWNvbmQgYXJnIGFzIG91dHB1dCBidWZmZXJcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZihvcHRpb25zIGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKSB7XG4gICAgICBvdXRwdXQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm91dHB1dCA9IG91dHB1dDtcbiAgICBvcHRpb25zLml2ID0gaXY7XG4gICAgc3RhcnQuY2FsbChjaXBoZXIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBiYXNpYyBQRU0gKFByaXZhY3kgRW5oYW5jZWQgTWFpbCkgYWxnb3JpdGhtcy5cbiAqXG4gKiBTZWU6IFJGQyAxNDIxLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBIEZvcmdlIFBFTSBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqIHR5cGU6IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgbWVzc2FnZSAoZWc6IFwiUlNBIFBSSVZBVEUgS0VZXCIpLlxuICpcbiAqIHByb2NUeXBlOiBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIHByb2Nlc3NpbmcgcGVyZm9ybWVkIG9uIHRoZSBtZXNzYWdlLFxuICogICBpdCBoYXMgdHdvIHN1YmZpZWxkczogdmVyc2lvbiBhbmQgdHlwZSwgZWc6IDQsRU5DUllQVEVELlxuICpcbiAqIGNvbnRlbnREb21haW46IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgY29udGVudCBpbiB0aGUgbWVzc2FnZSwgdHlwaWNhbGx5XG4gKiAgIG9ubHkgdXNlcyB0aGUgdmFsdWU6IFwiUkZDODIyXCIuXG4gKlxuICogZGVrSW5mbzogaWRlbnRpZmllcyB0aGUgbWVzc2FnZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBhbmQgbW9kZSBhbmQgaW5jbHVkZXNcbiAqICAgYW55IHBhcmFtZXRlcnMgZm9yIHRoZSBhbGdvcml0aG0sIGl0IGhhcyB0d28gc3ViZmllbGRzOiBhbGdvcml0aG0gYW5kXG4gKiAgIHBhcmFtZXRlcnMsIGVnOiBERVMtQ0JDLEY4MTQzRURFNTk2MEM1OTcuXG4gKlxuICogaGVhZGVyczogY29udGFpbnMgYWxsIG90aGVyIFBFTSBlbmNhcHN1bGF0ZWQgaGVhZGVycyAtLSB3aGVyZSBvcmRlciBpc1xuICogICBzaWduaWZpY2FudCAoZm9yIHBhaXJpbmcgZGF0YSBsaWtlIHJlY2lwaWVudCBJRCArIGtleSBpbmZvKS5cbiAqXG4gKiBib2R5OiB0aGUgYmluYXJ5LWVuY29kZWQgYm9keS5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIHNob3J0Y3V0IGZvciBwZW0gQVBJXG52YXIgcGVtID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wZW0gPSBmb3JnZS5wZW0gfHwge307XG5cbi8qKlxuICogRW5jb2RlcyAoc2VyaWFsaXplcykgdGhlIGdpdmVuIFBFTSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1zZyB0aGUgUEVNIG1lc3NhZ2Ugb2JqZWN0IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSBmb3IgdGhlIGJvZHksIChkZWZhdWx0OiA2NCkuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbnBlbS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBydmFsID0gJy0tLS0tQkVHSU4gJyArIG1zZy50eXBlICsgJy0tLS0tXFxyXFxuJztcblxuICAvLyBlbmNvZGUgc3BlY2lhbCBoZWFkZXJzXG4gIHZhciBoZWFkZXI7XG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIGhlYWRlciA9IHtcbiAgICAgIG5hbWU6ICdQcm9jLVR5cGUnLFxuICAgICAgdmFsdWVzOiBbU3RyaW5nKG1zZy5wcm9jVHlwZS52ZXJzaW9uKSwgbXNnLnByb2NUeXBlLnR5cGVdXG4gICAgfTtcbiAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgfVxuICBpZihtc2cuY29udGVudERvbWFpbikge1xuICAgIGhlYWRlciA9IHtuYW1lOiAnQ29udGVudC1Eb21haW4nLCB2YWx1ZXM6IFttc2cuY29udGVudERvbWFpbl19O1xuICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICB9XG4gIGlmKG1zZy5kZWtJbmZvKSB7XG4gICAgaGVhZGVyID0ge25hbWU6ICdERUstSW5mbycsIHZhbHVlczogW21zZy5kZWtJbmZvLmFsZ29yaXRobV19O1xuICAgIGlmKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpIHtcbiAgICAgIGhlYWRlci52YWx1ZXMucHVzaChtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgcnZhbCArPSBmb2xkSGVhZGVyKGhlYWRlcik7XG4gIH1cblxuICBpZihtc2cuaGVhZGVycykge1xuICAgIC8vIGVuY29kZSBhbGwgb3RoZXIgaGVhZGVyc1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cuaGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgcnZhbCArPSBmb2xkSGVhZGVyKG1zZy5oZWFkZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyB0ZXJtaW5hdGUgaGVhZGVyXG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIHJ2YWwgKz0gJ1xcclxcbic7XG4gIH1cblxuICAvLyBhZGQgYm9keVxuICBydmFsICs9IGZvcmdlLnV0aWwuZW5jb2RlNjQobXNnLmJvZHksIG9wdGlvbnMubWF4bGluZSB8fCA2NCkgKyAnXFxyXFxuJztcblxuICBydmFsICs9ICctLS0tLUVORCAnICsgbXNnLnR5cGUgKyAnLS0tLS1cXHJcXG4nO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyAoZGVzZXJpYWxpemVzKSBhbGwgUEVNIG1lc3NhZ2VzIGZvdW5kIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTSBtZXNzYWdlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gKi9cbnBlbS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBzcGxpdCBzdHJpbmcgaW50byBQRU0gbWVzc2FnZXMgKGJlIGxlbmllbnQgdy9FT0Ygb24gQkVHSU4gbGluZSlcbiAgdmFyIHJNZXNzYWdlID0gL1xccyotLS0tLUJFR0lOIChbQS1aMC05LSBdKyktLS0tLVxccj9cXG4/KFtcXHgyMS1cXHg3ZVxcc10rPyg/Olxccj9cXG5cXHI/XFxuKSk/KFs6QS1aYS16MC05K1xcLz1cXHNdKz8pLS0tLS1FTkQgXFwxLS0tLS0vZztcbiAgdmFyIHJIZWFkZXIgPSAvKFtcXHgyMS1cXHg3ZV0rKTpcXHMqKFtcXHgyMS1cXHg3ZVxcc146XSspLztcbiAgdmFyIHJDUkxGID0gL1xccj9cXG4vO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlKHRydWUpIHtcbiAgICBtYXRjaCA9IHJNZXNzYWdlLmV4ZWMoc3RyKTtcbiAgICBpZighbWF0Y2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtc2cgPSB7XG4gICAgICB0eXBlOiBtYXRjaFsxXSxcbiAgICAgIHByb2NUeXBlOiBudWxsLFxuICAgICAgY29udGVudERvbWFpbjogbnVsbCxcbiAgICAgIGRla0luZm86IG51bGwsXG4gICAgICBoZWFkZXJzOiBbXSxcbiAgICAgIGJvZHk6IGZvcmdlLnV0aWwuZGVjb2RlNjQobWF0Y2hbM10pXG4gICAgfTtcbiAgICBydmFsLnB1c2gobXNnKTtcblxuICAgIC8vIG5vIGhlYWRlcnNcbiAgICBpZighbWF0Y2hbMl0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGhlYWRlcnNcbiAgICB2YXIgbGluZXMgPSBtYXRjaFsyXS5zcGxpdChyQ1JMRik7XG4gICAgdmFyIGxpID0gMDtcbiAgICB3aGlsZShtYXRjaCAmJiBsaSA8IGxpbmVzLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0IGxpbmUsIHRyaW0gYW55IHJocyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xpXS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcblxuICAgICAgLy8gUkZDMjgyMiB1bmZvbGQgYW55IGZvbGxvd2luZyBmb2xkZWQgbGluZXNcbiAgICAgIGZvcih2YXIgbmwgPSBsaSArIDE7IG5sIDwgbGluZXMubGVuZ3RoOyArK25sKSB7XG4gICAgICAgIHZhciBuZXh0ID0gbGluZXNbbmxdO1xuICAgICAgICBpZighL1xccy8udGVzdChuZXh0WzBdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gbmV4dDtcbiAgICAgICAgbGkgPSBubDtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgaGVhZGVyXG4gICAgICBtYXRjaCA9IGxpbmUubWF0Y2gockhlYWRlcik7XG4gICAgICBpZihtYXRjaCkge1xuICAgICAgICB2YXIgaGVhZGVyID0ge25hbWU6IG1hdGNoWzFdLCB2YWx1ZXM6IFtdfTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG1hdGNoWzJdLnNwbGl0KCcsJyk7XG4gICAgICAgIGZvcih2YXIgdmkgPSAwOyB2aSA8IHZhbHVlcy5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsdWVzLnB1c2gobHRyaW0odmFsdWVzW3ZpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvYy1UeXBlIG11c3QgYmUgdGhlIGZpcnN0IGhlYWRlclxuICAgICAgICBpZighbXNnLnByb2NUeXBlKSB7XG4gICAgICAgICAgaWYoaGVhZGVyLm5hbWUgIT09ICdQcm9jLVR5cGUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICdlbmNhcHN1bGF0ZWQgaGVhZGVyIG11c3QgYmUgXCJQcm9jLVR5cGVcIi4nKTtcbiAgICAgICAgICB9IGVsc2UgaWYoaGVhZGVyLnZhbHVlcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIlByb2MtVHlwZVwiICcgK1xuICAgICAgICAgICAgICAnaGVhZGVyIG11c3QgaGF2ZSB0d28gc3ViZmllbGRzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cucHJvY1R5cGUgPSB7dmVyc2lvbjogdmFsdWVzWzBdLCB0eXBlOiB2YWx1ZXNbMV19O1xuICAgICAgICB9IGVsc2UgaWYoIW1zZy5jb250ZW50RG9tYWluICYmIGhlYWRlci5uYW1lID09PSAnQ29udGVudC1Eb21haW4nKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbC1jYXNlIENvbnRlbnQtRG9tYWluXG4gICAgICAgICAgbXNnLmNvbnRlbnREb21haW4gPSB2YWx1ZXNbMF0gfHwgJyc7XG4gICAgICAgIH0gZWxzZSBpZighbXNnLmRla0luZm8gJiYgaGVhZGVyLm5hbWUgPT09ICdERUstSW5mbycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsLWNhc2UgREVLLUluZm9cbiAgICAgICAgICBpZihoZWFkZXIudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiREVLLUluZm9cIiAnICtcbiAgICAgICAgICAgICAgJ2hlYWRlciBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHN1YmZpZWxkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cuZGVrSW5mbyA9IHthbGdvcml0aG06IHZhbHVlc1swXSwgcGFyYW1ldGVyczogdmFsdWVzWzFdIHx8IG51bGx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zZy5oZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICArK2xpO1xuICAgIH1cblxuICAgIGlmKG1zZy5wcm9jVHlwZSA9PT0gJ0VOQ1JZUFRFRCcgJiYgIW1zZy5kZWtJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgXCJERUstSW5mb1wiICcgK1xuICAgICAgICAnaGVhZGVyIG11c3QgYmUgcHJlc2VudCBpZiBcIlByb2MtVHlwZVwiIGlzIFwiRU5DUllQVEVEXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYocnZhbC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLicpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG5mdW5jdGlvbiBmb2xkSGVhZGVyKGhlYWRlcikge1xuICB2YXIgcnZhbCA9IGhlYWRlci5uYW1lICsgJzogJztcblxuICAvLyBlbnN1cmUgdmFsdWVzIHdpdGggQ1JMRiBhcmUgZm9sZGVkXG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGluc2VydFNwYWNlID0gZnVuY3Rpb24obWF0Y2gsICQxKSB7XG4gICAgcmV0dXJuICcgJyArICQxO1xuICB9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaGVhZGVyLnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhbHVlcy5wdXNoKGhlYWRlci52YWx1ZXNbaV0ucmVwbGFjZSgvXihcXFMrXFxyXFxuKS8sIGluc2VydFNwYWNlKSk7XG4gIH1cbiAgcnZhbCArPSB2YWx1ZXMuam9pbignLCcpICsgJ1xcclxcbic7XG5cbiAgLy8gZG8gZm9sZGluZ1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIGNhbmRpZGF0ZSA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgcnZhbC5sZW5ndGg7ICsraSwgKytsZW5ndGgpIHtcbiAgICBpZihsZW5ndGggPiA2NSAmJiBjYW5kaWRhdGUgIT09IC0xKSB7XG4gICAgICB2YXIgaW5zZXJ0ID0gcnZhbFtjYW5kaWRhdGVdO1xuICAgICAgaWYoaW5zZXJ0ID09PSAnLCcpIHtcbiAgICAgICAgKytjYW5kaWRhdGU7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICsgJ1xcclxcbiAnICsgcnZhbC5zdWJzdHIoY2FuZGlkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICtcbiAgICAgICAgICAnXFxyXFxuJyArIGluc2VydCArIHJ2YWwuc3Vic3RyKGNhbmRpZGF0ZSArIDEpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gKGkgLSBjYW5kaWRhdGUgLSAxKTtcbiAgICAgIGNhbmRpZGF0ZSA9IC0xO1xuICAgICAgKytpO1xuICAgIH0gZWxzZSBpZihydmFsW2ldID09PSAnICcgfHwgcnZhbFtpXSA9PT0gJ1xcdCcgfHwgcnZhbFtpXSA9PT0gJywnKSB7XG4gICAgICBjYW5kaWRhdGUgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuXG5mdW5jdGlvbiBsdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBQYXNzd29yZC1iYXNlZCBlbmNyeXB0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICogQGF1dGhvciBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBBbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbzpcbiAqXG4gKiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBlbmNyeXB0aW9uQWxnb3JpdGhtICBFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGF0YSAgICAgICAgRW5jcnlwdGVkRGF0YSB9XG4gKlxuICogRW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBPQ1RFVCBTVFJJTkdcbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbl9fd2VicGFja19yZXF1aXJlX18oNSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbl9fd2VicGFja19yZXF1aXJlX18oNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5pZih0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG59XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLyogUGFzc3dvcmQtYmFzZWQgZW5jcnlwdGlvbiBpbXBsZW1lbnRhdGlvbi4gKi9cbnZhciBwa2kgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG5tb2R1bGUuZXhwb3J0cyA9IHBraS5wYmUgPSBmb3JnZS5wYmUgPSBmb3JnZS5wYmUgfHwge307XG52YXIgb2lkcyA9IHBraS5vaWRzO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgdy9hbGdvcml0aG0gcGFyYW1zXG52YXIgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uZW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2VuY3J5cHRpb25PaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIucGFyYW1ldGVycycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGlvblBhcmFtcydcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gZW5jcnlwdGVkRGF0YVxuICAgIG5hbWU6ICdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5lbmNyeXB0ZWREYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnZW5jcnlwdGVkRGF0YSdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBQQkVTMkFsZ29yaXRobXMgc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3L1BCS0RGMiArIEFFUyBlbmNyeXB0aW9uIHNjaGVtZXNcbnZhciBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMua2V5RGVyaXZhdGlvbkZ1bmMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jLm9pZCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2tkZk9pZCdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5zYWx0JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2tkZlNhbHQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLml0ZXJhdGlvbkNvdW50JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAna2RmSXRlcmF0aW9uQ291bnQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLmtleUxlbmd0aCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdrZXlMZW5ndGgnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHByZlxuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYuYWxnb3JpdGhtJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogJ3ByZk9pZCdcbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZS5vaWQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5lbmNyeXB0aW9uU2NoZW1lLml2JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNJdidcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zLnNhbHQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzYWx0J1xuICB9LCB7XG4gICAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMuaXRlcmF0aW9ucycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnaXRlcmF0aW9ucydcbiAgfV1cbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QsIHByb2R1Y2luZyBhbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqXG4gKiBQQkVTMkFsZ29yaXRobXMgQUxHT1JJVEhNLUlERU5USUZJRVIgOjo9XG4gKiAgIHsge1BCRVMyLXBhcmFtcyBJREVOVElGSUVEIEJZIGlkLVBCRVMyfSwgLi4ufVxuICpcbiAqIGlkLVBCRVMyIE9CSkVDVCBJREVOVElGSUVSIDo6PSB7cGtjcy01IDEzfVxuICpcbiAqIFBCRVMyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBrZXlEZXJpdmF0aW9uRnVuYyBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJFUzItS0RGc319LFxuICogICBlbmNyeXB0aW9uU2NoZW1lIEFsZ29yaXRobUlkZW50aWZpZXIge3tQQkVTMi1FbmNzfX1cbiAqIH1cbiAqXG4gKiBQQkVTMi1LREZzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PVxuICogICB7IHtQQktERjItcGFyYW1zIElERU5USUZJRUQgQlkgaWQtUEJLREYyfSwgLi4uIH1cbiAqXG4gKiBQQkVTMi1FbmNzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PSB7IC4uLiB9XG4gKlxuICogUEJLREYyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBzYWx0IENIT0lDRSB7XG4gKiAgICAgc3BlY2lmaWVkIE9DVEVUIFNUUklORyxcbiAqICAgICBvdGhlclNvdXJjZSBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVNhbHRTb3VyY2VzfX1cbiAqICAgfSxcbiAqICAgaXRlcmF0aW9uQ291bnQgSU5URUdFUiAoMS4uTUFYKSxcbiAqICAga2V5TGVuZ3RoIElOVEVHRVIgKDEuLk1BWCkgT1BUSU9OQUwsXG4gKiAgIHByZiBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVBSRnN9fSBERUZBVUxUIGFsZ2lkLWhtYWNXaXRoU0hBMVxuICogfVxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZW5jcnlwdCB3aXRoLlxuICogQHBhcmFtIG9wdGlvbnM6XG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ2FlczEyOCcsICdhZXMxOTInLCAnYWVzMjU2JywgJzNkZXMnKSwgZGVmYXVsdHMgdG8gJ2FlczEyOCcuXG4gKiAgICAgICAgICBjb3VudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplIHRoZSBzYWx0IHNpemUgdG8gdXNlLlxuICogICAgICAgICAgcHJmQWxnb3JpdGhtIHRoZSBQUkYgbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJylcbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyA9IGZ1bmN0aW9uKG9iaiwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5zYWx0U2l6ZSA9IG9wdGlvbnMuc2FsdFNpemUgfHwgODtcbiAgb3B0aW9ucy5jb3VudCA9IG9wdGlvbnMuY291bnQgfHwgMjA0ODtcbiAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCAnYWVzMTI4JztcbiAgb3B0aW9ucy5wcmZBbGdvcml0aG0gPSBvcHRpb25zLnByZkFsZ29yaXRobSB8fCAnc2hhMSc7XG5cbiAgLy8gZ2VuZXJhdGUgUEJFIHBhcmFtc1xuICB2YXIgc2FsdCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMob3B0aW9ucy5zYWx0U2l6ZSk7XG4gIHZhciBjb3VudCA9IG9wdGlvbnMuY291bnQ7XG4gIHZhciBjb3VudEJ5dGVzID0gYXNuMS5pbnRlZ2VyVG9EZXIoY291bnQpO1xuICB2YXIgZGtMZW47XG4gIHZhciBlbmNyeXB0aW9uQWxnb3JpdGhtO1xuICB2YXIgZW5jcnlwdGVkRGF0YTtcbiAgaWYob3B0aW9ucy5hbGdvcml0aG0uaW5kZXhPZignYWVzJykgPT09IDAgfHwgb3B0aW9ucy5hbGdvcml0aG0gPT09ICdkZXMnKSB7XG4gICAgLy8gZG8gUEJFUzJcbiAgICB2YXIgaXZMZW4sIGVuY09pZCwgY2lwaGVyRm47XG4gICAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnYWVzMTI4JzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBpdkxlbiA9IDE2O1xuICAgICAgZW5jT2lkID0gb2lkc1snYWVzMTI4LUNCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FlczE5Mic6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgaXZMZW4gPSAxNjtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2FlczE5Mi1DQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZXMyNTYnOlxuICAgICAgZGtMZW4gPSAzMjtcbiAgICAgIGl2TGVuID0gMTY7XG4gICAgICBlbmNPaWQgPSBvaWRzWydhZXMyNTYtQ0JDJ107XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVzJzpcbiAgICAgIGRrTGVuID0gODtcbiAgICAgIGl2TGVuID0gODtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2Rlc0NCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHByaXZhdGUga2V5LiBVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gICAgdmFyIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aCcgKyBvcHRpb25zLnByZkFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBtZCA9IHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xuXG4gICAgLy8gZW5jcnlwdCBwcml2YXRlIGtleSB1c2luZyBwYmUgU0hBLTEgYW5kIEFFUy9ERVNcbiAgICB2YXIgZGsgPSBmb3JnZS5wa2NzNS5wYmtkZjIocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgbWQpO1xuICAgIHZhciBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoaXZMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIob2JqKSk7XG4gICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgIGVuY3J5cHRlZERhdGEgPSBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKCk7XG5cbiAgICAvLyBnZXQgUEJLREYyLXBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBjcmVhdGVQYmtkZjJQYXJhbXMoc2FsdCwgY291bnRCeXRlcywgZGtMZW4sIHByZkFsZ29yaXRobSk7XG5cbiAgICBlbmNyeXB0aW9uQWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQkVTMiddKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8ga2V5RGVyaXZhdGlvbkZ1bmNcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQktERjInXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gUEJLREYyLXBhcmFtc1xuICAgICAgICAgIHBhcmFtc1xuICAgICAgICBdKSxcbiAgICAgICAgLy8gZW5jcnlwdGlvblNjaGVtZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihlbmNPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgIC8vIGl2XG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgaXYpXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2UgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICczZGVzJykge1xuICAgIC8vIERvIFBLQ1MxMiBQQkVcbiAgICBka0xlbiA9IDI0O1xuXG4gICAgdmFyIHNhbHRCeXRlcyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoc2FsdCk7XG4gICAgdmFyIGRrID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdEJ5dGVzLCAxLCBjb3VudCwgZGtMZW4pO1xuICAgIHZhciBpdiA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHRCeXRlcywgMiwgY291bnQsIGRrTGVuKTtcbiAgICB2YXIgY2lwaGVyID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIoZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShhc24xLnRvRGVyKG9iaikpO1xuICAgIGNpcGhlci5maW5pc2goKTtcbiAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwa2NzLTEyUGJlUGFyYW1zXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIHNhbHRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNhbHQpLFxuICAgICAgICAvLyBpdGVyYXRpb24gY291bnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKCkpXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgcHJpdmF0ZSBrZXkuIFVua25vd24gZW5jcnlwdGlvbiBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBlbmNyeXB0aW9uQWxnb3JpdGhtXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSxcbiAgICAvLyBlbmNyeXB0ZWREYXRhXG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgZW5jcnlwdGVkRGF0YSlcbiAgXSk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mbyBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8gPSBmdW5jdGlvbihvYmosIHBhc3N3b3JkKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBjaXBoZXJcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNyeXB0aW9uT2lkKTtcbiAgdmFyIGNpcGhlciA9IHBraS5wYmUuZ2V0Q2lwaGVyKG9pZCwgY2FwdHVyZS5lbmNyeXB0aW9uUGFyYW1zLCBwYXNzd29yZCk7XG5cbiAgLy8gZ2V0IGVuY3J5cHRlZCBkYXRhXG4gIHZhciBlbmNyeXB0ZWQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmVuY3J5cHRlZERhdGEpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgcnZhbCA9IGFzbjEuZnJvbURlcihjaXBoZXIub3V0cHV0KTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGVwa2kgdGhlIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0gPSBmdW5jdGlvbihlcGtpLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKGVwa2kpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBFTS1lbmNvZGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIEFTTi4xIGZvcm1hdC4gRGVjcnlwdGlvblxuICogaXMgbm90IHBlcmZvcm1lZC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBpbiBQRU0tZm9ybWF0LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kuZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICByZXR1cm4gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYW4gUlNBIHByaXZhdGUga2V5LiBCeSBkZWZhdWx0LCB0aGUga2V5IHdpbGwgYmUgd3JhcHBlZCBpblxuICogYSBQcml2YXRlS2V5SW5mbyBhbmQgZW5jcnlwdGVkIHRvIHByb2R1Y2UgYSBQS0NTIzggRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKiBUaGlzIGlzIHRoZSBzdGFuZGFyZCwgcHJlZmVycmVkIHdheSB0byBlbmNyeXB0IGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogVG8gcHJvZHVjZSBhIG5vbi1zdGFuZGFyZCBQRU0tZW5jcnlwdGVkIHByaXZhdGUga2V5IHRoYXQgdXNlcyBlbmNhcHN1bGF0ZWRcbiAqIGhlYWRlcnMgdG8gaW5kaWNhdGUgdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIChvbGQtc3R5bGUgbm9uLVBLQ1MjOCBPcGVuU1NMXG4gKiBwcml2YXRlIGtleSBlbmNyeXB0aW9uKSwgc2V0IHRoZSAnbGVnYWN5JyBvcHRpb24gdG8gdHJ1ZS4gTm90ZTogVXNpbmcgdGhpc1xuICogb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byBiZSBmb3JjZWQgdG8gMS5cbiAqXG4gKiBOb3RlOiBUaGUgJ2RlcycgYWxnb3JpdGhtIGlzIHN1cHBvcnRlZCwgYnV0IGl0IGlzIG5vdCBjb25zaWRlcmVkIHRvIGJlXG4gKiBzZWN1cmUgYmVjYXVzZSBpdCBvbmx5IHVzZXMgYSBzaW5nbGUgNTYtYml0IGtleS4gSWYgcG9zc2libGUsIGl0IGlzIGhpZ2hseVxuICogcmVjb21tZW5kZWQgdGhhdCBhIGRpZmZlcmVudCBhbGdvcml0aG0gYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBSU0Ega2V5IHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtOiB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gdG8gdXNlXG4gKiAgICAgICAgICAgICgnYWVzMTI4JywgJ2FlczE5MicsICdhZXMyNTYnLCAnM2RlcycsICdkZXMnKS5cbiAqICAgICAgICAgIGNvdW50OiB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplOiB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIGxlZ2FjeTogb3V0cHV0IGFuIG9sZCBub24tUEtDUyM4IFBFTS1lbmNyeXB0ZWQrZW5jYXBzdWxhdGVkXG4gKiAgICAgICAgICAgIGhlYWRlcnMgKERFSy1JbmZvKSBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZW5jb2RlZCBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAvLyBzdGFuZGFyZCBQS0NTIzhcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCFvcHRpb25zLmxlZ2FjeSkge1xuICAgIC8vIGVuY3J5cHQgUHJpdmF0ZUtleUluZm9cbiAgICB2YXIgcnZhbCA9IHBraS53cmFwUnNhUHJpdmF0ZUtleShwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKTtcbiAgICBydmFsID0gcGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhydmFsLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0ocnZhbCk7XG4gIH1cblxuICAvLyBsZWdhY3kgbm9uLVBLQ1MjOFxuICB2YXIgYWxnb3JpdGhtO1xuICB2YXIgaXY7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgY2FzZSAnYWVzMTI4JzpcbiAgICBhbGdvcml0aG0gPSAnQUVTLTEyOC1DQkMnO1xuICAgIGRrTGVuID0gMTY7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMxOTInOlxuICAgIGFsZ29yaXRobSA9ICdBRVMtMTkyLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczI1Nic6XG4gICAgYWxnb3JpdGhtID0gJ0FFUy0yNTYtQ0JDJztcbiAgICBka0xlbiA9IDMyO1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYygxNik7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnM2Rlcyc6XG4gICAgYWxnb3JpdGhtID0gJ0RFUy1FREUzLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCk7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzJzpcbiAgICBhbGdvcml0aG0gPSAnREVTLUNCQyc7XG4gICAgZGtMZW4gPSA4O1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYyg4KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGVuY3J5cHQgUlNBIHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCAnICtcbiAgICAgICdlbmNyeXB0aW9uIGFsZ29yaXRobSBcIicgKyBvcHRpb25zLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgT3BlblNTTCBsZWdhY3kga2V5IGRlcml2YXRpb25cbiAgdmFyIGRrID0gZm9yZ2UucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyhwYXNzd29yZCwgaXYuc3Vic3RyKDAsIDgpLCBka0xlbik7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIGNpcGhlci51cGRhdGUoYXNuMS50b0Rlcihwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKSk7XG4gIGNpcGhlci5maW5pc2goKTtcblxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFJJVkFURSBLRVknLFxuICAgIHByb2NUeXBlOiB7XG4gICAgICB2ZXJzaW9uOiAnNCcsXG4gICAgICB0eXBlOiAnRU5DUllQVEVEJ1xuICAgIH0sXG4gICAgZGVrSW5mbzoge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBwYXJhbWV0ZXJzOiBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoaXYpLnRvVXBwZXJDYXNlKClcbiAgICB9LFxuICAgIGJvZHk6IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2cpO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhbiBSU0EgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBkZWNyeXB0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgUlNBIGtleSBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHBlbSwgcGFzc3dvcmQpIHtcbiAgdmFyIHJ2YWwgPSBudWxsO1xuXG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknICYmXG4gICAgbXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1JTQSBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgJyArXG4gICAgICAnaXMgbm90IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIsIFwiUFJJVkFURSBLRVlcIiwgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gZXJyb3I7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdmFyIGRrTGVuO1xuICAgIHZhciBjaXBoZXJGbjtcbiAgICBzd2l0Y2gobXNnLmRla0luZm8uYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnREVTLUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnREVTLUVERTMtQ0JDJzpcbiAgICAgIGRrTGVuID0gMjQ7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQUVTLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBRVMtMTkyLUNCQyc6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FFUy0yNTYtQ0JDJzpcbiAgICAgIGRrTGVuID0gMzI7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTQwLUNCQyc6XG4gICAgICBka0xlbiA9IDU7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTY0LUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA2NCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBmb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGRlY3J5cHQgcHJpdmF0ZSBrZXk7IHVuc3VwcG9ydGVkICcgK1xuICAgICAgICAnZW5jcnlwdGlvbiBhbGdvcml0aG0gXCInICsgbXNnLmRla0luZm8uYWxnb3JpdGhtICsgJ1wiLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gbXNnLmRla0luZm8uYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gdXNlIE9wZW5TU0wgbGVnYWN5IGtleSBkZXJpdmF0aW9uXG4gICAgdmFyIGl2ID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpO1xuICAgIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG1zZy5ib2R5KSk7XG4gICAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICBydmFsID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCA9IG1zZy5ib2R5O1xuICB9XG5cbiAgaWYobXNnLnR5cGUgPT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknKSB7XG4gICAgcnZhbCA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYXNuMS5mcm9tRGVyKHJ2YWwpLCBwYXNzd29yZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVjcnlwdGlvbiBhbHJlYWR5IHBlcmZvcm1lZCBhYm92ZVxuICAgIHJ2YWwgPSBhc24xLmZyb21EZXIocnZhbCk7XG4gIH1cblxuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgcnZhbCA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEocnZhbCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleSA9IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBpZCwgaXRlciwgbiwgbWQpIHtcbiAgdmFyIGosIGw7XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIGlmKCEoJ3NoYTEnIGluIGZvcmdlLm1kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNoYTFcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9XG5cbiAgdmFyIHUgPSBtZC5kaWdlc3RMZW5ndGg7XG4gIHZhciB2ID0gbWQuYmxvY2tMZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgLyogQ29udmVydCBwYXNzd29yZCB0byBVbmljb2RlIGJ5dGUgYnVmZmVyICsgdHJhaWxpbmcgMC1ieXRlLiAqL1xuICB2YXIgcGFzc0J1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgaWYocGFzc3dvcmQgIT09IG51bGwgJiYgcGFzc3dvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvcihsID0gMDsgbCA8IHBhc3N3b3JkLmxlbmd0aDsgbCsrKSB7XG4gICAgICBwYXNzQnVmLnB1dEludDE2KHBhc3N3b3JkLmNoYXJDb2RlQXQobCkpO1xuICAgIH1cbiAgICBwYXNzQnVmLnB1dEludDE2KDApO1xuICB9XG5cbiAgLyogTGVuZ3RoIG9mIHNhbHQgYW5kIHBhc3N3b3JkIGluIEJZVEVTLiAqL1xuICB2YXIgcCA9IHBhc3NCdWYubGVuZ3RoKCk7XG4gIHZhciBzID0gc2FsdC5sZW5ndGgoKTtcblxuICAvKiAxLiBDb25zdHJ1Y3QgYSBzdHJpbmcsIEQgKHRoZSBcImRpdmVyc2lmaWVyXCIpLCBieSBjb25jYXRlbmF0aW5nXG4gICAgICAgIHYgY29waWVzIG9mIElELiAqL1xuICB2YXIgRCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgRC5maWxsV2l0aEJ5dGUoaWQsIHYpO1xuXG4gIC8qIDIuIENvbmNhdGVuYXRlIGNvcGllcyBvZiB0aGUgc2FsdCB0b2dldGhlciB0byBjcmVhdGUgYSBzdHJpbmcgUyBvZiBsZW5ndGhcbiAgICAgICAgdiAqIGNlaWwocyAvIHYpIGJ5dGVzICh0aGUgZmluYWwgY29weSBvZiB0aGUgc2FsdCBtYXkgYmUgdHJ1bmFjdGVkXG4gICAgICAgIHRvIGNyZWF0ZSBTKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBzYWx0IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc28gaXMgUy4gKi9cbiAgdmFyIFNsZW4gPSB2ICogTWF0aC5jZWlsKHMgLyB2KTtcbiAgdmFyIFMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIGZvcihsID0gMDsgbCA8IFNsZW47IGwrKykge1xuICAgIFMucHV0Qnl0ZShzYWx0LmF0KGwgJSBzKSk7XG4gIH1cblxuICAvKiAzLiBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgdGhlIHBhc3N3b3JkIHRvZ2V0aGVyIHRvIGNyZWF0ZSBhIHN0cmluZyBQIG9mXG4gICAgICAgIGxlbmd0aCB2ICogY2VpbChwIC8gdikgYnl0ZXMgKHRoZSBmaW5hbCBjb3B5IG9mIHRoZSBwYXNzd29yZCBtYXkgYmVcbiAgICAgICAgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBQKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBwYXNzd29yZCBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNvIGlzIFAuICovXG4gIHZhciBQbGVuID0gdiAqIE1hdGguY2VpbChwIC8gdik7XG4gIHZhciBQID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICBmb3IobCA9IDA7IGwgPCBQbGVuOyBsKyspIHtcbiAgICBQLnB1dEJ5dGUocGFzc0J1Zi5hdChsICUgcCkpO1xuICB9XG5cbiAgLyogNC4gU2V0IEk9U3x8UCB0byBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBTIGFuZCBQLiAqL1xuICB2YXIgSSA9IFM7XG4gIEkucHV0QnVmZmVyKFApO1xuXG4gIC8qIDUuIFNldCBjPWNlaWwobiAvIHUpLiAqL1xuICB2YXIgYyA9IE1hdGguY2VpbChuIC8gdSk7XG5cbiAgLyogNi4gRm9yIGk9MSwgMiwgLi4uLCBjLCBkbyB0aGUgZm9sbG93aW5nOiAqL1xuICBmb3IodmFyIGkgPSAxOyBpIDw9IGM7IGkrKykge1xuICAgIC8qIGEpIFNldCBBaT1IXnIoRHx8SSkuIChsLmUuIHRoZSBydGggaGFzaCBvZiBEfHxJLCBIKEgoSCguLi5IKER8fEkpKSkpICovXG4gICAgdmFyIGJ1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBidWYucHV0Qnl0ZXMoRC5ieXRlcygpKTtcbiAgICBidWYucHV0Qnl0ZXMoSS5ieXRlcygpKTtcbiAgICBmb3IodmFyIHJvdW5kID0gMDsgcm91bmQgPCBpdGVyOyByb3VuZCsrKSB7XG4gICAgICBtZC5zdGFydCgpO1xuICAgICAgbWQudXBkYXRlKGJ1Zi5nZXRCeXRlcygpKTtcbiAgICAgIGJ1ZiA9IG1kLmRpZ2VzdCgpO1xuICAgIH1cblxuICAgIC8qIGIpIENvbmNhdGVuYXRlIGNvcGllcyBvZiBBaSB0byBjcmVhdGUgYSBzdHJpbmcgQiBvZiBsZW5ndGggdiBieXRlcyAodGhlXG4gICAgICAgICAgZmluYWwgY29weSBvZiBBaSBtYXkgYmUgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBCKS4gKi9cbiAgICB2YXIgQiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBmb3IobCA9IDA7IGwgPCB2OyBsKyspIHtcbiAgICAgIEIucHV0Qnl0ZShidWYuYXQobCAlIHUpKTtcbiAgICB9XG5cbiAgICAvKiBjKSBUcmVhdGluZyBJIGFzIGEgY29uY2F0ZW5hdGlvbiBJMCwgSTEsIC4uLiwgSWstMSBvZiB2LWJ5dGUgYmxvY2tzLFxuICAgICAgICAgIHdoZXJlIGs9Y2VpbChzIC8gdikgKyBjZWlsKHAgLyB2KSwgbW9kaWZ5IEkgYnkgc2V0dGluZ1xuICAgICAgICAgIElqPShJaitCKzEpIG1vZCAydiBmb3IgZWFjaCBqLiAgKi9cbiAgICB2YXIgayA9IE1hdGguY2VpbChzIC8gdikgKyBNYXRoLmNlaWwocCAvIHYpO1xuICAgIHZhciBJbmV3ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIGZvcihqID0gMDsgaiA8IGs7IGorKykge1xuICAgICAgdmFyIGNodW5rID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihJLmdldEJ5dGVzKHYpKTtcbiAgICAgIHZhciB4ID0gMHgxZmY7XG4gICAgICBmb3IobCA9IEIubGVuZ3RoKCkgLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICB4ID0geCA+PiA4O1xuICAgICAgICB4ICs9IEIuYXQobCkgKyBjaHVuay5hdChsKTtcbiAgICAgICAgY2h1bmsuc2V0QXQobCwgeCAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgSW5ldy5wdXRCdWZmZXIoY2h1bmspO1xuICAgIH1cbiAgICBJID0gSW5ldztcblxuICAgIC8qIEFkZCBBaSB0byBBLiAqL1xuICAgIHJlc3VsdC5wdXRCdWZmZXIoYnVmKTtcbiAgfVxuXG4gIHJlc3VsdC50cnVuY2F0ZShyZXN1bHQubGVuZ3RoKCkgLSBuKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvaWQgdGhlIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIHBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlciA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICBzd2l0Y2gob2lkKSB7XG4gIGNhc2UgcGtpLm9pZHNbJ3BrY3M1UEJFUzInXTpcbiAgICByZXR1cm4gcGtpLnBiZS5nZXRDaXBoZXJGb3JQQkVTMihvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGNhc2UgcGtpLm9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXTpcbiAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgIHJldHVybiBwa2kucGJlLmdldENpcGhlckZvclBLQ1MxMlBCRShvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGRlZmF1bHQ6XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgUEJFIGRhdGEgYmxvY2suIFVuc3VwcG9ydGVkIE9JRC4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcbiAgICAgICdwa2NzNVBCRVMyJyxcbiAgICAgICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyxcbiAgICAgICdwYmV3aXRoU0hBQW5kNDBCaXRSQzItQ0JDJ1xuICAgIF07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlIGFjY29yZGluZyB0byBQQkVTMiBwYXJhbXMgYmxvY2suXG4gKlxuICogVGhlIHJldHVybmVkIGNpcGhlciBpbnN0YW5jZSBpcyBhbHJlYWR5IHN0YXJ0ZWQgdXNpbmcgdGhlIElWXG4gKiBmcm9tIFBCRVMyIHBhcmFtZXRlciBibG9jay5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBQS0NTIzUgUEJLREYyIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIFBCRVMyLXBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlckZvclBCRVMyID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY2hlY2sgb2lkc1xuICBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUua2RmT2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkc1sncGtjczVQQktERjInXSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBPSUQuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIGVycm9yLnN1cHBvcnRlZE9pZHMgPSBbJ3BrY3M1UEJLREYyJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmVuY09pZCk7XG4gIGlmKG9pZCAhPT0gcGtpLm9pZHNbJ2FlczEyOC1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczE5Mi1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczI1Ni1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2Rlcy1FREUzLUNCQyddICYmXG4gICAgb2lkICE9PSBwa2kub2lkc1snZGVzQ0JDJ10pIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBzY2hlbWUgT0lELicpO1xuICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gW1xuICAgICAgJ2FlczEyOC1DQkMnLCAnYWVzMTkyLUNCQycsICdhZXMyNTYtQ0JDJywgJ2Rlcy1FREUzLUNCQycsICdkZXNDQkMnXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIHNldCBQQkUgcGFyYW1zXG4gIHZhciBzYWx0ID0gY2FwdHVyZS5rZGZTYWx0O1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmtkZkl0ZXJhdGlvbkNvdW50KTtcbiAgY291bnQgPSBjb3VudC5nZXRJbnQoY291bnQubGVuZ3RoKCkgPDwgMyk7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gocGtpLm9pZHNbb2lkXSkge1xuICBjYXNlICdhZXMxMjgtQ0JDJzpcbiAgICBka0xlbiA9IDE2O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczE5Mi1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnYWVzMjU2LUNCQyc6XG4gICAgZGtMZW4gPSAzMjtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdkZXMtRURFMy1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzQ0JDJzpcbiAgICBka0xlbiA9IDg7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGdldCBQUkYgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIG1kID0gcHJmT2lkVG9NZXNzYWdlRGlnZXN0KGNhcHR1cmUucHJmT2lkKTtcblxuICAvLyBkZWNyeXB0IHByaXZhdGUga2V5IHVzaW5nIHBiZSB3aXRoIGNob3NlbiBQUkYgYW5kIEFFUy9ERVNcbiAgdmFyIGRrID0gZm9yZ2UucGtjczUucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgdmFyIGl2ID0gY2FwdHVyZS5lbmNJdjtcbiAgdmFyIGNpcGhlciA9IGNpcGhlckZuKGRrKTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBHZXQgbmV3IEZvcmdlIGNpcGhlciBvYmplY3QgaW5zdGFuY2UgZm9yIFBLQ1MjMTIgUEJFLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjaXBoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBzdGFydGVkIHVzaW5nIHRoZSBrZXkgJiBJVlxuICogZGVyaXZlZCBmcm9tIHRoZSBwcm92aWRlZCBwYXNzd29yZCBhbmQgUEtDUyMxMiBQQkUgc2FsdC5cbiAqXG4gKiBAcGFyYW0gb2lkIFRoZSBQS0NTIzEyIFBCRSBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBBU04uMSBQS0NTIzEyIFBCRS1wYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgbmV3IGNpcGhlciBvYmplY3QgaW5zdGFuY2UuXG4gKi9cbnBraS5wYmUuZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHNhbHQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnNhbHQpO1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLml0ZXJhdGlvbnMpO1xuICBjb3VudCA9IGNvdW50LmdldEludChjb3VudC5sZW5ndGgoKSA8PCAzKTtcblxuICB2YXIgZGtMZW4sIGRJdkxlbiwgY2lwaGVyRm47XG4gIHN3aXRjaChvaWQpIHtcbiAgICBjYXNlIHBraS5vaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ106XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLnN0YXJ0RGVjcnlwdGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgICAgZGtMZW4gPSA1O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5LCBpdikge1xuICAgICAgICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICAgIGNpcGhlci5zdGFydChpdiwgbnVsbCk7XG4gICAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTICMxMiBQQkUgZGF0YSBibG9jay4gVW5zdXBwb3J0ZWQgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG4gIHZhciBrZXkgPSBwa2kucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0LCAxLCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgbWQuc3RhcnQoKTtcbiAgdmFyIGl2ID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdCwgMiwgY291bnQsIGRJdkxlbiwgbWQpO1xuXG4gIHJldHVybiBjaXBoZXJGbihrZXksIGl2KTtcbn07XG5cbi8qKlxuICogT3BlblNTTCdzIGxlZ2FjeSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBTZWU6IGh0dHA6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgZnJvbS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0IHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBka0xlbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGRlcml2ZWQga2V5LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbbWRdIGFuIG9wdGlvbmFsIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UuXG4gKi9cbnBraS5wYmUub3BlbnNzbERlcml2ZUJ5dGVzID0gZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIGRrTGVuLCBtZCkge1xuICBpZih0eXBlb2YgbWQgPT09ICd1bmRlZmluZWQnIHx8IG1kID09PSBudWxsKSB7XG4gICAgaWYoISgnbWQ1JyBpbiBmb3JnZS5tZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZDVcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gIH1cbiAgaWYoc2FsdCA9PT0gbnVsbCkge1xuICAgIHNhbHQgPSAnJztcbiAgfVxuICB2YXIgZGlnZXN0cyA9IFtoYXNoKG1kLCBwYXNzd29yZCArIHNhbHQpXTtcbiAgZm9yKHZhciBsZW5ndGggPSAxNiwgaSA9IDE7IGxlbmd0aCA8IGRrTGVuOyArK2ksIGxlbmd0aCArPSAxNikge1xuICAgIGRpZ2VzdHMucHVzaChoYXNoKG1kLCBkaWdlc3RzW2kgLSAxXSArIHBhc3N3b3JkICsgc2FsdCkpO1xuICB9XG4gIHJldHVybiBkaWdlc3RzLmpvaW4oJycpLnN1YnN0cigwLCBka0xlbik7XG59O1xuXG5mdW5jdGlvbiBoYXNoKG1kLCBieXRlcykge1xuICByZXR1cm4gbWQuc3RhcnQoKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG59XG5cbmZ1bmN0aW9uIHByZk9pZFRvTWVzc2FnZURpZ2VzdChwcmZPaWQpIHtcbiAgLy8gZ2V0IFBSRiBhbGdvcml0aG0sIGRlZmF1bHQgdG8gU0hBLTFcbiAgdmFyIHByZkFsZ29yaXRobTtcbiAgaWYoIXByZk9pZCkge1xuICAgIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aFNIQTEnO1xuICB9IGVsc2Uge1xuICAgIHByZkFsZ29yaXRobSA9IHBraS5vaWRzW2FzbjEuZGVyVG9PaWQocHJmT2lkKV07XG4gICAgaWYoIXByZkFsZ29yaXRobSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQUkYgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gcHJmT2lkO1xuICAgICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgICAnaG1hY1dpdGhTSEExJywgJ2htYWNXaXRoU0hBMjI0JywgJ2htYWNXaXRoU0hBMjU2JywgJ2htYWNXaXRoU0hBMzg0JyxcbiAgICAgICAgJ2htYWNXaXRoU0hBNTEyJ107XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xufVxuXG5mdW5jdGlvbiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKSB7XG4gIHZhciBmYWN0b3J5ID0gZm9yZ2UubWQ7XG4gIHN3aXRjaChwcmZBbGdvcml0aG0pIHtcbiAgY2FzZSAnaG1hY1dpdGhTSEEyMjQnOlxuICAgIGZhY3RvcnkgPSBmb3JnZS5tZC5zaGE1MTI7XG4gIGNhc2UgJ2htYWNXaXRoU0hBMSc6XG4gIGNhc2UgJ2htYWNXaXRoU0hBMjU2JzpcbiAgY2FzZSAnaG1hY1dpdGhTSEEzODQnOlxuICBjYXNlICdobWFjV2l0aFNIQTUxMic6XG4gICAgcHJmQWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFJGIGFsZ29yaXRobS4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBwcmZBbGdvcml0aG07XG4gICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgJ2htYWNXaXRoU0hBMScsICdobWFjV2l0aFNIQTIyNCcsICdobWFjV2l0aFNIQTI1NicsICdobWFjV2l0aFNIQTM4NCcsXG4gICAgICAnaG1hY1dpdGhTSEE1MTInXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZighZmFjdG9yeSB8fCAhKHByZkFsZ29yaXRobSBpbiBmYWN0b3J5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIHByZkFsZ29yaXRobSk7XG4gIH1cbiAgcmV0dXJuIGZhY3RvcnlbcHJmQWxnb3JpdGhtXS5jcmVhdGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGJrZGYyUGFyYW1zKHNhbHQsIGNvdW50Qnl0ZXMsIGRrTGVuLCBwcmZBbGdvcml0aG0pIHtcbiAgdmFyIHBhcmFtcyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBzYWx0XG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2FsdCksXG4gICAgLy8gaXRlcmF0aW9uIGNvdW50XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGNvdW50Qnl0ZXMuZ2V0Qnl0ZXMoKSlcbiAgXSk7XG4gIC8vIHdoZW4gUFJGIGFsZ29yaXRobSBpcyBub3QgU0hBLTEgZGVmYXVsdCwgYWRkIGtleSBsZW5ndGggYW5kIFBSRiBhbGdvcml0aG1cbiAgaWYocHJmQWxnb3JpdGhtICE9PSAnaG1hY1dpdGhTSEExJykge1xuICAgIHBhcmFtcy52YWx1ZS5wdXNoKFxuICAgICAgLy8ga2V5IGxlbmd0aFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGRrTGVuLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllclxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHNbcHJmQWxnb3JpdGhtXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgXSkpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENpcGhlciBiYXNlIEFQSS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlciA9IGZvcmdlLmNpcGhlciB8fCB7fTtcblxuLy8gcmVnaXN0ZXJlZCBhbGdvcml0aG1zXG5mb3JnZS5jaXBoZXIuYWxnb3JpdGhtcyA9IGZvcmdlLmNpcGhlci5hbGdvcml0aG1zIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjaXBoZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlblxuICogYWxnb3JpdGhtIGFuZCBrZXkuIFRoZSBhbGdvcml0aG0gbWF5IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHZhbHVlIGZvciBhXG4gKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWxnb3JpdGhtIG9yIGl0IG1heSBiZSBnaXZlbiBhcyBhIGNpcGhlciBhbGdvcml0aG1cbiAqIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSwgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFsZ29yaXRobSBBUElcbiAqICAgICAgICAgIG9iamVjdC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGFcbiAqICAgICAgICAgIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiBmYWxzZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlY2lwaGVyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW5cbiAqIGFsZ29yaXRobSBhbmQga2V5LiBUaGUgYWxnb3JpdGhtIG1heSBiZSBwcm92aWRlZCBhcyBhIHN0cmluZyB2YWx1ZSBmb3IgYVxuICogcHJldmlvdXNseSByZWdpc3RlcmVkIGFsZ29yaXRobSBvciBpdCBtYXkgYmUgZ2l2ZW4gYXMgYSBjaXBoZXIgYWxnb3JpdGhtXG4gKiBBUEkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UsIGVpdGhlciBhIHN0cmluZyBvciBhbiBhbGdvcml0aG0gQVBJXG4gKiAgICAgICAgICBvYmplY3QuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlLCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvciBhXG4gKiAgICAgICAgICBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gYWxnb3JpdGhtIGJ5IG5hbWUuIElmIHRoZSBuYW1lIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIHRoZVxuICogYWxnb3JpdGhtIEFQSSBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIEFQSSBvYmplY3QuXG4gKi9cbmZvcmdlLmNpcGhlci5yZWdpc3RlckFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIGFsZ29yaXRobSkge1xuICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXSA9IGFsZ29yaXRobTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHJlZ2lzdGVyZWQgYWxnb3JpdGhtIGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhbGdvcml0aG0sIGlmIGZvdW5kLCBudWxsIGlmIG5vdC5cbiAqL1xuZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgaWYobmFtZSBpbiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtcykge1xuICAgIHJldHVybiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBCbG9ja0NpcGhlciA9IGZvcmdlLmNpcGhlci5CbG9ja0NpcGhlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgdGhpcy5tb2RlID0gdGhpcy5hbGdvcml0aG0ubW9kZTtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLm1vZGUuYmxvY2tTaXplO1xuICB0aGlzLl9maW5pc2ggPSBmYWxzZTtcbiAgdGhpcy5faW5wdXQgPSBudWxsO1xuICB0aGlzLm91dHB1dCA9IG51bGw7XG4gIHRoaXMuX29wID0gb3B0aW9ucy5kZWNyeXB0ID8gdGhpcy5tb2RlLmRlY3J5cHQgOiB0aGlzLm1vZGUuZW5jcnlwdDtcbiAgdGhpcy5fZGVjcnlwdCA9IG9wdGlvbnMuZGVjcnlwdDtcbiAgdGhpcy5hbGdvcml0aG0uaW5pdGlhbGl6ZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIG9yIHJlc3RhcnRzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcywgd2hpY2hldmVyXG4gKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICpcbiAqIEZvciBub24tR0NNIG1vZGUsIHRoZSBJViBtYXkgYmUgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5XG4gKiBvZiBieXRlcywgYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzLiBJZiB0aGUgSVYgaXMgaW5cbiAqIGJ5dGVzLCB0aGVuIGl0IG11c3QgYmUgTmIgKDE2KSBieXRlcyBpbiBsZW5ndGguIElmIHRoZSBJViBpcyBnaXZlbiBpbiBhc1xuICogMzItYml0IGludGVnZXJzLCB0aGVuIGl0IG11c3QgYmUgNCBpbnRlZ2VycyBsb25nLlxuICpcbiAqIE5vdGU6IGFuIElWIGlzIG5vdCByZXF1aXJlZCBvciB1c2VkIGluIEVDQiBtb2RlLlxuICpcbiAqIEZvciBHQ00tbW9kZSwgdGhlIElWIG11c3QgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3JcbiAqIGEgYnl0ZSBidWZmZXIuIFRoZSBudW1iZXIgb2YgYnl0ZXMgc2hvdWxkIGJlIDEyICg5NiBiaXRzKSBhcyByZWNvbW1lbmRlZFxuICogYnkgTklTVCBTUC04MDAtMzhEIGJ1dCBhbm90aGVyIGxlbmd0aCBtYXkgYmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2ZcbiAqICAgICAgICAgICAgYnl0ZXMsIG51bGwgdG8gcmV1c2UgdGhlIGxhc3QgY2lwaGVyZWQgYmxvY2sgZnJvbSBhIHByZXZpb3VzXG4gKiAgICAgICAgICAgIHVwZGF0ZSgpICh0aGlzIFwicmVzaWR1ZVwiIG1ldGhvZCBpcyBmb3IgbGVnYWN5IHN1cHBvcnQgb25seSkuXG4gKiAgICAgICAgICBhZGRpdGlvbmFsRGF0YSBhZGRpdGlvbmFsIGF1dGhlbnRpY2F0aW9uIGRhdGEgYXMgYSBiaW5hcnktZW5jb2RlZFxuICogICAgICAgICAgICBzdHJpbmcgb2YgYnl0ZXMsIGZvciAnR0NNJyBtb2RlLCAoZGVmYXVsdDogbm9uZSkuXG4gKiAgICAgICAgICB0YWdMZW5ndGggZGVzaXJlZCBsZW5ndGggb2YgYXV0aGVudGljYXRpb24gdGFnLCBpbiBiaXRzLCBmb3JcbiAqICAgICAgICAgICAgJ0dDTScgbW9kZSAoMC0xMjgsIGRlZmF1bHQ6IDEyOCkuXG4gKiAgICAgICAgICB0YWcgdGhlIGF1dGhlbnRpY2F0aW9uIHRhZyB0byBjaGVjayBpZiBkZWNyeXB0aW5nLCBhcyBhXG4gKiAgICAgICAgICAgICBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiAgICAgICAgICBvdXRwdXQgdGhlIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBvcHRzID0ge307XG4gIGZvcih2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICBvcHRzW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgb3B0cy5kZWNyeXB0ID0gdGhpcy5fZGVjcnlwdDtcbiAgdGhpcy5fZmluaXNoID0gZmFsc2U7XG4gIHRoaXMuX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5vdXRwdXQgPSBvcHRpb25zLm91dHB1dCB8fCBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLm1vZGUuc3RhcnQob3B0cyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBjaXBoZXIgbW9kZS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZihpbnB1dCkge1xuICAgIC8vIGlucHV0IGdpdmVuLCBzbyBlbXB0eSBpdCBpbnRvIHRoZSBpbnB1dCBidWZmZXJcbiAgICB0aGlzLl9pbnB1dC5wdXRCdWZmZXIoaW5wdXQpO1xuICB9XG5cbiAgLy8gZG8gY2lwaGVyIG9wZXJhdGlvbiB1bnRpbCBpdCBuZWVkcyBtb3JlIGlucHV0IGFuZCBub3QgZmluaXNoZWRcbiAgd2hpbGUoIXRoaXMuX29wLmNhbGwodGhpcy5tb2RlLCB0aGlzLl9pbnB1dCwgdGhpcy5vdXRwdXQsIHRoaXMuX2ZpbmlzaCkgJiZcbiAgICAhdGhpcy5fZmluaXNoKSB7fVxuXG4gIC8vIGZyZWUgY29uc3VtZWQgbWVtb3J5IGZyb20gaW5wdXQgYnVmZmVyXG4gIHRoaXMuX2lucHV0LmNvbXBhY3QoKTtcbn07XG5cbi8qKlxuICogRmluaXNoZXMgZW5jcnlwdGluZyBvciBkZWNyeXB0aW5nLlxuICpcbiAqIEBwYXJhbSBwYWQgYSBwYWRkaW5nIGZ1bmN0aW9uIHRvIHVzZSBpbiBDQkMgbW9kZSwgbnVsbCBmb3IgZGVmYXVsdCxcbiAqICAgICAgICAgIHNpZ25hdHVyZShibG9ja1NpemUsIGJ1ZmZlciwgZGVjcnlwdCkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICovXG5CbG9ja0NpcGhlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24ocGFkKSB7XG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHcvZGVwcmVjYXRlZCBwYWRkaW5nIEFQSVxuICAvLyBOb3RlOiB3aWxsIG92ZXJ3cml0ZSBwYWRkaW5nIGZ1bmN0aW9ucyBldmVuIGFmdGVyIGFub3RoZXIgc3RhcnQoKSBjYWxsXG4gIGlmKHBhZCAmJiAodGhpcy5tb2RlLm5hbWUgPT09ICdFQ0InIHx8IHRoaXMubW9kZS5uYW1lID09PSAnQ0JDJykpIHtcbiAgICB0aGlzLm1vZGUucGFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIGlucHV0LCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLm1vZGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIG91dHB1dCwgdHJ1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGJ1aWxkIG9wdGlvbnMgZm9yIHBhZGRpbmcgYW5kIGFmdGVyRmluaXNoIGZ1bmN0aW9uc1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICBvcHRpb25zLmRlY3J5cHQgPSB0aGlzLl9kZWNyeXB0O1xuXG4gIC8vIGdldCAjIG9mIGJ5dGVzIHRoYXQgd29uJ3QgZmlsbCBhIGJsb2NrXG4gIG9wdGlvbnMub3ZlcmZsb3cgPSB0aGlzLl9pbnB1dC5sZW5ndGgoKSAlIHRoaXMuYmxvY2tTaXplO1xuXG4gIGlmKCF0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS5wYWQpIHtcbiAgICBpZighdGhpcy5tb2RlLnBhZCh0aGlzLl9pbnB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBkbyBmaW5hbCB1cGRhdGVcbiAgdGhpcy5fZmluaXNoID0gdHJ1ZTtcbiAgdGhpcy51cGRhdGUoKTtcblxuICBpZih0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS51bnBhZCkge1xuICAgIGlmKCF0aGlzLm1vZGUudW5wYWQodGhpcy5vdXRwdXQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYodGhpcy5tb2RlLmFmdGVyRmluaXNoKSB7XG4gICAgaWYoIXRoaXMubW9kZS5hZnRlckZpbmlzaCh0aGlzLm91dHB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIFN1cHBvcnRlZCBjaXBoZXIgbW9kZXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyBzdXBwb3J0ZWQgY2lwaGVyIG1vZGVzXG52YXIgbW9kZXMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlci5tb2RlcyA9IGZvcmdlLmNpcGhlci5tb2RlcyB8fCB7fTtcblxuLyoqIEVsZWN0cm9uaWMgY29kZWJvb2sgKEVDQikgKERvbid0IHVzZSB0aGlzOyBpdCdzIG5vdCBzZWN1cmUpICoqL1xuXG5tb2Rlcy5lY2IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnRUNCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge307XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGRlY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gIHZhciBwYWRkaW5nID0gKGlucHV0Lmxlbmd0aCgpID09PSB0aGlzLmJsb2NrU2l6ZSA/XG4gICAgdGhpcy5ibG9ja1NpemUgOiAodGhpcy5ibG9ja1NpemUgLSBpbnB1dC5sZW5ndGgoKSkpO1xuICBpbnB1dC5maWxsV2l0aEJ5dGUocGFkZGluZywgcGFkZGluZyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCwgb3B0aW9ucykge1xuICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2tTaXplXG4gIGlmKG9wdGlvbnMub3ZlcmZsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZW5zdXJlIHBhZGRpbmcgYnl0ZSBjb3VudCBpcyB2YWxpZFxuICB2YXIgbGVuID0gb3V0cHV0Lmxlbmd0aCgpO1xuICB2YXIgY291bnQgPSBvdXRwdXQuYXQobGVuIC0gMSk7XG4gIGlmKGNvdW50ID4gKHRoaXMuYmxvY2tTaXplIDw8IDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICBvdXRwdXQudHJ1bmNhdGUoY291bnQpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKiBDaXBoZXItYmxvY2sgQ2hhaW5pbmcgKENCQykgKiovXG5cbm1vZGVzLmNiYyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDQkMnO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIE5vdGU6IGxlZ2FjeSBzdXBwb3J0IGZvciB1c2luZyBJViByZXNpZHVlIChoYXMgc2VjdXJpdHkgZmxhd3MpXG4gIC8vIGlmIElWIGlzIG51bGwsIHJldXNlIGJsb2NrIGZyb20gcHJldmlvdXMgcHJvY2Vzc2luZ1xuICBpZihvcHRpb25zLml2ID09PSBudWxsKSB7XG4gICAgLy8gbXVzdCBoYXZlIGEgcHJldmlvdXMgYmxvY2tcbiAgICBpZighdGhpcy5fcHJldikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5faXYgPSB0aGlzLl9wcmV2LnNsaWNlKDApO1xuICB9IGVsc2UgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzYXZlIElWIGFzIFwicHJldmlvdXNcIiBibG9ja1xuICAgIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdik7XG4gICAgdGhpcy5fcHJldiA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB9XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgLy8gQ0JDIFhPUidzIElWIChvciBwcmV2aW91cyBibG9jaykgd2l0aCBwbGFpbnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wcmV2W2ldIF4gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0LCBzYXZlIHByZXZpb3VzIGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9vdXRCbG9jaztcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBkZWNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dCwgc2F2ZSBwcmV2aW91cyBjaXBoZXJlZCBibG9ja1xuICAvLyBDQkMgWE9SJ3MgSVYgKG9yIHByZXZpb3VzIGJsb2NrKSB3aXRoIGNpcGhlcnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9wcmV2W2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9pbkJsb2NrLnNsaWNlKDApO1xufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gIC8vIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcGFkIGJ5dGVzKVxuICB2YXIgcGFkZGluZyA9IChpbnB1dC5sZW5ndGgoKSA9PT0gdGhpcy5ibG9ja1NpemUgP1xuICAgIHRoaXMuYmxvY2tTaXplIDogKHRoaXMuYmxvY2tTaXplIC0gaW5wdXQubGVuZ3RoKCkpKTtcbiAgaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yOiBpbnB1dCBkYXRhIG5vdCBhIG11bHRpcGxlIG9mIGJsb2NrU2l6ZVxuICBpZihvcHRpb25zLm92ZXJmbG93ID4gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgdmFyIGNvdW50ID0gb3V0cHV0LmF0KGxlbiAtIDEpO1xuICBpZihjb3VudCA+ICh0aGlzLmJsb2NrU2l6ZSA8PCAyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiogQ2lwaGVyIGZlZWRiYWNrIChDRkIpICoqL1xuXG5tb2Rlcy5jZmIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnQ0ZCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX2luQmxvY2tbaV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgfVxuXG4gIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgcGFydGlhbCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIodGhpcy5fcGFydGlhbEJsb2NrW2ldKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmxvY2sgY29tcGxldGUsIHVwZGF0ZSBpbnB1dCBibG9ja1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wYXJ0aWFsQmxvY2tbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENGQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5faW5CbG9ja1tpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIHBhcnRpYWwgb3V0cHV0XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX3BhcnRpYWxCbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXJcbiAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIC8vIGJsb2NrIGNvbXBsZXRlLCB1cGRhdGUgaW5wdXQgYmxvY2tcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcGFydGlhbEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbi8qKiBPdXRwdXQgZmVlZGJhY2sgKE9GQikgKiovXG5cbm1vZGVzLm9mYiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdPRkInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKE9GQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCBhbmQgdXBkYXRlIG5leHQgaW5wdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX291dEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLm9mYi5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLm9mYi5wcm90b3R5cGUuZW5jcnlwdDtcblxuLyoqIENvdW50ZXIgKENUUikgKiovXG5cbm1vZGVzLmN0ciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDVFInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENUUiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIG91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgIH1cblxuICAgIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIGJsb2NrIGNvbXBsZXRlLCBpbmNyZW1lbnQgY291bnRlciAoaW5wdXQgYmxvY2spXG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5kZWNyeXB0ID0gbW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0O1xuXG4vKiogR2Fsb2lzL0NvdW50ZXIgTW9kZSAoR0NNKSAqKi9cblxubW9kZXMuZ2NtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0dDTSc7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcblxuICAvLyBSIGlzIGFjdHVhbGx5IHRoaXMgdmFsdWUgY29uY2F0ZW5hdGVkIHdpdGggMTIwIG1vcmUgemVybyBiaXRzLCBidXRcbiAgLy8gd2Ugb25seSBYT1IgYWdhaW5zdCBSIHNvIHRoZSBvdGhlciB6ZXJvcyBoYXZlIG5vIGVmZmVjdCAtLSB3ZSBqdXN0XG4gIC8vIGFwcGx5IHRoaXMgdmFsdWUgdG8gdGhlIGZpcnN0IGludGVnZXIgaW4gYSBibG9ja1xuICB0aGlzLl9SID0gMHhFMTAwMDAwMDtcbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gZW5zdXJlIElWIGlzIGEgYnl0ZSBidWZmZXJcbiAgdmFyIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5pdik7XG5cbiAgLy8gbm8gY2lwaGVyZWQgZGF0YSBwcm9jZXNzZWQgeWV0XG4gIHRoaXMuX2NpcGhlckxlbmd0aCA9IDA7XG5cbiAgLy8gZGVmYXVsdCBhZGRpdGlvbmFsIGRhdGEgaXMgbm9uZVxuICB2YXIgYWRkaXRpb25hbERhdGE7XG4gIGlmKCdhZGRpdGlvbmFsRGF0YScgaW4gb3B0aW9ucykge1xuICAgIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5hZGRpdGlvbmFsRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkaXRpb25hbERhdGEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0YWcgbGVuZ3RoIGlzIDEyOCBiaXRzXG4gIGlmKCd0YWdMZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSBvcHRpb25zLnRhZ0xlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSAxMjg7XG4gIH1cblxuICAvLyBpZiB0YWcgaXMgZ2l2ZW4sIGVuc3VyZSB0YWcgbWF0Y2hlcyB0YWcgbGVuZ3RoXG4gIHRoaXMuX3RhZyA9IG51bGw7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIC8vIHNhdmUgdGFnIHRvIGNoZWNrIGxhdGVyXG4gICAgdGhpcy5fdGFnID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy50YWcpLmdldEJ5dGVzKCk7XG4gICAgaWYodGhpcy5fdGFnLmxlbmd0aCAhPT0gKHRoaXMuX3RhZ0xlbmd0aCAvIDgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHRhZyBkb2VzIG5vdCBtYXRjaCB0YWcgbGVuZ3RoLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSB0bXAgc3RvcmFnZSBmb3IgaGFzaCBjYWxjdWxhdGlvblxuICB0aGlzLl9oYXNoQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG5cbiAgLy8gbm8gdGFnIGdlbmVyYXRlZCB5ZXRcbiAgdGhpcy50YWcgPSBudWxsO1xuXG4gIC8vIGdlbmVyYXRlIGhhc2ggc3Via2V5XG4gIC8vIChhcHBseSBibG9jayBjaXBoZXIgdG8gXCJ6ZXJvXCIgYmxvY2spXG4gIHRoaXMuX2hhc2hTdWJrZXkgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQoWzAsIDAsIDAsIDBdLCB0aGlzLl9oYXNoU3Via2V5KTtcblxuICAvLyBnZW5lcmF0ZSB0YWJsZSBNXG4gIC8vIHVzZSA0LWJpdCB0YWJsZXMgKDMyIGNvbXBvbmVudCBkZWNvbXBvc2l0aW9uIG9mIGEgMTYgYnl0ZSB2YWx1ZSlcbiAgLy8gOC1iaXQgdGFibGVzIHRha2UgbW9yZSBzcGFjZSBhbmQgYXJlIGtub3duIHRvIGhhdmUgc2VjdXJpdHlcbiAgLy8gdnVsbmVyYWJpbGl0aWVzIChpbiBuYXRpdmUgaW1wbGVtZW50YXRpb25zKVxuICB0aGlzLmNvbXBvbmVudEJpdHMgPSA0O1xuICB0aGlzLl9tID0gdGhpcy5nZW5lcmF0ZUhhc2hUYWJsZSh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLmNvbXBvbmVudEJpdHMpO1xuXG4gIC8vIE5vdGU6IHN1cHBvcnQgSVYgbGVuZ3RoIGRpZmZlcmVudCBmcm9tIDk2IGJpdHM/IChvbmx5IHN1cHBvcnRpbmdcbiAgLy8gOTYgYml0cyBpcyByZWNvbW1lbmRlZCBieSBOSVNUIFNQLTgwMC0zOEQpXG4gIC8vIGdlbmVyYXRlIEpfMFxuICB2YXIgaXZMZW5ndGggPSBpdi5sZW5ndGgoKTtcbiAgaWYoaXZMZW5ndGggPT09IDEyKSB7XG4gICAgLy8gOTYtYml0IElWXG4gICAgdGhpcy5fajAgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgMV07XG4gIH0gZWxzZSB7XG4gICAgLy8gSVYgaXMgTk9UIDk2LWJpdHNcbiAgICB0aGlzLl9qMCA9IFswLCAwLCAwLCAwXTtcbiAgICB3aGlsZShpdi5sZW5ndGgoKSA+IDApIHtcbiAgICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgICAgdGhpcy5faGFzaFN1YmtleSwgdGhpcy5fajAsXG4gICAgICAgIFtpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpXSk7XG4gICAgfVxuICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgIHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX2owLCBbMCwgMF0uY29uY2F0KGZyb202NFRvMzIoaXZMZW5ndGggKiA4KSkpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgSUNCIChpbml0aWFsIGNvdW50ZXIgYmxvY2spXG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9qMC5zbGljZSgwKTtcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG5cbiAgLy8gY29uc3VtZSBhdXRoZW50aWNhdGlvbiBkYXRhXG4gIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYWRkaXRpb25hbERhdGEpO1xuICAvLyBzYXZlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggYXMgYSBCRSA2NC1iaXQgbnVtYmVyXG4gIHRoaXMuX2FEYXRhTGVuZ3RoID0gZnJvbTY0VG8zMihhZGRpdGlvbmFsRGF0YS5sZW5ndGgoKSAqIDgpO1xuICAvLyBwYWQgYWRkaXRpb25hbCBkYXRhIHRvIDEyOCBiaXQgKDE2IGJ5dGUpIGJsb2NrIHNpemVcbiAgdmFyIG92ZXJmbG93ID0gYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYob3ZlcmZsb3cpIHtcbiAgICBhZGRpdGlvbmFsRGF0YS5maWxsV2l0aEJ5dGUoMCwgdGhpcy5ibG9ja1NpemUgLSBvdmVyZmxvdyk7XG4gIH1cbiAgdGhpcy5fcyA9IFswLCAwLCAwLCAwXTtcbiAgd2hpbGUoYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgPiAwKSB7XG4gICAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgW1xuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKVxuICAgIF0pO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXj0gaW5wdXQuZ2V0SW50MzIoKSk7XG4gICAgfVxuICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA9PT0gMCB8fCBmaW5pc2gpIHtcbiAgICAgIC8vIGhhbmRsZSBvdmVyZmxvdyBwcmlvciB0byBoYXNoaW5nXG4gICAgICBpZihmaW5pc2gpIHtcbiAgICAgICAgLy8gZ2V0IGJsb2NrIG92ZXJmbG93XG4gICAgICAgIHZhciBvdmVyZmxvdyA9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSBvdmVyZmxvdztcbiAgICAgICAgLy8gdHJ1bmNhdGUgZm9yIGhhc2ggZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZSAtIG92ZXJmbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IG91dHB1dCBibG9jayBmb3IgaGFzaGluZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICB0aGlzLl9vdXRCbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0SW50MzIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gICAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXIsIGdldCBwYXJ0aWFsIG91dHB1dCxcbiAgICAgIC8vIGFuZCByZXR1cm4gZWFybHlcbiAgICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBoYXNoIGJsb2NrIFNcbiAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0TGVuZ3RoID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKEdDTSBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG5cbiAgLy8gdXBkYXRlIGhhc2ggYmxvY2sgU1xuICB0aGlzLl9oYXNoQmxvY2tbMF0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMl0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbM10gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCB0aGlzLl9oYXNoQmxvY2spO1xuXG4gIC8vIFhPUiBoYXNoIGlucHV0IHdpdGggb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXiB0aGlzLl9oYXNoQmxvY2tbaV0pO1xuICB9XG5cbiAgLy8gaW5jcmVtZW50IGNpcGhlciBkYXRhIGxlbmd0aFxuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmFmdGVyRmluaXNoID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gIHZhciBydmFsID0gdHJ1ZTtcblxuICAvLyBoYW5kbGUgb3ZlcmZsb3dcbiAgaWYob3B0aW9ucy5kZWNyeXB0ICYmIG9wdGlvbnMub3ZlcmZsb3cpIHtcbiAgICBvdXRwdXQudHJ1bmNhdGUodGhpcy5ibG9ja1NpemUgLSBvcHRpb25zLm92ZXJmbG93KTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBhdXRoZW50aWNhdGlvbiB0YWdcbiAgdGhpcy50YWcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGNvbmNhdGVuYXRlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggd2l0aCBjaXBoZXIgbGVuZ3RoXG4gIHZhciBsZW5ndGhzID0gdGhpcy5fYURhdGFMZW5ndGguY29uY2F0KGZyb202NFRvMzIodGhpcy5fY2lwaGVyTGVuZ3RoICogOCkpO1xuXG4gIC8vIGluY2x1ZGUgbGVuZ3RocyBpbiBoYXNoXG4gIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIGxlbmd0aHMpO1xuXG4gIC8vIGRvIEdDVFIoSl8wLCBTKVxuICB2YXIgdGFnID0gW107XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5fajAsIHRhZyk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLnRhZy5wdXRJbnQzMih0aGlzLl9zW2ldIF4gdGFnW2ldKTtcbiAgfVxuXG4gIC8vIHRyaW0gdGFnIHRvIGxlbmd0aFxuICB0aGlzLnRhZy50cnVuY2F0ZSh0aGlzLnRhZy5sZW5ndGgoKSAlICh0aGlzLl90YWdMZW5ndGggLyA4KSk7XG5cbiAgLy8gY2hlY2sgYXV0aGVudGljYXRpb24gdGFnXG4gIGlmKG9wdGlvbnMuZGVjcnlwdCAmJiB0aGlzLnRhZy5ieXRlcygpICE9PSB0aGlzLl90YWcpIHtcbiAgICBydmFsID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU2VlIE5JU1QgU1AtODAwLTM4RCA2LjMgKEFsZ29yaXRobSAxKS4gVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBHYWxvaXNcbiAqIGZpZWxkIG11bHRpcGxpY2F0aW9uLiBUaGUgZmllbGQsIEdGKDJeMTI4KSwgaXMgZGVmaW5lZCBieSB0aGUgcG9seW5vbWlhbDpcbiAqXG4gKiB4XjEyOCArIHheNyArIHheMiArIHggKyAxXG4gKlxuICogV2hpY2ggaXMgcmVwcmVzZW50ZWQgaW4gbGl0dGxlLWVuZGlhbiBiaW5hcnkgZm9ybSBhczogMTExMDAwMDEgKDB4ZTEpLiBXaGVuXG4gKiB0aGUgdmFsdWUgb2YgYSBjb2VmZmljaWVudCBpcyAxLCBhIGJpdCBpcyBzZXQuIFRoZSB2YWx1ZSBSLCBpcyB0aGVcbiAqIGNvbmNhdGVuYXRpb24gb2YgdGhpcyB2YWx1ZSBhbmQgMTIwIHplcm8gYml0cywgeWllbGRpbmcgYSAxMjgtYml0IHZhbHVlXG4gKiB3aGljaCBtYXRjaGVzIHRoZSBibG9jayBzaXplLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtdWx0aXBseSB0d28gZWxlbWVudHMgKHZlY3RvcnMgb2YgYnl0ZXMpLCBYIGFuZCBZLCBpblxuICogdGhlIGZpZWxkIEdGKDJeMTI4KS4gVGhlIHJlc3VsdCBpcyBpbml0aWFsaXplZCB0byB6ZXJvLiBGb3IgZWFjaCBiaXQgb2ZcbiAqIFggKG91dCBvZiAxMjgpLCB4X2ksIGlmIHhfaSBpcyBzZXQsIHRoZW4gdGhlIHJlc3VsdCBpcyBtdWx0aXBsaWVkIChYT1InZClcbiAqIGJ5IHRoZSBjdXJyZW50IHZhbHVlIG9mIFkuIEZvciBlYWNoIGJpdCwgdGhlIHZhbHVlIG9mIFkgd2lsbCBiZSByYWlzZWQgYnlcbiAqIGEgcG93ZXIgb2YgeCAobXVsdGlwbGllZCBieSB0aGUgcG9seW5vbWlhbCB4KS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnlcbiAqIHNoaWZ0aW5nIFkgb25jZSB0byB0aGUgcmlnaHQuIElmIHRoZSBjdXJyZW50IHZhbHVlIG9mIFksIHByaW9yIHRvIGJlaW5nXG4gKiBtdWx0aXBsaWVkIGJ5IHgsIGhhcyAwIGFzIGl0cyBMU0IsIHRoZW4gaXQgaXMgYSAxMjd0aCBkZWdyZWUgcG9seW5vbWlhbC5cbiAqIE90aGVyd2lzZSwgd2UgbXVzdCBkaXZpZGUgYnkgUiBhZnRlciBzaGlmdGluZyB0byBmaW5kIHRoZSByZW1haW5kZXIuXG4gKlxuICogQHBhcmFtIHggdGhlIGZpcnN0IGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBzZWNvbmQuXG4gKiBAcGFyYW0geSB0aGUgc2Vjb25kIGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBmaXJzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBibG9jayByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgel9pID0gWzAsIDAsIDAsIDBdO1xuICB2YXIgdl9pID0geS5zbGljZSgwKTtcblxuICAvLyBjYWxjdWxhdGUgWl8xMjggKGJsb2NrIGhhcyAxMjggYml0cylcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgLy8gaWYgeF9pIGlzIDAsIFpfe2krMX0gPSBaX2kgKHVuY2hhbmdlZClcbiAgICAvLyBlbHNlIFpfe2krMX0gPSBaX2kgXiBWX2lcbiAgICAvLyBnZXQgeF9pIGJ5IGZpbmRpbmcgMzItYml0IGludCBwb3NpdGlvbiwgdGhlbiBsZWZ0IHNoaWZ0IDEgYnkgcmVtYWluZGVyXG4gICAgdmFyIHhfaSA9IHhbKGkgLyAzMikgfCAwXSAmICgxIDw8ICgzMSAtIGkgJSAzMikpO1xuICAgIGlmKHhfaSkge1xuICAgICAgel9pWzBdIF49IHZfaVswXTtcbiAgICAgIHpfaVsxXSBePSB2X2lbMV07XG4gICAgICB6X2lbMl0gXj0gdl9pWzJdO1xuICAgICAgel9pWzNdIF49IHZfaVszXTtcbiAgICB9XG5cbiAgICAvLyBpZiBMU0IoVl9pKSBpcyAxLCBWX2kgPSBWX2kgPj4gMVxuICAgIC8vIGVsc2UgVl9pID0gKFZfaSA+PiAxKSBeIFJcbiAgICB0aGlzLnBvdyh2X2ksIHZfaSk7XG4gIH1cblxuICByZXR1cm4gel9pO1xufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbih4LCBvdXQpIHtcbiAgLy8gaWYgTFNCKHgpIGlzIDEsIHggPSB4ID4+PiAxXG4gIC8vIGVsc2UgeCA9ICh4ID4+PiAxKSBeIFJcbiAgdmFyIGxzYiA9IHhbM10gJiAxO1xuXG4gIC8vIGFsd2F5cyBkbyB4ID4+PiAxOlxuICAvLyBzdGFydGluZyB3aXRoIHRoZSByaWdodG1vc3QgaW50ZWdlciwgc2hpZnQgZWFjaCBpbnRlZ2VyIHRvIHRoZSByaWdodFxuICAvLyBvbmUgYml0LCBwdWxsaW5nIGluIHRoZSBiaXQgZnJvbSB0aGUgaW50ZWdlciB0byB0aGUgbGVmdCBhcyBpdHMgdG9wXG4gIC8vIG1vc3QgYml0IChkbyB0aGlzIGZvciB0aGUgbGFzdCAzIGludGVnZXJzKVxuICBmb3IodmFyIGkgPSAzOyBpID4gMDsgLS1pKSB7XG4gICAgb3V0W2ldID0gKHhbaV0gPj4+IDEpIHwgKCh4W2kgLSAxXSAmIDEpIDw8IDMxKTtcbiAgfVxuICAvLyBzaGlmdCB0aGUgZmlyc3QgaW50ZWdlciBub3JtYWxseVxuICBvdXRbMF0gPSB4WzBdID4+PiAxO1xuXG4gIC8vIGlmIGxzYiB3YXMgbm90IHNldCwgdGhlbiBwb2x5bm9taWFsIGhhZCBhIGRlZ3JlZSBvZiAxMjcgYW5kIGRvZXNuJ3RcbiAgLy8gbmVlZCB0byBkaXZpZGVkOyBvdGhlcndpc2UsIFhPUiB3aXRoIFIgdG8gZmluZCB0aGUgcmVtYWluZGVyOyB3ZSBvbmx5XG4gIC8vIG5lZWQgdG8gWE9SIHRoZSBmaXJzdCBpbnRlZ2VyIHNpbmNlIFIgdGVjaG5pY2FsbHkgZW5kcyB3LzEyMCB6ZXJvIGJpdHNcbiAgaWYobHNiKSB7XG4gICAgb3V0WzBdIF49IHRoaXMuX1I7XG4gIH1cbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUudGFibGVNdWx0aXBseSA9IGZ1bmN0aW9uKHgpIHtcbiAgLy8gYXNzdW1lcyA0LWJpdCB0YWJsZXMgYXJlIHVzZWRcbiAgdmFyIHogPSBbMCwgMCwgMCwgMF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChpIC8gOCkgfCAwO1xuICAgIHZhciB4X2kgPSAoeFtpZHhdID4+PiAoKDcgLSAoaSAlIDgpKSAqIDQpKSAmIDB4RjtcbiAgICB2YXIgYWggPSB0aGlzLl9tW2ldW3hfaV07XG4gICAgelswXSBePSBhaFswXTtcbiAgICB6WzFdIF49IGFoWzFdO1xuICAgIHpbMl0gXj0gYWhbMl07XG4gICAgelszXSBePSBhaFszXTtcbiAgfVxuICByZXR1cm4gejtcbn07XG5cbi8qKlxuICogQSBjb250aW51aW5nIHZlcnNpb24gb2YgdGhlIEdIQVNIIGFsZ29yaXRobSB0aGF0IG9wZXJhdGVzIG9uIGEgc2luZ2xlXG4gKiBibG9jay4gVGhlIGhhc2ggYmxvY2ssIGxhc3QgaGFzaCB2YWx1ZSAoWW0pIGFuZCB0aGUgbmV3IGJsb2NrIHRvIGhhc2hcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBibG9jay5cbiAqIEBwYXJhbSB5IHRoZSBwcmV2aW91cyB2YWx1ZSBmb3IgWW0sIHVzZSBbMCwgMCwgMCwgMF0gZm9yIGEgbmV3IGhhc2guXG4gKiBAcGFyYW0geCB0aGUgYmxvY2sgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBoYXNoZWQgdmFsdWUgKFltKS5cbiAqL1xubW9kZXMuZ2NtLnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uKGgsIHksIHgpIHtcbiAgeVswXSBePSB4WzBdO1xuICB5WzFdIF49IHhbMV07XG4gIHlbMl0gXj0geFsyXTtcbiAgeVszXSBePSB4WzNdO1xuICByZXR1cm4gdGhpcy50YWJsZU11bHRpcGx5KHkpO1xuICAvL3JldHVybiB0aGlzLm11bHRpcGx5KHksIGgpO1xufTtcblxuLyoqXG4gKiBQcmVjb21wdXRlcyBhIHRhYmxlIGZvciBtdWx0aXBseWluZyBhZ2FpbnN0IHRoZSBoYXNoIHN1YmtleS4gVGhpc1xuICogbWVjaGFuaXNtIHByb3ZpZGVzIGEgc3Vic3RhbnRpYWwgc3BlZWQgaW5jcmVhc2Ugb3ZlciBtdWx0aXBsaWNhdGlvblxuICogcGVyZm9ybWVkIHdpdGhvdXQgYSB0YWJsZS4gVGhlIHRhYmxlLWJhc2VkIG11bHRpcGxpY2F0aW9uIHRoaXMgdGFibGUgaXNcbiAqIGZvciBzb2x2ZXMgWCAqIEggYnkgbXVsdGlwbHlpbmcgZWFjaCBjb21wb25lbnQgb2YgWCBieSBIIGFuZCB0aGVuXG4gKiBjb21wb3NpbmcgdGhlIHJlc3VsdHMgdG9nZXRoZXIgdXNpbmcgWE9SLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGFibGVzIHdpdGggZGlmZmVyZW50IGJpdCBzaXplc1xuICogZm9yIHRoZSBjb21wb25lbnRzLCBob3dldmVyLCB0aGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhlcmUgYXJlXG4gKiAzMiBjb21wb25lbnRzIG9mIFggKHdoaWNoIGlzIGEgMTYgYnl0ZSB2ZWN0b3IpLCB0aGVyZWZvcmUgZWFjaCBjb21wb25lbnRcbiAqIHRha2VzIDQtYml0cyAoc28gdGhlIHRhYmxlIGlzIGNvbnN0cnVjdGVkIHdpdGggYml0cz00KS5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBzdWJrZXkuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlSGFzaFRhYmxlID0gZnVuY3Rpb24oaCwgYml0cykge1xuICAvLyBUT0RPOiBUaGVyZSBhcmUgZnVydGhlciBvcHRpbWl6YXRpb25zIHRoYXQgd291bGQgdXNlIG9ubHkgdGhlXG4gIC8vIGZpcnN0IHRhYmxlIE1fMCAob3Igc29tZSB2YXJpYW50KSBhbG9uZyB3aXRoIGEgcmVtYWluZGVyIHRhYmxlO1xuICAvLyB0aGlzIGNhbiBiZSBleHBsb3JlZCBpbiB0aGUgZnV0dXJlXG4gIHZhciBtdWx0aXBsaWVyID0gOCAvIGJpdHM7XG4gIHZhciBwZXJJbnQgPSA0ICogbXVsdGlwbGllcjtcbiAgdmFyIHNpemUgPSAxNiAqIG11bHRpcGxpZXI7XG4gIHZhciBtID0gbmV3IEFycmF5KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgdmFyIHRtcCA9IFswLCAwLCAwLCAwXTtcbiAgICB2YXIgaWR4ID0gKGkgLyBwZXJJbnQpIHwgMDtcbiAgICB2YXIgc2hmdCA9ICgocGVySW50IC0gMSAtIChpICUgcGVySW50KSkgKiBiaXRzKTtcbiAgICB0bXBbaWR4XSA9ICgxIDw8IChiaXRzIC0gMSkpIDw8IHNoZnQ7XG4gICAgbVtpXSA9IHRoaXMuZ2VuZXJhdGVTdWJIYXNoVGFibGUodGhpcy5tdWx0aXBseSh0bXAsIGgpLCBiaXRzKTtcbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdGFibGUgZm9yIG11bHRpcGx5aW5nIGFnYWluc3QgdGhlIGhhc2ggc3Via2V5IGZvciBvbmVcbiAqIHBhcnRpY3VsYXIgY29tcG9uZW50IChvdXQgb2YgYWxsIHBvc3NpYmxlIGNvbXBvbmVudCB2YWx1ZXMpLlxuICpcbiAqIEBwYXJhbSBtaWQgdGhlIHByZS1tdWx0aXBsaWVkIHZhbHVlIGZvciB0aGUgbWlkZGxlIGtleSBvZiB0aGUgdGFibGUuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlU3ViSGFzaFRhYmxlID0gZnVuY3Rpb24obWlkLCBiaXRzKSB7XG4gIC8vIGNvbXB1dGUgdGhlIHRhYmxlIHF1aWNrbHkgYnkgbWluaW1pemluZyB0aGUgbnVtYmVyIG9mXG4gIC8vIFBPVyBvcGVyYXRpb25zIC0tIHRoZXkgb25seSBuZWVkIHRvIGJlIHBlcmZvcm1lZCBmb3IgcG93ZXJzIG9mIDIsXG4gIC8vIGFsbCBvdGhlciBlbnRyaWVzIGNhbiBiZSBjb21wb3NlZCBmcm9tIHRob3NlIHBvd2VycyB1c2luZyBYT1JcbiAgdmFyIHNpemUgPSAxIDw8IGJpdHM7XG4gIHZhciBoYWxmID0gc2l6ZSA+Pj4gMTtcbiAgdmFyIG0gPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIG1baGFsZl0gPSBtaWQuc2xpY2UoMCk7XG4gIHZhciBpID0gaGFsZiA+Pj4gMTtcbiAgd2hpbGUoaSA+IDApIHtcbiAgICAvLyByYWlzZSBtMFsyICogaV0gYW5kIHN0b3JlIGluIG0wW2ldXG4gICAgdGhpcy5wb3cobVsyICogaV0sIG1baV0gPSBbXSk7XG4gICAgaSA+Pj0gMTtcbiAgfVxuICBpID0gMjtcbiAgd2hpbGUoaSA8IGhhbGYpIHtcbiAgICBmb3IodmFyIGogPSAxOyBqIDwgaTsgKytqKSB7XG4gICAgICB2YXIgbV9pID0gbVtpXTtcbiAgICAgIHZhciBtX2ogPSBtW2pdO1xuICAgICAgbVtpICsgal0gPSBbXG4gICAgICAgIG1faVswXSBeIG1falswXSxcbiAgICAgICAgbV9pWzFdIF4gbV9qWzFdLFxuICAgICAgICBtX2lbMl0gXiBtX2pbMl0sXG4gICAgICAgIG1faVszXSBeIG1falszXVxuICAgICAgXTtcbiAgICB9XG4gICAgaSAqPSAyO1xuICB9XG4gIG1bMF0gPSBbMCwgMCwgMCwgMF07XG4gIC8qIE5vdGU6IFdlIGNvdWxkIGF2b2lkIHN0b3JpbmcgdGhlc2UgYnkgZG9pbmcgY29tcG9zaXRpb24gZHVyaW5nIG11bHRpcGx5XG4gIGNhbGN1bGF0ZSB0b3AgaGFsZiB1c2luZyBjb21wb3NpdGlvbiBieSBzcGVlZCBpcyBwcmVmZXJyZWQuICovXG4gIGZvcihpID0gaGFsZiArIDE7IGkgPCBzaXplOyArK2kpIHtcbiAgICB2YXIgYyA9IG1baSBeIGhhbGZdO1xuICAgIG1baV0gPSBbbWlkWzBdIF4gY1swXSwgbWlkWzFdIF4gY1sxXSwgbWlkWzJdIF4gY1syXSwgbWlkWzNdIF4gY1szXV07XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtSVYoaXYpIHtcbiAgaWYodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGNvbnZlcnQgaXYgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgfVxuXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShpdikgJiYgaXYubGVuZ3RoID4gNCkge1xuICAgIC8vIGNvbnZlcnQgaXYgYnl0ZSBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdmFyIHRtcCA9IGl2O1xuICAgIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICBpdi5wdXRCeXRlKHRtcFtpXSk7XG4gICAgfVxuICB9XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoaXYpKSB7XG4gICAgLy8gY29udmVydCBpdiBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gICAgaXYgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKV07XG4gIH1cblxuICByZXR1cm4gaXY7XG59XG5cbmZ1bmN0aW9uIGluYzMyKGJsb2NrKSB7XG4gIC8vIGluY3JlbWVudCBsYXN0IDMyIGJpdHMgb2YgYmxvY2sgb25seVxuICBibG9ja1tibG9jay5sZW5ndGggLSAxXSA9IChibG9ja1tibG9jay5sZW5ndGggLSAxXSArIDEpICYgMHhGRkZGRkZGRjtcbn1cblxuZnVuY3Rpb24gZnJvbTY0VG8zMihudW0pIHtcbiAgLy8gY29udmVydCA2NC1iaXQgbnVtYmVyIHRvIHR3byBCRSBJbnQzMnNcbiAgcmV0dXJuIFsobnVtIC8gMHgxMDAwMDAwMDApIHwgMCwgbnVtICYgMHhGRkZGRkZGRl07XG59XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIERFUyAoRGF0YSBFbmNyeXB0aW9uIFN0YW5kYXJkKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIHN1cHBvcnRzIERFUyBhcyB3ZWxsIGFzIDNERVMtRURFIGluIEVDQiBhbmQgQ0JDIG1vZGUuXG4gKiBJdCBpcyBiYXNlZCBvbiB0aGUgQlNELWxpY2Vuc2VkIGltcGxlbWVudGF0aW9uIGJ5IFBhdWwgVGVybzpcbiAqXG4gKiBQYXVsIFRlcm8sIEp1bHkgMjAwMVxuICogaHR0cDovL3d3dy50ZXJvLmNvLnVrL2Rlcy9cbiAqXG4gKiBPcHRpbWlzZWQgZm9yIHBlcmZvcm1hbmNlIHdpdGggbGFyZ2UgYmxvY2tzIGJ5IE1pY2hhZWwgSGF5d29ydGgsIE5vdmVtYmVyIDIwMDFcbiAqIGh0dHA6Ly93d3cubmV0ZGVhbGluZy5jb21cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICogSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1RcbiAqIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVlcbiAqIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAqIFNVQ0ggREFNQUdFLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBERVMgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmRlcyA9IGZvcmdlLmRlcyB8fCB7fTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gJ0VDQicgOiAnQ0JDJylcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqIGRlY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZSB8fCAoaXYgPT09IG51bGwgPyAnRUNCJyA6ICdDQkMnKVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgREVTIGNpcGhlciBhbGdvcml0aG0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gbW9kZSB0aGUgbW9kZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIERFUyBhbGdvcml0aG0gb2JqZWN0LlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYubmFtZSA9IG5hbWU7XG4gIHNlbGYubW9kZSA9IG5ldyBtb2RlKHtcbiAgICBibG9ja1NpemU6IDgsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX2tleXMsIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl9rZXlzLCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIERFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMua2V5KTtcbiAgaWYodGhpcy5uYW1lLmluZGV4T2YoJzNERVMnKSA9PT0gMCkge1xuICAgIGlmKGtleS5sZW5ndGgoKSAhPT0gMjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBUcmlwbGUtREVTIGtleSBzaXplOiAnICsga2V5Lmxlbmd0aCgpICogOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvbiB0byAxNiBvciA0OCBzdWJrZXlzIChzaW5nbGUgb3IgdHJpcGxlIERFUylcbiAgdGhpcy5fa2V5cyA9IF9jcmVhdGVLZXlzKGtleSk7XG4gIHRoaXMuX2luaXQgPSB0cnVlO1xufTtcblxuLyoqIFJlZ2lzdGVyIERFUyBhbGdvcml0aG1zICoqL1xuXG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUVDQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtQ0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLU9GQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuZGVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogREVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgc3BmdW5jdGlvbjEgPSBbMHgxMDEwNDAwLDAsMHgxMDAwMCwweDEwMTA0MDQsMHgxMDEwMDA0LDB4MTA0MDQsMHg0LDB4MTAwMDAsMHg0MDAsMHgxMDEwNDAwLDB4MTAxMDQwNCwweDQwMCwweDEwMDA0MDQsMHgxMDEwMDA0LDB4MTAwMDAwMCwweDQsMHg0MDQsMHgxMDAwNDAwLDB4MTAwMDQwMCwweDEwNDAwLDB4MTA0MDAsMHgxMDEwMDAwLDB4MTAxMDAwMCwweDEwMDA0MDQsMHgxMDAwNCwweDEwMDAwMDQsMHgxMDAwMDA0LDB4MTAwMDQsMCwweDQwNCwweDEwNDA0LDB4MTAwMDAwMCwweDEwMDAwLDB4MTAxMDQwNCwweDQsMHgxMDEwMDAwLDB4MTAxMDQwMCwweDEwMDAwMDAsMHgxMDAwMDAwLDB4NDAwLDB4MTAxMDAwNCwweDEwMDAwLDB4MTA0MDAsMHgxMDAwMDA0LDB4NDAwLDB4NCwweDEwMDA0MDQsMHgxMDQwNCwweDEwMTA0MDQsMHgxMDAwNCwweDEwMTAwMDAsMHgxMDAwNDA0LDB4MTAwMDAwNCwweDQwNCwweDEwNDA0LDB4MTAxMDQwMCwweDQwNCwweDEwMDA0MDAsMHgxMDAwNDAwLDAsMHgxMDAwNCwweDEwNDAwLDAsMHgxMDEwMDA0XTtcbnZhciBzcGZ1bmN0aW9uMiA9IFstMHg3ZmVmN2ZlMCwtMHg3ZmZmODAwMCwweDgwMDAsMHgxMDgwMjAsMHgxMDAwMDAsMHgyMCwtMHg3ZmVmZmZlMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwtMHg3ZmVmN2ZlMCwtMHg3ZmVmODAwMCwtMHg4MDAwMDAwMCwtMHg3ZmZmODAwMCwweDEwMDAwMCwweDIwLC0weDdmZWZmZmUwLDB4MTA4MDAwLDB4MTAwMDIwLC0weDdmZmY3ZmUwLDAsLTB4ODAwMDAwMDAsMHg4MDAwLDB4MTA4MDIwLC0weDdmZjAwMDAwLDB4MTAwMDIwLC0weDdmZmZmZmUwLDAsMHgxMDgwMDAsMHg4MDIwLC0weDdmZWY4MDAwLC0weDdmZjAwMDAwLDB4ODAyMCwwLDB4MTA4MDIwLC0weDdmZWZmZmUwLDB4MTAwMDAwLC0weDdmZmY3ZmUwLC0weDdmZjAwMDAwLC0weDdmZWY4MDAwLDB4ODAwMCwtMHg3ZmYwMDAwMCwtMHg3ZmZmODAwMCwweDIwLC0weDdmZWY3ZmUwLDB4MTA4MDIwLDB4MjAsMHg4MDAwLC0weDgwMDAwMDAwLDB4ODAyMCwtMHg3ZmVmODAwMCwweDEwMDAwMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwweDEwODAwMCwwLC0weDdmZmY4MDAwLDB4ODAyMCwtMHg4MDAwMDAwMCwtMHg3ZmVmZmZlMCwtMHg3ZmVmN2ZlMCwweDEwODAwMF07XG52YXIgc3BmdW5jdGlvbjMgPSBbMHgyMDgsMHg4MDIwMjAwLDAsMHg4MDIwMDA4LDB4ODAwMDIwMCwwLDB4MjAyMDgsMHg4MDAwMjAwLDB4MjAwMDgsMHg4MDAwMDA4LDB4ODAwMDAwOCwweDIwMDAwLDB4ODAyMDIwOCwweDIwMDA4LDB4ODAyMDAwMCwweDIwOCwweDgwMDAwMDAsMHg4LDB4ODAyMDIwMCwweDIwMCwweDIwMjAwLDB4ODAyMDAwMCwweDgwMjAwMDgsMHgyMDIwOCwweDgwMDAyMDgsMHgyMDIwMCwweDIwMDAwLDB4ODAwMDIwOCwweDgsMHg4MDIwMjA4LDB4MjAwLDB4ODAwMDAwMCwweDgwMjAyMDAsMHg4MDAwMDAwLDB4MjAwMDgsMHgyMDgsMHgyMDAwMCwweDgwMjAyMDAsMHg4MDAwMjAwLDAsMHgyMDAsMHgyMDAwOCwweDgwMjAyMDgsMHg4MDAwMjAwLDB4ODAwMDAwOCwweDIwMCwwLDB4ODAyMDAwOCwweDgwMDAyMDgsMHgyMDAwMCwweDgwMDAwMDAsMHg4MDIwMjA4LDB4OCwweDIwMjA4LDB4MjAyMDAsMHg4MDAwMDA4LDB4ODAyMDAwMCwweDgwMDAyMDgsMHgyMDgsMHg4MDIwMDAwLDB4MjAyMDgsMHg4LDB4ODAyMDAwOCwweDIwMjAwXTtcbnZhciBzcGZ1bmN0aW9uNCA9IFsweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODAsMHg4MDAwODEsMHg4MDAwMDEsMHgyMDAxLDAsMHg4MDIwMDAsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDB4ODAwMDgwLDB4ODAwMDAxLDB4MSwweDIwMDAsMHg4MDAwMDAsMHg4MDIwMDEsMHg4MCwweDgwMDAwMCwweDIwMDEsMHgyMDgwLDB4ODAwMDgxLDB4MSwweDIwODAsMHg4MDAwODAsMHgyMDAwLDB4ODAyMDgwLDB4ODAyMDgxLDB4ODEsMHg4MDAwODAsMHg4MDAwMDEsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDAsMHg4MDIwMDAsMHgyMDgwLDB4ODAwMDgwLDB4ODAwMDgxLDB4MSwweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODEsMHg4MSwweDEsMHgyMDAwLDB4ODAwMDAxLDB4MjAwMSwweDgwMjA4MCwweDgwMDA4MSwweDIwMDEsMHgyMDgwLDB4ODAwMDAwLDB4ODAyMDAxLDB4ODAsMHg4MDAwMDAsMHgyMDAwLDB4ODAyMDgwXTtcbnZhciBzcGZ1bmN0aW9uNSA9IFsweDEwMCwweDIwODAxMDAsMHgyMDgwMDAwLDB4NDIwMDAxMDAsMHg4MDAwMCwweDEwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQwMDgwMTAwLDB4ODAwMDAsMHgyMDAwMTAwLDB4NDAwODAxMDAsMHg0MjAwMDEwMCwweDQyMDgwMDAwLDB4ODAxMDAsMHg0MDAwMDAwMCwweDIwMDAwMDAsMHg0MDA4MDAwMCwweDQwMDgwMDAwLDAsMHg0MDAwMDEwMCwweDQyMDgwMTAwLDB4NDIwODAxMDAsMHgyMDAwMTAwLDB4NDIwODAwMDAsMHg0MDAwMDEwMCwwLDB4NDIwMDAwMDAsMHgyMDgwMTAwLDB4MjAwMDAwMCwweDQyMDAwMDAwLDB4ODAxMDAsMHg4MDAwMCwweDQyMDAwMTAwLDB4MTAwLDB4MjAwMDAwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQyMDAwMTAwLDB4NDAwODAxMDAsMHgyMDAwMTAwLDB4NDAwMDAwMDAsMHg0MjA4MDAwMCwweDIwODAxMDAsMHg0MDA4MDEwMCwweDEwMCwweDIwMDAwMDAsMHg0MjA4MDAwMCwweDQyMDgwMTAwLDB4ODAxMDAsMHg0MjAwMDAwMCwweDQyMDgwMTAwLDB4MjA4MDAwMCwwLDB4NDAwODAwMDAsMHg0MjAwMDAwMCwweDgwMTAwLDB4MjAwMDEwMCwweDQwMDAwMTAwLDB4ODAwMDAsMCwweDQwMDgwMDAwLDB4MjA4MDEwMCwweDQwMDAwMTAwXTtcbnZhciBzcGZ1bmN0aW9uNiA9IFsweDIwMDAwMDEwLDB4MjA0MDAwMDAsMHg0MDAwLDB4MjA0MDQwMTAsMHgyMDQwMDAwMCwweDEwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDQwNDAxMCwweDQwMDAwMCwweDIwMDAwMDEwLDB4NDAwMDEwLDB4MjAwMDQwMDAsMHgyMDAwMDAwMCwweDQwMTAsMCwweDQwMDAxMCwweDIwMDA0MDEwLDB4NDAwMCwweDQwNDAwMCwweDIwMDA0MDEwLDB4MTAsMHgyMDQwMDAxMCwweDIwNDAwMDEwLDAsMHg0MDQwMTAsMHgyMDQwNDAwMCwweDQwMTAsMHg0MDQwMDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4MjAwMDQwMDAsMHgxMCwweDIwNDAwMDEwLDB4NDA0MDAwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHg0MDEwLDB4MjAwMDAwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDIwMDAwMDAwLDB4NDAxMCwweDIwMDAwMDEwLDB4MjA0MDQwMTAsMHg0MDQwMDAsMHgyMDQwMDAwMCwweDQwNDAxMCwweDIwNDA0MDAwLDAsMHgyMDQwMDAxMCwweDEwLDB4NDAwMCwweDIwNDAwMDAwLDB4NDA0MDEwLDB4NDAwMCwweDQwMDAxMCwweDIwMDA0MDEwLDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4NDAwMDEwLDB4MjAwMDQwMTBdO1xudmFyIHNwZnVuY3Rpb243ID0gWzB4MjAwMDAwLDB4NDIwMDAwMiwweDQwMDA4MDIsMCwweDgwMCwweDQwMDA4MDIsMHgyMDA4MDIsMHg0MjAwODAwLDB4NDIwMDgwMiwweDIwMDAwMCwwLDB4NDAwMDAwMiwweDIsMHg0MDAwMDAwLDB4NDIwMDAwMiwweDgwMiwweDQwMDA4MDAsMHgyMDA4MDIsMHgyMDAwMDIsMHg0MDAwODAwLDB4NDAwMDAwMiwweDQyMDAwMDAsMHg0MjAwODAwLDB4MjAwMDAyLDB4NDIwMDAwMCwweDgwMCwweDgwMiwweDQyMDA4MDIsMHgyMDA4MDAsMHgyLDB4NDAwMDAwMCwweDIwMDgwMCwweDQwMDAwMDAsMHgyMDA4MDAsMHgyMDAwMDAsMHg0MDAwODAyLDB4NDAwMDgwMiwweDQyMDAwMDIsMHg0MjAwMDAyLDB4MiwweDIwMDAwMiwweDQwMDAwMDAsMHg0MDAwODAwLDB4MjAwMDAwLDB4NDIwMDgwMCwweDgwMiwweDIwMDgwMiwweDQyMDA4MDAsMHg4MDIsMHg0MDAwMDAyLDB4NDIwMDgwMiwweDQyMDAwMDAsMHgyMDA4MDAsMCwweDIsMHg0MjAwODAyLDAsMHgyMDA4MDIsMHg0MjAwMDAwLDB4ODAwLDB4NDAwMDAwMiwweDQwMDA4MDAsMHg4MDAsMHgyMDAwMDJdO1xudmFyIHNwZnVuY3Rpb244ID0gWzB4MTAwMDEwNDAsMHgxMDAwLDB4NDAwMDAsMHgxMDA0MTA0MCwweDEwMDAwMDAwLDB4MTAwMDEwNDAsMHg0MCwweDEwMDAwMDAwLDB4NDAwNDAsMHgxMDA0MDAwMCwweDEwMDQxMDQwLDB4NDEwMDAsMHgxMDA0MTAwMCwweDQxMDQwLDB4MTAwMCwweDQwLDB4MTAwNDAwMDAsMHgxMDAwMDA0MCwweDEwMDAxMDAwLDB4MTA0MCwweDQxMDAwLDB4NDAwNDAsMHgxMDA0MDA0MCwweDEwMDQxMDAwLDB4MTA0MCwwLDAsMHgxMDA0MDA0MCwweDEwMDAwMDQwLDB4MTAwMDEwMDAsMHg0MTA0MCwweDQwMDAwLDB4NDEwNDAsMHg0MDAwMCwweDEwMDQxMDAwLDB4MTAwMCwweDQwLDB4MTAwNDAwNDAsMHgxMDAwLDB4NDEwNDAsMHgxMDAwMTAwMCwweDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDQwMDQwLDB4MTAwMDAwMDAsMHg0MDAwMCwweDEwMDAxMDQwLDAsMHgxMDA0MTA0MCwweDQwMDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDAxMDAwLDB4MTAwMDEwNDAsMCwweDEwMDQxMDQwLDB4NDEwMDAsMHg0MTAwMCwweDEwNDAsMHgxMDQwLDB4NDAwNDAsMHgxMDAwMDAwMCwweDEwMDQxMDAwXTtcblxuLyoqXG4gKiBDcmVhdGUgbmVjZXNzYXJ5IHN1YiBrZXlzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIDY0LWJpdCBvciAxOTItYml0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXlzLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlS2V5cyhrZXkpIHtcbiAgdmFyIHBjMmJ5dGVzMCAgPSBbMCwweDQsMHgyMDAwMDAwMCwweDIwMDAwMDA0LDB4MTAwMDAsMHgxMDAwNCwweDIwMDEwMDAwLDB4MjAwMTAwMDQsMHgyMDAsMHgyMDQsMHgyMDAwMDIwMCwweDIwMDAwMjA0LDB4MTAyMDAsMHgxMDIwNCwweDIwMDEwMjAwLDB4MjAwMTAyMDRdLFxuICAgICAgcGMyYnl0ZXMxICA9IFswLDB4MSwweDEwMDAwMCwweDEwMDAwMSwweDQwMDAwMDAsMHg0MDAwMDAxLDB4NDEwMDAwMCwweDQxMDAwMDEsMHgxMDAsMHgxMDEsMHgxMDAxMDAsMHgxMDAxMDEsMHg0MDAwMTAwLDB4NDAwMDEwMSwweDQxMDAxMDAsMHg0MTAwMTAxXSxcbiAgICAgIHBjMmJ5dGVzMiAgPSBbMCwweDgsMHg4MDAsMHg4MDgsMHgxMDAwMDAwLDB4MTAwMDAwOCwweDEwMDA4MDAsMHgxMDAwODA4LDAsMHg4LDB4ODAwLDB4ODA4LDB4MTAwMDAwMCwweDEwMDAwMDgsMHgxMDAwODAwLDB4MTAwMDgwOF0sXG4gICAgICBwYzJieXRlczMgID0gWzAsMHgyMDAwMDAsMHg4MDAwMDAwLDB4ODIwMDAwMCwweDIwMDAsMHgyMDIwMDAsMHg4MDAyMDAwLDB4ODIwMjAwMCwweDIwMDAwLDB4MjIwMDAwLDB4ODAyMDAwMCwweDgyMjAwMDAsMHgyMjAwMCwweDIyMjAwMCwweDgwMjIwMDAsMHg4MjIyMDAwXSxcbiAgICAgIHBjMmJ5dGVzNCAgPSBbMCwweDQwMDAwLDB4MTAsMHg0MDAxMCwwLDB4NDAwMDAsMHgxMCwweDQwMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwXSxcbiAgICAgIHBjMmJ5dGVzNSAgPSBbMCwweDQwMCwweDIwLDB4NDIwLDAsMHg0MDAsMHgyMCwweDQyMCwweDIwMDAwMDAsMHgyMDAwNDAwLDB4MjAwMDAyMCwweDIwMDA0MjAsMHgyMDAwMDAwLDB4MjAwMDQwMCwweDIwMDAwMjAsMHgyMDAwNDIwXSxcbiAgICAgIHBjMmJ5dGVzNiAgPSBbMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDIsMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDJdLFxuICAgICAgcGMyYnl0ZXM3ICA9IFswLDB4MTAwMDAsMHg4MDAsMHgxMDgwMCwweDIwMDAwMDAwLDB4MjAwMTAwMDAsMHgyMDAwMDgwMCwweDIwMDEwODAwLDB4MjAwMDAsMHgzMDAwMCwweDIwODAwLDB4MzA4MDAsMHgyMDAyMDAwMCwweDIwMDMwMDAwLDB4MjAwMjA4MDAsMHgyMDAzMDgwMF0sXG4gICAgICBwYzJieXRlczggID0gWzAsMHg0MDAwMCwwLDB4NDAwMDAsMHgyLDB4NDAwMDIsMHgyLDB4NDAwMDIsMHgyMDAwMDAwLDB4MjA0MDAwMCwweDIwMDAwMDAsMHgyMDQwMDAwLDB4MjAwMDAwMiwweDIwNDAwMDIsMHgyMDAwMDAyLDB4MjA0MDAwMl0sXG4gICAgICBwYzJieXRlczkgID0gWzAsMHgxMDAwMDAwMCwweDgsMHgxMDAwMDAwOCwwLDB4MTAwMDAwMDAsMHg4LDB4MTAwMDAwMDgsMHg0MDAsMHgxMDAwMDQwMCwweDQwOCwweDEwMDAwNDA4LDB4NDAwLDB4MTAwMDA0MDAsMHg0MDgsMHgxMDAwMDQwOF0sXG4gICAgICBwYzJieXRlczEwID0gWzAsMHgyMCwwLDB4MjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgyMDAwLDB4MjAyMCwweDIwMDAsMHgyMDIwLDB4MTAyMDAwLDB4MTAyMDIwLDB4MTAyMDAwLDB4MTAyMDIwXSxcbiAgICAgIHBjMmJ5dGVzMTEgPSBbMCwweDEwMDAwMDAsMHgyMDAsMHgxMDAwMjAwLDB4MjAwMDAwLDB4MTIwMDAwMCwweDIwMDIwMCwweDEyMDAyMDAsMHg0MDAwMDAwLDB4NTAwMDAwMCwweDQwMDAyMDAsMHg1MDAwMjAwLDB4NDIwMDAwMCwweDUyMDAwMDAsMHg0MjAwMjAwLDB4NTIwMDIwMF0sXG4gICAgICBwYzJieXRlczEyID0gWzAsMHgxMDAwLDB4ODAwMDAwMCwweDgwMDEwMDAsMHg4MDAwMCwweDgxMDAwLDB4ODA4MDAwMCwweDgwODEwMDAsMHgxMCwweDEwMTAsMHg4MDAwMDEwLDB4ODAwMTAxMCwweDgwMDEwLDB4ODEwMTAsMHg4MDgwMDEwLDB4ODA4MTAxMF0sXG4gICAgICBwYzJieXRlczEzID0gWzAsMHg0LDB4MTAwLDB4MTA0LDAsMHg0LDB4MTAwLDB4MTA0LDB4MSwweDUsMHgxMDEsMHgxMDUsMHgxLDB4NSwweDEwMSwweDEwNV07XG5cbiAgLy8gaG93IG1hbnkgaXRlcmF0aW9ucyAoMSBmb3IgZGVzLCAzIGZvciB0cmlwbGUgZGVzKVxuICAvLyBjaGFuZ2VkIGJ5IFBhdWwgMTYvNi8yMDA3IHRvIHVzZSBUcmlwbGUgREVTIGZvciA5KyBieXRlIGtleXNcbiAgdmFyIGl0ZXJhdGlvbnMgPSBrZXkubGVuZ3RoKCkgPiA4ID8gMyA6IDE7XG5cbiAgLy8gc3RvcmVzIHRoZSByZXR1cm4ga2V5c1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIC8vIG5vdyBkZWZpbmUgdGhlIGxlZnQgc2hpZnRzIHdoaWNoIG5lZWQgdG8gYmUgZG9uZVxuICB2YXIgc2hpZnRzID0gWzAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDBdO1xuXG4gIHZhciBuID0gMCwgdG1wO1xuICBmb3IodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgdmFyIGxlZnQgPSBrZXkuZ2V0SW50MzIoKTtcbiAgICB2YXIgcmlnaHQgPSBrZXkuZ2V0SW50MzIoKTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gNCkgXiByaWdodCkgJiAweDBmMGYwZjBmO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMikgXiByaWdodCkgJiAweDMzMzMzMzMzO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMik7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgICBsZWZ0IF49IHRtcDtcbiAgICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICAgIC8vIHJpZ2h0IG5lZWRzIHRvIGJlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBsYXN0IGZvdXIgYml0cyBvZiBsZWZ0XG4gICAgdG1wID0gKGxlZnQgPDwgOCkgfCAoKHJpZ2h0ID4+PiAyMCkgJiAweDAwMDAwMGYwKTtcblxuICAgIC8vIGxlZnQgbmVlZHMgdG8gYmUgcHV0IHVwc2lkZSBkb3duXG4gICAgbGVmdCA9ICgocmlnaHQgPDwgMjQpIHwgKChyaWdodCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAoKHJpZ2h0ID4+PiA4KSAmIDB4ZmYwMCkgfCAoKHJpZ2h0ID4+PiAyNCkgJiAweGYwKSk7XG4gICAgcmlnaHQgPSB0bXA7XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGVzZSBzaGlmdHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IGtleXNcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2hpZnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvL3NoaWZ0IHRoZSBrZXlzIGVpdGhlciBvbmUgb3IgdHdvIGJpdHMgdG8gdGhlIGxlZnRcbiAgICAgIGlmKHNoaWZ0c1tpXSkge1xuICAgICAgICBsZWZ0ID0gKGxlZnQgPDwgMikgfCAobGVmdCA+Pj4gMjYpO1xuICAgICAgICByaWdodCA9IChyaWdodCA8PCAyKSB8IChyaWdodCA+Pj4gMjYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IChsZWZ0IDw8IDEpIHwgKGxlZnQgPj4+IDI3KTtcbiAgICAgICAgcmlnaHQgPSAocmlnaHQgPDwgMSkgfCAocmlnaHQgPj4+IDI3KTtcbiAgICAgIH1cbiAgICAgIGxlZnQgJj0gLTB4ZjtcbiAgICAgIHJpZ2h0ICY9IC0weGY7XG5cbiAgICAgIC8vIG5vdyBhcHBseSBQQy0yLCBpbiBzdWNoIGEgd2F5IHRoYXQgRSBpcyBlYXNpZXIgd2hlbiBlbmNyeXB0aW5nIG9yXG4gICAgICAvLyBkZWNyeXB0aW5nIHRoaXMgY29udmVyc2lvbiB3aWxsIGxvb2sgbGlrZSBQQy0yIGV4Y2VwdCBvbmx5IHRoZSBsYXN0IDZcbiAgICAgIC8vIGJpdHMgb2YgZWFjaCBieXRlIGFyZSB1c2VkIHJhdGhlciB0aGFuIDQ4IGNvbnNlY3V0aXZlIGJpdHMgYW5kIHRoZVxuICAgICAgLy8gb3JkZXIgb2YgbGluZXMgd2lsbCBiZSBhY2NvcmRpbmcgdG8gaG93IHRoZSBTIHNlbGVjdGlvbiBmdW5jdGlvbnMgd2lsbFxuICAgICAgLy8gYmUgYXBwbGllZDogUzIsIFM0LCBTNiwgUzgsIFMxLCBTMywgUzUsIFM3XG4gICAgICB2YXIgbGVmdHRtcCA9IChcbiAgICAgICAgcGMyYnl0ZXMwW2xlZnQgPj4+IDI4XSB8IHBjMmJ5dGVzMVsobGVmdCA+Pj4gMjQpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzMlsobGVmdCA+Pj4gMjApICYgMHhmXSB8IHBjMmJ5dGVzM1sobGVmdCA+Pj4gMTYpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzNFsobGVmdCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzNVsobGVmdCA+Pj4gOCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXM2WyhsZWZ0ID4+PiA0KSAmIDB4Zl0pO1xuICAgICAgdmFyIHJpZ2h0dG1wID0gKFxuICAgICAgICBwYzJieXRlczdbcmlnaHQgPj4+IDI4XSB8IHBjMmJ5dGVzOFsocmlnaHQgPj4+IDI0KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczlbKHJpZ2h0ID4+PiAyMCkgJiAweGZdIHwgcGMyYnl0ZXMxMFsocmlnaHQgPj4+IDE2KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczExWyhyaWdodCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzMTJbKHJpZ2h0ID4+PiA4KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczEzWyhyaWdodCA+Pj4gNCkgJiAweGZdKTtcbiAgICAgIHRtcCA9ICgocmlnaHR0bXAgPj4+IDE2KSBeIGxlZnR0bXApICYgMHgwMDAwZmZmZjtcbiAgICAgIGtleXNbbisrXSA9IGxlZnR0bXAgXiB0bXA7XG4gICAgICBrZXlzW24rK10gPSByaWdodHRtcCBeICh0bXAgPDwgMTYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDEgYnl0ZSkgdXNpbmcgREVTLiBUaGUgdXBkYXRlIHdpbGwgZWl0aGVyXG4gKiBlbmNyeXB0IG9yIGRlY3J5cHQgdGhlIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBrZXlzIHRoZSBleHBhbmRlZCBrZXlzLlxuICogQHBhcmFtIGlucHV0IHRoZSBpbnB1dCBibG9jayAoYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIHVwZGF0ZWQgb3V0cHV0IGJsb2NrLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0IHRoZSBibG9jaywgZmFsc2UgdG8gZW5jcnlwdCBpdC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKGtleXMsIGlucHV0LCBvdXRwdXQsIGRlY3J5cHQpIHtcbiAgLy8gc2V0IHVwIGxvb3BzIGZvciBzaW5nbGUgb3IgdHJpcGxlIERFU1xuICB2YXIgaXRlcmF0aW9ucyA9IGtleXMubGVuZ3RoID09PSAzMiA/IDMgOiA5O1xuICB2YXIgbG9vcGluZztcbiAgaWYoaXRlcmF0aW9ucyA9PT0gMykge1xuICAgIGxvb3BpbmcgPSBkZWNyeXB0ID8gWzMwLCAtMiwgLTJdIDogWzAsIDMyLCAyXTtcbiAgfSBlbHNlIHtcbiAgICBsb29waW5nID0gKGRlY3J5cHQgP1xuICAgICAgWzk0LCA2MiwgLTIsIDMyLCA2NCwgMiwgMzAsIC0yLCAtMl0gOlxuICAgICAgWzAsIDMyLCAyLCA2MiwgMzAsIC0yLCA2NCwgOTYsIDJdKTtcbiAgfVxuXG4gIHZhciB0bXA7XG5cbiAgdmFyIGxlZnQgPSBpbnB1dFswXTtcbiAgdmFyIHJpZ2h0ID0gaW5wdXRbMV07XG5cbiAgLy8gZmlyc3QgZWFjaCA2NCBiaXQgY2h1bmsgb2YgdGhlIG1lc3NhZ2UgbXVzdCBiZSBwZXJtdXRlZCBhY2NvcmRpbmcgdG8gSVBcbiAgdG1wID0gKChsZWZ0ID4+PiA0KSBeIHJpZ2h0KSAmIDB4MGYwZjBmMGY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDQpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gMTYpIF4gcmlnaHQpICYgMHgwMDAwZmZmZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMTYpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgOCk7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gIC8vIHJvdGF0ZSBsZWZ0IDEgYml0XG4gIGxlZnQgPSAoKGxlZnQgPDwgMSkgfCAobGVmdCA+Pj4gMzEpKTtcbiAgcmlnaHQgPSAoKHJpZ2h0IDw8IDEpIHwgKHJpZ2h0ID4+PiAzMSkpO1xuXG4gIGZvcih2YXIgaiA9IDA7IGogPCBpdGVyYXRpb25zOyBqICs9IDMpIHtcbiAgICB2YXIgZW5kbG9vcCA9IGxvb3BpbmdbaiArIDFdO1xuICAgIHZhciBsb29waW5jID0gbG9vcGluZ1tqICsgMl07XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uXG4gICAgZm9yKHZhciBpID0gbG9vcGluZ1tqXTsgaSAhPSBlbmRsb29wOyBpICs9IGxvb3BpbmMpIHtcbiAgICAgIHZhciByaWdodDEgPSByaWdodCBeIGtleXNbaV07XG4gICAgICB2YXIgcmlnaHQyID0gKChyaWdodCA+Pj4gNCkgfCAocmlnaHQgPDwgMjgpKSBeIGtleXNbaSArIDFdO1xuXG4gICAgICAvLyBwYXNzaW5nIHRoZXNlIGJ5dGVzIHRocm91Z2ggdGhlIFMgc2VsZWN0aW9uIGZ1bmN0aW9uc1xuICAgICAgdG1wID0gbGVmdDtcbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gdG1wIF4gKFxuICAgICAgICBzcGZ1bmN0aW9uMlsocmlnaHQxID4+PiAyNCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb240WyhyaWdodDEgPj4+IDE2KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjZbKHJpZ2h0MSA+Pj4gIDgpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uOFtyaWdodDEgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb24xWyhyaWdodDIgPj4+IDI0KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjNbKHJpZ2h0MiA+Pj4gMTYpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uNVsocmlnaHQyID4+PiAgOCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb243W3JpZ2h0MiAmIDB4M2ZdKTtcbiAgICB9XG4gICAgLy8gdW5yZXZlcnNlIGxlZnQgYW5kIHJpZ2h0XG4gICAgdG1wID0gbGVmdDtcbiAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgcmlnaHQgPSB0bXA7XG4gIH1cblxuICAvLyByb3RhdGUgcmlnaHQgMSBiaXRcbiAgbGVmdCA9ICgobGVmdCA+Pj4gMSkgfCAobGVmdCA8PCAzMSkpO1xuICByaWdodCA9ICgocmlnaHQgPj4+IDEpIHwgKHJpZ2h0IDw8IDMxKSk7XG5cbiAgLy8gbm93IHBlcmZvcm0gSVAtMSwgd2hpY2ggaXMgSVAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gOCkgXiBsZWZ0KSAmIDB4MDBmZjAwZmY7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDE2KSBeIHJpZ2h0KSAmIDB4MDAwMGZmZmY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDE2KTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDQpIF4gcmlnaHQpICYgMHgwZjBmMGYwZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgb3V0cHV0WzBdID0gbGVmdDtcbiAgb3V0cHV0WzFdID0gcmlnaHQ7XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBERVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogICAgICAgICAgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICogICAgICAgICAgbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlQ2lwaGVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCAnQ0JDJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIGFsZ29yaXRobSA9ICdERVMtJyArIG1vZGU7XG5cbiAgdmFyIGNpcGhlcjtcbiAgaWYob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH1cblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdGFydCBBUElcbiAgdmFyIHN0YXJ0ID0gY2lwaGVyLnN0YXJ0O1xuICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9ucykge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBzdXBwb3J0IHNlY29uZCBhcmcgYXMgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciBvdXRwdXQgPSBudWxsO1xuICAgIGlmKG9wdGlvbnMgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgIG91dHB1dCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMub3V0cHV0ID0gb3V0cHV0O1xuICAgIG9wdGlvbnMuaXYgPSBpdjtcbiAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24gIzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogU2VlIFJGQyAyODk4IGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBwa2NzNSA9IGZvcmdlLnBrY3M1ID0gZm9yZ2UucGtjczUgfHwge307XG5cbnZhciBjcnlwdG87XG5pZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0KSB7XG4gIGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xufVxuXG4vKipcbiAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBwIHRoZSBwYXNzd29yZCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBzIHRoZSBzYWx0IGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIGMgdGhlIGl0ZXJhdGlvbiBjb3VudCwgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICogQHBhcmFtIGRrTGVuIHRoZSBpbnRlbmRlZCBsZW5ndGgsIGluIGJ5dGVzLCBvZiB0aGUgZGVyaXZlZCBrZXksXG4gKiAgICAgICAgICAobWF4OiAyXjMyIC0gMSkgKiBoYXNoIGxlbmd0aCBvZiB0aGUgUFJGLlxuICogQHBhcmFtIFttZF0gdGhlIG1lc3NhZ2UgZGlnZXN0IChvciBhbGdvcml0aG0gaWRlbnRpZmllciBhcyBhIHN0cmluZykgdG8gdXNlXG4gKiAgICAgICAgICBpbiB0aGUgUFJGLCBkZWZhdWx0cyB0byBTSEEtMS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXkpXSBwcmVzZW5jZSB0cmlnZ2VycyBhc3luY2hyb25vdXMgdmVyc2lvbiwgY2FsbGVkXG4gKiAgICAgICAgICBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlcml2ZWQga2V5LCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcywgZm9yIHRoZVxuICogICAgICAgICAgIHN5bmNocm9ub3VzIHZlcnNpb24gKGlmIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCkuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGJrZGYyID0gcGtjczUucGJrZGYyID0gZnVuY3Rpb24oXG4gIHAsIHMsIGMsIGRrTGVuLCBtZCwgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG1kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtZDtcbiAgICBtZCA9IG51bGw7XG4gIH1cblxuICAvLyB1c2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlmIHBvc3NpYmxlIGFuZCBub3QgZGlzYWJsZWQsIG5vdGUgdGhhdFxuICAvLyBzb21lIG5vZGUgdmVyc2lvbnMgb25seSBzdXBwb3J0IFNIQS0xLCBvdGhlcnMgYWxsb3cgZGlnZXN0IHRvIGJlIGNoYW5nZWRcbiAgaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAgIGNyeXB0by5wYmtkZjIgJiYgKG1kID09PSBudWxsIHx8IHR5cGVvZiBtZCAhPT0gJ29iamVjdCcpICYmXG4gICAgKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA+IDQgfHwgKCFtZCB8fCBtZCA9PT0gJ3NoYTEnKSkpIHtcbiAgICBpZih0eXBlb2YgbWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkZWZhdWx0IHByZiB0byBTSEEtMVxuICAgICAgbWQgPSAnc2hhMSc7XG4gICAgfVxuICAgIHAgPSBuZXcgQnVmZmVyKHAsICdiaW5hcnknKTtcbiAgICBzID0gbmV3IEJ1ZmZlcihzLCAnYmluYXJ5Jyk7XG4gICAgaWYoIWNhbGxiYWNrKSB7XG4gICAgICBpZihjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjJTeW5jKHAsIHMsIGMsIGRrTGVuKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3J5cHRvLnBia2RmMlN5bmMocCwgcywgYywgZGtMZW4sIG1kKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgfVxuICAgIGlmKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjIocCwgcywgYywgZGtMZW4sIGZ1bmN0aW9uKGVyciwga2V5KSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcnlwdG8ucGJrZGYyKHAsIHMsIGMsIGRrTGVuLCBtZCwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIC8vIGRlZmF1bHQgcHJmIHRvIFNIQS0xXG4gICAgbWQgPSAnc2hhMSc7XG4gIH1cbiAgaWYodHlwZW9mIG1kID09PSAnc3RyaW5nJykge1xuICAgIGlmKCEobWQgaW4gZm9yZ2UubWQuYWxnb3JpdGhtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIG1kKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gIH1cblxuICB2YXIgaExlbiA9IG1kLmRpZ2VzdExlbmd0aDtcblxuICAvKiAxLiBJZiBka0xlbiA+ICgyXjMyIC0gMSkgKiBoTGVuLCBvdXRwdXQgXCJkZXJpdmVkIGtleSB0b28gbG9uZ1wiIGFuZFxuICAgIHN0b3AuICovXG4gIGlmKGRrTGVuID4gKDB4RkZGRkZGRkYgKiBoTGVuKSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Rlcml2ZWQga2V5IGlzIHRvbyBsb25nLicpO1xuICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgLyogMi4gTGV0IGxlbiBiZSB0aGUgbnVtYmVyIG9mIGhMZW4tb2N0ZXQgYmxvY2tzIGluIHRoZSBkZXJpdmVkIGtleSxcbiAgICByb3VuZGluZyB1cCwgYW5kIGxldCByIGJlIHRoZSBudW1iZXIgb2Ygb2N0ZXRzIGluIHRoZSBsYXN0XG4gICAgYmxvY2s6XG5cbiAgICBsZW4gPSBDRUlMKGRrTGVuIC8gaExlbiksXG4gICAgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbi4gKi9cbiAgdmFyIGxlbiA9IE1hdGguY2VpbChka0xlbiAvIGhMZW4pO1xuICB2YXIgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbjtcblxuICAvKiAzLiBGb3IgZWFjaCBibG9jayBvZiB0aGUgZGVyaXZlZCBrZXkgYXBwbHkgdGhlIGZ1bmN0aW9uIEYgZGVmaW5lZFxuICAgIGJlbG93IHRvIHRoZSBwYXNzd29yZCBQLCB0aGUgc2FsdCBTLCB0aGUgaXRlcmF0aW9uIGNvdW50IGMsIGFuZFxuICAgIHRoZSBibG9jayBpbmRleCB0byBjb21wdXRlIHRoZSBibG9jazpcblxuICAgIFRfMSA9IEYoUCwgUywgYywgMSksXG4gICAgVF8yID0gRihQLCBTLCBjLCAyKSxcbiAgICAuLi5cbiAgICBUX2xlbiA9IEYoUCwgUywgYywgbGVuKSxcblxuICAgIHdoZXJlIHRoZSBmdW5jdGlvbiBGIGlzIGRlZmluZWQgYXMgdGhlIGV4Y2x1c2l2ZS1vciBzdW0gb2YgdGhlXG4gICAgZmlyc3QgYyBpdGVyYXRlcyBvZiB0aGUgdW5kZXJseWluZyBwc2V1ZG9yYW5kb20gZnVuY3Rpb24gUFJGXG4gICAgYXBwbGllZCB0byB0aGUgcGFzc3dvcmQgUCBhbmQgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHNhbHQgU1xuICAgIGFuZCB0aGUgYmxvY2sgaW5kZXggaTpcblxuICAgIEYoUCwgUywgYywgaSkgPSB1XzEgWE9SIHVfMiBYT1IgLi4uIFhPUiB1X2NcblxuICAgIHdoZXJlXG5cbiAgICB1XzEgPSBQUkYoUCwgUyB8fCBJTlQoaSkpLFxuICAgIHVfMiA9IFBSRihQLCB1XzEpLFxuICAgIC4uLlxuICAgIHVfYyA9IFBSRihQLCB1X3tjLTF9KS5cblxuICAgIEhlcmUsIElOVChpKSBpcyBhIGZvdXItb2N0ZXQgZW5jb2Rpbmcgb2YgdGhlIGludGVnZXIgaSwgbW9zdFxuICAgIHNpZ25pZmljYW50IG9jdGV0IGZpcnN0LiAqL1xuICB2YXIgcHJmID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgcHJmLnN0YXJ0KG1kLCBwKTtcbiAgdmFyIGRrID0gJyc7XG4gIHZhciB4b3IsIHVfYywgdV9jMTtcblxuICAvLyBzeW5jIHZlcnNpb25cbiAgaWYoIWNhbGxiYWNrKSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8PSBsZW47ICsraSkge1xuICAgICAgLy8gUFJGKFAsIFMgfHwgSU5UKGkpKSAoZmlyc3QgaXRlcmF0aW9uKVxuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZShzKTtcbiAgICAgIHByZi51cGRhdGUoZm9yZ2UudXRpbC5pbnQzMlRvQnl0ZXMoaSkpO1xuICAgICAgeG9yID0gdV9jMSA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgICBmb3IodmFyIGogPSAyOyBqIDw9IGM7ICsraikge1xuICAgICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICAgIHByZi51cGRhdGUodV9jMSk7XG4gICAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgICAvLyBGKHAsIHMsIGMsIGkpXG4gICAgICAgIHhvciA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoeG9yLCB1X2MsIGhMZW4pO1xuICAgICAgICB1X2MxID0gdV9jO1xuICAgICAgfVxuXG4gICAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgICAgcHJvZHVjZSBhIGRlcml2ZWQga2V5IERLOlxuXG4gICAgICAgIERLID0gVF8xIHx8IFRfMiB8fCAgLi4uICB8fCBUX2xlbjwwLi5yLTE+ICovXG4gICAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuICAgIH1cbiAgICAvKiA1LiBPdXRwdXQgdGhlIGRlcml2ZWQga2V5IERLLiAqL1xuICAgIHJldHVybiBkaztcbiAgfVxuXG4gIC8vIGFzeW5jIHZlcnNpb25cbiAgdmFyIGkgPSAxLCBqO1xuICBmdW5jdGlvbiBvdXRlcigpIHtcbiAgICBpZihpID4gbGVuKSB7XG4gICAgICAvLyBkb25lXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGspO1xuICAgIH1cblxuICAgIC8vIFBSRihQLCBTIHx8IElOVChpKSkgKGZpcnN0IGl0ZXJhdGlvbilcbiAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgcHJmLnVwZGF0ZShzKTtcbiAgICBwcmYudXBkYXRlKGZvcmdlLnV0aWwuaW50MzJUb0J5dGVzKGkpKTtcbiAgICB4b3IgPSB1X2MxID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgaiA9IDI7XG4gICAgaW5uZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgIGlmKGogPD0gYykge1xuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZSh1X2MxKTtcbiAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgLy8gRihwLCBzLCBjLCBpKVxuICAgICAgeG9yID0gZm9yZ2UudXRpbC54b3JCeXRlcyh4b3IsIHVfYywgaExlbik7XG4gICAgICB1X2MxID0gdV9jO1xuICAgICAgKytqO1xuICAgICAgcmV0dXJuIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGlubmVyKTtcbiAgICB9XG5cbiAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgIHByb2R1Y2UgYSBkZXJpdmVkIGtleSBESzpcblxuICAgICAgREsgPSBUXzEgfHwgVF8yIHx8ICAuLi4gIHx8IFRfbGVuPDAuLnItMT4gKi9cbiAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuXG4gICAgKytpO1xuICAgIG91dGVyKCk7XG4gIH1cblxuICBvdXRlcigpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSGFzaC1iYXNlZCBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgaW1wbGVtZW50YXRpb24uIFJlcXVpcmVzIGEgbWVzc2FnZVxuICogZGlnZXN0IG9iamVjdCB0aGF0IGNhbiBiZSBvYnRhaW5lZCwgZm9yIGV4YW1wbGUsIGZyb20gZm9yZ2UubWQuc2hhMSBvclxuICogZm9yZ2UubWQubWQ1LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBITUFDIEFQSSAqL1xudmFyIGhtYWMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmhtYWMgPSBmb3JnZS5obWFjIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gSE1BQyBvYmplY3QgdGhhdCB1c2VzIHRoZSBnaXZlbiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhbiBITUFDIG9iamVjdC5cbiAqL1xuaG1hYy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gdGhlIGhtYWMga2V5IHRvIHVzZVxuICB2YXIgX2tleSA9IG51bGw7XG5cbiAgLy8gdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZVxuICB2YXIgX21kID0gbnVsbDtcblxuICAvLyB0aGUgaW5uZXIgcGFkZGluZ1xuICB2YXIgX2lwYWRkaW5nID0gbnVsbDtcblxuICAvLyB0aGUgb3V0ZXIgcGFkZGluZ1xuICB2YXIgX29wYWRkaW5nID0gbnVsbDtcblxuICAvLyBobWFjIGNvbnRleHRcbiAgdmFyIGN0eCA9IHt9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIEhNQUMgd2l0aCB0aGUgZ2l2ZW4ga2V5IGFuZCBtZXNzYWdlIGRpZ2VzdC5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2UsIG51bGwgdG8gcmV1c2UgdGhlIHByZXZpb3VzIG9uZSxcbiAgICogICAgICAgICAgIGEgc3RyaW5nIHRvIHVzZSBidWlsdGluICdzaGExJywgJ21kNScsICdzaGEyNTYnLlxuICAgKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGFzIGEgc3RyaW5nLCBhcnJheSBvZiBieXRlcywgYnl0ZSBidWZmZXIsXG4gICAqICAgICAgICAgICBvciBudWxsIHRvIHJldXNlIHRoZSBwcmV2aW91cyBrZXkuXG4gICAqL1xuICBjdHguc3RhcnQgPSBmdW5jdGlvbihtZCwga2V5KSB7XG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIGlmKHR5cGVvZiBtZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY3JlYXRlIGJ1aWx0aW4gbWVzc2FnZSBkaWdlc3RcbiAgICAgICAgbWQgPSBtZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZihtZCBpbiBmb3JnZS5tZC5hbGdvcml0aG1zKSB7XG4gICAgICAgICAgX21kID0gZm9yZ2UubWQuYWxnb3JpdGhtc1ttZF0uY3JlYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhhc2ggYWxnb3JpdGhtIFwiJyArIG1kICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0b3JlIG1lc3NhZ2UgZGlnZXN0XG4gICAgICAgIF9tZCA9IG1kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGtleSA9PT0gbnVsbCkge1xuICAgICAgLy8gcmV1c2UgcHJldmlvdXMga2V5XG4gICAgICBrZXkgPSBfa2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gICAgICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgLy8gY29udmVydCBieXRlIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICAgICAgdmFyIHRtcCA9IGtleTtcbiAgICAgICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleS5wdXRCeXRlKHRtcFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIGxvbmdlciB0aGFuIGJsb2Nrc2l6ZSwgaGFzaCBpdFxuICAgICAgdmFyIGtleWxlbiA9IGtleS5sZW5ndGgoKTtcbiAgICAgIGlmKGtleWxlbiA+IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICBfbWQuc3RhcnQoKTtcbiAgICAgICAgX21kLnVwZGF0ZShrZXkuYnl0ZXMoKSk7XG4gICAgICAgIGtleSA9IF9tZC5kaWdlc3QoKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWl4IGtleSBpbnRvIGlubmVyIGFuZCBvdXRlciBwYWRkaW5nXG4gICAgICAvLyBpcGFkZGluZyA9IFsweDM2ICogYmxvY2tzaXplXSBeIGtleVxuICAgICAgLy8gb3BhZGRpbmcgPSBbMHg1QyAqIGJsb2Nrc2l6ZV0gXiBrZXlcbiAgICAgIF9pcGFkZGluZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfb3BhZGRpbmcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGtleWxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0bXAgPSBrZXkuYXQoaSk7XG4gICAgICAgIF9pcGFkZGluZy5wdXRCeXRlKDB4MzYgXiB0bXApO1xuICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDIF4gdG1wKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIHNob3J0ZXIgdGhhbiBibG9ja3NpemUsIGFkZCBhZGRpdGlvbmFsIHBhZGRpbmdcbiAgICAgIGlmKGtleWxlbiA8IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICB2YXIgdG1wID0gX21kLmJsb2NrTGVuZ3RoIC0ga2V5bGVuO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wOyArK2kpIHtcbiAgICAgICAgICBfaXBhZGRpbmcucHV0Qnl0ZSgweDM2KTtcbiAgICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2tleSA9IGtleTtcbiAgICAgIF9pcGFkZGluZyA9IF9pcGFkZGluZy5ieXRlcygpO1xuICAgICAgX29wYWRkaW5nID0gX29wYWRkaW5nLmJ5dGVzKCk7XG4gICAgfVxuXG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcblxuICAgIC8vIHByZXBhcmUgdG8gZG8gaW5uZXIgaGFzaFxuICAgIC8vIGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKVxuICAgIF9tZC5zdGFydCgpO1xuICAgIF9tZC51cGRhdGUoX2lwYWRkaW5nKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgSE1BQyB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIHVwZGF0ZSB3aXRoLlxuICAgKi9cbiAgY3R4LnVwZGF0ZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgX21kLnVwZGF0ZShieXRlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgKE1BQykuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBjdHguZ2V0TWFjID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcbiAgICAvLyBoZXJlIHdlIGRvIHRoZSBvdXRlciBoYXNoaW5nXG4gICAgdmFyIGlubmVyID0gX21kLmRpZ2VzdCgpLmJ5dGVzKCk7XG4gICAgX21kLnN0YXJ0KCk7XG4gICAgX21kLnVwZGF0ZShfb3BhZGRpbmcpO1xuICAgIF9tZC51cGRhdGUoaW5uZXIpO1xuICAgIHJldHVybiBfbWQuZGlnZXN0KCk7XG4gIH07XG4gIC8vIGFsaWFzIGZvciBnZXRNYWNcbiAgY3R4LmRpZ2VzdCA9IGN0eC5nZXRNYWM7XG5cbiAgcmV0dXJuIGN0eDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiAoaWdub3JlZCkgKi9cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDUgIFRvbSBXdVxuLy8gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscy5cblxuLy8gQmFzaWMgSmF2YVNjcmlwdCBCTiBsaWJyYXJ5IC0gc3Vic2V0IHVzZWZ1bCBmb3IgUlNBIGVuY3J5cHRpb24uXG5cbi8qXG5MaWNlbnNpbmcgKExJQ0VOU0UpXG4tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblRoaXMgc29mdHdhcmUgaXMgY292ZXJlZCB1bmRlciB0aGUgZm9sbG93aW5nIGNvcHlyaWdodDpcbiovXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDAzLTIwMDUgIFRvbSBXdVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUy1JU1wiIEFORCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUywgSU1QTElFRCBPUiBPVEhFUldJU0UsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04sIEFOWVxuICogV0FSUkFOVFkgT0YgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLlxuICpcbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRPTSBXVSBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBJTkNJREVOVEFMLFxuICogSU5ESVJFQ1QgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9GIEFOWSBLSU5ELCBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSXG4gKiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIE9SIE5PVCBBRFZJU0VEIE9GXG4gKiBUSEUgUE9TU0lCSUxJVFkgT0YgREFNQUdFLCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIEFSSVNJTkcgT1VUXG4gKiBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqIEluIGFkZGl0aW9uLCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiBhcHBsaWVzOlxuICpcbiAqIEFsbCByZWRpc3RyaWJ1dGlvbnMgbXVzdCByZXRhaW4gYW4gaW50YWN0IGNvcHkgb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlXG4gKiBhbmQgZGlzY2xhaW1lci5cbiAqL1xuLypcbkFkZHJlc3MgYWxsIHF1ZXN0aW9ucyByZWdhcmRpbmcgdGhpcyBsaWNlbnNlIHRvOlxuXG4gIFRvbSBXdVxuICB0andAY3MuU3RhbmZvcmQuRURVXG4qL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5qc2JuID0gZm9yZ2UuanNibiB8fCB7fTtcblxuLy8gQml0cyBwZXIgZGlnaXRcbnZhciBkYml0cztcblxuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkmMHhmZmZmZmYpPT0weGVmY2FmZSk7XG5cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG5mdW5jdGlvbiBCaWdJbnRlZ2VyKGEsYixjKSB7XG4gIHRoaXMuZGF0YSA9IFtdO1xuICBpZihhICE9IG51bGwpXG4gICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICBlbHNlIGlmKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwyNTYpO1xuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYik7XG59XG5mb3JnZS5qc2JuLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuXG4vLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG5mdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxuXG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuXG4vLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4vLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKSB7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIHYgPSB4KnRoaXMuZGF0YVtpKytdK3cuZGF0YVtqXStjO1xuICAgIGMgPSBNYXRoLmZsb29yKHYvMHg0MDAwMDAwKTtcbiAgICB3LmRhdGFbaisrXSA9IHYmMHgzZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHg3ZmZmLCB4aCA9IHg+PjE1O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4N2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNTtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHg3ZmZmKTw8MTUpK3cuZGF0YVtqXSsoYyYweDNmZmZmZmZmKTtcbiAgICBjID0gKGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHgzZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4M2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNDtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHgzZmZmKTw8MTQpK3cuZGF0YVtqXStjO1xuICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHhmZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBub2RlLmpzIChubyBicm93c2VyKVxuaWYodHlwZW9mKG5hdmlnYXRvcikgPT09ICd1bmRlZmluZWQnKVxue1xuICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICBkYml0cyA9IDI4O1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICBkYml0cyA9IDMwO1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gIGRiaXRzID0gMjY7XG59IGVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gIGRiaXRzID0gMjg7XG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMTw8ZGJpdHMpLTEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMTw8ZGJpdHMpO1xuXG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMixCSV9GUCk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQLWRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyKmRiaXRzLUJJX0ZQO1xuXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbnZhciBCSV9SQyA9IG5ldyBBcnJheSgpO1xudmFyIHJyLHZ2O1xucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xucnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5cbmZ1bmN0aW9uIGludDJjaGFyKG4pIHsgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTsgfVxuZnVuY3Rpb24gaW50QXQocyxpKSB7XG4gIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgcmV0dXJuIChjPT1udWxsKT8tMTpjO1xufVxuXG4vLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gIHIudCA9IHRoaXMudDtcbiAgci5zID0gdGhpcy5zO1xufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbmZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICB0aGlzLnQgPSAxO1xuICB0aGlzLnMgPSAoeDwwKT8tMTowO1xuICBpZih4ID4gMCkgdGhpcy5kYXRhWzBdID0geDtcbiAgZWxzZSBpZih4IDwgLTEpIHRoaXMuZGF0YVswXSA9IHgrdGhpcy5EVjtcbiAgZWxzZSB0aGlzLnQgPSAwO1xufVxuXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkgeyB2YXIgciA9IG5iaSgpOyByLmZyb21JbnQoaSk7IHJldHVybiByOyB9XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbmZ1bmN0aW9uIGJucEZyb21TdHJpbmcocyxiKSB7XG4gIHZhciBrO1xuICBpZihiID09IDE2KSBrID0gNDtcbiAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICBlbHNlIGlmKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgZWxzZSB7IHRoaXMuZnJvbVJhZGl4KHMsYik7IHJldHVybjsgfVxuICB0aGlzLnQgPSAwO1xuICB0aGlzLnMgPSAwO1xuICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgdmFyIHggPSAoaz09OCk/c1tpXSYweGZmOmludEF0KHMsaSk7XG4gICAgaWYoeCA8IDApIHtcbiAgICAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbWkgPSBmYWxzZTtcbiAgICBpZihzaCA9PSAwKVxuICAgICAgdGhpcy5kYXRhW3RoaXMudCsrXSA9IHg7XG4gICAgZWxzZSBpZihzaCtrID4gdGhpcy5EQikge1xuICAgICAgdGhpcy5kYXRhW3RoaXMudC0xXSB8PSAoeCYoKDE8PCh0aGlzLkRCLXNoKSktMSkpPDxzaDtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAoeD4+KHRoaXMuREItc2gpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQtMV0gfD0geDw8c2g7XG4gICAgc2ggKz0gaztcbiAgICBpZihzaCA+PSB0aGlzLkRCKSBzaCAtPSB0aGlzLkRCO1xuICB9XG4gIGlmKGsgPT0gOCAmJiAoc1swXSYweDgwKSAhPSAwKSB7XG4gICAgdGhpcy5zID0gLTE7XG4gICAgaWYoc2ggPiAwKSB0aGlzLmRhdGFbdGhpcy50LTFdIHw9ICgoMTw8KHRoaXMuREItc2gpKS0xKTw8c2g7XG4gIH1cbiAgdGhpcy5jbGFtcCgpO1xuICBpZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gIHZhciBjID0gdGhpcy5zJnRoaXMuRE07XG4gIHdoaWxlKHRoaXMudCA+IDAgJiYgdGhpcy5kYXRhW3RoaXMudC0xXSA9PSBjKSAtLXRoaXMudDtcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIGlmKHRoaXMucyA8IDApIHJldHVybiBcIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgdmFyIGttID0gKDE8PGspLTEsIGQsIG0gPSBmYWxzZSwgciA9IFwiXCIsIGkgPSB0aGlzLnQ7XG4gIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSVrO1xuICBpZihpLS0gPiAwKSB7XG4gICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzLmRhdGFbaV0+PnApID4gMCkgeyBtID0gdHJ1ZTsgciA9IGludDJjaGFyKGQpOyB9XG4gICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICBpZihwIDwgaykge1xuICAgICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KGstcCk7XG4gICAgICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLWspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT1rKSkma207XG4gICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgfVxuICAgICAgaWYoZCA+IDApIG0gPSB0cnVlO1xuICAgICAgaWYobSkgciArPSBpbnQyY2hhcihkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0/cjpcIjBcIjtcbn1cblxuLy8gKHB1YmxpYykgLXRoaXNcbmZ1bmN0aW9uIGJuTmVnYXRlKCkgeyB2YXIgciA9IG5iaSgpOyBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyxyKTsgcmV0dXJuIHI7IH1cblxuLy8gKHB1YmxpYykgfHRoaXN8XG5mdW5jdGlvbiBibkFicygpIHsgcmV0dXJuICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzOyB9XG5cbi8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG5mdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gIHZhciByID0gdGhpcy5zLWEucztcbiAgaWYociAhPSAwKSByZXR1cm4gcjtcbiAgdmFyIGkgPSB0aGlzLnQ7XG4gIHIgPSBpLWEudDtcbiAgaWYociAhPSAwKSByZXR1cm4gKHRoaXMuczwwKT8tcjpyO1xuICB3aGlsZSgtLWkgPj0gMCkgaWYoKHI9dGhpcy5kYXRhW2ldLWEuZGF0YVtpXSkgIT0gMCkgcmV0dXJuIHI7XG4gIHJldHVybiAwO1xufVxuXG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICB2YXIgciA9IDEsIHQ7XG4gIGlmKCh0PXg+Pj4xNikgIT0gMCkgeyB4ID0gdDsgciArPSAxNjsgfVxuICBpZigodD14Pj44KSAhPSAwKSB7IHggPSB0OyByICs9IDg7IH1cbiAgaWYoKHQ9eD4+NCkgIT0gMCkgeyB4ID0gdDsgciArPSA0OyB9XG4gIGlmKCh0PXg+PjIpICE9IDApIHsgeCA9IHQ7IHIgKz0gMjsgfVxuICBpZigodD14Pj4xKSAhPSAwKSB7IHggPSB0OyByICs9IDE7IH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbmZ1bmN0aW9uIGJuQml0TGVuZ3RoKCkge1xuICBpZih0aGlzLnQgPD0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpcy5kYXRhW3RoaXMudC0xXV4odGhpcy5zJnRoaXMuRE0pKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4scikge1xuICB2YXIgaTtcbiAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpK25dID0gdGhpcy5kYXRhW2ldO1xuICBmb3IoaSA9IG4tMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpXSA9IDA7XG4gIHIudCA9IHRoaXMudCtuO1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbmZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpIHtcbiAgZm9yKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaS1uXSA9IHRoaXMuZGF0YVtpXTtcbiAgci50ID0gTWF0aC5tYXgodGhpcy50LW4sMCk7XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuZnVuY3Rpb24gYm5wTFNoaWZ0VG8obixyKSB7XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxjYnMpLTE7XG4gIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKSwgYyA9ICh0aGlzLnM8PGJzKSZ0aGlzLkRNLCBpO1xuICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkge1xuICAgIHIuZGF0YVtpK2RzKzFdID0gKHRoaXMuZGF0YVtpXT4+Y2JzKXxjO1xuICAgIGMgPSAodGhpcy5kYXRhW2ldJmJtKTw8YnM7XG4gIH1cbiAgZm9yKGkgPSBkcy0xOyBpID49IDA7IC0taSkgci5kYXRhW2ldID0gMDtcbiAgci5kYXRhW2RzXSA9IGM7XG4gIHIudCA9IHRoaXMudCtkcysxO1xuICByLnMgPSB0aGlzLnM7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKSB7XG4gIHIucyA9IHRoaXMucztcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICBpZihkcyA+PSB0aGlzLnQpIHsgci50ID0gMDsgcmV0dXJuOyB9XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxicyktMTtcbiAgci5kYXRhWzBdID0gdGhpcy5kYXRhW2RzXT4+YnM7XG4gIGZvcih2YXIgaSA9IGRzKzE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgIHIuZGF0YVtpLWRzLTFdIHw9ICh0aGlzLmRhdGFbaV0mYm0pPDxjYnM7XG4gICAgci5kYXRhW2ktZHNdID0gdGhpcy5kYXRhW2ldPj5icztcbiAgfVxuICBpZihicyA+IDApIHIuZGF0YVt0aGlzLnQtZHMtMV0gfD0gKHRoaXMucyZibSk8PGNicztcbiAgci50ID0gdGhpcy50LWRzO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5wU3ViVG8oYSxyKSB7XG4gIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgd2hpbGUoaSA8IG0pIHtcbiAgICBjICs9IHRoaXMuZGF0YVtpXS1hLmRhdGFbaV07XG4gICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICAgYyA+Pj0gdGhpcy5EQjtcbiAgfVxuICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICBjIC09IGEucztcbiAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyArPSB0aGlzLnM7XG4gIH0gZWxzZSB7XG4gICAgYyArPSB0aGlzLnM7XG4gICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgYyAtPSBhLmRhdGFbaV07XG4gICAgICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgfVxuICAgIGMgLT0gYS5zO1xuICB9XG4gIHIucyA9IChjPDApPy0xOjA7XG4gIGlmKGMgPCAtMSkgci5kYXRhW2krK10gPSB0aGlzLkRWK2M7XG4gIGVsc2UgaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbiAgci50ID0gaTtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVRvKGEscikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICB2YXIgaSA9IHgudDtcbiAgci50ID0gaSt5LnQ7XG4gIHdoaWxlKC0taSA+PSAwKSByLmRhdGFbaV0gPSAwO1xuICBmb3IoaSA9IDA7IGkgPCB5LnQ7ICsraSkgci5kYXRhW2kreC50XSA9IHguYW0oMCx5LmRhdGFbaV0scixpLDAseC50KTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xuICBpZih0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG5mdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgdmFyIGkgPSByLnQgPSAyKngudDtcbiAgd2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG4gIGZvcihpID0gMDsgaSA8IHgudC0xOyArK2kpIHtcbiAgICB2YXIgYyA9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgICBpZigoci5kYXRhW2kreC50XSs9eC5hbShpKzEsMip4LmRhdGFbaV0sciwyKmkrMSxjLHgudC1pLTEpKSA+PSB4LkRWKSB7XG4gICAgICByLmRhdGFbaSt4LnRdIC09IHguRFY7XG4gICAgICByLmRhdGFbaSt4LnQrMV0gPSAxO1xuICAgIH1cbiAgfVxuICBpZihyLnQgPiAwKSByLmRhdGFbci50LTFdICs9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpIHtcbiAgdmFyIHBtID0gbS5hYnMoKTtcbiAgaWYocG0udCA8PSAwKSByZXR1cm47XG4gIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgaWYocSAhPSBudWxsKSBxLmZyb21JbnQoMCk7XG4gICAgaWYociAhPSBudWxsKSB0aGlzLmNvcHlUbyhyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYociA9PSBudWxsKSByID0gbmJpKCk7XG4gIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgdmFyIG5zaCA9IHRoaXMuREItbmJpdHMocG0uZGF0YVtwbS50LTFdKTtcdC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gIGlmKG5zaCA+IDApIHsgcG0ubFNoaWZ0VG8obnNoLHkpOyBwdC5sU2hpZnRUbyhuc2gscik7IH0gZWxzZSB7IHBtLmNvcHlUbyh5KTsgcHQuY29weVRvKHIpOyB9XG4gIHZhciB5cyA9IHkudDtcbiAgdmFyIHkwID0geS5kYXRhW3lzLTFdO1xuICBpZih5MCA9PSAwKSByZXR1cm47XG4gIHZhciB5dCA9IHkwKigxPDx0aGlzLkYxKSsoKHlzPjEpP3kuZGF0YVt5cy0yXT4+dGhpcy5GMjowKTtcbiAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICB2YXIgaSA9IHIudCwgaiA9IGkteXMsIHQgPSAocT09bnVsbCk/bmJpKCk6cTtcbiAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHIuZGF0YVtyLnQrK10gPSAxO1xuICAgIHIuc3ViVG8odCxyKTtcbiAgfVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsdCk7XG4gIHQuc3ViVG8oeSx5KTtcdC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlKHkudCA8IHlzKSB5LmRhdGFbeS50KytdID0gMDtcbiAgd2hpbGUoLS1qID49IDApIHtcbiAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgIHZhciBxZCA9IChyLmRhdGFbLS1pXT09eTApP3RoaXMuRE06TWF0aC5mbG9vcihyLmRhdGFbaV0qZDErKHIuZGF0YVtpLTFdK2UpKmQyKTtcbiAgICBpZigoci5kYXRhW2ldKz15LmFtKDAscWQscixqLDAseXMpKSA8IHFkKSB7XHQvLyBUcnkgaXQgb3V0XG4gICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgci5zdWJUbyh0LHIpO1xuICAgICAgd2hpbGUoci5kYXRhW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgIH1cbiAgfVxuICBpZihxICE9IG51bGwpIHtcbiAgICByLmRyU2hpZnRUbyh5cyxxKTtcbiAgICBpZih0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSk7XG4gIH1cbiAgci50ID0geXM7XG4gIHIuY2xhbXAoKTtcbiAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7XHQvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5iaSgpO1xuICB0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtcbiAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG5mdW5jdGlvbiBDbGFzc2ljKG0pIHsgdGhpcy5tID0gbTsgfVxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gIGVsc2UgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkgeyB4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpOyB9XG5mdW5jdGlvbiBjTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5mdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbkNsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG5DbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmKHRoaXMudCA8IDEpIHJldHVybiAwO1xuICB2YXIgeCA9IHRoaXMuZGF0YVswXTtcbiAgaWYoKHgmMSkgPT0gMCkgcmV0dXJuIDA7XG4gIHZhciB5ID0geCYzO1x0XHQvLyB5ID09IDEveCBtb2QgMl4yXG4gIHkgPSAoeSooMi0oeCYweGYpKnkpKSYweGY7XHQvLyB5ID09IDEveCBtb2QgMl40XG4gIHkgPSAoeSooMi0oeCYweGZmKSp5KSkmMHhmZjtcdC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgeSA9ICh5KigyLSgoKHgmMHhmZmZmKSp5KSYweGZmZmYpKSkmMHhmZmZmO1x0Ly8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5KigyLXgqeSV0aGlzLkRWKSkldGhpcy5EVjtcdFx0Ly8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5PjApP3RoaXMuRFYteToteTtcbn1cblxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbmZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICB0aGlzLm0gPSBtO1xuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICB0aGlzLm1wbCA9IHRoaXMubXAmMHg3ZmZmO1xuICB0aGlzLm1waCA9IHRoaXMubXA+PjE1O1xuICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgdGhpcy5tdDIgPSAyKm0udDtcbn1cblxuLy8geFIgbW9kIG1cbmZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gIHIuZGl2UmVtVG8odGhpcy5tLG51bGwscik7XG4gIGlmKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5jb3B5VG8ocik7XG4gIHRoaXMucmVkdWNlKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gIHdoaWxlKHgudCA8PSB0aGlzLm10MilcdC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgIHguZGF0YVt4LnQrK10gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4LmRhdGFbaV0qbXAgbW9kIERWXG4gICAgdmFyIGogPSB4LmRhdGFbaV0mMHg3ZmZmO1xuICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHguZGF0YVtpXT4+MTUpKnRoaXMubXBsKSZ0aGlzLnVtKTw8MTUpKSZ4LkRNO1xuICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgIGogPSBpK3RoaXMubS50O1xuICAgIHguZGF0YVtqXSArPSB0aGlzLm0uYW0oMCx1MCx4LGksMCx0aGlzLm0udCk7XG4gICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgd2hpbGUoeC5kYXRhW2pdID49IHguRFYpIHsgeC5kYXRhW2pdIC09IHguRFY7IHguZGF0YVsrK2pdKys7IH1cbiAgfVxuICB4LmNsYW1wKCk7XG4gIHguZHJTaGlmdFRvKHRoaXMubS50LHgpO1xuICBpZih4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xufVxuXG4vLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbmZ1bmN0aW9uIG1vbnRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuZnVuY3Rpb24gbW9udE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnQ7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbk1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xuTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuZnVuY3Rpb24gYm5wSXNFdmVuKCkgeyByZXR1cm4gKCh0aGlzLnQ+MCk/KHRoaXMuZGF0YVswXSYxKTp0aGlzLnMpID09IDA7IH1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUseikge1xuICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICB2YXIgciA9IG5iaSgpLCByMiA9IG5iaSgpLCBnID0gei5jb252ZXJ0KHRoaXMpLCBpID0gbmJpdHMoZSktMTtcbiAgZy5jb3B5VG8ocik7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLHIyKTtcbiAgICBpZigoZSYoMTw8aSkpID4gMCkgei5tdWxUbyhyMixnLHIpO1xuICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLG0pIHtcbiAgdmFyIHo7XG4gIGlmKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pOyBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgcmV0dXJuIHRoaXMuZXhwKGUseik7XG59XG5cbi8vIHByb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcblxuLy8gcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBqc2JuMiBsaWJcblxuLy9Db3B5cmlnaHQgKGMpIDIwMDUtMjAwOSAgVG9tIFd1XG4vL0FsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1NlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscyAoU2VlIGpzYm4uanMgZm9yIExJQ0VOU0UpLlxuXG4vL0V4dGVuZGVkIEphdmFTY3JpcHQgQk4gZnVuY3Rpb25zLCByZXF1aXJlZCBmb3IgUlNBIHByaXZhdGUgb3BzLlxuXG4vL1ZlcnNpb24gMS4xOiBuZXcgQmlnSW50ZWdlcihcIjBcIiwgMTApIHJldHVybnMgXCJwcm9wZXJcIiB6ZXJvXG5cbi8vKHB1YmxpYylcbmZ1bmN0aW9uIGJuQ2xvbmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuY29weVRvKHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG5mdW5jdGlvbiBibkludFZhbHVlKCkge1xuaWYodGhpcy5zIDwgMCkge1xuIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdLXRoaXMuRFY7XG4gZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIC0xO1xufSBlbHNlIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdO1xuZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIDA7XG4vLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxucmV0dXJuICgodGhpcy5kYXRhWzFdJigoMTw8KDMyLXRoaXMuREIpKS0xKSk8PHRoaXMuREIpfHRoaXMuZGF0YVswXTtcbn1cblxuLy8ocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MjQpPj4yNDsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG5mdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MTYpPj4xNjsgfVxuXG4vLyhwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbmZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpOyB9XG5cbi8vKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbmZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuaWYodGhpcy5zIDwgMCkgcmV0dXJuIC0xO1xuZWxzZSBpZih0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpcy5kYXRhWzBdIDw9IDApKSByZXR1cm4gMDtcbmVsc2UgcmV0dXJuIDE7XG59XG5cbi8vKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuaWYoYiA9PSBudWxsKSBiID0gMTA7XG5pZih0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSByZXR1cm4gXCIwXCI7XG52YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbnZhciBhID0gTWF0aC5wb3coYixjcyk7XG52YXIgZCA9IG5idihhKSwgeSA9IG5iaSgpLCB6ID0gbmJpKCksIHIgPSBcIlwiO1xudGhpcy5kaXZSZW1UbyhkLHkseik7XG53aGlsZSh5LnNpZ251bSgpID4gMCkge1xuIHIgPSAoYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4geS5kaXZSZW1UbyhkLHkseik7XG59XG5yZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbn1cblxuLy8ocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBGcm9tUmFkaXgocyxiKSB7XG50aGlzLmZyb21JbnQoMCk7XG5pZihiID09IG51bGwpIGIgPSAxMDtcbnZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xudmFyIGQgPSBNYXRoLnBvdyhiLGNzKSwgbWkgPSBmYWxzZSwgaiA9IDAsIHcgPSAwO1xuZm9yKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiB2YXIgeCA9IGludEF0KHMsaSk7XG4gaWYoeCA8IDApIHtcbiAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHRoaXMuc2lnbnVtKCkgPT0gMCkgbWkgPSB0cnVlO1xuICAgY29udGludWU7XG4gfVxuIHcgPSBiKncreDtcbiBpZigrK2ogPj0gY3MpIHtcbiAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG4gICBqID0gMDtcbiAgIHcgPSAwO1xuIH1cbn1cbmlmKGogPiAwKSB7XG4gdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7XG4gdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG59XG5pZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsYixjKSB7XG5pZihcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gaWYoYSA8IDIpIHRoaXMuZnJvbUludCgxKTtcbiBlbHNlIHtcbiAgIHRoaXMuZnJvbU51bWJlcihhLGMpO1xuICAgaWYoIXRoaXMudGVzdEJpdChhLTEpKSAgLy8gZm9yY2UgTVNCIHNldFxuICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxvcF9vcix0aGlzKTtcbiAgIGlmKHRoaXMuaXNFdmVuKCkpIHRoaXMuZEFkZE9mZnNldCgxLDApOyAvLyBmb3JjZSBvZGRcbiAgIHdoaWxlKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICB0aGlzLmRBZGRPZmZzZXQoMiwwKTtcbiAgICAgaWYodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksdGhpcyk7XG4gICB9XG4gfVxufSBlbHNlIHtcbiAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuIHZhciB4ID0gbmV3IEFycmF5KCksIHQgPSBhJjc7XG4geC5sZW5ndGggPSAoYT4+MykrMTtcbiBiLm5leHRCeXRlcyh4KTtcbiBpZih0ID4gMCkgeFswXSAmPSAoKDE8PHQpLTEpOyBlbHNlIHhbMF0gPSAwO1xuIHRoaXMuZnJvbVN0cmluZyh4LDI1Nik7XG59XG59XG5cbi8vKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbnZhciBpID0gdGhpcy50LCByID0gbmV3IEFycmF5KCk7XG5yWzBdID0gdGhpcy5zO1xudmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJTgsIGQsIGsgPSAwO1xuaWYoaS0tID4gMCkge1xuIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldPj5wKSAhPSAodGhpcy5zJnRoaXMuRE0pPj5wKVxuICAgcltrKytdID0gZHwodGhpcy5zPDwodGhpcy5EQi1wKSk7XG4gd2hpbGUoaSA+PSAwKSB7XG4gICBpZihwIDwgOCkge1xuICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KDgtcCk7XG4gICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLTgpO1xuICAgfSBlbHNlIHtcbiAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT04KSkmMHhmZjtcbiAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICB9XG4gICBpZigoZCYweDgwKSAhPSAwKSBkIHw9IC0yNTY7XG4gICBpZihrID09IDAgJiYgKHRoaXMucyYweDgwKSAhPSAoZCYweDgwKSkgKytrO1xuICAgaWYoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHJbaysrXSA9IGQ7XG4gfVxufVxucmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJuRXF1YWxzKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPT0wKTsgfVxuZnVuY3Rpb24gYm5NaW4oYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk8MCk/dGhpczphOyB9XG5mdW5jdGlvbiBibk1heChhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT4wKT90aGlzOmE7IH1cblxuLy8ocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsb3Ascikge1xudmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbmZvcihpID0gMDsgaSA8IG07ICsraSkgci5kYXRhW2ldID0gb3AodGhpcy5kYXRhW2ldLGEuZGF0YVtpXSk7XG5pZihhLnQgPCB0aGlzLnQpIHtcbiBmID0gYS5zJnRoaXMuRE07XG4gZm9yKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHIuZGF0YVtpXSA9IG9wKHRoaXMuZGF0YVtpXSxmKTtcbiByLnQgPSB0aGlzLnQ7XG59IGVsc2Uge1xuIGYgPSB0aGlzLnMmdGhpcy5ETTtcbiBmb3IoaSA9IG07IGkgPCBhLnQ7ICsraSkgci5kYXRhW2ldID0gb3AoZixhLmRhdGFbaV0pO1xuIHIudCA9IGEudDtcbn1cbnIucyA9IG9wKHRoaXMucyxhLnMpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCx5KSB7IHJldHVybiB4Jnk7IH1cbmZ1bmN0aW9uIGJuQW5kKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmQscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyB8IGFcbmZ1bmN0aW9uIG9wX29yKHgseSkgeyByZXR1cm4geHx5OyB9XG5mdW5jdGlvbiBibk9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgseSkgeyByZXR1cm4geF55OyB9XG5mdW5jdGlvbiBiblhvcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfeG9yLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgseSkgeyByZXR1cm4geCZ+eTsgfVxuZnVuY3Rpb24gYm5BbmROb3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZG5vdCxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB+dGhpc1xuZnVuY3Rpb24gYm5Ob3QoKSB7XG52YXIgciA9IG5iaSgpO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaV0gPSB0aGlzLkRNJn50aGlzLmRhdGFbaV07XG5yLnQgPSB0aGlzLnQ7XG5yLnMgPSB+dGhpcy5zO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA8PCBuXG5mdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG52YXIgciA9IG5iaSgpO1xuaWYobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5sU2hpZnRUbyhuLHIpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA+PiBuXG5mdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xudmFyIHIgPSBuYmkoKTtcbmlmKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtcbnJldHVybiByO1xufVxuXG4vL3JldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuaWYoeCA9PSAwKSByZXR1cm4gLTE7XG52YXIgciA9IDA7XG5pZigoeCYweGZmZmYpID09IDApIHsgeCA+Pj0gMTY7IHIgKz0gMTY7IH1cbmlmKCh4JjB4ZmYpID09IDApIHsgeCA+Pj0gODsgciArPSA4OyB9XG5pZigoeCYweGYpID09IDApIHsgeCA+Pj0gNDsgciArPSA0OyB9XG5pZigoeCYzKSA9PSAwKSB7IHggPj49IDI7IHIgKz0gMjsgfVxuaWYoKHgmMSkgPT0gMCkgKytyO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG5mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbmZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiBpZih0aGlzLmRhdGFbaV0gIT0gMCkgcmV0dXJuIGkqdGhpcy5EQitsYml0KHRoaXMuZGF0YVtpXSk7XG5pZih0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50KnRoaXMuREI7XG5yZXR1cm4gLTE7XG59XG5cbi8vcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG52YXIgciA9IDA7XG53aGlsZSh4ICE9IDApIHsgeCAmPSB4LTE7ICsrcjsgfVxucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuZnVuY3Rpb24gYm5CaXRDb3VudCgpIHtcbnZhciByID0gMCwgeCA9IHRoaXMucyZ0aGlzLkRNO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpcy5kYXRhW2ldXngpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbmZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG52YXIgaiA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbmlmKGogPj0gdGhpcy50KSByZXR1cm4odGhpcy5zIT0wKTtcbnJldHVybigodGhpcy5kYXRhW2pdJigxPDwobiV0aGlzLkRCKSkpIT0wKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sb3ApIHtcbnZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xudGhpcy5iaXR3aXNlVG8ocixvcCxyKTtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgfCAoMTw8bilcbmZ1bmN0aW9uIGJuU2V0Qml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbmZ1bmN0aW9uIGJuQ2xlYXJCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuZnVuY3Rpb24gYm5GbGlwQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKTsgfVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuZnVuY3Rpb24gYm5wQWRkVG8oYSxyKSB7XG52YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG53aGlsZShpIDwgbSkge1xuIGMgKz0gdGhpcy5kYXRhW2ldK2EuZGF0YVtpXTtcbiByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiBjID4+PSB0aGlzLkRCO1xufVxuaWYoYS50IDwgdGhpcy50KSB7XG4gYyArPSBhLnM7XG4gd2hpbGUoaSA8IHRoaXMudCkge1xuICAgYyArPSB0aGlzLmRhdGFbaV07XG4gICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgIGMgPj49IHRoaXMuREI7XG4gfVxuIGMgKz0gdGhpcy5zO1xufSBlbHNlIHtcbiBjICs9IHRoaXMucztcbiB3aGlsZShpIDwgYS50KSB7XG4gICBjICs9IGEuZGF0YVtpXTtcbiAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgYyA+Pj0gdGhpcy5EQjtcbiB9XG4gYyArPSBhLnM7XG59XG5yLnMgPSAoYzwwKT8tMTowO1xuaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbmVsc2UgaWYoYyA8IC0xKSByLmRhdGFbaSsrXSA9IHRoaXMuRFYrYztcbnIudCA9IGk7XG5yLmNsYW1wKCk7XG59XG5cbi8vKHB1YmxpYykgdGhpcyArIGFcbmZ1bmN0aW9uIGJuQWRkKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5hZGRUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgLSBhXG5mdW5jdGlvbiBiblN1YnRyYWN0KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5zdWJUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgKiBhXG5mdW5jdGlvbiBibk11bHRpcGx5KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5tdWx0aXBseVRvKGEscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAvIGFcbmZ1bmN0aW9uIGJuRGl2aWRlKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAlIGFcbmZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLG51bGwscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG5mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG52YXIgcSA9IG5iaSgpLCByID0gbmJpKCk7XG50aGlzLmRpdlJlbVRvKGEscSxyKTtcbnJldHVybiBuZXcgQXJyYXkocSxyKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pIHtcbnRoaXMuZGF0YVt0aGlzLnRdID0gdGhpcy5hbSgwLG4tMSx0aGlzLDAsMCx0aGlzLnQpO1xuKyt0aGlzLnQ7XG50aGlzLmNsYW1wKCk7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpIHtcbmlmKG4gPT0gMCkgcmV0dXJuO1xud2hpbGUodGhpcy50IDw9IHcpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xudGhpcy5kYXRhW3ddICs9IG47XG53aGlsZSh0aGlzLmRhdGFbd10gPj0gdGhpcy5EVikge1xuIHRoaXMuZGF0YVt3XSAtPSB0aGlzLkRWO1xuIGlmKCsrdyA+PSB0aGlzLnQpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xuICsrdGhpcy5kYXRhW3ddO1xufVxufVxuXG4vL0EgXCJudWxsXCIgcmVkdWNlclxuZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG5mdW5jdGlvbiBuTm9wKHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIG5NdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgfVxuZnVuY3Rpb24gblNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB9XG5cbk51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbk51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvO1xuTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lXG5mdW5jdGlvbiBiblBvdyhlKSB7IHJldHVybiB0aGlzLmV4cChlLG5ldyBOdWxsRXhwKCkpOyB9XG5cbi8vKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSxuLHIpIHtcbnZhciBpID0gTWF0aC5taW4odGhpcy50K2EudCxuKTtcbnIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbnIudCA9IGk7XG53aGlsZShpID4gMCkgci5kYXRhWy0taV0gPSAwO1xudmFyIGo7XG5mb3IoaiA9IHIudC10aGlzLnQ7IGkgPCBqOyArK2kpIHIuZGF0YVtpK3RoaXMudF0gPSB0aGlzLmFtKDAsYS5kYXRhW2ldLHIsaSwwLHRoaXMudCk7XG5mb3IoaiA9IE1hdGgubWluKGEudCxuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLGEuZGF0YVtpXSxyLGksMCxuLWkpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSxuLHIpIHtcbi0tbjtcbnZhciBpID0gci50ID0gdGhpcy50K2EudC1uO1xuci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxud2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG5mb3IoaSA9IE1hdGgubWF4KG4tdGhpcy50LDApOyBpIDwgYS50OyArK2kpXG4gci5kYXRhW3RoaXMudCtpLW5dID0gdGhpcy5hbShuLWksYS5kYXRhW2ldLHIsMCwwLHRoaXMudCtpLW4pO1xuci5jbGFtcCgpO1xuci5kclNoaWZ0VG8oMSxyKTtcbn1cblxuLy9CYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG5mdW5jdGlvbiBCYXJyZXR0KG0pIHtcbi8vIHNldHVwIEJhcnJldHRcbnRoaXMucjIgPSBuYmkoKTtcbnRoaXMucTMgPSBuYmkoKTtcbkJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTtcbnRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbnRoaXMubSA9IG07XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbmlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG5lbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbmVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuXG4vL3ggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbnguZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7XG5pZih4LnQgPiB0aGlzLm0udCsxKSB7IHgudCA9IHRoaXMubS50KzE7IHguY2xhbXAoKTsgfVxudGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpO1xudGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7XG53aGlsZSh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO1xueC5zdWJUbyh0aGlzLnIyLHgpO1xud2hpbGUoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbn1cblxuLy9yID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy9yID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuZnVuY3Rpb24gYm5Nb2RQb3coZSxtKSB7XG52YXIgaSA9IGUuYml0TGVuZ3RoKCksIGssIHIgPSBuYnYoMSksIHo7XG5pZihpIDw9IDApIHJldHVybiByO1xuZWxzZSBpZihpIDwgMTgpIGsgPSAxO1xuZWxzZSBpZihpIDwgNDgpIGsgPSAzO1xuZWxzZSBpZihpIDwgMTQ0KSBrID0gNDtcbmVsc2UgaWYoaSA8IDc2OCkgayA9IDU7XG5lbHNlIGsgPSA2O1xuaWYoaSA8IDgpXG4geiA9IG5ldyBDbGFzc2ljKG0pO1xuZWxzZSBpZihtLmlzRXZlbigpKVxuIHogPSBuZXcgQmFycmV0dChtKTtcbmVsc2VcbiB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG5cbi8vIHByZWNvbXB1dGF0aW9uXG52YXIgZyA9IG5ldyBBcnJheSgpLCBuID0gMywgazEgPSBrLTEsIGttID0gKDE8PGspLTE7XG5nWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuaWYoayA+IDEpIHtcbiB2YXIgZzIgPSBuYmkoKTtcbiB6LnNxclRvKGdbMV0sZzIpO1xuIHdoaWxlKG4gPD0ga20pIHtcbiAgIGdbbl0gPSBuYmkoKTtcbiAgIHoubXVsVG8oZzIsZ1tuLTJdLGdbbl0pO1xuICAgbiArPSAyO1xuIH1cbn1cblxudmFyIGogPSBlLnQtMSwgdywgaXMxID0gdHJ1ZSwgcjIgPSBuYmkoKSwgdDtcbmkgPSBuYml0cyhlLmRhdGFbal0pLTE7XG53aGlsZShqID49IDApIHtcbiBpZihpID49IGsxKSB3ID0gKGUuZGF0YVtqXT4+KGktazEpKSZrbTtcbiBlbHNlIHtcbiAgIHcgPSAoZS5kYXRhW2pdJigoMTw8KGkrMSkpLTEpKTw8KGsxLWkpO1xuICAgaWYoaiA+IDApIHcgfD0gZS5kYXRhW2otMV0+Pih0aGlzLkRCK2ktazEpO1xuIH1cblxuIG4gPSBrO1xuIHdoaWxlKCh3JjEpID09IDApIHsgdyA+Pj0gMTsgLS1uOyB9XG4gaWYoKGkgLT0gbikgPCAwKSB7IGkgKz0gdGhpcy5EQjsgLS1qOyB9XG4gaWYoaXMxKSB7ICAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICBnW3ddLmNvcHlUbyhyKTtcbiAgIGlzMSA9IGZhbHNlO1xuIH0gZWxzZSB7XG4gICB3aGlsZShuID4gMSkgeyB6LnNxclRvKHIscjIpOyB6LnNxclRvKHIyLHIpOyBuIC09IDI7IH1cbiAgIGlmKG4gPiAwKSB6LnNxclRvKHIscjIpOyBlbHNlIHsgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICB6Lm11bFRvKHIyLGdbd10scik7XG4gfVxuXG4gd2hpbGUoaiA+PSAwICYmIChlLmRhdGFbal0mKDE8PGkpKSA9PSAwKSB7XG4gICB6LnNxclRvKHIscjIpOyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7XG4gICBpZigtLWkgPCAwKSB7IGkgPSB0aGlzLkRCLTE7IC0tajsgfVxuIH1cbn1cbnJldHVybiB6LnJldmVydChyKTtcbn1cblxuLy8ocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuZnVuY3Rpb24gYm5HQ0QoYSkge1xudmFyIHggPSAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpcy5jbG9uZSgpO1xudmFyIHkgPSAoYS5zPDApP2EubmVnYXRlKCk6YS5jbG9uZSgpO1xuaWYoeC5jb21wYXJlVG8oeSkgPCAwKSB7IHZhciB0ID0geDsgeCA9IHk7IHkgPSB0OyB9XG52YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCksIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuaWYoZyA8IDApIHJldHVybiB4O1xuaWYoaSA8IGcpIGcgPSBpO1xuaWYoZyA+IDApIHtcbiB4LnJTaGlmdFRvKGcseCk7XG4geS5yU2hpZnRUbyhnLHkpO1xufVxud2hpbGUoeC5zaWdudW0oKSA+IDApIHtcbiBpZigoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLHgpO1xuIGlmKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGkseSk7XG4gaWYoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgeC5zdWJUbyh5LHgpO1xuICAgeC5yU2hpZnRUbygxLHgpO1xuIH0gZWxzZSB7XG4gICB5LnN1YlRvKHgseSk7XG4gICB5LnJTaGlmdFRvKDEseSk7XG4gfVxufVxuaWYoZyA+IDApIHkubFNoaWZ0VG8oZyx5KTtcbnJldHVybiB5O1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbmlmKG4gPD0gMCkgcmV0dXJuIDA7XG52YXIgZCA9IHRoaXMuRFYlbiwgciA9ICh0aGlzLnM8MCk/bi0xOjA7XG5pZih0aGlzLnQgPiAwKVxuIGlmKGQgPT0gMCkgciA9IHRoaXMuZGF0YVswXSVuO1xuIGVsc2UgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByID0gKGQqcit0aGlzLmRhdGFbaV0pJW47XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG5mdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xudmFyIGFjID0gbS5pc0V2ZW4oKTtcbmlmKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG52YXIgdSA9IG0uY2xvbmUoKSwgdiA9IHRoaXMuY2xvbmUoKTtcbnZhciBhID0gbmJ2KDEpLCBiID0gbmJ2KDApLCBjID0gbmJ2KDApLCBkID0gbmJ2KDEpO1xud2hpbGUodS5zaWdudW0oKSAhPSAwKSB7XG4gd2hpbGUodS5pc0V2ZW4oKSkge1xuICAgdS5yU2hpZnRUbygxLHUpO1xuICAgaWYoYWMpIHtcbiAgICAgaWYoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHsgYS5hZGRUbyh0aGlzLGEpOyBiLnN1YlRvKG0sYik7IH1cbiAgICAgYS5yU2hpZnRUbygxLGEpO1xuICAgfSBlbHNlIGlmKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sYik7XG4gICBiLnJTaGlmdFRvKDEsYik7XG4gfVxuIHdoaWxlKHYuaXNFdmVuKCkpIHtcbiAgIHYuclNoaWZ0VG8oMSx2KTtcbiAgIGlmKGFjKSB7XG4gICAgIGlmKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7IGMuYWRkVG8odGhpcyxjKTsgZC5zdWJUbyhtLGQpOyB9XG4gICAgIGMuclNoaWZ0VG8oMSxjKTtcbiAgIH0gZWxzZSBpZighZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLGQpO1xuICAgZC5yU2hpZnRUbygxLGQpO1xuIH1cbiBpZih1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICB1LnN1YlRvKHYsdSk7XG4gICBpZihhYykgYS5zdWJUbyhjLGEpO1xuICAgYi5zdWJUbyhkLGIpO1xuIH0gZWxzZSB7XG4gICB2LnN1YlRvKHUsdik7XG4gICBpZihhYykgYy5zdWJUbyhhLGMpO1xuICAgZC5zdWJUbyhiLGQpO1xuIH1cbn1cbmlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuaWYoZC5jb21wYXJlVG8obSkgPj0gMCkgcmV0dXJuIGQuc3VidHJhY3QobSk7XG5pZihkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLGQpOyBlbHNlIHJldHVybiBkO1xuaWYoZC5zaWdudW0oKSA8IDApIHJldHVybiBkLmFkZChtKTsgZWxzZSByZXR1cm4gZDtcbn1cblxudmFyIGxvd3ByaW1lcyA9IFsyLDMsNSw3LDExLDEzLDE3LDE5LDIzLDI5LDMxLDM3LDQxLDQzLDQ3LDUzLDU5LDYxLDY3LDcxLDczLDc5LDgzLDg5LDk3LDEwMSwxMDMsMTA3LDEwOSwxMTMsMTI3LDEzMSwxMzcsMTM5LDE0OSwxNTEsMTU3LDE2MywxNjcsMTczLDE3OSwxODEsMTkxLDE5MywxOTcsMTk5LDIxMSwyMjMsMjI3LDIyOSwyMzMsMjM5LDI0MSwyNTEsMjU3LDI2MywyNjksMjcxLDI3NywyODEsMjgzLDI5MywzMDcsMzExLDMxMywzMTcsMzMxLDMzNywzNDcsMzQ5LDM1MywzNTksMzY3LDM3MywzNzksMzgzLDM4OSwzOTcsNDAxLDQwOSw0MTksNDIxLDQzMSw0MzMsNDM5LDQ0Myw0NDksNDU3LDQ2MSw0NjMsNDY3LDQ3OSw0ODcsNDkxLDQ5OSw1MDMsNTA5XTtcbnZhciBscGxpbSA9ICgxPDwyNikvbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV07XG5cbi8vKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG5mdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG52YXIgaSwgeCA9IHRoaXMuYWJzKCk7XG5pZih4LnQgPT0gMSAmJiB4LmRhdGFbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV0pIHtcbiBmb3IoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICBpZih4LmRhdGFbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZTtcbiByZXR1cm4gZmFsc2U7XG59XG5pZih4LmlzRXZlbigpKSByZXR1cm4gZmFsc2U7XG5pID0gMTtcbndoaWxlKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gdmFyIG0gPSBsb3dwcmltZXNbaV0sIGogPSBpKzE7XG4gd2hpbGUoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdO1xuIG0gPSB4Lm1vZEludChtKTtcbiB3aGlsZShpIDwgaikgaWYobSVsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2U7XG59XG5yZXR1cm4geC5taWxsZXJSYWJpbih0KTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xudmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG52YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuaWYoayA8PSAwKSByZXR1cm4gZmFsc2U7XG52YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG52YXIgcHJuZyA9IGJuR2V0UHJuZygpO1xudmFyIGE7XG5mb3IodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gLy8gc2VsZWN0IHdpdG5lc3MgJ2EnIGF0IHJhbmRvbSBmcm9tIGJldHdlZW4gMSBhbmQgbjFcbiBkbyB7XG4gICBhID0gbmV3IEJpZ0ludGVnZXIodGhpcy5iaXRMZW5ndGgoKSwgcHJuZyk7XG4gfVxuIHdoaWxlKGEuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA8PSAwIHx8IGEuY29tcGFyZVRvKG4xKSA+PSAwKTtcbiB2YXIgeSA9IGEubW9kUG93KHIsdGhpcyk7XG4gaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgIHZhciBqID0gMTtcbiAgIHdoaWxlKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgeSA9IHkubW9kUG93SW50KDIsdGhpcyk7XG4gICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBpZih5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlO1xuIH1cbn1cbnJldHVybiB0cnVlO1xufVxuXG4vLyBnZXQgcHNldWRvIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5mdW5jdGlvbiBibkdldFBybmcoKSB7XG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgcmV0dXJuIHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vL3Byb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gYm5wQWRkVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XG5cbi8vcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBiblNpZ051bTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gYm5TZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gYm5BZGQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBibkRpdmlkZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG5cbi8vQmlnSW50ZWdlciBpbnRlcmZhY2VzIG5vdCBpbXBsZW1lbnRlZCBpbiBqc2JuOlxuXG4vL0JpZ0ludGVnZXIoaW50IHNpZ251bSwgYnl0ZVtdIG1hZ25pdHVkZSlcbi8vZG91YmxlIGRvdWJsZVZhbHVlKClcbi8vZmxvYXQgZmxvYXRWYWx1ZSgpXG4vL2ludCBoYXNoQ29kZSgpXG4vL2xvbmcgbG9uZ1ZhbHVlKClcbi8vc3RhdGljIEJpZ0ludGVnZXIgdmFsdWVPZihsb25nIHZhbClcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMTYwLWJpdCBkaWdlc3QgKFNIQS0xKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHNoYTEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnNoYTEgPSBmb3JnZS5zaGExIHx8IHt9O1xuZm9yZ2UubWQuc2hhMSA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMSA9IHNoYTE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNIQS0xIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICovXG5zaGExLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMSBzdGF0ZSBjb250YWlucyBmaXZlIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg4MCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGExJyxcbiAgICBibG9ja0xlbmd0aDogNjQsXG4gICAgZGlnZXN0TGVuZ3RoOiAyMCxcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDY0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGg2NCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9zdGF0ZSA9IHtcbiAgICAgIGgwOiAweDY3NDUyMzAxLFxuICAgICAgaDE6IDB4RUZDREFCODksXG4gICAgICBoMjogMHg5OEJBRENGRSxcbiAgICAgIGgzOiAweDEwMzI1NDc2LFxuICAgICAgaDQ6IDB4QzNEMkUxRjBcbiAgICB9O1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgLy8gc3RhcnQgZGlnZXN0IGF1dG9tYXRpY2FsbHkgZm9yIGZpcnN0IHRpbWVcbiAgbWQuc3RhcnQoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGlnZXN0IHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgaW5wdXQuIFRoZSBnaXZlbiBpbnB1dCBjYW5cbiAgICogdHJlYXRlZCBhcyByYXcgaW5wdXQgKG5vIGVuY29kaW5nIHdpbGwgYmUgYXBwbGllZCkgb3IgYW4gZW5jb2Rpbmcgb2ZcbiAgICogJ3V0ZjgnIG1heWJlIGdpdmVuIHRvIGVuY29kZSB0aGUgaW5wdXQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgdGhlIG1lc3NhZ2UgaW5wdXQgdG8gdXBkYXRlIHdpdGguXG4gICAqIEBwYXJhbSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQudXBkYXRlID0gZnVuY3Rpb24obXNnLCBlbmNvZGluZykge1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIG1zZyA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtZXNzYWdlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgIG1kLm1lc3NhZ2VMZW5ndGggKz0gbGVuO1xuICAgIGxlbiA9IFsobGVuIC8gMHgxMDAwMDAwMDApID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICBsZW5bMV0gPSBsZW5bMF0gKyAoKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPj4+IDA7XG4gICAgICBsZW5bMF0gPSAoKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX3N0YXRlLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgIC8qKlxuICAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICAqXG4gICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgICovXG4gICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTEgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDggYnl0ZXMgKDY0XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSA1NiBieXRlc1xuICAgICg0NDggYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiBiZWNhdXNlXG4gICAgNTEyIC0gMTI4ID0gNDQ4LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiwgdGhlbiA1MTIgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeSBmcm9tIG5leHQgaW50XG4gICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgY2FycnkgPSAobmV4dCAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgYml0cyA9IG5leHQgPj4+IDA7XG4gICAgfVxuICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG5cbiAgICB2YXIgczIgPSB7XG4gICAgICBoMDogX3N0YXRlLmgwLFxuICAgICAgaDE6IF9zdGF0ZS5oMSxcbiAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICBoMzogX3N0YXRlLmgzLFxuICAgICAgaDQ6IF9zdGF0ZS5oNFxuICAgIH07XG4gICAgX3VwZGF0ZShzMiwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgxKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgyKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg0KTtcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtMSBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgNjQpO1xuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBTSEEtMSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gcyB0aGUgU0hBLTEgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQsIGEsIGIsIGMsIGQsIGUsIGYsIGk7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDY0KSB7XG4gICAgLy8gdGhlIHcgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBzaXh0ZWVuIDMyLWJpdCBiaWctZW5kaWFuIHdvcmRzXG4gICAgLy8gYW5kIHRoZW4gZXh0ZW5kZWQgaW50byA4MCAzMi1iaXQgd29yZHMgYWNjb3JkaW5nIHRvIFNIQS0xIGFsZ29yaXRobVxuICAgIC8vIGFuZCBmb3IgMzItNzkgdXNpbmcgTWF4IExvY2t0eXVraGluJ3Mgb3B0aW1pemF0aW9uXG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhID0gcy5oMDtcbiAgICBiID0gcy5oMTtcbiAgICBjID0gcy5oMjtcbiAgICBkID0gcy5oMztcbiAgICBlID0gcy5oNDtcblxuICAgIC8vIHJvdW5kIDFcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB0ID0gYnl0ZXMuZ2V0SW50MzIoKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIGZvcig7IGkgPCAyMDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDNdIF4gd1tpIC0gOF0gXiB3W2kgLSAxNF0gXiB3W2kgLSAxNl0pO1xuICAgICAgdCA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDJcbiAgICBmb3IoOyBpIDwgMzI7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSAzXSBeIHdbaSAtIDhdIF4gd1tpIC0gMTRdIF4gd1tpIC0gMTZdKTtcbiAgICAgIHQgPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NkVEOUVCQTEgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDQwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg2RUQ5RUJBMSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCAzXG4gICAgZm9yKDsgaSA8IDYwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIF4gYykpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDhGMUJCQ0RDICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDRcbiAgICBmb3IoOyBpIDwgODA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweENBNjJDMUQ2ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuXG4gICAgbGVuIC09IDY0O1xuICB9XG59XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgWC41MDkgYW5kIHJlbGF0ZWQgY29tcG9uZW50cyAoc3VjaCBhc1xuICogQ2VydGlmaWNhdGlvbiBTaWduaW5nIFJlcXVlc3RzKSBvZiBhIFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIGNlcnRpZmljYXRlIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDIDI0NTkpOlxuICpcbiAqIENlcnRpZmljYXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHRic0NlcnRpZmljYXRlICAgICAgIFRCU0NlcnRpZmljYXRlLFxuICogICBzaWduYXR1cmVBbGdvcml0aG0gICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBzaWduYXR1cmVWYWx1ZSAgICAgICBCSVQgU1RSSU5HXG4gKiB9XG4gKlxuICogVEJTQ2VydGlmaWNhdGUgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgIFswXSAgRVhQTElDSVQgVmVyc2lvbiBERUZBVUxUIHYxLFxuICogICBzZXJpYWxOdW1iZXIgICAgICAgICBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlcixcbiAqICAgc2lnbmF0dXJlICAgICAgICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgaXNzdWVyICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgdmFsaWRpdHkgICAgICAgICAgICAgVmFsaWRpdHksXG4gKiAgIHN1YmplY3QgICAgICAgICAgICAgIE5hbWUsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXlJbmZvIFN1YmplY3RQdWJsaWNLZXlJbmZvLFxuICogICBpc3N1ZXJVbmlxdWVJRCAgWzFdICBJTVBMSUNJVCBVbmlxdWVJZGVudGlmaWVyIE9QVElPTkFMLFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYyIG9yIHYzXG4gKiAgIHN1YmplY3RVbmlxdWVJRCBbMl0gIElNUExJQ0lUIFVuaXF1ZUlkZW50aWZpZXIgT1BUSU9OQUwsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIC0tIElmIHByZXNlbnQsIHZlcnNpb24gc2hhbGwgYmUgdjIgb3IgdjNcbiAqICAgZXh0ZW5zaW9ucyAgICAgIFszXSAgRVhQTElDSVQgRXh0ZW5zaW9ucyBPUFRJT05BTFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYzXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUiAgeyB2MSgwKSwgdjIoMSksIHYzKDIpIH1cbiAqXG4gKiBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlciA6Oj0gSU5URUdFUlxuICpcbiAqIE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIC8vIG9ubHkgb25lIHBvc3NpYmxlIGNob2ljZSBmb3Igbm93XG4gKiAgIFJETlNlcXVlbmNlXG4gKiB9XG4gKlxuICogUkROU2VxdWVuY2UgOjo9IFNFUVVFTkNFIE9GIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqXG4gKiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIDo6PSBTRVQgT0YgQXR0cmlidXRlVHlwZUFuZFZhbHVlXG4gKlxuICogQXR0cmlidXRlVHlwZUFuZFZhbHVlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICAgIEF0dHJpYnV0ZVR5cGUsXG4gKiAgIHZhbHVlICAgIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKiBBdHRyaWJ1dGVUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWSBERUZJTkVEIEJZIEF0dHJpYnV0ZVR5cGVcbiAqXG4gKiBWYWxpZGl0eSA6Oj0gU0VRVUVOQ0Uge1xuICogICBub3RCZWZvcmUgICAgICBUaW1lLFxuICogICBub3RBZnRlciAgICAgICBUaW1lXG4gKiB9XG4gKlxuICogVGltZSA6Oj0gQ0hPSUNFIHtcbiAqICAgdXRjVGltZSAgICAgICAgVVRDVGltZSxcbiAqICAgZ2VuZXJhbFRpbWUgICAgR2VuZXJhbGl6ZWRUaW1lXG4gKiB9XG4gKlxuICogVW5pcXVlSWRlbnRpZmllciA6Oj0gQklUIFNUUklOR1xuICpcbiAqIFN1YmplY3RQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSAgICAgICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgICAgIEJJVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBFeHRlbnNpb25zIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEV4dGVuc2lvblxuICpcbiAqIEV4dGVuc2lvbiA6Oj0gU0VRVUVOQ0Uge1xuICogICBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFLFxuICogICBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBUaGUgb25seSBrZXkgYWxnb3JpdGhtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIFBLSSBpcyBSU0EuXG4gKlxuICogUlNBU1NBLVBTUyBzaWduYXR1cmVzIGFyZSBkZXNjcmliZWQgaW4gUkZDIDM0NDcgYW5kIFJGQyA0MDU1LlxuICpcbiAqIFBLQ1MjMTAgdjEuNyBkZXNjcmliZXMgY2VydGlmaWNhdGUgc2lnbmluZyByZXF1ZXN0czpcbiAqXG4gKiBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm86XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgSU5URUdFUiB7IHYxKDApIH0gKHYxLC4uLiksXG4gKiAgIHN1YmplY3QgICAgICAgTmFtZSxcbiAqICAgc3ViamVjdFBLSW5mbyBTdWJqZWN0UHVibGljS2V5SW5mb3t7IFBLSW5mb0FsZ29yaXRobXMgfX0sXG4gKiAgIGF0dHJpYnV0ZXMgICAgWzBdIEF0dHJpYnV0ZXN7eyBDUklBdHRyaWJ1dGVzIH19XG4gKiB9XG4gKlxuICogQXR0cmlidXRlcyB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVQgT0YgQXR0cmlidXRle3sgSU9TZXQgfX1cbiAqXG4gKiBDUklBdHRyaWJ1dGVzICBBVFRSSUJVVEUgIDo6PSB7XG4gKiAgIC4uLiAtLSBhZGQgYW55IGxvY2FsbHkgZGVmaW5lZCBhdHRyaWJ1dGVzIGhlcmUgLS0gfVxuICpcbiAqIEF0dHJpYnV0ZSB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICBBVFRSSUJVVEUuJmlkKHtJT1NldH0pLFxuICogICB2YWx1ZXMgU0VUIFNJWkUoMS4uTUFYKSBPRiBBVFRSSUJVVEUuJlR5cGUoe0lPU2V0fXtAdHlwZX0pXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3QgOjo9IFNFUVVFTkNFIHtcbiAqICAgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyxcbiAqICAgc2lnbmF0dXJlQWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXJ7eyBTaWduYXR1cmVBbGdvcml0aG1zIH19LFxuICogICBzaWduYXR1cmUgICAgICAgICAgQklUIFNUUklOR1xuICogfVxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKiBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIChQS0kpIGltcGxlbWVudGF0aW9uLiAqL1xudmFyIHBraSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xudmFyIG9pZHMgPSBwa2kub2lkcztcblxuLy8gc2hvcnQgbmFtZSBPSUQgbWFwcGluZ3NcbnZhciBfc2hvcnROYW1lcyA9IHt9O1xuX3Nob3J0TmFtZXNbJ0NOJ10gPSBvaWRzWydjb21tb25OYW1lJ107XG5fc2hvcnROYW1lc1snY29tbW9uTmFtZSddID0gJ0NOJztcbl9zaG9ydE5hbWVzWydDJ10gPSBvaWRzWydjb3VudHJ5TmFtZSddO1xuX3Nob3J0TmFtZXNbJ2NvdW50cnlOYW1lJ10gPSAnQyc7XG5fc2hvcnROYW1lc1snTCddID0gb2lkc1snbG9jYWxpdHlOYW1lJ107XG5fc2hvcnROYW1lc1snbG9jYWxpdHlOYW1lJ10gPSAnTCc7XG5fc2hvcnROYW1lc1snU1QnXSA9IG9pZHNbJ3N0YXRlT3JQcm92aW5jZU5hbWUnXTtcbl9zaG9ydE5hbWVzWydzdGF0ZU9yUHJvdmluY2VOYW1lJ10gPSAnU1QnO1xuX3Nob3J0TmFtZXNbJ08nXSA9IG9pZHNbJ29yZ2FuaXphdGlvbk5hbWUnXTtcbl9zaG9ydE5hbWVzWydvcmdhbml6YXRpb25OYW1lJ10gPSAnTyc7XG5fc2hvcnROYW1lc1snT1UnXSA9IG9pZHNbJ29yZ2FuaXphdGlvbmFsVW5pdE5hbWUnXTtcbl9zaG9ydE5hbWVzWydvcmdhbml6YXRpb25hbFVuaXROYW1lJ10gPSAnT1UnO1xuX3Nob3J0TmFtZXNbJ0UnXSA9IG9pZHNbJ2VtYWlsQWRkcmVzcyddO1xuX3Nob3J0TmFtZXNbJ2VtYWlsQWRkcmVzcyddID0gJ0UnO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFN1YmplY3RQdWJsaWNLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCBhbiBSU0EgcHVibGljIGtleVxudmFyIHB1YmxpY0tleVZhbGlkYXRvciA9IGZvcmdlLnBraS5yc2EucHVibGljS2V5VmFsaWRhdG9yO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFguNTA5djMgY2VydGlmaWNhdGVcbnZhciB4NTA5Q2VydGlmaWNhdGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0ZScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAndGJzQ2VydGlmaWNhdGUnLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZlcnNpb24nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDAsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uLmludGVnZXInLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmVyc2lvbidcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNlcmlhbE51bWJlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjZXJ0U2VyaWFsTnVtYmVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRpbmZvU2lnbmF0dXJlT2lkJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlQXNuMTogJ2NlcnRpbmZvU2lnbmF0dXJlUGFyYW1zJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0SXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIC8vIE5vdGU6IFVUQyBhbmQgZ2VuZXJhbGl6ZWQgdGltZXMgbWF5IGJvdGggYXBwZWFyIHNvIHRoZSBjYXB0dXJlXG4gICAgICAvLyBuYW1lcyBhcmUgYmFzZWQgb24gdGhlaXIgZGV0ZWN0ZWQgb3JkZXIsIHRoZSBuYW1lcyB1c2VkIGJlbG93XG4gICAgICAvLyBhcmUgb25seSBmb3IgdGhlIGNvbW1vbiBjYXNlLCB3aGljaCB2YWxpZGl0eSB0aW1lIHJlYWxseSBtZWFuc1xuICAgICAgLy8gXCJub3RCZWZvcmVcIiBhbmQgd2hpY2ggbWVhbnMgXCJub3RBZnRlclwiIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBvcmRlclxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKFVUQyB0aW1lIGNhc2UpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKHV0YyknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5MVVUQ1RpbWUnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKGdlbmVyYWxpemVkIHRpbWUgY2FzZSlcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZSAoZ2VuZXJhbGl6ZWQpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZSdcbiAgICAgIH0sIHtcbiAgICAgICAgLy8gbm90QWZ0ZXIgKFRpbWUpIChvbmx5IFVUQyB0aW1lIGlzIHN1cHBvcnRlZClcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEFmdGVyICh1dGMpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTNVVENUaW1lJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBub3RBZnRlciAoVGltZSkgKG9ubHkgVVRDIHRpbWUgaXMgc3VwcG9ydGVkKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKGdlbmVyYWxpemVkKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWUnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zdWJqZWN0JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U3ViamVjdCdcbiAgICB9LFxuICAgICAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgICAgIHB1YmxpY0tleVZhbGlkYXRvcixcbiAgICB7XG4gICAgICAvLyBpc3N1ZXJVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSUQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDEsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJVbmlxdWVJRC5pZCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0SXNzdWVyVW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIHN1YmplY3RVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlEJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAyLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlELmlkJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTdWJqZWN0VW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIEV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmV4dGVuc2lvbnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDMsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydEV4dGVuc2lvbnMnLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllciAoc2lnbmF0dXJlIGFsZ29yaXRobSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2NlcnRTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U2lnbmF0dXJlUGFyYW1zJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5zaWduYXR1cmVWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTaWduYXR1cmUnXG4gIH1dXG59O1xuXG52YXIgcnNhc3NhUHNzUGFyYW1ldGVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAncnNhcHNzJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnaGFzaE9pZCdcbiAgICAgICAgLyogcGFyYW1ldGVyIGJsb2NrIG9taXR0ZWQsIGZvciBTSEExIE5VTEwgYW55aG93LiAqL1xuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ21hc2tHZW5PaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtcycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1zLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYXNrR2VuSGFzaE9pZCdcbiAgICAgICAgICAvKiBwYXJhbWV0ZXIgYmxvY2sgb21pdHRlZCwgZm9yIFNIQTEgTlVMTCBhbnlob3cuICovXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnNhbHRMZW5ndGgnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMixcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3Muc2FsdExlbmd0aC5zYWx0TGVuZ3RoJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdzYWx0TGVuZ3RoJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnRyYWlsZXJGaWVsZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAzLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ3JzYXBzcy50cmFpbGVyLnRyYWlsZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5DbGFzcy5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3RyYWlsZXInXG4gICAgfV1cbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICBjYXB0dXJlQXNuMTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uaW50ZWdlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmVyc2lvbidcbiAgfSwge1xuICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLnN1YmplY3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0J1xuICB9LFxuICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gIHtcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcycsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzLnR5cGUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMudmFsdWUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlXG4gICAgICB9XVxuICAgIH1dXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgQ2VydGlmaWNhdGlvblJlcXVlc3Qgc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdCcsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdjc3InLFxuICB2YWx1ZTogW1xuICAgIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvciwge1xuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjc3JTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjc3JTaWduYXR1cmVQYXJhbXMnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIHNpZ25hdHVyZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjc3JTaWduYXR1cmUnXG4gIH1dXG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJETlNlcXVlbmNlIG9mIEFTTi4xIERFUi1lbmNvZGVkIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqIHNldHMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kIHZhbHVlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHJkbiB0aGUgUkROU2VxdWVuY2UgdG8gY29udmVydC5cbiAqIEBwYXJhbSBtZCBhIG1lc3NhZ2UgZGlnZXN0IHRvIGFwcGVuZCB0eXBlIGFuZCB2YWx1ZSB0byBpZiBwcm92aWRlZC5cbiAqL1xucGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5ID0gZnVuY3Rpb24ocmRuLCBtZCkge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIGVhY2ggdmFsdWUgaW4gJ3JkbicgaW4gaXMgYSBTRVQgb2YgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZVxuICB2YXIgc2V0LCBhdHRyLCBvYmo7XG4gIGZvcih2YXIgc2kgPSAwOyBzaSA8IHJkbi52YWx1ZS5sZW5ndGg7ICsrc2kpIHtcbiAgICAvLyBnZXQgdGhlIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgc2V0ID0gcmRuLnZhbHVlW3NpXTtcblxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIFNFVCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgc2VxdWVuY2VcbiAgICAvLyBjb250YWluaW5nIGZpcnN0IGEgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIGEgdmFsdWUgKGRlZmluZWQgYnlcbiAgICAvLyB0aGUgT0lEKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXQudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIG9iaiA9IHt9O1xuICAgICAgYXR0ciA9IHNldC52YWx1ZVtpXTtcbiAgICAgIG9iai50eXBlID0gYXNuMS5kZXJUb09pZChhdHRyLnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgIG9iai52YWx1ZSA9IGF0dHIudmFsdWVbMV0udmFsdWU7XG4gICAgICBvYmoudmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVbMV0udHlwZTtcbiAgICAgIC8vIGlmIHRoZSBPSUQgaXMga25vd24sIGdldCBpdHMgbmFtZSBhbmQgc2hvcnQgbmFtZVxuICAgICAgaWYob2JqLnR5cGUgaW4gb2lkcykge1xuICAgICAgICBvYmoubmFtZSA9IG9pZHNbb2JqLnR5cGVdO1xuICAgICAgICBpZihvYmoubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICAgIG9iai5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1tvYmoubmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kKSB7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudHlwZSk7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudmFsdWUpO1xuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIEFTTi4xIENSSUF0dHJpYnV0ZXMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kXG4gKiB2YWx1ZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIHRoZSBDUklBdHRyaWJ1dGVzIHRvIGNvbnZlcnQuXG4gKi9cbnBraS5DUklBdHRyaWJ1dGVzQXNBcnJheSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBlYWNoIHZhbHVlIGluICdhdHRyaWJ1dGVzJyBpbiBpcyBhIFNFUVVFTkNFIHdpdGggYW4gT0lEIGFuZCBhIFNFVFxuICBmb3IodmFyIHNpID0gMDsgc2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytzaSkge1xuICAgIC8vIGdldCB0aGUgYXR0cmlidXRlIHNlcXVlbmNlXG4gICAgdmFyIHNlcSA9IGF0dHJpYnV0ZXNbc2ldO1xuXG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgU0VRVUVOQ0UgY29udGFpbmluZyBmaXJzdCBhIHR5cGUgKGFuIE9JRCkgYW5kXG4gICAgLy8gc2Vjb25kIGEgc2V0IG9mIHZhbHVlcyAoZGVmaW5lZCBieSB0aGUgT0lEKVxuICAgIHZhciB0eXBlID0gYXNuMS5kZXJUb09pZChzZXEudmFsdWVbMF0udmFsdWUpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXEudmFsdWVbMV0udmFsdWU7XG4gICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgdmFsdWVzLmxlbmd0aDsgKyt2aSkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgb2JqLnR5cGUgPSB0eXBlO1xuICAgICAgb2JqLnZhbHVlID0gdmFsdWVzW3ZpXS52YWx1ZTtcbiAgICAgIG9iai52YWx1ZVRhZ0NsYXNzID0gdmFsdWVzW3ZpXS50eXBlO1xuICAgICAgLy8gaWYgdGhlIE9JRCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lIGFuZCBzaG9ydCBuYW1lXG4gICAgICBpZihvYmoudHlwZSBpbiBvaWRzKSB7XG4gICAgICAgIG9iai5uYW1lID0gb2lkc1tvYmoudHlwZV07XG4gICAgICAgIGlmKG9iai5uYW1lIGluIF9zaG9ydE5hbWVzKSB7XG4gICAgICAgICAgb2JqLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW29iai5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcGFyc2UgZXh0ZW5zaW9uc1xuICAgICAgaWYob2JqLnR5cGUgPT09IG9pZHMuZXh0ZW5zaW9uUmVxdWVzdCkge1xuICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgb2JqLmV4dGVuc2lvbnMucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMShvYmoudmFsdWVbZWldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaChvYmopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGlzc3VlciBvciBzdWJqZWN0IGF0dHJpYnV0ZSBmcm9tIGl0cyBuYW1lLCB0eXBlLCBvciBzaG9ydCBuYW1lLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGlzc3VlciBvciBzdWJqZWN0IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIGEgc2hvcnQgbmFtZSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICBzaG9ydE5hbWUgdGhlIHNob3J0IG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIGZvciB0aGUgYXR0cmlidXRlLlxuICogICAgICAgICAgdHlwZSB0aGUgdHlwZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGUob2JqLCBvcHRpb25zKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7c2hvcnROYW1lOiBvcHRpb25zfTtcbiAgfVxuXG4gIHZhciBydmFsID0gbnVsbDtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IG9iai5hdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IG9iai5hdHRyaWJ1dGVzW2ldO1xuICAgIGlmKG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgPT09IGF0dHIudHlwZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMubmFtZSAmJiBvcHRpb25zLm5hbWUgPT09IGF0dHIubmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMuc2hvcnROYW1lICYmIG9wdGlvbnMuc2hvcnROYW1lID09PSBhdHRyLnNob3J0TmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGZyb20gQVNOLjEgc3RydWN0dXJlLlxuICpcbiAqIEN1cnJlbnRseSBvbmx5IFJTQVNTQS1QU1Mgc3VwcG9ydGVkLiAgVGhlIFBLQ1MjMSB2MS41IHNpZ25hdHVyZSBzY2hlbWUgaGFkXG4gKiBubyBwYXJhbWV0ZXJzLlxuICpcbiAqIFJTQVNTQS1QU1MtcGFyYW1zICA6Oj0gIFNFUVVFTkNFICB7XG4gKiAgIGhhc2hBbGdvcml0aG0gICAgICBbMF0gSGFzaEFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhMUlkZW50aWZpZXIsXG4gKiAgIG1hc2tHZW5BbGdvcml0aG0gICBbMV0gTWFza0dlbkFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWdmMVNIQTFJZGVudGlmaWVyLFxuICogICBzYWx0TGVuZ3RoICAgICAgICAgWzJdIElOVEVHRVIgREVGQVVMVCAyMCxcbiAqICAgdHJhaWxlckZpZWxkICAgICAgIFszXSBJTlRFR0VSIERFRkFVTFQgMVxuICogfVxuICpcbiAqIEhhc2hBbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIE1hc2tHZW5BbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQHBhcmFtIG9pZCBUaGUgT0lEIHNwZWNpZnlpbmcgdGhlIHNpZ25hdHVyZSBhbGdvcml0aG1cbiAqIEBwYXJhbSBvYmogVGhlIEFTTi4xIHN0cnVjdHVyZSBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gZmlsbERlZmF1bHRzIFdoZXRoZXIgdG8gdXNlIHJldHVybiBkZWZhdWx0IHZhbHVlcyB3aGVyZSBvbWl0dGVkXG4gKiBAcmV0dXJuIHNpZ25hdHVyZSBwYXJhbWV0ZXIgb2JqZWN0XG4gKi9cbnZhciBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihvaWQsIG9iaiwgZmlsbERlZmF1bHRzKSB7XG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBpZihvaWQgIT09IG9pZHNbJ1JTQVNTQS1QU1MnXSkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBpZihmaWxsRGVmYXVsdHMpIHtcbiAgICBwYXJhbXMgPSB7XG4gICAgICBoYXNoOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snc2hhMSddXG4gICAgICB9LFxuICAgICAgbWdmOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snbWdmMSddLFxuICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydzaGExJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNhbHRMZW5ndGg6IDIwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2Fzc2FQc3NQYXJhbWV0ZXJWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFJTQVNTQS1QU1MgcGFyYW1ldGVyIGJsb2NrLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuaGFzaE9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLmhhc2ggPSBwYXJhbXMuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuaGFzaE9pZCk7XG4gIH1cblxuICBpZihjYXB0dXJlLm1hc2tHZW5PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcy5tZ2YgPSBwYXJhbXMubWdmIHx8IHt9O1xuICAgIHBhcmFtcy5tZ2YuYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5PaWQpO1xuICAgIHBhcmFtcy5tZ2YuaGFzaCA9IHBhcmFtcy5tZ2YuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMubWdmLmhhc2guYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5IYXNoT2lkKTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnNhbHRMZW5ndGggPSBjYXB0dXJlLnNhbHRMZW5ndGguY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5IGNlcnRpZmljYXRlIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhpcyB3aWxsIHNjYW4gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWQgYmFja1xuICogdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY2VydGlmaWNhdGVGcm9tUGVtID0gZnVuY3Rpb24ocGVtLCBjb21wdXRlSGFzaCwgc3RyaWN0KSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdDRVJUSUZJQ0FURScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1g1MDkgQ0VSVElGSUNBVEUnICYmXG4gICAgbXNnLnR5cGUgIT09ICdUUlVTVEVEIENFUlRJRklDQVRFJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGUgZnJvbSBQRU07IFBFTSBoZWFkZXIgdHlwZSAnICtcbiAgICAgICdpcyBub3QgXCJDRVJUSUZJQ0FURVwiLCBcIlg1MDkgQ0VSVElGSUNBVEVcIiwgb3IgXCJUUlVTVEVEIENFUlRJRklDQVRFXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBjZXJ0aWZpY2F0ZSB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZVRvUGVtID0gZnVuY3Rpb24oY2VydCwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0NFUlRJRklDQVRFJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnB1YmxpY0tleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ1BVQkxJQyBLRVknICYmIG1zZy50eXBlICE9PSAnUlNBIFBVQkxJQyBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwdWJsaWMga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyICcgK1xuICAgICAgJ3R5cGUgaXMgbm90IFwiUFVCTElDIEtFWVwiIG9yIFwiUlNBIFBVQkxJQyBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcblxuICByZXR1cm4gcGtpLnB1YmxpY0tleUZyb21Bc24xKG9iaik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IHRvIFBFTSBmb3JtYXQgKHVzaW5nIGEgU3ViamVjdFB1YmxpY0tleUluZm8pLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1BlbSA9IGZ1bmN0aW9uKGtleSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BVQkxJQyBLRVknLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHB1YmxpYyBrZXkgdG8gUEVNIGZvcm1hdCAodXNpbmcgYW4gUlNBUHVibGljS2V5KS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXlQZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFVCTElDIEtFWScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBmaW5nZXJwcmludCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW21kXSB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSAoZGVmYXVsdHMgdG8gZm9yZ2UubWQuc2hhMSkuXG4gKiAgICAgICAgICBbdHlwZV0gdGhlIHR5cGUgb2YgZmluZ2VycHJpbnQsIHN1Y2ggYXMgJ1JTQVB1YmxpY0tleScsXG4gKiAgICAgICAgICAgICdTdWJqZWN0UHVibGljS2V5SW5mbycgKGRlZmF1bHRzIHRvICdSU0FQdWJsaWNLZXknKS5cbiAqICAgICAgICAgIFtlbmNvZGluZ10gYW4gYWx0ZXJuYXRpdmUgb3V0cHV0IGVuY29kaW5nLCBzdWNoIGFzICdoZXgnXG4gKiAgICAgICAgICAgIChkZWZhdWx0cyB0byBub25lLCBvdXRwdXRzIGEgYnl0ZSBidWZmZXIpLlxuICogICAgICAgICAgW2RlbGltaXRlcl0gdGhlIGRlbGltaXRlciB0byB1c2UgYmV0d2VlbiBieXRlcyBmb3IgJ2hleCcgZW5jb2RlZFxuICogICAgICAgICAgICBvdXRwdXQsIGVnOiAnOicgKGRlZmF1bHRzIHRvIG5vbmUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbmdlcnByaW50IGFzIGEgYnl0ZSBidWZmZXIgb3Igb3RoZXIgZW5jb2RpbmcgYmFzZWQgb24gb3B0aW9ucy5cbiAqL1xucGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50ID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbWQgPSBvcHRpb25zLm1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8ICdSU0FQdWJsaWNLZXknO1xuXG4gIHZhciBieXRlcztcbiAgc3dpdGNoKHR5cGUpIHtcbiAgY2FzZSAnUlNBUHVibGljS2V5JzpcbiAgICBieXRlcyA9IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSkpLmdldEJ5dGVzKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1N1YmplY3RQdWJsaWNLZXlJbmZvJzpcbiAgICBieXRlcyA9IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaW5nZXJwcmludCB0eXBlIFwiJyArIG9wdGlvbnMudHlwZSArICdcIi4nKTtcbiAgfVxuXG4gIC8vIGhhc2ggcHVibGljIGtleSBieXRlc1xuICBtZC5zdGFydCgpO1xuICBtZC51cGRhdGUoYnl0ZXMpO1xuICB2YXIgZGlnZXN0ID0gbWQuZGlnZXN0KCk7XG4gIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgdmFyIGhleCA9IGRpZ2VzdC50b0hleCgpO1xuICAgIGlmKG9wdGlvbnMuZGVsaW1pdGVyKSB7XG4gICAgICByZXR1cm4gaGV4Lm1hdGNoKC8uezJ9L2cpLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9IGVsc2UgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICByZXR1cm4gZGlnZXN0LmdldEJ5dGVzKCk7XG4gIH0gZWxzZSBpZihvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIFwiJyArIG9wdGlvbnMuZW5jb2RpbmcgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIGRpZ2VzdDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGlzIHdpbGwgc2NhbiB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2ZcbiAqIHRoZSBBU04uMSBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWRcbiAqIGJhY2sgdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKS5cbiAqL1xucGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbVBlbSA9IGZ1bmN0aW9uKHBlbSwgY29tcHV0ZUhhc2gsIHN0cmljdCkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnQ0VSVElGSUNBVEUgUkVRVUVTVCcpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRpb24gcmVxdWVzdCBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIG5vdCBcIkNFUlRJRklDQVRFIFJFUVVFU1RcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGZyb20gUEVNOyAnICtcbiAgICAgICdQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvUGVtID0gZnVuY3Rpb24oY3NyLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnQ0VSVElGSUNBVEUgUkVRVUVTVCcsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGlvblJlcXVlc3RUb0FzbjEoY3NyKSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgWC41MDl2MyBSU0EgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jcmVhdGVDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2VydCA9IHt9O1xuICBjZXJ0LnZlcnNpb24gPSAweDAyO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9ICcwMCc7XG4gIGNlcnQuc2lnbmF0dXJlT2lkID0gbnVsbDtcbiAgY2VydC5zaWduYXR1cmUgPSBudWxsO1xuICBjZXJ0LnNpZ2luZm8gPSB7fTtcbiAgY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IG51bGw7XG4gIGNlcnQudmFsaWRpdHkgPSB7fTtcbiAgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgPSBuZXcgRGF0ZSgpO1xuICBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyID0gbmV3IERhdGUoKTtcblxuICBjZXJ0Lmlzc3VlciA9IHt9O1xuICBjZXJ0Lmlzc3Vlci5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5pc3N1ZXIsIHNuKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gW107XG4gIGNlcnQuaXNzdWVyLmhhc2ggPSBudWxsO1xuXG4gIGNlcnQuc3ViamVjdCA9IHt9O1xuICBjZXJ0LnN1YmplY3QuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuc3ViamVjdCwgc24pO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBbXTtcbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuXG4gIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICBjZXJ0LnB1YmxpY0tleSA9IG51bGw7XG4gIGNlcnQubWQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2Ygc3ViamVjdCBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICogQHBhcmFtIHVuaXF1ZUlkIGFuIG9wdGlvbmFsIGEgdW5pcXVlIElEIHRvIHVzZS5cbiAgICovXG4gIGNlcnQuc2V0U3ViamVjdCA9IGZ1bmN0aW9uKGF0dHJzLCB1bmlxdWVJZCkge1xuICAgIC8vIHNldCBuZXcgYXR0cmlidXRlcywgY2xlYXIgaGFzaFxuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycyk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBkZWxldGUgY2VydC5zdWJqZWN0LnVuaXF1ZUlkO1xuICAgIGlmKHVuaXF1ZUlkKSB7XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgY2VydC5zdWJqZWN0LnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgfVxuICAgIGNlcnQuc3ViamVjdC5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgaXNzdWVyIG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2YgaXNzdWVyIGF0dHJpYnV0ZXMgdG8gdXNlLlxuICAgKiBAcGFyYW0gdW5pcXVlSWQgYW4gb3B0aW9uYWwgYSB1bmlxdWUgSUQgdG8gdXNlLlxuICAgKi9cbiAgY2VydC5zZXRJc3N1ZXIgPSBmdW5jdGlvbihhdHRycywgdW5pcXVlSWQpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXMsIGNsZWFyIGhhc2hcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBkZWxldGUgY2VydC5pc3N1ZXIudW5pcXVlSWQ7XG4gICAgaWYodW5pcXVlSWQpIHtcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICBjZXJ0Lmlzc3Vlci51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIH1cbiAgICBjZXJ0Lmlzc3Vlci5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgZXh0ZW5zaW9ucyBvZiB0aGlzIGNlcnRpZmljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gZXh0cyB0aGUgYXJyYXkgb2YgZXh0ZW5zaW9ucyB0byB1c2UuXG4gICAqL1xuICBjZXJ0LnNldEV4dGVuc2lvbnMgPSBmdW5jdGlvbihleHRzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhleHRzW2ldLCB7Y2VydDogY2VydH0pO1xuICAgIH1cbiAgICAvLyBzZXQgbmV3IGV4dGVuc2lvbnNcbiAgICBjZXJ0LmV4dGVuc2lvbnMgPSBleHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGV4dGVuc2lvbiBieSBpdHMgbmFtZSBvciBpZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG5hbWUgdG8gdXNlIG9yIGFuIG9iamVjdCB3aXRoOlxuICAgKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIHRvIHVzZS5cbiAgICogICAgICAgICAgaWQgdGhlIGlkIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgY2VydC5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0ge25hbWU6IG9wdGlvbnN9O1xuICAgIH1cblxuICAgIHZhciBydmFsID0gbnVsbDtcbiAgICB2YXIgZXh0O1xuICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IGNlcnQuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgZXh0ID0gY2VydC5leHRlbnNpb25zW2ldO1xuICAgICAgaWYob3B0aW9ucy5pZCAmJiBleHQuaWQgPT09IG9wdGlvbnMuaWQpIHtcbiAgICAgICAgcnZhbCA9IGV4dDtcbiAgICAgIH0gZWxzZSBpZihvcHRpb25zLm5hbWUgJiYgZXh0Lm5hbWUgPT09IG9wdGlvbnMubmFtZSkge1xuICAgICAgICBydmFsID0gZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhpcyBjZXJ0aWZpY2F0ZSB1c2luZyB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aC5cbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIChkZWZhdWx0cyB0byBmb3JnZS5tZC5zaGExKS5cbiAgICovXG4gIGNlcnQuc2lnbiA9IGZ1bmN0aW9uKGtleSwgbWQpIHtcbiAgICAvLyBUT0RPOiBnZXQgc2lnbmF0dXJlIE9JRCBmcm9tIHByaXZhdGUga2V5XG4gICAgY2VydC5tZCA9IG1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIGFsZ29yaXRobU9pZCA9IG9pZHNbY2VydC5tZC5hbGdvcml0aG0gKyAnV2l0aFJTQUVuY3J5cHRpb24nXTtcbiAgICBpZighYWxnb3JpdGhtT2lkKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSBPSUQuJyk7XG4gICAgICBlcnJvci5hbGdvcml0aG0gPSBjZXJ0Lm1kLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBhbGdvcml0aG1PaWQ7XG5cbiAgICAvLyBnZXQgVEJTQ2VydGlmaWNhdGUsIGNvbnZlcnQgdG8gREVSXG4gICAgY2VydC50YnNDZXJ0aWZpY2F0ZSA9IHBraS5nZXRUQlNDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNlcnQudGJzQ2VydGlmaWNhdGUpO1xuXG4gICAgLy8gZGlnZXN0IGFuZCBzaWduXG4gICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgY2VydC5zaWduYXR1cmUgPSBrZXkuc2lnbihjZXJ0Lm1kKTtcbiAgfTtcblxuICAvKipcbiAgICogQXR0ZW1wdHMgdmVyaWZ5IHRoZSBzaWduYXR1cmUgb24gdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSB1c2luZyB0aGlzXG4gICAqIGNlcnRpZmljYXRlJ3MgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGNoaWxkIHRoZSBjZXJ0aWZpY2F0ZSB0byB2ZXJpZnkuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnkgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIHZhciBydmFsID0gZmFsc2U7XG5cbiAgICBpZighY2VydC5pc3N1ZWQoY2hpbGQpKSB7XG4gICAgICB2YXIgaXNzdWVyID0gY2hpbGQuaXNzdWVyO1xuICAgICAgdmFyIHN1YmplY3QgPSBjZXJ0LnN1YmplY3Q7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1RoZSBwYXJlbnQgY2VydGlmaWNhdGUgZGlkIG5vdCBpc3N1ZSB0aGUgZ2l2ZW4gY2hpbGQgJyArXG4gICAgICAgICdjZXJ0aWZpY2F0ZTsgdGhlIGNoaWxkIGNlcnRpZmljYXRlXFwncyBpc3N1ZXIgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xuICAgICAgICAncGFyZW50XFwncyBzdWJqZWN0LicpO1xuICAgICAgZXJyb3IuZXhwZWN0ZWRJc3N1ZXIgPSBpc3N1ZXIuYXR0cmlidXRlcztcbiAgICAgIGVycm9yLmFjdHVhbElzc3VlciA9IHN1YmplY3QuYXR0cmlidXRlcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBtZCA9IGNoaWxkLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBpZihjaGlsZC5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgICB2YXIgb2lkID0gb2lkc1tjaGlsZC5zaWduYXR1cmVPaWRdO1xuICAgICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICAgIGNhc2UgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhMzg0V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihtZCA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICAgJ1Vua25vd24gc2lnbmF0dXJlIE9JRC4nKTtcbiAgICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY2hpbGQuc2lnbmF0dXJlT2lkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIFRCU0NlcnRpZmljYXRlIGFuZCBkaWdlc3QgaXRcbiAgICAgIHZhciB0YnNDZXJ0aWZpY2F0ZSA9IGNoaWxkLnRic0NlcnRpZmljYXRlIHx8IHBraS5nZXRUQlNDZXJ0aWZpY2F0ZShjaGlsZCk7XG4gICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKHRic0NlcnRpZmljYXRlKTtcbiAgICAgIG1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgICB9XG5cbiAgICBpZihtZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHNjaGVtZTtcblxuICAgICAgc3dpdGNoKGNoaWxkLnNpZ25hdHVyZU9pZCkge1xuICAgICAgY2FzZSBvaWRzLnNoYTFXaXRoUlNBRW5jcnlwdGlvbjpcbiAgICAgICAgc2NoZW1lID0gdW5kZWZpbmVkOyAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgc2NoZW1lICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICAgIHZhciBoYXNoLCBtZ2Y7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBtZ2YgKi9cbiAgICAgICAgaGFzaCA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgICAgZXJyb3Iub2lkID0gY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IGhhc2g7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICBtZ2YgPSBvaWRzW2NoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZF07XG4gICAgICAgIGlmKG1nZiA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1nZlttZ2ZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBlcnJvci5vaWQgPSBjaGlsZC5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgIGhhc2ggPSBvaWRzW2NoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdVbnN1cHBvcnRlZCBSU0FTU0EtUFNTIGhhc2ggZnVuY3Rpb24uJyxcbiAgICAgICAgICAgIG9pZDogY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZCxcbiAgICAgICAgICAgIG5hbWU6IGhhc2hcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2NoZW1lID0gZm9yZ2UucHNzLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSwgbWdmLFxuICAgICAgICAgIGNoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuc2FsdExlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyB2ZXJpZnkgc2lnbmF0dXJlIG9uIGNlcnQgdXNpbmcgcHVibGljIGtleVxuICAgICAgcnZhbCA9IGNlcnQucHVibGljS2V5LnZlcmlmeShcbiAgICAgICAgbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSwgY2hpbGQuc2lnbmF0dXJlLCBzY2hlbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIGlzc3VlciBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogY2VydGlmaWNhdGUncyBzdWJqZWN0LiBOb3RlIHRoYXQgbm8gc2lnbmF0dXJlIGNoZWNrIGlzIHBlcmZvcm1lZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3MgaXNzdWVyIG1hdGNoZXMgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSdzXG4gICAqICAgICAgICAgc3ViamVjdC5cbiAgICovXG4gIGNlcnQuaXNJc3N1ZXIgPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIGkgPSBjZXJ0Lmlzc3VlcjtcbiAgICB2YXIgcyA9IHBhcmVudC5zdWJqZWN0O1xuXG4gICAgLy8gY29tcGFyZSBoYXNoZXMgaWYgcHJlc2VudFxuICAgIGlmKGkuaGFzaCAmJiBzLmhhc2gpIHtcbiAgICAgIHJ2YWwgPSAoaS5oYXNoID09PSBzLmhhc2gpO1xuICAgIH0gZWxzZSBpZihpLmF0dHJpYnV0ZXMubGVuZ3RoID09PSBzLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBhbGwgYXR0cmlidXRlcyBhcmUgdGhlIHNhbWUgc28gaXNzdWVyIG1hdGNoZXMgc3ViamVjdFxuICAgICAgcnZhbCA9IHRydWU7XG4gICAgICB2YXIgaWF0dHIsIHNhdHRyO1xuICAgICAgZm9yKHZhciBuID0gMDsgcnZhbCAmJiBuIDwgaS5hdHRyaWJ1dGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGlhdHRyID0gaS5hdHRyaWJ1dGVzW25dO1xuICAgICAgICBzYXR0ciA9IHMuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgaWYoaWF0dHIudHlwZSAhPT0gc2F0dHIudHlwZSB8fCBpYXR0ci52YWx1ZSAhPT0gc2F0dHIudmFsdWUpIHtcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgbWlzbWF0Y2hcbiAgICAgICAgICBydmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2VydGlmaWNhdGUncyBzdWJqZWN0IG1hdGNoZXMgdGhlIGlzc3VlciBvZiB0aGVcbiAgICogZ2l2ZW4gY2VydGlmaWNhdGUpLiBOb3RlIHRoYXQgbm90IHNpZ25hdHVyZSBjaGVjayBpcyBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGlsZCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3Mgc3ViamVjdCBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogICAgICAgICBjZXJ0aWZpY2F0ZSdzIGlzc3Vlci5cbiAgICovXG4gIGNlcnQuaXNzdWVkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuaXNJc3N1ZXIoY2VydCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgc3ViamVjdEtleUlkZW50aWZpZXIgZm9yIHRoaXMgY2VydGlmaWNhdGUgYXMgYnl0ZSBidWZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGZvciB0aGlzIGNlcnRpZmljYXRlIGFzIGJ5dGUgYnVmZmVyLlxuICAgKi9cbiAgY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgLyogU2VlOiA0LjIuMS4yIHNlY3Rpb24gb2YgdGhlIHRoZSBSRkMzMjgwLCBrZXlJZGVudGlmaWVyIGlzIGVpdGhlcjpcblxuICAgICAgKDEpIFRoZSBrZXlJZGVudGlmaWVyIGlzIGNvbXBvc2VkIG9mIHRoZSAxNjAtYml0IFNIQS0xIGhhc2ggb2YgdGhlXG4gICAgICAgIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXkgKGV4Y2x1ZGluZyB0aGUgdGFnLFxuICAgICAgICBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdHMpLlxuXG4gICAgICAoMikgVGhlIGtleUlkZW50aWZpZXIgaXMgY29tcG9zZWQgb2YgYSBmb3VyIGJpdCB0eXBlIGZpZWxkIHdpdGhcbiAgICAgICAgdGhlIHZhbHVlIDAxMDAgZm9sbG93ZWQgYnkgdGhlIGxlYXN0IHNpZ25pZmljYW50IDYwIGJpdHMgb2YgdGhlXG4gICAgICAgIFNIQS0xIGhhc2ggb2YgdGhlIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgKGV4Y2x1ZGluZyB0aGUgdGFnLCBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdCBzdHJpbmcgYml0cykuXG4gICAgKi9cblxuICAgIC8vIHNraXBwaW5nIHRoZSB0YWcsIGxlbmd0aCwgYW5kIG51bWJlciBvZiB1bnVzZWQgYml0cyBpcyB0aGUgc2FtZVxuICAgIC8vIGFzIGp1c3QgdXNpbmcgdGhlIFJTQVB1YmxpY0tleSAoZm9yIFJTQSBrZXlzLCB3aGljaCBhcmUgdGhlXG4gICAgLy8gb25seSBvbmVzIHN1cHBvcnRlZClcbiAgICByZXR1cm4gcGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50KGNlcnQucHVibGljS2V5LCB7dHlwZTogJ1JTQVB1YmxpY0tleSd9KTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGV4dGVuc2lvbiB2YWx1ZSBmb3IgdGhpcyBjZXJ0aWZpY2F0ZVxuICAgKiBhZ2FpbnN0IGl0cyBwdWJsaWMga2V5LiBJZiBubyBleHRlbnNpb24gaXMgZm91bmQsIGZhbHNlIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnlTdWJqZWN0S2V5SWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvaWQgPSBvaWRzWydzdWJqZWN0S2V5SWRlbnRpZmllciddO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICBpZihleHQuaWQgPT09IG9pZCkge1xuICAgICAgICB2YXIgc2tpID0gY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIChmb3JnZS51dGlsLmhleFRvQnl0ZXMoZXh0LnN1YmplY3RLZXlJZGVudGlmaWVyKSA9PT0gc2tpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZSBmcm9tIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGltcGxlbWVudGF0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBhIGNlcnRpZmljYXRlIGJhY2sgdG8gQVNOLjEgc28gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNlcnQgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gIC8vIHZhbGlkYXRlIGNlcnRpZmljYXRlIGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgWC41MDkgY2VydGlmaWNhdGUuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYW4gWDUwOXYzIENlcnRpZmljYXRlLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRlXG4gIHZhciBjZXJ0ID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRlKCk7XG4gIGNlcnQudmVyc2lvbiA9IGNhcHR1cmUuY2VydFZlcnNpb24gP1xuICAgIGNhcHR1cmUuY2VydFZlcnNpb24uY2hhckNvZGVBdCgwKSA6IDA7XG4gIHZhciBzZXJpYWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmNlcnRTZXJpYWxOdW1iZXIpO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9IHNlcmlhbC50b0hleCgpO1xuICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0U2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNlcnQuc2lnbmF0dXJlT2lkLCBjYXB0dXJlLmNlcnRTaWduYXR1cmVQYXJhbXMsIHRydWUpO1xuICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCxcbiAgICBjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zLCBmYWxzZSk7XG4gIGNlcnQuc2lnbmF0dXJlID0gY2FwdHVyZS5jZXJ0U2lnbmF0dXJlO1xuXG4gIHZhciB2YWxpZGl0eSA9IFtdO1xuICBpZihjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEudXRjVGltZVRvRGF0ZShjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlKFxuICAgICAgY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLnV0Y1RpbWVUb0RhdGUoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShcbiAgICAgIGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSkpO1xuICB9XG4gIGlmKHZhbGlkaXR5Lmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIG5vdEJlZm9yZS9ub3RBZnRlciB2YWxpZGl0eSB0aW1lczsgbW9yZSAnICtcbiAgICAgICd0aGFuIHR3byB0aW1lcyB3ZXJlIHByb3ZpZGVkIGluIHRoZSBjZXJ0aWZpY2F0ZS4nKTtcbiAgfVxuICBpZih2YWxpZGl0eS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBub3RCZWZvcmUvbm90QWZ0ZXIgdmFsaWRpdHkgdGltZXM7IHRoZXkgJyArXG4gICAgICAnd2VyZSBub3QgcHJvdmlkZWQgYXMgZWl0aGVyIFVUQ1RpbWUgb3IgR2VuZXJhbGl6ZWRUaW1lLicpO1xuICB9XG4gIGNlcnQudmFsaWRpdHkubm90QmVmb3JlID0gdmFsaWRpdHlbMF07XG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSB2YWxpZGl0eVsxXTtcblxuICAvLyBrZWVwIFRCU0NlcnRpZmljYXRlIHRvIHByZXNlcnZlIHNpZ25hdHVyZSB3aGVuIGV4cG9ydGluZ1xuICBjZXJ0LnRic0NlcnRpZmljYXRlID0gY2FwdHVyZS50YnNDZXJ0aWZpY2F0ZTtcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICBjZXJ0Lm1kID0gbnVsbDtcbiAgICBpZihjZXJ0LnNpZ25hdHVyZU9pZCBpbiBvaWRzKSB7XG4gICAgICB2YXIgb2lkID0gb2lkc1tjZXJ0LnNpZ25hdHVyZU9pZF07XG4gICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUlNBU1NBLVBTUyc6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihjZXJ0Lm1kID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIHNpZ25hdHVyZSBPSUQuJyk7XG4gICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjZXJ0LnNpZ25hdHVyZU9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBUQlNDZXJ0aWZpY2F0ZSBhbmQgZGlnZXN0IGl0XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjZXJ0LnRic0NlcnRpZmljYXRlKTtcbiAgICBjZXJ0Lm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBpc3N1ZXIsIGJ1aWxkIGlzc3VlciBtZXNzYWdlIGRpZ2VzdFxuICB2YXIgaW1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgY2VydC5pc3N1ZXIuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuaXNzdWVyLCBzbik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRJc3N1ZXIsIGltZCk7XG4gIGlmKGNhcHR1cmUuY2VydElzc3VlclVuaXF1ZUlkKSB7XG4gICAgY2VydC5pc3N1ZXIudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRJc3N1ZXJVbmlxdWVJZDtcbiAgfVxuICBjZXJ0Lmlzc3Vlci5oYXNoID0gaW1kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNlcnQuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5zdWJqZWN0LCBzbik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRTdWJqZWN0LCBzbWQpO1xuICBpZihjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQpIHtcbiAgICBjZXJ0LnN1YmplY3QudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQ7XG4gIH1cbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBzbWQuZGlnZXN0KCkudG9IZXgoKTtcblxuICAvLyBoYW5kbGUgZXh0ZW5zaW9uc1xuICBpZihjYXB0dXJlLmNlcnRFeHRlbnNpb25zKSB7XG4gICAgY2VydC5leHRlbnNpb25zID0gcGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uc0Zyb21Bc24xKGNhcHR1cmUuY2VydEV4dGVuc2lvbnMpO1xuICB9IGVsc2Uge1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICB9XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNlcnQucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU04uMSBleHRlbnNpb25zIG9iamVjdCAod2l0aCBleHRlbnNpb24gc2VxdWVuY2VzIGFzIGl0c1xuICogdmFsdWVzKSBpbnRvIGFuIGFycmF5IG9mIGV4dGVuc2lvbiBvYmplY3RzIHdpdGggdHlwZXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBTdXBwb3J0ZWQgZXh0ZW5zaW9uczpcbiAqXG4gKiBpZC1jZS1rZXlVc2FnZSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTUgfVxuICogS2V5VXNhZ2UgOjo9IEJJVCBTVFJJTkcge1xuICogICBkaWdpdGFsU2lnbmF0dXJlICAgICAgICAoMCksXG4gKiAgIG5vblJlcHVkaWF0aW9uICAgICAgICAgICgxKSxcbiAqICAga2V5RW5jaXBoZXJtZW50ICAgICAgICAgKDIpLFxuICogICBkYXRhRW5jaXBoZXJtZW50ICAgICAgICAoMyksXG4gKiAgIGtleUFncmVlbWVudCAgICAgICAgICAgICg0KSxcbiAqICAga2V5Q2VydFNpZ24gICAgICAgICAgICAgKDUpLFxuICogICBjUkxTaWduICAgICAgICAgICAgICAgICAoNiksXG4gKiAgIGVuY2lwaGVyT25seSAgICAgICAgICAgICg3KSxcbiAqICAgZGVjaXBoZXJPbmx5ICAgICAgICAgICAgKDgpXG4gKiB9XG4gKlxuICogaWQtY2UtYmFzaWNDb25zdHJhaW50cyBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTkgfVxuICogQmFzaWNDb25zdHJhaW50cyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjQSAgICAgICAgICAgICAgICAgICAgICBCT09MRUFOIERFRkFVTFQgRkFMU0UsXG4gKiAgIHBhdGhMZW5Db25zdHJhaW50ICAgICAgIElOVEVHRVIgKDAuLk1BWCkgT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBzdWJqZWN0QWx0TmFtZSBFWFRFTlNJT04gOjo9IHtcbiAqICAgU1lOVEFYIEdlbmVyYWxOYW1lc1xuICogICBJREVOVElGSUVEIEJZIGlkLWNlLXN1YmplY3RBbHROYW1lXG4gKiB9XG4gKlxuICogR2VuZXJhbE5hbWVzIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEdlbmVyYWxOYW1lXG4gKlxuICogR2VuZXJhbE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIG90aGVyTmFtZSAgICAgIFswXSBJTlNUQU5DRSBPRiBPVEhFUi1OQU1FLFxuICogICByZmM4MjJOYW1lICAgICBbMV0gSUE1U3RyaW5nLFxuICogICBkTlNOYW1lICAgICAgICBbMl0gSUE1U3RyaW5nLFxuICogICB4NDAwQWRkcmVzcyAgICBbM10gT1JBZGRyZXNzLFxuICogICBkaXJlY3RvcnlOYW1lICBbNF0gTmFtZSxcbiAqICAgZWRpUGFydHlOYW1lICAgWzVdIEVESVBhcnR5TmFtZSxcbiAqICAgdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciBbNl0gSUE1U3RyaW5nLFxuICogICBJUEFkZHJlc3MgICAgICBbN10gT0NURVQgU1RSSU5HLFxuICogICByZWdpc3RlcmVkSUQgICBbOF0gT0JKRUNUIElERU5USUZJRVJcbiAqIH1cbiAqXG4gKiBPVEhFUi1OQU1FIDo6PSBUWVBFLUlERU5USUZJRVJcbiAqXG4gKiBFRElQYXJ0eU5hbWUgOjo9IFNFUVVFTkNFIHtcbiAqICAgbmFtZUFzc2lnbmVyIFswXSBEaXJlY3RvcnlTdHJpbmcge3ViLW5hbWV9IE9QVElPTkFMLFxuICogICBwYXJ0eU5hbWUgICAgWzFdIERpcmVjdG9yeVN0cmluZyB7dWItbmFtZX1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyBBU04uMSB3aXRoIGV4dGVuc2lvbiBzZXF1ZW5jZXMgdG8gcGFyc2UuXG4gKlxuICogQHJldHVybiB0aGUgYXJyYXkuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMSA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgZXh0ZW5zaW9uIHNlcXVlbmNlXG4gICAgdmFyIGV4dHNlcSA9IGV4dHMudmFsdWVbaV07XG4gICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgZXh0c2VxLnZhbHVlLmxlbmd0aDsgKytlaSkge1xuICAgICAgcnZhbC5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xKGV4dHNlcS52YWx1ZVtlaV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2luZ2xlIGNlcnRpZmljYXRlIGV4dGVuc2lvbiBmcm9tIEFTTi4xLlxuICpcbiAqIEBwYXJhbSBleHQgdGhlIGV4dGVuc2lvbiBpbiBBU04uMSBmb3JtYXQuXG4gKlxuICogQHJldHVybiB0aGUgcGFyc2VkIGV4dGVuc2lvbiBhcyBhbiBvYmplY3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGFuIGV4dGVuc2lvbiBoYXM6XG4gIC8vIFswXSBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUlxuICAvLyBbMV0gY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFXG4gIC8vIFsyXSBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAgdmFyIGUgPSB7fTtcbiAgZS5pZCA9IGFzbjEuZGVyVG9PaWQoZXh0LnZhbHVlWzBdLnZhbHVlKTtcbiAgZS5jcml0aWNhbCA9IGZhbHNlO1xuICBpZihleHQudmFsdWVbMV0udHlwZSA9PT0gYXNuMS5UeXBlLkJPT0xFQU4pIHtcbiAgICBlLmNyaXRpY2FsID0gKGV4dC52YWx1ZVsxXS52YWx1ZS5jaGFyQ29kZUF0KDApICE9PSAweDAwKTtcbiAgICBlLnZhbHVlID0gZXh0LnZhbHVlWzJdLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGUudmFsdWUgPSBleHQudmFsdWVbMV0udmFsdWU7XG4gIH1cbiAgLy8gaWYgdGhlIG9pZCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lXG4gIGlmKGUuaWQgaW4gb2lkcykge1xuICAgIGUubmFtZSA9IG9pZHNbZS5pZF07XG5cbiAgICAvLyBoYW5kbGUga2V5IHVzYWdlXG4gICAgaWYoZS5uYW1lID09PSAna2V5VXNhZ2UnKSB7XG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIHZhciBiMyA9IDB4MDA7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNraXAgZmlyc3QgYnl0ZSwganVzdCBpbmRpY2F0ZXMgdW51c2VkIGJpdHMgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBiZSBwYWRkZWQgd2l0aCAwcyBhbnl3YXlcbiAgICAgICAgLy8gZ2V0IGJ5dGVzIHdpdGggZmxhZyBiaXRzXG4gICAgICAgIGIyID0gZXYudmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgICAgYjMgPSBldi52YWx1ZS5sZW5ndGggPiAyID8gZXYudmFsdWUuY2hhckNvZGVBdCgyKSA6IDA7XG4gICAgICB9XG4gICAgICAvLyBzZXQgZmxhZ3NcbiAgICAgIGUuZGlnaXRhbFNpZ25hdHVyZSA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5ub25SZXB1ZGlhdGlvbiA9IChiMiAmIDB4NDApID09PSAweDQwO1xuICAgICAgZS5rZXlFbmNpcGhlcm1lbnQgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUuZGF0YUVuY2lwaGVybWVudCA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5rZXlBZ3JlZW1lbnQgPSAoYjIgJiAweDA4KSA9PT0gMHgwODtcbiAgICAgIGUua2V5Q2VydFNpZ24gPSAoYjIgJiAweDA0KSA9PT0gMHgwNDtcbiAgICAgIGUuY1JMU2lnbiA9IChiMiAmIDB4MDIpID09PSAweDAyO1xuICAgICAgZS5lbmNpcGhlck9ubHkgPSAoYjIgJiAweDAxKSA9PT0gMHgwMTtcbiAgICAgIGUuZGVjaXBoZXJPbmx5ID0gKGIzICYgMHg4MCkgPT09IDB4ODA7XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgICAvLyBoYW5kbGUgYmFzaWMgY29uc3RyYWludHNcbiAgICAgIC8vIGdldCB2YWx1ZSBhcyBTRVFVRU5DRVxuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgLy8gZ2V0IGNBIEJPT0xFQU4gZmxhZyAoZGVmYXVsdHMgdG8gZmFsc2UpXG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAwICYmIGV2LnZhbHVlWzBdLnR5cGUgPT09IGFzbjEuVHlwZS5CT09MRUFOKSB7XG4gICAgICAgIGUuY0EgPSAoZXYudmFsdWVbMF0udmFsdWUuY2hhckNvZGVBdCgwKSAhPT0gMHgwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLmNBID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBnZXQgcGF0aCBsZW5ndGggY29uc3RyYWludFxuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDAgJiYgZXYudmFsdWVbMF0udHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIpIHtcbiAgICAgICAgdmFsdWUgPSBldi52YWx1ZVswXS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gZXYudmFsdWVbMV0udmFsdWU7XG4gICAgICB9XG4gICAgICBpZih2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBlLnBhdGhMZW5Db25zdHJhaW50ID0gYXNuMS5kZXJUb0ludGVnZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihlLm5hbWUgPT09ICdleHRLZXlVc2FnZScpIHtcbiAgICAgIC8vIGhhbmRsZSBleHRLZXlVc2FnZVxuICAgICAgLy8gdmFsdWUgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBmb3IodmFyIHZpID0gMDsgdmkgPCBldi52YWx1ZS5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoZXYudmFsdWVbdmldLnZhbHVlKTtcbiAgICAgICAgaWYob2lkIGluIG9pZHMpIHtcbiAgICAgICAgICBlW29pZHNbb2lkXV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVbb2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnbnNDZXJ0VHlwZScpIHtcbiAgICAgIC8vIGhhbmRsZSBuc0NlcnRUeXBlXG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gc2tpcCBmaXJzdCBieXRlLCBqdXN0IGluZGljYXRlcyB1bnVzZWQgYml0cyB3aGljaFxuICAgICAgICAvLyB3aWxsIGJlIHBhZGRlZCB3aXRoIDBzIGFueXdheVxuICAgICAgICAvLyBnZXQgYnl0ZXMgd2l0aCBmbGFnIGJpdHNcbiAgICAgICAgYjIgPSBldi52YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGZsYWdzXG4gICAgICBlLmNsaWVudCA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5zZXJ2ZXIgPSAoYjIgJiAweDQwKSA9PT0gMHg0MDtcbiAgICAgIGUuZW1haWwgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUub2Jqc2lnbiA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5yZXNlcnZlZCA9IChiMiAmIDB4MDgpID09PSAweDA4O1xuICAgICAgZS5zc2xDQSA9IChiMiAmIDB4MDQpID09PSAweDA0O1xuICAgICAgZS5lbWFpbENBID0gKGIyICYgMHgwMikgPT09IDB4MDI7XG4gICAgICBlLm9iakNBID0gKGIyICYgMHgwMSkgPT09IDB4MDE7XG4gICAgfSBlbHNlIGlmKFxuICAgICAgZS5uYW1lID09PSAnc3ViamVjdEFsdE5hbWUnIHx8XG4gICAgICBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgICAgLy8gaGFuZGxlIHN1YmplY3RBbHROYW1lL2lzc3VlckFsdE5hbWVcbiAgICAgIGUuYWx0TmFtZXMgPSBbXTtcblxuICAgICAgLy8gZXYgaXMgYSBTWU5UQVggU0VRVUVOQ0VcbiAgICAgIHZhciBnbjtcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBldi52YWx1ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICAvLyBnZXQgR2VuZXJhbE5hbWVcbiAgICAgICAgZ24gPSBldi52YWx1ZVtuXTtcblxuICAgICAgICB2YXIgYWx0TmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBnbi50eXBlLFxuICAgICAgICAgIHZhbHVlOiBnbi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBlLmFsdE5hbWVzLnB1c2goYWx0TmFtZSk7XG5cbiAgICAgICAgLy8gTm90ZTogU3VwcG9ydCBmb3IgdHlwZXMgMSwyLDYsNyw4XG4gICAgICAgIHN3aXRjaChnbi50eXBlKSB7XG4gICAgICAgIC8vIHJmYzgyMk5hbWVcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAvLyBkTlNOYW1lXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciAoVVJJKVxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElQQWRkcmVzc1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgLy8gY29udmVydCB0byBJUHY0L0lQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgYWx0TmFtZS5pcCA9IGZvcmdlLnV0aWwuYnl0ZXNUb0lQKGduLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gcmVnaXN0ZXJlZElEXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBhbHROYW1lLm9pZCA9IGFzbjEuZGVyVG9PaWQoZ24udmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHVuc3VwcG9ydGVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnc3ViamVjdEtleUlkZW50aWZpZXInKSB7XG4gICAgICAvLyB2YWx1ZSBpcyBhbiBPQ1RFVFNUUklORyB3L3RoZSBoYXNoIG9mIHRoZSBrZXktdHlwZSBzcGVjaWZpY1xuICAgICAgLy8gcHVibGljIGtleSBzdHJ1Y3R1cmUgKGVnOiBSU0FQdWJsaWNLZXkpXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGV2LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gaW1wbGVtZW50YXRpb24gZm9yIGNvbnZlcnRpbmdcbiAqIGEgY2VydGlmaWNhdGUgYmFjayB0byBBU04uMSBzbyB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2YgdGhlXG4gKiBBU04uMSBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNzciBvYmplY3QgaXMgY3JlYXRlZC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaiwgY29tcHV0ZUhhc2gpIHtcbiAgLy8gdmFsaWRhdGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIGNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEwIGNlcnRpZmljYXRlIHJlcXVlc3QuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYSBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdFxuICB2YXIgY3NyID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0KCk7XG4gIGNzci52ZXJzaW9uID0gY2FwdHVyZS5jc3JWZXJzaW9uID8gY2FwdHVyZS5jc3JWZXJzaW9uLmNoYXJDb2RlQXQoMCkgOiAwO1xuICBjc3Iuc2lnbmF0dXJlT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNzci5zaWduYXR1cmVPaWQsIGNhcHR1cmUuY3NyU2lnbmF0dXJlUGFyYW1zLCB0cnVlKTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoXG4gICAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkLCBjYXB0dXJlLmNzclNpZ25hdHVyZVBhcmFtcywgZmFsc2UpO1xuICBjc3Iuc2lnbmF0dXJlID0gY2FwdHVyZS5jc3JTaWduYXR1cmU7XG5cbiAgLy8ga2VlcCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gdG8gcHJlc2VydmUgc2lnbmF0dXJlIHdoZW4gZXhwb3J0aW5nXG4gIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBjYXB0dXJlLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbztcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICBjc3IubWQgPSBudWxsO1xuICAgIGlmKGNzci5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgdmFyIG9pZCA9IG9pZHNbY3NyLnNpZ25hdHVyZU9pZF07XG4gICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTUxMldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihjc3IubWQgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIHNpZ25hdHVyZSBPSUQuJyk7XG4gICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnbmF0dXJlT2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBhbmQgZGlnZXN0IGl0XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcihjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKTtcbiAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICB9XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNzci5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3Iuc3ViamVjdCwgc24pO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBwa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoXG4gICAgY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0LCBzbWQpO1xuICBjc3Iuc3ViamVjdC5oYXNoID0gc21kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNzci5wdWJsaWNLZXkgPSBwa2kucHVibGljS2V5RnJvbUFzbjEoY2FwdHVyZS5zdWJqZWN0UHVibGljS2V5SW5mbyk7XG5cbiAgLy8gY29udmVydCBhdHRyaWJ1dGVzIGZyb20gQVNOLjFcbiAgY3NyLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLCBzbik7XG4gIH07XG4gIGNzci5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY3NyLmF0dHJpYnV0ZXMgPSBwa2kuQ1JJQXR0cmlidXRlc0FzQXJyYXkoXG4gICAgY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9BdHRyaWJ1dGVzIHx8IFtdKTtcblxuICByZXR1cm4gY3NyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IGNlcnRpZmljYXRpb24gcmVxdWVzdCAoYSBDU1Igb3IgY2VydGlmaWNhdGUgc2lnbmluZ1xuICogcmVxdWVzdCkuIE9uY2UgY3JlYXRlZCwgaXRzIHB1YmxpYyBrZXkgYW5kIGF0dHJpYnV0ZXMgY2FuIGJlIHNldCBhbmQgdGhlblxuICogaXQgY2FuIGJlIHNpZ25lZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBlbXB0eSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jcmVhdGVDZXJ0aWZpY2F0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3NyID0ge307XG4gIGNzci52ZXJzaW9uID0gMHgwMDtcbiAgY3NyLnNpZ25hdHVyZU9pZCA9IG51bGw7XG4gIGNzci5zaWduYXR1cmUgPSBudWxsO1xuICBjc3Iuc2lnaW5mbyA9IHt9O1xuICBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBudWxsO1xuXG4gIGNzci5zdWJqZWN0ID0ge307XG4gIGNzci5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3Iuc3ViamVjdCwgc24pO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBbXTtcbiAgY3NyLnN1YmplY3QuaGFzaCA9IG51bGw7XG5cbiAgY3NyLnB1YmxpY0tleSA9IG51bGw7XG4gIGNzci5hdHRyaWJ1dGVzID0gW107XG4gIGNzci5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNzciwgc24pO1xuICB9O1xuICBjc3IuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNzci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5tZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN1YmplY3Qgb2YgdGhpcyBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2Ygc3ViamVjdCBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICovXG4gIGNzci5zZXRTdWJqZWN0ID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXNcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBjc3Iuc3ViamVjdC5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIHRoZSBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICovXG4gIGNzci5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXNcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNzci5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoaXMgY2VydGlmaWNhdGlvbiByZXF1ZXN0IHVzaW5nIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoLlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgKGRlZmF1bHRzIHRvIGZvcmdlLm1kLnNoYTEpLlxuICAgKi9cbiAgY3NyLnNpZ24gPSBmdW5jdGlvbihrZXksIG1kKSB7XG4gICAgLy8gVE9ETzogZ2V0IHNpZ25hdHVyZSBPSUQgZnJvbSBwcml2YXRlIGtleVxuICAgIGNzci5tZCA9IG1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIGFsZ29yaXRobU9pZCA9IG9pZHNbY3NyLm1kLmFsZ29yaXRobSArICdXaXRoUlNBRW5jcnlwdGlvbiddO1xuICAgIGlmKCFhbGdvcml0aG1PaWQpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSBPSUQuJyk7XG4gICAgICBlcnJvci5hbGdvcml0aG0gPSBjc3IubWQuYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNzci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBhbGdvcml0aG1PaWQ7XG5cbiAgICAvLyBnZXQgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLCBjb252ZXJ0IHRvIERFUlxuICAgIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBwa2kuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGNzcik7XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcihjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKTtcblxuICAgIC8vIGRpZ2VzdCBhbmQgc2lnblxuICAgIGNzci5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgY3NyLnNpZ25hdHVyZSA9IGtleS5zaWduKGNzci5tZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHZlcmlmeSB0aGUgc2lnbmF0dXJlIG9uIHRoZSBwYXNzZWQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IHVzaW5nXG4gICAqIGl0cyBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBBIENTUiB0aGF0IGhhcyBiZWVuIGV4cG9ydGVkIHRvIGEgZmlsZSBpbiBQRU0gZm9ybWF0IGNhbiBiZSB2ZXJpZmllZCB1c2luZ1xuICAgKiBPcGVuU1NMIHVzaW5nIHRoaXMgY29tbWFuZDpcbiAgICpcbiAgICogb3BlbnNzbCByZXEgLWluIDx0aGUtY3NyLXBlbS1maWxlPiAtdmVyaWZ5IC1ub291dCAtdGV4dFxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNzci52ZXJpZnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIG1kID0gY3NyLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBpZihjc3Iuc2lnbmF0dXJlT2lkIGluIG9pZHMpIHtcbiAgICAgICAgLy8gVE9ETzogY3JlYXRlIERSWSBgT0lEIHRvIG1kYCBmdW5jdGlvblxuICAgICAgICB2YXIgb2lkID0gb2lkc1tjc3Iuc2lnbmF0dXJlT2lkXTtcbiAgICAgICAgc3dpdGNoKG9pZCkge1xuICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhNTEyV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSU0FTU0EtUFNTJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZGlnZXN0LiAnICtcbiAgICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnbmF0dXJlT2lkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBhbmQgZGlnZXN0IGl0XG4gICAgICB2YXIgY3JpID0gY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyB8fFxuICAgICAgICBwa2kuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGNzcik7XG4gICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNyaSk7XG4gICAgICBtZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgfVxuXG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBzY2hlbWU7XG5cbiAgICAgIHN3aXRjaChjc3Iuc2lnbmF0dXJlT2lkKSB7XG4gICAgICBjYXNlIG9pZHMuc2hhMVdpdGhSU0FFbmNyeXB0aW9uOlxuICAgICAgICAvKiB1c2UgUEtDUyMxIHYxLjUgcGFkZGluZyBzY2hlbWUgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9pZHNbJ1JTQVNTQS1QU1MnXTpcbiAgICAgICAgdmFyIGhhc2gsIG1nZjtcblxuICAgICAgICAvKiBpbml0aWFsaXplIG1nZiAqL1xuICAgICAgICBoYXNoID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgICAgZXJyb3Iub2lkID0gY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkO1xuICAgICAgICAgIGVycm9yLm5hbWUgPSBoYXNoO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgbWdmID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgaWYobWdmID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWdmW21nZl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIGVycm9yLm9pZCA9IGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgIGhhc2ggPSBvaWRzW2Nzci5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgaWYoaGFzaCA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1kW2hhc2hdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBlcnJvci5vaWQgPSBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZDtcbiAgICAgICAgICBlcnJvci5uYW1lID0gaGFzaDtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtZSA9IGZvcmdlLnBzcy5jcmVhdGUoZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCksIG1nZixcbiAgICAgICAgICBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHZlcmlmeSBzaWduYXR1cmUgb24gY3NyIHVzaW5nIGl0cyBwdWJsaWMga2V5XG4gICAgICBydmFsID0gY3NyLnB1YmxpY0tleS52ZXJpZnkoXG4gICAgICAgIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCksIGNzci5zaWduYXR1cmUsIHNjaGVtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIGNzcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDkgc3ViamVjdCBvciBpc3N1ZXIgdG8gYW4gQVNOLjEgUkROU2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgc3ViamVjdCBvciBpc3N1ZXIgKGRpc3Rpbmd1aXNoZWQgbmFtZSkuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgUkROU2VxdWVuY2UuXG4gKi9cbmZ1bmN0aW9uIF9kblRvQXNuMShvYmopIHtcbiAgLy8gY3JlYXRlIGFuIGVtcHR5IFJETlNlcXVlbmNlXG4gIHZhciBydmFsID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGl0ZXJhdGUgb3ZlciBhdHRyaWJ1dGVzXG4gIHZhciBhdHRyLCBzZXQ7XG4gIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgIC8vIHJldXNlIHRhZyBjbGFzcyBmb3IgYXR0cmlidXRlIHZhbHVlIGlmIGF2YWlsYWJsZVxuICAgIHZhciB2YWx1ZVRhZ0NsYXNzID0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORztcbiAgICBpZigndmFsdWVUYWdDbGFzcycgaW4gYXR0cikge1xuICAgICAgdmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVUYWdDbGFzcztcblxuICAgICAgaWYodmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gRklYTUU6IGhhbmRsZSBtb3JlIGVuY29kaW5nc1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgc2V0IGlzIGFuIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZSBmaXJzdFxuICAgIC8vIGNvbnRhaW5pbmcgdGhlIHR5cGUgKGFuIE9JRCkgYW5kIHNlY29uZCB0aGUgdmFsdWVcbiAgICBzZXQgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKGF0dHIudHlwZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIEF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCB2YWx1ZVRhZ0NsYXNzLCBmYWxzZSwgdmFsdWUpXG4gICAgICBdKVxuICAgIF0pO1xuICAgIHJ2YWwudmFsdWUucHVzaChzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogR2V0cyBhbGwgcHJpbnRhYmxlIGF0dHJpYnV0ZXMgKHR5cGljYWxseSBvZiBhbiBpc3N1ZXIgb3Igc3ViamVjdCkgaW4gYVxuICogc2ltcGxpZmllZCBKU09OIGZvcm1hdCBmb3IgZGlzcGxheS5cbiAqXG4gKiBAcGFyYW0gYXR0cnMgdGhlIGF0dHJpYnV0ZXMuXG4gKlxuICogQHJldHVybiB0aGUgSlNPTiBmb3IgZGlzcGxheS5cbiAqL1xuZnVuY3Rpb24gX2dldEF0dHJpYnV0ZXNBc0pzb24oYXR0cnMpIHtcbiAgdmFyIHJ2YWwgPSB7fTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZihhdHRyLnNob3J0TmFtZSAmJiAoXG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5VVEY4IHx8XG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5QUklOVEFCTEVTVFJJTkcgfHxcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLklBNVNUUklORykpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICBpZihhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KGF0dHIudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYoIShhdHRyLnNob3J0TmFtZSBpbiBydmFsKSkge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmKGZvcmdlLnV0aWwuaXNBcnJheShydmFsW2F0dHIuc2hvcnROYW1lXSkpIHtcbiAgICAgICAgcnZhbFthdHRyLnNob3J0TmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXSA9IFtydmFsW2F0dHIuc2hvcnROYW1lXSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBGaWxscyBpbiBtaXNzaW5nIGZpZWxkcyBpbiBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSBhdHRycyB0aGUgYXR0cmlidXRlcyB0byBmaWxsIG1pc3NpbmcgZmllbGRzIGluLlxuICovXG5mdW5jdGlvbiBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpIHtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcblxuICAgIC8vIHBvcHVsYXRlIG1pc3NpbmcgbmFtZVxuICAgIGlmKHR5cGVvZiBhdHRyLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZihhdHRyLnR5cGUgJiYgYXR0ci50eXBlIGluIHBraS5vaWRzKSB7XG4gICAgICAgIGF0dHIubmFtZSA9IHBraS5vaWRzW2F0dHIudHlwZV07XG4gICAgICB9IGVsc2UgaWYoYXR0ci5zaG9ydE5hbWUgJiYgYXR0ci5zaG9ydE5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gcGtpLm9pZHNbX3Nob3J0TmFtZXNbYXR0ci5zaG9ydE5hbWVdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3B1bGF0ZSBtaXNzaW5nIHR5cGUgKE9JRClcbiAgICBpZih0eXBlb2YgYXR0ci50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYoYXR0ci5uYW1lICYmIGF0dHIubmFtZSBpbiBwa2kub2lkcykge1xuICAgICAgICBhdHRyLnR5cGUgPSBwa2kub2lkc1thdHRyLm5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdBdHRyaWJ1dGUgdHlwZSBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgICBlcnJvci5hdHRyaWJ1dGUgPSBhdHRyO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3B1bGF0ZSBtaXNzaW5nIHNob3J0bmFtZVxuICAgIGlmKHR5cGVvZiBhdHRyLnNob3J0TmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmKGF0dHIubmFtZSAmJiBhdHRyLm5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgYXR0ci5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1thdHRyLm5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZXh0ZW5zaW9ucyB0byB2YWx1ZVxuICAgIGlmKGF0dHIudHlwZSA9PT0gb2lkcy5leHRlbnNpb25SZXF1ZXN0KSB7XG4gICAgICBhdHRyLnZhbHVlQ29uc3RydWN0ZWQgPSB0cnVlO1xuICAgICAgYXR0ci52YWx1ZVRhZ0NsYXNzID0gYXNuMS5UeXBlLlNFUVVFTkNFO1xuICAgICAgaWYoIWF0dHIudmFsdWUgJiYgYXR0ci5leHRlbnNpb25zKSB7XG4gICAgICAgIGF0dHIudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgYXR0ci5leHRlbnNpb25zLmxlbmd0aDsgKytlaSkge1xuICAgICAgICAgIGF0dHIudmFsdWUucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEoXG4gICAgICAgICAgICBfZmlsbE1pc3NpbmdFeHRlbnNpb25GaWVsZHMoYXR0ci5leHRlbnNpb25zW2VpXSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiBhdHRyLnZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdBdHRyaWJ1dGUgdmFsdWUgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgIGVycm9yLmF0dHJpYnV0ZSA9IGF0dHI7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGaWxscyBpbiBtaXNzaW5nIGZpZWxkcyBpbiBjZXJ0aWZpY2F0ZSBleHRlbnNpb25zLlxuICpcbiAqIEBwYXJhbSBlIHRoZSBleHRlbnNpb24uXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIFtjZXJ0XSB0aGUgY2VydGlmaWNhdGUgdGhlIGV4dGVuc2lvbnMgYXJlIGZvci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHRlbnNpb24uXG4gKi9cbmZ1bmN0aW9uIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvcHVsYXRlIG1pc3NpbmcgbmFtZVxuICBpZih0eXBlb2YgZS5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKGUuaWQgJiYgZS5pZCBpbiBwa2kub2lkcykge1xuICAgICAgZS5uYW1lID0gcGtpLm9pZHNbZS5pZF07XG4gICAgfVxuICB9XG5cbiAgLy8gcG9wdWxhdGUgbWlzc2luZyBpZFxuICBpZih0eXBlb2YgZS5pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZihlLm5hbWUgJiYgZS5uYW1lIGluIHBraS5vaWRzKSB7XG4gICAgICBlLmlkID0gcGtpLm9pZHNbZS5uYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFeHRlbnNpb24gSUQgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgIGVycm9yLmV4dGVuc2lvbiA9IGU7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBpZih0eXBlb2YgZS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBtaXNzaW5nIHZhbHVlOlxuXG4gIC8vIHZhbHVlIGlzIGEgQklUIFNUUklOR1xuICBpZihlLm5hbWUgPT09ICdrZXlVc2FnZScpIHtcbiAgICAvLyBidWlsZCBmbGFnc1xuICAgIHZhciB1bnVzZWQgPSAwO1xuICAgIHZhciBiMiA9IDB4MDA7XG4gICAgdmFyIGIzID0gMHgwMDtcbiAgICBpZihlLmRpZ2l0YWxTaWduYXR1cmUpIHtcbiAgICAgIGIyIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cbiAgICBpZihlLm5vblJlcHVkaWF0aW9uKSB7XG4gICAgICBiMiB8PSAweDQwO1xuICAgICAgdW51c2VkID0gNjtcbiAgICB9XG4gICAgaWYoZS5rZXlFbmNpcGhlcm1lbnQpIHtcbiAgICAgIGIyIHw9IDB4MjA7XG4gICAgICB1bnVzZWQgPSA1O1xuICAgIH1cbiAgICBpZihlLmRhdGFFbmNpcGhlcm1lbnQpIHtcbiAgICAgIGIyIHw9IDB4MTA7XG4gICAgICB1bnVzZWQgPSA0O1xuICAgIH1cbiAgICBpZihlLmtleUFncmVlbWVudCkge1xuICAgICAgYjIgfD0gMHgwODtcbiAgICAgIHVudXNlZCA9IDM7XG4gICAgfVxuICAgIGlmKGUua2V5Q2VydFNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MDQ7XG4gICAgICB1bnVzZWQgPSAyO1xuICAgIH1cbiAgICBpZihlLmNSTFNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MDI7XG4gICAgICB1bnVzZWQgPSAxO1xuICAgIH1cbiAgICBpZihlLmVuY2lwaGVyT25seSkge1xuICAgICAgYjIgfD0gMHgwMTtcbiAgICAgIHVudXNlZCA9IDA7XG4gICAgfVxuICAgIGlmKGUuZGVjaXBoZXJPbmx5KSB7XG4gICAgICBiMyB8PSAweDgwO1xuICAgICAgdW51c2VkID0gNztcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYml0IHN0cmluZ1xuICAgIHZhciB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodW51c2VkKTtcbiAgICBpZihiMyAhPT0gMCkge1xuICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiMikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGIzKTtcbiAgICB9IGVsc2UgaWYoYjIgIT09IDApIHtcbiAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjIpO1xuICAgIH1cbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgLy8gYmFzaWNDb25zdHJhaW50cyBpcyBhIFNFUVVFTkNFXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgIC8vIGNBIEJPT0xFQU4gZmxhZyBkZWZhdWx0cyB0byBmYWxzZVxuICAgIGlmKGUuY0EpIHtcbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CT09MRUFOLCBmYWxzZSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGKSkpO1xuICAgIH1cbiAgICBpZigncGF0aExlbkNvbnN0cmFpbnQnIGluIGUpIHtcbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoZS5wYXRoTGVuQ29uc3RyYWludCkuZ2V0Qnl0ZXMoKSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2V4dEtleVVzYWdlJykge1xuICAgIC8vIGV4dEtleVVzYWdlIGlzIGEgU0VRVUVOQ0Ugb2YgT0lEc1xuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcbiAgICBmb3IodmFyIGtleSBpbiBlKSB7XG4gICAgICBpZihlW2tleV0gIT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBrZXkgaXMgbmFtZSBpbiBPSUQgbWFwXG4gICAgICBpZihrZXkgaW4gb2lkcykge1xuICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSwgYXNuMS5vaWRUb0RlcihvaWRzW2tleV0pLmdldEJ5dGVzKCkpKTtcbiAgICAgIH0gZWxzZSBpZihrZXkuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAvLyBhc3N1bWUga2V5IGlzIGFuIE9JRFxuICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSwgYXNuMS5vaWRUb0RlcihrZXkpLmdldEJ5dGVzKCkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICduc0NlcnRUeXBlJykge1xuICAgIC8vIG5zQ2VydFR5cGUgaXMgYSBCSVQgU1RSSU5HXG4gICAgLy8gYnVpbGQgZmxhZ3NcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICB2YXIgYjIgPSAweDAwO1xuXG4gICAgaWYoZS5jbGllbnQpIHtcbiAgICAgIGIyIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cbiAgICBpZihlLnNlcnZlcikge1xuICAgICAgYjIgfD0gMHg0MDtcbiAgICAgIHVudXNlZCA9IDY7XG4gICAgfVxuICAgIGlmKGUuZW1haWwpIHtcbiAgICAgIGIyIHw9IDB4MjA7XG4gICAgICB1bnVzZWQgPSA1O1xuICAgIH1cbiAgICBpZihlLm9ianNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MTA7XG4gICAgICB1bnVzZWQgPSA0O1xuICAgIH1cbiAgICBpZihlLnJlc2VydmVkKSB7XG4gICAgICBiMiB8PSAweDA4O1xuICAgICAgdW51c2VkID0gMztcbiAgICB9XG4gICAgaWYoZS5zc2xDQSkge1xuICAgICAgYjIgfD0gMHgwNDtcbiAgICAgIHVudXNlZCA9IDI7XG4gICAgfVxuICAgIGlmKGUuZW1haWxDQSkge1xuICAgICAgYjIgfD0gMHgwMjtcbiAgICAgIHVudXNlZCA9IDE7XG4gICAgfVxuICAgIGlmKGUub2JqQ0EpIHtcbiAgICAgIGIyIHw9IDB4MDE7XG4gICAgICB1bnVzZWQgPSAwO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBiaXQgc3RyaW5nXG4gICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bnVzZWQpO1xuICAgIGlmKGIyICE9PSAwKSB7XG4gICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIyKTtcbiAgICB9XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICdzdWJqZWN0QWx0TmFtZScgfHwgZS5uYW1lID09PSAnaXNzdWVyQWx0TmFtZScpIHtcbiAgICAvLyBTWU5UQVggU0VRVUVOQ0VcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gICAgdmFyIGFsdE5hbWU7XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IGUuYWx0TmFtZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGFsdE5hbWUgPSBlLmFsdE5hbWVzW25dO1xuICAgICAgdmFyIHZhbHVlID0gYWx0TmFtZS52YWx1ZTtcbiAgICAgIC8vIGhhbmRsZSBJUFxuICAgICAgaWYoYWx0TmFtZS50eXBlID09PSA3ICYmIGFsdE5hbWUuaXApIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmJ5dGVzRnJvbUlQKGFsdE5hbWUuaXApO1xuICAgICAgICBpZih2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdFeHRlbnNpb24gXCJpcFwiIHZhbHVlIGlzIG5vdCBhIHZhbGlkIElQdjQgb3IgSVB2NiBhZGRyZXNzLicpO1xuICAgICAgICAgIGVycm9yLmV4dGVuc2lvbiA9IGU7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihhbHROYW1lLnR5cGUgPT09IDgpIHtcbiAgICAgICAgLy8gaGFuZGxlIE9JRFxuICAgICAgICBpZihhbHROYW1lLm9pZCkge1xuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcihhc24xLm9pZFRvRGVyKGFsdE5hbWUub2lkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVwcmVjYXRlZCAuLi4gY29udmVydCB2YWx1ZSB0byBPSURcbiAgICAgICAgICB2YWx1ZSA9IGFzbjEub2lkVG9EZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlLnZhbHVlLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgYWx0TmFtZS50eXBlLCBmYWxzZSxcbiAgICAgICAgdmFsdWUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICdzdWJqZWN0S2V5SWRlbnRpZmllcicgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgdmFyIHNraSA9IG9wdGlvbnMuY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCk7XG4gICAgZS5zdWJqZWN0S2V5SWRlbnRpZmllciA9IHNraS50b0hleCgpO1xuICAgIC8vIE9DVEVUU1RSSU5HIHcvZGlnZXN0XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNraS5nZXRCeXRlcygpKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2F1dGhvcml0eUtleUlkZW50aWZpZXInICYmIG9wdGlvbnMuY2VydCkge1xuICAgIC8vIFNZTlRBWCBTRVFVRU5DRVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgdmFyIHNlcSA9IGUudmFsdWUudmFsdWU7XG5cbiAgICBpZihlLmtleUlkZW50aWZpZXIpIHtcbiAgICAgIHZhciBrZXlJZGVudGlmaWVyID0gKGUua2V5SWRlbnRpZmllciA9PT0gdHJ1ZSA/XG4gICAgICAgIG9wdGlvbnMuY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKSA6XG4gICAgICAgIGUua2V5SWRlbnRpZmllcik7XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCBmYWxzZSwga2V5SWRlbnRpZmllcikpO1xuICAgIH1cblxuICAgIGlmKGUuYXV0aG9yaXR5Q2VydElzc3Vlcikge1xuICAgICAgdmFyIGF1dGhvcml0eUNlcnRJc3N1ZXIgPSBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgNCwgdHJ1ZSwgW1xuICAgICAgICAgIF9kblRvQXNuMShlLmF1dGhvcml0eUNlcnRJc3N1ZXIgPT09IHRydWUgP1xuICAgICAgICAgICAgb3B0aW9ucy5jZXJ0Lmlzc3VlciA6IGUuYXV0aG9yaXR5Q2VydElzc3VlcilcbiAgICAgICAgXSlcbiAgICAgIF07XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBhdXRob3JpdHlDZXJ0SXNzdWVyKSk7XG4gICAgfVxuXG4gICAgaWYoZS5zZXJpYWxOdW1iZXIpIHtcbiAgICAgIHZhciBzZXJpYWxOdW1iZXIgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoZS5zZXJpYWxOdW1iZXIgPT09IHRydWUgP1xuICAgICAgICBvcHRpb25zLmNlcnQuc2VyaWFsTnVtYmVyIDogZS5zZXJpYWxOdW1iZXIpO1xuICAgICAgc2VxLnB1c2goXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgZmFsc2UsIHNlcmlhbE51bWJlcikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKSB7XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcblxuICAgIC8vIENyZWF0ZSBzdWIgU0VRVUVOQ0Ugb2YgRGlzdHJpYnV0aW9uUG9pbnROYW1lXG4gICAgdmFyIHN1YlNlcSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcblxuICAgIC8vIENyZWF0ZSBmdWxsTmFtZSBDSE9JQ0VcbiAgICB2YXIgZnVsbE5hbWVHZW5lcmFsTmFtZXMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcbiAgICB2YXIgYWx0TmFtZTtcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgZS5hbHROYW1lcy5sZW5ndGg7ICsrbikge1xuICAgICAgYWx0TmFtZSA9IGUuYWx0TmFtZXNbbl07XG4gICAgICB2YXIgdmFsdWUgPSBhbHROYW1lLnZhbHVlO1xuICAgICAgLy8gaGFuZGxlIElQXG4gICAgICBpZihhbHROYW1lLnR5cGUgPT09IDcgJiYgYWx0TmFtZS5pcCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuYnl0ZXNGcm9tSVAoYWx0TmFtZS5pcCk7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4dGVuc2lvbiBcImlwXCIgdmFsdWUgaXMgbm90IGEgdmFsaWQgSVB2NCBvciBJUHY2IGFkZHJlc3MuJyk7XG4gICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGFsdE5hbWUudHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBoYW5kbGUgT0lEXG4gICAgICAgIGlmKGFsdE5hbWUub2lkKSB7XG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKGFzbjEub2lkVG9EZXIoYWx0TmFtZS5vaWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZXByZWNhdGVkIC4uLiBjb252ZXJ0IHZhbHVlIHRvIE9JRFxuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bGxOYW1lR2VuZXJhbE5hbWVzLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgYWx0TmFtZS50eXBlLCBmYWxzZSxcbiAgICAgICAgdmFsdWUpKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gdGhlIHBhcmVudCBTRVFVRU5DRVxuICAgIHN1YlNlcS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW2Z1bGxOYW1lR2VuZXJhbE5hbWVzXSkpO1xuICAgIHNlcS5wdXNoKHN1YlNlcSk7XG4gIH1cblxuICAvLyBlbnN1cmUgdmFsdWUgaGFzIGJlZW4gZGVmaW5lZCBieSBub3dcbiAgaWYodHlwZW9mIGUudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFeHRlbnNpb24gdmFsdWUgbm90IHNwZWNpZmllZC4nKTtcbiAgICBlcnJvci5leHRlbnNpb24gPSBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBvYmplY3QgdG8gQVNOLjFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2lkIFNpZ25hdHVyZSBhbGdvcml0aG0gT0lEXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBzaWduYXR1cmUgcGFyYW1ldHJzIG9iamVjdFxuICogQHJldHVybiBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIF9zaWduYXR1cmVQYXJhbWV0ZXJzVG9Bc24xKG9pZCwgcGFyYW1zKSB7XG4gIHN3aXRjaChvaWQpIHtcbiAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICBpZihwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFydHMucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgXSlcbiAgICAgIF0pKTtcbiAgICB9XG5cbiAgICBpZihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIF0pKTtcbiAgICB9XG5cbiAgICBpZihwYXJhbXMuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKHBhcmFtcy5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpKVxuICAgICAgXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBwYXJ0cyk7XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QncyBhdHRyaWJ1dGVzIHRvIGFuIEFTTi4xIHNldCBvZlxuICogQ1JJQXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0gY3NyIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBzZXQgb2YgQ1JJQXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gX0NSSUF0dHJpYnV0ZXNUb0FzbjEoY3NyKSB7XG4gIC8vIGNyZWF0ZSBhbiBlbXB0eSBjb250ZXh0LXNwZWNpZmljIGNvbnRhaW5lclxuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW10pO1xuXG4gIC8vIG5vIGF0dHJpYnV0ZXMsIHJldHVybiBlbXB0eSBjb250YWluZXJcbiAgaWYoY3NyLmF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cblxuICAvLyBlYWNoIGF0dHJpYnV0ZSBoYXMgYSBzZXF1ZW5jZSB3aXRoIGEgdHlwZSBhbmQgYSBzZXQgb2YgdmFsdWVzXG4gIHZhciBhdHRycyA9IGNzci5hdHRyaWJ1dGVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG5cbiAgICAvLyByZXVzZSB0YWcgY2xhc3MgZm9yIGF0dHJpYnV0ZSB2YWx1ZSBpZiBhdmFpbGFibGVcbiAgICB2YXIgdmFsdWVUYWdDbGFzcyA9IGFzbjEuVHlwZS5VVEY4O1xuICAgIGlmKCd2YWx1ZVRhZ0NsYXNzJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuICAgIH1cbiAgICBpZih2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgodmFsdWUpO1xuICAgIH1cbiAgICB2YXIgdmFsdWVDb25zdHJ1Y3RlZCA9IGZhbHNlO1xuICAgIGlmKCd2YWx1ZUNvbnN0cnVjdGVkJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZUNvbnN0cnVjdGVkID0gYXR0ci52YWx1ZUNvbnN0cnVjdGVkO1xuICAgIH1cbiAgICAvLyBGSVhNRTogaGFuZGxlIG1vcmUgZW5jb2RpbmdzXG5cbiAgICAvLyBjcmVhdGUgYSBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIHNldFxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIHNldCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgZmlyc3RcbiAgICAvLyBjb250YWluaW5nIHRoZSB0eXBlIChhbiBPSUQpIGFuZCBzZWNvbmQgdGhlIHZhbHVlXG4gICAgdmFyIHNlcSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIEF0dHJpYnV0ZVR5cGVcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0RlcihhdHRyLnR5cGUpLmdldEJ5dGVzKCkpLFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVQsIHRydWUsIFtcbiAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIHZhbHVlVGFnQ2xhc3MsIHZhbHVlQ29uc3RydWN0ZWQsIHZhbHVlKVxuICAgICAgXSlcbiAgICBdKTtcbiAgICBydmFsLnZhbHVlLnB1c2goc2VxKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuXG5jb25zdCBqYW5fMV8xOTUwID0gbmV3IERhdGUoJzE5NTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5jb25zdCBqYW5fMV8yMDUwID0gbmV3IERhdGUoJzIwNTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBEYXRlIG9iamVjdCB0byBBU04uMVxuICogSGFuZGxlcyB0aGUgZGlmZmVyZW50IGZvcm1hdCBiZWZvcmUgYW5kIGFmdGVyIDFzdCBKYW51YXJ5IDIwNTBcbiAqXG4gKiBAcGFyYW0gZGF0ZSBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRlLlxuICovXG4gZnVuY3Rpb24gX2RhdGVUb0FzbjEoZGF0ZSl7XG4gIGlmKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuVVRDVElNRSwgZmFsc2UsXG4gICAgICBhc24xLmRhdGVUb1V0Y1RpbWUoZGF0ZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLCBmYWxzZSxcbiAgICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGRhdGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIEFTTi4xIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBUQlNDZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmdldFRCU0NlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICB2YXIgbm90QmVmb3JlID0gX2RhdGVUb0FzbjEoY2VydC52YWxpZGl0eS5ub3RCZWZvcmUpO1xuICB2YXIgbm90QWZ0ZXIgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKTtcbiAgdmFyIHRicyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihjZXJ0LnZlcnNpb24pLmdldEJ5dGVzKCkpXG4gICAgXSksXG4gICAgLy8gc2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhjZXJ0LnNlcmlhbE51bWJlcikpLFxuICAgIC8vIHNpZ25hdHVyZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoXG4gICAgICAgIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzKVxuICAgIF0pLFxuICAgIC8vIGlzc3VlclxuICAgIF9kblRvQXNuMShjZXJ0Lmlzc3VlciksXG4gICAgLy8gdmFsaWRpdHlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBub3RCZWZvcmUsXG4gICAgICBub3RBZnRlclxuICAgIF0pLFxuICAgIC8vIHN1YmplY3RcbiAgICBfZG5Ub0FzbjEoY2VydC5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY2VydC5wdWJsaWNLZXkpXG4gIF0pO1xuXG4gIGlmKGNlcnQuaXNzdWVyLnVuaXF1ZUlkKSB7XG4gICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBpZihjZXJ0LnN1YmplY3QudW5pcXVlSWQpIHtcbiAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZFxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBpZihjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIGV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoY2VydC5leHRlbnNpb25zKSk7XG4gIH1cblxuICByZXR1cm4gdGJzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBBU04uMSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZiBhXG4gKiBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5cbiAqL1xucGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cbiAgdmFyIGNyaSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKGNzci52ZXJzaW9uKS5nZXRCeXRlcygpKSxcbiAgICAvLyBzdWJqZWN0XG4gICAgX2RuVG9Bc24xKGNzci5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY3NyLnB1YmxpY0tleSksXG4gICAgLy8gYXR0cmlidXRlc1xuICAgIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcilcbiAgXSk7XG5cbiAgcmV0dXJuIGNyaTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBEaXN0aW5ndWlzaGVkTmFtZSAoc3ViamVjdCBvciBpc3N1ZXIpIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZG4gdGhlIERpc3Rpbmd1aXNoZWROYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBEaXN0aW5ndWlzaGVkTmFtZS5cbiAqL1xucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xID0gZnVuY3Rpb24oZG4pIHtcbiAgcmV0dXJuIF9kblRvQXNuMShkbik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5djMgUlNBIGNlcnRpZmljYXRlIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlVG9Bc24xID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBwcmVmZXIgY2FjaGVkIFRCU0NlcnRpZmljYXRlIG92ZXIgZ2VuZXJhdGluZyBvbmVcbiAgdmFyIHRic0NlcnRpZmljYXRlID0gY2VydC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG5cbiAgLy8gQ2VydGlmaWNhdGVcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICAgIHRic0NlcnRpZmljYXRlLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY2VydC5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoY2VydC5zaWduYXR1cmVPaWQsIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgKyBjZXJ0LnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIFguNTA5djMgY2VydGlmaWNhdGUgZXh0ZW5zaW9ucyB0byBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbnMgaW4gQVNOLjEgZm9ybWF0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zVG9Bc24xID0gZnVuY3Rpb24oZXh0cykge1xuICAvLyBjcmVhdGUgdG9wLWxldmVsIGV4dGVuc2lvbiBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDMsIHRydWUsIFtdKTtcblxuICAvLyBjcmVhdGUgZXh0ZW5zaW9uIHNlcXVlbmNlIChzdG9yZXMgYSBzZXF1ZW5jZSBmb3IgZWFjaCBleHRlbnNpb24pXG4gIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHJ2YWwudmFsdWUucHVzaChzZXEpO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgc2VxLnZhbHVlLnB1c2gocGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xKGV4dHNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gdG8gQVNOLjEuXG4gKlxuICogQHBhcmFtIGV4dCB0aGUgZXh0ZW5zaW9uIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIGluIEFTTi4xIGZvcm1hdC5cbiAqL1xucGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGNyZWF0ZSBhIHNlcXVlbmNlIGZvciBlYWNoIGV4dGVuc2lvblxuICB2YXIgZXh0c2VxID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGV4dG5JRCAoT0lEKVxuICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgYXNuMS5vaWRUb0RlcihleHQuaWQpLmdldEJ5dGVzKCkpKTtcblxuICAvLyBjcml0aWNhbCBkZWZhdWx0cyB0byBmYWxzZVxuICBpZihleHQuY3JpdGljYWwpIHtcbiAgICAvLyBjcml0aWNhbCBCT09MRUFOIERFRkFVTFQgRkFMU0VcbiAgICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQk9PTEVBTiwgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBleHQudmFsdWU7XG4gIGlmKHR5cGVvZiBleHQudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUgaXMgYXNuLjFcbiAgICB2YWx1ZSA9IGFzbjEudG9EZXIodmFsdWUpLmdldEJ5dGVzKCk7XG4gIH1cblxuICAvLyBleHRuVmFsdWUgKE9DVEVUIFNUUklORylcbiAgZXh0c2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIGV4dHNlcTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCB0byBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBwcmVmZXIgY2FjaGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBvdmVyIGdlbmVyYXRpbmcgb25lXG4gIHZhciBjcmkgPSBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHx8XG4gICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuXG4gIC8vIENlcnRpZmljYXRlXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXG4gICAgY3JpLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY3NyLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzXG4gICAgICBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShjc3Iuc2lnbmF0dXJlT2lkLCBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBzaWduYXR1cmVcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApICsgY3NyLnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDQSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gY2VydHMgYW4gb3B0aW9uYWwgYXJyYXkgb2YgY2VydGlmaWNhdGUgb2JqZWN0cyBvciBQRU0tZm9ybWF0dGVkXG4gKiAgICAgICAgICBjZXJ0aWZpY2F0ZSBzdHJpbmdzIHRvIGFkZCB0byB0aGUgQ0Egc3RvcmUuXG4gKlxuICogQHJldHVybiB0aGUgQ0Egc3RvcmUuXG4gKi9cbnBraS5jcmVhdGVDYVN0b3JlID0gZnVuY3Rpb24oY2VydHMpIHtcbiAgLy8gY3JlYXRlIENBIHN0b3JlXG4gIHZhciBjYVN0b3JlID0ge1xuICAgIC8vIHN0b3JlZCBjZXJ0aWZpY2F0ZXNcbiAgICBjZXJ0czoge31cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY2VydGlmaWNhdGUgdGhhdCBpc3N1ZWQgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSBvciBpdHNcbiAgICogJ3BhcmVudCcuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBvciBudWxsIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cbiAgY2FTdG9yZS5nZXRJc3N1ZXIgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJ2YWwgPSBnZXRCeVN1YmplY3QoY2VydC5pc3N1ZXIpO1xuXG4gICAgLy8gc2VlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzXG4gICAgLyppZihmb3JnZS51dGlsLmlzQXJyYXkocnZhbCkpIHtcbiAgICAgIC8vIFRPRE86IHJlc29sdmUgbXVsdGlwbGUgbWF0Y2hlcyBieSBjaGVja2luZ1xuICAgICAgLy8gYXV0aG9yaXR5S2V5L3N1YmplY3RLZXkvaXNzdWVyVW5pcXVlSUQvb3RoZXIgaWRlbnRpZmllcnMsIGV0Yy5cbiAgICAgIC8vIEZJWE1FOiBvciBhbHRlcm5hdGl2ZWx5IGRvIGF1dGhvcml0eSBrZXkgbWFwcGluZ1xuICAgICAgLy8gaWYgcG9zc2libGUgKFguNTA5djEgY2VydHMgY2FuJ3Qgd29yaz8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBtdWx0aXBsZSBpc3N1ZXIgbWF0Y2hlcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH0qL1xuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0cnVzdGVkIGNlcnRpZmljYXRlIHRvIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGFkZCBhcyBhIHRydXN0ZWQgY2VydGlmaWNhdGUgKGVpdGhlciBhXG4gICAqICAgICAgICAgIHBraS5jZXJ0aWZpY2F0ZSBvYmplY3Qgb3IgYSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICovXG4gIGNhU3RvcmUuYWRkQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkgeyAgLy8gYXZvaWQgZHVwbGljYXRlIGNlcnRpZmljYXRlcyBpbiBzdG9yZVxuICAgICAgaWYoY2VydC5zdWJqZWN0Lmhhc2ggaW4gY2FTdG9yZS5jZXJ0cykge1xuICAgICAgICAvLyBzdWJqZWN0IGhhc2ggYWxyZWFkeSBleGlzdHMsIGFwcGVuZCB0byBhcnJheVxuICAgICAgICB2YXIgdG1wID0gY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkodG1wKSkge1xuICAgICAgICAgIHRtcCA9IFt0bXBdO1xuICAgICAgICB9XG4gICAgICAgIHRtcC5wdXNoKGNlcnQpO1xuICAgICAgICBjYVN0b3JlLmNlcnRzW2NlcnQuc3ViamVjdC5oYXNoXSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdID0gY2VydDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIGdpdmVuIGNlcnRpZmljYXRlIGlzIGluIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGNoZWNrIChlaXRoZXIgYSBwa2kuY2VydGlmaWNhdGUgb3IgYVxuICAgKiAgICAgICAgICBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBpbiB0aGUgc3RvcmUsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNhU3RvcmUuaGFzQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGdldEJ5U3ViamVjdChjZXJ0LnN1YmplY3QpO1xuICAgIGlmKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgbWF0Y2ggPSBbbWF0Y2hdO1xuICAgIH1cbiAgICAvLyBjb21wYXJlIERFUi1lbmNvZGluZyBvZiBjZXJ0aWZpY2F0ZXNcbiAgICB2YXIgZGVyMSA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKGNlcnQpKS5nZXRCeXRlcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGRlcjIgPSBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShtYXRjaFtpXSkpLmdldEJ5dGVzKCk7XG4gICAgICBpZihkZXIxID09PSBkZXIyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBvZiB0aGUgY2VydGlmaWNhdGVzIGtlcHQgaW4gdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUgcGtpLmNlcnRpZmljYXRlIG9iamVjdHMgaW4gdGhlIHN0b3JlLlxuICAgKi9cbiAgY2FTdG9yZS5saXN0QWxsQ2VydGlmaWNhdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNlcnRMaXN0ID0gW107XG5cbiAgICBmb3IodmFyIGhhc2ggaW4gY2FTdG9yZS5jZXJ0cykge1xuICAgICAgaWYoY2FTdG9yZS5jZXJ0cy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjYVN0b3JlLmNlcnRzW2hhc2hdO1xuICAgICAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGNlcnRMaXN0LnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlcnRMaXN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2VydGlmaWNhdGUgZnJvbSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byByZW1vdmUgKGVpdGhlciBhIHBraS5jZXJ0aWZpY2F0ZSBvciBhXG4gICAqICAgICAgICAgIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZSB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwgaWYgdGhlIGNlcnRpZmljYXRlXG4gICAqICAgICAgICAgICB3YXNuJ3QgaW4gc3RvcmUuXG4gICAqL1xuICBjYVN0b3JlLnJlbW92ZUNlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBjb252ZXJ0IGZyb20gcGVtIGlmIG5lY2Vzc2FyeVxuICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2VydCA9IGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgfVxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG4gICAgaWYoIWNhU3RvcmUuaGFzQ2VydGlmaWNhdGUoY2VydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGdldEJ5U3ViamVjdChjZXJ0LnN1YmplY3QpO1xuXG4gICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShtYXRjaCkpIHtcbiAgICAgIHJlc3VsdCA9IGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgICAgZGVsZXRlIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIERFUi1lbmNvZGluZyBvZiBjZXJ0aWZpY2F0ZXNcbiAgICB2YXIgZGVyMSA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKGNlcnQpKS5nZXRCeXRlcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGRlcjIgPSBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShtYXRjaFtpXSkpLmdldEJ5dGVzKCk7XG4gICAgICBpZihkZXIxID09PSBkZXIyKSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGNoW2ldO1xuICAgICAgICBtYXRjaC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG1hdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QnlTdWJqZWN0KHN1YmplY3QpIHtcbiAgICBlbnN1cmVTdWJqZWN0SGFzSGFzaChzdWJqZWN0KTtcbiAgICByZXR1cm4gY2FTdG9yZS5jZXJ0c1tzdWJqZWN0Lmhhc2hdIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdWJqZWN0SGFzSGFzaChzdWJqZWN0KSB7XG4gICAgLy8gcHJvZHVjZSBzdWJqZWN0IGhhc2ggaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmKCFzdWJqZWN0Lmhhc2gpIHtcbiAgICAgIHZhciBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBzdWJqZWN0LmF0dHJpYnV0ZXMgPSAgcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KF9kblRvQXNuMShzdWJqZWN0KSwgbWQpO1xuICAgICAgc3ViamVjdC5oYXNoID0gbWQuZGlnZXN0KCkudG9IZXgoKTtcbiAgICB9XG4gIH1cblxuICAvLyBhdXRvLWFkZCBwYXNzZWQgaW4gY2VydHNcbiAgaWYoY2VydHMpIHtcbiAgICAvLyBwYXJzZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlcyBhcyBuZWNlc3NhcnlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2VydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjZXJ0ID0gY2VydHNbaV07XG4gICAgICBjYVN0b3JlLmFkZENlcnRpZmljYXRlKGNlcnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYVN0b3JlO1xufTtcblxuLyoqXG4gKiBDZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24gZXJyb3JzLCBiYXNlZCBvbiBUTFMuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUVycm9yID0ge1xuICBiYWRfY2VydGlmaWNhdGU6ICdmb3JnZS5wa2kuQmFkQ2VydGlmaWNhdGUnLFxuICB1bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZTogJ2ZvcmdlLnBraS5VbnN1cHBvcnRlZENlcnRpZmljYXRlJyxcbiAgY2VydGlmaWNhdGVfcmV2b2tlZDogJ2ZvcmdlLnBraS5DZXJ0aWZpY2F0ZVJldm9rZWQnLFxuICBjZXJ0aWZpY2F0ZV9leHBpcmVkOiAnZm9yZ2UucGtpLkNlcnRpZmljYXRlRXhwaXJlZCcsXG4gIGNlcnRpZmljYXRlX3Vua25vd246ICdmb3JnZS5wa2kuQ2VydGlmaWNhdGVVbmtub3duJyxcbiAgdW5rbm93bl9jYTogJ2ZvcmdlLnBraS5Vbmtub3duQ2VydGlmaWNhdGVBdXRob3JpdHknXG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGEgY2VydGlmaWNhdGUgY2hhaW4gYWdhaW5zdCB0aGUgZ2l2ZW4gQ2VydGlmaWNhdGUgQXV0aG9yaXR5IHN0b3JlXG4gKiB3aXRoIGFuIG9wdGlvbmFsIGN1c3RvbSB2ZXJpZnkgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIGNhU3RvcmUgYSBjZXJ0aWZpY2F0ZSBzdG9yZSB0byB2ZXJpZnkgYWdhaW5zdC5cbiAqIEBwYXJhbSBjaGFpbiB0aGUgY2VydGlmaWNhdGUgY2hhaW4gdG8gdmVyaWZ5LCB3aXRoIHRoZSByb290IG9yIGhpZ2hlc3RcbiAqICAgICAgICAgIGF1dGhvcml0eSBhdCB0aGUgZW5kIChhbiBhcnJheSBvZiBjZXJ0aWZpY2F0ZXMpLlxuICogQHBhcmFtIHZlcmlmeSBjYWxsZWQgZm9yIGV2ZXJ5IGNlcnRpZmljYXRlIGluIHRoZSBjaGFpbi5cbiAqXG4gKiBUaGUgdmVyaWZ5IGNhbGxiYWNrIGhhcyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqXG4gKiB2ZXJpZmllZCAtIFNldCB0byB0cnVlIGlmIGNlcnRpZmljYXRlIHdhcyB2ZXJpZmllZCwgb3RoZXJ3aXNlIHRoZVxuICogICBwa2kuY2VydGlmaWNhdGVFcnJvciBmb3Igd2h5IHRoZSBjZXJ0aWZpY2F0ZSBmYWlsZWQuXG4gKiBkZXB0aCAtIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBjaGFpbiwgd2hlcmUgMCBpcyB0aGUgZW5kIHBvaW50J3MgY2VydC5cbiAqIGNlcnRzIC0gVGhlIGNlcnRpZmljYXRlIGNoYWluLCAqTk9URSogYW4gZW1wdHkgY2hhaW4gaW5kaWNhdGVzIGFuIGFub255bW91c1xuICogICBlbmQgcG9pbnQuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzIGFuZCBvbiBmYWlsdXJlIGVpdGhlciB0aGUgYXBwcm9wcmlhdGVcbiAqIHBraS5jZXJ0aWZpY2F0ZUVycm9yIG9yIGFuIG9iamVjdCB3aXRoICdlcnJvcicgc2V0IHRvIHRoZSBhcHByb3ByaWF0ZVxuICogcGtpLmNlcnRpZmljYXRlRXJyb3IgYW5kICdtZXNzYWdlJyBzZXQgdG8gYSBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZXJyb3IgdGhyb3duIGlmIG5vdC5cbiAqL1xucGtpLnZlcmlmeUNlcnRpZmljYXRlQ2hhaW4gPSBmdW5jdGlvbihjYVN0b3JlLCBjaGFpbiwgdmVyaWZ5KSB7XG4gIC8qIEZyb206IFJGQzMyODAgLSBJbnRlcm5ldCBYLjUwOSBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIENlcnRpZmljYXRlXG4gICAgU2VjdGlvbiA2OiBDZXJ0aWZpY2F0aW9uIFBhdGggVmFsaWRhdGlvblxuICAgIFNlZSBpbmxpbmUgcGFyZW50aGV0aWNhbHMgcmVsYXRlZCB0byB0aGlzIHBhcnRpY3VsYXIgaW1wbGVtZW50YXRpb24uXG5cbiAgICBUaGUgcHJpbWFyeSBnb2FsIG9mIHBhdGggdmFsaWRhdGlvbiBpcyB0byB2ZXJpZnkgdGhlIGJpbmRpbmcgYmV0d2VlblxuICAgIGEgc3ViamVjdCBkaXN0aW5ndWlzaGVkIG5hbWUgb3IgYSBzdWJqZWN0IGFsdGVybmF0aXZlIG5hbWUgYW5kIHN1YmplY3RcbiAgICBwdWJsaWMga2V5LCBhcyByZXByZXNlbnRlZCBpbiB0aGUgZW5kIGVudGl0eSBjZXJ0aWZpY2F0ZSwgYmFzZWQgb24gdGhlXG4gICAgcHVibGljIGtleSBvZiB0aGUgdHJ1c3QgYW5jaG9yLiBUaGlzIHJlcXVpcmVzIG9idGFpbmluZyBhIHNlcXVlbmNlIG9mXG4gICAgY2VydGlmaWNhdGVzIHRoYXQgc3VwcG9ydCB0aGF0IGJpbmRpbmcuIFRoYXQgc2VxdWVuY2Ugc2hvdWxkIGJlIHByb3ZpZGVkXG4gICAgaW4gdGhlIHBhc3NlZCAnY2hhaW4nLiBUaGUgdHJ1c3QgYW5jaG9yIHNob3VsZCBiZSBpbiB0aGUgZ2l2ZW4gQ0FcbiAgICBzdG9yZS4gVGhlICdlbmQgZW50aXR5JyBjZXJ0aWZpY2F0ZSBpcyB0aGUgY2VydGlmaWNhdGUgcHJvdmlkZWQgYnkgdGhlXG4gICAgZW5kIHBvaW50ICh0eXBpY2FsbHkgYSBzZXJ2ZXIpIGFuZCBpcyB0aGUgZmlyc3QgaW4gdGhlIGNoYWluLlxuXG4gICAgVG8gbWVldCB0aGlzIGdvYWwsIHRoZSBwYXRoIHZhbGlkYXRpb24gcHJvY2VzcyB2ZXJpZmllcywgYW1vbmcgb3RoZXJcbiAgICB0aGluZ3MsIHRoYXQgYSBwcm9zcGVjdGl2ZSBjZXJ0aWZpY2F0aW9uIHBhdGggKGEgc2VxdWVuY2Ugb2YgblxuICAgIGNlcnRpZmljYXRlcyBvciBhICdjaGFpbicpIHNhdGlzZmllcyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICAoYSkgZm9yIGFsbCB4IGluIHsxLCAuLi4sIG4tMX0sIHRoZSBzdWJqZWN0IG9mIGNlcnRpZmljYXRlIHggaXNcbiAgICAgICAgICB0aGUgaXNzdWVyIG9mIGNlcnRpZmljYXRlIHgrMTtcblxuICAgIChiKSBjZXJ0aWZpY2F0ZSAxIGlzIGlzc3VlZCBieSB0aGUgdHJ1c3QgYW5jaG9yO1xuXG4gICAgKGMpIGNlcnRpZmljYXRlIG4gaXMgdGhlIGNlcnRpZmljYXRlIHRvIGJlIHZhbGlkYXRlZDsgYW5kXG5cbiAgICAoZCkgZm9yIGFsbCB4IGluIHsxLCAuLi4sIG59LCB0aGUgY2VydGlmaWNhdGUgd2FzIHZhbGlkIGF0IHRoZVxuICAgICAgICAgIHRpbWUgaW4gcXVlc3Rpb24uXG5cbiAgICBOb3RlIHRoYXQgaGVyZSAnbicgaXMgaW5kZXggMCBpbiB0aGUgY2hhaW4gYW5kIDEgaXMgdGhlIGxhc3QgY2VydGlmaWNhdGVcbiAgICBpbiB0aGUgY2hhaW4gYW5kIGl0IG11c3QgYmUgc2lnbmVkIGJ5IGEgY2VydGlmaWNhdGUgaW4gdGhlIGNvbm5lY3Rpb24nc1xuICAgIENBIHN0b3JlLlxuXG4gICAgVGhlIHBhdGggdmFsaWRhdGlvbiBwcm9jZXNzIGFsc28gZGV0ZXJtaW5lcyB0aGUgc2V0IG9mIGNlcnRpZmljYXRlXG4gICAgcG9saWNpZXMgdGhhdCBhcmUgdmFsaWQgZm9yIHRoaXMgcGF0aCwgYmFzZWQgb24gdGhlIGNlcnRpZmljYXRlIHBvbGljaWVzXG4gICAgZXh0ZW5zaW9uLCBwb2xpY3kgbWFwcGluZyBleHRlbnNpb24sIHBvbGljeSBjb25zdHJhaW50cyBleHRlbnNpb24sIGFuZFxuICAgIGluaGliaXQgYW55LXBvbGljeSBleHRlbnNpb24uXG5cbiAgICBOb3RlOiBQb2xpY3kgbWFwcGluZyBleHRlbnNpb24gbm90IHN1cHBvcnRlZCAoTm90IFJlcXVpcmVkKS5cblxuICAgIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0ZSBoYXMgYW4gdW5zdXBwb3J0ZWQgY3JpdGljYWwgZXh0ZW5zaW9uLCB0aGVuIGl0XG4gICAgbXVzdCBiZSByZWplY3RlZC5cblxuICAgIE5vdGU6IEEgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgaWYgdGhlIEROcyB0aGF0IGFwcGVhciBpbiB0aGUgc3ViamVjdFxuICAgIGFuZCBpc3N1ZXIgZmllbGRzIGFyZSBpZGVudGljYWwgYW5kIGFyZSBub3QgZW1wdHkuXG5cbiAgICBUaGUgcGF0aCB2YWxpZGF0aW9uIGFsZ29yaXRobSBhc3N1bWVzIHRoZSBmb2xsb3dpbmcgc2V2ZW4gaW5wdXRzIGFyZVxuICAgIHByb3ZpZGVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmcgbG9naWMuIFdoYXQgdGhpcyBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuICAgIHdpbGwgdXNlIGlzIHByb3ZpZGVkIHBhcmVudGhldGljYWxseTpcblxuICAgIChhKSBhIHByb3NwZWN0aXZlIGNlcnRpZmljYXRpb24gcGF0aCBvZiBsZW5ndGggbiAodGhlICdjaGFpbicpXG4gICAgKGIpIHRoZSBjdXJyZW50IGRhdGUvdGltZTogKCdub3cnKS5cbiAgICAoYykgdXNlci1pbml0aWFsLXBvbGljeS1zZXQ6IEEgc2V0IG9mIGNlcnRpZmljYXRlIHBvbGljeSBpZGVudGlmaWVyc1xuICAgICAgICAgIG5hbWluZyB0aGUgcG9saWNpZXMgdGhhdCBhcmUgYWNjZXB0YWJsZSB0byB0aGUgY2VydGlmaWNhdGUgdXNlci5cbiAgICAgICAgICBUaGUgdXNlci1pbml0aWFsLXBvbGljeS1zZXQgY29udGFpbnMgdGhlIHNwZWNpYWwgdmFsdWUgYW55LXBvbGljeVxuICAgICAgICAgIGlmIHRoZSB1c2VyIGlzIG5vdCBjb25jZXJuZWQgYWJvdXQgY2VydGlmaWNhdGUgcG9saWN5XG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZC4gQW55IHBvbGljeSBpcyBhY2NlcHRlZCkuXG4gICAgKGQpIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvbiwgZGVzY3JpYmluZyBhIENBIHRoYXQgc2VydmVzIGFzIGEgdHJ1c3RcbiAgICAgICAgICBhbmNob3IgZm9yIHRoZSBjZXJ0aWZpY2F0aW9uIHBhdGguIFRoZSB0cnVzdCBhbmNob3IgaW5mb3JtYXRpb25cbiAgICAgICAgICBpbmNsdWRlczpcblxuICAgICAgKDEpICB0aGUgdHJ1c3RlZCBpc3N1ZXIgbmFtZSxcbiAgICAgICgyKSAgdGhlIHRydXN0ZWQgcHVibGljIGtleSBhbGdvcml0aG0sXG4gICAgICAoMykgIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXksIGFuZFxuICAgICAgKDQpICBvcHRpb25hbGx5LCB0aGUgdHJ1c3RlZCBwdWJsaWMga2V5IHBhcmFtZXRlcnMgYXNzb2NpYXRlZFxuICAgICAgICAgICAgIHdpdGggdGhlIHB1YmxpYyBrZXkuXG5cbiAgICAgIChUcnVzdCBhbmNob3JzIGFyZSBwcm92aWRlZCB2aWEgY2VydGlmaWNhdGVzIGluIHRoZSBDQSBzdG9yZSkuXG5cbiAgICAgIFRoZSB0cnVzdCBhbmNob3IgaW5mb3JtYXRpb24gbWF5IGJlIHByb3ZpZGVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmdcbiAgICAgIHByb2NlZHVyZSBpbiB0aGUgZm9ybSBvZiBhIHNlbGYtc2lnbmVkIGNlcnRpZmljYXRlLiBUaGUgdHJ1c3RlZCBhbmNob3JcbiAgICAgIGluZm9ybWF0aW9uIGlzIHRydXN0ZWQgYmVjYXVzZSBpdCB3YXMgZGVsaXZlcmVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmdcbiAgICAgIHByb2NlZHVyZSBieSBzb21lIHRydXN0d29ydGh5IG91dC1vZi1iYW5kIHByb2NlZHVyZS4gSWYgdGhlIHRydXN0ZWRcbiAgICAgIHB1YmxpYyBrZXkgYWxnb3JpdGhtIHJlcXVpcmVzIHBhcmFtZXRlcnMsIHRoZW4gdGhlIHBhcmFtZXRlcnMgYXJlXG4gICAgICBwcm92aWRlZCBhbG9uZyB3aXRoIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXkgKE5vIHBhcmFtZXRlcnMgdXNlZCBpbiB0aGlzXG4gICAgICBpbXBsZW1lbnRhdGlvbikuXG5cbiAgICAoZSkgaW5pdGlhbC1wb2xpY3ktbWFwcGluZy1pbmhpYml0LCB3aGljaCBpbmRpY2F0ZXMgaWYgcG9saWN5IG1hcHBpbmcgaXNcbiAgICAgICAgICBhbGxvd2VkIGluIHRoZSBjZXJ0aWZpY2F0aW9uIHBhdGguXG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZCwgbm8gcG9saWN5IGNoZWNraW5nKVxuXG4gICAgKGYpIGluaXRpYWwtZXhwbGljaXQtcG9saWN5LCB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIHBhdGggbXVzdCBiZSB2YWxpZFxuICAgICAgICAgIGZvciBhdCBsZWFzdCBvbmUgb2YgdGhlIGNlcnRpZmljYXRlIHBvbGljaWVzIGluIHRoZSB1c2VyLWluaXRpYWwtXG4gICAgICAgICAgcG9saWN5LXNldC5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBubyBwb2xpY3kgY2hlY2tpbmcpXG5cbiAgICAoZykgaW5pdGlhbC1hbnktcG9saWN5LWluaGliaXQsIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIHRoZVxuICAgICAgICAgIGFueVBvbGljeSBPSUQgc2hvdWxkIGJlIHByb2Nlc3NlZCBpZiBpdCBpcyBpbmNsdWRlZCBpbiBhXG4gICAgICAgICAgY2VydGlmaWNhdGUuXG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZCwgc28gYW55IHBvbGljeSBpcyB2YWxpZCBwcm92aWRlZCB0aGF0IGl0IGlzXG4gICAgICAgICAgbm90IG1hcmtlZCBhcyBjcml0aWNhbCkgKi9cblxuICAvKiBCYXNpYyBQYXRoIFByb2Nlc3Npbmc6XG5cbiAgICBGb3IgZWFjaCBjZXJ0aWZpY2F0ZSBpbiB0aGUgJ2NoYWluJywgdGhlIGZvbGxvd2luZyBpcyBjaGVja2VkOlxuXG4gICAgMS4gVGhlIGNlcnRpZmljYXRlIHZhbGlkaXR5IHBlcmlvZCBpbmNsdWRlcyB0aGUgY3VycmVudCB0aW1lLlxuICAgIDIuIFRoZSBjZXJ0aWZpY2F0ZSB3YXMgc2lnbmVkIGJ5IGl0cyBwYXJlbnQgKHdoZXJlIHRoZSBwYXJlbnQgaXMgZWl0aGVyXG4gICAgICAgdGhlIG5leHQgaW4gdGhlIGNoYWluIG9yIGZyb20gdGhlIENBIHN0b3JlKS4gQWxsb3cgcHJvY2Vzc2luZyB0b1xuICAgICAgIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHN0ZXAgaWYgbm8gcGFyZW50IGlzIGZvdW5kIGJ1dCB0aGUgY2VydGlmaWNhdGUgaXNcbiAgICAgICBpbiB0aGUgQ0Egc3RvcmUuXG4gICAgMy4gVE9ETzogVGhlIGNlcnRpZmljYXRlIGhhcyBub3QgYmVlbiByZXZva2VkLlxuICAgIDQuIFRoZSBjZXJ0aWZpY2F0ZSBpc3N1ZXIgbmFtZSBtYXRjaGVzIHRoZSBwYXJlbnQncyBzdWJqZWN0IG5hbWUuXG4gICAgNS4gVE9ETzogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHNlbGYtaXNzdWVkIGFuZCBub3QgdGhlIGZpbmFsIGNlcnRpZmljYXRlXG4gICAgICAgaW4gdGhlIGNoYWluLCBza2lwIHRoaXMgc3RlcCwgb3RoZXJ3aXNlIHZlcmlmeSB0aGF0IHRoZSBzdWJqZWN0IG5hbWVcbiAgICAgICBpcyB3aXRoaW4gb25lIG9mIHRoZSBwZXJtaXR0ZWQgc3VidHJlZXMgb2YgWC41MDAgZGlzdGluZ3Vpc2hlZCBuYW1lc1xuICAgICAgIGFuZCB0aGF0IGVhY2ggb2YgdGhlIGFsdGVybmF0aXZlIG5hbWVzIGluIHRoZSBzdWJqZWN0QWx0TmFtZSBleHRlbnNpb25cbiAgICAgICAoY3JpdGljYWwgb3Igbm9uLWNyaXRpY2FsKSBpcyB3aXRoaW4gb25lIG9mIHRoZSBwZXJtaXR0ZWQgc3VidHJlZXMgZm9yXG4gICAgICAgdGhhdCBuYW1lIHR5cGUuXG4gICAgNi4gVE9ETzogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHNlbGYtaXNzdWVkIGFuZCBub3QgdGhlIGZpbmFsIGNlcnRpZmljYXRlXG4gICAgICAgaW4gdGhlIGNoYWluLCBza2lwIHRoaXMgc3RlcCwgb3RoZXJ3aXNlIHZlcmlmeSB0aGF0IHRoZSBzdWJqZWN0IG5hbWVcbiAgICAgICBpcyBub3Qgd2l0aGluIG9uZSBvZiB0aGUgZXhjbHVkZWQgc3VidHJlZXMgZm9yIFguNTAwIGRpc3Rpbmd1aXNoZWRcbiAgICAgICBuYW1lcyBhbmQgbm9uZSBvZiB0aGUgc3ViamVjdEFsdE5hbWUgZXh0ZW5zaW9uIG5hbWVzIGFyZSBleGNsdWRlZCBmb3JcbiAgICAgICB0aGF0IG5hbWUgdHlwZS5cbiAgICA3LiBUaGUgb3RoZXIgc3RlcHMgaW4gdGhlIGFsZ29yaXRobSBmb3IgYmFzaWMgcGF0aCBwcm9jZXNzaW5nIGludm9sdmVcbiAgICAgICBoYW5kbGluZyB0aGUgcG9saWN5IGV4dGVuc2lvbiB3aGljaCBpcyBub3QgcHJlc2VudGx5IHN1cHBvcnRlZCBpbiB0aGlzXG4gICAgICAgaW1wbGVtZW50YXRpb24uIEluc3RlYWQsIGlmIGEgY3JpdGljYWwgcG9saWN5IGV4dGVuc2lvbiBpcyBmb3VuZCwgdGhlXG4gICAgICAgY2VydGlmaWNhdGUgaXMgcmVqZWN0ZWQgYXMgbm90IHN1cHBvcnRlZC5cbiAgICA4LiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgbm90IHRoZSBmaXJzdCBvciBpZiBpdHMgdGhlIG9ubHkgY2VydGlmaWNhdGUgaW5cbiAgICAgICB0aGUgY2hhaW4gKGhhdmluZyBubyBwYXJlbnQgZnJvbSB0aGUgQ0Egc3RvcmUgb3IgaXMgc2VsZi1zaWduZWQpIGFuZCBpdFxuICAgICAgIGhhcyBhIGNyaXRpY2FsIGtleSB1c2FnZSBleHRlbnNpb24sIHZlcmlmeSB0aGF0IHRoZSBrZXlDZXJ0U2lnbiBiaXQgaXNcbiAgICAgICBzZXQuIElmIHRoZSBrZXkgdXNhZ2UgZXh0ZW5zaW9uIGV4aXN0cywgdmVyaWZ5IHRoYXQgdGhlIGJhc2ljXG4gICAgICAgY29uc3RyYWludHMgZXh0ZW5zaW9uIGV4aXN0cy4gSWYgdGhlIGJhc2ljIGNvbnN0cmFpbnRzIGV4dGVuc2lvbiBleGlzdHMsXG4gICAgICAgdmVyaWZ5IHRoYXQgdGhlIGNBIGZsYWcgaXMgc2V0LiBJZiBwYXRoTGVuQ29uc3RyYWludCBpcyBzZXQsIGVuc3VyZSB0aGF0XG4gICAgICAgdGhlIG51bWJlciBvZiBjZXJ0aWZpY2F0ZXMgdGhhdCBwcmVjZWRlIGluIHRoZSBjaGFpbiAoY29tZSBlYXJsaWVyXG4gICAgICAgaW4gdGhlIGNoYWluIGFzIGltcGxlbWVudGVkIGJlbG93KSwgZXhjbHVkaW5nIHRoZSB2ZXJ5IGZpcnN0IGluIHRoZVxuICAgICAgIGNoYWluICh0eXBpY2FsbHkgdGhlIGVuZC1lbnRpdHkgb25lKSwgaXNuJ3QgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAgIHBhdGhMZW5Db25zdHJhaW50LiBUaGlzIGNvbnN0cmFpbnQgbGltaXRzIHRoZSBudW1iZXIgb2YgaW50ZXJtZWRpYXRlXG4gICAgICAgQ0FzIHRoYXQgbWF5IGFwcGVhciBiZWxvdyBhIENBIGJlZm9yZSBvbmx5IGVuZC1lbnRpdHkgY2VydGlmaWNhdGVzXG4gICAgICAgbWF5IGJlIGlzc3VlZC4gKi9cblxuICAvLyBjb3B5IGNlcnQgY2hhaW4gcmVmZXJlbmNlcyB0byBhbm90aGVyIGFycmF5IHRvIHByb3RlY3QgYWdhaW5zdCBjaGFuZ2VzXG4gIC8vIGluIHZlcmlmeSBjYWxsYmFja1xuICBjaGFpbiA9IGNoYWluLnNsaWNlKDApO1xuICB2YXIgY2VydHMgPSBjaGFpbi5zbGljZSgwKTtcblxuICAvLyBnZXQgY3VycmVudCBkYXRlXG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIC8vIHZlcmlmeSBlYWNoIGNlcnQgaW4gdGhlIGNoYWluIHVzaW5nIGl0cyBwYXJlbnQsIHdoZXJlIHRoZSBwYXJlbnRcbiAgLy8gaXMgZWl0aGVyIHRoZSBuZXh0IGluIHRoZSBjaGFpbiBvciBmcm9tIHRoZSBDQSBzdG9yZVxuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuICB2YXIgZGVwdGggPSAwO1xuICBkbyB7XG4gICAgdmFyIGNlcnQgPSBjaGFpbi5zaGlmdCgpO1xuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBzZWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICAvLyAxLiBjaGVjayB2YWxpZCB0aW1lXG4gICAgaWYobm93IDwgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgfHwgbm93ID4gY2VydC52YWxpZGl0eS5ub3RBZnRlcikge1xuICAgICAgZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdmFsaWQgeWV0IG9yIGhhcyBleHBpcmVkLicsXG4gICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5jZXJ0aWZpY2F0ZV9leHBpcmVkLFxuICAgICAgICBub3RCZWZvcmU6IGNlcnQudmFsaWRpdHkubm90QmVmb3JlLFxuICAgICAgICBub3RBZnRlcjogY2VydC52YWxpZGl0eS5ub3RBZnRlcixcbiAgICAgICAgbm93OiBub3dcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMi4gdmVyaWZ5IHdpdGggcGFyZW50IGZyb20gY2hhaW4gb3IgQ0Egc3RvcmVcbiAgICBpZihlcnJvciA9PT0gbnVsbCkge1xuICAgICAgcGFyZW50ID0gY2hhaW5bMF0gfHwgY2FTdG9yZS5nZXRJc3N1ZXIoY2VydCk7XG4gICAgICBpZihwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHNlbGYtc2lnbmVkIGNlcnRcbiAgICAgICAgaWYoY2VydC5pc0lzc3VlcihjZXJ0KSkge1xuICAgICAgICAgIHNlbGZTaWduZWQgPSB0cnVlO1xuICAgICAgICAgIHBhcmVudCA9IGNlcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocGFyZW50KSB7XG4gICAgICAgIC8vIEZJWE1FOiBjdXJyZW50IENBIHN0b3JlIGltcGxlbWVudGF0aW9uIG1pZ2h0IGhhdmUgbXVsdGlwbGVcbiAgICAgICAgLy8gY2VydGlmaWNhdGVzIHdoZXJlIHRoZSBpc3N1ZXIgY2FuJ3QgYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZVxuICAgICAgICAvLyBjZXJ0aWZpY2F0ZSAoaGFwcGVucyByYXJlbHkgd2l0aCwgZWc6IG9sZCBjZXJ0aWZpY2F0ZXMpIHNvIG5vcm1hbGl6ZVxuICAgICAgICAvLyBieSBhbHdheXMgcHV0dGluZyBwYXJlbnRzIGludG8gYW4gYXJyYXlcbiAgICAgICAgLy8gVE9ETzogdGhlcmUncyBtYXkgYmUgYW4gZXh0cmVtZSBkZWdlbmVyYXRlIGNhc2UgY3VycmVudGx5IHVuY292ZXJlZFxuICAgICAgICAvLyB3aGVyZSBhbiBvbGQgaW50ZXJtZWRpYXRlIGNlcnRpZmljYXRlIHNlZW1zIHRvIGhhdmUgYSBtYXRjaGluZyBwYXJlbnRcbiAgICAgICAgLy8gYnV0IG5vbmUgb2YgdGhlIHBhcmVudHMgYWN0dWFsbHkgdmVyaWZ5IC4uLiBidXQgdGhlIGludGVybWVkaWF0ZVxuICAgICAgICAvLyBpcyBpbiB0aGUgQ0EgYW5kIGl0IHNob3VsZCBwYXNzIHRoaXMgY2hlY2s7IG5lZWRzIGludmVzdGlnYXRpb25cbiAgICAgICAgdmFyIHBhcmVudHMgPSBwYXJlbnQ7XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkocGFyZW50cykpIHtcbiAgICAgICAgICBwYXJlbnRzID0gW3BhcmVudHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHZlcmlmeSB3aXRoIGVhY2ggcG9zc2libGUgcGFyZW50ICh0eXBpY2FsbHkgb25seSBvbmUpXG4gICAgICAgIHZhciB2ZXJpZmllZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSghdmVyaWZpZWQgJiYgcGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50cy5zaGlmdCgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2ZXJpZmllZCA9IHBhcmVudC52ZXJpZnkoY2VydCk7XG4gICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgLy8gZmFpbHVyZSB0byB2ZXJpZnksIGRvbid0IGNhcmUgd2h5LCB0cnkgbmV4dCBvbmVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZighdmVyaWZpZWQpIHtcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBzaWduYXR1cmUgaXMgaW52YWxpZC4nLFxuICAgICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYgKCFwYXJlbnQgfHwgc2VsZlNpZ25lZCkgJiZcbiAgICAgICAgIWNhU3RvcmUuaGFzQ2VydGlmaWNhdGUoY2VydCkpIHtcbiAgICAgICAgLy8gbm8gcGFyZW50IGlzc3VlciBhbmQgY2VydGlmaWNhdGUgaXRzZWxmIGlzIG5vdCB0cnVzdGVkXG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdHJ1c3RlZC4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci51bmtub3duX2NhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogMy4gY2hlY2sgcmV2b2tlZFxuXG4gICAgLy8gNC4gY2hlY2sgZm9yIG1hdGNoaW5nIGlzc3Vlci9zdWJqZWN0XG4gICAgaWYoZXJyb3IgPT09IG51bGwgJiYgcGFyZW50ICYmICFjZXJ0LmlzSXNzdWVyKHBhcmVudCkpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBub3QgaXNzdWVyXG4gICAgICBlcnJvciA9IHtcbiAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIGlzc3VlciBpcyBpbnZhbGlkLicsXG4gICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNS4gVE9ETzogY2hlY2sgbmFtZXMgd2l0aCBwZXJtaXR0ZWQgbmFtZXMgdHJlZVxuXG4gICAgLy8gNi4gVE9ETzogY2hlY2sgbmFtZXMgYWdhaW5zdCBleGNsdWRlZCBuYW1lcyB0cmVlXG5cbiAgICAvLyA3LiBjaGVjayBmb3IgdW5zdXBwb3J0ZWQgY3JpdGljYWwgZXh0ZW5zaW9uc1xuICAgIGlmKGVycm9yID09PSBudWxsKSB7XG4gICAgICAvLyBzdXBwb3J0ZWQgZXh0ZW5zaW9uc1xuICAgICAgdmFyIHNlID0ge1xuICAgICAgICBrZXlVc2FnZTogdHJ1ZSxcbiAgICAgICAgYmFzaWNDb25zdHJhaW50czogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGVycm9yID09PSBudWxsICYmIGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGV4dCA9IGNlcnQuZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgaWYoZXh0LmNyaXRpY2FsICYmICEoZXh0Lm5hbWUgaW4gc2UpKSB7XG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnQ2VydGlmaWNhdGUgaGFzIGFuIHVuc3VwcG9ydGVkIGNyaXRpY2FsIGV4dGVuc2lvbi4nLFxuICAgICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDguIGNoZWNrIGZvciBDQSBpZiBjZXJ0IGlzIG5vdCBmaXJzdCBvciBpcyB0aGUgb25seSBjZXJ0aWZpY2F0ZVxuICAgIC8vIHJlbWFpbmluZyBpbiBjaGFpbiB3aXRoIG5vIHBhcmVudCBvciBpcyBzZWxmLXNpZ25lZFxuICAgIGlmKGVycm9yID09PSBudWxsICYmXG4gICAgICAoIWZpcnN0IHx8IChjaGFpbi5sZW5ndGggPT09IDAgJiYgKCFwYXJlbnQgfHwgc2VsZlNpZ25lZCkpKSkge1xuICAgICAgLy8gZmlyc3QgY2hlY2sga2V5VXNhZ2UgZXh0ZW5zaW9uIGFuZCB0aGVuIGJhc2ljIGNvbnN0cmFpbnRzXG4gICAgICB2YXIgYmNFeHQgPSBjZXJ0LmdldEV4dGVuc2lvbignYmFzaWNDb25zdHJhaW50cycpO1xuICAgICAgdmFyIGtleVVzYWdlRXh0ID0gY2VydC5nZXRFeHRlbnNpb24oJ2tleVVzYWdlJyk7XG4gICAgICBpZihrZXlVc2FnZUV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBrZXlDZXJ0U2lnbiBtdXN0IGJlIHRydWUgYW5kIHRoZXJlIG11c3QgYmUgYSBiYXNpY1xuICAgICAgICAvLyBjb25zdHJhaW50cyBleHRlbnNpb25cbiAgICAgICAgaWYoIWtleVVzYWdlRXh0LmtleUNlcnRTaWduIHx8IGJjRXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gYmFkIGNlcnRpZmljYXRlXG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnQ2VydGlmaWNhdGUga2V5VXNhZ2Ugb3IgYmFzaWNDb25zdHJhaW50cyBjb25mbGljdCAnICtcbiAgICAgICAgICAgICAgJ29yIGluZGljYXRlIHRoYXQgdGhlIGNlcnRpZmljYXRlIGlzIG5vdCBhIENBLiAnICtcbiAgICAgICAgICAgICAgJ0lmIHRoZSBjZXJ0aWZpY2F0ZSBpcyB0aGUgb25seSBvbmUgaW4gdGhlIGNoYWluIG9yICcgK1xuICAgICAgICAgICAgICAnaXNuXFwndCB0aGUgZmlyc3QgdGhlbiB0aGUgY2VydGlmaWNhdGUgbXVzdCBiZSBhICcgK1xuICAgICAgICAgICAgICAndmFsaWQgQ0EuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBiYXNpYyBjb25zdHJhaW50cyBjQSBmbGFnIG11c3QgYmUgc2V0XG4gICAgICBpZihlcnJvciA9PT0gbnVsbCAmJiBiY0V4dCAhPT0gbnVsbCAmJiAhYmNFeHQuY0EpIHtcbiAgICAgICAgLy8gYmFkIGNlcnRpZmljYXRlXG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAnQ2VydGlmaWNhdGUgYmFzaWNDb25zdHJhaW50cyBpbmRpY2F0ZXMgdGhlIGNlcnRpZmljYXRlICcgK1xuICAgICAgICAgICAgJ2lzIG5vdCBhIENBLicsXG4gICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gaWYgZXJyb3IgaXMgbm90IG51bGwgYW5kIGtleVVzYWdlIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBrbm93IGl0XG4gICAgICAvLyBoYXMga2V5Q2VydFNpZ24gYW5kIHRoZXJlIGlzIGEgYmFzaWMgY29uc3RyYWludHMgZXh0ZW5zaW9uIHRvbyxcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHdlIGNhbiBjaGVjayBwYXRoTGVuQ29uc3RyYWludCAoaWYgaXQgZXhpc3RzKVxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYga2V5VXNhZ2VFeHQgIT09IG51bGwgJiZcbiAgICAgICAgJ3BhdGhMZW5Db25zdHJhaW50JyBpbiBiY0V4dCkge1xuICAgICAgICAvLyBwYXRoTGVuIGlzIHRoZSBtYXhpbXVtICMgb2YgaW50ZXJtZWRpYXRlIENBIGNlcnRzIHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGZvdW5kIGJldHdlZW4gdGhlIGN1cnJlbnQgY2VydGlmaWNhdGUgYW5kIHRoZSBlbmQtZW50aXR5IChkZXB0aCAwKVxuICAgICAgICAvLyBjZXJ0aWZpY2F0ZTsgdGhpcyBudW1iZXIgZG9lcyBub3QgaW5jbHVkZSB0aGUgZW5kLWVudGl0eSAoZGVwdGggMCxcbiAgICAgICAgLy8gbGFzdCBpbiB0aGUgY2hhaW4pIGV2ZW4gaWYgaXQgaGFwcGVucyB0byBiZSBhIENBIGNlcnRpZmljYXRlIGl0c2VsZlxuICAgICAgICB2YXIgcGF0aExlbiA9IGRlcHRoIC0gMTtcbiAgICAgICAgaWYocGF0aExlbiA+IGJjRXh0LnBhdGhMZW5Db25zdHJhaW50KSB7XG4gICAgICAgICAgLy8gcGF0aExlbkNvbnN0cmFpbnQgdmlvbGF0ZWQsIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGJhc2ljQ29uc3RyYWludHMgcGF0aExlbkNvbnN0cmFpbnQgdmlvbGF0ZWQuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsbCBhcHBsaWNhdGlvbiBjYWxsYmFja1xuICAgIHZhciB2ZmQgPSAoZXJyb3IgPT09IG51bGwpID8gdHJ1ZSA6IGVycm9yLmVycm9yO1xuICAgIHZhciByZXQgPSB2ZXJpZnkgPyB2ZXJpZnkodmZkLCBkZXB0aCwgY2VydHMpIDogdmZkO1xuICAgIGlmKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gY2xlYXIgYW55IHNldCBlcnJvclxuICAgICAgZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBwYXNzZWQgYmFzaWMgdGVzdHMsIHNldCBkZWZhdWx0IG1lc3NhZ2UgYW5kIGFsZXJ0XG4gICAgICBpZih2ZmQgPT09IHRydWUpIHtcbiAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgbWVzc2FnZTogJ1RoZSBhcHBsaWNhdGlvbiByZWplY3RlZCB0aGUgY2VydGlmaWNhdGUuJyxcbiAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBjdXN0b20gZXJyb3IgaW5mb1xuICAgICAgaWYocmV0IHx8IHJldCA9PT0gMCkge1xuICAgICAgICAvLyBzZXQgY3VzdG9tIG1lc3NhZ2UgYW5kIGVycm9yXG4gICAgICAgIGlmKHR5cGVvZiByZXQgPT09ICdvYmplY3QnICYmICFmb3JnZS51dGlsLmlzQXJyYXkocmV0KSkge1xuICAgICAgICAgIGlmKHJldC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IHJldC5tZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmVycm9yID0gcmV0LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gc2V0IGN1c3RvbSBlcnJvclxuICAgICAgICAgIGVycm9yLmVycm9yID0gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBubyBsb25nZXIgZmlyc3QgY2VydCBpbiBjaGFpblxuICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgKytkZXB0aDtcbiAgfSB3aGlsZShjaGFpbi5sZW5ndGggPiAwKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgUEtDUyMxIFBTUyBzaWduYXR1cmUgcGFkZGluZy5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIHNob3J0Y3V0IGZvciBQU1MgQVBJXG52YXIgcHNzID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wc3MgPSBmb3JnZS5wc3MgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIFBTUyBzaWduYXR1cmUgc2NoZW1lIG9iamVjdC5cbiAqXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCB3YXlzIHRvIHByb3ZpZGUgYSBzYWx0IGZvciBlbmNvZGluZzpcbiAqXG4gKiAxLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIG9ubHkgYW5kIHRoZSBidWlsdC1pbiBQUk5HIHdpbGwgZ2VuZXJhdGUgaXQuXG4gKiAyLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIGFuZCBhIGN1c3RvbSBQUk5HIHdpdGggJ2dldEJ5dGVzU3luYycgZGVmaW5lZCB0aGF0XG4gKiAgIHdpbGwgYmUgdXNlZC5cbiAqIDMuIFNwZWNpZnkgdGhlIHNhbHQgaXRzZWxmIGFzIGEgZm9yZ2UudXRpbC5CeXRlQnVmZmVyLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLCBhIGZvcmdlIG1kIGluc3RhbmNlLlxuICogICAgICAgICAgbWdmIHRoZSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gdG8gdXNlLCBhIGZvcmdlIG1nZiBpbnN0YW5jZS5cbiAqICAgICAgICAgIFtzYWx0TGVuZ3RoXSB0aGUgbGVuZ3RoIG9mIHRoZSBzYWx0IGluIG9jdGV0cy5cbiAqICAgICAgICAgIFtwcm5nXSB0aGUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSB0byBwcm9kdWNlIGEgc2FsdC5cbiAqICAgICAgICAgIFtzYWx0XSB0aGUgc2FsdCB0byB1c2Ugd2hlbiBlbmNvZGluZy5cbiAqXG4gKiBAcmV0dXJuIGEgc2lnbmF0dXJlIHNjaGVtZSBvYmplY3QuXG4gKi9cbnBzcy5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHcvbGVnYWN5IGFyZ3M6IGhhc2gsIG1nZiwgc0xlblxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1kOiBhcmd1bWVudHNbMF0sXG4gICAgICBtZ2Y6IGFyZ3VtZW50c1sxXSxcbiAgICAgIHNhbHRMZW5ndGg6IGFyZ3VtZW50c1syXVxuICAgIH07XG4gIH1cblxuICB2YXIgaGFzaCA9IG9wdGlvbnMubWQ7XG4gIHZhciBtZ2YgPSBvcHRpb25zLm1nZjtcbiAgdmFyIGhMZW4gPSBoYXNoLmRpZ2VzdExlbmd0aDtcblxuICB2YXIgc2FsdF8gPSBvcHRpb25zLnNhbHQgfHwgbnVsbDtcbiAgaWYodHlwZW9mIHNhbHRfID09PSAnc3RyaW5nJykge1xuICAgIC8vIGFzc3VtZSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICBzYWx0XyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNhbHRfKTtcbiAgfVxuXG4gIHZhciBzTGVuO1xuICBpZignc2FsdExlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgIHNMZW4gPSBvcHRpb25zLnNhbHRMZW5ndGg7XG4gIH0gZWxzZSBpZihzYWx0XyAhPT0gbnVsbCkge1xuICAgIHNMZW4gPSBzYWx0Xy5sZW5ndGgoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbHQgbGVuZ3RoIG5vdCBzcGVjaWZpZWQgb3Igc3BlY2lmaWMgc2FsdCBub3QgZ2l2ZW4uJyk7XG4gIH1cblxuICBpZihzYWx0XyAhPT0gbnVsbCAmJiBzYWx0Xy5sZW5ndGgoKSAhPT0gc0xlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gc2FsdCBsZW5ndGggZG9lcyBub3QgbWF0Y2ggbGVuZ3RoIG9mIGdpdmVuIHNhbHQuJyk7XG4gIH1cblxuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG5cbiAgdmFyIHBzc29iaiA9IHt9O1xuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgUFNTIHNpZ25hdHVyZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIEVNU0EtUFNTLUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcsIHNlY3Rpb24gOS4xLjEuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAgICogQHBhcmFtIG1vZHNCaXRzIHRoZSBsZW5ndGggb2YgdGhlIFJTQSBtb2R1bHVzIGluIGJpdHMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBsZW5ndGhcbiAgICogICAgICAgICAgIGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpLlxuICAgKi9cbiAgcHNzb2JqLmVuY29kZSA9IGZ1bmN0aW9uKG1kLCBtb2RCaXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgIHZhciBlbUxlbiA9IE1hdGguY2VpbChlbUJpdHMgLyA4KTtcblxuICAgIC8qIDIuIExldCBtSGFzaCA9IEhhc2goTSksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICB2YXIgbUhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogMy4gSWYgZW1MZW4gPCBoTGVuICsgc0xlbiArIDIsIG91dHB1dCBcImVuY29kaW5nIGVycm9yXCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyB0byBlbmNyeXB0LicpO1xuICAgIH1cblxuICAgIC8qIDQuIEdlbmVyYXRlIGEgcmFuZG9tIG9jdGV0IHN0cmluZyBzYWx0IG9mIGxlbmd0aCBzTGVuOyBpZiBzTGVuID0gMCxcbiAgICAgKiAgICB0aGVuIHNhbHQgaXMgdGhlIGVtcHR5IHN0cmluZy4gKi9cbiAgICB2YXIgc2FsdDtcbiAgICBpZihzYWx0XyA9PT0gbnVsbCkge1xuICAgICAgc2FsdCA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHNMZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYWx0ID0gc2FsdF8uYnl0ZXMoKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgTScgPSAoMHgpMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgfHwgbUhhc2ggfHwgc2FsdDsgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDYuIExldCBIID0gSGFzaChNJyksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUobV8uZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIGggPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiA3LiBHZW5lcmF0ZSBhbiBvY3RldCBzdHJpbmcgUFMgY29uc2lzdGluZyBvZiBlbUxlbiAtIHNMZW4gLSBoTGVuIC0gMlxuICAgICAqICAgIHplcm8gb2N0ZXRzLiAgVGhlIGxlbmd0aCBvZiBQUyBtYXkgYmUgMC4gKi9cbiAgICB2YXIgcHMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgcHMuZmlsbFdpdGhCeXRlKDAsIGVtTGVuIC0gc0xlbiAtIGhMZW4gLSAyKTtcblxuICAgIC8qIDguIExldCBEQiA9IFBTIHx8IDB4MDEgfHwgc2FsdDsgREIgaXMgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aFxuICAgICAqICAgIGVtTGVuIC0gaExlbiAtIDEuICovXG4gICAgcHMucHV0Qnl0ZSgweDAxKTtcbiAgICBwcy5wdXRCeXRlcyhzYWx0KTtcbiAgICB2YXIgZGIgPSBwcy5nZXRCeXRlcygpO1xuXG4gICAgLyogOS4gTGV0IGRiTWFzayA9IE1HRihILCBlbUxlbiAtIGhMZW4gLSAxKS4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIGRiTWFzayA9IG1nZi5nZW5lcmF0ZShoLCBtYXNrTGVuKTtcblxuICAgIC8qIDEwLiBMZXQgbWFza2VkREIgPSBEQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIG1hc2tlZERCID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBtYXNrZWREQiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRiLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogMTEuIFNldCB0aGUgbGVmdG1vc3QgOGVtTGVuIC0gZW1CaXRzIGJpdHMgb2YgdGhlIGxlZnRtb3N0IG9jdGV0IGluXG4gICAgICogICAgIG1hc2tlZERCIHRvIHplcm8uICovXG4gICAgdmFyIG1hc2sgPSAoMHhGRjAwID4+ICg4ICogZW1MZW4gLSBlbUJpdHMpKSAmIDB4RkY7XG4gICAgbWFza2VkREIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoMCkgJiB+bWFzaykgK1xuICAgICAgbWFza2VkREIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTIuIExldCBFTSA9IG1hc2tlZERCIHx8IEggfHwgMHhiYy5cbiAgICAgKiAxMy4gT3V0cHV0IEVNLiAqL1xuICAgIHJldHVybiBtYXNrZWREQiArIGggKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIFBTUyBzaWduYXR1cmUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBFTVNBLVBTUy1WRVJJRlkgYXMgcGVyIFJGQyAzNDQ3LCBzZWN0aW9uIDkuMS4yLlxuICAgKlxuICAgKiBAcGFyYW0gbUhhc2ggdGhlIG1lc3NhZ2UgZGlnZXN0IGhhc2gsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nLCB0b1xuICAgKiAgICAgICAgIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLlxuICAgKiBAcGFyYW0gZW0gdGhlIGVuY29kZWQgbWVzc2FnZSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICogICAgICAgICAgKFJTQSBkZWNyeXB0aW9uIHJlc3VsdCkuXG4gICAqIEBwYXJhbSBtb2RzQml0cyB0aGUgbGVuZ3RoIG9mIHRoZSBSU0EgbW9kdWx1cyBpbiBiaXRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHNpZ25hdHVyZSB3YXMgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIHBzc29iai52ZXJpZnkgPSBmdW5jdGlvbihtSGFzaCwgZW0sIG1vZEJpdHMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgZW1CaXRzID0gbW9kQml0cyAtIDE7XG4gICAgdmFyIGVtTGVuID0gTWF0aC5jZWlsKGVtQml0cyAvIDgpO1xuXG4gICAgLyogYy4gQ29udmVydCB0aGUgbWVzc2FnZSByZXByZXNlbnRhdGl2ZSBtIHRvIGFuIGVuY29kZWQgbWVzc2FnZSBFTVxuICAgICAqICAgIG9mIGxlbmd0aCBlbUxlbiA9IGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpIG9jdGV0cywgd2hlcmUgbW9kQml0c1xuICAgICAqICAgIGlzIHRoZSBsZW5ndGggaW4gYml0cyBvZiB0aGUgUlNBIG1vZHVsdXMgbiAqL1xuICAgIGVtID0gZW0uc3Vic3RyKC1lbUxlbik7XG5cbiAgICAvKiAzLiBJZiBlbUxlbiA8IGhMZW4gKyBzTGVuICsgMiwgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IHBhcmFtZXRlcnMgdG8gUFNTIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24uJyk7XG4gICAgfVxuXG4gICAgLyogNC4gSWYgdGhlIHJpZ2h0bW9zdCBvY3RldCBvZiBFTSBkb2VzIG5vdCBoYXZlIGhleGFkZWNpbWFsIHZhbHVlXG4gICAgICogICAgMHhiYywgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW0uY2hhckNvZGVBdChlbUxlbiAtIDEpICE9PSAweGJjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kZWQgbWVzc2FnZSBkb2VzIG5vdCBlbmQgaW4gMHhCQy4nKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgbWFza2VkREIgYmUgdGhlIGxlZnRtb3N0IGVtTGVuIC0gaExlbiAtIDEgb2N0ZXRzIG9mIEVNLCBhbmRcbiAgICAgKiAgICBsZXQgSCBiZSB0aGUgbmV4dCBoTGVuIG9jdGV0cy4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyKDAsIG1hc2tMZW4pO1xuICAgIHZhciBoID0gZW0uc3Vic3RyKG1hc2tMZW4sIGhMZW4pO1xuXG4gICAgLyogNi4gSWYgdGhlIGxlZnRtb3N0IDhlbUxlbiAtIGVtQml0cyBiaXRzIG9mIHRoZSBsZWZ0bW9zdCBvY3RldCBpblxuICAgICAqICAgIG1hc2tlZERCIGFyZSBub3QgYWxsIGVxdWFsIHRvIHplcm8sIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBtYXNrID0gKDB4RkYwMCA+PiAoOCAqIGVtTGVuIC0gZW1CaXRzKSkgJiAweEZGO1xuICAgIGlmKChtYXNrZWREQi5jaGFyQ29kZUF0KDApICYgbWFzaykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQml0cyBiZXlvbmQga2V5c2l6ZSBub3QgemVybyBhcyBleHBlY3RlZC4nKTtcbiAgICB9XG5cbiAgICAvKiA3LiBMZXQgZGJNYXNrID0gTUdGKEgsIGVtTGVuIC0gaExlbiAtIDEpLiAqL1xuICAgIHZhciBkYk1hc2sgPSBtZ2YuZ2VuZXJhdGUoaCwgbWFza0xlbik7XG5cbiAgICAvKiA4LiBMZXQgREIgPSBtYXNrZWREQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIGRiID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBkYiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogOS4gU2V0IHRoZSBsZWZ0bW9zdCA4ZW1MZW4gLSBlbUJpdHMgYml0cyBvZiB0aGUgbGVmdG1vc3Qgb2N0ZXRcbiAgICAgKiBpbiBEQiB0byB6ZXJvLiAqL1xuICAgIGRiID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYi5jaGFyQ29kZUF0KDApICYgfm1hc2spICsgZGIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTAuIElmIHRoZSBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMiBsZWZ0bW9zdCBvY3RldHMgb2YgREIgYXJlIG5vdCB6ZXJvXG4gICAgICogb3IgaWYgdGhlIG9jdGV0IGF0IHBvc2l0aW9uIGVtTGVuIC0gaExlbiAtIHNMZW4gLSAxICh0aGUgbGVmdG1vc3RcbiAgICAgKiBwb3NpdGlvbiBpcyBcInBvc2l0aW9uIDFcIikgZG9lcyBub3QgaGF2ZSBoZXhhZGVjaW1hbCB2YWx1ZSAweDAxLFxuICAgICAqIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBjaGVja0xlbiA9IGVtTGVuIC0gaExlbiAtIHNMZW4gLSAyO1xuICAgIGZvcihpID0gMDsgaSA8IGNoZWNrTGVuOyBpKyspIHtcbiAgICAgIGlmKGRiLmNoYXJDb2RlQXQoaSkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWZ0bW9zdCBvY3RldHMgbm90IHplcm8gYXMgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihkYi5jaGFyQ29kZUF0KGNoZWNrTGVuKSAhPT0gMHgwMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbnNpc3RlbnQgUFNTIHNpZ25hdHVyZSwgMHgwMSBtYXJrZXIgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgLyogMTEuIExldCBzYWx0IGJlIHRoZSBsYXN0IHNMZW4gb2N0ZXRzIG9mIERCLiAqL1xuICAgIHZhciBzYWx0ID0gZGIuc3Vic3RyKC1zTGVuKTtcblxuICAgIC8qIDEyLiAgTGV0IE0nID0gKDB4KTAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIHx8IG1IYXNoIHx8IHNhbHQgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDEzLiBMZXQgSCcgPSBIYXNoKE0nKSwgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aCBoTGVuLiAqL1xuICAgIGhhc2guc3RhcnQoKTtcbiAgICBoYXNoLnVwZGF0ZShtXy5nZXRCeXRlcygpKTtcbiAgICB2YXIgaF8gPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiAxNC4gSWYgSCA9IEgnLCBvdXRwdXQgXCJjb25zaXN0ZW50LlwiIE90aGVyd2lzZSwgb3V0cHV0IFwiaW5jb25zaXN0ZW50LlwiICovXG4gICAgcmV0dXJuIGggPT09IGhfO1xuICB9O1xuXG4gIHJldHVybiBwc3NvYmo7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBiYXNpYyBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAqIHN1cHBvcnQgZm9yIFJTQSBwdWJsaWMgYW5kIHByaXZhdGUga2V5cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbl9fd2VicGFja19yZXF1aXJlX18oOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbl9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKiBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIChQS0kpIGltcGxlbWVudGF0aW9uLiAqL1xudmFyIHBraSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQuIFVzZSBwZW0uZGVjb2RlKCkgaW5zdGVhZC5cbiAqXG4gKiBDb252ZXJ0cyBQRU0tZm9ybWF0dGVkIGRhdGEgdG8gREVSLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBERVItZm9ybWF0dGVkIGRhdGEuXG4gKi9cbnBraS5wZW1Ub0RlciA9IGZ1bmN0aW9uKHBlbSkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQRU0gdG8gREVSOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG4gIHJldHVybiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuYm9keSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwcml2YXRlIGtleSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwcml2YXRlIGtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiYgbXNnLnR5cGUgIT09ICdSU0EgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNICcgK1xuICAgICAgJ2hlYWRlciB0eXBlIGlzIG5vdCBcIlBSSVZBVEUgS0VZXCIgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG5cbiAgcmV0dXJuIHBraS5wcml2YXRlS2V5RnJvbUFzbjEob2JqKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHByaXZhdGUga2V5IHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleVRvUGVtID0gZnVuY3Rpb24oa2V5LCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5wcml2YXRlS2V5VG9Bc24xKGtleSkpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBraSB0aGUgUHJpdmF0ZUtleUluZm8uXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUluZm9Ub1BlbSA9IGZ1bmN0aW9uKHBraSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBCYXNlLU4vQmFzZS1YIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBmcm9tIGJhc2UteDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmFzZS14XG4gKlxuICogV2hpY2ggaXMgTUlUIGxpY2Vuc2VkOlxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCBiYXNlLXggY29udHJpYnV0b3JzIChjKSAyMDE2XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGJhc2VOIGFscGhhYmV0IGluZGV4ZXNcbnZhciBfcmV2ZXJzZUFscGhhYmV0cyA9IHt9O1xuXG4vKipcbiAqIEJhc2VOLWVuY29kZXMgYSBVaW50OEFycmF5IHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2VOLWVuY29kZWQgb3V0cHV0IHN0cmluZy5cbiAqL1xuYXBpLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCwgbWF4bGluZSkge1xuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYobWF4bGluZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBtYXhsaW5lICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibWF4bGluZVwiIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgaWYoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgLy8gYXNzdW1lIGZvcmdlIGJ5dGUgYnVmZmVyXG4gICAgb3V0cHV0ID0gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgICB2YXIgZGlnaXRzID0gWzBdO1xuICAgIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0W2ldOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIGJhc2U7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IoaSA9IDA7IGlucHV0W2ldID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG91dHB1dCArPSBmaXJzdDtcbiAgICB9XG4gICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gICAgfVxuICB9XG5cbiAgaWYobWF4bGluZSkge1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJy57MSwnICsgbWF4bGluZSArICd9JywgJ2cnKTtcbiAgICBvdXRwdXQgPSBvdXRwdXQubWF0Y2gocmVnZXgpLmpvaW4oJ1xcclxcbicpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2VOLWVuY29kZWQgKHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldCkgc3RyaW5nIHRvIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlTi1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5LlxuICovXG5hcGkuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIGFscGhhYmV0KSB7XG4gIGlmKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlucHV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF07XG4gIGlmKCF0YWJsZSkge1xuICAgIC8vIGNvbXB1dGUgcmV2ZXJzZSBhbHBoYWJldFxuICAgIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0YWJsZVthbHBoYWJldC5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgdmFyIGJ5dGVzID0gWzBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB0YWJsZVtpbnB1dC5jaGFyQ29kZUF0KGkpXTtcbiAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBieXRlc1tqXSAqIGJhc2U7XG4gICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgIGNhcnJ5ID4+PSA4O1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgY2FycnkgPj49IDg7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgZm9yKHZhciBrID0gMDsgaW5wdXRba10gPT09IGZpcnN0ICYmIGsgPCBpbnB1dC5sZW5ndGggLSAxOyArK2spIHtcbiAgICBieXRlcy5wdXNoKDApO1xuICB9XG5cbiAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpO1xufTtcblxuZnVuY3Rpb24gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCkge1xuICB2YXIgaSA9IDA7XG4gIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gIHZhciBkaWdpdHMgPSBbMF07XG4gIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCgpOyArK2kpIHtcbiAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0LmF0KGkpOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IoaSA9IDA7IGlucHV0LmF0KGkpID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGgoKSAtIDE7ICsraSkge1xuICAgIG91dHB1dCArPSBmaXJzdDtcbiAgfVxuICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIG91dHB1dCArPSBhbHBoYWJldFtkaWdpdHNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMjU2LWJpdCBkaWdlc3QgKFNIQS0yNTYpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFNlZSBGSVBTIDE4MC0yIGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgc2hhMjU2ID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGEyNTYgPSBmb3JnZS5zaGEyNTYgfHwge307XG5mb3JnZS5tZC5zaGEyNTYgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTI1NiA9IHNoYTI1NjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTI1NiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMjU2LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMjU2IHN0YXRlIGNvbnRhaW5zIGVpZ2h0IDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg2NCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICBkaWdlc3RMZW5ndGg6IDMyLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogOFxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoNjQgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDY0ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX3N0YXRlID0ge1xuICAgICAgaDA6IDB4NkEwOUU2NjcsXG4gICAgICBoMTogMHhCQjY3QUU4NSxcbiAgICAgIGgyOiAweDNDNkVGMzcyLFxuICAgICAgaDM6IDB4QTU0RkY1M0EsXG4gICAgICBoNDogMHg1MTBFNTI3RixcbiAgICAgIGg1OiAweDlCMDU2ODhDLFxuICAgICAgaDY6IDB4MUY4M0Q5QUIsXG4gICAgICBoNzogMHg1QkUwQ0QxOVxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtMjU2IHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDQsXG4gICAgICBoNTogX3N0YXRlLmg1LFxuICAgICAgaDY6IF9zdGF0ZS5oNixcbiAgICAgIGg3OiBfc3RhdGUuaDdcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNyk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTI1NiBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIHRhYmxlIG9mIGNvbnN0YW50c1xudmFyIF9rID0gbnVsbDtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gY3JlYXRlIEsgdGFibGUgZm9yIFNIQS0yNTZcbiAgX2sgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gICAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAgIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gICAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAgIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gICAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMl07XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS0yNTYgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0yNTYgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQxLCB0MiwgczAsIHMxLCBjaCwgbWFqLCBpLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gNjQgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMjU2XG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgd1tpXSA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgfVxuICAgIGZvcig7IGkgPCA2NDsgKytpKSB7XG4gICAgICAvLyBYT1Igd29yZCAyIHdvcmRzIGFnbyByb3QgcmlnaHQgMTcsIHJvdCByaWdodCAxOSwgc2hmdCByaWdodCAxMFxuICAgICAgdDEgPSB3W2kgLSAyXTtcbiAgICAgIHQxID1cbiAgICAgICAgKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXlxuICAgICAgICAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeXG4gICAgICAgICh0MSA+Pj4gMTApO1xuICAgICAgLy8gWE9SIHdvcmQgMTUgd29yZHMgYWdvIHJvdCByaWdodCA3LCByb3QgcmlnaHQgMTgsIHNoZnQgcmlnaHQgM1xuICAgICAgdDIgPSB3W2kgLSAxNV07XG4gICAgICB0MiA9XG4gICAgICAgICgodDIgPj4+IDcpIHwgKHQyIDw8IDI1KSkgXlxuICAgICAgICAoKHQyID4+PiAxOCkgfCAodDIgPDwgMTQpKSBeXG4gICAgICAgICh0MiA+Pj4gMyk7XG4gICAgICAvLyBzdW0odDEsIHdvcmQgNyBhZ28sIHQyLCB3b3JkIDE2IGFnbykgbW9kdWxvIDJeMzJcbiAgICAgIHdbaV0gPSAodDEgKyB3W2kgLSA3XSArIHQyICsgd1tpIC0gMTZdKSB8IDA7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG4gICAgZiA9IHMuaDU7XG4gICAgZyA9IHMuaDY7XG4gICAgaCA9IHMuaDc7XG5cbiAgICAvLyByb3VuZCBmdW5jdGlvblxuICAgIGZvcihpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIC8vIFN1bTEoZSlcbiAgICAgIHMxID1cbiAgICAgICAgKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXlxuICAgICAgICAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXlxuICAgICAgICAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgIC8vIENoKGUsIGYsIGcpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgY2ggPSBnIF4gKGUgJiAoZiBeIGcpKTtcbiAgICAgIC8vIFN1bTAoYSlcbiAgICAgIHMwID1cbiAgICAgICAgKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXlxuICAgICAgICAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXlxuICAgICAgICAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAvLyBNYWooYSwgYiwgYykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBtYWogPSAoYSAmIGIpIHwgKGMgJiAoYSBeIGIpKTtcblxuICAgICAgLy8gbWFpbiBhbGdvcml0aG1cbiAgICAgIHQxID0gaCArIHMxICsgY2ggKyBfa1tpXSArIHdbaV07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgaCA9IGc7XG4gICAgICBnID0gZjtcbiAgICAgIGYgPSBlO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICAvLyBjYW4ndCB0cnVuY2F0ZSB3aXRoIGB8IDBgXG4gICAgICBlID0gKGQgKyB0MSkgPj4+IDA7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiA9IGE7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIC8vIGNhbid0IHRydW5jYXRlIHdpdGggYHwgMGBcbiAgICAgIGEgPSAodDEgKyB0MikgPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuICAgIHMuaDUgPSAocy5oNSArIGYpIHwgMDtcbiAgICBzLmg2ID0gKHMuaDYgKyBnKSB8IDA7XG4gICAgcy5oNyA9IChzLmg3ICsgaCkgfCAwO1xuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmVcbiAqIFBzZXVkbyBSYW5kb20gTnVtYmVyIEdlbmVyYXRvciAoUFJORykuIFRoZSBGb3J0dW5hIGFsZ29yaXRobSBpcyBmb2xsb3dlZFxuICogaGVyZSB0aG91Z2ggdGhlIHVzZSBvZiBTSEEtMjU2IGlzIG5vdCBlbmZvcmNlZDsgd2hlbiBnZW5lcmF0aW5nIGFuXG4gKiBhIFBSTkcgY29udGV4dCwgdGhlIGhhc2hpbmcgYWxnb3JpdGhtIGFuZCBibG9jayBjaXBoZXIgdXNlZCBmb3JcbiAqIHRoZSBnZW5lcmF0b3IgYXJlIHNwZWNpZmllZCB2aWEgYSBwbHVnaW4uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcnlwdG8gPSBudWxsO1xuaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXSkge1xuICBfY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG59XG5cbi8qIFBSTkcgQVBJICovXG52YXIgcHJuZyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJuZyA9IGZvcmdlLnBybmcgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HIGNvbnRleHQuXG4gKlxuICogQSBQUk5HIHBsdWdpbiBtdXN0IGJlIHBhc3NlZCBpbiB0aGF0IHdpbGwgcHJvdmlkZTpcbiAqXG4gKiAxLiBBIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGtleSBhbmQgc2VlZCBvZiBhIFBSTkcgY29udGV4dC4gSXRcbiAqICAgd2lsbCBiZSBnaXZlbiBhIDE2IGJ5dGUga2V5IGFuZCBhIDE2IGJ5dGUgc2VlZC4gQW55IGtleSBleHBhbnNpb25cbiAqICAgb3IgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHNlZWQgZnJvbSBhIGJ5dGUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2ZcbiAqICAgaW50ZWdlcnMgKG9yIHNpbWlsYXIpIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gKiAyLiBUaGUgY3J5cHRvZ3JhcGhpYyBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBnZW5lcmF0b3IuIEl0IHRha2VzIGEga2V5IGFuZFxuICogICBhIHNlZWQuXG4gKiAzLiBBIHNlZWQgaW5jcmVtZW50IGZ1bmN0aW9uLiBJdCB0YWtlcyB0aGUgc2VlZCBhbmQgcmV0dXJucyBzZWVkICsgMS5cbiAqIDQuIEFuIGFwaSB0byBjcmVhdGUgYSBtZXNzYWdlIGRpZ2VzdC5cbiAqXG4gKiBGb3IgYW4gZXhhbXBsZSwgc2VlIHJhbmRvbS5qcy5cbiAqXG4gKiBAcGFyYW0gcGx1Z2luIHRoZSBQUk5HIHBsdWdpbiB0byB1c2UuXG4gKi9cbnBybmcuY3JlYXRlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gIHZhciBjdHggPSB7XG4gICAgcGx1Z2luOiBwbHVnaW4sXG4gICAga2V5OiBudWxsLFxuICAgIHNlZWQ6IG51bGwsXG4gICAgdGltZTogbnVsbCxcbiAgICAvLyBudW1iZXIgb2YgcmVzZWVkcyBzbyBmYXJcbiAgICByZXNlZWRzOiAwLFxuICAgIC8vIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBzbyBmYXJcbiAgICBnZW5lcmF0ZWQ6IDAsXG4gICAgLy8gbm8gaW5pdGlhbCBrZXkgYnl0ZXNcbiAgICBrZXlCeXRlczogJydcbiAgfTtcblxuICAvLyBjcmVhdGUgMzIgZW50cm9weSBwb29scyAoZWFjaCBpcyBhIG1lc3NhZ2UgZGlnZXN0KVxuICB2YXIgbWQgPSBwbHVnaW4ubWQ7XG4gIHZhciBwb29scyA9IG5ldyBBcnJheSgzMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgcG9vbHNbaV0gPSBtZC5jcmVhdGUoKTtcbiAgfVxuICBjdHgucG9vbHMgPSBwb29scztcblxuICAvLyBlbnRyb3B5IHBvb2xzIGFyZSB3cml0dGVuIHRvIGN5Y2xpY2FsbHksIHN0YXJ0aW5nIGF0IGluZGV4IDBcbiAgY3R4LnBvb2wgPSAwO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmFuZG9tIGJ5dGVzLiBUaGUgYnl0ZXMgbWF5IGJlIGdlbmVyYXRlZCBzeW5jaHJvbm91c2x5IG9yXG4gICAqIGFzeW5jaHJvbm91c2x5LiBXZWIgd29ya2VycyBtdXN0IHVzZSB0aGUgYXN5bmNocm9ub3VzIGludGVyZmFjZSBvclxuICAgKiBlbHNlIHRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGJ5dGVzKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4gY291bnQgcmFuZG9tIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdlbmVyYXRlID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgLy8gZG8gc3luY2hyb25vdXNseVxuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGN0eC5nZW5lcmF0ZVN5bmMoY291bnQpO1xuICAgIH1cblxuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHJlc2V0IGtleSBmb3IgZXZlcnkgcmVxdWVzdCB0byBwcm90ZWN0IHByZXZpb3VzbHlcbiAgICAvLyBnZW5lcmF0ZWQgcmFuZG9tIGJ5dGVzIHNob3VsZCB0aGUga2V5IGJlIGRpc2NvdmVyZWQ7XG4gICAgLy8gdGhlcmUgaXMgbm8gMTAwbXMgYmFzZWQgcmVzZWVkaW5nIGJlY2F1c2Ugb2YgdGhpc1xuICAgIC8vIGZvcmNlZCByZXNlZWQgZm9yIGV2ZXJ5IGBnZW5lcmF0ZWAgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgZ2VuZXJhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGVycikge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdWZmaWNpZW50IGJ5dGVzIGdlbmVyYXRlZFxuICAgICAgaWYoYi5sZW5ndGgoKSA+PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYi5nZXRCeXRlcyhjb3VudCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbW91bnQgb2YgZGF0YSBnZW5lcmF0ZWQgaXMgZ3JlYXRlciB0aGFuIDEgTWlCLCB0cmlnZ2VyIHJlc2VlZFxuICAgICAgaWYoY3R4LmdlbmVyYXRlZCA+IDB4ZmZmZmYpIHtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcHJldmVudCBzdGFjayBvdmVyZmxvd1xuICAgICAgICByZXR1cm4gZm9yZ2UudXRpbC5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVzZWVkKGdlbmVyYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG5cbiAgICAgIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGdlbmVyYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZXMgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIGNvdW50IHJhbmRvbSBieXRlcyBhcyBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZW5lcmF0ZVN5bmMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gcmVzZXQga2V5IGZvciBldmVyeSByZXF1ZXN0IHRvIHByb3RlY3QgcHJldmlvdXNseVxuICAgIC8vIGdlbmVyYXRlZCByYW5kb20gYnl0ZXMgc2hvdWxkIHRoZSBrZXkgYmUgZGlzY292ZXJlZDtcbiAgICAvLyB0aGVyZSBpcyBubyAxMDBtcyBiYXNlZCByZXNlZWRpbmcgYmVjYXVzZSBvZiB0aGlzXG4gICAgLy8gZm9yY2VkIHJlc2VlZCBmb3IgZXZlcnkgYGdlbmVyYXRlU3luY2AgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHdoaWxlKGIubGVuZ3RoKCkgPCBjb3VudCkge1xuICAgICAgLy8gaWYgYW1vdW50IG9mIGRhdGEgZ2VuZXJhdGVkIGlzIGdyZWF0ZXIgdGhhbiAxIE1pQiwgdHJpZ2dlciByZXNlZWRcbiAgICAgIGlmKGN0eC5nZW5lcmF0ZWQgPiAweGZmZmZmKSB7XG4gICAgICAgIGN0eC5rZXkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZihjdHgua2V5ID09PSBudWxsKSB7XG4gICAgICAgIF9yZXNlZWRTeW5jKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMoY291bnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrKGVycikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzZWVkKGNhbGxiYWNrKSB7XG4gICAgaWYoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgIF9zZWVkKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LnNlZWRGaWxlKG5lZWRlZCwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICAgICAgX3NlZWQoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNlZWRTeW5jKCkge1xuICAgIGlmKGN0eC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoID49IDMyKSB7XG4gICAgICByZXR1cm4gX3NlZWQoKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LmNvbGxlY3QoY3R4LnNlZWRGaWxlU3luYyhuZWVkZWQpKTtcbiAgICBfc2VlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBzZWVkcyBhIGdlbmVyYXRvciBvbmNlIGVub3VnaCBieXRlcyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3NlZWQoKSB7XG4gICAgLy8gdXBkYXRlIHJlc2VlZCBjb3VudFxuICAgIGN0eC5yZXNlZWRzID0gKGN0eC5yZXNlZWRzID09PSAweGZmZmZmZmZmKSA/IDAgOiBjdHgucmVzZWVkcyArIDE7XG5cbiAgICAvLyBnb2FsIGlzIHRvIHVwZGF0ZSBga2V5YCB2aWE6XG4gICAgLy8ga2V5ID0gaGFzaChrZXkgKyBzKVxuICAgIC8vICAgd2hlcmUgJ3MnIGlzIGFsbCBjb2xsZWN0ZWQgZW50cm9weSBmcm9tIHNlbGVjdGVkIHBvb2xzLCB0aGVuLi4uXG5cbiAgICAvLyBjcmVhdGUgYSBwbHVnaW4tYmFzZWQgbWVzc2FnZSBkaWdlc3RcbiAgICB2YXIgbWQgPSBjdHgucGx1Z2luLm1kLmNyZWF0ZSgpO1xuXG4gICAgLy8gY29uc3VtZSBjdXJyZW50IGtleSBieXRlc1xuICAgIG1kLnVwZGF0ZShjdHgua2V5Qnl0ZXMpO1xuXG4gICAgLy8gZGlnZXN0IHRoZSBlbnRyb3B5IG9mIHBvb2xzIHdob3NlIGluZGV4IGsgbWVldCB0aGVcbiAgICAvLyBjb25kaXRpb24gJ24gbW9kIDJeayA9PSAwJyB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcmVzZWVkc1xuICAgIHZhciBfMnBvd0sgPSAxO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCAzMjsgKytrKSB7XG4gICAgICBpZihjdHgucmVzZWVkcyAlIF8ycG93SyA9PT0gMCkge1xuICAgICAgICBtZC51cGRhdGUoY3R4LnBvb2xzW2tdLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICAgICAgICBjdHgucG9vbHNba10uc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIF8ycG93SyA9IF8ycG93SyA8PCAxO1xuICAgIH1cblxuICAgIC8vIGdldCBkaWdlc3QgZm9yIGtleSBieXRlc1xuICAgIGN0eC5rZXlCeXRlcyA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHVwZGF0ZSBgc2VlZGAgdmlhIGBzZWVkID0gaGFzaChrZXkpYFxuICAgIC8vIGluc3RlYWQgb2YgaW5pdGlhbGl6aW5nIHRvIHplcm8gb25jZSBhbmQgb25seVxuICAgIC8vIGV2ZXIgaW5jcmVtZW50aW5nIGl0XG4gICAgbWQuc3RhcnQoKTtcbiAgICBtZC51cGRhdGUoY3R4LmtleUJ5dGVzKTtcbiAgICB2YXIgc2VlZEJ5dGVzID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIHVwZGF0ZSBzdGF0ZVxuICAgIGN0eC5rZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleShjdHgua2V5Qnl0ZXMpO1xuICAgIGN0eC5zZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkKHNlZWRCeXRlcyk7XG4gICAgY3R4LmdlbmVyYXRlZCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgc2VlZEZpbGUuIFRoaXMgc2VlZEZpbGUgaXMgdXNlZCB3aGVuIGVudHJvcHlcbiAgICogaXMgbmVlZGVkIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gbmVlZGVkIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0U2VlZEZpbGUobmVlZGVkKSB7XG4gICAgLy8gdXNlIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHN0cm9uZyBzb3VyY2Ugb2YgZW50cm9weSBpZiBhdmFpbGFibGVcbiAgICB2YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbiAgICBpZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIF9jcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcbiAgICAgIGlmKF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGlmKGdldFJhbmRvbVZhbHVlcykge1xuICAgICAgd2hpbGUoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgICAvLyBtYXggYnl0ZSBsZW5ndGggaXMgNjU1MzYgYmVmb3JlIFF1b3RhRXhjZWVkZWRFcnJvciBpcyB0aHJvd25cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLyNSYW5kb21Tb3VyY2UtbWV0aG9kLWdldFJhbmRvbVZhbHVlc1xuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihuZWVkZWQgLSBiLmxlbmd0aCgpLCA2NTUzNikgLyA0KTtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5mbG9vcihjb3VudCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdldFJhbmRvbVZhbHVlcyhlbnRyb3B5KTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYi5wdXRJbnQzMihlbnRyb3B5W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8qIG9ubHkgaWdub3JlIFF1b3RhRXhjZWVkZWRFcnJvciAqL1xuICAgICAgICAgIGlmKCEodHlwZW9mIFF1b3RhRXhjZWVkZWRFcnJvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBRdW90YUV4Y2VlZGVkRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJlIHNhZCBhbmQgYWRkIHNvbWUgd2VhayByYW5kb20gZGF0YVxuICAgIGlmKGIubGVuZ3RoKCkgPCBuZWVkZWQpIHtcbiAgICAgIC8qIERyYXdzIGZyb20gUGFyay1NaWxsZXIgXCJtaW5pbWFsIHN0YW5kYXJkXCIgMzEgYml0IFBSTkcsXG4gICAgICBpbXBsZW1lbnRlZCB3aXRoIERhdmlkIEcuIENhcnRhJ3Mgb3B0aW1pemF0aW9uOiB3aXRoIDMyIGJpdCBtYXRoXG4gICAgICBhbmQgd2l0aG91dCBkaXZpc2lvbiAoUHVibGljIERvbWFpbikuICovXG4gICAgICB2YXIgaGksIGxvLCBuZXh0O1xuICAgICAgdmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDAwMCk7XG4gICAgICB3aGlsZShiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgIGxvID0gMTY4MDcgKiAoc2VlZCAmIDB4RkZGRik7XG4gICAgICAgIGhpID0gMTY4MDcgKiAoc2VlZCA+PiAxNik7XG4gICAgICAgIGxvICs9IChoaSAmIDB4N0ZGRikgPDwgMTY7XG4gICAgICAgIGxvICs9IGhpID4+IDE1O1xuICAgICAgICBsbyA9IChsbyAmIDB4N0ZGRkZGRkYpICsgKGxvID4+IDMxKTtcbiAgICAgICAgc2VlZCA9IGxvICYgMHhGRkZGRkZGRjtcblxuICAgICAgICAvLyBjb25zdW1lIGxvd2VyIDMgYnl0ZXMgb2Ygc2VlZFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgLy8gdGhyb3cgaW4gbW9yZSBwc2V1ZG8gcmFuZG9tXG4gICAgICAgICAgbmV4dCA9IHNlZWQgPj4+IChpIDw8IDMpO1xuICAgICAgICAgIG5leHQgXj0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgwMTAwKTtcbiAgICAgICAgICBiLnB1dEJ5dGUoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0ICYgMHhGRikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMobmVlZGVkKTtcbiAgfVxuICAvLyBpbml0aWFsaXplIHNlZWQgZmlsZSBBUElzXG4gIGlmKF9jcnlwdG8pIHtcbiAgICAvLyB1c2Ugbm9kZWpzIGFzeW5jIEFQSVxuICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzLnRvU3RyaW5nKCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1c2Ugbm9kZWpzIHN5bmMgQVBJXG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGZ1bmN0aW9uKG5lZWRlZCkge1xuICAgICAgcmV0dXJuIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkKS50b1N0cmluZygpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNlZWRGaWxlID0gZnVuY3Rpb24obmVlZGVkLCBjYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGVmYXVsdFNlZWRGaWxlKG5lZWRlZCkpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGRlZmF1bHRTZWVkRmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGVudHJvcHkgdG8gYSBwcm5nIGN0eCdzIGFjY3VtdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIG9mIGVudHJvcHkgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjdHguY29sbGVjdCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBvb2xzIGRpc3RyaWJ1dGluZyBlbnRyb3B5IGN5Y2xpY2FsbHlcbiAgICB2YXIgY291bnQgPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGN0eC5wb29sc1tjdHgucG9vbF0udXBkYXRlKGJ5dGVzLnN1YnN0cihpLCAxKSk7XG4gICAgICBjdHgucG9vbCA9IChjdHgucG9vbCA9PT0gMzEpID8gMCA6IGN0eC5wb29sICsgMTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbGxlY3RzIGFuIGludGVnZXIgb2YgbiBiaXRzLlxuICAgKlxuICAgKiBAcGFyYW0gaSB0aGUgaW50ZWdlciBlbnRyb3B5LlxuICAgKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gICAqL1xuICBjdHguY29sbGVjdEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgICB2YXIgYnl0ZXMgPSAnJztcbiAgICBmb3IodmFyIHggPSAwOyB4IDwgbjsgeCArPSA4KSB7XG4gICAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IHgpICYgMHhGRik7XG4gICAgfVxuICAgIGN0eC5jb2xsZWN0KGJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgV2ViIFdvcmtlciB0byByZWNlaXZlIGltbWVkaWF0ZSBlbnRyb3B5IGZyb20gdGhlIG1haW4gdGhyZWFkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB1bnRpbCBXZWIgV29ya2VycyBjYW4gYWNjZXNzIHRoZSBuYXRpdmUgY3J5cHRvXG4gICAqIEFQSS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0d2ljZSBmb3IgZWFjaCBjcmVhdGVkIHdvcmtlciwgb25jZSBpblxuICAgKiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBvbmNlIGluIHRoZSB3b3JrZXIgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gd29ya2VyIHRoZSB3b3JrZXIgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBjdHgucmVnaXN0ZXJXb3JrZXIgPSBmdW5jdGlvbih3b3JrZXIpIHtcbiAgICAvLyB3b3JrZXIgcmVjZWl2ZXMgcmFuZG9tIGJ5dGVzXG4gICAgaWYod29ya2VyID09PSBzZWxmKSB7XG4gICAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YS5mb3JnZS5wcm5nLmVyciwgZGF0YS5mb3JnZS5wcm5nLmJ5dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtmb3JnZToge3Bybmc6IHtuZWVkZWQ6IG5lZWRlZH19fSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWluIHRocmVhZCBzZW5kcyByYW5kb20gYnl0ZXMgdXBvbiByZXF1ZXN0XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgIGN0eC5zZWVkRmlsZShkYXRhLmZvcmdlLnBybmcubmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe2ZvcmdlOiB7cHJuZzoge2VycjogZXJyLCBieXRlczogYnl0ZXN9fX0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhlIHdvcmtlciBkaWVzP1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjdHg7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBSQzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBJbmZvcm1hdGlvbiBvbiB0aGUgUkMyIGNpcGhlciBpcyBhdmFpbGFibGUgZnJvbSBSRkMgIzIyNjgsXG4gKiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjY4LnR4dFxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHBpVGFibGUgPSBbXG4gIDB4ZDksIDB4NzgsIDB4ZjksIDB4YzQsIDB4MTksIDB4ZGQsIDB4YjUsIDB4ZWQsIDB4MjgsIDB4ZTksIDB4ZmQsIDB4NzksIDB4NGEsIDB4YTAsIDB4ZDgsIDB4OWQsXG4gIDB4YzYsIDB4N2UsIDB4MzcsIDB4ODMsIDB4MmIsIDB4NzYsIDB4NTMsIDB4OGUsIDB4NjIsIDB4NGMsIDB4NjQsIDB4ODgsIDB4NDQsIDB4OGIsIDB4ZmIsIDB4YTIsXG4gIDB4MTcsIDB4OWEsIDB4NTksIDB4ZjUsIDB4ODcsIDB4YjMsIDB4NGYsIDB4MTMsIDB4NjEsIDB4NDUsIDB4NmQsIDB4OGQsIDB4MDksIDB4ODEsIDB4N2QsIDB4MzIsXG4gIDB4YmQsIDB4OGYsIDB4NDAsIDB4ZWIsIDB4ODYsIDB4YjcsIDB4N2IsIDB4MGIsIDB4ZjAsIDB4OTUsIDB4MjEsIDB4MjIsIDB4NWMsIDB4NmIsIDB4NGUsIDB4ODIsXG4gIDB4NTQsIDB4ZDYsIDB4NjUsIDB4OTMsIDB4Y2UsIDB4NjAsIDB4YjIsIDB4MWMsIDB4NzMsIDB4NTYsIDB4YzAsIDB4MTQsIDB4YTcsIDB4OGMsIDB4ZjEsIDB4ZGMsXG4gIDB4MTIsIDB4NzUsIDB4Y2EsIDB4MWYsIDB4M2IsIDB4YmUsIDB4ZTQsIDB4ZDEsIDB4NDIsIDB4M2QsIDB4ZDQsIDB4MzAsIDB4YTMsIDB4M2MsIDB4YjYsIDB4MjYsXG4gIDB4NmYsIDB4YmYsIDB4MGUsIDB4ZGEsIDB4NDYsIDB4NjksIDB4MDcsIDB4NTcsIDB4MjcsIDB4ZjIsIDB4MWQsIDB4OWIsIDB4YmMsIDB4OTQsIDB4NDMsIDB4MDMsXG4gIDB4ZjgsIDB4MTEsIDB4YzcsIDB4ZjYsIDB4OTAsIDB4ZWYsIDB4M2UsIDB4ZTcsIDB4MDYsIDB4YzMsIDB4ZDUsIDB4MmYsIDB4YzgsIDB4NjYsIDB4MWUsIDB4ZDcsXG4gIDB4MDgsIDB4ZTgsIDB4ZWEsIDB4ZGUsIDB4ODAsIDB4NTIsIDB4ZWUsIDB4ZjcsIDB4ODQsIDB4YWEsIDB4NzIsIDB4YWMsIDB4MzUsIDB4NGQsIDB4NmEsIDB4MmEsXG4gIDB4OTYsIDB4MWEsIDB4ZDIsIDB4NzEsIDB4NWEsIDB4MTUsIDB4NDksIDB4NzQsIDB4NGIsIDB4OWYsIDB4ZDAsIDB4NWUsIDB4MDQsIDB4MTgsIDB4YTQsIDB4ZWMsXG4gIDB4YzIsIDB4ZTAsIDB4NDEsIDB4NmUsIDB4MGYsIDB4NTEsIDB4Y2IsIDB4Y2MsIDB4MjQsIDB4OTEsIDB4YWYsIDB4NTAsIDB4YTEsIDB4ZjQsIDB4NzAsIDB4MzksXG4gIDB4OTksIDB4N2MsIDB4M2EsIDB4ODUsIDB4MjMsIDB4YjgsIDB4YjQsIDB4N2EsIDB4ZmMsIDB4MDIsIDB4MzYsIDB4NWIsIDB4MjUsIDB4NTUsIDB4OTcsIDB4MzEsXG4gIDB4MmQsIDB4NWQsIDB4ZmEsIDB4OTgsIDB4ZTMsIDB4OGEsIDB4OTIsIDB4YWUsIDB4MDUsIDB4ZGYsIDB4MjksIDB4MTAsIDB4NjcsIDB4NmMsIDB4YmEsIDB4YzksXG4gIDB4ZDMsIDB4MDAsIDB4ZTYsIDB4Y2YsIDB4ZTEsIDB4OWUsIDB4YTgsIDB4MmMsIDB4NjMsIDB4MTYsIDB4MDEsIDB4M2YsIDB4NTgsIDB4ZTIsIDB4ODksIDB4YTksXG4gIDB4MGQsIDB4MzgsIDB4MzQsIDB4MWIsIDB4YWIsIDB4MzMsIDB4ZmYsIDB4YjAsIDB4YmIsIDB4NDgsIDB4MGMsIDB4NWYsIDB4YjksIDB4YjEsIDB4Y2QsIDB4MmUsXG4gIDB4YzUsIDB4ZjMsIDB4ZGIsIDB4NDcsIDB4ZTUsIDB4YTUsIDB4OWMsIDB4NzcsIDB4MGEsIDB4YTYsIDB4MjAsIDB4NjgsIDB4ZmUsIDB4N2YsIDB4YzEsIDB4YWRcbl07XG5cbnZhciBzID0gWzEsIDIsIDMsIDVdO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHdvcmQgbGVmdCBieSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBCaXRzIHRoYXQgYXJlIHNoaWZ0ZWQgb3V0IG9uIHRoZSBsZWZ0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgcmlnaHRcbiAqIGhhbmQgc2lkZS5cbiAqXG4gKiBAcGFyYW0gd29yZCBUaGUgd29yZCB0byBzaGlmdCBsZWZ0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9sID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkIDw8IGJpdHMpICYgMHhmZmZmKSB8ICgod29yZCAmIDB4ZmZmZikgPj4gKDE2IC0gYml0cykpO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB3b3JkIHJpZ2h0IGJ5IGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIEJpdHMgdGhhdCBhcmUgc2hpZnRlZCBvdXQgb24gdGhlIHJpZ2h0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgbGVmdFxuICogaGFuZCBzaWRlLlxuICpcbiAqIEBwYXJhbSB3b3JkIFRoZSB3b3JkIHRvIHNoaWZ0IHJpZ2h0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9yID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkICYgMHhmZmZmKSA+PiBiaXRzKSB8ICgod29yZCA8PCAoMTYgLSBiaXRzKSkgJiAweGZmZmYpO1xufTtcblxuLyogUkMyIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYzIgPSBmb3JnZS5yYzIgfHwge307XG5cbi8qKlxuICogUGVyZm9ybSBSQzIga2V5IGV4cGFuc2lvbiBhcyBwZXIgUkZDICMyMjY4LCBzZWN0aW9uIDIuXG4gKlxuICogQHBhcmFtIGtleSB2YXJpYWJsZS1sZW5ndGggdXNlciBrZXkgKGJldHdlZW4gMSBhbmQgMTI4IGJ5dGVzKVxuICogQHBhcmFtIGVmZktleUJpdHMgbnVtYmVyIG9mIGVmZmVjdGl2ZSBrZXkgYml0cyAoZGVmYXVsdDogMTI4KVxuICogQHJldHVybiB0aGUgZXhwYW5kZWQgUkMyIGtleSAoQnl0ZUJ1ZmZlciBvZiAxMjggYnl0ZXMpXG4gKi9cbmZvcmdlLnJjMi5leHBhbmRLZXkgPSBmdW5jdGlvbihrZXksIGVmZktleUJpdHMpIHtcbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9XG4gIGVmZktleUJpdHMgPSBlZmZLZXlCaXRzIHx8IDEyODtcblxuICAvKiBpbnRyb2R1Y2UgdmFyaWFibGVzIHRoYXQgbWF0Y2ggdGhlIG5hbWVzIHVzZWQgaW4gUkZDICMyMjY4ICovXG4gIHZhciBMID0ga2V5O1xuICB2YXIgVCA9IGtleS5sZW5ndGgoKTtcbiAgdmFyIFQxID0gZWZmS2V5Qml0cztcbiAgdmFyIFQ4ID0gTWF0aC5jZWlsKFQxIC8gOCk7XG4gIHZhciBUTSA9IDB4ZmYgPj4gKFQxICYgMHgwNyk7XG4gIHZhciBpO1xuXG4gIGZvcihpID0gVDsgaSA8IDEyODsgaSsrKSB7XG4gICAgTC5wdXRCeXRlKHBpVGFibGVbKEwuYXQoaSAtIDEpICsgTC5hdChpIC0gVCkpICYgMHhmZl0pO1xuICB9XG5cbiAgTC5zZXRBdCgxMjggLSBUOCwgcGlUYWJsZVtMLmF0KDEyOCAtIFQ4KSAmIFRNXSk7XG5cbiAgZm9yKGkgPSAxMjcgLSBUODsgaSA+PSAwOyBpLS0pIHtcbiAgICBMLnNldEF0KGksIHBpVGFibGVbTC5hdChpICsgMSkgXiBMLmF0KGkgKyBUOCldKTtcbiAgfVxuXG4gIHJldHVybiBMO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUkMyIGNpcGhlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKGFzIGJhc2UgZm9yIGtleSBnZW5lcmF0aW9uKS5cbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgZWZmZWN0aXZlIGtleSBiaXRzLlxuICogQHBhcmFtIGVuY3J5cHQgZmFsc2UgZm9yIGRlY3J5cHRpb24sIHRydWUgZm9yIGVuY3J5cHRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG52YXIgY3JlYXRlQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzLCBlbmNyeXB0KSB7XG4gIHZhciBfZmluaXNoID0gZmFsc2UsIF9pbnB1dCA9IG51bGwsIF9vdXRwdXQgPSBudWxsLCBfaXYgPSBudWxsO1xuICB2YXIgbWl4Um91bmQsIG1hc2hSb3VuZDtcbiAgdmFyIGksIGosIEsgPSBbXTtcblxuICAvKiBFeHBhbmQga2V5IGFuZCBmaWxsIGludG8gS1tdIEFycmF5ICovXG4gIGtleSA9IGZvcmdlLnJjMi5leHBhbmRLZXkoa2V5LCBiaXRzKTtcbiAgZm9yKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIEsucHVzaChrZXkuZ2V0SW50MTZMZSgpKTtcbiAgfVxuXG4gIGlmKGVuY3J5cHQpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtaXhpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1peGluZyBvbi5cbiAgICAgKi9cbiAgICBtaXhSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgUltpXSA9IHJvbChSW2ldLCBzW2ldKTtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtYXNoaW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtYXNoaW5nIG9uLlxuICAgICAqL1xuICAgIG1hc2hSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1peGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWl4aW5nIG9uLlxuICAgICAqL1xuICAgIG1peFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldID0gcm9yKFJbaV0sIHNbaV0pO1xuICAgICAgICBSW2ldIC09IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1hc2hpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1hc2hpbmcgb24uXG4gICAgICovXG4gICAgbWFzaFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldIC09IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhlIHNwZWNpZmllZCBjaXBoZXIgZXhlY3V0aW9uIHBsYW4uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgZm91ciB3b3JkcyBmcm9tIHRoZSBpbnB1dCBidWZmZXIsIGFwcGxpZXMgdGhlIElWIG9uXG4gICAqIGl0IChpZiByZXF1ZXN0ZWQpIGFuZCBydW5zIHRoZSBwcm92aWRlZCBleGVjdXRpb24gcGxhbi5cbiAgICpcbiAgICogVGhlIHBsYW4gbXVzdCBiZSBwdXQgdG9nZXRoZXIgaW4gZm9ybSBvZiBhIGFycmF5IG9mIGFycmF5cy4gIFdoZXJlIHRoZVxuICAgKiBvdXRlciBvbmUgaXMgc2ltcGx5IGEgbGlzdCBvZiBzdGVwcyB0byBwZXJmb3JtIGFuZCB0aGUgaW5uZXIgb25lIG5lZWRzXG4gICAqIHRvIGhhdmUgdHdvIGVsZW1lbnRzOiB0aGUgZmlyc3Qgb25lIHRlbGxpbmcgaG93IG1hbnkgcm91bmRzIHRvIHBlcmZvcm0sXG4gICAqIHRoZSBzZWNvbmQgb25lIHRlbGxpbmcgd2hhdCB0byBkbyAoaS5lLiB0aGUgZnVuY3Rpb24gdG8gY2FsbCkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBsYW4gVGhlIHBsYW4gdG8gZXhlY3V0ZS5cbiAgICovXG4gIHZhciBydW5QbGFuID0gZnVuY3Rpb24ocGxhbikge1xuICAgIHZhciBSID0gW107XG5cbiAgICAvKiBHZXQgZGF0YSBmcm9tIGlucHV0IGJ1ZmZlciBhbmQgZmlsbCB0aGUgZm91ciB3b3JkcyBpbnRvIFIgKi9cbiAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSBfaW5wdXQuZ2V0SW50MTZMZSgpO1xuXG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcsIGFwcGx5IHRoZSBJViBmaXJzdC4gKi9cbiAgICAgICAgICB2YWwgXj0gX2l2LmdldEludDE2TGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBXZSdyZSBkZWNyeXB0aW9uLCBrZWVwIGNpcGhlciB0ZXh0IGZvciBuZXh0IGJsb2NrLiAqL1xuICAgICAgICAgIF9pdi5wdXRJbnQxNkxlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUi5wdXNoKHZhbCAmIDB4ZmZmZik7XG4gICAgfVxuXG4gICAgLyogUmVzZXQgZ2xvYmFsIFwialwiIHZhcmlhYmxlIGFzIHBlciBzcGVjLiAqL1xuICAgIGogPSBlbmNyeXB0ID8gMCA6IDYzO1xuXG4gICAgLyogUnVuIGV4ZWN1dGlvbiBwbGFuLiAqL1xuICAgIGZvcih2YXIgcHRyID0gMDsgcHRyIDwgcGxhbi5sZW5ndGg7IHB0cisrKSB7XG4gICAgICBmb3IodmFyIGN0ciA9IDA7IGN0ciA8IHBsYW5bcHRyXVswXTsgY3RyKyspIHtcbiAgICAgICAgcGxhbltwdHJdWzFdKFIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFdyaXRlIGJhY2sgcmVzdWx0IHRvIG91dHB1dCBidWZmZXIuICovXG4gICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcgaW4gQ0JDLW1vZGUsIGZlZWQgYmFjayBlbmNyeXB0ZWQgYnl0ZXMgaW50b1xuICAgICAgICAgICAgIElWIGJ1ZmZlciB0byBjYXJyeSBpdCBmb3J3YXJkIHRvIG5leHQgYmxvY2suICovXG4gICAgICAgICAgX2l2LnB1dEludDE2TGUoUltpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUltpXSBePSBfaXYuZ2V0SW50MTZMZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vdXRwdXQucHV0SW50MTZMZShSW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyogQ3JlYXRlIGNpcGhlciBvYmplY3QgKi9cbiAgdmFyIGNpcGhlciA9IG51bGw7XG4gIGNpcGhlciA9IHtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLCB3aGljaGV2ZXJcbiAgICAgKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICAgICAqXG4gICAgICogVG8gdXNlIHRoZSBjaXBoZXIgaW4gQ0JDIG1vZGUsIGl2IG1heSBiZSBnaXZlbiBlaXRoZXIgYXMgYSBzdHJpbmdcbiAgICAgKiBvZiBieXRlcywgb3IgYXMgYSBieXRlIGJ1ZmZlci4gIEZvciBFQ0IgbW9kZSwgZ2l2ZSBudWxsIGFzIGl2LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLCBudWxsIGZvciBFQ0IgbW9kZS5cbiAgICAgKiBAcGFyYW0gb3V0cHV0IHRoZSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbihpdiwgb3V0cHV0KSB7XG4gICAgICBpZihpdikge1xuICAgICAgICAvKiBDQkMgbW9kZSAqL1xuICAgICAgICBpZih0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihpdik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2ZpbmlzaCA9IGZhbHNlO1xuICAgICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9vdXRwdXQgPSBvdXRwdXQgfHwgbmV3IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfaXYgPSBpdjtcblxuICAgICAgY2lwaGVyLm91dHB1dCA9IF9vdXRwdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYoIV9maW5pc2gpIHtcbiAgICAgICAgLy8gbm90IGZpbmlzaGluZywgc28gZmlsbCB0aGUgaW5wdXQgYnVmZmVyIHdpdGggbW9yZSBpbnB1dFxuICAgICAgICBfaW5wdXQucHV0QnVmZmVyKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoX2lucHV0Lmxlbmd0aCgpID49IDgpIHtcbiAgICAgICAgcnVuUGxhbihbXG4gICAgICAgICAgICBbIDUsIG1peFJvdW5kIF0sXG4gICAgICAgICAgICBbIDEsIG1hc2hSb3VuZCBdLFxuICAgICAgICAgICAgWyA2LCBtaXhSb3VuZCBdLFxuICAgICAgICAgICAgWyAxLCBtYXNoUm91bmQgXSxcbiAgICAgICAgICAgIFsgNSwgbWl4Um91bmQgXVxuICAgICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2hlcyBlbmNyeXB0aW5nIG9yIGRlY3J5cHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFkIGEgcGFkZGluZyBmdW5jdGlvbiB0byB1c2UsIG51bGwgZm9yIFBLQ1MjNyBwYWRkaW5nLFxuICAgICAqICAgICAgICAgICBzaWduYXR1cmUoYmxvY2tTaXplLCBidWZmZXIsIGRlY3J5cHQpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICAgICAqL1xuICAgIGZpbmlzaDogZnVuY3Rpb24ocGFkKSB7XG4gICAgICB2YXIgcnZhbCA9IHRydWU7XG5cbiAgICAgIGlmKGVuY3J5cHQpIHtcbiAgICAgICAgaWYocGFkKSB7XG4gICAgICAgICAgcnZhbCA9IHBhZCg4LCBfaW5wdXQsICFlbmNyeXB0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gICAgICAgICAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSAoX2lucHV0Lmxlbmd0aCgpID09PSA4KSA/IDggOiAoOCAtIF9pbnB1dC5sZW5ndGgoKSk7XG4gICAgICAgICAgX2lucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nLCBwYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihydmFsKSB7XG4gICAgICAgIC8vIGRvIGZpbmFsIHVwZGF0ZVxuICAgICAgICBfZmluaXNoID0gdHJ1ZTtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZighZW5jcnlwdCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2sgc2l6ZVxuICAgICAgICBydmFsID0gKF9pbnB1dC5sZW5ndGgoKSA9PT0gMCk7XG4gICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICBpZihwYWQpIHtcbiAgICAgICAgICAgIHJ2YWwgPSBwYWQoOCwgX291dHB1dCwgIWVuY3J5cHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgcGFkZGluZyBieXRlIGNvdW50IGlzIHZhbGlkXG4gICAgICAgICAgICB2YXIgbGVuID0gX291dHB1dC5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IF9vdXRwdXQuYXQobGVuIC0gMSk7XG5cbiAgICAgICAgICAgIGlmKGNvdW50ID4gbGVuKSB7XG4gICAgICAgICAgICAgIHJ2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgICAgICAgICAgICAgX291dHB1dC50cnVuY2F0ZShjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXJcbiAqIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKiBUaGUgY2lwaGVyIGlzIGluaXRpYWxpemVkIHRvIHVzZSAxMjggZWZmZWN0aXZlIGtleSBiaXRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuc3RhcnRFbmNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0KSB7XG4gIHZhciBjaXBoZXIgPSBmb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gIGNpcGhlci5zdGFydChpdiwgb3V0cHV0KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIFRvIHN0YXJ0IGVuY3J5cHRpbmcgY2FsbCBzdGFydCgpIG9uIHRoZSBjaXBoZXIgd2l0aCBhbiBpdiBhbmQgb3B0aW9uYWxcbiAqIG91dHB1dCBidWZmZXIuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgYml0cykge1xuICByZXR1cm4gY3JlYXRlQ2lwaGVyKGtleSwgYml0cywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlclxuICogb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqIFRoZSBjaXBoZXIgaXMgaW5pdGlhbGl6ZWQgdG8gdXNlIDEyOCBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQpIHtcbiAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgY2lwaGVyLnN0YXJ0KGl2LCBvdXRwdXQpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogVG8gc3RhcnQgZGVjcnlwdGluZyBjYWxsIHN0YXJ0KCkgb24gdGhlIGNpcGhlciB3aXRoIGFuIGl2IGFuZCBvcHRpb25hbFxuICogb3V0cHV0IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzKSB7XG4gIHJldHVybiBjcmVhdGVDaXBoZXIoa2V5LCBiaXRzLCBmYWxzZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBQYXJ0aWFsIGltcGxlbWVudGF0aW9uIG9mIFBLQ1MjMSB2Mi4yOiBSU0EtT0VBUFxuICpcbiAqIE1vZGlmaWVkIGJ1dCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIE1JVCBhbmQgQlNEIGxpY2Vuc2VkIGNvZGU6XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2tqdXIvanNqd3MvYmxvYi9tYXN0ZXIvcnNhLmpzOlxuICpcbiAqIFRoZSAnanNqd3MnKEpTT04gV2ViIFNpZ25hdHVyZSBKYXZhU2NyaXB0IExpYnJhcnkpIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgS2VuamkgVXJ1c2hpbWFcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIGh0dHA6Ly93ZWJyc2EuY3ZzLnNvdXJjZWZvcmdlLm5ldC92aWV3dmMvd2VicnNhL0NsaWVudC9SU0FFUy1PQUVQLmpzP2NvbnRlbnQtdHlwZT10ZXh0JTJGcGxhaW46XG4gKlxuICogUlNBRVMtT0FFUC5qc1xuICogJElkOiBSU0FFUy1PQUVQLmpzLHYgMS4xLjEuMSAyMDAzLzAzLzE5IDE1OjM3OjIwIGVsbGlzcHJpdGNoYXJkIEV4cCAkXG4gKiBKYXZhU2NyaXB0IEltcGxlbWVudGF0aW9uIG9mIFBLQ1MgIzEgdjIuMSBSU0EgQ1JZUFRPR1JBUEhZIFNUQU5EQVJEIChSU0EgTGFib3JhdG9yaWVzLCBKdW5lIDE0LCAyMDAyKVxuICogQ29weXJpZ2h0IChDKSBFbGxpcyBQcml0Y2hhcmQsIEd1YXJkaWFuIFVubGltaXRlZCAyMDAzLlxuICogQ29udGFjdDogZWxsaXNAbnVraW5ldGljcy5jb21cbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbiAqXG4gKiBPZmZpY2lhbCBkb2N1bWVudGF0aW9uOiBodHRwOi8vd3d3LnJzYS5jb20vcnNhbGFicy9ub2RlLmFzcD9pZD0yMTI1XG4gKlxuICogQGF1dGhvciBFdmFuIEpvbmVzIChodHRwOi8vZXZhbmpvbmVzLmNhLylcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbi8vIHNob3J0Y3V0IGZvciBQS0NTIzEgQVBJXG52YXIgcGtjczEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3MxID0gZm9yZ2UucGtjczEgfHwge307XG5cbi8qKlxuICogRW5jb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIG1lc3NhZ2UgKE0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbCBsYWJlbCAoTClcbiAqIGFuZCBzZWVkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGVuY3J5cHRpb24sIGl0IG9ubHkgZW5jb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIHNlZWQgdGhlIHNlZWQgdG8gdXNlLlxuICogICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UsIHVuZGVmaW5lZCBmb3IgU0hBLTEuXG4gKiAgICAgICAgICBtZ2YxIG9wdGlvbmFsIG1nZjEgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE1HRjEuXG4gKlxuICogQHJldHVybiB0aGUgZW5jb2RlZCBtZXNzYWdlIGJ5dGVzLlxuICovXG5wa2NzMS5lbmNvZGVfcnNhX29hZXAgPSBmdW5jdGlvbihrZXksIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgLy8gcGFyc2UgYXJndW1lbnRzXG4gIHZhciBsYWJlbDtcbiAgdmFyIHNlZWQ7XG4gIHZhciBtZDtcbiAgdmFyIG1nZjFNZDtcbiAgLy8gbGVnYWN5IGFyZ3MgKGxhYmVsLCBzZWVkLCBtZClcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zO1xuICAgIHNlZWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gYXJndW1lbnRzWzRdIHx8IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmKG9wdGlvbnMpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgdW5kZWZpbmVkO1xuICAgIHNlZWQgPSBvcHRpb25zLnNlZWQgfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gb3B0aW9ucy5tZCB8fCB1bmRlZmluZWQ7XG4gICAgaWYob3B0aW9ucy5tZ2YxICYmIG9wdGlvbnMubWdmMS5tZCkge1xuICAgICAgbWdmMU1kID0gb3B0aW9ucy5tZ2YxLm1kO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlZmF1bHQgT0FFUCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZighbWQpIHtcbiAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgbWQuc3RhcnQoKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgTUdGLTEgdG8gc2FtZSBhcyBPQUVQXG4gIGlmKCFtZ2YxTWQpIHtcbiAgICBtZ2YxTWQgPSBtZDtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgbGVuZ3RoIGluIGJ5dGVzIGFuZCBjaGVjayBvdXRwdXRcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICB2YXIgbWF4TGVuZ3RoID0ga2V5TGVuZ3RoIC0gMiAqIG1kLmRpZ2VzdExlbmd0aCAtIDI7XG4gIGlmKG1lc3NhZ2UubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGlucHV0IG1lc3NhZ2UgbGVuZ3RoIGlzIHRvbyBsb25nLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoO1xuICAgIGVycm9yLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKCFsYWJlbCkge1xuICAgIGxhYmVsID0gJyc7XG4gIH1cbiAgbWQudXBkYXRlKGxhYmVsLCAncmF3Jyk7XG4gIHZhciBsSGFzaCA9IG1kLmRpZ2VzdCgpO1xuXG4gIHZhciBQUyA9ICcnO1xuICB2YXIgUFNfbGVuZ3RoID0gbWF4TGVuZ3RoIC0gbWVzc2FnZS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgUFNfbGVuZ3RoOyBpKyspIHtcbiAgICBQUyArPSAnXFx4MDAnO1xuICB9XG5cbiAgdmFyIERCID0gbEhhc2guZ2V0Qnl0ZXMoKSArIFBTICsgJ1xceDAxJyArIG1lc3NhZ2U7XG5cbiAgaWYoIXNlZWQpIHtcbiAgICBzZWVkID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG1kLmRpZ2VzdExlbmd0aCk7XG4gIH0gZWxzZSBpZihzZWVkLmxlbmd0aCAhPT0gbWQuZGlnZXN0TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIFJTQUVTLU9BRVAgc2VlZC4gVGhlIHNlZWQgbGVuZ3RoIG11c3QgJyArXG4gICAgICAnbWF0Y2ggdGhlIGRpZ2VzdCBsZW5ndGguJyk7XG4gICAgZXJyb3Iuc2VlZExlbmd0aCA9IHNlZWQubGVuZ3RoO1xuICAgIGVycm9yLmRpZ2VzdExlbmd0aCA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgbWFza2VkREIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKERCLCBkYk1hc2ssIERCLmxlbmd0aCk7XG5cbiAgdmFyIHNlZWRNYXNrID0gcnNhX21nZjEobWFza2VkREIsIG1kLmRpZ2VzdExlbmd0aCwgbWdmMU1kKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHNlZWQsIHNlZWRNYXNrLCBzZWVkLmxlbmd0aCk7XG5cbiAgLy8gcmV0dXJuIGVuY29kZWQgbWVzc2FnZVxuICByZXR1cm4gJ1xceDAwJyArIG1hc2tlZFNlZWQgKyBtYXNrZWREQjtcbn07XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSAoRU0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbFxuICogbGFiZWwgKEwpLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGRlY3J5cHRpb24sIGl0IG9ubHkgZGVjb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBlbSB0aGUgZW5jb2RlZCBtZXNzYWdlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBPQUVQLCB1bmRlZmluZWQgZm9yIFNIQS0xLlxuICogICAgICAgICAgbWdmMSBvcHRpb25hbCBtZ2YxIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBNR0YxLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgbWVzc2FnZSBieXRlcy5cbiAqL1xucGtjczEuZGVjb2RlX3JzYV9vYWVwID0gZnVuY3Rpb24oa2V5LCBlbSwgb3B0aW9ucykge1xuICAvLyBwYXJzZSBhcmdzXG4gIHZhciBsYWJlbDtcbiAgdmFyIG1kO1xuICB2YXIgbWdmMU1kO1xuICAvLyBsZWdhY3kgYXJnc1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnM7XG4gICAgbWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYob3B0aW9ucykge1xuICAgIGxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCB1bmRlZmluZWQ7XG4gICAgbWQgPSBvcHRpb25zLm1kIHx8IHVuZGVmaW5lZDtcbiAgICBpZihvcHRpb25zLm1nZjEgJiYgb3B0aW9ucy5tZ2YxLm1kKSB7XG4gICAgICBtZ2YxTWQgPSBvcHRpb25zLm1nZjEubWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcHV0ZSBsZW5ndGggaW4gYnl0ZXNcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIGlmKGVtLmxlbmd0aCAhPT0ga2V5TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlbS5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWRMZW5ndGggPSBrZXlMZW5ndGg7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBkZWZhdWx0IE9BRVAgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYobWQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBtZC5zdGFydCgpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCBNR0YtMSB0byBzYW1lIGFzIE9BRVBcbiAgaWYoIW1nZjFNZCkge1xuICAgIG1nZjFNZCA9IG1kO1xuICB9XG5cbiAgaWYoa2V5TGVuZ3RoIDwgMiAqIG1kLmRpZ2VzdExlbmd0aCArIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JTQUVTLU9BRVAga2V5IGlzIHRvbyBzaG9ydCBmb3IgdGhlIGhhc2ggZnVuY3Rpb24uJyk7XG4gIH1cblxuICBpZighbGFiZWwpIHtcbiAgICBsYWJlbCA9ICcnO1xuICB9XG4gIG1kLnVwZGF0ZShsYWJlbCwgJ3JhdycpO1xuICB2YXIgbEhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gIC8vIHNwbGl0IHRoZSBtZXNzYWdlIGludG8gaXRzIHBhcnRzXG4gIHZhciB5ID0gZW0uY2hhckF0KDApO1xuICB2YXIgbWFza2VkU2VlZCA9IGVtLnN1YnN0cmluZygxLCBtZC5kaWdlc3RMZW5ndGggKyAxKTtcbiAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyaW5nKDEgKyBtZC5kaWdlc3RMZW5ndGgpO1xuXG4gIHZhciBzZWVkTWFzayA9IHJzYV9tZ2YxKG1hc2tlZERCLCBtZC5kaWdlc3RMZW5ndGgsIG1nZjFNZCk7XG4gIHZhciBzZWVkID0gZm9yZ2UudXRpbC54b3JCeXRlcyhtYXNrZWRTZWVkLCBzZWVkTWFzaywgbWFza2VkU2VlZC5sZW5ndGgpO1xuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgZGIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKG1hc2tlZERCLCBkYk1hc2ssIG1hc2tlZERCLmxlbmd0aCk7XG5cbiAgdmFyIGxIYXNoUHJpbWUgPSBkYi5zdWJzdHJpbmcoMCwgbWQuZGlnZXN0TGVuZ3RoKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIHRoYXQgYWxsIHZhbHVlcyBtYXRjaCB3aGF0IGlzIGV4cGVjdGVkXG4gIHZhciBlcnJvciA9ICh5ICE9PSAnXFx4MDAnKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIGxIYXNoIHZzIGxIYXNoUHJpbWVcbiAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmRpZ2VzdExlbmd0aDsgKytpKSB7XG4gICAgZXJyb3IgfD0gKGxIYXNoLmNoYXJBdChpKSAhPT0gbEhhc2hQcmltZS5jaGFyQXQoaSkpO1xuICB9XG5cbiAgLy8gXCJjb25zdGFudCB0aW1lXCIgZmluZCB0aGUgMHgxIGJ5dGUgc2VwYXJhdGluZyB0aGUgcGFkZGluZyAoemVyb3MpIGZyb20gdGhlXG4gIC8vIG1lc3NhZ2VcbiAgLy8gVE9ETzogSXQgbXVzdCBiZSBwb3NzaWJsZSB0byBkbyB0aGlzIGluIGEgYmV0dGVyL3NtYXJ0ZXIgd2F5P1xuICB2YXIgaW5fcHMgPSAxO1xuICB2YXIgaW5kZXggPSBtZC5kaWdlc3RMZW5ndGg7XG4gIGZvcih2YXIgaiA9IG1kLmRpZ2VzdExlbmd0aDsgaiA8IGRiLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGNvZGUgPSBkYi5jaGFyQ29kZUF0KGopO1xuXG4gICAgdmFyIGlzXzAgPSAoY29kZSAmIDB4MSkgXiAweDE7XG5cbiAgICAvLyBub24temVybyBpZiBub3QgMCBvciAxIGluIHRoZSBwcyBzZWN0aW9uXG4gICAgdmFyIGVycm9yX21hc2sgPSBpbl9wcyA/IDB4ZmZmZSA6IDB4MDAwMDtcbiAgICBlcnJvciB8PSAoY29kZSAmIGVycm9yX21hc2spO1xuXG4gICAgLy8gbGF0Y2ggaW5fcHMgdG8gemVybyBhZnRlciB3ZSBmaW5kIDB4MVxuICAgIGluX3BzID0gaW5fcHMgJiBpc18wO1xuICAgIGluZGV4ICs9IGluX3BzO1xuICB9XG5cbiAgaWYoZXJyb3IgfHwgZGIuY2hhckNvZGVBdChpbmRleCkgIT09IDB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSU0FFUy1PQUVQIHBhZGRpbmcuJyk7XG4gIH1cblxuICByZXR1cm4gZGIuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG59O1xuXG5mdW5jdGlvbiByc2FfbWdmMShzZWVkLCBtYXNrTGVuZ3RoLCBoYXNoKSB7XG4gIC8vIGRlZmF1bHQgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYoIWhhc2gpIHtcbiAgICBoYXNoID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfVxuICB2YXIgdCA9ICcnO1xuICB2YXIgY291bnQgPSBNYXRoLmNlaWwobWFza0xlbmd0aCAvIGhhc2guZGlnZXN0TGVuZ3RoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAoaSA+PiAyNCkgJiAweEZGLCAoaSA+PiAxNikgJiAweEZGLCAoaSA+PiA4KSAmIDB4RkYsIGkgJiAweEZGKTtcbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUoc2VlZCArIGMpO1xuICAgIHQgKz0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICB9XG4gIHJldHVybiB0LnN1YnN0cmluZygwLCBtYXNrTGVuZ3RoKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogUHJpbWUgbnVtYmVyIGdlbmVyYXRpb24gQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnByaW1lIGFscmVhZHkgZGVmaW5lZFxuaWYoZm9yZ2UucHJpbWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcmltZTtcbiAgcmV0dXJuO1xufVxuXG4vKiBQUklNRSBBUEkgKi9cbnZhciBwcmltZSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJpbWUgPSBmb3JnZS5wcmltZSB8fCB7fTtcblxudmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG5cbi8vIHByaW1lcyBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xudmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuVEhJUlRZLmZyb21JbnQoMzApO1xudmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4fHk7fTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcHJvYmFibGUgcHJpbWUgd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQWx0ZXJuYXRpdmUgYWxnb3JpdGhtcyBjYW4gYmUgc3BlY2lmaWVkIGJ5IG5hbWUgYXMgYSBzdHJpbmcgb3IgYXMgYW5cbiAqIG9iamVjdCB3aXRoIGN1c3RvbSBvcHRpb25zIGxpa2Ugc286XG4gKlxuICoge1xuICogICBuYW1lOiAnUFJJTUVJTkMnLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgbWF4QmxvY2tUaW1lOiA8dGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gYmxvY2sgdGhlIG1haW5cbiAqICAgICAgIHRocmVhZCBiZWZvcmUgYWxsb3dpbmcgSS9PIG90aGVyIEpTIHRvIHJ1bj4sXG4gKiAgICAgbWlsbGVyUmFiaW5UZXN0czogPHRoZSBudW1iZXIgb2YgbWlsbGVyLXJhYmluIHRlc3RzIHRvIHJ1bj4sXG4gKiAgICAgd29ya2VyU2NyaXB0OiA8dGhlIHdvcmtlciBzY3JpcHQgVVJMPixcbiAqICAgICB3b3JrZXJzOiA8dGhlIG51bWJlciBvZiB3ZWIgd29ya2VycyAoaWYgc3VwcG9ydGVkKSB0byB1c2UsXG4gKiAgICAgICAtMSB0byB1c2UgZXN0aW1hdGVkIGNvcmVzIG1pbnVzIG9uZT4uXG4gKiAgICAgd29ya0xvYWQ6IHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgbnVtYmVyIG9mIGJpdHMgZm9yIHRoZSBwcmltZSBudW1iZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBbYWxnb3JpdGhtXSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiAgICAgICAgICBbcHJuZ10gYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuXG4gKlxuICogQHJldHVybiBjYWxsYmFjayhlcnIsIG51bSkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnByaW1lLmdlbmVyYXRlUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBkZWZhdWx0IHRvIFBSSU1FSU5DIGFsZ29yaXRobVxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcbiAgaWYodHlwZW9mIGFsZ29yaXRobSA9PT0gJ3N0cmluZycpIHtcbiAgICBhbGdvcml0aG0gPSB7bmFtZTogYWxnb3JpdGhtfTtcbiAgfVxuICBhbGdvcml0aG0ub3B0aW9ucyA9IGFsZ29yaXRobS5vcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICB2YXIgcm5nID0ge1xuICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgYiA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHgubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHhbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmKGFsZ29yaXRobS5uYW1lID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcmV0dXJuIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgYWxnb3JpdGhtLm9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmltZSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobS5uYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoJ3dvcmtlcnMnIGluIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIGluaXRpYWxpemUgcmFuZG9tIG51bWJlclxuICB2YXIgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcblxuICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybSAzMGsraSBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEuIFRoZVxuICBudW1iZXIgd2UgYXJlIGdpdmVuIGlzIGFsd2F5cyBhbGlnbmVkIGF0IDMwayArIDEuIEVhY2ggdGltZSB0aGUgbnVtYmVyIGlzXG4gIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlclxuICB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgdmFyIGRlbHRhSWR4ID0gMDtcblxuICAvLyBnZXQgcmVxdWlyZWQgbnVtYmVyIG9mIE1SIHRlc3RzXG4gIHZhciBtclRlc3RzID0gZ2V0TWlsbGVyUmFiaW5UZXN0cyhudW0uYml0TGVuZ3RoKCkpO1xuICBpZignbWlsbGVyUmFiaW5UZXN0cycgaW4gb3B0aW9ucykge1xuICAgIG1yVGVzdHMgPSBvcHRpb25zLm1pbGxlclJhYmluVGVzdHM7XG4gIH1cblxuICAvLyBmaW5kIHByaW1lIG5lYXJlc3QgdG8gJ251bScgZm9yIG1heEJsb2NrVGltZSBtc1xuICAvLyAxMCBtcyBnaXZlcyA1bXMgb2YgbGVld2F5IGZvciBvdGhlciBjYWxjdWxhdGlvbnMgYmVmb3JlIGRyb3BwaW5nXG4gIC8vIGJlbG93IDYwZnBzICgxMDAwLzYwID09IDE2LjY3KSwgYnV0IGluIHJlYWxpdHksIHRoZSBudW1iZXIgd2lsbFxuICAvLyBsaWtlbHkgYmUgaGlnaGVyIGR1ZSB0byBhbiAnYXRvbWljJyBiaWcgaW50IG1vZFBvd1xuICB2YXIgbWF4QmxvY2tUaW1lID0gMTA7XG4gIGlmKCdtYXhCbG9ja1RpbWUnIGluIG9wdGlvbnMpIHtcbiAgICBtYXhCbG9ja1RpbWUgPSBvcHRpb25zLm1heEJsb2NrVGltZTtcbiAgfVxuXG4gIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGFydCA9ICtuZXcgRGF0ZSgpO1xuICBkbyB7XG4gICAgLy8gb3ZlcmZsb3csIHJlZ2VuZXJhdGUgcmFuZG9tIG51bWJlclxuICAgIGlmKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgfVxuICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgaWYobnVtLmlzUHJvYmFibGVQcmltZShtclRlc3RzKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bSk7XG4gICAgfVxuICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgIG51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICB9IHdoaWxlKG1heEJsb2NrVGltZSA8IDAgfHwgKCtuZXcgRGF0ZSgpIC0gc3RhcnQgPCBtYXhCbG9ja1RpbWUpKTtcblxuICAvLyBrZWVwIHRyeWluZyBsYXRlclxuICBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8vIE5PVEU6IFRoaXMgYWxnb3JpdGhtIGlzIGluZGV0ZXJtaW5hdGUgaW4gbmF0dXJlIGJlY2F1c2Ugd29ya2Vyc1xuLy8gcnVuIGluIHBhcmFsbGVsIGxvb2tpbmcgYXQgZGlmZmVyZW50IHNlZ21lbnRzIG9mIG51bWJlcnMuIEV2ZW4gaWYgdGhpc1xuLy8gYWxnb3JpdGhtIGlzIHJ1biB0d2ljZSB3aXRoIHRoZSBzYW1lIGlucHV0IGZyb20gYSBwcmVkaWN0YWJsZSBSTkcsIGl0XG4vLyBtYXkgcHJvZHVjZSBkaWZmZXJlbnQgb3V0cHV0cy5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lV2l0aFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyB3ZWIgd29ya2VycyB1bmF2YWlsYWJsZVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSByYW5kb20gbnVtYmVyXG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuXG4gIC8vIHVzZSB3ZWIgd29ya2VycyB0byBnZW5lcmF0ZSBrZXlzXG4gIHZhciBudW1Xb3JrZXJzID0gb3B0aW9ucy53b3JrZXJzO1xuICB2YXIgd29ya0xvYWQgPSBvcHRpb25zLndvcmtMb2FkIHx8IDEwMDtcbiAgdmFyIHJhbmdlID0gd29ya0xvYWQgKiAzMCAvIDg7XG4gIHZhciB3b3JrZXJTY3JpcHQgPSBvcHRpb25zLndvcmtlclNjcmlwdCB8fCAnZm9yZ2UvcHJpbWUud29ya2VyLmpzJztcbiAgaWYobnVtV29ya2VycyA9PT0gLTEpIHtcbiAgICByZXR1cm4gZm9yZ2UudXRpbC5lc3RpbWF0ZUNvcmVzKGZ1bmN0aW9uKGVyciwgY29yZXMpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIDJcbiAgICAgICAgY29yZXMgPSAyO1xuICAgICAgfVxuICAgICAgbnVtV29ya2VycyA9IGNvcmVzIC0gMTtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyByZXF1aXJlIGF0IGxlYXN0IDEgd29ya2VyXG4gICAgbnVtV29ya2VycyA9IE1hdGgubWF4KDEsIG51bVdvcmtlcnMpO1xuXG4gICAgLy8gVE9ETzogY29uc2lkZXIgb3B0aW1pemluZyBieSBzdGFydGluZyB3b3JrZXJzIG91dHNpZGUgZ2V0UHJpbWUoKSAuLi5cbiAgICAvLyBub3RlIHRoYXQgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhleSB3aWxsIGhhdmUgdG8gYmUgbWFkZSBpbnRlcm5hbGx5XG4gICAgLy8gYXN5bmNocm9ub3VzIHdoaWNoIG1heSBhY3R1YWxseSBiZSBzbG93ZXJcblxuICAgIC8vIHN0YXJ0IHdvcmtlcnMgaW1tZWRpYXRlbHlcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIC8vIEZJWE1FOiBmaXggcGF0aCBvciB1c2UgYmxvYiBVUkxzXG4gICAgICB3b3JrZXJzW2ldID0gbmV3IFdvcmtlcih3b3JrZXJTY3JpcHQpO1xuICAgIH1cbiAgICB2YXIgcnVubmluZyA9IG51bVdvcmtlcnM7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHJlcXVlc3RzIGZyb20gd29ya2VycyBhbmQgYXNzaWduIHJhbmdlcyB0byBmaW5kIHByaW1lXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyogTm90ZTogVGhlIGRpc3RyaWJ1dGlvbiBvZiByYW5kb20gbnVtYmVycyBpcyB1bmtub3duLiBUaGVyZWZvcmUsIGVhY2hcbiAgICB3ZWIgd29ya2VyIGlzIGNvbnRpbnVvdXNseSBhbGxvY2F0ZWQgYSByYW5nZSBvZiBudW1iZXJzIHRvIGNoZWNrIGZvciBhXG4gICAgcmFuZG9tIG51bWJlciB1bnRpbCBvbmUgaXMgZm91bmQuXG5cbiAgICBFdmVyeSAzMCBudW1iZXJzIHdpbGwgYmUgY2hlY2tlZCBqdXN0IDggdGltZXMsIGJlY2F1c2UgcHJpbWUgbnVtYmVyc1xuICAgIGhhdmUgdGhlIGZvcm06XG5cbiAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xICh0aGVyZSBhcmUgOCB2YWx1ZXMgb2YgaSBmb3IgdGhpcylcblxuICAgIFRoZXJlZm9yZSwgaWYgd2Ugd2FudCBhIHdlYiB3b3JrZXIgdG8gcnVuIE4gY2hlY2tzIGJlZm9yZSBhc2tpbmcgZm9yXG4gICAgYSBuZXcgcmFuZ2Ugb2YgbnVtYmVycywgZWFjaCByYW5nZSBtdXN0IGNvbnRhaW4gTiozMC84IG51bWJlcnMuXG5cbiAgICBGb3IgMTAwIGNoZWNrcyAod29ya0xvYWQpLCB0aGlzIGlzIGEgcmFuZ2Ugb2YgMzc1LiAqL1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gd29ya2VyTWVzc2FnZShlKSB7XG4gICAgICAvLyBpZ25vcmUgbWVzc2FnZSwgcHJpbWUgYWxyZWFkeSBmb3VuZFxuICAgICAgaWYoZm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAtLXJ1bm5pbmc7XG4gICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgIGlmKGRhdGEuZm91bmQpIHtcbiAgICAgICAgLy8gdGVybWluYXRlIGFsbCB3b3JrZXJzXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB3b3JrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQmlnSW50ZWdlcihkYXRhLnByaW1lLCAxNikpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVyZmxvdywgcmVnZW5lcmF0ZSByYW5kb20gbnVtYmVyXG4gICAgICBpZihudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc2lnbiBuZXcgcmFuZ2UgdG8gY2hlY2tcbiAgICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuXG4gICAgICAvLyBzdGFydCBwcmltZSBzZWFyY2hcbiAgICAgIGUudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaGV4OiBoZXgsXG4gICAgICAgIHdvcmtMb2FkOiB3b3JrTG9hZFxuICAgICAgfSk7XG5cbiAgICAgIG51bS5kQWRkT2Zmc2V0KHJhbmdlLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIHVzaW5nIHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cyBhbmQgUk5HLlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgYml0cyBmb3IgdGhlIG51bWJlci5cbiAqIEBwYXJhbSBybmcgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpIHtcbiAgdmFyIG51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHJuZyk7XG4gIC8vIGZvcmNlIE1TQiBzZXRcbiAgdmFyIGJpdHMxID0gYml0cyAtIDE7XG4gIGlmKCFudW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICBudW0uYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChiaXRzMSksIG9wX29yLCBudW0pO1xuICB9XG4gIC8vIGFsaWduIG51bWJlciBvbiAzMGsrMSBib3VuZGFyeVxuICBudW0uZEFkZE9mZnNldCgzMSAtIG51bS5tb2QoVEhJUlRZKS5ieXRlVmFsdWUoKSwgMCk7XG4gIHJldHVybiBudW07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIE1pbGxlci1SYWJpbiB0ZXN0cyB0byBnZW5lcmF0ZSBhXG4gKiBwcmltZSB3aXRoIGFuIGVycm9yIHByb2JhYmlsaXR5IG9mICgxLzIpXjgwLlxuICpcbiAqIFNlZSBIYW5kYm9vayBvZiBBcHBsaWVkIENyeXB0b2dyYXBoeSBDaGFwdGVyIDQsIFRhYmxlIDQuNC5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUuXG4gKlxuICogQHJldHVybiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBQS0NTIzEyLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBQS0NTIzEyIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgZnRwOi8vZnRwLnJzYXNlY3VyaXR5LmNvbS9wdWIvcGtjcy9wa2NzLTEyL3BrY3MtMTItdGMxLnBkZiBmb3IgZGV0YWlscylcbiAqXG4gKiBQRlggOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgSU5URUdFUiB7djMoMyl9KHYzLC4uLiksXG4gKiAgIGF1dGhTYWZlIENvbnRlbnRJbmZvLFxuICogICBtYWNEYXRhICBNYWNEYXRhIE9QVElPTkFMXG4gKiB9XG4gKlxuICogTWFjRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICBtYWMgRGlnZXN0SW5mbyxcbiAqICAgbWFjU2FsdCBPQ1RFVCBTVFJJTkcsXG4gKiAgIGl0ZXJhdGlvbnMgSU5URUdFUiBERUZBVUxUIDFcbiAqIH1cbiAqIE5vdGU6IFRoZSBpdGVyYXRpb25zIGRlZmF1bHQgaXMgZm9yIGhpc3RvcmljYWwgcmVhc29ucyBhbmQgaXRzIHVzZSBpc1xuICogZGVwcmVjYXRlZC4gQSBoaWdoZXIgdmFsdWUsIGxpa2UgMTAyNCwgaXMgcmVjb21tZW5kZWQuXG4gKlxuICogRGlnZXN0SW5mbyBpcyBkZWZpbmVkIGluIFBLQ1MjNyBhcyBmb2xsb3dzOlxuICpcbiAqIERpZ2VzdEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGRpZ2VzdCBEaWdlc3RcbiAqIH1cbiAqXG4gKiBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIFNIQTEgdGhlcmUgaXMgbm9uZS5cbiAqXG4gKiBBbGdvcml0aG1JZGVudGlmZXIgOjo9IFNFUVVFTkNFIHtcbiAqICAgIGFsZ29yaXRobSBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAqXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgIFswXSBFWFBMSUNJVCBBTlkgREVGSU5FRCBCWSBjb250ZW50VHlwZSBPUFRJT05BTFxuICogfVxuICpcbiAqIENvbnRlbnRUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICpcbiAqIEF1dGhlbnRpY2F0ZWRTYWZlIDo6PSBTRVFVRU5DRSBPRiBDb250ZW50SW5mb1xuICogLS0gRGF0YSBpZiB1bmVuY3J5cHRlZFxuICogLS0gRW5jcnlwdGVkRGF0YSBpZiBwYXNzd29yZC1lbmNyeXB0ZWRcbiAqIC0tIEVudmVsb3BlZERhdGEgaWYgcHVibGljIGtleS1lbmNyeXB0ZWRcbiAqXG4gKlxuICogU2FmZUNvbnRlbnRzIDo6PSBTRVFVRU5DRSBPRiBTYWZlQmFnXG4gKlxuICogU2FmZUJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBiYWdJZCAgICAgQkFHLVRZUEUuJmlkICh7UEtDUzEyQmFnU2V0fSlcbiAqICAgYmFnVmFsdWUgIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSh7UEtDUzEyQmFnU2V0fXtAYmFnSWR9KSxcbiAqICAgYmFnQXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogUEtDUzEyQXR0cmlidXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGF0dHJJZCBBVFRSSUJVVEUuJmlkICh7UEtDUzEyQXR0clNldH0pLFxuICogICBhdHRyVmFsdWVzIFNFVCBPRiBBVFRSSUJVVEUuJlR5cGUgKHtQS0NTMTJBdHRyU2V0fXtAYXR0cklkfSlcbiAqIH0gLS0gVGhpcyB0eXBlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgWC41MDAgdHlwZSDigJlBdHRyaWJ1dGXigJlcbiAqXG4gKiBQS0NTMTJBdHRyU2V0IEFUVFJJQlVURSA6Oj0ge1xuICogICBmcmllbmRseU5hbWUgfCAtLSBmcm9tIFBLQ1MgIzlcbiAqICAgbG9jYWxLZXlJZCwgLS0gZnJvbSBQS0NTICM5XG4gKiAgIC4uLiAtLSBPdGhlciBhdHRyaWJ1dGVzIGFyZSBhbGxvd2VkXG4gKiB9XG4gKlxuICogQ2VydEJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjZXJ0SWQgICAgQkFHLVRZUEUuJmlkICAgKHtDZXJ0VHlwZXN9KSxcbiAqICAgY2VydFZhbHVlIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSAoe0NlcnRUeXBlc317QGNlcnRJZH0pXG4gKiB9XG4gKlxuICogeDUwOUNlcnRpZmljYXRlIEJBRy1UWVBFIDo6PSB7T0NURVQgU1RSSU5HIElERU5USUZJRUQgQlkge2NlcnRUeXBlcyAxfX1cbiAqICAgLS0gREVSLWVuY29kZWQgWC41MDkgY2VydGlmaWNhdGUgc3RvcmVkIGluIE9DVEVUIFNUUklOR1xuICpcbiAqIHNkc2lDZXJ0aWZpY2F0ZSBCQUctVFlQRSA6Oj0ge0lBNVN0cmluZyBJREVOVElGSUVEIEJZIHtjZXJ0VHlwZXMgMn19XG4gKiAtLSBCYXNlNjQtZW5jb2RlZCBTRFNJIGNlcnRpZmljYXRlIHN0b3JlZCBpbiBJQTVTdHJpbmdcbiAqXG4gKiBDZXJ0VHlwZXMgQkFHLVRZUEUgOjo9IHtcbiAqICAgeDUwOUNlcnRpZmljYXRlIHxcbiAqICAgc2RzaUNlcnRpZmljYXRlLFxuICogICAuLi4gLS0gRm9yIGZ1dHVyZSBleHRlbnNpb25zXG4gKiB9XG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xICYgUEtJIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjMTIgQVBJXG52YXIgcDEyID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2NzMTIgPSBmb3JnZS5wa2NzMTIgfHwge307XG5cbnZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsICAvLyBhIENvbnRlbnRJbmZvXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NvbnRlbnQnXG4gIH1dXG59O1xuXG52YXIgcGZ4VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUEZYJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUEZYLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sXG4gIGNvbnRlbnRJbmZvVmFsaWRhdG9yLCB7XG4gICAgbmFtZTogJ1BGWC5tYWNEYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnbWFjJyxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLCAgLy8gRGlnZXN0SW5mb1xuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ1BGWC5tYWNEYXRhLm1hYy5kaWdlc3RBbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSwgIC8vIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMuZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYWNBbGdvcml0aG0nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6ICdtYWNBbGdvcml0aG1QYXJhbWV0ZXJzJ1xuICAgICAgICB9XVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdtYWNEaWdlc3QnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWNTYWx0JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdtYWNTYWx0J1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5pdGVyYXRpb25zJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlOiAnbWFjSXRlcmF0aW9ucydcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHNhZmVCYWdWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTYWZlQmFnJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdJZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdiYWdJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdTYWZlQmFnLmJhZ1ZhbHVlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnYmFnVmFsdWUnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnYmFnQXR0cmlidXRlcydcbiAgfV1cbn07XG5cbnZhciBhdHRyaWJ1dGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdBdHRyaWJ1dGUnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0cklkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ29pZCdcbiAgfSwge1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0clZhbHVlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZTogJ3ZhbHVlcydcbiAgfV1cbn07XG5cbnZhciBjZXJ0QmFnVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydEJhZycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NlcnRCYWcuY2VydElkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NlcnRJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdDZXJ0QmFnLmNlcnRWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAvKiBTbyBmYXIgd2Ugb25seSBzdXBwb3J0IFguNTA5IGNlcnRpZmljYXRlcyAod2hpY2ggYXJlIHdyYXBwZWQgaW5cbiAgICAgICBhbiBPQ1RFVCBTVFJJTkcsIGhlbmNlIGhhcmQgY29kZSB0aGF0IGhlcmUpLiAqL1xuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRCYWcuY2VydFZhbHVlWzBdJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnY2VydCdcbiAgICB9XVxuICB9XVxufTtcblxuLyoqXG4gKiBTZWFyY2ggU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSBmb3IgYmFncyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhlIHNlYXJjaCBjYW4gb3B0aW9uYWxseSBiZSBuYXJyb3dlZCBieSBhIGNlcnRhaW4gYmFnIHR5cGUuXG4gKlxuICogQHBhcmFtIHNhZmVDb250ZW50cyB0aGUgU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0gYXR0ck5hbWUgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gKiBAcGFyYW0gYXR0clZhbHVlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAqXG4gKiBAcmV0dXJuIGFuIGFycmF5IG9mIG1hdGNoaW5nIGJhZ3MuXG4gKi9cbmZ1bmN0aW9uIF9nZXRCYWdzQnlBdHRyaWJ1dGUoc2FmZUNvbnRlbnRzLCBhdHRyTmFtZSwgYXR0clZhbHVlLCBiYWdUeXBlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgc2FmZUNvbnRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHNhZmVDb250ZW50c1tpXS5zYWZlQmFncy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGJhZyA9IHNhZmVDb250ZW50c1tpXS5zYWZlQmFnc1tqXTtcbiAgICAgIGlmKGJhZ1R5cGUgIT09IHVuZGVmaW5lZCAmJiBiYWcudHlwZSAhPT0gYmFnVHlwZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgZmlsdGVyIGJ5IGJhZyB0eXBlLCBubyBhdHRyaWJ1dGUgc3BlY2lmaWVkXG4gICAgICBpZihhdHRyTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXS5pbmRleE9mKGF0dHJWYWx1ZSkgPj0gMCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbiBpbnRvIGEgUEZYIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbi5cbiAqIEBwYXJhbSBzdHJpY3QgdHJ1ZSB0byB1c2Ugc3RyaWN0IERFUiBkZWNvZGluZywgZmFsc2Ugbm90IHRvIChkZWZhdWx0OiB0cnVlKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIFBLQ1MjMTIgUEZYIG9iamVjdC5cbiAqL1xucDEyLnBrY3MxMkZyb21Bc24xID0gZnVuY3Rpb24ob2JqLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGhhbmRsZSBhcmdzXG4gIGlmKHR5cGVvZiBzdHJpY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBzdHJpY3Q7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmKHN0cmljdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIFBGWCBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBwZnhWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFBLQ1MjMTIgUEZYLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjMTIgUEZYLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9yO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHBmeCA9IHtcbiAgICB2ZXJzaW9uOiBjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSxcbiAgICBzYWZlQ29udGVudHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBiYWdzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgdGhlIGF0dHJpYnV0ZXMgdG8gZmlsdGVyIGJ5OlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkXSB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkSGV4XSB0aGUgbG9jYWxLZXlJZCBpbiBoZXggdG8gc2VhcmNoIGZvci5cbiAgICAgKiAgICAgICAgICBbZnJpZW5kbHlOYW1lXSB0aGUgZnJpZW5kbHkgbmFtZSB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtiYWdUeXBlXSBiYWcgdHlwZSB0byBuYXJyb3cgZWFjaCBhdHRyaWJ1dGUgc2VhcmNoIGJ5LlxuICAgICAqXG4gICAgICogQHJldHVybiBhIG1hcCBvZiBhdHRyaWJ1dGUgdHlwZSB0byBhbiBhcnJheSBvZiBtYXRjaGluZyBiYWdzIG9yLCBpZiBub1xuICAgICAqICAgICAgICAgICBhdHRyaWJ1dGUgd2FzIGdpdmVuIGJ1dCBhIGJhZyB0eXBlLCB0aGUgbWFwIGtleSB3aWxsIGJlIHRoZVxuICAgICAqICAgICAgICAgICBiYWcgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRCYWdzOiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgIHZhciBydmFsID0ge307XG5cbiAgICAgIHZhciBsb2NhbEtleUlkO1xuICAgICAgaWYoJ2xvY2FsS2V5SWQnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZmlsdGVyLmxvY2FsS2V5SWQ7XG4gICAgICB9IGVsc2UgaWYoJ2xvY2FsS2V5SWRIZXgnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGZpbHRlci5sb2NhbEtleUlkSGV4KTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIG9uIGJhZ1R5cGUgb25seVxuICAgICAgaWYobG9jYWxLZXlJZCA9PT0gdW5kZWZpbmVkICYmICEoJ2ZyaWVuZGx5TmFtZScgaW4gZmlsdGVyKSAmJlxuICAgICAgICAnYmFnVHlwZScgaW4gZmlsdGVyKSB7XG4gICAgICAgIHJ2YWxbZmlsdGVyLmJhZ1R5cGVdID0gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCBudWxsLCBudWxsLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGxvY2FsS2V5SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBydmFsLmxvY2FsS2V5SWQgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdsb2NhbEtleUlkJyxcbiAgICAgICAgICBsb2NhbEtleUlkLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG4gICAgICBpZignZnJpZW5kbHlOYW1lJyBpbiBmaWx0ZXIpIHtcbiAgICAgICAgcnZhbC5mcmllbmRseU5hbWUgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdmcmllbmRseU5hbWUnLFxuICAgICAgICAgIGZpbHRlci5mcmllbmRseU5hbWUsIGZpbHRlci5iYWdUeXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgZnJpZW5kbHlOYW1lIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcmllbmRseU5hbWUgdGhlIGZyaWVuZGx5IG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gW2JhZ1R5cGVdIGJhZyB0eXBlIHRvIG5hcnJvdyBzZWFyY2ggYnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGJhZ3Mgd2l0aCBtYXRjaGluZyBmcmllbmRseU5hbWUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUZyaWVuZGx5TmFtZTogZnVuY3Rpb24oZnJpZW5kbHlOYW1lLCBiYWdUeXBlKSB7XG4gICAgICByZXR1cm4gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgcGZ4LnNhZmVDb250ZW50cywgJ2ZyaWVuZGx5TmFtZScsIGZyaWVuZGx5TmFtZSwgYmFnVHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgbG9jYWxLZXlJZCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxLZXlJZCB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYmFncyB3aXRoIG1hdGNoaW5nIGxvY2FsS2V5SWQgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUxvY2FsS2V5SWQ6IGZ1bmN0aW9uKGxvY2FsS2V5SWQsIGJhZ1R5cGUpIHtcbiAgICAgIHJldHVybiBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCAnbG9jYWxLZXlJZCcsIGxvY2FsS2V5SWQsIGJhZ1R5cGUpO1xuICAgIH1cbiAgfTtcblxuICBpZihjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSAhPT0gMykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignUEtDUyMxMiBQRlggb2YgdmVyc2lvbiBvdGhlciB0aGFuIDMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci52ZXJzaW9uID0gY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpICE9PSBwa2kub2lkcy5kYXRhKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdPbmx5IFBLQ1MjMTIgUEZYIGluIHBhc3N3b3JkIGludGVncml0eSBtb2RlIHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci5vaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gIGlmKGRhdGEudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGRhdGEudHlwZSAhPT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIGF1dGhTYWZlIGNvbnRlbnQgZGF0YSBpcyBub3QgYW4gT0NURVQgU1RSSU5HLicpO1xuICB9XG4gIGRhdGEgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpO1xuXG4gIC8vIGNoZWNrIGZvciBNQUNcbiAgaWYoY2FwdHVyZS5tYWMpIHtcbiAgICB2YXIgbWQgPSBudWxsO1xuICAgIHZhciBtYWNLZXlCeXRlcyA9IDA7XG4gICAgdmFyIG1hY0FsZ29yaXRobSA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5tYWNBbGdvcml0aG0pO1xuICAgIHN3aXRjaChtYWNBbGdvcml0aG0pIHtcbiAgICBjYXNlIHBraS5vaWRzLnNoYTE6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDIwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5zaGEyNTY6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHBraS5vaWRzLnNoYTM4NDpcbiAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgbWFjS2V5Qnl0ZXMgPSA0ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcGtpLm9pZHMuc2hhNTEyOlxuICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5tZDU6XG4gICAgICBtZCA9IGZvcmdlLm1kLm1kNS5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMTY7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiB1c2VzIHVuc3VwcG9ydGVkIE1BQyBhbGdvcml0aG06ICcgKyBtYWNBbGdvcml0aG0pO1xuICAgIH1cblxuICAgIC8vIHZlcmlmeSBNQUMgKGl0ZXJhdGlvbnMgZGVmYXVsdCB0byAxKVxuICAgIHZhciBtYWNTYWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihjYXB0dXJlLm1hY1NhbHQpO1xuICAgIHZhciBtYWNJdGVyYXRpb25zID0gKCgnbWFjSXRlcmF0aW9ucycgaW4gY2FwdHVyZSkgP1xuICAgICAgcGFyc2VJbnQoZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGNhcHR1cmUubWFjSXRlcmF0aW9ucyksIDE2KSA6IDEpO1xuICAgIHZhciBtYWNLZXkgPSBwMTIuZ2VuZXJhdGVLZXkoXG4gICAgICBwYXNzd29yZCwgbWFjU2FsdCwgMywgbWFjSXRlcmF0aW9ucywgbWFjS2V5Qnl0ZXMsIG1kKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQobWQsIG1hY0tleSk7XG4gICAgbWFjLnVwZGF0ZShkYXRhLnZhbHVlKTtcbiAgICB2YXIgbWFjVmFsdWUgPSBtYWMuZ2V0TWFjKCk7XG4gICAgaWYobWFjVmFsdWUuZ2V0Qnl0ZXMoKSAhPT0gY2FwdHVyZS5tYWNEaWdlc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBNQUMgY291bGQgbm90IGJlIHZlcmlmaWVkLiBJbnZhbGlkIHBhc3N3b3JkPycpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWNvZGVBdXRoZW50aWNhdGVkU2FmZShwZngsIGRhdGEudmFsdWUsIHN0cmljdCwgcGFzc3dvcmQpO1xuICByZXR1cm4gcGZ4O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIFBLQ1MjNyBEYXRhLiBQS0NTIzcgKFJGQyAyMzE1KSBkZWZpbmVzIFwiRGF0YVwiIGFzIGFuIE9DVEVUIFNUUklORyxcbiAqIGJ1dCBpdCBpcyBzb21ldGltZXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaXMgY29tcG9zZWQvY29uc3RydWN0ZWQgb2YgY2h1bmtzLFxuICogZWFjaCBpdHMgb3duIE9DVEVUIFNUUklORy4gVGhpcyBpcyBCRVItZW5jb2RpbmcgdnMuIERFUi1lbmNvZGluZy4gVGhpc1xuICogZnVuY3Rpb24gdHJhbnNmb3JtcyB0aGlzIGNvcm5lci1jYXNlIGludG8gdGhlIHVzdWFsIHNpbXBsZSxcbiAqIG5vbi1jb21wb3NlZC9jb25zdHJ1Y3RlZCBPQ1RFVCBTVFJJTkcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXkgYmUgbW92ZWQgdG8gQVNOLjEgYXQgc29tZSBwb2ludCB0byBiZXR0ZXIgZGVhbCB3aXRoXG4gKiBtb3JlIEJFUi1lbmNvZGluZyBpc3N1ZXMsIHNob3VsZCB0aGV5IGFyaXNlLlxuICpcbiAqIEBwYXJhbSBkYXRhIHRoZSBBU04uMSBEYXRhIG9iamVjdCB0byB0cmFuc2Zvcm0uXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVQa2NzN0RhdGEoZGF0YSkge1xuICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIFwiY2h1bmtlZFwiIGRhdGEgY29udGVudDogYW4gb2N0ZXQgc3RyaW5nIGNvbXBvc2VkXG4gIC8vIG9mIG90aGVyIG9jdGV0IHN0cmluZ3NcbiAgaWYoZGF0YS5jb21wb3NlZCB8fCBkYXRhLmNvbnN0cnVjdGVkKSB7XG4gICAgdmFyIHZhbHVlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsdWUucHV0Qnl0ZXMoZGF0YS52YWx1ZVtpXS52YWx1ZSk7XG4gICAgfVxuICAgIGRhdGEuY29tcG9zZWQgPSBkYXRhLmNvbnN0cnVjdGVkID0gZmFsc2U7XG4gICAgZGF0YS52YWx1ZSA9IHZhbHVlLmdldEJ5dGVzKCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlIFBLQ1MjMTIgQXV0aGVudGljYXRlZFNhZmUgKEJFUiBlbmNvZGVkKSBpbnRvIFBGWCBvYmplY3QuXG4gKlxuICogVGhlIEF1dGhlbnRpY2F0ZWRTYWZlIGlzIGEgQkVSLWVuY29kZWQgU0VRVUVOQ0UgT0YgQ29udGVudEluZm8uXG4gKlxuICogQHBhcmFtIHBmeCBUaGUgUEtDUyMxMiBQRlggb2JqZWN0IHRvIGZpbGwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYXV0aFNhZmUgQkVSLWVuY29kZWQgQXV0aGVudGljYXRlZFNhZmUuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUF1dGhlbnRpY2F0ZWRTYWZlKHBmeCwgYXV0aFNhZmUsIHN0cmljdCwgcGFzc3dvcmQpIHtcbiAgYXV0aFNhZmUgPSBhc24xLmZyb21EZXIoYXV0aFNhZmUsIHN0cmljdCk7ICAvKiBhY3R1YWxseSBpdCdzIEJFUiBlbmNvZGVkICovXG5cbiAgaWYoYXV0aFNhZmUudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGF1dGhTYWZlLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgICBhdXRoU2FmZS5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBBdXRoZW50aWNhdGVkU2FmZSBleHBlY3RlZCB0byBiZSBhICcgK1xuICAgICAgJ1NFUVVFTkNFIE9GIENvbnRlbnRJbmZvJyk7XG4gIH1cblxuICBmb3IodmFyIGkgPSAwOyBpIDwgYXV0aFNhZmUudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGVudEluZm8gPSBhdXRoU2FmZS52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIGNvbnRlbnRJbmZvIGFuZCBjYXB0dXJlIGRhdGFcbiAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZighYXNuMS52YWxpZGF0ZShjb250ZW50SW5mbywgY29udGVudEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgQ29udGVudEluZm8uJyk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge1xuICAgICAgZW5jcnlwdGVkOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIHNhZmVDb250ZW50cyA9IG51bGw7XG4gICAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gICAgc3dpdGNoKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jb250ZW50VHlwZSkpIHtcbiAgICBjYXNlIHBraS5vaWRzLmRhdGE6XG4gICAgICBpZihkYXRhLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fFxuICAgICAgICAgZGF0YS50eXBlICE9PSBhc24xLlR5cGUuT0NURVRTVFJJTkcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIFNhZmVDb250ZW50cyBEYXRhIGlzIG5vdCBhbiBPQ1RFVCBTVFJJTkcuJyk7XG4gICAgICB9XG4gICAgICBzYWZlQ29udGVudHMgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5lbmNyeXB0ZWREYXRhOlxuICAgICAgc2FmZUNvbnRlbnRzID0gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpO1xuICAgICAgb2JqLmVuY3J5cHRlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQS0NTIzEyIGNvbnRlbnRUeXBlLicpO1xuICAgICAgZXJyb3IuY29udGVudFR5cGUgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgb2JqLnNhZmVCYWdzID0gX2RlY29kZVNhZmVDb250ZW50cyhzYWZlQ29udGVudHMsIHN0cmljdCwgcGFzc3dvcmQpO1xuICAgIHBmeC5zYWZlQ29udGVudHMucHVzaChvYmopO1xuICB9XG59XG5cbi8qKlxuICogRGVjcnlwdCBQS0NTIzcgRW5jcnlwdGVkRGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIGRhdGEgQVNOLjEgZW5jb2RlZCBFbmNyeXB0ZWRDb250ZW50SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHVzZXItcHJvdmlkZWQgcGFzc3dvcmQuXG4gKlxuICogQHJldHVybiBUaGUgZGVjcnlwdGVkIFNhZmVDb250ZW50cyAoQVNOLjEgb2JqZWN0KS5cbiAqL1xuZnVuY3Rpb24gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShcbiAgICBkYXRhLCBmb3JnZS5wa2NzNy5hc24xLmVuY3J5cHRlZERhdGFWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIEVuY3J5cHRlZENvbnRlbnRJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLmRhdGEpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAnUEtDUyMxMiBFbmNyeXB0ZWRDb250ZW50SW5mbyBDb250ZW50VHlwZSBpcyBub3QgRGF0YS4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgY2lwaGVyXG4gIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNBbGdvcml0aG0pO1xuICB2YXIgY2lwaGVyID0gcGtpLnBiZS5nZXRDaXBoZXIob2lkLCBjYXB0dXJlLmVuY1BhcmFtZXRlciwgcGFzc3dvcmQpO1xuXG4gIC8vIGdldCBlbmNyeXB0ZWQgZGF0YVxuICB2YXIgZW5jcnlwdGVkQ29udGVudEFzbjEgPSBfZGVjb2RlUGtjczdEYXRhKGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudEFzbjEpO1xuICB2YXIgZW5jcnlwdGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZW5jcnlwdGVkQ29udGVudEFzbjEudmFsdWUpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoIWNpcGhlci5maW5pc2goKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgUEtDUyMxMiBTYWZlQ29udGVudHMuJyk7XG4gIH1cblxuICByZXR1cm4gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNhZmVDb250ZW50cyAoQkVSLWVuY29kZWQpIGludG8gYXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKlxuICogVGhlIHNhZmVDb250ZW50cyBpcyBhIEJFUi1lbmNvZGVkIFNFUVVFTkNFIE9GIFNhZmVCYWcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNhZmVDb250ZW50cyBCRVItZW5jb2RlZCBzYWZlQ29udGVudHMuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVTYWZlQ29udGVudHMoc2FmZUNvbnRlbnRzLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGlmIHN0cmljdCBhbmQgbm8gc2FmZSBjb250ZW50cywgcmV0dXJuIGVtcHR5IHNhZmVzXG4gIGlmKCFzdHJpY3QgJiYgc2FmZUNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIGFjdHVhbGx5IGl0J3MgQkVSLWVuY29kZWRcbiAgc2FmZUNvbnRlbnRzID0gYXNuMS5mcm9tRGVyKHNhZmVDb250ZW50cywgc3RyaWN0KTtcblxuICBpZihzYWZlQ29udGVudHMudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgc2FmZUNvbnRlbnRzLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgIHNhZmVDb250ZW50cy5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdQS0NTIzEyIFNhZmVDb250ZW50cyBleHBlY3RlZCB0byBiZSBhIFNFUVVFTkNFIE9GIFNhZmVCYWcuJyk7XG4gIH1cblxuICB2YXIgcmVzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzYWZlQ29udGVudHMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2FmZUJhZyA9IHNhZmVDb250ZW50cy52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIFNhZmVCYWcgYW5kIGNhcHR1cmUgZGF0YVxuICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGlmKCFhc24xLnZhbGlkYXRlKHNhZmVCYWcsIHNhZmVCYWdWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgU2FmZUJhZy4nKTtcbiAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8qIENyZWF0ZSBiYWcgb2JqZWN0IGFuZCBwdXNoIHRvIHJlc3VsdCBhcnJheS4gKi9cbiAgICB2YXIgYmFnID0ge1xuICAgICAgdHlwZTogYXNuMS5kZXJUb09pZChjYXB0dXJlLmJhZ0lkKSxcbiAgICAgIGF0dHJpYnV0ZXM6IF9kZWNvZGVCYWdBdHRyaWJ1dGVzKGNhcHR1cmUuYmFnQXR0cmlidXRlcylcbiAgICB9O1xuICAgIHJlcy5wdXNoKGJhZyk7XG5cbiAgICB2YXIgdmFsaWRhdG9yLCBkZWNvZGVyO1xuICAgIHZhciBiYWdBc24xID0gY2FwdHVyZS5iYWdWYWx1ZS52YWx1ZVswXTtcbiAgICBzd2l0Y2goYmFnLnR5cGUpIHtcbiAgICAgIGNhc2UgcGtpLm9pZHMucGtjczhTaHJvdWRlZEtleUJhZzpcbiAgICAgICAgLyogYmFnQXNuMSBoYXMgYSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbywgd2hpY2ggd2UgbmVlZCB0byBkZWNyeXB0LlxuICAgICAgICAgICBBZnRlcndhcmRzIHdlIGNhbiBoYW5kbGUgaXQgbGlrZSBhIGtleUJhZyxcbiAgICAgICAgICAgd2hpY2ggaXMgYSBQcml2YXRlS2V5SW5mby4gKi9cbiAgICAgICAgYmFnQXNuMSA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYmFnQXNuMSwgcGFzc3dvcmQpO1xuICAgICAgICBpZihiYWdBc24xID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1VuYWJsZSB0byBkZWNyeXB0IFBLQ1MjOCBTaHJvdWRlZEtleUJhZywgd3JvbmcgcGFzc3dvcmQ/Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgcGtpLm9pZHMua2V5QmFnOlxuICAgICAgICAvKiBBIFBLQ1MjMTIga2V5QmFnIGlzIGEgc2ltcGxlIFByaXZhdGVLZXlJbmZvIGFzIHVuZGVyc3Rvb2QgYnkgb3VyXG4gICAgICAgICAgIFBLSSBtb2R1bGUsIGhlbmNlIHdlIGRvbid0IGhhdmUgdG8gZG8gdmFsaWRhdGlvbi9jYXB0dXJpbmcgaGVyZSxcbiAgICAgICAgICAganVzdCBwYXNzIHdoYXQgd2UgYWxyZWFkeSBnb3QuICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYmFnLmtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoYmFnQXNuMSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSB1bmtub3duIGtleSB0eXBlLCBwYXNzIGFzbjEgdmFsdWVcbiAgICAgICAgICBiYWcua2V5ID0gbnVsbDtcbiAgICAgICAgICBiYWcuYXNuMSA9IGJhZ0FzbjE7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7ICAvKiBOb3RoaW5nIG1vcmUgdG8gZG8uICovXG5cbiAgICAgIGNhc2UgcGtpLm9pZHMuY2VydEJhZzpcbiAgICAgICAgLyogQSBQS0NTIzEyIGNlcnRCYWcgY2FuIHdyYXAgYm90aCBYLjUwOSBhbmQgc2RzaSBjZXJ0aWZpY2F0ZXMuXG4gICAgICAgICAgIFRoZXJlZm9yZSBwdXQgdGhlIFNhZmVCYWcgY29udGVudCB0aHJvdWdoIGFub3RoZXIgdmFsaWRhdG9yIHRvXG4gICAgICAgICAgIGNhcHR1cmUgdGhlIGZpZWxkcy4gIEFmdGVyd2FyZHMgY2hlY2sgJiBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICAgICAgdmFsaWRhdG9yID0gY2VydEJhZ1ZhbGlkYXRvcjtcbiAgICAgICAgZGVjb2RlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0SWQpICE9PSBwa2kub2lkcy54NTA5Q2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1Vuc3VwcG9ydGVkIGNlcnRpZmljYXRlIHR5cGUsIG9ubHkgWC41MDkgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRJZCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0cnVlPXByb2R1Y2UgY2VydCBoYXNoXG4gICAgICAgICAgdmFyIGNlcnRBc24xID0gYXNuMS5mcm9tRGVyKGNhcHR1cmUuY2VydCwgc3RyaWN0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmFnLmNlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tQXNuMShjZXJ0QXNuMSwgdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBjZXJ0IHR5cGUsIHBhc3MgYXNuMSB2YWx1ZVxuICAgICAgICAgICAgYmFnLmNlcnQgPSBudWxsO1xuICAgICAgICAgICAgYmFnLmFzbjEgPSBjZXJ0QXNuMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBLQ1MjMTIgU2FmZUJhZyB0eXBlLicpO1xuICAgICAgICBlcnJvci5vaWQgPSBiYWcudHlwZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLyogVmFsaWRhdGUgU2FmZUJhZyB2YWx1ZSAoaS5lLiBDZXJ0QmFnLCBldGMuKSBhbmQgY2FwdHVyZSBkYXRhIGlmIG5lZWRlZC4gKi9cbiAgICBpZih2YWxpZGF0b3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICFhc24xLnZhbGlkYXRlKGJhZ0FzbjEsIHZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyICcgKyB2YWxpZGF0b3IubmFtZSk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvKiBDYWxsIGRlY29kZXIgZnVuY3Rpb24gZnJvbSBhYm92ZSB0byBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICBkZWNvZGVyKCk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNFVCBPRiBQS0NTMTJBdHRyaWJ1dGUgaW50byBKYXZhU2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIChBU04uMSBvYmplY3QpLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUJhZ0F0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICB2YXIgZGVjb2RlZEF0dHJzID0ge307XG5cbiAgaWYoYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZighYXNuMS52YWxpZGF0ZShhdHRyaWJ1dGVzW2ldLCBhdHRyaWJ1dGVWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyIEJhZ0F0dHJpYnV0ZS4nKTtcbiAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5vaWQpO1xuICAgICAgaWYocGtpLm9pZHNbb2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlLCBpZ25vcmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0gPSBbXTtcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBjYXB0dXJlLnZhbHVlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0ucHVzaChjYXB0dXJlLnZhbHVlc1tqXS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZWRBdHRycztcbn1cblxuLyoqXG4gKiBXcmFwcyBhIHByaXZhdGUga2V5IGFuZCBjZXJ0aWZpY2F0ZSBpbiBhIFBLQ1MjMTIgUEZYIHdyYXBwZXIuIElmIGFcbiAqIHBhc3N3b3JkIGlzIHByb3ZpZGVkIHRoZW4gdGhlIHByaXZhdGUga2V5IHdpbGwgYmUgZW5jcnlwdGVkLlxuICpcbiAqIEFuIGVudGlyZSBjZXJ0aWZpY2F0ZSBjaGFpbiBtYXkgYWxzbyBiZSBpbmNsdWRlZC4gVG8gZG8gdGhpcywgcGFzc1xuICogYW4gYXJyYXkgZm9yIHRoZSBcImNlcnRcIiBwYXJhbWV0ZXIgd2hlcmUgdGhlIGZpcnN0IGNlcnRpZmljYXRlIGlzXG4gKiB0aGUgb25lIHRoYXQgaXMgcGFpcmVkIHdpdGggdGhlIHByaXZhdGUga2V5IGFuZCBlYWNoIHN1YnNlcXVlbnQgb25lXG4gKiB2ZXJpZmllcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgY2VydGlmaWNhdGVzIG1heSBiZSBpbiBQRU0gZm9ybWF0IG9yXG4gKiBoYXZlIGJlZW4gYWxyZWFkeSBwYXJzZWQgYnkgRm9yZ2UuXG4gKlxuICogQHRvZG8gaW1wbGVtZW50IHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gZm9yIHRoZSB3aG9sZSBwYWNrYWdlXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgKG1heSBiZSBhbiBhcnJheSBvZiBjZXJ0aWZpY2F0ZXMgaW4gb3JkZXJcbiAqICAgICAgICAgIHRvIHNwZWNpZnkgYSBjZXJ0aWZpY2F0ZSBjaGFpbikuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdhZXMxMjgnLCAnYWVzMTkyJywgJ2FlczI1NicsICczZGVzJyksIGRlZmF1bHRzIHRvICdhZXMxMjgnLlxuICogICAgICAgICAgY291bnQgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZSB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIHVzZU1hYyB0cnVlIHRvIGluY2x1ZGUgYSBNQUMsIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqICAgICAgICAgIGxvY2FsS2V5SWQgdGhlIGxvY2FsIGtleSBJRCB0byB1c2UsIGluIGhleC5cbiAqICAgICAgICAgIGZyaWVuZGx5TmFtZSB0aGUgZnJpZW5kbHkgbmFtZSB0byB1c2UuXG4gKiAgICAgICAgICBnZW5lcmF0ZUxvY2FsS2V5SWQgdHJ1ZSB0byBnZW5lcmF0ZSBhIHJhbmRvbSBsb2NhbCBrZXkgSUQsXG4gKiAgICAgICAgICAgIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQS0NTIzEyIFBGWCBBU04uMSBvYmplY3QuXG4gKi9cbnAxMi50b1BrY3MxMkFzbjEgPSBmdW5jdGlvbihrZXksIGNlcnQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc2FsdFNpemUgPSBvcHRpb25zLnNhbHRTaXplIHx8IDg7XG4gIG9wdGlvbnMuY291bnQgPSBvcHRpb25zLmNvdW50IHx8IDIwNDg7XG4gIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgb3B0aW9ucy5lbmNBbGdvcml0aG0gfHwgJ2FlczEyOCc7XG4gIGlmKCEoJ3VzZU1hYycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnVzZU1hYyA9IHRydWU7XG4gIH1cbiAgaWYoISgnbG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmxvY2FsS2V5SWQgPSBudWxsO1xuICB9XG4gIGlmKCEoJ2dlbmVyYXRlTG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmdlbmVyYXRlTG9jYWxLZXlJZCA9IHRydWU7XG4gIH1cblxuICB2YXIgbG9jYWxLZXlJZCA9IG9wdGlvbnMubG9jYWxLZXlJZDtcbiAgdmFyIGJhZ0F0dHJzO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgbG9jYWxLZXlJZCA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhsb2NhbEtleUlkKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZ2VuZXJhdGVMb2NhbEtleUlkKSB7XG4gICAgLy8gdXNlIFNIQS0xIG9mIHBhaXJlZCBjZXJ0LCBpZiBhdmFpbGFibGVcbiAgICBpZihjZXJ0KSB7XG4gICAgICB2YXIgcGFpcmVkQ2VydCA9IGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSA/IGNlcnRbMF0gOiBjZXJ0O1xuICAgICAgaWYodHlwZW9mIHBhaXJlZENlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhaXJlZENlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tUGVtKHBhaXJlZENlcnQpO1xuICAgICAgfVxuICAgICAgdmFyIHNoYTEgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgc2hhMS51cGRhdGUoYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEocGFpcmVkQ2VydCkpLmdldEJ5dGVzKCkpO1xuICAgICAgbG9jYWxLZXlJZCA9IHNoYTEuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IGNvbnNpZGVyIHVzaW5nIFNIQS0xIG9mIHB1YmxpYyBrZXkgKHdoaWNoIGNhbiBiZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGZyb20gcHJpdmF0ZSBrZXkgY29tcG9uZW50cyksIHNlZTogY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyXG4gICAgICAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXNcbiAgICAgIGxvY2FsS2V5SWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoMjApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRycyA9IFtdO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgYXR0cnMucHVzaChcbiAgICAgIC8vIGxvY2FsS2V5SURcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYXR0cklkXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmxvY2FsS2V5SWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgICBsb2NhbEtleUlkKVxuICAgICAgICBdKVxuICAgICAgXSkpO1xuICB9XG4gIGlmKCdmcmllbmRseU5hbWUnIGluIG9wdGlvbnMpIHtcbiAgICBhdHRycy5wdXNoKFxuICAgICAgLy8gZnJpZW5kbHlOYW1lXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGF0dHJJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5mcmllbmRseU5hbWUpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CTVBTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9ucy5mcmllbmRseU5hbWUpXG4gICAgICAgIF0pXG4gICAgICBdKSk7XG4gIH1cblxuICBpZihhdHRycy5sZW5ndGggPiAwKSB7XG4gICAgYmFnQXR0cnMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgYXR0cnMpO1xuICB9XG5cbiAgLy8gY29sbGVjdCBjb250ZW50cyBmb3IgQXV0aGVudGljYXRlZFNhZmVcbiAgdmFyIGNvbnRlbnRzID0gW107XG5cbiAgLy8gY3JlYXRlIHNhZmUgYmFnKHMpIGZvciBjZXJ0aWZpY2F0ZSBjaGFpblxuICB2YXIgY2hhaW4gPSBbXTtcbiAgaWYoY2VydCAhPT0gbnVsbCkge1xuICAgIGlmKGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSkge1xuICAgICAgY2hhaW4gPSBjZXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFpbiA9IFtjZXJ0XTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2VydFNhZmVCYWdzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjaGFpbi5sZW5ndGg7ICsraSkge1xuICAgIC8vIGNvbnZlcnQgY2VydCBmcm9tIFBFTSBhcyBuZWNlc3NhcnlcbiAgICBjZXJ0ID0gY2hhaW5baV07XG4gICAgaWYodHlwZW9mIGNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjZXJ0ID0gcGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICB9XG5cbiAgICAvLyBTYWZlQmFnXG4gICAgdmFyIGNlcnRCYWdBdHRycyA9IChpID09PSAwKSA/IGJhZ0F0dHJzIDogdW5kZWZpbmVkO1xuICAgIHZhciBjZXJ0QXNuMSA9IHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KTtcbiAgICB2YXIgY2VydFNhZmVCYWcgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5jZXJ0QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gQ2VydEJhZ1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIC8vIGNlcnRJZFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLng1MDlDZXJ0aWZpY2F0ZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgICAvLyBjZXJ0VmFsdWUgKHg1MDlDZXJ0aWZpY2F0ZSlcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLnRvRGVyKGNlcnRBc24xKS5nZXRCeXRlcygpKVxuICAgICAgICAgICAgXSldKV0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgY2VydEJhZ0F0dHJzXG4gICAgICBdKTtcbiAgICBjZXJ0U2FmZUJhZ3MucHVzaChjZXJ0U2FmZUJhZyk7XG4gIH1cblxuICBpZihjZXJ0U2FmZUJhZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBjZXJ0U2FmZUNvbnRlbnRzID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBjZXJ0U2FmZUJhZ3MpO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIgY2VydENJID1cbiAgICAgIC8vIFBLQ1MjNyBDb250ZW50SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBjb250ZW50VHlwZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEudG9EZXIoY2VydFNhZmVDb250ZW50cykuZ2V0Qnl0ZXMoKSlcbiAgICAgICAgXSlcbiAgICAgIF0pO1xuICAgIGNvbnRlbnRzLnB1c2goY2VydENJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBzYWZlIGNvbnRlbnRzIGZvciBwcml2YXRlIGtleVxuICB2YXIga2V5QmFnID0gbnVsbDtcbiAgaWYoa2V5ICE9PSBudWxsKSB7XG4gICAgLy8gU2FmZUJhZ1xuICAgIHZhciBwa0FzbjEgPSBwa2kud3JhcFJzYVByaXZhdGVLZXkocGtpLnByaXZhdGVLZXlUb0FzbjEoa2V5KSk7XG4gICAgaWYocGFzc3dvcmQgPT09IG51bGwpIHtcbiAgICAgIC8vIG5vIGVuY3J5cHRpb25cbiAgICAgIGtleUJhZyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYmFnSWRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMua2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa0FzbjFcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGJhZ0F0dHJpYnV0ZXMgKE9QVElPTkFMKVxuICAgICAgICBiYWdBdHRyc1xuICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuY3J5cHRlZCBQcml2YXRlS2V5SW5mb1xuICAgICAga2V5QmFnID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5wa2NzOFNocm91ZGVkS2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa2kuZW5jcnlwdFByaXZhdGVLZXlJbmZvKHBrQXNuMSwgcGFzc3dvcmQsIG9wdGlvbnMpXG4gICAgICAgIF0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgYmFnQXR0cnNcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBrZXlTYWZlQ29udGVudHMgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW2tleUJhZ10pO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIga2V5Q0kgPVxuICAgICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGNvbnRlbnRUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAvLyBPSUQgZm9yIHRoZSBjb250ZW50IHR5cGUgaXMgJ2RhdGEnXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5kYXRhKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gY29udGVudFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS50b0RlcihrZXlTYWZlQ29udGVudHMpLmdldEJ5dGVzKCkpXG4gICAgICAgIF0pXG4gICAgICBdKTtcbiAgICBjb250ZW50cy5wdXNoKGtleUNJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBBdXRoZW50aWNhdGVkU2FmZSBieSBzdHJpbmdpbmcgdG9nZXRoZXIgdGhlIGNvbnRlbnRzXG4gIHZhciBzYWZlID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgY29udGVudHMpO1xuXG4gIHZhciBtYWNEYXRhO1xuICBpZihvcHRpb25zLnVzZU1hYykge1xuICAgIC8vIE1hY0RhdGFcbiAgICB2YXIgc2hhMSA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIG1hY1NhbHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKFxuICAgICAgZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG9wdGlvbnMuc2FsdFNpemUpKTtcbiAgICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgIC8vIDE2MC1iaXQga2V5XG4gICAgdmFyIGtleSA9IHAxMi5nZW5lcmF0ZUtleShwYXNzd29yZCwgbWFjU2FsdCwgMywgY291bnQsIDIwKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQoc2hhMSwga2V5KTtcbiAgICBtYWMudXBkYXRlKGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIG1hY1ZhbHVlID0gbWFjLmdldE1hYygpO1xuICAgIG1hY0RhdGEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBtYWMgRGlnZXN0SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBkaWdlc3RBbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIGFsZ29yaXRobSA9IFNIQS0xXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5zaGExKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAvLyBwYXJhbWV0ZXJzID0gTnVsbFxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgICBdKSxcbiAgICAgICAgLy8gZGlnZXN0XG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgICAgZmFsc2UsIG1hY1ZhbHVlLmdldEJ5dGVzKCkpXG4gICAgICBdKSxcbiAgICAgIC8vIG1hY1NhbHQgT0NURVQgU1RSSU5HXG4gICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIG1hY1NhbHQuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBpdGVyYXRpb25zIElOVEVHRVIgKFhYWDogT25seSBzdXBwb3J0IGNvdW50IDwgNjU1MzYpXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0Rlcihjb3VudCkuZ2V0Qnl0ZXMoKVxuICAgICAgKVxuICAgIF0pO1xuICB9XG5cbiAgLy8gUEZYXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMykuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gY29udGVudFR5cGVcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmRhdGEpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gY29udGVudFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgIGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSlcbiAgICAgIF0pXG4gICAgXSksXG4gICAgbWFjRGF0YVxuICBdKTtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucDEyLmdlbmVyYXRlS2V5ID0gZm9yZ2UucGJlLmdlbmVyYXRlUGtjczEyS2V5O1xuXG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFTTi4xIHZhbGlkYXRvcnMgZm9yIFBLQ1MjNyB2MS41LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgUEtDUyM3IGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDICMyMzE1IGZvciBkZXRhaWxzLCBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzE1LnR4dCk6XG4gKlxuICogQSBQS0NTIzcgbWVzc2FnZSBjb25zaXN0cyBvZiBhIENvbnRlbnRJbmZvIG9uIHJvb3QgbGV2ZWwsIHdoaWNoIG1heVxuICogY29udGFpbiBhbnkgbnVtYmVyIG9mIGZ1cnRoZXIgQ29udGVudEluZm8gbmVzdGVkIGludG8gaXQuXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgICAgICAgICAgICBbMF0gIEVYUExJQ0lUIEFOWSBERUZJTkVEIEJZIGNvbnRlbnRUeXBlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudFR5cGUgOjo9IE9CSkVDVCBJREVOVElGSUVSXG4gKlxuICogRW52ZWxvcGVkRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICByZWNpcGllbnRJbmZvcyAgICAgICAgICAgICBSZWNpcGllbnRJbmZvcyxcbiAqICAgZW5jcnlwdGVkQ29udGVudEluZm8gICAgICAgRW5jcnlwdGVkQ29udGVudEluZm9cbiAqIH1cbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGVuY3J5cHRlZENvbnRlbnRJbmZvICAgICAgIEVuY3J5cHRlZENvbnRlbnRJbmZvXG4gKiB9XG4gKlxuICogaWQtc2lnbmVkRGF0YSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0geyBpc28oMSkgbWVtYmVyLWJvZHkoMilcbiAqICAgdXMoODQwKSByc2Fkc2koMTEzNTQ5KSBwa2NzKDEpIHBrY3M3KDcpIDIgfVxuICpcbiAqIFNpZ25lZERhdGEgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgSU5URUdFUixcbiAqICAgZGlnZXN0QWxnb3JpdGhtcyAgRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMsXG4gKiAgIGNvbnRlbnRJbmZvICAgICAgIENvbnRlbnRJbmZvLFxuICogICBjZXJ0aWZpY2F0ZXMgICAgICBbMF0gSU1QTElDSVQgQ2VydGlmaWNhdGVzIE9QVElPTkFMLFxuICogICBjcmxzICAgICAgICAgICAgICBbMV0gSU1QTElDSVQgQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMgT1BUSU9OQUwsXG4gKiAgIHNpZ25lckluZm9zICAgICAgIFNpZ25lckluZm9zXG4gKiB9XG4gKlxuICogU2lnbmVySW5mb3MgOjo9IFNFVCBPRiBTaWduZXJJbmZvXG4gKlxuICogU2lnbmVySW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICBpc3N1ZXJBbmRTZXJpYWxOdW1iZXIgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGRpZ2VzdEFsZ29yaXRobSAgICAgICAgICAgIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICAgIFswXSBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMLFxuICogICBkaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtICBEaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGlnZXN0ICAgICAgICAgICAgRW5jcnlwdGVkRGlnZXN0LFxuICogICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICBbMV0gSU1QTElDSVQgQXR0cmlidXRlcyBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEF0dHJpYnV0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICBhdHRyVHlwZSAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgYXR0clZhbHVlcyAgU0VUIE9GIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqXG4gKiBSZWNpcGllbnRJbmZvcyA6Oj0gU0VUIE9GIFJlY2lwaWVudEluZm9cbiAqXG4gKiBFbmNyeXB0ZWRDb250ZW50SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjb250ZW50VHlwZSAgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtICBDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGVuY3J5cHRlZENvbnRlbnQgICAgICAgWzBdICBJTVBMSUNJVCBFbmNyeXB0ZWRDb250ZW50IE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIEFFUyBhbmQgREVTMywgdGhlcmUgaXMgb25seSBvbmUsXG4gKiB0aGUgSVYuXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZENvbnRlbnQgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIFJlY2lwaWVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGlzc3VlckFuZFNlcmlhbE51bWJlciAgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGtleUVuY3J5cHRpb25BbGdvcml0aG0gICAgICBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkS2V5ICAgICAgICAgICAgICAgIEVuY3J5cHRlZEtleVxuICogfVxuICpcbiAqIElzc3VlckFuZFNlcmlhbE51bWJlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBpc3N1ZXIgICAgICAgICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgICAgICAgIENlcnRpZmljYXRlU2VyaWFsTnVtYmVyXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZEtleSA6Oj0gT0NURVQgU1RSSU5HXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gc2hvcnRjdXQgZm9yIEFTTi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vLyBzaG9ydGN1dCBmb3IgUEtDUyM3IEFQSVxudmFyIHA3diA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtjczdhc24xID0gZm9yZ2UucGtjczdhc24xIHx8IHt9O1xuZm9yZ2UucGtjczcgPSBmb3JnZS5wa2NzNyB8fCB7fTtcbmZvcmdlLnBrY3M3LmFzbjEgPSBwN3Y7XG5cbnZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ29udGVudEluZm8uQ29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAwLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY29udGVudCdcbiAgfV1cbn07XG5wN3YuY29udGVudEluZm9WYWxpZGF0b3IgPSBjb250ZW50SW5mb1ZhbGlkYXRvcjtcblxudmFyIGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50VHlwZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdjb250ZW50VHlwZSdcbiAgfSwge1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNBbGdvcml0aG0nXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvLmNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtLnBhcmFtZXRlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICBjYXB0dXJlQXNuMTogJ2VuY1BhcmFtZXRlcidcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvLmVuY3J5cHRlZENvbnRlbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICAvKiBUaGUgUEtDUyM3IHN0cnVjdHVyZSBvdXRwdXQgYnkgT3BlblNTTCBzb21ld2hhdCBkaWZmZXJzIGZyb20gd2hhdFxuICAgICAqIG90aGVyIGltcGxlbWVudGF0aW9ucyBkbyBnZW5lcmF0ZS5cbiAgICAgKlxuICAgICAqIE9wZW5TU0wgZ2VuZXJhdGVzIGEgc3RydWN0dXJlIGxpa2UgdGhpczpcbiAgICAgKiBTRVFVRU5DRSB7XG4gICAgICogICAgLi4uXG4gICAgICogICAgWzBdXG4gICAgICogICAgICAgMjYgREEgNjcgRDIgMTcgOUMgNDUgM0MgQjEgMkEgQTggNTkgMkYgMjkgMzMgMzhcbiAgICAgKiAgICAgICBDMyBDMyBERiA4NiA3MSA3NCA3QSAxOSA5RiA0MCBEMCAyOSBCRSA4NSA5MCA0NVxuICAgICAqICAgICAgIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFdoZXJlYXMgb3RoZXIgaW1wbGVtZW50YXRpb25zIChhbmQgdGhpcyBQS0NTIzcgbW9kdWxlKSBnZW5lcmF0ZTpcbiAgICAgKiBTRVFVRU5DRSB7XG4gICAgICogICAgLi4uXG4gICAgICogICAgWzBdIHtcbiAgICAgKiAgICAgICBPQ1RFVCBTVFJJTkdcbiAgICAgKiAgICAgICAgICAyNiBEQSA2NyBEMiAxNyA5QyA0NSAzQyBCMSAyQSBBOCA1OSAyRiAyOSAzMyAzOFxuICAgICAqICAgICAgICAgIEMzIEMzIERGIDg2IDcxIDc0IDdBIDE5IDlGIDQwIEQwIDI5IEJFIDg1IDkwIDQ1XG4gICAgICogICAgICAgICAgLi4uXG4gICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIHN1cHBvcnQgYm90aCwgd2UganVzdCBjYXB0dXJlIHRoZSBjb250ZXh0IHNwZWNpZmljXG4gICAgICogZmllbGQgaGVyZS4gIFRoZSBPQ1RFVCBTVFJJTkcgYml0IGlzIHJlbW92ZWQgYmVsb3cuXG4gICAgICovXG4gICAgY2FwdHVyZTogJ2VuY3J5cHRlZENvbnRlbnQnLFxuICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGVkQ29udGVudEFzbjEnXG4gIH1dXG59O1xuXG5wN3YuZW52ZWxvcGVkRGF0YVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VudmVsb3BlZERhdGEnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdFbnZlbG9wZWREYXRhLlZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAnRW52ZWxvcGVkRGF0YS5SZWNpcGllbnRJbmZvcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdyZWNpcGllbnRJbmZvcydcbiAgfV0uY29uY2F0KGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yKVxufTtcblxucDd2LmVuY3J5cHRlZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbmNyeXB0ZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9XS5jb25jYXQoZW5jcnlwdGVkQ29udGVudEluZm9WYWxpZGF0b3IpXG59O1xuXG52YXIgc2lnbmVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnU2lnbmVySW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1NpZ25lckluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1NpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnaXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlci5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2VyaWFsJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZGlnZXN0QWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdkaWdlc3RQYXJhbWV0ZXInLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmU6ICdzaWduYXR1cmVBbGdvcml0aG0nXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5lbmNyeXB0ZWREaWdlc3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzaWduYXR1cmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby51bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ3VuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnXG4gIH1dXG59O1xuXG5wN3Yuc2lnbmVkRGF0YVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1NpZ25lZERhdGEnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTaWduZWREYXRhLlZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5EaWdlc3RBbGdvcml0aG1zJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2RpZ2VzdEFsZ29yaXRobXMnXG4gIH0sXG4gIGNvbnRlbnRJbmZvVmFsaWRhdG9yLFxuICB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuQ2VydGlmaWNhdGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0ZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5DZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0cycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY3JscydcbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZWREYXRhLlNpZ25lckluZm9zJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjYXB0dXJlOiAnc2lnbmVySW5mb3MnLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbc2lnbmVyVmFsaWRhdG9yXVxuICB9XVxufTtcblxucDd2LnJlY2lwaWVudEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdSZWNpcGllbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnaXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2VyaWFsJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5rZXlFbmNyeXB0aW9uQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNBbGdvcml0aG0nXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdlbmNQYXJhbWV0ZXInXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmVuY3J5cHRlZEtleScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2VuY0tleSdcbiAgfV1cbn07XG5cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIE5vZGUuanMgbW9kdWxlIGZvciBGb3JnZSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKlxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZiA9IGZvcmdlLm1nZiB8fCB7fTtcbmZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMTtcblxuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gTUdGMS5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZm9yZ2UubWdmID0gZm9yZ2UubWdmIHx8IHt9O1xudmFyIG1nZjEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMSA9IGZvcmdlLm1nZjEgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIE1HRjEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IEFQSSB0byB1c2UgKGVnOiBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpKS5cbiAqXG4gKiBAcmV0dXJuIGEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqL1xubWdmMS5jcmVhdGUgPSBmdW5jdGlvbihtZCkge1xuICB2YXIgbWdmID0ge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG1hc2sgb2Ygc3BlY2lmaWVkIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWVkIFRoZSBzZWVkIGZvciBtYXNrIGdlbmVyYXRpb24uXG4gICAgICogQHBhcmFtIG1hc2tMZW4gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCBtYXNrLlxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihzZWVkLCBtYXNrTGVuKSB7XG4gICAgICAvKiAyLiBMZXQgVCBiZSB0aGUgZW1wdHkgb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgdmFyIHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgICAgIC8qIDMuIEZvciBjb3VudGVyIGZyb20gMCB0byBjZWlsKG1hc2tMZW4gLyBoTGVuKSwgZG8gdGhlIGZvbGxvd2luZzogKi9cbiAgICAgIHZhciBsZW4gPSBNYXRoLmNlaWwobWFza0xlbiAvIG1kLmRpZ2VzdExlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLyogYS4gQ29udmVydCBjb3VudGVyIHRvIGFuIG9jdGV0IHN0cmluZyBDIG9mIGxlbmd0aCA0IG9jdGV0cyAqL1xuICAgICAgICB2YXIgYyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgICAgYy5wdXRJbnQzMihpKTtcblxuICAgICAgICAvKiBiLiBDb25jYXRlbmF0ZSB0aGUgaGFzaCBvZiB0aGUgc2VlZCBtZ2ZTZWVkIGFuZCBDIHRvIHRoZSBvY3RldFxuICAgICAgICAgKiBzdHJpbmcgVDogKi9cbiAgICAgICAgbWQuc3RhcnQoKTtcbiAgICAgICAgbWQudXBkYXRlKHNlZWQgKyBjLmdldEJ5dGVzKCkpO1xuICAgICAgICB0LnB1dEJ1ZmZlcihtZC5kaWdlc3QoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qIE91dHB1dCB0aGUgbGVhZGluZyBtYXNrTGVuIG9jdGV0cyBvZiBUIGFzIHRoZSBvY3RldCBzdHJpbmcgbWFzay4gKi9cbiAgICAgIHQudHJ1bmNhdGUodC5sZW5ndGgoKSAtIG1hc2tMZW4pO1xuICAgICAgcmV0dXJuIHQuZ2V0Qnl0ZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIG1nZjtcbn07XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9